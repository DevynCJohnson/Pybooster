#!/bin/sh
# -*- coding: utf-8-unix; Mode: Shell; indent-tabs-mode: nil; tab-width: 4 -*-
# vim: set fileencoding=utf-8 filetype=shell syn=sh.doxygen fileformat=unix tabstop=4 expandtab :
# kate: encoding utf-8; bom off; syntax shell; indent-mode normal; eol unix; replace-tabs on; indent-width 4; tab-width 4; remove-trailing-space on; line-numbers on;
#' @brief Wrapper for scanning a shell script with various syntax checkers
#' @file shanalysis
#' @version 2018.10.02
#' @author Devyn Collier Johnson <DevynCJohnson@Gmail.com>
#' @copyright Public Domain (CC0) - https://creativecommons.org/publicdomain/zero/1.0/


if [ -z "${1:-}" ]; then
    printf 'ERROR: A parameter is required!\n' >&2
    exit 1
elif [ "$1" = '--help' ] || [ "$1" = 'help' ] || [ "$1" = '-h' ]; then
    printf 'Specify the pathname of each shell script to scan.\n'
    exit 0
fi


# SETUP #


export LANG='en_US.UTF-8'
export LC_ALL='C'
export LC_CTYPE='C'
export FirstLoopPass=0

# Use a faster alternative if possible
if [ -x "$(command -v mawk)" ]; then
    awk_cmd() { mawk "${1}"; }
    noblanks() { mawk NF; }
elif [ -x "$(command -v nawk)" ]; then
    awk_cmd() { nawk "${1}"; }
    noblanks() { nawk NF; }
else
    awk_cmd() { awk "${1}"; }
    noblanks() { awk NF; }
fi


# MAIN #


for file in "${@:-}"; do
    ([ ! -r "$file" ] || [ -d "$file" ]) && printf '%s: The specified file is non-readable or non-existent!\n' "$file" >&2 && continue
    FILE_TYPE='UNKNOWN'
    echo "$file" | grep -E -e '.*(bashrc|profile|*shrc)' > /dev/null && FILE_TYPE='SHELL'
    head -1 "$file" | grep -E -e '#!/bin/(ash|bash|busybox|csh|dash|ksh|lksh|mksh|rbash|rzsh|sash|sh|tcsh|zsh).*' > /dev/null && FILE_TYPE='SHELL'
    head -1 "$file" | grep -E -e '#!/usr/bin/(awk|bwk|gawk|jawk|mawk|nawk).*' > /dev/null && FILE_TYPE='AWK'

    if [ "$FILE_TYPE" = 'SHELL' ]; then  # Check shell scripts

        if [ -x "$(command -v bashate)" ]; then
            printf '======  *BASHATE*  ======\n'
            bashate --ignore E006 --verbose "$file" | awk_cmd '{ OFS=""; gsub(/^Running bashate on .+$/, ""); if (NF > 0) { print; } }'
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'bashate: command not found!\n' >&2
        fi

        if [ -x "$(command -v shellcheck)" ]; then
            printf '======  *SHELLCHECK*  ======\n'
            shellcheck --color=auto --exclude=SC1090,SC1091 --external-sources --format=gcc "$file" | noblanks
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'shellcheck: command not found!\n' >&2
        fi

        if [ -x "$(command -v sh)" ]; then
            printf '======  *POSIX COMPLIANCE*  ======\n'
            sh -n "$file" | noblanks
        elif [ -x "$(command -v ash)" ]; then
            printf '======  *POSIX COMPLIANCE (ASH)*  ======\n'
            ash -n "$file" | noblanks
        elif [ -x "$(command -v dash)" ]; then
            printf '======  *POSIX COMPLIANCE (DASH)*  ======\n'
            dash -n "$file" | noblanks
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'sh: command not found!\n' >&2
        fi

        if [ -x "$(command -v checkbashisms)" ]; then
            printf '======  *BASHISMS*  ======\n'
            checkbashisms --extra "$file" 2>&1 | awk_cmd '{ gsub(/^could not find any possible bashisms in bash script.*$/, ""); if (NF > 0) { print; } }'
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'checkbashisms: command not found!\n' >&2
        fi

    elif [ "$FILE_TYPE" = 'AWK' ]; then  # Check AWK scripts

        if [ -x "$(command -v awk)" ]; then
            printf '======  *AWK CHECK*  ======\n'
            awk --lint --source 'BEGIN { exit(0) } END { exit(0) }' --file "$file" 2>&1 | noblanks
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'awk: command not found!\n' >&2
        fi

        if [ -x "$(command -v gawk)" ]; then
            printf '======  *GAWK CHECK*  ======\n'
            gawk --lint --source 'BEGIN { exit(0) } END { exit(0) }' --file "$file" 2>&1 | noblanks
        elif [ "$FirstLoopPass" -eq 0 ]; then
            printf 'gawk: command not found!\n' >&2
        fi

    else  # Unsupported file

        printf '%s: The specified file is not a shell script!\n' "$file" >&2 && continue

    fi

    if [ -x "$(command -v code-analysis)" ]; then
        code-analysis "$file"
    elif [ "$FirstLoopPass" -eq 0 ]; then
        printf 'code-analysis: command not found!\n' >&2
    fi

    FirstLoopPass=1

done
