#!/bin/bash
# -*- coding: utf-8-unix; Mode: Shell; indent-tabs-mode: nil; tab-width: 4 -*-
# vim: set fileencoding=utf-8 filetype=shell syn=sh.doxygen fileformat=unix tabstop=4 expandtab :
# kate: encoding utf-8; bom off; syntax shell; indent-mode normal; eol unix; replace-tabs on; indent-width 4; tab-width 4; remove-trailing-space on; line-numbers on;
# @brief Universal setup script for Posix-compatible shells
# @file shell_ext
# @version 2018.08.31
# @author Devyn Collier Johnson <DevynCJohnson@Gmail.com>
# @copyright Public Domain (CC0) - https://creativecommons.org/publicdomain/zero/1.0/


# GLOBAL SETTINGS #


# Fix graphical-sudo issues on Wayland
[ -n "${XDG_SESSION_TYPE:-}" ] && [ "$XDG_SESSION_TYPE" = 'wayland' ] && [ -x "$(command -v xhost)" ] && xhost +si:localuser:root > /dev/null

[ -x /usr/libexec/path_helper ] && eval "$(/usr/libexec/path_helper -s)"

export XDG_UTILS_DEBUG_LEVEL=0


# SET SPECIAL PATHS #


# Path

notinpath() { (echo "$PATH" | grep -F -q -v "$1" && return 0) || return 1; }
[ -x "$(command -v brew)" ] && path_tmp="${PATH}:$(brew --cellar)" && PATH="$path_tmp" && unset path_tmp
[ -d /usr/local/opt ] && notinpath '/usr/local/opt' && PATH="${PATH}:/usr/local/opt"
[ -d /opt/bin ] && notinpath '/opt/bin' && PATH="${PATH}:/opt/bin"
[ -d /snap/bin ] && notinpath '/snap/bin' && PATH="${PATH}:/snap/bin"
[ -d "${HOME}/bin" ] && notinpath "${HOME}/bin" && notinpath '\~/bin' && PATH="${HOME}/bin:${PATH}"
[ -d "${HOME}/.local/bin" ] && notinpath "${HOME}/.local/bin" && notinpath '\~/.local/bin' && PATH="${HOME}/.local/bin:${PATH}"
[ -d /wine/bin ] && notinpath '/wine/bin' && PATH="${PATH}:/wine/bin"
[ -d /usr/X11/opt ] && notinpath '/usr/X11/opt' && PATH="${PATH}:/opt/X11/bin"
export PATH

# Package Config Path

notinpcpath() { (echo "$PKG_CONFIG_PATH" | grep -F -q -v "$1" && return 0) || return 1; }
[ "$(notinpcpath "${HOME}/.local/pkgconfig")" ] && [ "$(notinpcpath '\~/.local/pkgconfig')" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:${HOME}/.local/pkgconfig"
[ -d /lib/pkgconfig ] && [ "$(notinpcpath /lib/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/lib/pkgconfig"
[ -d /usr/lib/pkgconfig ] && [ "$(notinpcpath /usr/lib/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/usr/lib/pkgconfig"
[ -d /usr/lib/x86_64-linux-gnu/pkgconfig ] && [ "$(notinpcpath /usr/lib/x86_64-linux-gnu/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/usr/lib/x86_64-linux-gnu/pkgconfig"
[ -d /usr/local/lib/pkgconfig ] && [ "$(notinpcpath /usr/local/lib/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/usr/local/lib/pkgconfig"
[ -d /usr/local/share/pkgconfig ] && [ "$(notinpcpath /usr/local/share/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/usr/local/share/pkgconfig"
[ -d /usr/share/pkgconfig ] && [ "$(notinpcpath /usr/share/pkgconfig)" ] && PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}:/usr/share/pkgconfig"
PKG_CONFIG_PATH="$(echo "$PKG_CONFIG_PATH" | sed -E 's/^::(.+)$/\1/; s/^:(.+)$/\1/')"
export PKG_CONFIG_PATH
PKGCONFIG_PATH="$PKG_CONFIG_PATH"
export PKGCONFIG_PATH
listpath() { echo "$PATH" | awk -F ':' '{ for (i = 1; i <= NF; i++) { print "["i"]", $i; } }'; }
export -f listpath notinpath notinpcpath


# VARIABLES #


if [ -d /etc/apt ] && [ -x "$(command -v apt-get)" ] && [ -e /etc/debian_version ]; then
    # Possible values include: bogl corba dialog gtk ncurses newt noninteractive readline slang text
    export DEBIAN_FRONTEND='dialog'
fi
[ -z "${KRELEASE:-}" ] && KRELEASE='unknown' && [ -x "$(command -v uname)" ] && readonly KRELEASE="$(uname -r)" && export KRELEASE
export PYTHONOPTIMIZE=True

# Glade Path Environment Variables

if [ -x "$(command -v glade)" ]; then
    # GI_TYPELIB_PATH
    notingipath() { (echo "$GI_TYPELIB_PATH" | grep -F -q -v "$1" && return 0) || return 1; }
    if [ -d /usr/lib/girepository-1.0 ]; then
        if [ -z "${GI_TYPELIB_PATH:-}" ]; then
            notingipath /usr/lib/girepository-1.0 && export GI_TYPELIB_PATH='/usr/lib/girepository-1.0'
        else
            notingipath /usr/lib/girepository-1.0 && export GI_TYPELIB_PATH="${GI_TYPELIB_PATH}:/usr/lib/girepository-1.0"
        fi
    fi
    if [ -d /usr/lib/x86_64-linux-gnu/girepository-1.0 ]; then
        if [ -z "${GI_TYPELIB_PATH:-}" ]; then
            notingipath /usr/lib/x86_64-linux-gnu/girepository-1.0 && export GI_TYPELIB_PATH='/usr/lib/x86_64-linux-gnu/girepository-1.0'
        else
            notingipath /usr/lib/x86_64-linux-gnu/girepository-1.0 && export GI_TYPELIB_PATH="${GI_TYPELIB_PATH}:/usr/lib/x86_64-linux-gnu/girepository-1.0"
        fi
    fi
    # GLADE_CATALOG_SEARCH_PATH
    notincatalogpath() { (echo "$GLADE_CATALOG_SEARCH_PATH" | grep -F -q -v "$1" && return 0) || return 1; }
    if [ -d /usr/share/glade/catalogs ]; then
        if [ -z "${GLADE_CATALOG_SEARCH_PATH:-}" ]; then
            notincatalogpath /usr/share/glade/catalogs && export GLADE_CATALOG_SEARCH_PATH='/usr/share/glade/catalogs'
        else
            notincatalogpath /usr/share/glade/catalogs && export GLADE_CATALOG_SEARCH_PATH="${GLADE_CATALOG_SEARCH_PATH}:/usr/share/glade/catalogs"
        fi
    fi
    # GLADE_MODULE_SEARCH_PATH
    notingmodpath() { (echo "$GLADE_MODULE_SEARCH_PATH" | grep -F -q -v "$1" && return 0) || return 1; }
    if [ -d /usr/lib/glade/modules ]; then
        if [ -z "${GLADE_MODULE_SEARCH_PATH:-}" ]; then
            notingmodpath /usr/lib/glade/modules && export GLADE_MODULE_SEARCH_PATH='/usr/lib/glade/modules'
        else
            notingmodpath /usr/lib/glade/modules && export GLADE_MODULE_SEARCH_PATH="${GLADE_MODULE_SEARCH_PATH}:/usr/lib/glade/modules"
        fi
    fi
    if [ -d /usr/lib/x86_64-linux-gnu/glade/modules ]; then
        if [ -z "${GLADE_MODULE_SEARCH_PATH:-}" ]; then
            notingmodpath /usr/lib/x86_64-linux-gnu/glade/modules && export GLADE_MODULE_SEARCH_PATH='/usr/lib/x86_64-linux-gnu/glade/modules'
        else
            notingmodpath /usr/lib/x86_64-linux-gnu/glade/modules && export GLADE_MODULE_SEARCH_PATH="${GLADE_MODULE_SEARCH_PATH}:/usr/lib/x86_64-linux-gnu/glade/modules"
        fi
    fi
fi


# EDITOR VARIABLES #


if [ -x "$(command -v nano)" ]; then
    SELECTED_EDITOR="$(command -v nano)"
    sunano() { sudo "${SELECTED_EDITOR}" "$1"; }
elif [ -x "$(command -v pico)" ]; then
    SELECTED_EDITOR="$(command -v pico)"
    supico() { sudo "${SELECTED_EDITOR}" "$1"; }
elif [ -x "$(command -v emacs)" ]; then
    SELECTED_EDITOR="$(command -v emacs)"
    suemacs() { sudo "${SELECTED_EDITOR}" "$1"; }
elif [ -x "$(command -v vim)" ]; then
    SELECTED_EDITOR="$(command -v vim)"
    suvim() { sudo "${SELECTED_EDITOR}" "$1"; }
elif [ -x "$(command -v vi)" ]; then
    SELECTED_EDITOR="$(command -v vi)"
    suvi() { sudo "${SELECTED_EDITOR}" "$1"; }
elif [ -x "$(command -v vile)" ]; then
    SELECTED_EDITOR="$(command -v vile)"
elif [ -x "$(command -v levee)" ]; then
    SELECTED_EDITOR="$(command -v levee)"
elif [ -x "$(command -v nvi)" ]; then
    SELECTED_EDITOR="$(command -v nvi)"
fi
[ -n "${SELECTED_EDITOR:-}" ] && export SELECTED_EDITOR && export EDITOR="$SELECTED_EDITOR" && export VISUAL="$SELECTED_EDITOR"
[ -n "${SELECTED_EDITOR:-}" ] && sedit() { sudo "${SELECTED_EDITOR}" "$1"; }
[ -x "$(command -v brew)" ] && export HOMEBREW_EDITOR="$EDITOR"
export SUDO_EDITOR="$SELECTED_EDITOR"


# CONDITIONAL TESTING FUNCTIONS #


isBlockFile() { ([ -b "$1" ] && return 0) || return 1; }
isInPath() { (command -v "$1" && return 0) || return 1; }
isBuiltin() { (command -V "$1" 2> /dev/null | grep -q -w -i 'builtin') || return $?; }
isDir() { ([ -d "$1" ] && return 0) || return 1; }
isEnvAWS() { if [ -n "${AWS_BATCH_CE_NAME:-}" ] || [ -n "${AWS_BATCH_JOB_ID:-}" ] || [ -n "${AWS_EXECUTION_ENV:-}" ] || [ -n "${LAMBDA_RUNTIME_DIR:-}" ]; then return 0; else return 1; fi; }
isFile() { ([ -f "$1" ] && return 0) || return 1; }
isFileExecutable() { ([ -x "$1" ] && return 0) || return 1; }
isFileReadable() { ([ -r "$1" ] && return 0) || return 1; }
isFileWritable() { ([ -w "$1" ] && return 0) || return 1; }
isFileOrDir() { if [ -d "$1" ] || [ -f "$1" ]; then return 0; else return 1; fi; }
isFunction() { command -V "$1" 2> /dev/null | head -1 | grep -q -w -i 'function'; return $?; }
isptmx() { tty | awk '{ if ($0~/\/dev\/ptmx.*/) { print "true" } else { print "false" } }'; }
ispts() { tty | awk '{ if ($0~/\/dev\/pts.*/) { print "true" } else { print "false" } }'; }
isSymLink() { ([ -h "$1" ] && return 0) || return 1; }
istty() { tty | awk '{ if ($0~/\/dev\/tty.*/) { print "true" } else { print "false" } }'; }
strcontains() { (echo "$2" | grep -F -q "$1" && return 0) || return 1; }
strdoesnotcontain() { (echo "$2" | grep -F -q -v "$1" && return 0) || return 1; }
export -f isBlockFile isInPath isBuiltin isDir isFile isFileExecutable isFileReadable
export -f isFileWritable isFileOrDir isFunction ispts isSymLink istty strcontains strdoesnotcontain


# GRAPHICAL INTERFACE FUNCTIONS #


if [ -x "$(command -v zenity)" ] && [ "$(istty)" = 'false' ]; then
    win_cal() { zenity --title=Calendar --calendar --text='' --day=1 --month=1 --year="$1" 2> /dev/null; }
    win_err() { zenity --title=Error --error --text="${1}" 2> /dev/null; }
    win_info() { zenity --title=Information --info --text="${1}" 2> /dev/null; }
    win_warn() { zenity --title=Warning --warning --text="${1}" 2> /dev/null; }
fi


# PACKAGE MANAGER FUNCTIONS #


[ "$PROFILE_SHELL" = 'bash' ] && set -a
if [ "$PLATFORM" = 'darwin' ] && [ "$PLATFORM" != 'gnu' ]; then  # Apple/Darwin Package Managers
    # TODO: Add MacPorts and Fink
    if [ -n "$(command -v brew)" ]; then  # MacOS Homebrew
        cleanrepocache() { brew cleanup; }
        clrpkg() { brew prune; }
        getpkgsrc() { brew fetch "${@//;// }"; }
        lsrepos() { brew tap; }
        mkbrewpkg() { brew create "${@//;// }"; }
        pkginfo() { brew info formula "${@//;// }"; }
        pkginstall() { brew install "${@//;// }"; }
        pkglsaval() { brew list --unbrewed; }
        pkglsinst() { brew list; }
        pkglsleaves() { brew leaves; }
        pkglsup() { brew outdated; }
        pkgreinstall() { brew reinstall "${@//;// }"; }
        pkguninstall() { brew uninstall "${@//;// }"; }
        pkgupdate() { ([ -n "${*:-}" ] && brew upgrade "${@//;// }") || ([ -z "${*:-}" ] && brew upgrade); }
        refreshman() { brew man; }
        refreshrepo() { brew update --force; }
        repocheck() { brew doctor; }
        repofinddebian() { brew search --debian "${@//;// }"; }
        repofindfedora() { brew search --fedora "${@//;// }"; }
        repofindfink() { brew search --fink "${@//;// }"; }
        repofindmacports() { brew search --macports "${@//;// }"; }
        repofindopensuse() { brew search --opensuse "${@//;// }"; }
        repofindubuntu() { brew search --ubuntu "${@//;// }"; }
        repoinfo() { brew tap-info; }
        writebrewfile() { brew bundle cleanup; }
    fi
elif [ -d /etc/apt ] && [ -x "$(command -v apt-get)" ]; then  # Debian Linux Apt
    cleanrepocache() { sudo apt-get clean; }
    clrpkg() { sudo apt-get autoremove; }
    [ -n "$(command -v apt-cache)" ] && findpkg() { apt-cache search "$1"; }
    getPkgChlog() { apt-get changelog "${@//;// }"; }
    getpkgsrc() { apt-get source --download-only "${@//;// }"; }
    pkginstall() { sudo apt-get install "${@//;// }"; }
    pkglsall() { apt-cache --no-generate pkgnames "${1:-}"; }
    pkgreinstall() { sudo apt-get install --reinstall "${@//;// }"; }
    pkguninstall() { sudo apt-get purge "${@//;// }"; }
    pkgupdate() { sudo apt-get install --only-upgrade "${@//;// }"; }
    refreshrepo() { sudo apt-get update; }
    repocheck() { sudo apt-get check; }
    sysupdate() { sudo apt-get dist-upgrade; }
    if [ -x "$(command -v add-apt-repository)" ]; then
        addrepo() { sudo add-apt-repository "${@//;// }"; }
        rmrepo() { sudo add-apt-repository --remove "${@//;// }"; }
    fi
    if [ -x "$(command -v dpkg)" ]; then
        alias filepkgorigin='dpkg-query -S'
        alias filesfrompkg='dpkg-query -L'
        alias pkglsinst='dpkg --list | grep ^i'
    fi
    [ -x "$(command -v dpkg-query)" ] && alias pkgfind='dpkg-query --list'
elif [ -d /etc/dnf ] && [ -x "$(command -v dnf)" ]; then  # Fedora DNF
    cleanrepocache() { sudo dnf clean all; }
    clrpkg() { sudo dnf autoremove; }
    pkgdowngrade() { sudo dnf downgrade "${@//;// }"; }
    pkginfo() { dnf info "${@//;// }"; }
    pkginstall() { sudo dnf install "${@//;// }"; }
    pkglsall() { dnf list all; }
    pkglsaval() { dnf list available; }
    pkglsinst() { dnf list installed; }
    pkglsup() { dnf list updates; }
    pkgreinstall() { sudo dnf reinstall "${@//;// }"; }
    pkguninstall() { sudo dnf remove "${@//;// }"; }
    pkgupdate() { sudo dnf upgrade "${@//;// }"; }
    refreshrepo() { sudo dnf clean expire-cache && sudo dnf check-update; }
    repocheck() { sudo dnf check; }
    sysupdate() { sudo dnf upgrade --refresh; }
elif [ -d /etc/portage ] && [ -x "$(command -v emerge)" ]; then  # Gentoo Emerge
    cleanrepocache() { eclean distfiles; }
    clrpkg() { eclean --depclean; }
    getPkgChlog() { equery changes -f "${@//;// }"; }
    pkginstall() { emerge -a "${@//;// }"; }
    pkglsall() { emerge -ep world; }
    pkglsinst() { emerge -ep world; }
    pkglsup() { emerge -uDNp world; }
    pkgreinstall() { emerge -1O "${@//;// }"; }
    pkguninstall() { emerge -C "${@//;// }"; }
    refreshrepo() { emerge --sync && layman -S; }
    repocheck() { emerge -uDN world; }
    sysupdate() { emerge -u world; }
elif [ -f /etc/opkg.conf ] && [ -x "$(command -v opkg)" ]; then  # OpenWrt Opkg
    pkginstall() { opkg install "${@//;// }"; }
    pkglstaval() { opkg list; }
    pkglstinst() { opkg list-installed; }
    pkglstup() { opkg list-upgradable; }
    pkguninstall() { opkg remove "${@//;// }"; }
    pkgupdate() { opkg upgrade "${@//;// }"; }
    refreshrepo() { opkg update; }
elif [ -d /etc/pacman ] && [ -x "$(command -v pacman)" ]; then  # Arch Linux Pacman
    cleanrepocache() { pacman -Scc; }
    clrpkg() { pacman -Rs -; }
    getPkgChlog() { pacman -Qc "${@//;// }"; }
    pkginstall() { pacman -S "${@//;// }"; }
    pkglsaval() { pacman -Sl; }
    pkglsinst() { pacman -Qqe; }
    pkglsup() { pacman -Qu; }
    pkgreinstall() { pacman -S "${@//;// }"; }
    pkguninstall() { pacman -Rs "${@//;// }"; }
    pkgupdate() { pacman -Syu "${@//;// }"; }
    refreshrepo() { pacman -Sy; }
    repocheck() { pacman -Dk; }
    sysupdate() { pacman -Syu; }
elif [ "$OSFAMILY" = 'sun' ] && [ -x "$(command -v pkg)" ]; then  # Solaris IPS (pkg)
    pkginstall() { pkg install "${@//;// }"; }
    pkglsinst() { pkg list; }
    pkguninstall() { pkg uninstall "${@//;// }"; }
    pkgupdate() { pkg upgrade "${@//;// }"; }
    repocheck() { pkg verify; }
    sysupdate() { pkg update; }
elif [ "$OSFAMILY" = 'sun' ] && [ -x "$(command -v pkgutil)" ]; then  # Solaris pkgutil
    pkginstall() { pkgutil --install "${@//;// }"; }
    pkgreinstall() { pkgutil --force --install "${@//;// }"; }
    pkguninstall() { pkgutil --remove "${@//;// }"; }
    pkgupdate() { pkgutil --upgrade "${@//;// }"; }
    refreshrepo() { pkgutil --catalog; }
    repocheck() { pkgutil --syscheck; }
elif [ -d /etc/yum ] && [ -x "$(command -v yum)" ]; then  # RedHat Linux Yum
    cleanrepocache() { sudo yum clean all; }
    cleanrpmdb() { sudo yum clean rpmdb; }
    clrpkg() { sudo yum autoremove; }
    getPkgChlog() { yum changelog "${@//;// }"; }
    pkgdowngrade() { sudo yum downgrade "${@//;// }"; }
    pkginfo() { yum info "${@//;// }"; }
    pkginstall() { sudo yum install "${@//;// }"; }
    pkglsall() { yum list all; }
    pkglsaval() { yum list available; }
    pkglsinst() { yum list installed; }
    pkglsup() { yum list updates; }
    pkgreinstall() { sudo yum reinstall "${@//;// }"; }
    pkguninstall() { sudo yum remove "${@//;// }"; }
    pkgupdate() { sudo yum update "${@//;// }"; }
    refreshrepo() { sudo yum makecache; }
    repocheck() { sudo yum check; }
    sysupdate() { sudo yum upgrade; }
elif [ -d /etc/zypp ] && [ -x "$(command -v zypper)" ]; then  # OpenSUSE Zypper
    cleanrepocache() { zypper clean; }
    clrpkg() { zypper remove --clean-deps; }
    getPkgChlog() { rpm -q --changelog "${@//;// }"; }
    pkginstall() { zypper install "${@//;// }"; }
    pkglsall() { zypper packages; }
    pkglsinst() { zypper search --installed-only; }
    pkglsup() { zypper list-updates; }
    pkgreinstall() { zypper install --force "${@//;// }"; }
    pkguninstall() { zypper remove "${@//;// }"; }
    refreshrepo() { zypper refresh; }
    repocheck() { zypper verify; }
    sysupdate() { zypper update; }
fi
[ "$PROFILE_SHELL" = 'bash' ] && set +a


# INTERACTIVE SHELL #


# If not running interactively, then do not do anything
if [ -z "${PS1}" ]; then
    export isinteractive='false'
    return
else
    case "$-" in
        *i*) export isinteractive='true';;
        *) export isinteractive='false'; return;;
    esac
fi


# SHELL SETTINGS #


[ -n "${DEBUG:-}" ] && set -u
HISTCONTROL=erasedups:ignoreboth:ignoredups:ignorespace
export HISTSIZE=40
export HISTFILESIZE=40
if [ "$PROFILE_SHELL" = 'bash' ] && [ -n "$(command -v shopt)" ]; then
    shopt -s checkwinsize
    shopt -s extglob
    shopt -s histappend
    [ ! "$PLATFORM" = 'darwin' ] && shopt -s globstar
fi
if [ "$TERM" = 'Apple_Terminal' ]; then
    setopt combiningchars
    disable log
fi
set +o noglob || true
set +o verbose || true

# Make `less` more friendly for non-text input files
[ -x "$(command -v lesspipe)" ] && eval "$(SHELL=/bin/sh lesspipe)"


# MISCELLANEOUS FEATURES #


# Sudo Hint
if [ ! -e "${HOME}/.sudo_as_admin_successful" ] && [ ! -e "${HOME}/.hushlogin" ]; then
    case " $(groups) " in *\ admin\ *|*\ sudo\ *)
        printf 'To run a command as administrator (user "root"), use "sudo <command>".\nSee "man sudo_root" for details.\n'
    esac
fi
alias sudo='sudo '

# Use the `command-not-found` package (if installed)
if [ -x /usr/lib/command-not-found ]; then
    command_not_found_handle() { /usr/lib/command-not-found -- "$1"; return $?; }
elif [ -x /usr/lib/command-not-found ]; then
    command_not_found_handle() { /usr/share/command-not-found/command-not-found -- "$1"; return $?; }
else
    command_not_found_handle() { printf '%s: command not found\n' "$1" >&2; return 127; }
fi


# COLORIZED TERMINAL #


if [ -n "${TERM:-}" ]; then
    case "$TERM" in
        [aEKx]term*|gnome*|hurd|konsole*|linux|mach-*color|screen-256color*|xterm) color_prompt='yes';;
        ansi|*color*|cygwin|interix*|putty*|rxvt*|wsvt*|X11*) color_prompt='yes';;
        termix|kitty|mosh|iterm2|panteon|tinyterm|mintty) color_prompt='yes';;
        *) color_prompt='no';;  # cons25, cons25-debian, dumb, mach*, pcansi, screen*, sun, vt*
    esac  # ls /lib/terminfo/*
elif [ -n "${COLORTERM:-}" ]; then
    if [ -x "$(command -v tput)" ] && tput setaf 1 2>&1 /dev/null; then
        # Color support present; assume it is compliant with Ecma-48 (ISO/IEC-6429)
        color_prompt='yes'
    else
        color_prompt=''
    fi
fi
[ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ] && debian_chroot="$(cat /etc/debian_chroot)"
[ -z "${debian_chroot:-}" ] && [ ! -r /etc/debian_chroot ] && debian_chroot=''
PS1=''
# Enable color support for various commands
if [ -n "${color_prompt:-}" ] && [ "$color_prompt" = 'yes' ]; then
    if [ "$(id -u)" -eq 0 ]; then
        PS1='\[\033[0m\]${debian_chroot:+($debian_chroot)}\[\033[0m\]\[\033[01;32m\]\u\[\033[0m\]@\[\033[01;33m\]\h\[\033[0m\]:\[\033[01;34m\]\w\[\033[0m\]# '
    else
        PS1='\[\033[0m\]${debian_chroot:+($debian_chroot)}\[\033[0m\]\[\033[01;32m\]\u\[\033[0m\]@\[\033[01;33m\]\h\[\033[0m\]:\[\033[01;34m\]\w\[\033[0m\]\$ '
    fi
    alias grep='grep --color=auto'
    alias cgrep='grep --color=always'
    if [ -x "$(command -v egrep)" ]; then
        alias egrep='egrep --color=auto'
    else
        alias egrep='grep -E --color=auto'
    fi
    if [ -x "$(command -v fgrep)" ]; then
        alias fgrep='fgrep --color=auto'
    else
        alias fgrep='grep -F --color=auto'
    fi
    export LESS_TERMCAP_mb=$'\033[1;32m'  # Start blinking
    export LESS_TERMCAP_md=$'\033[1;32m'  # Start bold mode
    export LESS_TERMCAP_me=$'\033[0m'  # End all mode
    export LESS_TERMCAP_se=$'\033[0m'  # End standout mode
    export LESS_TERMCAP_so=$'\033[01;33m'  # Start standout mode
    export LESS_TERMCAP_ue=$'\033[0m'  # End underlining
    export LESS_TERMCAP_us=$'\033[1;4;31m'  # Start underlining
else  # No color support
    if [ "$(id -u)" -eq 0 ]; then
        PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w# '
    else
        PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
    fi
fi
unset color_prompt

# Enable color support for `ls`
if [ -x "$(command -v dircolors)" ]; then
    export CLICOLOR=1
    if [ -r "${HOME}/.dircolors" ]; then
        eval "$(dircolors -b "${HOME}/.dircolors")"
    else
        eval "$(dircolors -b)"
    fi
    [ -n "$(command -v dir)" ] && alias dir='dir --color=auto'
    if [ ! "$OSFAMILY" = 'bsd' ]; then
        alias ls='ls --color=auto'
    fi
    [ -n "$(command -v vdir)" ] && alias vdir='vdir --color=auto'
fi


# ALIASES #


# Compression Utility Aliases

[ -x "$(command -v 7z)" ] && [ ! -x "$(command -v un7z)" ] && alias un7z='7z e'
[ -x "$(command -v bunzip2)" ] && [ ! -x "$(command -v unbzip2)" ] && alias unbzip2='bunzip2'
[ -x "$(command -v gunzip)" ] && [ ! -x "$(command -v ungzip)" ] && alias ungzip='gunzip'
[ -x "$(command -v lzop)" ] && [ ! -x "$(command -v unlzop)" ] && alias unlzop='lzop -d'
[ -x "$(command -v msexpand)" ] && [ ! -x "$(command -v unmscompress)" ] && alias unmscompress='msexpand'
[ -x "$(command -v p7zip)" ] && [ ! -x "$(command -v unp7zip)" ] && alias unp7zip='p7zip --decompress'
[ -x "$(command -v runzip)" ] && [ ! -x "$(command -v unrzip)" ] && alias unrzip='runzip'
[ -x "$(command -v tar)" ] && [ ! -x "$(command -v untar)" ] && alias untar='tar --extract -f' && alias untgz='tar -xzf'

# Cryptography Aliases

if [ -x "$(command -v openssl)" ]; then
    alias Crypto_brainpool512='openssl ecparam -name brainpoolP512t1 -genkey'
    alias Crypto_c2tnb431r1='openssl ecparam -name c2tnb431r1 -genkey'
    alias Crypto_prime256='openssl ecparam -name prime256v1 -genkey'
    alias Crypto_secp521='openssl ecparam -name secp521r1 -genkey'
    alias Crypto_sect571k1='openssl ecparam -name sect571k1 -genkey'
    alias Crypto_sect571r1='openssl ecparam -name sect571r1 -genkey'
    alias CryptoCurves='openssl ecparam -list_curves'
    alias CryptoPrime='openssl prime -generate -bits'
    alias CryptoPswd='openssl passwd'
    alias CryptoRand='openssl rand -base64'
    alias md2='openssl dgst -md2'
    alias md5='openssl dgst -md5'
    alias mdc2='openssl dgst -mdc2'
    alias rmd160='openssl dgst -rmd160'
    alias sha1='openssl dgst -sha1'
    alias sha224='openssl dgst -sha224'
    alias sha256='openssl dgst -sha256'
    alias sha384='openssl dgst -sha384'
    alias sha512='openssl dgst -sha512'
fi

# Filesystem Maneuvering Aliases

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias back='cd -'
alias cd..='cd ..'
alias dirs='ls -d */'
alias ff.='find . -type f -name'
alias ff='find / -type f -name'
alias gotoetc='cd /etc'
alias gohome='cd ${HOME}'
alias gotologs='cd /var/log'
alias l.='ls -d .*'
alias l='ls -C -F'
alias la='ls -A'
alias lb='ls -a -B -i -l'
alias ll='ls -a -l -F'
alias lr='ls -a -l -F -R'
alias lsl='if [ -x "$(command -v less)" ]; then ls -A -F -h -l | less; else ls -A -F -h -l | more; fi'
alias lsz='ls -a -l -F -S -W'
alias ltm='ls -a -l -F -t'

# File Manipulation Aliases

[ -z "$(command -v cptree)" ] && alias cptree='cp -R'
[ -z "$(command -v del)" ] && alias del='rm'
[ -z "$(command -v hardlink)" ] && alias hardlink='ln'
if [ -n "$(command -v chattr)" ]; then
    alias mkimmutable='chattr +i'
    alias mkmutable='chattr -i'
fi
[ -z "$(command -v softlink)" ] && alias softlink='ln -s'
[ -z "$(command -v softln)" ] && alias softln='ln -s'
[ -z "$(command -v trash)" ] && alias trash='mv -f -t "${HOME}/.local/share/Trash"'

# Kernel Module Management Aliases

if [ -x "$(command -v modprobe)" ] && [ -d "/lib/modules/${KRELEASE}" ]; then
    [ -d "/lib/modules/${KRELEASE}/kernel/fs" ] && alias lsavalfsmods='ls "/lib/modules/${KRELEASE}/kernel/fs"'
    [ -d "/lib/modules/${KRELEASE}/updates/dkms" ] && alias loadvboxmods='sudo modprobe --all "/lib/modules/${KRELEASE}/updates/dkms/vbox"*'
    [ -d "/lib/modules/${KRELEASE}/updates/dkms" ] && alias unloadvboxmods='sudo modprobe -r --all "/lib/modules/${KRELEASE}/updates/dkms/vbox"*'
    [ -d "/lib/modules/${KRELEASE}/kernel/fs/reiserfs" ] && alias loadreiserfs='sudo modprobe reiserfs'
    [ -d "/lib/modules/${KRELEASE}/kernel/fs/reiserfs" ] && alias unloadreiserfs='sudo modprobe -r reiserfs'
    [ -d "/lib/modules/${KRELEASE}/kernel/fs/xfs" ] && alias loadxfs='sudo modprobe xfs'
    [ -d "/lib/modules/${KRELEASE}/kernel/fs/xfs" ] && alias unloadxfs='sudo modprobe -r xfs'
    [ -d "/lib/modules/${KRELEASE}/kernel/drivers/wacom" ] && alias loadwacom='sudo modprobe wacom'
    [ -d "/lib/modules/${KRELEASE}/kernel/drivers/wacom" ] && alias unloadwacom='sudo modprobe -r wacom'
fi

# Network Aliases

[ -x "$(command -v ping)" ] && alias testnet='ping -c 1 dcjtech.info || ping -c 1 duckduckgo.com'
if [ -x "$(command -v curl)" ]; then
    alias getwebip='curl'
    alias testwebtime="curl -s -w 'Testing Website Response Time: %{url_effective}\n\nLookup Time:\t\t%{time_namelookup}\nConnect Time:\t\t%{time_connect}\nPre-transfer Time:\t%{time_pretransfer}\nStart-transfer Time:\t%{time_starttransfer}\n\nTotal Time:\t\t%{time_total}\n' -o /dev/null http://www.google.com"
    alias webheaders='curl -I'
elif [ -x "$(command -v wget)" ]; then
    alias getwebip='wget -qO -'
fi
[ -n "$(command -v ifconfig)" ] && [ -z "$(command -v ipconfig)" ] && alias ipconfig='ifconfig'
[ -x "$(command -v iptables)" ] && alias ipt='sudo iptables'
if [ -x "$(command -v nmcli)" ]; then
    alias netOff='nmcli networking off'
    alias netOn='nmcli networking on'
    alias radioOff='nmcli radio all off'
    alias radioOn='nmcli radio all on'
    alias wifiOff='nmcli radio wifi off'
    alias wifiOn='nmcli radio wifi on'
    alias wwanOff='nmcli radio wwan off'
    alias wwanOn='nmcli radio wwan on'
    alias wifiScan='nmcli dev wifi'
fi
[ -x "$(command -v netstat)" ] && alias viewopenports='netstat -a -l -n -p -t -u'

# Package Management Aliases

if [ -x "$(command -v npm)" ]; then
    alias cleanjscache='sudo -H npm cache clean'
    alias jsinstall='sudo -H npm install -g'
    alias jspkglsinst='npm -g ls --depth 0'
    alias jsrepocheck='sudo -H npm doctor'
    alias jsuninstall='sudo -H npm uninstall -g'
    alias jsupdate='sudo -H npm update -g'
fi
if [ -x "$(command -v pear)" ]; then
    alias phpinstall='sudo -H pear install'
    alias phppkglsinst='pear list'
    alias phpuninstall='sudo -H pear uninstall'
    alias phpupdate='sudo -H pear upgrade'
fi
if [ -x "$(command -v pip3)" ]; then
    alias findpypkg='pip3 search'
    alias genpyreqfile='pip3 freeze > ./requirements.txt'
    alias getpypkgsrc='pip3 download'
    alias pyinstall='sudo -H pip3 install'
    alias pypkglsinst='pip3 list --format=columns'
    alias pypkglsnonreq='pip3 list --not-required --format=columns'
    alias pypkglsup='pip3 list -o --format=columns'
    alias pypkglsusr='pip3 list --user --format=columns'
    alias pyreinstall='sudo -H pip3 install --upgrade --force-reinstall'
    alias pyrepocheck='sudo -H pip3 check'
    alias pyuninstall='sudo -H pip3 uninstall'
    alias pyupdate='sudo -H pip3 install -U'
    pysysupdate() { sudo -H sh -c "pip3 freeze --local | grep -v '^\-e' | cut -d '=' -f 1 | xargs -n1 pip3 install -U"; }
fi

# Settings Manipulation Aliases

if [ -x "$(command -v dconf)" ]; then
    alias backupdconf='dconf dump / > "${HOME}/gsettings.dump"'
    alias restoredconf='dconf load <'
fi
if [ -x "$(command -v gsettings)" ]; then
    alias backupgset='gsettings list-recursively > "${HOME}/gsettings.lst"'
    if ([ -n "${XDG_SESSION_DESKTOP:-}" ] && [ "$XDG_SESSION_DESKTOP" = 'mate' ]) || ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'MATE' ]); then
        alias setgtktheme='gsettings set org.mate.desktop.interface gtk-theme'
    elif ([ -n "${XDG_SESSION_DESKTOP:-}" ] && [ "$XDG_SESSION_DESKTOP" = 'gnome' ]) || ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'GNOME' ]); then
        alias setgtktheme='gsettings set org.gnome.desktop.interface gtk-theme'
    elif ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'XFCE' ]); then
        alias setgtktheme='xfconf-query -c xsettings -p /Net/ThemeName -s'
    fi
fi

# String Manipulation Aliases

alias lowercase="tr '[:upper:]' '[:lower:]'"
alias uppercase="tr '[:lower:]' '[:upper:]'"

# System Control Aliases

[ -x "$(command -v fstrim)" ] && alias cleanssd='sudo fstrim -a -v'  # Clean unused blocks on SSD drives
if [ "$(id -u)" -eq 0 ] && [ -f /proc/sys/vm/drop_caches ]; then
    alias freepagecache='echo 1 > /proc/sys/vm/drop_caches'
    alias freeinodes='echo 2 > /proc/sys/vm/drop_caches'
    alias freeramcache='echo 3 > /proc/sys/vm/drop_caches'
fi
[ -x "$(command -v swapon)" ] && alias freeswap='sudo swapoff -a && sleep 2 && sudo swapon -a'
[ -f /var/log/Xorg.0.log ] && alias gpumeminfo="grep -F --color 'Memory:' /var/log/Xorg.0.log"
alias killjobs='kill "$(jobs -ps)" 2> /dev/null'
[ -x "$(command -v systemctl)" ] && alias lsenabledservices='systemctl list-unit-files | grep -F enabled'
[ -x "$(command -v free)" ] && alias meminfo='free -m -l -t'
[ -x "$(command -v xset)" ] && alias monitoroff='xset dpms force off'
alias powerdown='sudo shutdown -h now'
alias poweroff='sudo shutdown -h now'
alias reboot='history -c; sudo shutdown -r now'
alias resudo='sudo -v'
alias sedo='sudo -E'
alias unmount='sudo umount'
alias viewmount='mount | column -t'

# Terminal Control Aliases

alias CLEAR='clear'
alias clr='clear'
alias CLR='clear'
if [ "$PROFILE_SHELL" = 'bash' ]; then  # Clear the terminal and history prior to exiting
    alias clsh='clear; history -c; echo "" > ${HOME}/.bash_history; exit'
elif [ "$PROFILE_SHELL" = 'fish' ]; then
    alias clsh='clear; history -c; echo "" > ${HOME}/.local/share/fish/fish_history; exit'
elif [ "$PROFILE_SHELL" = 'zsh' ]; then
    alias clsh='clear; history -c; echo "" > ${HOME}/.zsh_history; exit'
elif [ -w "${HOME}/.sh_history" ]; then
    alias clsh='clear; history -c; echo "" > ${HOME}/.sh_history; exit'
else
    alias clsh='clear; history -c; exit'
fi
alias findalias='alias | grep -i -F'
alias findfunc='set | grep -i -F'
alias lsfuncs='set | grep -F "()"'
alias viewpath='echo "$PATH"'

# Miscellaneous Aliases

if [ -x "$(command -v notify-send)" ]; then
    alias alert='notify-send --urgency=low -i "Alert"'
else
    alias alert='printf "Alert\n"'
fi
alias ConsoleMessage='echo'
[ -x "$(command -v du)" ] && [ -x "$(command -v less)" ] && alias du.='du -ach | sort -h | less'
[ -x "$(command -v df)" ] && [ -x "$(command -v less)" ] && alias df.='df -a -h -T | less'
alias findpypling='grep -F "#!/usr/bin/env python3" ./*'  # Find files that begin with a Python hashpling
alias findr='grep -I -i -n -q -r -s --mmap .*'
alias findrx='grep -E -I -n -q -r -s --mmap .*'
[ -x "$(command -v compiz)" ] && alias rgui='pidof compiz && killall -SIGHUP compiz'  # Restart Compiz (fixes memory leak)
alias rless='less -r'
alias lessn='less -N'
alias today="date +%m/%d/%y"


# FUNCTIONS #


# Cryptographic Functions

[ -x "$(command -v openssl)" ] && CryptoRandStr() { head -c "$1" /dev/urandom | openssl enc -base64; }

# File Manipulation Functions

if [ "$PLATFORM" = 'linux' ] || [ "$PLATFORM" = 'cygwin' ]; then
    copyFileOwnership() {  # Copy the ownership and permissions of one file to another
        if [ -z "$1" ] || [ -z "$2" ]; then
            printf 'ERROR: A parameter is required!\n' >&2
        else
            chmod --reference="$1" "$2"
            chown --reference="$1" "$2"
        fi
    }
fi

fcat() {  # Find an executable script with the given name (without regex) and open it with cat
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Find an executable script with the given name (without regex) and open it with cat\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Find an executable script with the given name (without regex) and open it with cat\n'
    elif [ -r "$(which "${1}")" ]; then
        floc="$(which "${1}")"
        if file -b -L --mime "$floc" | grep -q '^text'; then
            cat "$floc"
        else
            printf 'ERROR: The file is not a plain-text script!\n' >&2
        fi
    else
        printf 'ERROR: The script was not found!\n' >&2
    fi
}

finddir() {  # Find a directory with the given name (without regex); searches from CWD if no directory is specified
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Find a directory with the given name (without regex); searches from CWD if no directory is specified\nUsage: finddir DIR_NAME [LOOK_IN_DIR]\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Find a directory with the given name (without regex); searches from CWD if no directory is specified\nUsage: finddir DIR_NAME [LOOK_IN_DIR]\n'
    elif [ -n "${2:-}" ] && [ -d "$2" ]; then
        find "$2" -mount -type d -name "$1" -exec printf '%s\n' '{}' + 2> /dev/null
    else
        find . -mount -type d -name "$1" -exec printf '%s\n' '{}' + 2> /dev/null
    fi
}

finddirx() {  # Find a directory with the given name (with regex); searches from / if no directory is specified
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Find a directory with the given name (with regex); searches from / if no directory is specified\nUsage: finddirx DIR_NAME [LOOK_IN_DIR]\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Find a directory with the given name (with regex); searches from / if no directory is specified\nUsage: finddirx DIR_NAME [LOOK_IN_DIR]\n'
    elif [ -n "${2:-}" ] && [ -d "$2" ]; then
        find "$2" -type d -regextype awk -regex ".*/${1}" -exec printf '%s\n' '{}' + 2> /dev/null
    else
        find / -type d -regextype awk -regex ".*/${1}" -exec printf '%s\n' '{}' + 2> /dev/null
    fi
}

findfile() {  # Find a file with the given name (without regex); searches from CWD if no directory is specified
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Find a file with the given name (without regex); searches from CWD if no directory is specified\nUsage: findfile FILE_NAME [LOOK_IN_DIR]\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Find a file with the given name (without regex); searches from CWD if no directory is specified\nUsage: findfile FILE_NAME [LOOK_IN_DIR]\n'
    elif [ -n "${2:-}" ] && [ -d "$2" ]; then
        find "$2" -mount -type f -name "$1" -exec printf '%s\n' '{}' + 2> /dev/null
    else
        find . -mount -type f -name "$1" -exec printf '%s\n' '{}' + 2> /dev/null
    fi
}

findfilex() {  # Find a file with the given name (with regex); searches from / if no directory is specified
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Find a file with the given name (with regex); searches from / if no directory is specified\nUsage: findfilex FILE_NAME [LOOK_IN_DIR]\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Find a file with the given name (with regex); searches from / if no directory is specified\nUsage: findfilex FILE_NAME [LOOK_IN_DIR]\n'
    elif [ -n "${2:-}" ] && [ -d "$2" ]; then
        find "$2" -type f -regextype awk -regex ".*/${1}" -exec printf '%s\n' '{}' + 2> /dev/null
    else
        find / -type f -regextype awk -regex ".*/${1}" -exec printf '%s\n' '{}' + 2> /dev/null
    fi
}

rmfiles() {  # Removes files that match the given regex pattern
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
        printf 'Removes files that match the given regex pattern\n--preview will print filenames instead of deleting them\nUsage: rmfiles [--preview] PATTERN [LOOK_IN_DIR]\n' >&2
    elif [ "$1" = "-h" ] || [ "$1" = "--help" ] || [ "$1" = "-?" ]; then
        printf 'Removes files that match the given regex pattern\n--preview will print filenames instead of deleting them\nUsage: rmfiles [--preview] PATTERN [LOOK_IN_DIR]\n'
    elif [ "$1" = '--test' ] || [ "$1" = '-t' ] || [ "$1" = '--preview' ]; then
        if [ -n "${3:-}" ] && [ -d "$3" ]; then
            find "$3" -type f -regextype awk -regex ".*/${2}" -exec printf '%s\n' '{}' + 2> /dev/null
        elif [ -n "${2:-}" ]; then
            find . -type f -regextype awk -regex ".*/${2}" -exec printf '%s\n' '{}' + 2> /dev/null
        else
            printf 'ERROR: Parameters are missing or invalid!\n' >&2
        fi
    elif [ -n "${2:-}" ] && [ -d "$2" ]; then
        find "$2" -type f -regextype awk -regex ".*/${1}" -exec rm -f '{}' + 2> /dev/null
    else
        find . -type f -regextype awk -regex ".*/${1}" -exec rm -f '{}' + 2> /dev/null
    fi
}

searchInPath() {  # Search for a filename in $PATH
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
    else
        for searchIn in ${PATH//:/ }; do
            find "$searchIn" -mount -type f -name "$1" -exec printf '%s\n' '{}' +
        done
    fi
}
alias findinpath=searchInPath

searchInPkgPath() {  # Search for a filename in $PKG_CONFIG_PATH
    if [ -z "$1" ]; then
        printf 'ERROR: A parameter is required!\n' >&2
    else
        for searchIn in ${PKG_CONFIG_PATH//:/ }; do
            find "$searchIn" -mount -type f -name "$1" -exec printf '%s\n' '{}' +
        done
    fi
}

# Networking Functions

CheckForNetwork() {  # Determine if the network is up by looking for any non-loopback internet network interfaces
    if [ -z "${NETWORKUP:-}" ]; then
        test="$(ifconfig -a inet 2> /dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l)"
        if [ "${test}" -gt 0 ]; then
            NETWORKUP='-YES-'
        else
            NETWORKUP='-NO-'
        fi
    fi
    unset test
}

downloadtar() { wget -c "$1" -O - | tar -xz; }

# Process Control Functions

GetPID() {  # Return the PID of a process (if found)
    program="$1"
    pidfile="${PIDFILE:=/var/run/${program}.pid}"
    pid=''
    unset program
    if [ -r "$pidfile" ]; then
        pid="$(head -1 "$pidfile")"
        if [ ! "$(kill -0 "$pid" 2> /dev/null)" ]; then
            printf 'Bad pid file %s; deleting.\n' "$pidfile"
            pid=''
            rm -f "$pidfile"
        fi
    fi
    unset pidfile
    if [ -n "$pid" ]; then
        printf '%s\n' "$pid"
        unset pid
        return 0
    fi
    unset pid
    return 1
}

if [ -x "$(command -v ps)" ]; then
    pscpu10() { echo '  PID USER     TTY      STAT %CPU %MEM COMMAND' && ps -e -o pid,user,tname,stat,pcpu,pmem,comm | awk '{ if (NR != 1) { print } }' | sort -nr -k 5 | awk 'FNR <= 10' && echo '  PID USER     TTY      STAT %CPU %MEM COMMAND'; }
    psmem10() { echo '  PID USER     TTY      STAT %CPU %MEM COMMAND' && ps -e -o pid,user,tname,stat,pcpu,pmem,comm | awk '{ if (NR != 1) { print } }' | sort -nr -k 6 | awk 'FNR <= 10' && echo '  PID USER     TTY      STAT %CPU %MEM COMMAND'; }
fi

# System Control Functions

if [ -r /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor ]; then
    ampupcpu_helper() {  # Set the CPU to performance mode (helper function)
        for FILE in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
            [ ! -w "$FILE" ] && break
            [ -w "$FILE" ] && echo -n performance > "$FILE"
        done
    }
    ampupcpu() {  # Set the CPU to performance mode
        sudo -H sh -c "ampupcpu_helper"
    }
fi

chkhw() {  # Check hardware sensors
    [ -x "$(command -v inxi)" ] && inxi -B -s -x -x -x
    [ -x "$(command -v acpi)" ] && acpi -i -s -V
    [ -x "$(command -v nvidia-smi)" ] && nvidia-smi -q -d "POWER,TEMPERATURE" | awk 'NR > 6'
    [ -x "$(command -v sensors)" ] && sensors
}

[ -x "$(command -v systemctl)" ] && enabledservices() { systemctl list-unit-files | grep -F enabled | awk '{ print $1 }' | sort; }

if [ -n "$(command -v StartService)" ] && [ -n "$(command -v RestartService)" ]; then
    RunService() {  # Generic Action Handler
        case "$1" in
            start) StartService;;
            stop) StopService;;
            restart) RestartService;;
            *) printf '%s: unknown argument: %s\n' "$0" "$1";;
        esac
    }
fi

# Miscellaneous Functions

if [ -x "$(command -v awk)" ]; then
    cmdusage() {  # Create table listing command usage with percentages
        history | awk '{ CMD[$2]++; count++; } END { for (a in CMD) print CMD[a] " " CMD[a] / count * 100 "% " a; }' | grep -F -v './' | column -c3 -s ' ' -t | sort -n -r | nl | head -n10
    }

    colortest() {  # Test the terminal's ability to produce colors
        awk 'BEGIN {
            for (column = 0; column < 256; column++) {
                g = ((column * 510) / 255);
                if (g > 255) { g = 510 - g; }
                printf "\033[48;2;%d;%d;%dm%s\033[0m", 255 - column, g, column, " ";
            }
            printf "\n";
        }'
    }
fi

[ "$PLATFORM" = 'linux' ] && findmod() { find "/lib/modules/${KRELEASE}" | grep -F -i "$1"; }
lastval() { printf '%s\n' "$?"; }

if [ -x "$(command -v pathchk)" ]; then
    testpathnames() {  # Test if the files in the given directory are using Posix-compliant pathnames
        if [ -n "$1" ] && [ -d "$1" ]; then
            find "$1" -exec pathchk -p -P '{}' +
        else
            find ./ -exec pathchk -p -P '{}' +
        fi
    }
    validatepathnames() {  # Test if the files in the given directory are using valid pathnames
        if [ -n "$1" ] && [ -d "$1" ]; then
            find "$1" -exec pathchk '{}' +
        else
            find ./ -exec pathchk '{}' +
        fi
    }
fi

if [ -d /usr/share/nano ]; then
    lsnanolangs() {  # List all programming languages supported by Nano
        find /usr/share/nano/* -type f -name "*.nanorc" -exec printf "%s\n" '{}' +
    }
    refreshnanorc() {  # Regenerate the ALL.nanorc file
        find /usr/share/nano/* -type f -name "*.nanorc" -exec printf "include %s\n" '{}' + | sudo tee /usr/share/nano/ALL.nanorc
    }
elif [ -d /usr/local/share/nano ]; then
    lsnanolangs() {  # List all programming languages supported by Nano
        find /usr/local/share/nano/* -type f -name "*.nanorc" -exec printf "%s\n" '{}' +
    }
    refreshnanorc() {  # Regenerate the ALL.nanorc file
        find /usr/local/share/nano/* -type f -name "*.nanorc" -exec printf "include %s\n" '{}' + | sudo tee /usr/local/share/nano/ALL.nanorc
    }
fi

rndfname() { date +%Y%m%u%d%H%M%S%s%N; }  # Create a random filename

if [ -x "$(command -v gsettings)" ]; then
    setwallpaper() {  # Set the desktop wallpaper to the specified image
        if [ -z "$1" ]; then
            printf 'ERROR: A parameter is required!\n' >&2
        elif [ ! -r "$1" ]; then
            printf '%s: The specified file is non-readable or non-existent!\n' "$1" >&2
        else
            if ([ -n "${XDG_SESSION_DESKTOP:-}" ] && [ "$XDG_SESSION_DESKTOP" = 'mate' ]) || ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'MATE' ]); then  # Mate
                gsettings set org.mate.desktop.background picture-filename "$1"
                gsettings set org.mate.desktop.screensaver picture-uri "$1"
            elif ([ -n "${XDG_SESSION_DESKTOP:-}" ] && [ "$XDG_SESSION_DESKTOP" = 'gnome' ]) || ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'GNOME' ]); then  # GNOME
                gsettings set org.gnome.desktop.background picture-uri "$1"
                gsettings set org.gnome.desktop.screensaver picture-uri "$1"
            elif ([ -n "${XDG_CURRENT_DESKTOP:-}" ] && [ "$XDG_CURRENT_DESKTOP" = 'XFCE' ]); then  # XFCE
                xfconf-query --channel xfce4-desktop --property /backdrop/screen0/monitor0/image-path --set "$1"
            fi
        fi
    }
fi

if [ -x "$(command -v sqlite3)" ]; then
    sqlvacuum() {  # Vacuum the specified SQLite database files
        for file in "$@"; do
            if [ ! -r "$file" ]; then
                printf '%s: The specified file is non-readable or non-existent!\n' "$file" >&2 && continue
            else
                echo 'vacuum;' | sqlite3 "$file"
            fi
        done
    }
fi


# AUTOCOMPLETE #


if [ "$PROFILE_SHELL" = 'bash' ] && [ "$isinteractive" = 'true' ] && [ -n "$(command -v mapfile)" ] && [ -n "$(command -v complete)" ]; then
    # Source/Import the Bash autocompletion feature
    if [ -r /etc/bash_completion ]; then
        . /etc/bash_completion
    elif [ -r /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    fi
    # Autocomplete package names for the system's package installation, uninstallation, and reinstallation commands
    if [ -n "$(command -v pkglsall)" ] && [ -n "$(command -v pkginstall)" ]; then
        _pkginstall_autocomplete() { mapfile -t COMPREPLY < <(pkglsall "$2"); }
        if [ -n "$(command -v _pkginstall_autocomplete)" ]; then
            complete -F _pkginstall_autocomplete -o nospace pkginstall
            complete -F _pkginstall_autocomplete -o nospace pkguninstall
            complete -F _pkginstall_autocomplete -o nospace pkgreinstall
            readonly -f _pkginstall_autocomplete
        fi
    fi
    # Autocomplete Python package names for pip3
    if [ -n "$(command -v pip3)" ]; then
        _pip_tmp() { pip3 list --format=columns | awk '{ if (NR > 2) { print } }' | cut -d ' ' -f 1 | awk "/^${1}/"; }
        _pip3_autocomplete() { mapfile -t COMPREPLY < <(_pip_tmp "$2"); }
        if [ -n "$(command -v _pip3_autocomplete)" ]; then
            complete -F _pip3_autocomplete -o nospace pyinstall
            complete -F _pip3_autocomplete -o nospace pyreinstall
            complete -F _pip3_autocomplete -o nospace pyuninstall
            complete -F _pip3_autocomplete -o nospace pyupdate
            readonly -f _pip3_autocomplete
        fi
    fi
    # Autocomplete make targets
    if [ -n "$(command -v make)" ]; then
        _make_target_tmp() { make -pqs | sed '/^.+:=.*$/d; /^#.*$/d; /^\-.*$/d;' | grep -o -E '^[a-zA-Z0-9_\-]+:.*$' | cut -d ':' -f 1 | awk "/^${1}/"; }
        _make_target_autocomplete() { mapfile -t COMPREPLY < <(_make_target_tmp "$2"); }
        if [ -n "$(command -v _make_autocomplete)" ]; then
            complete -F _make_target_autocomplete -o nospace make
            readonly -f _make_target_autocomplete
        fi
    fi
fi


# LOAD USER'S SHELL STARTUP FILES #


[ -r "${HOME}/.bash_aliases" ] && . "${HOME}/.bash_aliases"
[ -r "${HOME}/.sh_aliases" ] && . "${HOME}/.sh_aliases"
[ "$PROFILE_SHELL" = 'bash' ] && [ -r "${HOME}/.bashrc" ] && . "${HOME}/.bashrc"
