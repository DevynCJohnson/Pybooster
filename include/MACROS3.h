// -*- coding: utf-8-unix; Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*-
// vim: set fileencoding=utf-8 filetype=c syntax=c.doxygen fileformat=unix tabstop=4 :
// kate: encoding utf-8; bom off; syntax c; indent-mode cstyle; eol unix; replace-tabs off; indent-width 4; tab-width 4; remove-trailing-space on;
/**
@brief Standard Macros Header with AT&T-style Assembly
@file MACROS3.h
@version 2019.03.28
@author Devyn Collier Johnson <DevynCJohnson@Gmail.com>
@copyright LGPLv3

@section DESCRIPTION
This file defines various datatypes, macros, functions, etc.
Substitutes for most standard C library functions are also provided.
 - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html

@section LICENSE
GNU Lesser General Public License v3
Copyright (c) Devyn Collier Johnson, All rights reserved.

This software is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This software is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this software.
*/


/* ATOMIC OPERATIONS (<stdatomic.h> & <atomic.h>) */


#if (!(defined(ATOMIC_H) || defined(_ATOMIC_H) || defined(_ATOMIC_H_) || defined(BITS_ATOMIC_H) || defined(_STDATOMIC_H) || defined(_STDATOMIC_H_) || defined(__CLANG_STDATOMIC_H) || defined(__CLANG_STDATOMIC_H_)))  // http://en.cppreference.com/w/c/atomic & http://www.cplusplus.com/reference/atomic/
#define ATOMIC_H   (1)
#define _ATOMIC_H   (1)
#define _ATOMIC_H_   (1)
#define _ATOMIC_MACHINE_H   (1)
#define __ASM_GENERIC_ATOMIC_H   (1)
#define _ASM_GENERIC_ATOMIC_H   (1)
#define _ASM_GENERIC_ATOMIC_H_   (1)
#define __ASM_GENERIC_ATOMIC64_H   (1)
#define _ASM_GENERIC_ATOMIC64_H   (1)
#define _ASM_GENERIC_ATOMIC64_H_   (1)
#define LIBATOMIC_H   (1)
#define _LIBATOMIC_H   (1)
#define _LIBATOMIC_H_   (1)
#define BITS_ATOMIC_H   (1)
#define _BITS_ATOMIC_H   (1)
#define _BITS_ATOMIC_H_   (1)
#define STDATOMIC_H   (1)
#define _STDATOMIC_H   (1)
#define __STDATOMIC_H   (1)
#define _STDATOMIC_H_   (1)
#define __CLANG_STDATOMIC_H   (1)
#define __CLANG_STDATOMIC_H_   (1)
#define _OS_OSATOMIC_H   (1)
#define _OS_OSATOMIC_H_   (1)
#define _I386_ATOMIC_H   (1)
#define _I386_ATOMIC_H_   (1)
#undef __NEED__Atomic
#undef NEED__Atomic


#if ATOMIC_DEBUG
#   define ALIGN_TEST(p, t)   do { if ((uintptr_t)p & (sizeof(t) - 1)) { panic("Unaligned atomic pointer %p!\n", p); } } while (0x0)
#else
#   define ALIGN_TEST(p, t)
#endif

enum atomic_mem_order {
#   undef __ATOMIC_RELAXED
	__ATOMIC_RELAXED = 0,
#   undef __ATOMIC_CONSUME
	__ATOMIC_CONSUME = 1,
#   undef __ATOMIC_ACQUIRE
	__ATOMIC_ACQUIRE = 2,
#   undef __ATOMIC_RELEASE
	__ATOMIC_RELEASE = 3,
#   undef __ATOMIC_ACQ_REL
	__ATOMIC_ACQ_REL = 4,
#   undef __ATOMIC_SEQ_CST
	__ATOMIC_SEQ_CST = 5,
#   undef __ATOMIC_HLE_ACQUIRE
	__ATOMIC_HLE_ACQUIRE = 65536,
#   undef __ATOMIC_HLE_RELEASE
	__ATOMIC_HLE_RELEASE = 131072
};
#define ATOMIC_RELAXED   __ATOMIC_RELAXED
#define ATOMIC_CONSUME   __ATOMIC_CONSUME
#define ATOMIC_ACQUIRE   __ATOMIC_ACQUIRE
#define ATOMIC_RELEASE   __ATOMIC_RELEASE
#define ATOMIC_ACQ_REL   __ATOMIC_ACQ_REL
#define ATOMIC_SEQ_CST   __ATOMIC_SEQ_CST
/** Start lock elision on a lock variable; Memory order must be `__ATOMIC_ACQUIRE` or stronger */
#define ATOMIC_HLE_ACQUIRE   __ATOMIC_HLE_ACQUIRE
/** End lock elision on a lock variable; Memory order must be `__ATOMIC_RELEASE` or stronger */
#define ATOMIC_HLE_RELEASE   __ATOMIC_HLE_RELEASE

/** Used as an argument to functions that conduct atomic operations to specify how other operations on different threads are synchronized */
typedef enum memory_order_enum {
	memory_order_relaxed = 0,  //!< ATOMIC_RELAXED
	memory_order_consume = 1,  //!< ATOMIC_CONSUME
	memory_order_acquire = 2,  //!< ATOMIC_ACQUIRE
	memory_order_release = 3,  //!< ATOMIC_RELEASE
	memory_order_acq_rel = 4,  //!< ATOMIC_ACQ_REL
	memory_order_seq_cst = 5,  //!< ATOMIC_SEQ_CST
	memory_order_hle_acquire = 65536,  //!< ATOMIC_HLE_ACQUIRE
	memory_order_hle_release = 131072  //!< ATOMIC_HLE_RELEASE
} memory_order;

#if IS_SMP
#   define memory_order_consume_smp   memory_order_consume
#   define memory_order_acquire_smp   memory_order_acquire
#   define memory_order_release_smp   memory_order_release
#   define memory_order_acq_rel_smp   memory_order_acq_rel
#   define memory_order_seq_cst_smp   memory_order_seq_cst
#else
#   define memory_order_consume_smp   memory_order_relaxed
#   define memory_order_acquire_smp   memory_order_relaxed
#   define memory_order_release_smp   memory_order_relaxed
#   define memory_order_acq_rel_smp   memory_order_relaxed
#   define memory_order_seq_cst_smp   memory_order_relaxed
#endif

#ifndef AO_HASH_SIZE
#   define AO_HASH_SIZE   (16)
#endif
#define AO_HASH(x)   (((unsigned long)(x) >> 12) & (AO_HASH_SIZE - 1))

/* Indicate that the given atomic-type is lock-free
 - 0 if the types are never lock-free
 - 1 it the types are sometimes lock-free
 - 2 if the types are always lock-free
*/
#if (defined(__GCC_ATOMIC_BOOL_LOCK_FREE) && defined(__GCC_ATOMIC_INT_LOCK_FREE))
#   define ATOMIC_BOOL_LOCK_FREE   __GCC_ATOMIC_BOOL_LOCK_FREE
#   define ATOMIC_CHAR_LOCK_FREE   __GCC_ATOMIC_CHAR_LOCK_FREE
#   define ATOMIC_CHAR16_T_LOCK_FREE   __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#   define ATOMIC_CHAR32_T_LOCK_FREE   __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#   define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#   define ATOMIC_SHORT_LOCK_FREE   __GCC_ATOMIC_SHORT_LOCK_FREE
#   define ATOMIC_INT_LOCK_FREE   __GCC_ATOMIC_INT_LOCK_FREE
#   define ATOMIC_LONG_LOCK_FREE   __GCC_ATOMIC_LONG_LOCK_FREE
#   define ATOMIC_LLONG_LOCK_FREE   __GCC_ATOMIC_LLONG_LOCK_FREE
#   define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
#else
#   define ATOMIC_BOOL_LOCK_FREE   2
#   define ATOMIC_CHAR_LOCK_FREE   2
#   define ATOMIC_CHAR16_T_LOCK_FREE   2
#   define ATOMIC_CHAR32_T_LOCK_FREE   2
#   define ATOMIC_WCHAR_T_LOCK_FREE   2
#   define ATOMIC_SHORT_LOCK_FREE   2
#   define ATOMIC_INT_LOCK_FREE   2
#   define ATOMIC_LONG_LOCK_FREE   2
#   define ATOMIC_LLONG_LOCK_FREE   2
#   define ATOMIC_POINTER_LOCK_FREE   2
#endif


// MISCELLANEOUS ATOMIC CONSTANTS

#ifdef ARCHARM
static const UNUSED void* __arm_atomics[3];
#endif


// ATOMIC MACROS FUNCTIONS

/** @def kill_dependency
Breaks a dependency chain for memory_order_consume */
#if IS_GNUC
#   define kill_dependency(x)   __extension__ ({ auto_type __kill_dependency_tmp = (x); __kill_dependency_tmp; })
#else
#   define kill_dependency(x)   do { typeof((x)) __kill_dependency_tmp = (x); __kill_dependency_tmp; } while (0x0)
#endif


/** @defgroup Atomic_Barriers_Macros Macros used to implement various atomic barriers
@{ */  // (FB){

/** A barrier to stop the optimizer from moving code or assuming live register values */
#define compiler_barrier()   vasm(";" : : : "memory")
/** A barrier to stop the optimizer from moving code or assuming live register values */
#define barrier_data(ptr)   vasm(";" : : "r,i,n"(ptr) : "memory")

/** @def math_opt_barrier
@brief Safely load x, even if it was manipulated by non-float-point operations. This macro returns the value of x. This ensures compiler does not abuse its knowledge about x value and not optimize future operations.

@code{.c}
float x;
SET_FLOAT_WORD(x, 0x80000001);  // Sets a bit pattern
y = math_opt_barrier(x);  // Prevents the compiler from using an alternative to multiplication
y = y * y;  // Compiler cannot optimize; must use real multiply instruction
@endcode
*/
/** @def math_force_eval
Force expression `x` to be evaluated; This macro returns no value */
#ifdef ARCHX86_32

#   define math_opt_barrier(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "=t,y"(__x) : "0"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ auto_type __x = (x); if (sizeof(__xx) >= SIZEOF_DOUBLE) { vasm(";" : : "m"(__x)); } else { vasm(";" : : "f"(__x)); } })
#   define raise_flag(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "=t,y"(__x) : "0"(__x)); __x *= __x; if (sizeof(__x) >= SIZEOF_DOUBLE) { vasm(";" : : "m"(__x)); } else { vasm(";" : : "f"(__x)); } })

#elif defined(ARCHX86_64)

#   define math_opt_barrier(x)   __extension__ ({ auto_type __x = (x); if (sizeof(__x) <= SIZEOF_DOUBLE) { vasm(";" : "=v,x,y"(__x) : "0"(__x)); } else { vasm(";" : "=t"(__x) : "0"(__x)); } __x; })
#   define math_force_eval(x)   __extension__ ({ auto_type __x = (x); if (sizeof(__x) >= SIZEOF_DOUBLE) { vasm(";" : : "v,x,y"(__x)); } else { vasm(";" : : "f"(__x)); } })
#   define raise_flag(x)   __extension__ ({ auto_type __x = (x); if (sizeof(__x) > SIZEOF_DOUBLE) { vasm(";" : : "m"(__x)); } else if (sizeof(__x) == SIZEOF_DOUBLE) { vasm(";" : : "v,x,y"(__x)); } else { vasm(";" : : "f"(__x)); } })

#elif defined(ARCHAARCH64)

#   define math_opt_barrier(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "+w"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ auto_type __x = (x); vasm(";" : : "w"(__x)); })

#elif defined(ARCHALPHA)

#   define math_opt_barrier(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "+frm"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ auto_type __x = (x); vasm(";" : : "frm"(__x)); })

#elif defined(ARCHM68K)

#   define math_opt_barrier(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "=f"(__x) : "0"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ auto_type __x = (x); if (sizeof(__x) <= SIZEOF_DOUBLE) { vasm(";" : : "m"(__x)); } else { vasm(";" : : "f"(__x)); } })

#else

#   define math_opt_barrier(x)   do { typeof(x) __x = (x); vasm(";" : "+m"(__x)); __x; } while (0x0)
#   define math_force_eval(x)   do { typeof(x) __x = (x); vasm(";" : : "m"(__x)); } while (0x0)

#endif  // Math barriers
#ifndef raise_flag
#   define raise_flag(x)   do { typeof(x) __x = (x); vasm(";" : "+m"(__x)); vasm(";" : : "m"(__x)); } while (0x0)
#endif
#ifndef FORCE_EVAL
#   define FORCE_EVAL(x)   math_force_eval((x))
#endif

/** @def do_sync
Memory Barrier */
#if defined(ARCHALPHA)
#   define do_sync()   vasm("mb;" : : : "memory")
#elif defined(ARM_7_SERIES)
#   define do_sync()   vasm("dmb sy;" : : : "memory")
#elif defined(ARM_6_SERIES)
#   define do_sync()   vasm("mcr p15, 0, %0, c7, c10, 5;" : : "rin"(0) : "memory")
#elif defined(ARCHARM)
#   define do_sync()   vasm("dmb;" : : : "memory")
#elif defined(ARCHPOWERPC64)
#   define do_sync()   vasm("lwsync;" : : : "memory")
#elif defined(ARCHPOWERPC32)
#   define do_sync()   vasm("isync; eieio;" : : : "memory")
#elif defined(ARCHMIPS)
#   define do_sync()   vasm(".long 0xf;" : : : "memory")
#elif defined(ARCHSPARC)
#   define do_sync()   vasm("membar;" : : : "memory")
#elif defined(ARCHX86)
#   define do_sync()   vasm("mfence;" : : : "memory")
#else
#   define do_sync()   vasm(";" : : : "memory")
#endif
#define a_barrier_DEFINED
/** @def __sync_synchronize
Memory Barrier */
#ifndef __sync_synchronize
#   define __sync_synchronize()   do_sync()
#endif
/** @def OSMemoryBarrier
Memory Barrier */
#ifndef OSMemoryBarrier
#   define OSMemoryBarrier()   do_sync()
#endif
/** @def barrier
Memory Barrier */
#ifndef barrier
#   define barrier()   do_sync()
#endif
/** @def a_barrier
Memory Barrier */
#ifndef a_barrier
#   define a_barrier()   do_sync()
#endif
/** @def a_pre_llsc
Memory Barrier */
#ifndef a_pre_llsc
#   define a_pre_llsc()   do_sync()
#endif
/** @def a_post_llsc
Memory Barrier */
#ifndef a_post_llsc
#   define a_post_llsc()   do_sync()
#endif
/** @def atomic_full_barrier
Memory Barrier */
#ifndef atomic_full_barrier
#   define atomic_full_barrier()   do_sync()
#endif
/** @def atomic_read_barrier
Memory Barrier */
#ifndef atomic_read_barrier
#   define atomic_read_barrier()   do_sync()
#endif
/** @def atomic_write_barrier
Memory Barrier */
#ifndef atomic_write_barrier
#   define atomic_write_barrier()   do_sync()
#endif
/** Memory Barrier */
#define atomic_thread_fence(order)   do_sync()
/** Memory Barrier */
#define __atomic_thread_fence(order)   do_sync()
/** Memory Barrier */
#define __c11_atomic_thread_fence(order)   do_sync()

/** @def insn_barrier
Instruction Barrier */
#ifdef ARCHARM
#   define insn_barrier()   vasm("isb;" : : : "memory")
#elif defined(ARCHPOWERPC)
#   define insn_barrier()   vasm("isync;" : : : "memory")
#else
#   define insn_barrier()   vasm(";" : : : "memory")
#endif
/** @def isync
Instruction Barrier */
#ifndef isync
#   define isync()   insn_barrier()
#endif

/** Fence between a thread and a signal handler executed in the same thread */
#define atomic_signal_fence(order)   insn_barrier(); do_sync()
/** Fence between a thread and a signal handler executed in the same thread */
#define __atomic_signal_fence(order)   insn_barrier(); do_sync()
/** Fence between a thread and a signal handler executed in the same thread */
#define __c11_atomic_signal_fence(order)   insn_barrier(); do_sync()

/** @} */  // }


/** @def flush_cache
Flush internal processor cache */
#ifdef ARCHARM
#   define flush_cache()   vasm("dsb;" : : : "memory")
#elif defined(ARCHX86)
#   define flush_cache()   vasm("invd;" : : : "memory")
#else
#   define flush_cache()   vasm(";" : : : "memory")
#endif


/** @def nop
No-Operation (Null command) */
#ifndef nop
#   ifdef ARCHMIPS
#      define nop()   vasm("noop;" : : : "memory")
#   else
#      define nop()   vasm("nop;" : : : "memory")
#   endif
#endif
/** @def nop2
No-Operation (Null command) */
#ifndef nop2
#   ifdef ARCHMIPS
#      define nop2()   vasm("noop;" "noop;" : : : "memory")
#   else
#      define nop2()   vasm("nop;" "nop;" : : : "memory")
#   endif
#endif
/** @def noop
No-Operation (Null command) */
#ifndef noop
#   define noop()   nop()
#endif
/** @def Xyzzy
No-Operation (Null command) */
#ifndef Xyzzy
#   define Xyzzy   nop()
#endif
/** @def xyzzy
No-Operation (Null command) */
#ifndef xyzzy
#   define xyzzy   nop()
#endif
/** @def XYZZY
No-Operation (Null command) */
#ifndef XYZZY
#   define XYZZY   nop()
#endif
/** @def xYzZY
No-Operation (Null command) */
#ifndef xYzZY
#   define xYzZY   nop()
#endif
/** @def atomic_delay
Delayed NOP; No-Operation (Null command) */
#ifndef atomic_delay
#   define atomic_delay()   vasm(";" : : : "memory"); nop()
#endif


/** @def atomic_forced_read
Atomic Read */
#ifndef atomic_forced_read
#   if IS_GNUC
#      define atomic_forced_read(x)   __extension__ ({ auto_type __x = (x); vasm(";" : "=r"(__x) : "0"(__x)); __x; })
#   else
#      define atomic_forced_read(x)   do { typeof(x) __x; vasm(";" : "=r"(__x) : "0"(x)); __x; } while (0x0)
#   endif
#endif


/** @def a_spin
Atomic spin-lock */
#ifdef ARCHX86
#   define a_spin()   vasm("pause;" : : : "memory")
#else
#   define a_spin()   do_sync()
#endif


/** @def a_crash
Atomic crash */
#ifdef ARCHX86
#   define a_crash()   vasm("hlt;" : : : "memory")
#elif (defined(ARCHARM) && (!defined(ARM_THUMB)))
#   define a_crash()   vasm(".word 0xe7f000f0;" : : : "memory")
#elif (defined(ARCHARM) && defined(ARM_THUMB))
#   define a_crash()   vasm(".short 0xdeff;" : : : "memory")
#else
#   define a_crash()   insn_barrier(); ABORT_INSTRUCTION
#endif


/** Indicates whether the atomic object is lock-free */
#define atomic_is_lock_free(obj)   TRUE
/** Indicates whether the atomic object is lock-free */
#define __atomic_is_lock_free(obj)   TRUE
/** Indicates whether the atomic object is lock-free */
#define __c11_atomic_is_lock_free(obj)   TRUE


/** Atomically retrieve a value from a pointer */
#define __generic_a_load(ptr, val)   do_sync(); (val) = *(ptr); do_sync()
/** Compare and exchange a value and return a boolean indicating success */
#define __generic_cmpxchg_bool(ptr, oldval)   do_sync(); if (*ptr == oldval) { *ptr = newval; return TRUE; } else { return FALSE; } do_sync()
/** Compare and exchange a value */
#define __generic_cmpxchg(ptr, oldval)   do_sync(); if (*ptr == oldval) { *ptr = newval; return oldval; } else { return *ptr; } do_sync()


// ATOMIC FUNCTIONS

/** Atomically load `*ptr` */
LIB_FUNC NONNULL int a_load(volatile int* restrict ptr) {
	register int val = 0;
#   ifdef ARCHX86
	do_sync();
	vasm("xorl %1, %0;" : "+r"(val) : "m"(*ptr));
#   elif (defined(ARCHARM) && ((defined(ARM_6_SERIES) && (!defined(ARM_THUMB))) || defined(ARM_7_SERIES)))
	vasm("ldrex %0, %1;" : "=r"(val) : "Q"(*p));
#   elif defined(ARCHMIPS)
#      if (MIPS_REV < 6)
	vasm(".set push;" ".set mips2;" "ll %0, %1;" ".set pop;" : "=r"(val) : "m"(*p));
#      else
	vasm("ll %0, %1;" : "=r"(val) : "m"(*p));
#      endif  // MIPS
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}
/** Atomically load-link */
#define a_ll(ptr)   a_load((ptr))
/** Reads a value from an atomic object */
#define atomic_load_explicit(ptr, order)   a_load((ptr))
/** Reads a value from an atomic object */
#define atomic_load(ptr)   a_load((ptr))


/** Atomically load `*ptr` */
LIB_FUNC NONNULL long a_loadl(volatile long* restrict ptr) {
	register long val = 0;
#   ifdef ARCHX86
	do_sync();
#      if LONG_EQ_32BITS
	vasm("xorl %1, %0;" : "+r"(val) : "m"(*ptr));
#      elif LONG_EQ_64BITS
	vasm("xorq %1, %0;" : "+r"(val) : "m"(*ptr));
#      endif
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}


/** Atomically load `*ptr` */
LIB_FUNC NONNULL uint8_t a_load8(volatile uint8_t* restrict ptr) {
	register uint8_t val = 0;
#   ifdef ARCHX86
	do_sync();
	vasm("xorb %1, %0;" : "+r"(val) : "m"(*ptr));
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}


/** Atomically load `*ptr` */
LIB_FUNC NONNULL uint16_t a_load16(volatile uint16_t* restrict ptr) {
	register uint16_t val = 0;
#   ifdef ARCHX86
	do_sync();
	vasm("xorw %1, %0;" : "+r"(val) : "m"(*ptr));
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}


/** Atomically load `*ptr` */
LIB_FUNC NONNULL uint32_t a_load32(volatile uint32_t* restrict ptr) {
	register uint32_t val = 0;
#   ifdef ARCHX86
	do_sync();
	vasm("xorl %1, %0;" : "+r"(val) : "m"(*ptr));
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}


/** Atomically load `*ptr` */
LIB_FUNC NONNULL uint64_t a_load64(volatile uint64_t* restrict ptr) {
	register uint64_t val = 0;
#   ifdef ARCHX86
	do_sync();
	vasm("xorq %1, %0;" : "+r"(val) : "m"(*ptr));
#   else
	__generic_a_load(ptr, val);
#   endif
	return val;
}


/** Atomically Load-link */
LIB_FUNC NONNULL int a_ll_p(volatile int* restrict p) {
#   ifdef ARCHMIPS
	register int val = 0;
#      if (MIPS_REV < 6)
	vasm(".set push;" ".set mips2;" "ll %0, %1;" ".set pop;" : "=r"(v) : "m"(*p));
#      else
	vasm("ll %0, %1;" : "=r"(val) : "m"(*p));
#      endif  // MIPS
	return val;
#   else
	return a_load(p);
#   endif
}


/** Atomically Load-link */
LIB_FUNC NONNULL long a_ll_pl(volatile long* restrict p) {
#   ifdef ARCHMIPS
	register int v;
#      if (MIPS_REV < 6)
	vasm(".set push;" ".set mips2;" "lld %0, %1;" ".set pop;" : "=r"(v) : "m"(*p));
#      else
	vasm("lld %0, %1;" : "=r"(v) : "m"(*p));
#      endif  // MIPS
	return v;
#   else
	return a_loadl(p);
#   endif
}


#undef __generic_a_load


/** Atomically store `val` in `*ptr` */
LIB_FUNC NONNULL void a_store(volatile int* restrict ptr, const int val) {
#   ifdef ARCHX86
	register int tmp = val;
	vasm("lock xchgl %0, %1;" : "=r"(tmp), "+m"(*ptr) : "0"(tmp) : "memory");
#   else
	do_sync();
	while ((*ptr = val) != val);
	do_sync();
#   endif
}
/** Stores a value in an atomic object */
#define atomic_store_explicit(ptr, val, order)   a_store((ptr), (val))
/** Stores a value in an atomic object */
#define atomic_store(ptr, val)   a_store((ptr), (val))
/** Stores a value in an atomic object */
#define atomic_set(ptr, val)   a_store((ptr), (val))


/** Atomically store `val` in `*ptr` */
LIB_FUNC NONNULL void a_storel(volatile long* restrict ptr, const long val) {
#   ifdef ARCHX86
	register long tmp = val;
#      if LONG_EQ_32BITS
	vasm("lock xchgl %0, %1;" : "=r"(tmp), "+m"(*ptr) : "0"(tmp) : "memory");
#      elif LONG_EQ_64BITS
	vasm("lock xchgq %0, %1;" : "=r"(tmp), "+m"(*ptr) : "0"(tmp) : "memory");
#      endif
#   else
	do_sync();
	while ((*ptr = val) != val);
	do_sync();
#   endif
}


/** Atomic Store-conditional */
LIB_FUNC NONNULL int a_sc(volatile int* restrict p, const int v) {
#   ifdef ARCHMIPS
	register int r;
#      if (MIPS_REV < 6)
	vasm(".set push;" ".set mips2;" "sc %0, %1;" ".set pop;" : "=r"(r), "=m"(*p) : "0"(v) : "memory");
#      else
	vasm("sc %0, %1;" : "=r"(r), "=m"(*p) : "0"(v) : "memory");
#      endif  // MIPS
	return r;
#   elif (defined(ARCHARM) && ((defined(ARM_6_SERIES) && (!defined(ARM_THUMB))) || defined(ARM_7_SERIES)))
	register int r;
	vasm("strex %0, %2, %1;" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
	return !r;
#   elif (defined(ARCHARM) && defined(ARM_8_SERIES))
	register int r;
	vasm("stxr %0, %2, %1;" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
	return !r;
#   else
	a_store(p, v);
	return v;
#   endif
}


/** Atomic Store-conditional */
LIB_FUNC NONNULL int a_sc_p(volatile void* restrict p, void* restrict v) {
#   ifdef ARCHMIPS
	register int r;
#      if (MIPS_REV < 6)
	vasm(".set push;" ".set mips2;" "scd %0, %1;" ".set pop;" : "=r"(r), "=m"(*p) : "0"(v) : "memory");
#      else
	vasm("scd %0, %1;" : "=r"(r), "=m"(*p) : "0"(v) : "memory");
#      endif  // MIPS
	return r;
#   else
	do_sync();
	a_storel((volatile long*)p, (long)(*(volatile long*)v));
	return (int)(*(int*)v);
#   endif
}


/** Atomically set `*ptr` to zero */
LIB_FUNC NONNULL void a_zero(volatile int* restrict ptr) {
#   ifdef ARCHX86
	do_sync();
	vasm("xorl $0, %0;" : "+m"(*ptr) : : "memory");
#   else
	do_sync();
	while ((*ptr = 0) != 0);
	do_sync();
#   endif
}
/** Atomically set `*ptr` to zero */
#define atomic_flag_clear(ptr)   a_zero((ptr))
/** Atomically set `*ptr` to zero */
#define __atomic_clear(ptr)   a_zero((ptr))
/** Atomically set `*ptr` to zero */
#define atomic_flag_clear_explicit(ptr, order)   a_zero((ptr))


/** Atomically set `*ptr` to zero */
LIB_FUNC NONNULL void a_zerol(volatile long* restrict ptr) {
#   ifdef ARCHX86
	do_sync();
#      if LONG_EQ_32BITS
	vasm("xorl $0, %0;" : "+m"(*ptr) : : "memory");
#      elif LONG_EQ_64BITS
	vasm("xorq $0, %0;" : "+m"(*ptr) : : "memory");
#      endif
#   else
	do_sync();
	while ((*ptr = 0) != 0);
	do_sync();
#   endif
}


/** Atomic Compare-And-Swap (Boolean) */
LIB_FUNC NONNULL bool cmpxchg_bool(volatile int* restrict ptr, const int oldval, const int newval) {
#   ifdef ARCHX86
	register int ret;
	vasm("lock cmpxchgl %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	if (ret == oldval) { return TRUE; }
	return FALSE;
#   else
	__generic_cmpxchg_bool(ptr, oldval);
#   endif
}
#define atomic_compare_and_exchange_bool(ptr, oldval, newval)   cmpxchg_bool((ptr), (oldval), (newval))
#define atomic_compare_and_exchange_bool_acq(ptr, oldval, newval)   cmpxchg_bool((ptr), (oldval), (newval))
#define atomic_compare_and_exchange_bool_rel(ptr, oldval, newval)   cmpxchg_bool((ptr), (oldval), (newval))


/** Atomic Compare-And-Swap (Boolean) */
LIB_FUNC NONNULL bool cmpxchg8_bool(volatile uint8_t* restrict ptr, const uint8_t oldval, const uint8_t newval) {
#   ifdef ARCHX86
	register uint8_t ret;
	vasm("lock cmpxchgb %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	if (ret == oldval) { return TRUE; }
	return FALSE;
#   else
	__generic_cmpxchg_bool(ptr, oldval);
#   endif
}
#define cmpxchgb_bool(ptr, oldval, newval)   cmpxchg8_bool((volatile uint8_t*)(ptr), (uint8_t)(oldval), (uint8_t)(newval))


/** Atomic Compare-And-Swap (Boolean) */
LIB_FUNC NONNULL bool cmpxchg16_bool(volatile uint16_t* restrict ptr, const uint16_t oldval, const uint16_t newval) {
#   ifdef ARCHX86
	register uint16_t ret;
	vasm("lock cmpxchgw %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	if (ret == oldval) { return TRUE; }
	return FALSE;
#   else
	__generic_cmpxchg_bool(ptr, oldval);
#   endif
}
#define cmpxchgw_bool(ptr, oldval, newval)   cmpxchg16_bool((volatile uint16_t*)(ptr), (uint16_t)(oldval), (uint16_t)(newval))


/** Atomic Compare-And-Swap (Boolean) */
LIB_FUNC NONNULL bool cmpxchg32_bool(volatile uint32_t* restrict ptr, const uint32_t oldval, const uint32_t newval) {
#   ifdef ARCHX86
	register uint32_t ret;
	vasm("lock cmpxchgl %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	if (ret == oldval) { return TRUE; }
	return FALSE;
#   else
	__generic_cmpxchg_bool(ptr, oldval);
#   endif
}
#define cmpxchgl_bool(ptr, oldval, newval)   cmpxchg32_bool((volatile uint32_t*)(ptr), (uint32_t)(oldval), (uint32_t)(newval))


/** Atomic Compare-And-Swap (Boolean) */
LIB_FUNC NONNULL bool cmpxchg64_bool(volatile uint64_t* restrict ptr, const uint64_t oldval, const uint64_t newval) {
#   ifdef ARCHX86
	register uint64_t ret;
	vasm("lock cmpxchgq %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	if (ret == oldval) { return TRUE; }
	return FALSE;
#   else
	do_sync();
	__generic_cmpxchg_bool(ptr, oldval);
#   endif
}
#define cmpxchgq_bool(ptr, oldval, newval)   cmpxchg64_bool((volatile uint64_t*)(ptr), (uint64_t)(oldval), (uint64_t)(newval))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL int cmpxchg(volatile int* restrict ptr, const int oldval, const int newval) {
#   ifdef ARCHX86
	register int ret;
	vasm("lock cmpxchgl %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	return ret;
#   else
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define __CAS_int(ptr, oldval, newval)   (int)cmpxchg((ptr), (oldval), (newval))
#define a_cas(ptr, oldval, newval)   (int)cmpxchg((ptr), (oldval), (newval))
/** Atomically compare and exchange value */
#define os_atomic_cmpxchg(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define compare_and_swap(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __compare_and_swap(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __sync_bool_compare_and_swap(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __atomic_bool_compare_swap(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_exchange(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_exchange_strong(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_exchange_strong_explicit(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_exchange(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_exchange_strong(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_exchange_strong_explicit(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __atomic_compare_exchange(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __atomic_compare_exchange_strong(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __atomic_compare_exchange_strong_explicit(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define __c11_atomic_compare_exchange(ptr, oldval, newval, order)   cmpxchg((ptr), (oldval), (newval))
#define __c11_atomic_compare_exchange_strong(ptr, oldval, newval, order)   cmpxchg((ptr), (oldval), (newval))
#define __c11_atomic_compare_exchange_strong_explicit(ptr, oldval, newval, order)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_exchange_weak(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_exchange_weak_explicit(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_and_exchange_val_rel(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_and_exchange_val_acq(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define atomic_compare_and_exchange_val(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_and_exchange_val_rel(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_and_exchange_val_acq(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define catomic_compare_and_exchange_val(ptr, oldval, newval)   cmpxchg((ptr), (oldval), (newval))
#define a_testandset(ptr)   (!(cmpxchg((volatile int*)(ptr), 0, 1)))
#define testandset(ptr)   a_testandset((ptr))
#define __testandset(ptr)   a_testandset((ptr))
#define atomic_test_and_set(ptr)   a_testandset((ptr))
#define __atomic_test_and_set(ptr)   a_testandset((ptr))
#define atomic_flag_test_and_set(ptr)   a_testandset((ptr))
#define atomic_flag_test_and_set_explicit(ptr, order)   a_testandset((ptr))
#define atomic_flag_test_and_set_explicit_acq(ptr, order)   a_testandset((ptr))
#define atomic_flag_test_and_set_explicit_rel(ptr, order)   a_testandset((ptr))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL uint8_t cmpxchg8(volatile uint8_t* restrict ptr, const uint8_t oldval, const uint8_t newval) {
#   ifdef ARCHX86
	register uint8_t ret;
	vasm("lock cmpxchgb %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	return ret;
#   else
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define cmpxchgb(ptr, oldval, newval)   cmpxchg8((volatile uint8_t*)(ptr), (uint8_t)(oldval), (uint8_t)(newval))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL uint16_t cmpxchg16(volatile uint16_t* restrict ptr, const uint16_t oldval, const uint16_t newval) {
#   ifdef ARCHX86
	register uint16_t ret;
	vasm("lock cmpxchgw %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	return ret;
#   else
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define cmpxchgw(ptr, oldval, newval)   cmpxchg16((volatile uint16_t*)(ptr), (uint16_t)(oldval), (uint16_t)(newval))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL uint32_t cmpxchg32(volatile uint32_t* restrict ptr, const uint32_t oldval, const uint32_t newval) {
#   ifdef ARCHX86
	register uint32_t ret;
	vasm("lock cmpxchgl %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	return ret;
#   else
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define cmpxchgl(ptr, oldval, newval)   cmpxchg32((volatile uint32_t*)(ptr), (uint32_t)(oldval), (uint32_t)(newval))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL uint64_t cmpxchg64(volatile uint64_t* restrict ptr, const uint64_t oldval, const uint64_t newval) {
#   ifdef ARCHX86
	register uint64_t ret;
	vasm("lock cmpxchgq %2, %1;" : "=a"(ret), "+m"(*ptr)  : "r,i,n"(newval), "0"(oldval) : "memory");
	return ret;
#   else
	do_sync();
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define cmpxchgq(ptr, oldval, newval)   cmpxchg64((volatile uint64_t*)(ptr), (uint64_t)(oldval), (uint64_t)(newval))


/** Atomic Compare-And-Swap */
LIB_FUNC NONNULL size_t __CAS(volatile size_t* restrict ptr, const size_t oldval, const size_t newval) {
#   if SIZE_T_EQ_32BITS
	return cmpxchg32((volatile uint32_t*)ptr, (uint32_t)oldval, (uint32_t)newval);
#   elif SIZE_T_EQ_64BITS
	return cmpxchg64((volatile uint64_t*)ptr, (uint64_t)oldval, (uint64_t)newval);
#   else
	__generic_cmpxchg(ptr, oldval);
#   endif
}
#define cmpxchgsz(ptr, oldval, newval)   __CAS((volatile size_t*)(ptr), (size_t)(oldval), (size_t)(newval))


LIB_FUNC NONNULL void* a_cas_p(volatile void* ptr, void* oldval, void* restrict newval) {
#   ifdef ARCHX86
	vasm("lock cmpxchgl %2, %1;" : "=a"(oldval), "+m"(ptr) : "r,i,n"(newval), "0"(oldval) : "memory");
	return oldval;
#   else
	do_sync();
	if (*ptr == *oldval) {
		*ptr = *newval;
		return oldval;
	} else { return ptr; }
	do_sync();
#   endif
}
#define atomic_cmpxchg(val, old, new)   a_cas_p((val), (old), (new))


/** Atomically exchange/swap the values in two variables */
LIB_FUNC NONNULL int xchg(volatile int* restrict ptr, const int newval) {
#   ifdef ARCHX86
	register int val = newval;
	vasm("lock xchgl %0, %1;" : "=r"(val), "+m"(*ptr) : "0"(val) : "memory");
	return val;
#   else
	do_sync();
	const int old = *ptr;
	while (!(cmpxchg_bool(ptr, old, newval)));
	do_sync();
	return old;
#   endif
}
#define a_swap(ptr, newval)   xchg((ptr), (newval))
#define atomic_swap(newval, ptr)   xchg((newval), (ptr))
#define __atomic_swap(newval, ptr)   xchg((newval), (ptr))
#define atomic_xchg(ptr, newval)   xchg((ptr), (newval))
#define atomic_exchange(ptr, val)   xchg((ptr), (val))
#define atomic_exchange_rel(ptr, val)   xchg((ptr), (val))
#define atomic_exchange_acq(ptr, val)   xchg((ptr), (val))
#define atomic_exchange_explicit(ptr, val, order)   xchg((ptr), (val))


/** Atomically exchange/swap the values in two variables */
LIB_FUNC NONNULL uint8_t xchg8(volatile uint8_t* restrict ptr, const uint8_t newval) {
#   ifdef ARCHX86
	register uint8_t val = newval;
	vasm("lock xchgb %0, %1;" : "=r"(val), "+m"(*ptr) : "0"(val) : "memory");
	return val;
#   else
	do_sync();
	const uint8_t old = *ptr;
	while (!(cmpxchg8_bool(ptr, old, newval)));
	do_sync();
	return old;
#   endif
}
#define xchgb(ptr, newval)   xchg8((ptr), (newval))
#define __arch_exchange_8_int(ptr, newval)   xchg8((ptr), (newval))


/** Atomically exchange/swap the values in two variables */
LIB_FUNC NONNULL uint16_t xchg16(volatile uint16_t* restrict ptr, const uint16_t newval) {
#   ifdef ARCHX86
	register uint16_t val = newval;
	vasm("lock xchgw %0, %1;" : "=r"(val), "+m"(*ptr) : "0"(val) : "memory");
	return val;
#   else
	do_sync();
	const uint16_t old = *ptr;
	while (!(cmpxchg16_bool(ptr, old, newval)));
	do_sync();
	return old;
#   endif
}
#define xchgw(ptr, newval)   xchg16((ptr), (newval))
#define __arch_exchange_16_int(ptr, newval)   xchg16((ptr), (newval))


/** Atomically exchange/swap the values in two variables */
LIB_FUNC NONNULL uint32_t xchg32(volatile uint32_t* restrict ptr, const uint32_t newval) {
#   ifdef ARCHX86
	register uint32_t val = newval;
	vasm("lock xchgl %0, %1;" : "=r"(val), "+m"(*ptr) : "0"(val) : "memory");
	return val;
#   else
	do_sync();
	const uint32_t old = *ptr;
	while (!(cmpxchg32_bool(ptr, old, newval)));
	do_sync();
	return old;
#   endif
}
#define xchgl(ptr, newval)   xchg32((ptr), (newval))
#define __arch_exchange_32_int(ptr, newval)   xchg32((ptr), (newval))


/** Atomically exchange/swap the values in two variables */
LIB_FUNC NONNULL uint64_t xchg64(volatile uint64_t* restrict ptr, const uint64_t newval) {
#   ifdef ARCHX86
	register uint64_t val = newval;
	vasm("lock xchgq %0, %1;" : "=r"(val), "+m"(*ptr) : "0"(val) : "memory");
	return val;
#   else
	do_sync();
	const uint64_t old = *ptr;
	while (!(cmpxchg64_bool(ptr, old, newval)));
	do_sync();
	return old;
#   endif
}
#define xchgq(ptr, newval)   xchg64((ptr), (newval))
#define __arch_exchange_64_int(ptr, newval)   xchg64((ptr), (newval))


/** Atomic addition and return value */
LIB_FUNC NONNULL int a_fetch_add(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	register int v = val;
	vasm("lock xaddl %0, %1;" : "=r"(v), "+m"(*p) : "0"(v) : "memory");
	return v;
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old + val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#   endif
}
/** Atomic addition and return value */
#define __atomic_fetch_add(ptr, val)   a_fetch_add((ptr), (val))
#define __c11_atomic_fetch_add(ptr, val, order)   a_fetch_add((ptr), (val))
#define atomic_fetch_add(ptr, val)   a_fetch_add((ptr), (val))
#define __sync_fetch_and_add(ptr, val)   a_fetch_add((ptr), (val))
#define atomic_fetch_add_explicit(ptr, val, order)   a_fetch_add((ptr), (val))


LIB_FUNC NONNULL size_t __atomic_add(volatile size_t* restrict p, const size_t val) {
#   if SIZE_T_EQ_32BITS
#      ifdef ARCHX86
	register size_t v = val;
	vasm("lock xaddl %0, %1;" : "=r"(v), "+m"(*p) : "0"(v) : "memory");
	return v;
#      else
	do_sync();
	const size_t old = *p;
	const size_t newval = (size_t)(old + val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#      endif
#   elif SIZE_T_EQ_64BITS
#      ifdef ARCHX86
	register size_t v = val;
	vasm("lock xaddq %0, %1;" : "=r"(v), "+m"(*p) : "0"(v) : "memory");
	return v;
#      else
	do_sync();
	const size_t old = *p;
	const size_t newval = (size_t)(old + val);
	while (cmpxchg64(p, old, newval) != old);
	do_sync();
	return old;
#      endif
#   else
#      error   "__atomic_add() is not supported on the target platform!"
#   endif
}


LIB_FUNC NONNULL int atomic_add_return(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old + i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
	return newval;
}


/** Atomic Addition */
LIB_FUNC NONNULL void a_add(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	vasm("lock addl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old + val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void a_add_neg(volatile int* restrict p, const int val) {
	do_sync();
	const int old = *p;
	const int newval = (int)(-val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
}
#define atomic_add_negative(ptr, val)   a_add_neg((ptr), (val))


LIB_FUNC NONNULL int a_fetch_sub(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	do_sync();
	const int old = *p;
	vasm("lock subl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return old;
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old - val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#   endif
}
#define atomic_fetch_sub(ptr, val)   a_fetch_sub((ptr), (val))
#define __sync_fetch_and_sub(ptr, val)   a_fetch_sub((ptr), (val))
#define atomic_fetch_sub_explicit(ptr, val, order)   a_fetch_sub((ptr), (val))


LIB_FUNC NONNULL size_t __atomic_sub(volatile size_t* restrict p, const size_t val) {
#   if SIZE_T_EQ_32BITS
#      ifdef ARCHX86
	do_sync();
	const size_t old = *p;
	vasm("lock subl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return old;
#      else
	do_sync();
	const size_t old = *p;
	const size_t newval = (size_t)(old - val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#      endif
#   elif SIZE_T_EQ_64BITS
#      ifdef ARCHX86
	do_sync();
	const size_t old = *p;
	vasm("lock subq %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return old;
#      else
	do_sync();
	const size_t old = *p;
	const size_t newval = (size_t)(old - val);
	while (cmpxchg64(p, old, newval) != old);
	do_sync();
	return old;
#      endif
#   else
#      error   "__atomic_sub() is not supported on the target platform!"
#   endif
}


LIB_FUNC NONNULL int atomic_sub_return(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old - i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
	return newval;
}


/** Atomic Subtraction */
LIB_FUNC NONNULL void a_sub(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	vasm("lock subl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old - val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL int atomic_mul_return(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old * i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
	return newval;
}


LIB_FUNC NONNULL int atomic_div_return(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old / i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
	return newval;
}


LIB_FUNC NONNULL int atomic_mod_return(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old % i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
	return newval;
}


LIB_FUNC NONNULL int a_fetch_and(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	do_sync();
	vasm("lock andl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return *p;
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old & val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#   endif
}
#define atomic_fetch_and(ptr, val)   a_fetch_and((ptr), (val))
#define __c11_atomic_fetch_and(ptr, val, order)   a_fetch_and((ptr), (val))
#define __atomic_fetch_and(ptr, val)   a_fetch_and((ptr), (val))
#define atomic_fetch_and_explicit(ptr, val, order)   a_fetch_and((ptr), (val))


/** Atomic AND */
LIB_FUNC NONNULL void a_and(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	vasm("lock andl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old & val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void a_and_64(volatile uint64_t* restrict p, const uint64_t val) {
#   ifdef ARCHX86
	vasm("lock andq %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const uint64_t old = *p;
	const uint64_t newval = (uint64_t)(old & val);
	while (cmpxchg64(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void atomic_andop(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old & i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
}
#define atomic_clear_mask(i, val)   atomic_and((~(i)), (val))


LIB_FUNC NONNULL int a_fetch_or(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	do_sync();
	vasm("lock orl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return *p;
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old | val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#   endif
}
#define atomic_fetch_or(ptr, val)   a_fetch_or((ptr), (val))
#define __c11_atomic_fetch_or(ptr, val, order)   a_fetch_or((ptr), (val))
#define __atomic_fetch_or(ptr, val)   a_fetch_or((ptr), (val))
#define atomic_fetch_or_explicit(ptr, val, order)   a_fetch_or((ptr), (val))


/** Atomic OR */
LIB_FUNC NONNULL void a_or(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	vasm("lock orl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old | val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void a_or_64(volatile uint64_t* restrict p, const uint64_t val) {
#   ifdef ARCHX86
	vasm("lock orq %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const uint64_t old = *p;
	const uint64_t newval = (uint64_t)(old | val);
	while (cmpxchg64(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void a_or_l(volatile void* restrict p, const long val) {
#   if LONG_EQ_INT
	a_or((volatile int*)p, (int)val);
#   else
	a_or_64((volatile uint64_t*)p, (uint64_t)val);
#   endif
}


LIB_FUNC NONNULL void atomic_orop(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old | i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
}
#define atomic_set_mask(i, vval)   atomic_or((i), (val))


LIB_FUNC NONNULL int a_fetch_xor(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	do_sync();
	vasm("lock xorl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
	return *p;
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old ^ val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
	return old;
#   endif
}
#define atomic_fetch_xor(ptr, val)   a_fetch_xor((ptr), (val))
#define __c11_atomic_fetch_xor(ptr, val, order)   a_fetch_xor((ptr), (val))
#define __atomic_fetch_xor(ptr, val)   a_fetch_xor((ptr), (val))
#define atomic_fetch_xor_explicit(ptr, val, order)   a_fetch_xor((ptr), (val))


/** Atomic XOR */
LIB_FUNC NONNULL void a_xor(volatile int* restrict p, const int val) {
#   ifdef ARCHX86
	vasm("lock xorl %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(old ^ val);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void a_xor_64(volatile uint64_t* restrict p, const uint64_t val) {
#   ifdef ARCHX86
	vasm("lock xorq %1, %0;" : "+m"(*p) : "r,i,n"(val) : "memory");
#   else
	do_sync();
	const uint64_t old = *p;
	const uint64_t newval = (uint64_t)(old ^ val);
	while (cmpxchg64(p, old, newval) != old);
	do_sync();
#   endif
}


LIB_FUNC NONNULL void atomic_xorop(const int i, atomic_t* restrict val) {
	do_sync();
	const int old = val->counter;
	const int newval = (int)(old ^ i);
	while (cmpxchg(&val->counter, old, newval) != old);
	do_sync();
}


/** Atomic increment */
LIB_FUNC NONNULL void a_inc(volatile int* restrict p) {
#   ifdef ARCHX86
	vasm("lock incl %0;" : "+m"(*p) : : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(++old);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}
#define __atomic_inc(ptr)   a_inc((ptr))
#define atomic_inc(ptr)   a_inc((ptr))
#define atomic_increment(ptr)   a_inc((ptr))
#define catomic_inc(ptr)   a_inc((ptr))
#define atomic_increment_val(ptr)   a_inc((ptr))
#define catomic_increment_val(ptr)   a_inc((ptr))


/** Atomic decrement */
LIB_FUNC NONNULL void a_dec(volatile int* restrict p) {
#   ifdef ARCHX86
	vasm("lock decl %0;" : "+m"(*p) : : "memory");
#   else
	do_sync();
	const int old = *p;
	const int newval = (int)(--old);
	while (cmpxchg(p, old, newval) != old);
	do_sync();
#   endif
}
/** Atomic decrement */
#define __atomic_dec(ptr)   a_dec((ptr))
#define atomic_dec(ptr)   a_dec((ptr))
#define atomic_decrement(ptr)   a_dec((ptr))
#define catomic_dec(ptr)   a_dec((ptr))
#define atomic_decrement_val(ptr)   a_dec((ptr))
#define catomic_decrement_val(ptr)   a_dec((ptr))


/** Atomic decrement (if positive) */
LIB_FUNC NONNULL void a_dec_if_pos(volatile int* restrict ptr) {
	do_sync();
	if (*ptr >= 0) { a_dec(ptr); }
	do_sync();
}
#define atomic_decrement_if_positive(ptr)   a_dec_if_pos((ptr))


LIB_FUNC NONNULL int a_max(volatile int* restrict ptr, const int val) {
	do_sync();
	const int old = *ptr;
	if (old >= val) { return old; }
	return val;
}
#define atomic_max(ptr, val)   a_max((ptr), (val))
#define catomic_max(ptr, val)   a_max((ptr), (val))


LIB_FUNC NONNULL int a_min(volatile int* restrict ptr, const int val) {
	do_sync();
	const int old = *ptr;
	if (old >= val) { return val; }
	return old;
}
#define atomic_min(ptr, val)   a_min((ptr), (val))
#define catomic_min(ptr, val)   a_min((ptr), (val))


// TODO: Combine with Bit-Twiddling equivalents and add code for tzcnt/lzcnt
/** Atomically count trailing zeros */
LIB_FUNC ATTR_CF int a_ctz_64(const uint64_t val) {
#   ifdef ARCHX86
	register uint64_t x = val;
	vasm("bsf %1, %0;" : "=r"(x) : "0"(x));
	return (int)x;
#   else
	do_sync();
	return ctzll((unsigned long long)val);
#   endif
}


LIB_FUNC ATTR_CF int a_ctz_l(const unsigned long val) {
#   if LONG_EQ_64BITS
	return a_ctz_64(val);
#   else
	return (int)(debruijn32[(val & (-val)) * 0x076be629 >> 27]);
#   endif
}
#define ntz(val)   a_ctz_l((val))


LIB_FUNC NONNULL size_t atomic_bit_set(volatile size_t* restrict ptr, const size_t bit) {
	do_sync();
	const size_t old = *ptr;
	const size_t newval = (size_t)(old | (size_t)(1 << bit));
	return cmpxchgsz(ptr, old, newval);
}
#define atomic_bit_test_set(ptr, bit)   atomic_bit_set((ptr), (bit))


/** Set atomic spin-lock */
LIB_FUNC void spin_lock(volatile int* restrict ptr) {
	while (!cmpxchg_bool(ptr, 0, 1));
}


/** Unset atomic spin-lock */
LIB_FUNC void spin_unlock(volatile int* restrict ptr) {
	do_sync();
	*ptr = 0;
}


#endif  // ATOMIC_H


/* ERRNO: SYSTEM ERROR NUMBERS (<errno.h>) */


#if (!(defined(ERRNO_H) || defined(_ERRNO_H) || defined(_ERRNO_H_)))  // http://www.cplusplus.com/reference/cerrno/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
#define ERRNO_H   (1)
#define _ERRNO_H   (1)
#define _ERRNO_H_   (1)


/** Struct for table of error messages */
typedef struct attr_packed errname {
	short errcode;  //!< Error number
	short action;  //!< Operation which encountered the error
	const char* msg;  //!< Text describing the error
} errname_t;

/** In SVID error handling, `matherr` is called with this description of the exceptional condition */
typedef struct exception {
	int err, type;
	const char* name;
	double arg1, arg2, retval;
} exception_t;
static UNUSED struct exception exc = { 0, 0, NULL, 0.0, 0.0, 0.0 };

static const UNUSED char* const h_errlist[8] = {
	"Resolver Error 0 (no error)",
	"Unknown host",  //!< 1: HOST_NOT_FOUND
	"Host name lookup failure",  //!< 2: TRY_AGAIN
	"Unknown server error",  //!< 3: NO_RECOVERY
	"No address associated with name",  //!< 4: NO_ADDRESS
	"\0"
};
#define h_nerr   (int)(sizeof(h_errlist) / sizeof(h_errlist[0]))
static const UNUSED char align32 error_msg[16] = "Resolver error\0";
static const UNUSED char align8 colon_space[4] = ": \0";
#ifdef _BSD_SOURCE
/** Use `strerror()` instead */
static const UNUSED char* const sys_errlist[];
#   if SINGLE_THREAD_P
volatile UNUSED int sys_nerr = 0;
#   else
thread_local volatile UNUSED int sys_nerr = 0;
#   endif
#endif

/**
@brief Error numbers used to indicate errors in errno
 - HelenOS: Values in the range `[-1, -255]` are kernel error codes
 - HelenOS: Values in the range `[-256, -512]` are user error codes
*/
enum ERROR_NUMBERS {
#   ifdef OSHELENOS
/** No error */
	EOK = 0,
/** No such entry */
	ENOENT = -1,
/** Not enough memory */
	ENOMEM = -2,
/** Limit exceeded */
	ELIMIT = -3,
/** Connection refused */
	EREFUSED = -4,
/** Forward error */
	EFORWARD = -5,
/** Permission denied */
	EPERM = -6,
	EHANGUP = -7,
	EPARTY = -8,
/** Entry already exists */
	EEXIST = -9,
/** Bad memory pointer */
	EBADMEM = -10,
/** Not supported */
	ENOTSUP = -11,
/** Address not available */
	EADDRNOTAVAIL = -12,
/** Timeout expired */
	ETIMEOUT = -13,
/** Invalid value */
	EINVAL = -14,
/** Resource is busy */
	EBUSY = -15,
/** The result does not fit its size */
	EOVERFLOW = -16,
/** Operation was interrupted */
	EINTR = -17
#   elif defined(ARCHALPHA)
/** Operation not permitted */
	EPERM = 1,
/** No such file or directory */
	ENOENT = 2,
/** No such process */
	ESRCH = 3,
/** Interrupted system call */
	EINTR = 4,
/** I/O error */
	EIO = 5,
/** No such device or address */
	ENXIO = 6,
/** Arg list too long */
	E2BIG = 7,
/** Exec format error */
	ENOEXEC = 8,
/** Bad file number */
	EBADF = 9,
/** No child processes */
	ECHILD = 10,
/** Resource deadlock would occur */
	EDEADLK = 11,
/** Out of memory */
	ENOMEM = 12,
/** Permission denied */
	EACCES = 13,
/** Bad address */
	EFAULT = 14,
/** Block device required */
	ENOTBLK = 15,
/** Device or resource busy */
	EBUSY = 16,
/** File exists */
	EEXIST = 17,
/** Cross-device link */
	EXDEV = 18,
/** No such device */
	ENODEV = 19,
/** Not a directory */
	ENOTDIR = 20,
/** Is a directory */
	EISDIR = 21,
/** Invalid argument */
	EINVAL = 22,
/** File table overflow */
	ENFILE = 23,
/** Too many open files */
	EMFILE = 24,
/** Not a typewriter */
	ENOTTY = 25,
/** Text file busy */
	ETXTBSY = 26,
/** File too large */
	EFBIG = 27,
/** No space left on device */
	ENOSPC = 28,
/** Illegal seek */
	ESPIPE = 29,
/** Read-only file system */
	EROFS = 30,
/** Too many links */
	EMLINK = 31,
/** Broken pipe */
	EPIPE = 32,
/** Math argument out of domain of func */
	EDOM = 33,
/** Math result not representable */
	ERANGE = 34,
/** Try again */
	EAGAIN = 35,
/** Operation would block */
#      define EWOULDBLOCK   EAGAIN
/** Operation now in progress */
	EINPROGRESS = 36,
/** Operation already in progress */
	EALREADY = 37,
/** Socket operation on non-socket */
	ENOTSOCK = 38,
/** Destination address required */
	EDESTADDRREQ = 39,
/** Message too long */
	EMSGSIZE = 40,
/** Protocol wrong type for socket */
	EPROTOTYPE = 41,
/** Protocol not available */
	ENOPROTOOPT = 42,
/** Protocol not supported */
	EPROTONOSUPPORT = 43,
/** Socket type not supported */
	ESOCKTNOSUPPORT = 44,
/** Operation not supported on transport endpoint */
	EOPNOTSUPP = 45,
/** Operation not supported on transport endpoint */
#      define ENOTSUP   EOPNOTSUPP
/** Protocol family not supported */
	EPFNOSUPPORT = 46,
/** Address family not supported by protocol */
	EAFNOSUPPORT = 47,
/** Address already in use */
	EADDRINUSE = 48,
/** Cannot assign requested address */
	EADDRNOTAVAIL = 49,
/** Network is down */
	ENETDOWN = 50,
/** Network is unreachable */
	ENETUNREACH = 51,
/** Network dropped connection because of reset */
	ENETRESET = 52,
/** Software caused connection abort */
	ECONNABORTED = 53,
/** Connection reset by peer */
	ECONNRESET = 54,
/** No buffer space available */
	ENOBUFS = 55,
/** Transport endpoint is already connected */
	EISCONN = 56,
/** Transport endpoint is not connected */
	ENOTCONN = 57,
/** Cannot send after transport endpoint shutdown */
	ESHUTDOWN = 58,
/** Too many references: cannot splice */
	ETOOMANYREFS = 59,
/** Connection timed out */
	ETIMEDOUT = 60,
/** Connection refused */
	ECONNREFUSED = 61,
/** Too many symbolic links encountered */
	ELOOP = 62,
/** File name too long */
	ENAMETOOLONG = 63,
/** Host is down */
	EHOSTDOWN = 64,
/** No route to host */
	EHOSTUNREACH = 65,
/** Directory not empty */
	ENOTEMPTY = 66,
/** Too many users */
	EUSERS = 68,
/** Quota exceeded */
	EDQUOT = 69,
/** Stale NFS file handle */
	ESTALE = 70,
/** Object is remote */
	EREMOTE = 71,
/** No record locks available */
	ENOLCK = 77,
/** Function not implemented */
	ENOSYS = 78,
/** No message of desired type */
	ENOMSG = 80,
/** Identifier removed */
	EIDRM = 81,
/** Out of streams resources */
	ENOSR = 82,
/** Timer expired */
	ETIME = 83,
/** Not a data message */
	EBADMSG = 84,
/** Protocol error */
	EPROTO = 85,
/** No data available */
	ENODATA = 86,
/** Device not a stream */
	ENOSTR = 87,
/** Package not installed */
	ENOPKG = 92,
/** Illegal byte sequence */
	EILSEQ = 116,
/** Channel number out of range */
	ECHRNG = 88,
/** Level 2 not synchronized */
	EL2NSYNC = 89,
/** Level 3 halted */
	EL3HLT = 90,
/** Level 3 reset */
	EL3RST = 91,
/** Link number out of range */
	ELNRNG = 93,
/** Protocol driver not attached */
	EUNATCH = 94,
/** No CSI structure available */
	ENOCSI = 95,
/** Level 2 halted */
	EL2HLT = 96,
/** Invalid exchange */
	EBADE = 97,
/** Invalid request descriptor */
	EBADR = 98,
/** Exchange full */
	EXFULL = 99,
/** No anode */
	ENOANO = 100,
/** Invalid request code */
	EBADRQC = 101,
/** Invalid slot */
	EBADSLT = 102,
#      define EDEADLOCK   EDEADLK
/** Bad font file format */
	EBFONT = 104,
/** Machine is not on the network */
	ENONET = 105,
/** Link has been severed */
	ENOLINK = 106,
/** Advertise error */
	EADV = 107,
/** Srmount error */
	ESRMNT = 108,
/** Communication error on send */
	ECOMM = 109,
/** Multihop attempted */
	EMULTIHOP = 110,
/** RFS specific error */
	EDOTDOT = 111,
/** Value too large for defined datatype */
	EOVERFLOW = 112,
/** Name not unique on network */
	ENOTUNIQ = 113,
/** File descriptor in bad state */
	EBADFD = 114,
/** Remote address changed */
	EREMCHG = 115,
/** Structure needs cleaning */
	EUCLEAN = 117,
/** Not a XENIX named type file */
	ENOTNAM = 118,
/** No XENIX semaphores available */
	ENAVAIL = 119,
/** Is a named type file */
	EISNAM = 120,
/** Remote I/O error */
	EREMOTEIO = 121,
/** Can not access a needed shared library */
	ELIBACC = 122,
/** Accessing a corrupted shared library */
	ELIBBAD = 123,
/** .lib section in a.out corrupted */
	ELIBSCN = 124,
/** Attempting to link in too many shared libraries */
	ELIBMAX = 125,
/** Cannot exec a shared library directly */
	ELIBEXEC = 126,
/** Interrupted system call should be restarted */
	ERESTART = 127,
/** Streams pipe error */
	ESTRPIPE = 128,
/** No medium found */
	ENOMEDIUM = 129,
/** Wrong medium type */
	EMEDIUMTYPE = 130,
/** Operation Cancelled */
	ECANCELED = 131,
/** Required key not available */
	ENOKEY = 132,
/** Key has expired */
	EKEYEXPIRED = 133,
/** Key has been revoked */
	EKEYREVOKED = 134,
/** Key was rejected by service */
	EKEYREJECTED = 135,
	__SYS_NERR = ((EKEYREJECTED) + 1)
#   elif defined(ARCHMIPS)
/** Operation not permitted */
	EPERM = 1,
/** No such file or directory */
	ENOENT = 2,
/** No such process */
	ESRCH = 3,
/** Interrupted system call */
	EINTR = 4,
/** I/O error */
	EIO = 5,
/** No such device or address */
	ENXIO = 6,
/** Arg list too long */
	E2BIG = 7,
/** Exec format error */
	ENOEXEC = 8,
/** Bad file number */
	EBADF = 9,
/** No child processes */
	ECHILD = 10,
/** Try again */
	EAGAIN = 11,
/** Out of memory */
	ENOMEM = 12,
/** Permission denied */
	EACCES = 13,
/** Bad address */
	EFAULT = 14,
/** Block device required */
	ENOTBLK = 15,
/** Device or resource busy */
	EBUSY = 16,
/** File exists */
	EEXIST = 17,
/** Cross-device link */
	EXDEV = 18,
/** No such device */
	ENODEV = 19,
/** Not a directory */
	ENOTDIR = 20,
/** Is a directory */
	EISDIR = 21,
/** Invalid argument */
	EINVAL = 22,
/** File table overflow */
	ENFILE = 23,
/** Too many open files */
	EMFILE = 24,
/** Not a typewriter */
	ENOTTY = 25,
/** Text file busy */
	ETXTBSY = 26,
/** File too large */
	EFBIG = 27,
/** No space left on device */
	ENOSPC = 28,
/** Illegal seek */
	ESPIPE = 29,
/** Read-only file system */
	EROFS = 30,
/** Too many links */
	EMLINK = 31,
/** Broken pipe */
	EPIPE = 32,
/** Math argument out of domain of func */
	EDOM = 33,
/** Math result not representable */
	ERANGE = 34,
/** No message of desired type */
	ENOMSG = 35,
/** Identifier removed */
	EIDRM = 36,
/** Channel number out of range */
	ECHRNG = 37,
/** Level 2 not synchronized */
	EL2NSYNC = 38,
/** Level 3 halted */
	EL3HLT = 39,
/** Level 3 reset */
	EL3RST = 40,
/** Link number out of range */
	ELNRNG = 41,
/** Protocol driver not attached */
	EUNATCH = 42,
/** No CSI structure available */
	ENOCSI = 43,
/** Level 2 halted */
	EL2HLT = 44,
/** Resource deadlock would occur */
	EDEADLK = 45,
/** No record locks available */
	ENOLCK = 46,
/** Invalid exchange */
	EBADE = 50,
/** Invalid request descriptor */
	EBADR = 51,
/** Exchange full */
	EXFULL = 52,
/** No anode */
	ENOANO = 53,
/** Invalid request code */
	EBADRQC = 54,
/** Invalid slot */
	EBADSLT = 55,
/** File locking deadlock error */
	EDEADLOCK = 56,
/** Bad font file format */
	EBFONT = 59,
/** Device not a stream */
	ENOSTR = 60,
/** No data available */
	ENODATA = 61,
/** Timer expired */
	ETIME = 62,
/** Out of streams resources */
	ENOSR = 63,
/** Machine is not on the network */
	ENONET = 64,
/** Package not installed */
	ENOPKG = 65,
/** Object is remote */
	EREMOTE = 66,
/** Link has been severed */
	ENOLINK = 67,
/** Advertise error */
	EADV = 68,
/** Srmount error */
	ESRMNT = 69,
/** Communication error on send */
	ECOMM = 70,
/** Protocol error */
	EPROTO = 71,
/** RFS specific error */
	EDOTDOT = 73,
/** Multihop attempted */
	EMULTIHOP = 74,
/** Not a data message */
	EBADMSG = 77,
/** File name too long */
	ENAMETOOLONG = 78,
/** Value too large for defined datatype */
	EOVERFLOW = 79,
/** Name not unique on network */
	ENOTUNIQ = 80,
/** File descriptor in bad state */
	EBADFD = 81,
/** Remote address changed */
	EREMCHG = 82,
/** Can not access a needed shared library */
	ELIBACC = 83,
/** Accessing a corrupted shared library */
	ELIBBAD = 84,
/** .lib section in a.out corrupted */
	ELIBSCN = 85,
/** Attempting to link in too many shared libraries */
	ELIBMAX = 86,
/** Cannot exec a shared library directly */
	ELIBEXEC = 87,
/** Illegal byte sequence */
	EILSEQ = 88,
/** Function not implemented */
	ENOSYS = 89,
/** Too many symbolic links encountered */
	ELOOP = 90,
/** Interrupted system call should be restarted */
	ERESTART = 91,
/** Streams pipe error */
	ESTRPIPE = 92,
/** Directory not empty */
	ENOTEMPTY = 93,
/** Too many users */
	EUSERS = 94,
/** Socket operation on non-socket */
	ENOTSOCK = 95,
/** Destination address required */
	EDESTADDRREQ = 96,
/** Message too long */
	EMSGSIZE = 97,
/** Protocol wrong type for socket */
	EPROTOTYPE = 98,
/** Protocol not available */
	ENOPROTOOPT = 99,
/** Protocol not supported */
	EPROTONOSUPPORT = 120,
/** Socket type not supported */
	ESOCKTNOSUPPORT = 121,
/** Operation not supported on transport endpoint */
	EOPNOTSUPP = 122,
/** Operation not supported on transport endpoint */
	ENOTSUP = EOPNOTSUPP,
/** Protocol family not supported */
	EPFNOSUPPORT = 123,
/** Address family not supported by protocol */
	EAFNOSUPPORT = 124,
/** Address already in use */
	EADDRINUSE = 125,
/** Cannot assign requested address */
	EADDRNOTAVAIL = 126,
/** Network is down */
	ENETDOWN = 127,
/** Network is unreachable */
	ENETUNREACH = 128,
/** Network dropped connection because of reset */
	ENETRESET = 129,
/** Software caused connection abort */
	ECONNABORTED = 130,
/** Connection reset by peer */
	ECONNRESET = 131,
/** No buffer space available */
	ENOBUFS = 132,
/** Transport endpoint is already connected */
	EISCONN = 133,
/** Transport endpoint is not connected */
	ENOTCONN = 134,
/** Structure needs cleaning */
	EUCLEAN = 135,
/** Not a XENIX named type file */
	ENOTNAM = 137,
/** No XENIX semaphores available */
	ENAVAIL = 138,
/** Is a named type file */
	EISNAM = 139,
/** Remote I/O error */
	EREMOTEIO = 140,
/** Reserved */
	EINIT = 141,
/** Error 142 */
	EREMDEV = 142,
/** Cannot send after transport endpoint shutdown */
	ESHUTDOWN = 143,
/** Too many references: cannot splice */
	ETOOMANYREFS = 144,
/** Connection timed out */
	ETIMEDOUT = 145,
/** Connection refused */
	ECONNREFUSED = 146,
/** Host is down */
	EHOSTDOWN = 147,
/** No route to host */
	EHOSTUNREACH = 148,
/** Operation would block */
#      define EWOULDBLOCK   EAGAIN
/** Operation already in progress */
	EALREADY = 149,
/** Operation now in progress */
	EINPROGRESS = 150,
/** Stale NFS file handle */
	ESTALE = 151,
/** AIO operation canceled */
	ECANCELED = 158,
/** No medium found */
	ENOMEDIUM = 159,
/** Wrong medium type */
	EMEDIUMTYPE = 160,
/** Required key not available */
	ENOKEY = 161,
/** Key has expired */
	EKEYEXPIRED = 162,
/** Key has been revoked */
	EKEYREVOKED = 163,
/** Key was rejected by service */
	EKEYREJECTED = 164,
/** Quota exceeded */
	EDQUOT = 1133,
	__SYS_NERR = ((EKEYREJECTED) + 2)
#   elif defined(ARCHPARISC)
/** Operation not permitted */
	EPERM = 1,
/** No such file or directory */
	ENOENT = 2,
/** No such process */
	ESRCH = 3,
/** Interrupted system call */
	EINTR = 4,
/** I/O error */
	EIO = 5,
/** No such device or address */
	ENXIO = 6,
/** Argument list too long */
	E2BIG = 7,
/** Exec format error */
	ENOEXEC = 8,
/** Bad file number */
	EBADF = 9,
/** No child processes */
	ECHILD = 10,
/** Try again */
	EAGAIN = 11,
/** Out of memory */
	ENOMEM = 12,
/** Permission denied */
	EACCES = 13,
/** Bad address */
	EFAULT = 14,
/** Block device required */
	ENOTBLK = 15,
/** Device or resource busy */
	EBUSY = 16,
/** File exists */
	EEXIST = 17,
/** Cross-device link */
	EXDEV = 18,
/** No such device */
	ENODEV = 19,
/** Not a directory */
	ENOTDIR = 20,
/** Is a directory */
	EISDIR = 21,
/** Invalid argument */
	EINVAL = 22,
/** File table overflow */
	ENFILE = 23,
/** Too many open files */
	EMFILE = 24,
/** Not a typewriter */
	ENOTTY = 25,
/** Text file busy */
	ETXTBSY = 26,
/** File too large */
	EFBIG = 27,
/** No space left on device */
	ENOSPC = 28,
/** Illegal seek */
	ESPIPE = 29,
/** Read-only file system */
	EROFS = 30,
/** Too many links */
	EMLINK = 31,
/** Broken pipe */
	EPIPE = 32,
/** Math argument out of domain of func */
	EDOM = 33,
/** Math result not representable */
	ERANGE = 34,
/** No message of desired type */
	ENOMSG = 35,
/** Identifier removed */
	EIDRM = 36,
/** Channel number out of range */
	ECHRNG = 37,
/** Level 2 not synchronized */
	EL2NSYNC = 38,
/** Level 3 halted */
	EL3HLT = 39,
/** Level 3 reset */
	EL3RST = 40,
/** Link number out of range */
	ELNRNG = 41,
/** Protocol driver not attached */
	EUNATCH = 42,
/** No CSI structure available */
	ENOCSI = 43,
/** Level 2 halted */
	EL2HLT = 44,
/** Resource deadlock would occur */
	EDEADLK = 45,
#      define EDEADLOCK   EDEADLK
/** No record locks available */
	ENOLCK = 46,
/** Illegal byte sequence */
	EILSEQ = 47,
/** Machine is not on the network */
	ENONET = 50,
/** No data available */
	ENODATA = 51,
/** Timer expired */
	ETIME = 52,
/** Out of streams resources */
	ENOSR = 53,
/** Device not a stream */
	ENOSTR = 54,
/** Package not installed */
	ENOPKG = 55,
/** Link has been severed */
	ENOLINK = 57,
/** Advertise error */
	EADV = 58,
/** Srmount error */
	ESRMNT = 59,
/** Communication error on send */
	ECOMM = 60,
/** Protocol error */
	EPROTO = 61,
/** Multihop attempted */
	EMULTIHOP = 64,
/** RFS specific error */
	EDOTDOT = 66,
/** Not a data message */
	EBADMSG = 67,
/** Too many users */
	EUSERS = 68,
/** Quota exceeded */
	EDQUOT = 69,
/** Stale NFS file handle */
	ESTALE = 70,
/** Object is remote */
	EREMOTE = 71,
/** Value too large for defined datatype */
	EOVERFLOW = 72,
// These errnos are defined by Linux but not HPUX
/** Invalid exchange */
	EBADE = 160,
/** Invalid request descriptor */
	EBADR = 161,
/** Exchange full */
	EXFULL = 162,
/** No anode */
	ENOANO = 163,
/** Invalid request code */
	EBADRQC = 164,
/** Invalid slot */
	EBADSLT = 165,
/** Bad font file format */
	EBFONT = 166,
/** Name not unique on network */
	ENOTUNIQ = 167,
/** File descriptor in bad state */
	EBADFD = 168,
/** Remote address changed */
	EREMCHG = 169,
/** Can not access a needed shared library */
	ELIBACC = 170,
/** Accessing a corrupted shared library */
	ELIBBAD = 171,
/** .lib section in a.out corrupted */
	ELIBSCN = 172,
/** Attempting to link in too many shared libraries */
	ELIBMAX = 173,
/** Cannot exec a shared library directly */
	ELIBEXEC = 174,
/** Interrupted system call should be restarted */
	ERESTART = 175,
/** Streams pipe error */
	ESTRPIPE = 176,
/** Structure needs cleaning */
	EUCLEAN = 177,
/** Not a XENIX named type file */
	ENOTNAM = 178,
/** No XENIX semaphores available */
	ENAVAIL = 179,
/** Is a named type file */
	EISNAM = 180,
/** Remote I/O error */
	EREMOTEIO = 181,
/** No medium found */
	ENOMEDIUM = 182,
/** Wrong medium type */
	EMEDIUMTYPE = 183,
/** Required key not available */
	ENOKEY = 184,
/** Key has expired */
	EKEYEXPIRED = 185,
/** Key has been revoked */
	EKEYREVOKED = 186,
/** Key was rejected by service */
	EKEYREJECTED = 187,
// HPUX
/** symbol does not exist in executable */
	ENOSYM = 215,
/** Socket operation on non-socket */
	ENOTSOCK = 216,
/** Destination address required */
	EDESTADDRREQ = 217,
/** Message too long */
	EMSGSIZE = 218,
/** Protocol wrong type for socket */
	EPROTOTYPE = 219,
/** Protocol not available */
	ENOPROTOOPT = 220,
/** Protocol not supported */
	EPROTONOSUPPORT = 221,
/** Socket type not supported */
	ESOCKTNOSUPPORT = 222,
/** Operation not supported on transport endpoint */
	EOPNOTSUPP = 223,
/** Protocol family not supported */
	EPFNOSUPPORT = 224,
/** Address family not supported by protocol */
	EAFNOSUPPORT = 225,
/** Address already in use */
	EADDRINUSE = 226,
/** Cannot assign requested address */
	EADDRNOTAVAIL = 227,
/** Network is down */
	ENETDOWN = 228,
/** Network is unreachable */
	ENETUNREACH = 229,
/** Network dropped connection because of reset */
	ENETRESET = 230,
/** Software caused connection abort */
	ECONNABORTED = 231,
/** Connection reset by peer */
	ECONNRESET = 232,
/** No buffer space available */
	ENOBUFS = 233,
/** Transport endpoint is already connected */
	EISCONN = 234,
/** Transport endpoint is not connected */
	ENOTCONN = 235,
/** Cannot send after transport endpoint shutdown */
	ESHUTDOWN = 236,
/** Too many references: cannot splice */
	ETOOMANYREFS = 237,
/** for HP's NFS apparently */
	EREFUSED = ECONNREFUSED,
/** Connection timed out */
	ETIMEDOUT = 238,
/** Connection refused */
	ECONNREFUSED = 239,
/** Remote peer released connection */
	EREMOTERELEASE = 240,
/** Host is down */
	EHOSTDOWN = 241,
/** No route to host */
	EHOSTUNREACH = 242,
/** Operation already in progress */
	EALREADY = 244,
/** Operation now in progress */
	EINPROGRESS = 245,
/** Operation would block (Linux returns EAGAIN) */
	EWOULDBLOCK = 246,
/** Directory not empty */
	ENOTEMPTY = 247,
/** File name too long */
	ENAMETOOLONG = 248,
/** Too many symbolic links encountered */
	ELOOP = 249,
/** Function not implemented */
	ENOSYS = 251,
/** Function not implemented (POSIX.4 / HPUX) */
	ENOTSUP = 252,
/** aio request was canceled before complete (POSIX.4 / HPUX) */
	ECANCELLED = 253,
	__SYS_NERR = ((ECANCELLED) + 1)
#   elif defined(ARCHSPARC)
/** Operation not permitted */
	EPERM = 1,
/** No such file or directory */
	ENOENT = 2,
/** No such process */
	ESRCH = 3,
/** Interrupted system call */
	EINTR = 4,
/** I/O error */
	EIO = 5,
/** No such device or address */
	ENXIO = 6,
/** Arg list too long */
	E2BIG = 7,
/** Exec format error */
	ENOEXEC = 8,
/** Bad file number */
	EBADF = 9,
/** No child processes */
	ECHILD = 10,
/** Try again */
	EAGAIN = 11,
/** Out of memory */
	ENOMEM = 12,
/** Permission denied */
	EACCES = 13,
/** Bad address */
	EFAULT = 14,
/** Block device required */
	ENOTBLK = 15,
/** Device or resource busy */
	EBUSY = 16,
/** File exists */
	EEXIST = 17,
/** Cross-device link */
	EXDEV = 18,
/** No such device */
	ENODEV = 19,
/** Not a directory */
	ENOTDIR = 20,
/** Is a directory */
	EISDIR = 21,
/** Invalid argument */
	EINVAL = 22,
/** File table overflow */
	ENFILE = 23,
/** Too many open files */
	EMFILE = 24,
/** Not a typewriter */
	ENOTTY = 25,
/** Text file busy */
	ETXTBSY = 26,
/** File too large */
	EFBIG = 27,
/** No space left on device */
	ENOSPC = 28,
/** Illegal seek */
	ESPIPE = 29,
/** Read-only file system */
	EROFS = 30,
/** Too many links */
	EMLINK = 31,
/** Broken pipe */
	EPIPE = 32,
/** Math argument out of domain of func */
	EDOM = 33,
/** Math result not representable */
	ERANGE = 34,
/** Operation would block */
#      define EWOULDBLOCK   EAGAIN
/** Operation now in progress */
	EINPROGRESS = 36,
/** Operation already in progress */
	EALREADY = 37,
/** Socket operation on non-socket */
	ENOTSOCK = 38,
/** Destination address required */
	EDESTADDRREQ = 39,
/** Message too long */
	EMSGSIZE = 40,
/** Protocol wrong type for socket */
	EPROTOTYPE = 41,
/** Protocol not available */
	ENOPROTOOPT = 42,
/** Protocol not supported */
	EPROTONOSUPPORT = 43,
/** Socket type not supported */
	ESOCKTNOSUPPORT = 44,
/** Op not supported on transport endpoint */
	EOPNOTSUPP = 45,
/** Operation not supported on transport endpoint */
	ENOTSUP = EOPNOTSUPP,
/** Protocol family not supported */
	EPFNOSUPPORT = 46,
/** Address family not supported by protocol */
	EAFNOSUPPORT = 47,
/** Address already in use */
	EADDRINUSE = 48,
/** Cannot assign requested address */
	EADDRNOTAVAIL = 49,
/** Network is down */
	ENETDOWN = 50,
/** Network is unreachable */
	ENETUNREACH = 51,
/** Net dropped connection because of reset */
	ENETRESET = 52,
/** Software caused connection abort */
	ECONNABORTED = 53,
/** Connection reset by peer */
	ECONNRESET = 54,
/** No buffer space available */
	ENOBUFS = 55,
/** Transport endpoint is already connected */
	EISCONN = 56,
/** Transport endpoint is not connected */
	ENOTCONN = 57,
/** No send after transport endpoint shutdown */
	ESHUTDOWN = 58,
/** Too many references: cannot splice */
	ETOOMANYREFS = 59,
/** Connection timed out */
	ETIMEDOUT = 60,
/** Connection refused */
	ECONNREFUSED = 61,
/** Too many symbolic links encountered */
	ELOOP = 62,
/** File name too long */
	ENAMETOOLONG = 63,
/** Host is down */
	EHOSTDOWN = 64,
/** No route to host */
	EHOSTUNREACH = 65,
/** Directory not empty */
	ENOTEMPTY = 66,
/** SUNOS: Too many processes */
	EPROCLIM = 67,
/** Too many users */
	EUSERS = 68,
/** Quota exceeded */
	EDQUOT = 69,
/** Stale NFS file handle */
	ESTALE = 70,
/** Object is remote */
	EREMOTE = 71,
/** Device not a stream */
	ENOSTR = 72,
/** Timer expired */
	ETIME = 73,
/** Out of streams resources */
	ENOSR = 74,
/** No message of desired type */
	ENOMSG = 75,
/** Not a data message */
	EBADMSG = 76,
/** Identifier removed */
	EIDRM = 77,
/** Resource deadlock would occur */
	EDEADLK = 78,
/** No record locks available */
	ENOLCK = 79,
/** Machine is not on the network */
	ENONET = 80,
/** SunOS: Too many lvls of remote in path */
	ERREMOTE = 81,
/** Link has been severed */
	ENOLINK = 82,
/** Advertise error */
	EADV = 83,
/** Srmount error */
	ESRMNT = 84,
/** Communication error on send */
	ECOMM = 85,
/** Protocol error */
	EPROTO = 86,
/** Multihop attempted */
	EMULTIHOP = 87,
/** RFS specific error */
	EDOTDOT = 88,
/** Remote address changed */
	EREMCHG = 89,
/** Function not implemented */
	ENOSYS = 90,
/** Streams pipe error */
	ESTRPIPE = 91,
/** Value too large for defined datatype */
	EOVERFLOW = 92,
/** File descriptor in bad state */
	EBADFD = 93,
/** Channel number out of range */
	ECHRNG = 94,
/** Level 2 not synchronized */
	EL2NSYNC = 95,
/** Level 3 halted */
	EL3HLT = 96,
/** Level 3 reset */
	EL3RST = 97,
/** Link number out of range */
	ELNRNG = 98,
/** Protocol driver not attached */
	EUNATCH = 99,
/** No CSI structure available */
	ENOCSI = 100,
/** Level 2 halted */
	EL2HLT = 101,
/** Invalid exchange */
	EBADE = 102,
/** Invalid request descriptor */
	EBADR = 103,
/** Exchange full */
	EXFULL = 104,
/** No anode */
	ENOANO = 105,
/** Invalid request code */
	EBADRQC = 106,
/** Invalid slot */
	EBADSLT = 107,
/** File locking deadlock error */
	EDEADLOCK = 108,
/** Bad font file format */
	EBFONT = 109,
/** Cannot exec a shared library directly */
	ELIBEXEC = 110,
/** No data available */
	ENODATA = 111,
/** Accessing a corrupted shared library */
	ELIBBAD = 112,
/** Package not installed */
	ENOPKG = 113,
/** Can not access a needed shared library */
	ELIBACC = 114,
/** Name not unique on network */
	ENOTUNIQ = 115,
/** Interrupted syscall should be restarted */
	ERESTART = 116,
/** Structure needs cleaning */
	EUCLEAN = 117,
/** Not a XENIX named type file */
	ENOTNAM = 118,
/** No XENIX semaphores available */
	ENAVAIL = 119,
/** Is a named type file */
	EISNAM = 120,
/** Remote I/O error */
	EREMOTEIO = 121,
/** Illegal byte sequence */
	EILSEQ = 122,
/** Atmpt to link in too many shared libs */
	ELIBMAX = 123,
/** .lib section in a.out corrupted */
	ELIBSCN = 124,
/** No medium found */
	ENOMEDIUM = 125,
/** Wrong medium type */
	EMEDIUMTYPE = 126,
/** Operation Cancelled */
	ECANCELED = 127,
/** Required key not available */
	ENOKEY = 128,
/** Key has expired */
	EKEYEXPIRED = 129,
/** Key has been revoked */
	EKEYREVOKED = 130,
/** Key was rejected by service */
	EKEYREJECTED = 131,
	__SYS_NERR = ((EKEYREJECTED) + 1)
#   else  // ARM, i386, ia64, PowerPC, x86-64
/** Operation not permitted */
	EPERM = 1,
/** No such file or directory */
	ENOENT = 2,
/** No such process */
	ESRCH = 3,
/** Interrupted system call */
	EINTR = 4,
/** I/O error */
	EIO = 5,
/** No such device or address */
	ENXIO = 6,
/** Arg list too long */
	E2BIG = 7,
/** Exec format error */
	ENOEXEC = 8,
/** Bad file number */
	EBADF = 9,
/** No child processes */
	ECHILD = 10,
/** Try again */
	EAGAIN = 11,
/** Out of memory */
	ENOMEM = 12,
/** Permission denied */
	EACCES = 13,
/** Bad address */
	EFAULT = 14,
/** Block device required */
	ENOTBLK = 15,
/** Device or resource busy */
	EBUSY = 16,
/** File exists */
	EEXIST = 17,
/** Cross-device link */
	EXDEV = 18,
/** No such device */
	ENODEV = 19,
/** Not a directory */
	ENOTDIR = 20,
/** Is a directory */
	EISDIR = 21,
/** Invalid argument */
	EINVAL = 22,
/** File table overflow */
	ENFILE = 23,
/** Too many open files */
	EMFILE = 24,
/** Not a typewriter */
	ENOTTY = 25,
/** Text file busy */
	ETXTBSY = 26,
/** File too large */
	EFBIG = 27,
/** No space left on device */
	ENOSPC = 28,
/** Illegal seek */
	ESPIPE = 29,
/** Read-only file system */
	EROFS = 30,
/** Too many links */
	EMLINK = 31,
/** Broken pipe */
	EPIPE = 32,
/** Math argument out of domain of func */
	EDOM = 33,
/** Math result not representable */
	ERANGE = 34,
/** Resource deadlock would occur */
	EDEADLK = 35,
/** File name too long */
	ENAMETOOLONG = 36,
/** No record locks available */
	ENOLCK = 37,
/** Function not implemented */
	ENOSYS = 38,
/** Directory not empty */
	ENOTEMPTY = 39,
/** Too many symbolic links encountered */
	ELOOP = 40,
/** Operation would block */
#      define EWOULDBLOCK   EAGAIN
/** No message of desired type */
	ENOMSG = 42,
/** Identifier removed */
	EIDRM = 43,
/** Channel number out of range */
	ECHRNG = 44,
/** Level 2 not synchronized */
	EL2NSYNC = 45,
/** Level 3 halted */
	EL3HLT = 46,
/** Level 3 reset */
	EL3RST = 47,
/** Link number out of range */
	ELNRNG = 48,
/** Protocol driver not attached */
	EUNATCH = 49,
/** No CSI structure available */
	ENOCSI = 50,
/** Level 2 halted */
	EL2HLT = 51,
/** Invalid exchange */
	EBADE = 52,
/** Invalid request descriptor */
	EBADR = 53,
/** Exchange full */
	EXFULL = 54,
/** No anode */
	ENOANO = 55,
/** Invalid request code */
	EBADRQC = 56,
/** Invalid slot */
	EBADSLT = 57,
#      define EDEADLOCK   EDEADLK
/** Bad font file format */
	EBFONT = 59,
/** Device not a stream */
	ENOSTR = 60,
/** No data available */
	ENODATA = 61,
/** Timer expired */
	ETIME = 62,
/** Out of streams resources */
	ENOSR = 63,
/** Machine is not on the network */
	ENONET = 64,
/** Package not installed */
	ENOPKG = 65,
/** Object is remote */
	EREMOTE = 66,
/** Link has been severed */
	ENOLINK = 67,
/** Advertise error */
	EADV = 68,
/** Srmount error */
	ESRMNT = 69,
/** Communication error on send */
	ECOMM = 70,
/** Protocol error */
	EPROTO = 71,
/** Multihop attempted */
	EMULTIHOP = 72,
/** RFS specific error */
	EDOTDOT = 73,
/** Not a data message */
	EBADMSG = 74,
/** Value too large for defined datatype */
	EOVERFLOW = 75,
/** Name not unique on network */
	ENOTUNIQ = 76,
/** File descriptor in bad state */
	EBADFD = 77,
/** Remote address changed */
	EREMCHG = 78,
/** Can not access a needed shared library */
	ELIBACC = 79,
/** Accessing a corrupted shared library */
	ELIBBAD = 80,
/** .lib section in a.out corrupted */
	ELIBSCN = 81,
/** Attempting to link in too many shared libraries */
	ELIBMAX = 82,
/** Cannot exec a shared library directly */
	ELIBEXEC = 83,
/** Illegal byte sequence */
	EILSEQ = 84,
/** Interrupted system call should be restarted */
	ERESTART = 85,
/** Streams pipe error */
	ESTRPIPE = 86,
/** Too many users */
	EUSERS = 87,
/** Socket operation on non-socket */
	ENOTSOCK = 88,
/** Destination address required */
	EDESTADDRREQ = 89,
/** Message too long */
	EMSGSIZE = 90,
/** Protocol wrong type for socket */
	EPROTOTYPE = 91,
/** Protocol not available */
	ENOPROTOOPT = 92,
/** Protocol not supported */
	EPROTONOSUPPORT = 93,
/** Socket type not supported */
	ESOCKTNOSUPPORT = 94,
/** Operation not supported on transport endpoint */
	EOPNOTSUPP = 95,
/** Operation not supported on transport endpoint */
#      define ENOTSUP   EOPNOTSUPP
/** Protocol family not supported */
	EPFNOSUPPORT = 96,
/** Address family not supported by protocol */
	EAFNOSUPPORT = 97,
/** Address already in use */
	EADDRINUSE = 98,
/** Cannot assign requested address */
	EADDRNOTAVAIL = 99,
/** Network is down */
	ENETDOWN = 100,
/** Network is unreachable */
	ENETUNREACH = 101,
/** Network dropped connection because of reset */
	ENETRESET = 102,
/** Software caused connection abort */
	ECONNABORTED = 103,
/** Connection reset by peer */
	ECONNRESET = 104,
/** No buffer space available */
	ENOBUFS = 105,
/** Transport endpoint is already connected */
	EISCONN = 106,
/** Transport endpoint is not connected */
	ENOTCONN = 107,
/** Cannot send after transport endpoint shutdown */
	ESHUTDOWN = 108,
/** Too many references: cannot splice */
	ETOOMANYREFS = 109,
/** Connection timed out */
	ETIMEDOUT = 110,
/** Connection refused */
	ECONNREFUSED = 111,
/** Host is down */
	EHOSTDOWN = 112,
/** No route to host */
	EHOSTUNREACH = 113,
/** Operation already in progress */
	EALREADY = 114,
/** Operation now in progress */
	EINPROGRESS = 115,
/** Stale NFS file handle */
	ESTALE = 116,
/** Structure needs cleaning */
	EUCLEAN = 117,
/** Not a XENIX named type file */
	ENOTNAM = 118,
/** No XENIX semaphores available */
	ENAVAIL = 119,
/** Is a named type file */
	EISNAM = 120,
/** Remote I/O error */
	EREMOTEIO = 121,
/** Quota exceeded */
	EDQUOT = 122,
/** No medium found */
	ENOMEDIUM = 123,
/** Wrong medium type */
	EMEDIUMTYPE = 124,
/** Operation Canceled */
	ECANCELED = 125,
/** Required key not available */
	ENOKEY = 126,
/** Key has expired */
	EKEYEXPIRED = 127,
/** Key has been revoked */
	EKEYREVOKED = 128,
/** Key was rejected by service */
	EKEYREJECTED = 129,
	__SYS_NERR = ((EKEYREJECTED) + 1)
#   endif
};

/** @def EFTYPE
POSIX 1003.1 bad file format errno */
#ifndef EFTYPE
#   ifdef OSPOSIX
#      define EFTYPE   EIO
#   else
#      define EFTYPE   EINVAL
#   endif
#endif

/** @defgroup errmsg_Types Types of operations (passed to `errmsg()`)
@{ */  // (FB){

/** Opening a file */
#define E_OPEN   1
/** Creating a file */
#define E_CREAT   2
/** Executing a program */
#define E_EXEC   4

/** @} */  // }

/** @defgroup Exceptions Exceptions
@{ */  // (FB){

/** SIGINT received */
#define EXINT   0
/** Generic error */
#define EXERROR   1
/** Execute a shell procedure */
#define EXSHELLPROC   2
/** Command execution failed */
#define EXEXEC   3
/** Attribute not found (File system extended attribute error) */
#define ENOATTR   (_SIGN 93)

/** @} */  // }

/** @defgroup Psuedo_Kernel_Errors Pseudo-errors returned inside kernel to modify return to process
@{ */  // (FB){

/** Do not modify regs, just return */
#define EJUSTRETURN   (-2)
/** Restart syscall */
#define ERESTART   (-3)
/** ioctl not handled by this layer */
#define EPASSTHROUGH   (-4)
/** Dup given fd */
#define EDUPFD   (-5)
/** Move given fd */
#define EMOVEFD   (-6)

/** @} */  // }

/** @defgroup Realtime_XSI_Errors Realtime XSI STREAMS option errors
@{ */  // (FB){

/** Must equal largest errno */
#define ELAST   (_SIGN 96)
/** Bad adaptor */
#define EADAPT   (ELAST + 1)
/** Bad controller */
#define ECTLR   (ELAST + 2)
/** Bad drive */
#define EUNIT   (ELAST + 3)
/** Bad partition */
#define EPART   (ELAST + 4)
/** Cannot read disk label */
#define ERDLAB   (ELAST + 5)
/** Unlabeled disk */
#define EUNLAB   (ELAST + 6)
/** Relative seek not supported */
#define EOFFSET   (ELAST + 7)
/** Undefined driver command */
#define ECMD   (ELAST + 8)
/** Bad sector error */
#define EBSE   (ELAST + 9)
/** Write check error */
#define EWCK   (ELAST + 10)
/** Uncorrectable ecc error */
#define EECC   (ELAST + 11)
/** Hard error */
#define EHER   (ELAST + 12)
#define ESALAST   (ELAST + 12)

/** @} */  // }

/** Table of error messages */
static const UNUSED struct errname errormsg[] = {
	{ EINTR, (E_OPEN | E_CREAT | E_EXEC), "Interrupted" },
	{ EACCES, (E_OPEN | E_CREAT | E_EXEC), "Permission denied" },
	{ EIO, (E_OPEN | E_CREAT | E_EXEC), "I/O error" },
	{ EEXIST, (E_OPEN | E_CREAT | E_EXEC), "File exists" },
	{ ENOENT, E_OPEN, "No such file" },
	{ ENOENT, E_CREAT,"Directory nonexistent" },
	{ ENOENT, E_EXEC, "Not found" },
	{ ENOTDIR, E_OPEN, "No such file" },
	{ ENOTDIR, E_CREAT,"Directory nonexistent" },
	{ ENOTDIR, E_EXEC, "Not found" },
	{ EISDIR, (E_OPEN | E_CREAT | E_EXEC), "is a directory" },
#   ifdef EMFILE
	{ EMFILE, (E_OPEN | E_CREAT | E_EXEC), "Too many open files" },
#   endif
	{ ENFILE, (E_OPEN | E_CREAT | E_EXEC), "File table overflow" },
	{ ENOSPC, (E_OPEN | E_CREAT | E_EXEC), "File system full" },
#   ifdef EDQUOT
	{ EDQUOT, (E_OPEN | E_CREAT | E_EXEC), "Disk quota exceeded" },
#   endif
#   ifdef ENOSR
	{ ENOSR, (E_OPEN | E_CREAT | E_EXEC), "No streams resources" },
#   endif
	{ ENXIO, (E_OPEN | E_CREAT | E_EXEC), "No such device or address" },
	{ EROFS, (E_OPEN | E_CREAT | E_EXEC), "Read-only file system" },
	{ ETXTBSY, (E_OPEN | E_CREAT | E_EXEC), "Text busy" },
#   ifdef EAGAIN
	{ EAGAIN, E_EXEC, "Not enough memory" },
#   endif
	{ ENOMEM, (E_OPEN | E_CREAT | E_EXEC), "Not enough memory" },
#   ifdef ENOLINK
	{ ENOLINK, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef EMULTIHOP
	{ EMULTIHOP, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ECOMM
	{ ECOMM, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ESTALE
	{ ESTALE, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ETIMEDOUT
	{ ETIMEDOUT, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ELOOP
	{ ELOOP, (E_OPEN | E_CREAT | E_EXEC), "Symbolic link loop" },
#   endif
#   ifdef ENAMETOOLONG
	{ ENAMETOOLONG, 7, "File name too long" },
#   endif
	{ E2BIG, E_EXEC, "Argument list too long" },
#   ifdef ELIBACC
	{ ELIBACC, E_EXEC, "Shared library missing" },
#   endif
	{ 0, 0, NULL },
};

static const UNUSED struct attr_packed mi {
	int errno;
	const char* const msg;
} errlist[18] = {
	{ EADAPT, "Bad adaptor number" },
	{ ECTLR, "Bad controller number" },
	{ EUNIT, "Bad drive number" },
	{ EPART, "Bad partition" },
	{ ERDLAB, "Cannot read disk label" },
	{ EUNLAB, "Unlabeled" },
	{ ENXIO, "Device not configured" },
	{ EPERM, "Operation not permitted" },
	{ ENOENT, "No such file or directory" },
	{ ESTALE, "Stale NFS file handle" },
	{ EFTYPE, "Inappropriate file type or format" },
	{ ENOEXEC, "Exec format error" },
	{ EIO, "Input/output error" },
	{ EINVAL, "Invalid argument" },
	{ ENOTDIR, "Not a directory" },
	{ EOFFSET, "Invalid file offset" },
	{ EACCES, "Permission denied" },
	{ 0, 0 }
};

#ifndef __error_t_defined
/** Datatype for the `errno` variable; The Hurd &lt;bits/errno.h&gt; defines `error_t` as an enumerated type so that printing `error_t` values in the debugger shows the names */
typedef int   error_t;
#   define __error_t_defined   (1)
#endif
#ifndef errno_t
/** Darwin alternative to `error_t` */
#   define errno_t   error_t
#endif
#define SIZEOF_ERROR_T   SIZEOF_INT
typedef unsigned long   error_status_t;
#define SIZEOF_ERROR_STATUS_T   SIZEOF_LONG

/** @def errno
The global variable used for errors; In GNU, it is a per-thread variable */
/** @def exerrno
Error for `EXEXEC` */
#ifndef errno
#   if SINGLE_THREAD_P
volatile UNUSED int errno = 0;
volatile UNUSED int exerrno = 0;
#   else
thread_local volatile UNUSED int errno = 0;
thread_local volatile UNUSED int exerrno = 0;
#   endif
#endif
#ifndef _errno
/** The global variable used for errors; In GNU, it is a per-thread variable */
#   define _errno   errno
#endif
#ifndef __errno
/** The global variable used for errors; In GNU, it is a per-thread variable */
#   define __errno   errno
#endif
#ifndef __h_errno
/** The global variable used for errors; In GNU, it is a per-thread variable */
#   define __h_errno   errno
#endif
#ifndef __libc_h_errno
/** The global variable used for errors; In GNU, it is a per-thread variable */
#   define __libc_h_errno   errno
#endif
#ifndef h_errno
/** The global variable used for errors; In GNU, it is a per-thread variable */
#   define h_errno   errno
#endif
#ifndef SIZEOF_ERRNO
#   define SIZEOF_ERRNO   SIZEOF_INT
#endif

/** This gives the address of errno */
#define errno_location()   ((volatile int*)&errno)
/** This gives the address of errno */
#define __errno_location()   errno_location()
/** This gives the address of __h_errno */
#define __h_errno_location()   errno_location()
/** This gives the address of __h_errno */
#define h_errno_location()   errno_location()
#ifndef get_errno
/** Get the value of the `errno` variable */
#   define get_errno()   (a_load(errno_location()))
#endif
#ifndef set_errno
/** Set the value of the `errno` variable */
#   define set_errno(val)   (a_store(errno_location(), (int)(val)))
#endif
#ifndef __set_errno
/** Set the value of the `errno` variable */
#   define __set_errno(val)   set_errno((val))
#endif
#ifndef _set_errno
/** Set the value of the `errno` variable */
#   define _set_errno(val)   set_errno((val))
#endif
#ifndef clr_errno
/** Set the value of `errno` to 0 */
#   define clr_errno()   (a_zero(errno_location()))
#endif
#ifndef eq_errno
/** Test if `errno` is equal to the given value */
#   define eq_errno(val)   (get_errno() == (int)(val))
#endif
#ifndef neq_errno
/** Test if `errno` is not equal to the given value */
#   define neq_errno(val)   (get_errno() != (int)(val))
#endif
#ifndef is_errno_not_zero
/** Test if `errno` is not zero */
#   define is_errno_not_zero()   (get_errno() != 0)
#endif
#ifndef is_errno_neg
/** Test if `errno` is less than zero */
#   define is_errno_neg()   (get_errno() < 0)
#endif


// ERRNO FUNCTIONS

#define RETURN_AND_SET_ERRNO(err)   do { if (err < 0) { set_errno(err); return -1; } return err; } while (0x0)
/** Signal that an error occurred */
#define ERROR_RETURN   do { set_errno(EINVAL); return NULL; } while (0x0)
#define __fp_range_check(fp_y, fp_x)   do { if (__FPMAX_ZERO_OR_INF_CHECK((fpmax_t)(fp_y)) && ((fpmax_t)(fp_y) != 0) && (!(__FPMAX_ZERO_OR_INF_CHECK((fpmax_t)(fp_x))))) /* y is 0 or +/- infinity; y is not 0 (could have x>0, y==0 if underflow); or x is not 0 or +/- infinity */ { set_errno(ERANGE); /* x is not in y's range */ } } while (0x0)
/** Evaluate `expression` and repeat as long as it returns `-1` with `errno` set to `EINTR` */
#define TEMP_FAILURE_RETRY(expression)   __extension__ ({ long __result; do { __result = (long)(expression); } while (__result == (-1L) && eq_errno(EINTR)); __result; })


/** Return the string associated with a given host `errno` value */
LIB_FUNC ATTR_CF const char* hstrerror(const int err) {
	if (err < 0) { return (const char*)("Resolver internal error"); }
	else if (err < h_nerr) { return (const char*)(h_errlist[err]); }
	return (const char*)("Unknown resolver error");
}


/** Print the error message indicated by the value of `err` */
LIB_FUNC char* strerror(const int err) {
	const struct mi* restrict _mi = errlist;
	for (; _mi->msg; _mi++) {
		if (_mi->errno == err) { return UNCONST(_mi->msg); }
	}
	static char align32 tmpbuf[29] = "Unknown Error: code \0\0\0\0\0\0\0\0\0";
	char* restrict p = tmpbuf + 20;
	register int i = err;
	if (err < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	return tmpbuf;
}
/** Print the error message indicated by the value of `err` */
#define strerror_r(err, x, size)   strerror((err))
/** Print the error message indicated by the value of `err` */
#define rk_strerror_r(err)   strerror((err))
/** Print the error message indicated by the value of `err` */
#define rk_strerror(err)   strerror((err))
/** Print the error message indicated by the value of `err` */
#define strerror_l(err, locale)   strerror((err))


/** Print error message */
LIB_FUNC void perror(const char* s) {
	const int sverrno = get_errno();
	if (s == NULL) { s = ""; }
	const char* separator;
	if (*s == '\0') { separator = ""; }
	else { separator = ": "; }
	const char* buf = strerror(sverrno);
	(void)fprintf(stderr, "%s%s%s\n", s, separator, buf);
}


/** Print the error message indicated by the `errno` value */
LIB_FUNC void herror(const char* s) {
	const char* c = colon_space;
	if (!s || !(*s)) { c += 2; }
	const char* p = error_msg;
	register const int sverrno = get_errno();
	if ((sverrno >= 0) && (sverrno < h_nerr)) { p = h_errlist[sverrno]; }
	fprintf(stderr, "%s%s%s\n", s, c, p);
}
#define _herror(x)   herror((x))


#endif  // ERRNO_H


/* ABORT (<abort-instr.h>) */


#if (!(defined(ABORT_H) || defined(ABORT_INSTR_H) || defined(_ABORT_INSTR_H) || defined(_ABORT_INSTR_H_)))
#define ABORT_H   (1)
#define _ABORT_H   (1)
#define _ABORT_H_   (1)
#define ABORT_INSTR_H   (1)
#define _ABORT_INSTR_H   (1)
#define _ABORT_INSTR_H_   (1)


// ABORT_INSTRUCTION

/** @def ABORT_INSTRUCTION
An instruction that should crash any program */
#ifdef ARCHX86  // x86
#   define ABORT_INSTRUCTION   vasm("hlt;"); UNREACHABLE
#   define DebugBreak()   asm ("int $3;"); UNREACHABLE
#elif defined(ARCHAARCH64)  // Aarch64
#   define ABORT_INSTRUCTION   vasm("brk #1000;"); UNREACHABLE
#elif defined(ARCHPARISC)  // Parisc
#   define ABORT_INSTRUCTION   vasm("iitlbp %r0, (%sr0, %r0);"); UNREACHABLE
#elif defined(ARCHITANIUM)  // IA64
#   define ABORT_INSTRUCTION   vasm("break 0;"); UNREACHABLE
#elif defined(ARCHM68K)  // M68K
#   define ABORT_INSTRUCTION   vasm("illegal;"); UNREACHABLE
#elif defined(ARCHMICROBLAZE)  // Microblaze
#   define ABORT_INSTRUCTION   vasm("brki r0, -1;"); UNREACHABLE
#elif defined(ARCHMIPS)  // MIPS
#   ifdef ARCHMIPS16
#      define ABORT_INSTRUCTION   vasm("break 63;"); UNREACHABLE
#   else
#      define ABORT_INSTRUCTION   vasm("break 255;"); UNREACHABLE
#   endif
#elif defined(ARCHNIOS2)  // NIOS2
#   define ABORT_INSTRUCTION   vasm("trap 31;"); UNREACHABLE
#elif defined(ARCHPOWERPC)  // PowerPC
#   define ABORT_INSTRUCTION   vasm(".long 0;"); UNREACHABLE
#elif defined(ARCHS390)  // S390
#   define ABORT_INSTRUCTION   vasm(".word 0;"); UNREACHABLE
#elif defined(ARCHSPARC)  // Sparc
#   define ABORT_INSTRUCTION   vasm("unimp 0xf00;"); UNREACHABLE
#elif defined(ARCHSUPERH)  // SuperH
#   define ABORT_INSTRUCTION   vasm("sleep;"); UNREACHABLE
#elif defined(ARCHTILE)  // Tile
#   define ABORT_INSTRUCTION   vasm("ill;"); UNREACHABLE
#else
#   define ABORT_INSTRUCTION
#   if has_builtin(__builtin_trap)
#      define ABORT_INSTRUCTION   __builtin_trap(); UNREACHABLE
#   else
#      define ABORT_INSTRUCTION   do { vasm(";"); } until_break; UNREACHABLE
#   endif
#endif  // ABORT_INSTRUCTION
#ifndef ABORT
/** Privileged instruction to crash a userspace program; this directly calls assembly code */
#   define ABORT   ABORT_INSTRUCTION
#endif
#ifndef os_hardware_trap
/** Privileged instruction to crash a userspace program; this directly calls assembly code */
#   define os_hardware_trap()   ABORT_INSTRUCTION
#endif
#ifndef DebugBreak
#   define DebugBreak()
#endif


/** Abnormal program termination; this flushes streams before directly calling assembly code */
LIB_FUNC noreturn COLD void _abort(void) {
	fflush(NULL);
	ABORT_INSTRUCTION;
}
#ifndef abort
/** Alias to calling _abort(); Abnormal program termination; this flushes streams before directly calling assembly code */
#   define abort()   _abort()
#endif
#ifndef memory_full
/** Alias to calling _abort(); Abnormal program termination; this flushes streams before directly calling assembly code */
#   define memory_full()   _abort()
#endif


/** Abort the program and supply an error message */
LIB_FUNC noreturn COLD NONNULL void __chk_fail(const char* restrict message) {
	puts_err(message);
	abort();
}
#ifndef chk_fail
/** Alias to calling __chk_fail() */
#   define chk_fail(message)   __chk_fail((message))
#endif
#ifndef __fortify_fail
/** Alias to calling __chk_fail() */
#   define __fortify_fail(message)   __chk_fail((message))
#endif
#ifndef fortify_fail
/** Alias to calling __chk_fail() */
#   define fortify_fail(message)   __chk_fail((message))
#endif
#ifndef __libc_fatal
/** Alias to calling __chk_fail() */
#   define __libc_fatal(message)   __chk_fail((message))
#endif
#ifndef libc_fatal
/** Alias to calling __chk_fail() */
#   define libc_fatal(message)   __chk_fail((message))
#endif


/** Force a compile-time error if the condition is zero, but also produce a result (of value 0 and type size_t); Code from the Linux kernel */
#define BUILD_BUG_ON_ZERO(e)   (sizeof(struct { int :-!!(e); }))
/** Force a compile-time error if the condition is NULL, but also produce a result (of value 0 and type size_t); Code from the Linux kernel */
#define BUILD_BUG_ON_NULL(e)   ((void*)sizeof(struct { int :-!!(e); }))


#endif  // ABORT_H


/* LOGGING (<err.h> & <syslog.h>) */


#if (!(defined(_SYSLOG_H) || defined(_SYSLOG_H_) || defined(_SYS_SYSLOG_H_) || defined(_LOG_H) || defined(_ERR_H_) || defined(ERR_H_) || defined(__LOG_H__) || defined(_LOGGING_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/syslog.h.html
#define SYSLOG_H   (1)
#define _SYSLOG_H   (1)
#define _SYSLOG_H_   (1)
#define SYS_SYSLOG_H   (1)
#define _SYS_SYSLOG_H_   (1)
#define _LOG_H   (1)
#define _LOG_H_   (1)
#define __LOG_H__   (1)
#define _ERR_H_   (1)
#define ERR_H_   (1)
#define _LOGGING_H   (1)
#define SYS_SUBRPRF_H   (1)
#define _SYS_SUBRPRF_H_   (1)


/** Log Levels */
enum LOG_LEVELS {
/** System is unusable */
	LOG_EMERG = 0,
/** System is unusable */
#   define LEVEL_EMERG   LOG_EMERG
/** Action must be taken immediately */
	LOG_ALERT = 1,
/** Action must be taken immediately */
#   define LEVEL_ALERT   LOG_ALERT
/** Critical conditions */
	LOG_CRIT = 2,
/** Critical conditions */
#   define LEVEL_CRIT   LOG_CRIT
/** Error conditions */
	LOG_ERR = 3,
/** Error conditions */
#   define LEVEL_ERR   LOG_ERR
/** Warning conditions */
	LOG_WARNING = 4,
/** Warning conditions */
#   define LOG_WARN   LOG_WARNING
/** Warning conditions */
#   define LEVEL_WARNING   LOG_WARNING
/** Normal, but significant condition */
	LOG_NOTICE = 5,
/** Normal, but significant condition */
#   define LEVEL_NOTICE   LOG_NOTICE
/** Informational logging */
	LOG_INFO = 6,
/** Informational logging */
#   define LEVEL_INFO   LOG_INFO
/** Debug-level messages */
	LOG_DEBUG = 7,
/** Debug-level messages */
#   define LEVEL_DEBUG   LOG_DEBUG
/** Do not log anything */
	LOG_NONE = 8
/** Do not log anything */
#   define LEVEL_NONE   LOG_NONE
};

/** `logopt` flags for openlog() */
enum LOGOPT_FLAGS {
/** Log the pid with each message */
	LOG_PID = 1,
/** Log on the console if errors in sending */
	LOG_CONS = 2,
/** Delay open until first syslog() */
	LOG_ODELAY = 4,
/** Do not delay open */
	LOG_NDELAY = 8,
/** Do not wait for console forks */
	LOG_NOWAIT = 0x10,
/** Log to stderr as well */
	LOG_PERROR = 0x20
};

/** Facility codes for openlog() */
enum FACILITY_FLAGS {
/** Kernel messages */
	LOG_KERN = 0,
/** Random user-level messages */
	LOG_USER = 8,
/** Mail system */
	LOG_MAIL = 16,
/** System daemons */
	LOG_DAEMON = 24,
/** Security/authorization messages */
	LOG_AUTH = 32,
/** Messages generated internally by syslogd */
	LOG_SYSLOG = 40,
/** Line printer subsystem */
	LOG_LPR = 48,
/** Network news subsystem */
	LOG_NEWS = 56,
/** UUCP subsystem */
	LOG_UUCP = 64,
/** Clock daemon */
	LOG_CRON = 72,
/** Security/authorization messages (private) */
	LOG_AUTHPRIV = 80,
/** FTP daemon */
	LOG_FTP = 88,
// Other codes through 15 (reserved for system use) */
	LOG_LOCAL0 = 128,
	LOG_LOCAL1 = 136,
	LOG_LOCAL2 = 144,
	LOG_LOCAL3 = 152,
	LOG_LOCAL4 = 160,
	LOG_LOCAL5 = 168,
	LOG_LOCAL6 = 176,
	LOG_LOCAL7 = 184
};

/** Flags for prf() */
enum PRF_FLAGS {
/** Output to console */
	TOCONS = 1,
/** Output to tty */
	TOTTY = 2,
/** Output to log (log lock not held) */
	TOLOG = 4,
/** Output to string */
	TOSTR = 8,
/** Output to log (log lock held) */
	TOLOGLOCKED = 0x10
};


#define HAVE_DECL_WARNC   1
#define HAVE_DECL_VWARNC   1
#define HAVE_DECL_ERRC   1
#define HAVE_DECL_VERRC   1
/** Mask to extract logging priority */
#define LOG_PRIMASK   7
/** Extract priority */
#define LOG_PRI(p)   ((p) & LOG_PRIMASK)
#define LOG_MAKEPRI(fac, pri)   (((fac) << 3) | (pri))
/** Log mask to extract facility part */
#define LOG_FACMASK   0x3f8
#define LOG_FAC(p)   (((p) & LOG_FACMASK) >> 3)
#define LOG_MASK(pri)   set1bit(pri)
#define LOG_UPTO(pri)   ((1 << ((pri) + 1)) - 1)
/** The "no priority" priority */
#define INTERNAL_NOPRI   0x10
#define LOG_TYPE_OFF   0
#define LOG_TYPE_TTY   1
#define LOG_TYPE_FILE   2
/** Current number of log facilities */
#define LOG_NFACILITIES   24

/** Global variable used to store the logging type */
static volatile UNUSED int log_type = LOG_TYPE_OFF;
/** Log file, if needed */
static UNUSED FILE* log_file = NULL;
/** @def log_level
Global variable used to store the debug level */
#if (defined(DEBUG) && (!(defined(NODEBUG) || defined(NDEBUG))))
static volatile UNUSED int log_level = LOG_DEBUG;
#else
static volatile UNUSED int log_level = LOG_NONE;
#endif

typedef struct attr_packed _err_code { char* c_name; int c_val; }   ERR_CODE;

typedef struct attr_packed syslog_data {
	int log_version, log_file, log_connected, log_opened, log_stat;
	const char* log_tag;
	char log_hostname[256];
	int log_fac, log_mask;
} syslog_data_t;


#define SYSLOG_DATA_INIT   { -1, 0, 0, 0, 0, (const char*)0, "\0", LOG_USER, 0xff }
static volatile UNUSED struct syslog_data sdata = SYSLOG_DATA_INIT;


// ERROR FUNCTIONS

/** Issue an error message and then exit */
LIB_FUNC noreturn COLD ATTR_PRINTF(2, 0) void verr(const int eval, const char* restrict fmt, va_list ap) {
	const int sverrno = get_errno();
	(void)fprintf(stderr, "%s: ", getprogname());
	(void)vfprintf(stderr, fmt, ap);
	(void)fprintf(stderr, ": ");
	puts_err_no_output(strerror(sverrno));
	_Exit(eval);
	UNREACHABLE
}
#define sh_verr(eval, fmt, ...)   verr((eval), (fmt), (__VA_ARGS__))
#define _verr(eval, fmt, ...)   verr((eval), (fmt), (__VA_ARGS__))


/** Issue an error message and then exit */
LIB_FUNC noreturn COLD ATTR_PRINTF(2, 0) void verrx(const int eval, const char* restrict fmt, va_list ap) {
	(void)fprintf(stderr, "%s: ", getprogname());
	(void)vfprintf(stderr, fmt, ap);
	puts_err_no_output("");
	_Exit(eval);
	UNREACHABLE
}
#define sh_verrx(eval, fmt, ap)   verrx((eval), (fmt), (ap))
#define _verrx(eval, fmt, ap)   verrx((eval), (fmt), (ap))


/** Issue an error message and then exit */
LIB_FUNC noreturn COLD ATTR_PRINTF(2, 3) void err(const int eval, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	_verr(eval, fmt, ap);
	va_end(ap);
}
#define sh_err(eval, fmt, ...)   err((eval), (fmt), (__VA_ARGS__))
#define _err(eval, fmt, ...)   err((eval), (fmt), (__VA_ARGS__))


/** Issue an error message and then exit */
LIB_FUNC noreturn COLD ATTR_PRINTF(2, 3) void errx(const int eval, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	_verrx(eval, fmt, ap);
	va_end(ap);
}
#define sh_errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))
#define _sh_errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))
#define _errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))


// WARNING FUNCTIONS

/** Issue an warning message, but do not exit */
LIB_FUNC ATTR_PRINTF(1, 0) void vwarn(const char* restrict fmt, va_list ap) {
	const int sverrno = get_errno();
	(void)fprintf(stderr, "%s: ", getprogname());
	(void)vfprintf(stderr, fmt, ap);
	(void)fprintf(stderr, ": ");
	puts_err_no_output(strerror(sverrno));
}
#define sh_vwarn(fmt, ap)   vwarn((fmt), (ap))
#define _sh_vwarn(fmt, ap)   vwarn((fmt), (ap))
#define _vwarn(fmt, ap)   vwarn((fmt), (ap))


/** Issue an warning message, but do not exit */
LIB_FUNC ATTR_PRINTF(1, 0) void vwarnx(const char* restrict fmt, va_list ap) {
	(void)fprintf(stderr, "%s: ", getprogname());
	(void)vfprintf(stderr, fmt, ap);
	puts_err_no_output("");
}
#define sh_vwarnx(fmt, ap)   vwarnx((fmt), (ap))
#define _sh_vwarnx(fmt, ap)   vwarnx((fmt), (ap))
#define _vwarnx(fmt, ap)   vwarnx((fmt), (ap))


/** Issue an warning message, but do not exit */
LIB_FUNC ATTR_PRINTF(1, 2) void warn(const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	vwarn(fmt, ap);
	va_end(ap);
}
#define sh_warn(fmt, ...)   warn((fmt), (__VA_ARGS__))
#define _sh_warn(fmt, ...)   warn((fmt), (__VA_ARGS__))
#define _warn(fmt, ...)   warn((fmt), (__VA_ARGS__))


/** Issue an warning message, but do not exit */
LIB_FUNC ATTR_PRINTF(1, 2) void warnx(const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
}
#define sh_warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))
#define _sh_warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))
#define _warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))


LIB_FUNC noreturn COLD ATTR_PRINTF(1, 2) void fail(const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	char align64 buf[2048] = { 0 };
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	warnx("%s\n", buf);
	puts_err_no_output("This is probably a bug in this application or one of the libraries it uses.");
	abort();
}


// MISCELLANEOUS LOGGING FUNCTIONS

/** Open logging to TTY */
LIB_FUNC void log_open_tty(const int level) {
	log_type = LOG_TYPE_TTY;
	log_level = level;
	setlinebuf(stderr);
	setlinebuf(stdout);
	tzset();
}


/** Open logging to file */
LIB_FUNC void log_open_file(const int level, const char* restrict path) {
	log_file = fopen(path, "w");
	if (log_file == (FILE*)NULL) { return; }
	log_type = LOG_TYPE_FILE;
	log_level = level;
	setlinebuf(log_file);
	tzset();
}


/** Close logging */
LIB_FUNC void log_close(void) {
	if (log_type == LOG_TYPE_FILE) { fclose(log_file); }
	log_type = LOG_TYPE_OFF;
}
#define closelog()   log_close()


/** Write a log message */
LIB_FUNC ATTR_PRINTF(2, 0) void log_vwrite(const int pri, const char* restrict msg, va_list ap) {
	FILE* fp = log_file;
	switch (log_type) {
		case LOG_TYPE_TTY:
			if (pri == LOG_INFO) { fp = stdout; }
			else { fp = stderr; }
			fflush(fp);
			break;
		case LOG_TYPE_FILE:
			if ((fputc('\n', fp) == -1) || (vfprintf(fp, msg, ap) == -1)) { _Exit(1); }
		default:
			fflush(fp);
			break;
	}
}


/** Log a warning with error string */
LIB_FUNC ATTR_PRINTF(1, 2) void log_warn(const char* restrict msg, ...) {
	const int sverrno = get_errno();
	va_list ap;
	va_start(ap, msg);
	char* fmt;
	if (asprintf(&fmt, "%s: %s", msg, strerror(sverrno)) == -1) { _Exit(1); }
	DIAG_PUSH
	IGNORE_WFORMAT_NONLITERAL
	log_vwrite(LOG_CRIT, fmt, ap);
	DIAG_POP
	free(fmt);
	va_end(ap);
}


/** Log a warning */
LIB_FUNC ATTR_PRINTF(1, 2) void log_warnx(const char* restrict msg, ...) {
	va_list ap;
	va_start(ap, msg);
	log_vwrite(LOG_WARNING, msg, ap);
	va_end(ap);
}


/** Log an informational message */
LIB_FUNC ATTR_PRINTF(1, 2) void log_info(const char* restrict msg, ...) {
	if (log_level >= LOG_INFO) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_INFO, msg, ap);
		va_end(ap);
	}
}


/** Log a debugging message */
LIB_FUNC ATTR_PRINTF(1, 2) void log_debug(const char* restrict msg, ...) {
	if (log_level >= LOG_DEBUG) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_DEBUG, msg, ap);
		va_end(ap);
	}
}


/** Log a debugging message at level 2 */
LIB_FUNC ATTR_PRINTF(1, 2) void log_debug2(const char* restrict msg, ...) {
	if (log_level == LOG_DEBUG) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_DEBUG, msg, ap);
		va_end(ap);
	}
}


/** Log a critical error, with error string if necessary, and die */
LIB_FUNC noreturn COLD ATTR_PRINTF(1, 0) void log_vfatal(const char* restrict msg, va_list ap) {
	const int sverrno = get_errno();
	char* fmt;
	DIAG_PUSH
	IGNORE_WFORMAT_NONLITERAL
	if (sverrno != 0) {
		if (asprintf(&fmt, "fatal: %s: %s", msg, strerror(sverrno)) == -1) { _Exit(EXIT_FAILURE); }
		log_vwrite(LOG_CRIT, fmt, ap);
	} else {
		if (asprintf(&fmt, "fatal: %s", msg) == -1) { _Exit(EXIT_FAILURE); }
		log_vwrite(LOG_CRIT, fmt, ap);
	}
	DIAG_POP
	_Exit(EXIT_FAILURE);
	UNREACHABLE
}


/** Log a critical error, with error string, and die */
LIB_FUNC noreturn COLD ATTR_PRINTF(1, 2) void log_fatal(const char* msg, ...) {
	va_list ap;
	va_start(ap, msg);
	log_vfatal(msg, ap);
	UNREACHABLE
}


/** Signal that a fatal error occurred */
#define fatal(msg)   log_fatal("%s: %s", __func__, msg);


/** Log a critical error and die */
LIB_FUNC noreturn COLD ATTR_PRINTF(1, 2) void log_fatalx(const char* msg, ...) {
	clr_errno();
	va_list ap;
	va_start(ap, msg);
	log_vfatal(msg, ap);
	UNREACHABLE
}


/** Signal that a fatal error occurred */
#define fatalx(msg)   log_fatalx("%s: %s", __func__, msg);


/** Display a hex-dump */
LIB_FUNC void hexdump(const unsigned char* restrict d, const unsigned int size) {
	register unsigned int s;
	for (s = 0; s < size; s += 4) {
		fprintf(stdout, "0x%04x 0x%02X%02X%02X%02X %c%c%c%c\n", s, (unsigned int)d[s], (unsigned int)d[s + 1], (unsigned int)d[s + 2], (unsigned int)d[s + 3], d[s], d[s + 1], d[s + 2], d[s + 3]);
	}
}


/** Set the log mask level */
LIB_FUNC int setlogmask_r(const int pmask, volatile struct syslog_data* restrict data) {
	const int omask = data->log_mask;
	if (pmask != 0) { data->log_mask = pmask; }
	return omask;
}


/** Set the log mask level */
LIB_FUNC int setlogmask(const int pmask) {
	const int omask = sdata.log_mask;
	if (pmask != 0) { sdata.log_mask = pmask; }
	return omask;
}


/* TODO: Add err.h & syslog.h functions
err_set_exit
err_set_file
void logpri(int);
ATTR_PRINTF(2, 3) void log(int, const char*, ...);
ATTR_PRINTF(2, 0) void vlog(int, const char*, __va_list);
ATTR_PRINTF(1, 2) void addlog(const char*, ...);
void logwakeup(void);
void openlog(const char*, int, int);
void syslog(int, const char*, ...);
*/


#endif  // LOGGING


/* ASSERT (<assert.h>) */


#if (!(defined(ASSERT_H) || defined(_ASSERT_H) || defined(_ASSERT_H_)))  // http://www.cplusplus.com/reference/cassert/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/assert.h.html
#define ASSERT_H   (1)
#define _ASSERT_H   (1)
#define _ASSERT_H_   (1)
#define _PDCLIB_ASSERT_H   (1)


#undef assert
#undef _assert
#undef __assert
#undef __ASSERT_VOID_CAST
#if IS_CPLUSPLUS
#   define __ASSERT_VOID_CAST   static_cast<void>
#else
#   define __ASSERT_VOID_CAST   ((void)0)
#endif
#define __ASSERT_FUNCTION   __func__
#if IS_GNUC
#   define __OS_COMPILETIME_ASSERT__(e)   ( __extension__ ({ char __compile_time_assert__[(e) ? 1 : -1]; (void)__compile_time_assert__; }))
#   define OS_COMPILETIME_ASSERT(e)   ( __extension__ ({ char __compile_time_assert__[(e) ? 1 : -1]; (void)__compile_time_assert__; }))
#else
#   define __OS_COMPILETIME_ASSERT__(e)   (e)
#   define OS_COMPILETIME_ASSERT(e)   (e)
#endif
#define DIAGASSERT_ABORT   1
#define DIAGASSERT_STDERR   2
#define DIAGASSERT_SYSLOG   4

static volatile UNUSED int diagassert_flags = -1;


// If NDEBUG is defined, do nothing; If not, and EXPRESSION is zero, then print an error message and abort
#ifdef NDEBUG
#   define assert(expr)
#   define diagassert(expr)
#   define __diagassert(expr)
#   define __assert_fail(expr, file, line, func)
#else  // No NDEBUG
#   define __assert(expr, file, line, func)   ((void)fprintf(stderr, "%s:%u: Failed assertion `%s` in `%s`\n", file, line, expr, func); abort())


LIB_FUNC COLD void __diagassert(const char* restrict failedexpr, const char* restrict file, const int line, const char* restrict function) {
	register int diag_flags = diagassert_flags;
	if (diag_flags == -1) {
		diag_flags = DIAGASSERT_SYSLOG;
		const char* restrict p = getenv("LIBC_DIAGASSERT");
		for (; p && *p; p++) {
			switch (*p) {
				case 'a':
					diag_flags |= DIAGASSERT_ABORT;
					break;
				case 'A':
					diag_flags &= (~DIAGASSERT_ABORT);
					break;
				case 'e':
					diag_flags |= DIAGASSERT_STDERR;
					break;
				case 'E':
					diag_flags &= (~DIAGASSERT_STDERR);
					break;
				case 'l':
					diag_flags |= DIAGASSERT_SYSLOG;
					break;
				case 'L':
					diag_flags &= (~DIAGASSERT_SYSLOG);
					break;
				default: break;
			}
		}
	}
	char align64 buf[2048] = { 0 };
	snprintf(buf, sizeof(buf), "assertion \"%s\" failed: file \"%s\", line %d%s%s%s", failedexpr, file, line, function ? ", function \"" : "", function ? function : "", function ? "\"" : "");
	if (diag_flags & DIAGASSERT_STDERR) { (void)fprintf(stderr, "%s: %s\n", getprogname(), buf); }
	if (diag_flags & DIAGASSERT_SYSLOG) { syslog((LOG_DEBUG | LOG_USER), "%s", buf); }
	diagassert_flags = diag_flags;
	if (diag_flags & DIAGASSERT_ABORT) { abort(); }
}


#   if IS_GNUC
#      define assert(expr)   (PREDICT_UNLIKELY((expr), 0) ? (void)0 : __assert(#expr, __FILE__, __LINE__, __func__))
#      define diagassert(expr)   (PREDICT_UNLIKELY((expr), 0) ? __static_cast(void, 0) : __diagassert(#expr, __FILE__, __LINE__, __func__))
#   else  // Not GNU-GCC
#      define assert(expr)   ((void)((expr) ? ((void)0) : __assert(#expr, __FILE__, __LINE__, __func__)))
#      define diagassert(expression)   ((void)((expression) ? __static_cast(void, 0) : __diagassert(#expression, __FILE__, __LINE__, __func__)))
#   endif


LIB_FUNC noreturn COLD void __assert_fail(const char* restrict expr, const char* restrict file, const int _line, const char* restrict func) {
	fprintf(stderr, "Assertion failed: %s (%s: %s: %d)\n", expr, file, func, _line);
	fflush(NULL);
	abort();
}


#endif  // NDEBUG


#define _assert(expression)   assert(expression)
#define __assert13(expression)   assert(expression)
#define ASSERT(expression)   assert(expression)
#define ASSERTION(expression)   assert(expression)
#define assertion(expression)   assert(expression)
#define __diagassert13(expression)   diagassert(expression)
#define diagassert13(expression)   diagassert(expression)
#define _DIAGASSERT(expression)   diagassert(expression)
#define DIAGASSERT(expression)   diagassert(expression)
#define __warn_references(x, y)
#if DEBUG
#   define __reent_assert(x)   assert(x)
#else
#   define __reent_assert(x)   ((void)0)
#endif
#ifndef BUG_ON
#   define BUG_ON(c)   assert(!(c))
#endif
#ifndef WARN_ON
#   define WARN_ON(c)   BUG_ON((c))
#endif


// MISCELLANEOUS DEBUGGING MACROS

#define __TEST_RESULTS_FAILURE_MSG   " " ANSI_SGR_FG_RED "FAILED!" ANSI_SGR_END
/** Indicate whether the given results evaluate to true or not */
#define DEV_TEST_RESULTS(test_exp, str, results, print_type)   (results ? puts_no_output(str ": SUCCESS!") : (void)printf(str __TEST_RESULTS_FAILURE_MSG ": " print_type "\n", (test_exp)))
/** Indicate whether the command produced the desired boolean output or not */
#define BOOLEAN_TEST_RESULTS(test_exp, expected_value)   register bool tmpmvar = (bool)((int)(test_exp) == (int)(expected_value)); DEV_TEST_RESULTS(test_exp, #test_exp, tmpmvar, "%i")
/** Indicate whether the command produced the desired boolean output or not (unsigned error message) */
#define BOOLEAN_TEST_RESULTS_U(test_exp, expected_value)   register bool tmpmvar = (bool)((unsigned int)(test_exp) == (unsigned int)(expected_value)); DEV_TEST_RESULTS(test_exp, #test_exp, tmpmvar, "%u")
/** Indicate whether the command produced one of the two desired outputs or not */
#define VAL2_TEST_RESULTS(test_exp, expected_value1, expected_value2)   register bool tmpmvar = (bool)(((int)(test_exp) == (int)(expected_value1)) || ((int)(test_exp) == (int)(expected_value2))); DEV_TEST_RESULTS(test_exp, #test_exp, tmpmvar, "%i")
/** Indicate whether the command produced one of the two desired outputs or not (unsigned error message) */
#define VAL2_TEST_RESULTS_U(test_exp, expected_value1, expected_value2)   register bool tmpmvar = (bool)(((unsigned int)(test_exp) == (unsigned int)(expected_value1)) || ((unsigned int)(test_exp) == (unsigned int)(expected_value2))); DEV_TEST_RESULTS(test_exp, #test_exp, tmpmvar, "%u")
#define print_code_location()   puts_no_output(CODE_LOCATION)
/** Debugging macros that prints the line number and filename indicating the location of the macro; This allows developers to more quickly debug applications by getting a location printed to stderr; `TAG` must be a string; A newline is append to the end */
#define DEBUGPRINT(TAG)   fprintf(stderr, WHERESTR "%s\n", WHEREARG, TAG)
/** Print the datatype of the given data */
#define printdatatype(x)   puts_no_output(typename(x))


#endif  // ASSERT_H


/* SYSTEM CALLS */


#if ((!(defined(SYSCALL_H) || defined(_SYSCALL_H) || defined(_SYSCALL_H_) || defined(_INTERNAL_SYSCALL_H) || defined(_INTERNAL_SYSCALL_H_) || defined(_SYS_SYSCALL_H) || defined(_SYS_SYSCALL_H_) || defined(_SYSCALLS_COMMON_H) || defined(_SYSCALLS_COMMON_H_) || defined(_BITS_SYSCALLS_H) || defined(_BITS_SYSCALLS_H_))) && IS_NOT_ASSEMBLER)
#define SYSCALL_H   (1)
#define _SYSCALL_H   (1)
#define _SYSCALL_H_   (1)
#define _SYS_SYSCALL_H   (1)
#define _SYS_SYSCALL_H_   (1)
#define _INTERNAL_SYSCALL_H   (1)
#define _INTERNAL_SYSCALL_H_   (1)
#define SYSCALLS_COMMON_H   (1)
#define _SYSCALLS_COMMON_H   (1)
#define _SYSCALLS_COMMON_H_   (1)
#define BITS_SYSCALLS_H  (1)
#define _BITS_SYSCALLS_H  (1)
#define _BITS_SYSCALLS_H_  (1)


#ifndef SYSCALL_RLIM_INFINITY
#   ifdef ARCHMIPS
#      define SYSCALL_RLIM_INFINITY   (-1UL / 2)
#   else
#      define SYSCALL_RLIM_INFINITY   ((unsigned long long)(~0ULL))
#   endif
#endif
#ifndef SYSCALL_MMAP2_UNIT
#   define SYSCALL_MMAP2_UNIT   (4096ULL)
#endif
#ifndef DEFAULT_SYSCALL_CLOBBERS
#   define DEFAULT_SYSCALL_CLOBBERS   "memory", "cc"
#endif


// DARWIN SYSTEM CALLS

#if (defined(OSDARWIN) && defined(ARCHX86))
#   define SYS_MAXSYSCALL   439
#   define SYS_syscall   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_wait4   7
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_getfsstat   18
#   define SYS_getpid   20
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_sigaction   46
#   define SYS_getgid   47
#   define SYS_sigprocmask   48
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigpending   52
#   define SYS_sigaltstack   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_msync   65
#   define SYS_vfork   66
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_setitimer   83
#   define SYS_swapon   85
#   define SYS_getitimer   86
#   define SYS_getdtablesize   89
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_select   93
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_sigsuspend   111
#   define SYS_gettimeofday   116
#   define SYS_getrusage   117
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_settimeofday   122
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_utimes   138
#   define SYS_futimes   139
#   define SYS_adjtime   140
#   define SYS_gethostuuid   142
#   define SYS_setsid   147
#   define SYS_getpgid   151
#   define SYS_setprivexec   152
#   define SYS_pread   153
#   define SYS_pwrite   154
#   define SYS_nfssvc   155
#   define SYS_statfs   157
#   define SYS_fstatfs   158
#   define SYS_unmount   159
#   define SYS_getfh   161
#   define SYS_quotactl   165
#   define SYS_mount   167
#   define SYS_csops   169
#   define SYS_waitid   173
#   define SYS_add_profil   176
#   define SYS_kdebug_trace   180
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_sigreturn   184
#   define SYS_chud   185
#   define SYS_fdatasync   187
#   define SYS_stat   188
#   define SYS_fstat   189
#   define SYS_lstat   190
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_getdirentries   196
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_atsocket   206
#   define SYS_atgetmsg   207
#   define SYS_atputmsg   208
#   define SYS_atpsndreq   209
#   define SYS_atpsndrsp   210
#   define SYS_atpgetreq   211
#   define SYS_atpgetrsp   212
#   define SYS_mkcomplex   216
#   define SYS_statv   217
#   define SYS_lstatv   218
#   define SYS_fstatv   219
#   define SYS_getattrlist   220
#   define SYS_setattrlist   221
#   define SYS_getdirentriesattr   222
#   define SYS_exchangedata   223
#   define SYS_searchfs   225
#   define SYS_delete   226
#   define SYS_copyfile   227
#   define SYS_fgetattrlist   228
#   define SYS_fsetattrlist   229
#   define SYS_poll   230
#   define SYS_watchevent   231
#   define SYS_waitevent   232
#   define SYS_modwatch   233
#   define SYS_getxattr   234
#   define SYS_fgetxattr   235
#   define SYS_setxattr   236
#   define SYS_fsetxattr   237
#   define SYS_removexattr   238
#   define SYS_fremovexattr   239
#   define SYS_listxattr   240
#   define SYS_flistxattr   241
#   define SYS_fsctl   242
#   define SYS_initgroups   243
#   define SYS_posix_spawn   244
#   define SYS_ffsctl   245
#   define SYS_nfsclnt   247
#   define SYS_fhopen   248
#   define SYS_minherit   250
#   define SYS_semsys   251
#   define SYS_msgsys   252
#   define SYS_shmsys   253
#   define SYS_semctl   254
#   define SYS_semget   255
#   define SYS_semop   256
#   define SYS_msgctl   258
#   define SYS_msgget   259
#   define SYS_msgsnd   260
#   define SYS_msgrcv   261
#   define SYS_shmat   262
#   define SYS_shmctl   263
#   define SYS_shmdt   264
#   define SYS_shmget   265
#   define SYS_shm_open   266
#   define SYS_shm_unlink   267
#   define SYS_sem_open   268
#   define SYS_sem_close   269
#   define SYS_sem_unlink   270
#   define SYS_sem_wait   271
#   define SYS_sem_trywait   272
#   define SYS_sem_post   273
#   define SYS_sem_getvalue   274
#   define SYS_sem_init   275
#   define SYS_sem_destroy   276
#   define SYS_open_extended   277
#   define SYS_umask_extended   278
#   define SYS_stat_extended   279
#   define SYS_lstat_extended   280
#   define SYS_fstat_extended   281
#   define SYS_chmod_extended   282
#   define SYS_fchmod_extended   283
#   define SYS_access_extended   284
#   define SYS_settid   285
#   define SYS_gettid   286
#   define SYS_setsgroups   287
#   define SYS_getsgroups   288
#   define SYS_setwgroups   289
#   define SYS_getwgroups   290
#   define SYS_mkfifo_extended   291
#   define SYS_mkdir_extended   292
#   define SYS_identitysvc   293
#   define SYS_shared_region_check_np   294
#   define SYS_vm_pressure_monitor   296
#   define SYS_psynch_rw_longrdlock   297
#   define SYS_psynch_rw_yieldwrlock   298
#   define SYS_psynch_rw_downgrade   299
#   define SYS_psynch_rw_upgrade   300
#   define SYS_psynch_mutexwait   301
#   define SYS_psynch_mutexdrop   302
#   define SYS_psynch_cvbroad   303
#   define SYS_psynch_cvsignal   304
#   define SYS_psynch_cvwait   305
#   define SYS_psynch_rw_rdlock   306
#   define SYS_psynch_rw_wrlock   307
#   define SYS_psynch_rw_unlock   308
#   define SYS_psynch_rw_unlock2   309
#   define SYS_getsid   310
#   define SYS_settid_with_pid   311
#   define SYS_psynch_cvclrprepost   312
#   define SYS_aio_fsync   313
#   define SYS_aio_return   314
#   define SYS_aio_suspend   315
#   define SYS_aio_cancel   316
#   define SYS_aio_error   317
#   define SYS_aio_read   318
#   define SYS_aio_write   319
#   define SYS_lio_listio   320
#   define SYS_iopolicysys   322
#   define SYS_process_policy   323
#   define SYS_mlockall   324
#   define SYS_munlockall   325
#   define SYS_issetugid   327
#   define SYS___pthread_kill   328
#   define SYS___pthread_sigmask   329
#   define SYS___sigwait   330
#   define SYS___disable_threadsignal   331
#   define SYS___pthread_markcancel   332
#   define SYS___pthread_canceled   333
#   define SYS___semwait_signal   334
#   define SYS_proc_info   336
#   define SYS_sendfile   337
#   define SYS_stat64   338
#   define SYS_fstat64   339
#   define SYS_lstat64   340
#   define SYS_stat64_extended   341
#   define SYS_lstat64_extended   342
#   define SYS_fstat64_extended   343
#   define SYS_getdirentries64   344
#   define SYS_statfs64   345
#   define SYS_fstatfs64   346
#   define SYS_getfsstat64   347
#   define SYS___pthread_chdir   348
#   define SYS___pthread_fchdir   349
#   define SYS_audit   350
#   define SYS_auditon   351
#   define SYS_getauid   353
#   define SYS_setauid   354
#   define SYS_getaudit   355
#   define SYS_setaudit   356
#   define SYS_getaudit_addr   357
#   define SYS_setaudit_addr   358
#   define SYS_auditctl   359
#   define SYS_bsdthread_create   360
#   define SYS_bsdthread_terminate   361
#   define SYS_kqueue   362
#   define SYS_kevent   363
#   define SYS_lchown   364
#   define SYS_stack_snapshot   365
#   define SYS_bsdthread_register   366
#   define SYS_workq_open   367
#   define SYS_workq_kernreturn   368
#   define SYS_kevent64   369
#   define SYS___old_semwait_signal   370
#   define SYS___old_semwait_signal_nocancel   371
#   define SYS_thread_selfid   372
#   define SYS___mac_execve   380
#   define SYS___mac_syscall   381
#   define SYS___mac_get_file   382
#   define SYS___mac_set_file   383
#   define SYS___mac_get_link   384
#   define SYS___mac_set_link   385
#   define SYS___mac_get_proc   386
#   define SYS___mac_set_proc   387
#   define SYS___mac_get_fd   388
#   define SYS___mac_set_fd   389
#   define SYS___mac_get_pid   390
#   define SYS___mac_get_lcid   391
#   define SYS___mac_get_lctx   392
#   define SYS___mac_set_lctx   393
#   define SYS_setlcid   394
#   define SYS_getlcid   395
#   define SYS_read_nocancel   396
#   define SYS_write_nocancel   397
#   define SYS_open_nocancel   398
#   define SYS_close_nocancel   399
#   define SYS_wait4_nocancel   400
#   define SYS_recvmsg_nocancel   401
#   define SYS_sendmsg_nocancel   402
#   define SYS_recvfrom_nocancel   403
#   define SYS_accept_nocancel   404
#   define SYS_msync_nocancel   405
#   define SYS_fcntl_nocancel   406
#   define SYS_select_nocancel   407
#   define SYS_fsync_nocancel   408
#   define SYS_connect_nocancel   409
#   define SYS_sigsuspend_nocancel   410
#   define SYS_readv_nocancel   411
#   define SYS_writev_nocancel   412
#   define SYS_sendto_nocancel   413
#   define SYS_pread_nocancel   414
#   define SYS_pwrite_nocancel   415
#   define SYS_waitid_nocancel   416
#   define SYS_poll_nocancel   417
#   define SYS_msgsnd_nocancel   418
#   define SYS_msgrcv_nocancel   419
#   define SYS_sem_wait_nocancel   420
#   define SYS_aio_suspend_nocancel   421
#   define SYS___sigwait_nocancel   422
#   define SYS___semwait_signal_nocancel   423
#   define SYS___mac_mount   424
#   define SYS___mac_get_mount   425
#   define SYS___mac_getfsstat   426
#   define SYS_fsgetpath   427
#   define SYS_audit_session_self   428
#   define SYS_audit_session_join   429
#   define SYS_fileport_makeport   430
#   define SYS_fileport_makefd   431
#   define SYS_audit_session_port   432
#   define SYS_pid_suspend   433
#   define SYS_pid_resume   434
#   define SYS_pid_hibernate   435
#   define SYS_pid_shutdown_sockets   436
#   define SYS_shared_region_map_and_slide_np   438
#endif

#if (defined(OSDARWIN) && defined(ARCHAARCH64))
#   define SYS_MAXSYSCALL   440
#   define SYS_syscall   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_wait4   7
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_getfsstat   18
#   define SYS_getpid   20
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_sigaction   46
#   define SYS_getgid   47
#   define SYS_sigprocmask   48
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigpending   52
#   define SYS_sigaltstack   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_msync   65
#   define SYS_vfork   66
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_setitimer   83
#   define SYS_swapon   85
#   define SYS_getitimer   86
#   define SYS_getdtablesize   89
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_select   93
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_sigsuspend   111
#   define SYS_gettimeofday   116
#   define SYS_getrusage   117
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_settimeofday   122
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_utimes   138
#   define SYS_futimes   139
#   define SYS_adjtime   140
#   define SYS_gethostuuid   142
#   define SYS_setsid   147
#   define SYS_getpgid   151
#   define SYS_setprivexec   152
#   define SYS_pread   153
#   define SYS_pwrite   154
#   define SYS_nfssvc   155
#   define SYS_statfs   157
#   define SYS_fstatfs   158
#   define SYS_unmount   159
#   define SYS_getfh   161
#   define SYS_quotactl   165
#   define SYS_mount   167
#   define SYS_csops   169
#   define SYS_csops_audittoken   170
#   define SYS_waitid   173
#   define SYS_kdebug_trace   180
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_sigreturn   184
#   define SYS_chud   185
#   define SYS_fdatasync   187
#   define SYS_stat   188
#   define SYS_fstat   189
#   define SYS_lstat   190
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_getdirentries   196
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_atsocket   206
#   define SYS_atgetmsg   207
#   define SYS_atputmsg   208
#   define SYS_atpsndreq   209
#   define SYS_atpsndrsp   210
#   define SYS_atpgetreq   211
#   define SYS_atpgetrsp   212
#   define SYS_open_dprotected_np   216
#   define SYS_getattrlist   220
#   define SYS_setattrlist   221
#   define SYS_getdirentriesattr   222
#   define SYS_exchangedata   223
#   define SYS_searchfs   225
#   define SYS_delete   226
#   define SYS_copyfile   227
#   define SYS_fgetattrlist   228
#   define SYS_fsetattrlist   229
#   define SYS_poll   230
#   define SYS_watchevent   231
#   define SYS_waitevent   232
#   define SYS_modwatch   233
#   define SYS_getxattr   234
#   define SYS_fgetxattr   235
#   define SYS_setxattr   236
#   define SYS_fsetxattr   237
#   define SYS_removexattr   238
#   define SYS_fremovexattr   239
#   define SYS_listxattr   240
#   define SYS_flistxattr   241
#   define SYS_fsctl   242
#   define SYS_initgroups   243
#   define SYS_posix_spawn   244
#   define SYS_ffsctl   245
#   define SYS_nfsclnt   247
#   define SYS_fhopen   248
#   define SYS_minherit   250
#   define SYS_semsys   251
#   define SYS_msgsys   252
#   define SYS_shmsys   253
#   define SYS_semctl   254
#   define SYS_semget   255
#   define SYS_semop   256
#   define SYS_msgctl   258
#   define SYS_msgget   259
#   define SYS_msgsnd   260
#   define SYS_msgrcv   261
#   define SYS_shmat   262
#   define SYS_shmctl   263
#   define SYS_shmdt   264
#   define SYS_shmget   265
#   define SYS_shm_open   266
#   define SYS_shm_unlink   267
#   define SYS_sem_open   268
#   define SYS_sem_close   269
#   define SYS_sem_unlink   270
#   define SYS_sem_wait   271
#   define SYS_sem_trywait   272
#   define SYS_sem_post   273
#   define SYS_sem_getvalue   274
#   define SYS_sem_init   275
#   define SYS_sem_destroy   276
#   define SYS_open_extended   277
#   define SYS_umask_extended   278
#   define SYS_stat_extended   279
#   define SYS_lstat_extended   280
#   define SYS_fstat_extended   281
#   define SYS_chmod_extended   282
#   define SYS_fchmod_extended   283
#   define SYS_access_extended   284
#   define SYS_settid   285
#   define SYS_gettid   286
#   define SYS_setsgroups   287
#   define SYS_getsgroups   288
#   define SYS_setwgroups   289
#   define SYS_getwgroups   290
#   define SYS_mkfifo_extended   291
#   define SYS_mkdir_extended   292
#   define SYS_identitysvc   293
#   define SYS_shared_region_check_np   294
#   define SYS_vm_pressure_monitor   296
#   define SYS_psynch_rw_longrdlock   297
#   define SYS_psynch_rw_yieldwrlock   298
#   define SYS_psynch_rw_downgrade   299
#   define SYS_psynch_rw_upgrade   300
#   define SYS_psynch_mutexwait   301
#   define SYS_psynch_mutexdrop   302
#   define SYS_psynch_cvbroad   303
#   define SYS_psynch_cvsignal   304
#   define SYS_psynch_cvwait   305
#   define SYS_psynch_rw_rdlock   306
#   define SYS_psynch_rw_wrlock   307
#   define SYS_psynch_rw_unlock   308
#   define SYS_psynch_rw_unlock2   309
#   define SYS_getsid   310
#   define SYS_settid_with_pid   311
#   define SYS_psynch_cvclrprepost   312
#   define SYS_aio_fsync   313
#   define SYS_aio_return   314
#   define SYS_aio_suspend   315
#   define SYS_aio_cancel   316
#   define SYS_aio_error   317
#   define SYS_aio_read   318
#   define SYS_aio_write   319
#   define SYS_lio_listio   320
#   define SYS_iopolicysys   322
#   define SYS_process_policy   323
#   define SYS_mlockall   324
#   define SYS_munlockall   325
#   define SYS_issetugid   327
#   define SYS___pthread_kill   328
#   define SYS___pthread_sigmask   329
#   define SYS___sigwait   330
#   define SYS___disable_threadsignal   331
#   define SYS___pthread_markcancel   332
#   define SYS___pthread_canceled   333
#   define SYS___semwait_signal   334
#   define SYS_proc_info   336
#   define SYS_sendfile   337
#   define SYS_stat64   338
#   define SYS_fstat64   339
#   define SYS_lstat64   340
#   define SYS_stat64_extended   341
#   define SYS_lstat64_extended   342
#   define SYS_fstat64_extended   343
#   define SYS_getdirentries64   344
#   define SYS_statfs64   345
#   define SYS_fstatfs64   346
#   define SYS_getfsstat64   347
#   define SYS___pthread_chdir   348
#   define SYS___pthread_fchdir   349
#   define SYS_audit   350
#   define SYS_auditon   351
#   define SYS_getauid   353
#   define SYS_setauid   354
#   define SYS_getaudit_addr   357
#   define SYS_setaudit_addr   358
#   define SYS_auditctl   359
#   define SYS_bsdthread_create   360
#   define SYS_bsdthread_terminate   361
#   define SYS_kqueue   362
#   define SYS_kevent   363
#   define SYS_lchown   364
#   define SYS_stack_snapshot   365
#   define SYS_bsdthread_register   366
#   define SYS_workq_open   367
#   define SYS_workq_kernreturn   368
#   define SYS_kevent64   369
#   define SYS___old_semwait_signal   370
#   define SYS___old_semwait_signal_nocancel   371
#   define SYS_thread_selfid   372
#   define SYS_ledger   373
#   define SYS___mac_execve   380
#   define SYS___mac_syscall   381
#   define SYS___mac_get_file   382
#   define SYS___mac_set_file   383
#   define SYS___mac_get_link   384
#   define SYS___mac_set_link   385
#   define SYS___mac_get_proc   386
#   define SYS___mac_set_proc   387
#   define SYS___mac_get_fd   388
#   define SYS___mac_set_fd   389
#   define SYS___mac_get_pid   390
#   define SYS___mac_get_lcid   391
#   define SYS___mac_get_lctx   392
#   define SYS___mac_set_lctx   393
#   define SYS_setlcid   394
#   define SYS_getlcid   395
#   define SYS_read_nocancel   396
#   define SYS_write_nocancel   397
#   define SYS_open_nocancel   398
#   define SYS_close_nocancel   399
#   define SYS_wait4_nocancel   400
#   define SYS_recvmsg_nocancel   401
#   define SYS_sendmsg_nocancel   402
#   define SYS_recvfrom_nocancel   403
#   define SYS_accept_nocancel   404
#   define SYS_msync_nocancel   405
#   define SYS_fcntl_nocancel   406
#   define SYS_select_nocancel   407
#   define SYS_fsync_nocancel   408
#   define SYS_connect_nocancel   409
#   define SYS_sigsuspend_nocancel   410
#   define SYS_readv_nocancel   411
#   define SYS_writev_nocancel   412
#   define SYS_sendto_nocancel   413
#   define SYS_pread_nocancel   414
#   define SYS_pwrite_nocancel   415
#   define SYS_waitid_nocancel   416
#   define SYS_poll_nocancel   417
#   define SYS_msgsnd_nocancel   418
#   define SYS_msgrcv_nocancel   419
#   define SYS_sem_wait_nocancel   420
#   define SYS_aio_suspend_nocancel   421
#   define SYS___sigwait_nocancel   422
#   define SYS___semwait_signal_nocancel   423
#   define SYS___mac_mount   424
#   define SYS___mac_get_mount   425
#   define SYS___mac_getfsstat   426
#   define SYS_fsgetpath   427
#   define SYS_audit_session_self   428
#   define SYS_audit_session_join   429
#   define SYS_fileport_makeport   430
#   define SYS_fileport_makefd   431
#   define SYS_audit_session_port   432
#   define SYS_pid_suspend   433
#   define SYS_pid_resume   434
#   define SYS_pid_hibernate   435
#   define SYS_pid_shutdown_sockets   436
#   define SYS_shared_region_map_and_slide_np   438
#   define SYS_kas_info   439
#endif

#if (defined(OSDARWIN) && defined(ARCHAARCH32))
#   define SYS_MAXSYSCALL   427
#   define SYS_syscall   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_wait4   7
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_obreak   17
#   define SYS_ogetfsstat   18
#   define SYS_getfsstat   18
#   define SYS_getpid   20
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_sigaction   46
#   define SYS_getgid   47
#   define SYS_sigprocmask   48
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigpending   52
#   define SYS_sigaltstack   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_msync   65
#   define SYS_vfork   66
#   define SYS_sbrk   69
#   define SYS_sstk   70
#   define SYS_ovadvise   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_setitimer   83
#   define SYS_swapon   85
#   define SYS_getitimer   86
#   define SYS_getdtablesize   89
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_select   93
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_sigsuspend   111
#   define SYS_gettimeofday   116
#   define SYS_getrusage   117
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_settimeofday   122
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_utimes   138
#   define SYS_futimes   139
#   define SYS_adjtime   140
#   define SYS_gethostuuid   142
#   define SYS_setsid   147
#   define SYS_getpgid   151
#   define SYS_setprivexec   152
#   define SYS_pread   153
#   define SYS_pwrite   154
#   define SYS_nfssvc   155
#   define SYS_statfs   157
#   define SYS_fstatfs   158
#   define SYS_unmount   159
#   define SYS_getfh   161
#   define SYS_quotactl   165
#   define SYS_mount   167
#   define SYS_csops   169
#   define SYS_table   170
#   define SYS_waitid   173
#   define SYS_add_profil   176
#   define SYS_kdebug_trace   180
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_sigreturn   184
#   define SYS_chud   185
#   define SYS_stat   188
#   define SYS_fstat   189
#   define SYS_lstat   190
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_getdirentries   196
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_atsocket   206
#   define SYS_atgetmsg   207
#   define SYS_atputmsg   208
#   define SYS_atpsndreq   209
#   define SYS_atpsndrsp   210
#   define SYS_atpgetreq   211
#   define SYS_atpgetrsp   212
#   define SYS_kqueue_from_portset_np   214
#   define SYS_kqueue_portset_np   215
#   define SYS_mkcomplex   216
#   define SYS_statv   217
#   define SYS_lstatv   218
#   define SYS_fstatv   219
#   define SYS_getattrlist   220
#   define SYS_setattrlist   221
#   define SYS_getdirentriesattr   222
#   define SYS_exchangedata   223
#   define SYS_searchfs   225
#   define SYS_delete   226
#   define SYS_copyfile   227
#   define SYS_poll   230
#   define SYS_watchevent   231
#   define SYS_waitevent   232
#   define SYS_modwatch   233
#   define SYS_getxattr   234
#   define SYS_fgetxattr   235
#   define SYS_setxattr   236
#   define SYS_fsetxattr   237
#   define SYS_removexattr   238
#   define SYS_fremovexattr   239
#   define SYS_listxattr   240
#   define SYS_flistxattr   241
#   define SYS_fsctl   242
#   define SYS_initgroups   243
#   define SYS_posix_spawn   244
#   define SYS_nfsclnt   247
#   define SYS_fhopen   248
#   define SYS_minherit   250
#   define SYS_semsys   251
#   define SYS_msgsys   252
#   define SYS_shmsys   253
#   define SYS_semctl   254
#   define SYS_semget   255
#   define SYS_semop   256
#   define SYS_msgctl   258
#   define SYS_msgget   259
#   define SYS_msgsnd   260
#   define SYS_msgrcv   261
#   define SYS_shmat   262
#   define SYS_shmctl   263
#   define SYS_shmdt   264
#   define SYS_shmget   265
#   define SYS_shm_open   266
#   define SYS_shm_unlink   267
#   define SYS_sem_open   268
#   define SYS_sem_close   269
#   define SYS_sem_unlink   270
#   define SYS_sem_wait   271
#   define SYS_sem_trywait   272
#   define SYS_sem_post   273
#   define SYS_sem_getvalue   274
#   define SYS_sem_init   275
#   define SYS_sem_destroy   276
#   define SYS_open_extended   277
#   define SYS_umask_extended   278
#   define SYS_stat_extended   279
#   define SYS_lstat_extended   280
#   define SYS_fstat_extended   281
#   define SYS_chmod_extended   282
#   define SYS_fchmod_extended   283
#   define SYS_access_extended   284
#   define SYS_settid   285
#   define SYS_gettid   286
#   define SYS_setsgroups   287
#   define SYS_getsgroups   288
#   define SYS_setwgroups   289
#   define SYS_getwgroups   290
#   define SYS_mkfifo_extended   291
#   define SYS_mkdir_extended   292
#   define SYS_identitysvc   293
#   define SYS_shared_region_check_np   294
#   define SYS_shared_region_map_np   295
#   define SYS___pthread_mutex_destroy   301
#   define SYS___pthread_mutex_init   302
#   define SYS___pthread_mutex_lock   303
#   define SYS___pthread_mutex_trylock   304
#   define SYS___pthread_mutex_unlock   305
#   define SYS___pthread_cond_init   306
#   define SYS___pthread_cond_destroy   307
#   define SYS___pthread_cond_broadcast   308
#   define SYS___pthread_cond_signal   309
#   define SYS_getsid   310
#   define SYS_settid_with_pid   311
#   define SYS___pthread_cond_timedwait   312
#   define SYS_aio_fsync   313
#   define SYS_aio_return   314
#   define SYS_aio_suspend   315
#   define SYS_aio_cancel   316
#   define SYS_aio_error   317
#   define SYS_aio_read   318
#   define SYS_aio_write   319
#   define SYS_lio_listio   320
#   define SYS___pthread_cond_wait   321
#   define SYS_iopolicysys   322
#   define SYS_mlockall   324
#   define SYS_munlockall   325
#   define SYS_issetugid   327
#   define SYS___pthread_kill   328
#   define SYS___pthread_sigmask   329
#   define SYS___sigwait   330
#   define SYS___disable_threadsignal   331
#   define SYS___pthread_markcancel   332
#   define SYS___pthread_canceled   333
#   define SYS___semwait_signal   334
#   define SYS_proc_info   336
#   define SYS_sendfile   337
#   define SYS_stat64   338
#   define SYS_fstat64   339
#   define SYS_lstat64   340
#   define SYS_stat64_extended   341
#   define SYS_lstat64_extended   342
#   define SYS_fstat64_extended   343
#   define SYS_getdirentries64   344
#   define SYS_statfs64   345
#   define SYS_fstatfs64   346
#   define SYS_getfsstat64   347
#   define SYS___pthread_chdir   348
#   define SYS___pthread_fchdir   349
#   define SYS_audit   350
#   define SYS_auditon   351
#   define SYS_getauid   353
#   define SYS_setauid   354
#   define SYS_getaudit   355
#   define SYS_setaudit   356
#   define SYS_getaudit_addr   357
#   define SYS_setaudit_addr   358
#   define SYS_auditctl   359
#   define SYS_bsdthread_create   360
#   define SYS_bsdthread_terminate   361
#   define SYS_kqueue   362
#   define SYS_kevent   363
#   define SYS_lchown   364
#   define SYS_stack_snapshot   365
#   define SYS_bsdthread_register   366
#   define SYS_workq_open   367
#   define SYS_workq_ops   368
#   define SYS___mac_execve   380
#   define SYS___mac_syscall   381
#   define SYS___mac_get_file   382
#   define SYS___mac_set_file   383
#   define SYS___mac_get_link   384
#   define SYS___mac_set_link   385
#   define SYS___mac_get_proc   386
#   define SYS___mac_set_proc   387
#   define SYS___mac_get_fd   388
#   define SYS___mac_set_fd   389
#   define SYS___mac_get_pid   390
#   define SYS___mac_get_lcid   391
#   define SYS___mac_get_lctx   392
#   define SYS___mac_set_lctx   393
#   define SYS_setlcid   394
#   define SYS_getlcid   395
#   define SYS_read_nocancel   396
#   define SYS_write_nocancel   397
#   define SYS_open_nocancel   398
#   define SYS_close_nocancel   399
#   define SYS_wait4_nocancel   400
#   define SYS_recvmsg_nocancel   401
#   define SYS_sendmsg_nocancel   402
#   define SYS_recvfrom_nocancel   403
#   define SYS_accept_nocancel   404
#   define SYS_msync_nocancel   405
#   define SYS_fcntl_nocancel   406
#   define SYS_select_nocancel   407
#   define SYS_fsync_nocancel   408
#   define SYS_connect_nocancel   409
#   define SYS_sigsuspend_nocancel   410
#   define SYS_readv_nocancel   411
#   define SYS_writev_nocancel   412
#   define SYS_sendto_nocancel   413
#   define SYS_pread_nocancel   414
#   define SYS_pwrite_nocancel   415
#   define SYS_waitid_nocancel   416
#   define SYS_poll_nocancel   417
#   define SYS_msgsnd_nocancel   418
#   define SYS_msgrcv_nocancel   419
#   define SYS_sem_wait_nocancel   420
#   define SYS_aio_suspend_nocancel   421
#   define SYS___sigwait_nocancel   422
#   define SYS___semwait_signal_nocancel   423
#   define SYS___mac_mount   424
#   define SYS___mac_get_mount   425
#   define SYS___mac_getfsstat   426
#endif


// LINUX SYSTEM CALLS

#if (defined(OSLINUX) && defined(ARCHMIPS))
#   define SYS_syscall   4000
#   define SYS_exit   4001
#   define SYS_fork   4002
#   define SYS_read   4003
#   define SYS_write   4004
#   define SYS_open   4005
#   define SYS_close   4006
#   define SYS_waitpid   4007
#   define SYS_creat   4008
#   define SYS_link   4009
#   define SYS_unlink   4010
#   define SYS_execve   4011
#   define SYS_chdir   4012
#   define SYS_time   4013
#   define SYS_mknod   4014
#   define SYS_chmod   4015
#   define SYS_lchown   4016
#   define SYS_break   4017
#   define SYS_unused18   4018
#   define SYS_lseek   4019
#   define SYS_getpid   4020
#   define SYS_mount   4021
#   define SYS_umount   4022
#   define SYS_setuid   4023
#   define SYS_getuid   4024
#   define SYS_stime   4025
#   define SYS_ptrace   4026
#   define SYS_alarm   4027
#   define SYS_unused28   4028
#   define SYS_pause   4029
#   define SYS_utime   4030
#   define SYS_stty   4031
#   define SYS_gtty   4032
#   define SYS_access   4033
#   define SYS_nice   4034
#   define SYS_ftime   4035
#   define SYS_sync   4036
#   define SYS_kill   4037
#   define SYS_rename   4038
#   define SYS_mkdir   4039
#   define SYS_rmdir   4040
#   define SYS_dup   4041
#   define SYS_pipe   4042
#   define SYS_times   4043
#   define SYS_prof   4044
#   define SYS_brk   4045
#   define SYS_setgid   4046
#   define SYS_getgid   4047
#   define SYS_signal   4048
#   define SYS_geteuid   4049
#   define SYS_getegid   4050
#   define SYS_acct   4051
#   define SYS_umount2   4052
#   define SYS_lock   4053
#   define SYS_ioctl   4054
#   define SYS_fcntl   4055
#   define SYS_mpx   4056
#   define SYS_setpgid   4057
#   define SYS_ulimit   4058
#   define SYS_unused59   4059
#   define SYS_umask   4060
#   define SYS_chroot   4061
#   define SYS_ustat   4062
#   define SYS_dup2   4063
#   define SYS_getppid   4064
#   define SYS_getpgrp   4065
#   define SYS_setsid   4066
#   define SYS_sigaction   4067
#   define SYS_sgetmask   4068
#   define SYS_ssetmask   4069
#   define SYS_setreuid   4070
#   define SYS_setregid   4071
#   define SYS_sigsuspend   4072
#   define SYS_sigpending   4073
#   define SYS_sethostname   4074
#   define SYS_setrlimit   4075
#   define SYS_getrlimit   4076
#   define SYS_getrusage   4077
#   define SYS_gettimeofday   4078
#   define SYS_settimeofday   4079
#   define SYS_getgroups   4080
#   define SYS_setgroups   4081
#   define SYS_reserved82   4082
#   define SYS_symlink   4083
#   define SYS_unused84   4084
#   define SYS_readlink   4085
#   define SYS_uselib   4086
#   define SYS_swapon   4087
#   define SYS_reboot   4088
#   define SYS_readdir   4089
#   define SYS_mmap   4090
#   define SYS_munmap   4091
#   define SYS_truncate   4092
#   define SYS_ftruncate   4093
#   define SYS_fchmod   4094
#   define SYS_fchown   4095
#   define SYS_getpriority   4096
#   define SYS_setpriority   4097
#   define SYS_profil   4098
#   define SYS_statfs   4099
#   define SYS_fstatfs   4100
#   define SYS_ioperm   4101
#   define SYS_socketcall   4102
#   define SYS_syslog   4103
#   define SYS_setitimer   4104
#   define SYS_getitimer   4105
#   define SYS_stat   4106
#   define SYS_lstat   4107
#   define SYS_fstat   4108
#   define SYS_unused109   4109
#   define SYS_iopl   4110
#   define SYS_vhangup   4111
#   define SYS_idle   4112
#   define SYS_vm86   4113
#   define SYS_wait4   4114
#   define SYS_swapoff   4115
#   define SYS_sysinfo   4116
#   define SYS_ipc   4117
#   define SYS_fsync   4118
#   define SYS_sigreturn   4119
#   define SYS_clone   4120
#   define SYS_setdomainname   4121
#   define SYS_uname   4122
#   define SYS_modify_ldt   4123
#   define SYS_adjtimex   4124
#   define SYS_mprotect   4125
#   define SYS_sigprocmask   4126
#   define SYS_create_module   4127
#   define SYS_init_module   4128
#   define SYS_delete_module   4129
#   define SYS_get_kernel_syms   4130
#   define SYS_quotactl   4131
#   define SYS_getpgid   4132
#   define SYS_fchdir   4133
#   define SYS_bdflush   4134
#   define SYS_sysfs   4135
#   define SYS_personality   4136
#   define SYS_afs_syscall   4137
#   define SYS_setfsuid   4138
#   define SYS_setfsgid   4139
#   define SYS__llseek   4140
#   define SYS_getdents   4141
#   define SYS_select   4142
#   define SYS_flock   4143
#   define SYS_msync   4144
#   define SYS_readv   4145
#   define SYS_writev   4146
#   define SYS_cacheflush   4147
#   define SYS_cachectl   4148
#   define SYS_sysmips   4149
#   define SYS_unused150   4150
#   define SYS_getsid   4151
#   define SYS_fdatasync   4152
#   define SYS__sysctl   4153
#   define SYS_mlock   4154
#   define SYS_munlock   4155
#   define SYS_mlockall   4156
#   define SYS_munlockall   4157
#   define SYS_sched_setparam   4158
#   define SYS_sched_getparam   4159
#   define SYS_sched_setscheduler   4160
#   define SYS_sched_getscheduler   4161
#   define SYS_sched_yield   4162
#   define SYS_sched_get_priority_max  4163
#   define SYS_sched_get_priority_min  4164
#   define SYS_sched_rr_get_interval   4165
#   define SYS_nanosleep   4166
#   define SYS_mremap   4167
#   define SYS_accept   4168
#   define SYS_bind   4169
#   define SYS_connect   4170
#   define SYS_getpeername   4171
#   define SYS_getsockname   4172
#   define SYS_getsockopt   4173
#   define SYS_listen   4174
#   define SYS_recv   4175
#   define SYS_recvfrom   4176
#   define SYS_recvmsg   4177
#   define SYS_send   4178
#   define SYS_sendmsg   4179
#   define SYS_sendto   4180
#   define SYS_setsockopt   4181
#   define SYS_shutdown   4182
#   define SYS_socket   4183
#   define SYS_socketpair   4184
#   define SYS_setresuid   4185
#   define SYS_getresuid   4186
#   define SYS_query_module   4187
#   define SYS_poll   4188
#   define SYS_nfsservctl   4189
#   define SYS_setresgid   4190
#   define SYS_getresgid   4191
#   define SYS_prctl   4192
#   define SYS_rt_sigreturn   4193
#   define SYS_rt_sigaction   4194
#   define SYS_rt_sigprocmask   4195
#   define SYS_rt_sigpending   4196
#   define SYS_rt_sigtimedwait   4197
#   define SYS_rt_sigqueueinfo   4198
#   define SYS_rt_sigsuspend   4199
#   define SYS_pread   4200
#   define SYS_pwrite   4201
#   define SYS_chown   4202
#   define SYS_getcwd   4203
#   define SYS_capget   4204
#   define SYS_capset   4205
#   define SYS_sigaltstack   4206
#   define SYS_sendfile   4207
#   define SYS_getpmsg   4208
#   define SYS_putpmsg   4209
#   define SYS_mmap2   4210
#   define SYS_truncate64   4211
#   define SYS_ftruncate64   4212
#   define SYS_stat64   4213
#   define SYS_lstat64   4214
#   define SYS_fstat64   4215
#   define SYS_pivot_root   4216
#   define SYS_mincore   4217
#   define SYS_madvise   4218
#   define SYS_getdents64   4219
#   define SYS_fcntl64   4220
#   define SYS_reserved221   4221
#   define SYS_gettid   4222
#   define SYS_readahead   4223
#   define SYS_setxattr   4224
#   define SYS_lsetxattr   4225
#   define SYS_fsetxattr   4226
#   define SYS_getxattr   4227
#   define SYS_lgetxattr   4228
#   define SYS_fgetxattr   4229
#   define SYS_listxattr   4230
#   define SYS_llistxattr   4231
#   define SYS_flistxattr   4232
#   define SYS_removexattr   4233
#   define SYS_lremovexattr   4234
#   define SYS_fremovexattr   4235
#   define SYS_tkill   4236
#   define SYS_sendfile64   4237
#   define SYS_futex   4238
#   define SYS_sched_setaffinity   4239
#   define SYS_sched_getaffinity   4240
#   define SYS_io_setup   4241
#   define SYS_io_destroy   4242
#   define SYS_io_getevents   4243
#   define SYS_io_submit   4244
#   define SYS_io_cancel   4245
#   define SYS_exit_group   4246
#   define SYS_lookup_dcookie   4247
#   define SYS_epoll_create   4248
#   define SYS_epoll_ctl   4249
#   define SYS_epoll_wait   4250
#   define SYS_remap_file_pages   4251
#   define SYS_set_tid_address   4252
#   define SYS_restart_syscall   4253
#   define SYS_fadvise   4254
#   define SYS_statfs64   4255
#   define SYS_fstatfs64   4256
#   define SYS_timer_create   4257
#   define SYS_timer_settime   4258
#   define SYS_timer_gettime   4259
#   define SYS_timer_getoverrun   4260
#   define SYS_timer_delete   4261
#   define SYS_clock_settime   4262
#   define SYS_clock_gettime   4263
#   define SYS_clock_getres   4264
#   define SYS_clock_nanosleep   4265
#   define SYS_tgkill   4266
#   define SYS_utimes   4267
#   define SYS_mbind   4268
#   define SYS_get_mempolicy   4269
#   define SYS_set_mempolicy   4270
#   define SYS_mq_open   4271
#   define SYS_mq_unlink   4272
#   define SYS_mq_timedsend   4273
#   define SYS_mq_timedreceive   4274
#   define SYS_mq_notify   4275
#   define SYS_mq_getsetattr   4276
#   define SYS_vserver   4277
#   define SYS_waitid   4278
#   define SYS_add_key   4280
#   define SYS_request_key   4281
#   define SYS_keyctl   4282
#   define SYS_set_thread_area   4283
#   define SYS_inotify_init   4284
#   define SYS_inotify_add_watch   4285
#   define SYS_inotify_rm_watch   4286
#   define SYS_migrate_pages   4287
#   define SYS_openat   4288
#   define SYS_mkdirat   4289
#   define SYS_mknodat   4290
#   define SYS_fchownat   4291
#   define SYS_futimesat   4292
#   define SYS_fstatat   4293
#   define SYS_unlinkat   4294
#   define SYS_renameat   4295
#   define SYS_linkat   4296
#   define SYS_symlinkat   4297
#   define SYS_readlinkat   4298
#   define SYS_fchmodat   4299
#   define SYS_faccessat   4300
#   define SYS_pselect6   4301
#   define SYS_ppoll   4302
#   define SYS_unshare   4303
#   define SYS_splice   4304
#   define SYS_sync_file_range   4305
#   define SYS_tee   4306
#   define SYS_vmsplice   4307
#   define SYS_move_pages   4308
#   define SYS_set_robust_list   4309
#   define SYS_get_robust_list   4310
#   define SYS_kexec_load   4311
#   define SYS_getcpu   4312
#   define SYS_epoll_pwait   4313
#   define SYS_ioprio_set   4314
#   define SYS_ioprio_get   4315
#   define SYS_utimensat   4316
#   define SYS_signalfd   4317
#   define SYS_timerfd   4318
#   define SYS_eventfd   4319
#   define SYS_fallocate   4320
#   define SYS_timerfd_create   4321
#   define SYS_timerfd_gettime   4322
#   define SYS_timerfd_settime   4323
#   define SYS_signalfd4   4324
#   define SYS_eventfd2   4325
#   define SYS_epoll_create1   4326
#   define SYS_dup3   4327
#   define SYS_pipe2   4328
#   define SYS_inotify_init1   4329
#   define SYS_preadv   4330
#   define SYS_pwritev   4331
#   define SYS_rt_tgsigqueueinfo   4332
#   define SYS_perf_event_open   4333
#   define SYS_accept4   4334
#   define SYS_recvmmsg   4335
#   define SYS_fanotify_init   4336
#   define SYS_fanotify_mark   4337
#   define SYS_prlimit64   4338
#   define SYS_name_to_handle_at   4339
#   define SYS_open_by_handle_at   4340
#   define SYS_clock_adjtime   4341
#   define SYS_syncfs   4342
#   define SYS_sendmmsg   4343
#   define SYS_setns   4344
#   define SYS_process_vm_readv   4345
#   define SYS_process_vm_writev   4346
#   define SYS_kcmp   4347
#   define SYS_finit_module   4348
#   define SYS_sched_setattr   4349
#   define SYS_sched_getattr   4350
#   define SYS_renameat2   4351
#   define SYS_seccomp   4352
#   define SYS_getrandom   4353
#   define SYS_memfd_create   4354
#   define SYS_bpf   4355
#   define SYS_execveat   4356
#   define SYS_userfaultfd   4357
#   define SYS_membarrier   4358
#   define SYS_mlock2   4359
#endif

#if (defined(OSLINUX) && defined(ARCHX86_64))
#   define SYS_read   0
#   define SYS_write   1
#   define SYS_open   2
#   define SYS_close   3
#   define SYS_stat   4
#   define SYS_fstat   5
#   define SYS_lstat   6
#   define SYS_poll   7
#   define SYS_lseek   8
#   define SYS_mmap   9
#   define SYS_mprotect   10
#   define SYS_munmap   11
#   define SYS_brk   12
#   define SYS_rt_sigaction   13
#   define SYS_rt_sigprocmask   14
#   define SYS_rt_sigreturn   15
#   define SYS_ioctl   16
#   define SYS_pread64   17
#   define SYS_pwrite64   18
#   define SYS_readv   19
#   define SYS_writev   20
#   define SYS_access   21
#   define SYS_pipe   22
#   define SYS_select   23
#   define SYS_sched_yield   24
#   define SYS_mremap   25
#   define SYS_msync   26
#   define SYS_mincore   27
#   define SYS_madvise   28
#   define SYS_shmget   29
#   define SYS_shmat   30
#   define SYS_shmctl   31
#   define SYS_dup   32
#   define SYS_dup2   33
#   define SYS_pause   34
#   define SYS_nanosleep   35
#   define SYS_getitimer   36
#   define SYS_alarm   37
#   define SYS_setitimer   38
#   define SYS_getpid   39
#   define SYS_sendfile   40
#   define SYS_socket   41
#   define SYS_connect   42
#   define SYS_accept   43
#   define SYS_sendto   44
#   define SYS_recvfrom   45
#   define SYS_sendmsg   46
#   define SYS_recvmsg   47
#   define SYS_shutdown   48
#   define SYS_bind   49
#   define SYS_listen   50
#   define SYS_getsockname   51
#   define SYS_getpeername   52
#   define SYS_socketpair   53
#   define SYS_setsockopt   54
#   define SYS_getsockopt   55
#   define SYS_clone   56
#   define SYS_fork   57
#   define SYS_vfork   58
#   define SYS_execve   59
#   define SYS_exit   60
#   define SYS_wait4   61
#   define SYS_kill   62
#   define SYS_uname   63
#   define SYS_semget   64
#   define SYS_semop   65
#   define SYS_semctl   66
#   define SYS_shmdt   67
#   define SYS_msgget   68
#   define SYS_msgsnd   69
#   define SYS_msgrcv   70
#   define SYS_msgctl   71
#   define SYS_fcntl   72
#   define SYS_fcntl64   72
#   define SYS_flock   73
#   define SYS_fsync   74
#   define SYS_fdatasync   75
#   define SYS_truncate   76
#   define SYS_ftruncate   77
#   define SYS_getdents   78
#   define SYS_getcwd   79
#   define SYS_chdir   80
#   define SYS_fchdir   81
#   define SYS_rename   82
#   define SYS_mkdir   83
#   define SYS_rmdir   84
#   define SYS_creat   85
#   define SYS_link   86
#   define SYS_unlink   87
#   define SYS_symlink   88
#   define SYS_readlink   89
#   define SYS_chmod   90
#   define SYS_fchmod   91
#   define SYS_chown   92
#   define SYS_fchown   93
#   define SYS_lchown   94
#   define SYS_umask   95
#   define SYS_gettimeofday   96
#   define SYS_getrlimit   97
#   define SYS_getrusage   98
#   define SYS_sysinfo   99
#   define SYS_times   100
#   define SYS_ptrace   101
#   define SYS_getuid   102
#   define SYS_syslog   103
#   define SYS_getgid   104
#   define SYS_setuid   105
#   define SYS_setgid   106
#   define SYS_geteuid   107
#   define SYS_getegid   108
#   define SYS_setpgid   109
#   define SYS_getppid   110
#   define SYS_getpgrp   111
#   define SYS_setsid   112
#   define SYS_setreuid   113
#   define SYS_setregid   114
#   define SYS_getgroups   115
#   define SYS_setgroups   116
#   define SYS_setresuid   117
#   define SYS_getresuid   118
#   define SYS_setresgid   119
#   define SYS_getresgid   120
#   define SYS_getpgid   121
#   define SYS_setfsuid   122
#   define SYS_setfsgid   123
#   define SYS_getsid   124
#   define SYS_capget   125
#   define SYS_capset   126
#   define SYS_rt_sigpending   127
#   define SYS_rt_sigtimedwait   128
#   define SYS_rt_sigqueueinfo   129
#   define SYS_rt_sigsuspend   130
#   define SYS_sigaltstack   131
#   define SYS_utime   132
#   define SYS_mknod   133
#   define SYS_uselib   134
#   define SYS_personality   135
#   define SYS_ustat   136
#   define SYS_statfs   137
#   define SYS_fstatfs   138
#   define SYS_sysfs   139
#   define SYS_getpriority   140
#   define SYS_setpriority   141
#   define SYS_sched_setparam   142
#   define SYS_sched_getparam   143
#   define SYS_sched_setscheduler   144
#   define SYS_sched_getscheduler   145
#   define SYS_sched_get_priority_max   146
#   define SYS_sched_get_priority_min   147
#   define SYS_sched_rr_get_interval   148
#   define SYS_mlock   149
#   define SYS_munlock   150
#   define SYS_mlockall   151
#   define SYS_munlockall   152
#   define SYS_vhangup   153
#   define SYS_modify_ldt   154
#   define SYS_pivot_root   155
#   define SYS__sysctl   156
#   define SYS_prctl   157
#   define SYS_arch_prctl   158
#   define SYS_adjtimex   159
#   define SYS_setrlimit   160
#   define SYS_chroot   161
#   define SYS_sync   162
#   define SYS_acct   163
#   define SYS_settimeofday   164
#   define SYS_mount   165
#   define SYS_umount2   166
#   define SYS_swapon   167
#   define SYS_swapoff   168
#   define SYS_reboot   169
#   define SYS_sethostname   170
#   define SYS_setdomainname   171
#   define SYS_iopl   172
#   define SYS_ioperm   173
#   define SYS_create_module   174
#   define SYS_init_module   175
#   define SYS_delete_module   176
#   define SYS_get_kernel_syms   177
#   define SYS_query_module   178
#   define SYS_quotactl   179
#   define SYS_nfsservctl   180
#   define SYS_getpmsg   181
#   define SYS_putpmsg   182
#   define SYS_afs_syscall   183
#   define SYS_tuxcall   184
#   define SYS_security   185
#   define SYS_gettid   186
#   define SYS_readahead   187
#   define SYS_setxattr   188
#   define SYS_lsetxattr   189
#   define SYS_fsetxattr   190
#   define SYS_getxattr   191
#   define SYS_lgetxattr   192
#   define SYS_fgetxattr   193
#   define SYS_listxattr   194
#   define SYS_llistxattr   195
#   define SYS_flistxattr   196
#   define SYS_removexattr   197
#   define SYS_lremovexattr   198
#   define SYS_fremovexattr   199
#   define SYS_tkill   200
#   define SYS_time   201
#   define SYS_futex   202
#   define SYS_sched_setaffinity   203
#   define SYS_sched_getaffinity   204
#   define SYS_set_thread_area   205
#   define SYS_io_setup   206
#   define SYS_io_destroy   207
#   define SYS_io_getevents   208
#   define SYS_io_submit   209
#   define SYS_io_cancel   210
#   define SYS_get_thread_area   211
#   define SYS_lookup_dcookie   212
#   define SYS_epoll_create   213
#   define SYS_epoll_ctl_old   214
#   define SYS_epoll_wait_old   215
#   define SYS_remap_file_pages   216
#   define SYS_getdents64   217
#   define SYS_set_tid_address   218
#   define SYS_restart_syscall   219
#   define SYS_semtimedop   220
#   define SYS_fadvise64   221
#   define SYS_timer_create   222
#   define SYS_timer_settime   223
#   define SYS_timer_gettime   224
#   define SYS_timer_getoverrun   225
#   define SYS_timer_delete   226
#   define SYS_clock_settime   227
#   define SYS_clock_gettime   228
#   define SYS_clock_getres   229
#   define SYS_clock_nanosleep   230
#   define SYS_exit_group   231
#   define SYS_epoll_wait   232
#   define SYS_epoll_ctl   233
#   define SYS_tgkill   234
#   define SYS_utimes   235
#   define SYS_vserver   236
#   define SYS_mbind   237
#   define SYS_set_mempolicy   238
#   define SYS_get_mempolicy   239
#   define SYS_mq_open   240
#   define SYS_mq_unlink   241
#   define SYS_mq_timedsend   242
#   define SYS_mq_timedreceive   243
#   define SYS_mq_notify   244
#   define SYS_mq_getsetattr   245
#   define SYS_kexec_load   246
#   define SYS_waitid   247
#   define SYS_add_key   248
#   define SYS_request_key   249
#   define SYS_keyctl   250
#   define SYS_ioprio_set   251
#   define SYS_ioprio_get   252
#   define SYS_inotify_init   253
#   define SYS_inotify_add_watch   254
#   define SYS_inotify_rm_watch   255
#   define SYS_migrate_pages   256
#   define SYS_openat   257
#   define SYS_mkdirat   258
#   define SYS_mknodat   259
#   define SYS_fchownat   260
#   define SYS_futimesat   261
#   define SYS_newfstatat   262
#   define SYS_unlinkat   263
#   define SYS_renameat   264
#   define SYS_linkat   265
#   define SYS_symlinkat   266
#   define SYS_readlinkat   267
#   define SYS_fchmodat   268
#   define SYS_faccessat   269
#   define SYS_pselect6   270
#   define SYS_ppoll   271
#   define SYS_unshare   272
#   define SYS_set_robust_list   273
#   define SYS_get_robust_list   274
#   define SYS_splice   275
#   define SYS_tee   276
#   define SYS_sync_file_range   277
#   define SYS_vmsplice   278
#   define SYS_move_pages   279
#   define SYS_utimensat   280
#   define SYS_epoll_pwait   281
#   define SYS_signalfd   282
#   define SYS_timerfd_create   283
#   define SYS_eventfd   284
#   define SYS_fallocate   285
#   define SYS_timerfd_settime   286
#   define SYS_timerfd_gettime   287
#   define SYS_accept4   288
#   define SYS_signalfd4   289
#   define SYS_eventfd2   290
#   define SYS_epoll_create1   291
#   define SYS_dup3   292
#   define SYS_pipe2   293
#   define SYS_inotify_init1   294
#   define SYS_preadv   295
#   define SYS_pwritev   296
#   define SYS_rt_tgsigqueueinfo   297
#   define SYS_perf_event_open   298
#   define SYS_recvmmsg   299
#   define SYS_fanotify_init   300
#   define SYS_fanotify_mark   301
#   define SYS_prlimit64   302
#   define SYS_name_to_handle_at   303
#   define SYS_open_by_handle_at   304
#   define SYS_clock_adjtime   305
#   define SYS_syncfs   306
#   define SYS_sendmmsg   307
#   define SYS_setns   308
#   define SYS_getcpu   309
#   define SYS_process_vm_readv   310
#   define SYS_process_vm_writev   311
#   define SYS_kcmp   312
#   define SYS_finit_module   313
#   define SYS_sched_setattr   314
#   define SYS_sched_getattr   315
#   define SYS_renameat2   316
#   define SYS_seccomp   317
#   define SYS_getrandom   318
#   define SYS_memfd_create   319
#   define SYS_kexec_file_load   320
#   define SYS_bpf   321
#   define SYS_execveat   322
#   define SYS_userfaultfd   323
#   define SYS_membarrier   324
#   define SYS_mlock2   325
#endif

#if (defined(OSLINUX) && defined(ARCHARM))
#   define SYS_breakpoint   0xf0001
#   define SYS_cacheflush   0xf0002
#   define SYS_usr26   0xf0003
#   define SYS_usr32   0xf0004
#   define SYS_set_tls   0xf0005
#   define SYS_restart_syscall   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_creat   8
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_execve   11
#   define SYS_chdir   12
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_lchown   16
#   define SYS_lseek   19
#   define SYS_getpid   20
#   define SYS_mount   21
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_ptrace   26
#   define SYS_pause   29
#   define SYS_access   33
#   define SYS_nice   34
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_rename   38
#   define SYS_mkdir   39
#   define SYS_rmdir   40
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_times   43
#   define SYS_brk   45
#   define SYS_setgid   46
#   define SYS_getgid   47
#   define SYS_geteuid   49
#   define SYS_getegid   50
#   define SYS_acct   51
#   define SYS_umount2   52
#   define SYS_ioctl   54
#   define SYS_fcntl   55
#   define SYS_setpgid   57
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_ustat   62
#   define SYS_dup2   63
#   define SYS_getppid   64
#   define SYS_getpgrp   65
#   define SYS_setsid   66
#   define SYS_sigaction   67
#   define SYS_setreuid   70
#   define SYS_setregid   71
#   define SYS_sigsuspend   72
#   define SYS_sigpending   73
#   define SYS_sethostname   74
#   define SYS_setrlimit   75
#   define SYS_getrusage   77
#   define SYS_gettimeofday   78
#   define SYS_settimeofday   79
#   define SYS_getgroups   80
#   define SYS_setgroups   81
#   define SYS_symlink   83
#   define SYS_readlink   85
#   define SYS_uselib   86
#   define SYS_swapon   87
#   define SYS_reboot   88
#   define SYS_munmap   91
#   define SYS_truncate   92
#   define SYS_ftruncate   93
#   define SYS_fchmod   94
#   define SYS_fchown   95
#   define SYS_getpriority   96
#   define SYS_setpriority   97
#   define SYS_statfs   99
#   define SYS_fstatfs   100
#   define SYS_syslog   103
#   define SYS_setitimer   104
#   define SYS_getitimer   105
#   define SYS_stat   106
#   define SYS_lstat   107
#   define SYS_fstat   108
#   define SYS_vhangup   111
#   define SYS_wait4   114
#   define SYS_swapoff   115
#   define SYS_sysinfo   116
#   define SYS_fsync   118
#   define SYS_sigreturn   119
#   define SYS_clone   120
#   define SYS_setdomainname   121
#   define SYS_uname   122
#   define SYS_adjtimex   124
#   define SYS_mprotect   125
#   define SYS_sigprocmask   126
#   define SYS_init_module   128
#   define SYS_delete_module   129
#   define SYS_quotactl   131
#   define SYS_getpgid   132
#   define SYS_fchdir   133
#   define SYS_bdflush   134
#   define SYS_sysfs   135
#   define SYS_personality   136
#   define SYS_setfsuid   138
#   define SYS_setfsgid   139
#   define SYS__llseek   140
#   define SYS_getdents   141
#   define SYS__newselect   142
#   define SYS_flock   143
#   define SYS_msync   144
#   define SYS_readv   145
#   define SYS_writev   146
#   define SYS_getsid   147
#   define SYS_fdatasync   148
#   define SYS__sysctl   149
#   define SYS_mlock   150
#   define SYS_munlock   151
#   define SYS_mlockall   152
#   define SYS_munlockall   153
#   define SYS_sched_setparam   154
#   define SYS_sched_getparam   155
#   define SYS_sched_setscheduler   156
#   define SYS_sched_getscheduler   157
#   define SYS_sched_yield   158
#   define SYS_sched_get_priority_max   159
#   define SYS_sched_get_priority_min   160
#   define SYS_sched_rr_get_interval   161
#   define SYS_nanosleep   162
#   define SYS_mremap   163
#   define SYS_setresuid   164
#   define SYS_getresuid   165
#   define SYS_poll   168
#   define SYS_nfsservctl   169
#   define SYS_setresgid   170
#   define SYS_getresgid   171
#   define SYS_prctl   172
#   define SYS_rt_sigreturn   173
#   define SYS_rt_sigaction   174
#   define SYS_rt_sigprocmask   175
#   define SYS_rt_sigpending   176
#   define SYS_rt_sigtimedwait   177
#   define SYS_rt_sigqueueinfo   178
#   define SYS_rt_sigsuspend   179
#   define SYS_pread64   180
#   define SYS_pwrite64   181
#   define SYS_chown   182
#   define SYS_getcwd   183
#   define SYS_capget   184
#   define SYS_capset   185
#   define SYS_sigaltstack   186
#   define SYS_sendfile   187
#   define SYS_vfork   190
#   define SYS_ugetrlimit   191
#   define SYS_mmap2   192
#   define SYS_truncate64   193
#   define SYS_ftruncate64   194
#   define SYS_stat64   195
#   define SYS_lstat64   196
#   define SYS_fstat64   197
#   define SYS_lchown32   198
#   define SYS_getuid32   199
#   define SYS_getgid32   200
#   define SYS_geteuid32   201
#   define SYS_getegid32   202
#   define SYS_setreuid32   203
#   define SYS_setregid32   204
#   define SYS_getgroups32   205
#   define SYS_setgroups32   206
#   define SYS_fchown32   207
#   define SYS_setresuid32   208
#   define SYS_getresuid32   209
#   define SYS_setresgid32   210
#   define SYS_getresgid32   211
#   define SYS_chown32   212
#   define SYS_setuid32   213
#   define SYS_setgid32   214
#   define SYS_setfsuid32   215
#   define SYS_setfsgid32   216
#   define SYS_getdents64   217
#   define SYS_pivot_root   218
#   define SYS_mincore   219
#   define SYS_madvise   220
#   define SYS_fcntl64   221
#   define SYS_gettid   224
#   define SYS_readahead   225
#   define SYS_setxattr   226
#   define SYS_lsetxattr   227
#   define SYS_fsetxattr   228
#   define SYS_getxattr   229
#   define SYS_lgetxattr   230
#   define SYS_fgetxattr   231
#   define SYS_listxattr   232
#   define SYS_llistxattr   233
#   define SYS_flistxattr   234
#   define SYS_removexattr   235
#   define SYS_lremovexattr   236
#   define SYS_fremovexattr   237
#   define SYS_tkill   238
#   define SYS_sendfile64   239
#   define SYS_futex   240
#   define SYS_sched_setaffinity   241
#   define SYS_sched_getaffinity   242
#   define SYS_io_setup   243
#   define SYS_io_destroy   244
#   define SYS_io_getevents   245
#   define SYS_io_submit   246
#   define SYS_io_cancel   247
#   define SYS_exit_group   248
#   define SYS_lookup_dcookie   249
#   define SYS_epoll_create   250
#   define SYS_epoll_ctl   251
#   define SYS_epoll_wait   252
#   define SYS_remap_file_pages   253
#   define SYS_set_tid_address   256
#   define SYS_timer_create   257
#   define SYS_timer_settime   258
#   define SYS_timer_gettime   259
#   define SYS_timer_getoverrun   260
#   define SYS_timer_delete   261
#   define SYS_clock_settime   262
#   define SYS_clock_gettime   263
#   define SYS_clock_getres   264
#   define SYS_clock_nanosleep   265
#   define SYS_statfs64   266
#   define SYS_fstatfs64   267
#   define SYS_tgkill   268
#   define SYS_utimes   269
#   define SYS_fadvise64_64   270
#   define SYS_pciconfig_iobase   271
#   define SYS_pciconfig_read   272
#   define SYS_pciconfig_write   273
#   define SYS_mq_open   274
#   define SYS_mq_unlink   275
#   define SYS_mq_timedsend   276
#   define SYS_mq_timedreceive   277
#   define SYS_mq_notify   278
#   define SYS_mq_getsetattr   279
#   define SYS_waitid   280
#   define SYS_socket   281
#   define SYS_bind   282
#   define SYS_connect   283
#   define SYS_listen   284
#   define SYS_accept   285
#   define SYS_getsockname   286
#   define SYS_getpeername   287
#   define SYS_socketpair   288
#   define SYS_send   289
#   define SYS_sendto   290
#   define SYS_recv   291
#   define SYS_recvfrom   292
#   define SYS_shutdown   293
#   define SYS_setsockopt   294
#   define SYS_getsockopt   295
#   define SYS_sendmsg   296
#   define SYS_recvmsg   297
#   define SYS_semop   298
#   define SYS_semget   299
#   define SYS_semctl   300
#   define SYS_msgsnd   301
#   define SYS_msgrcv   302
#   define SYS_msgget   303
#   define SYS_msgctl   304
#   define SYS_shmat   305
#   define SYS_shmdt   306
#   define SYS_shmget   307
#   define SYS_shmctl   308
#   define SYS_add_key   309
#   define SYS_request_key   310
#   define SYS_keyctl   311
#   define SYS_semtimedop   312
#   define SYS_vserver   313
#   define SYS_ioprio_set   314
#   define SYS_ioprio_get   315
#   define SYS_inotify_init   316
#   define SYS_inotify_add_watch   317
#   define SYS_inotify_rm_watch   318
#   define SYS_mbind   319
#   define SYS_get_mempolicy   320
#   define SYS_set_mempolicy   321
#   define SYS_openat   322
#   define SYS_mkdirat   323
#   define SYS_mknodat   324
#   define SYS_fchownat   325
#   define SYS_futimesat   326
#   define SYS_fstatat64   327
#   define SYS_unlinkat   328
#   define SYS_renameat   329
#   define SYS_linkat   330
#   define SYS_symlinkat   331
#   define SYS_readlinkat   332
#   define SYS_fchmodat   333
#   define SYS_faccessat   334
#   define SYS_pselect6   335
#   define SYS_ppoll   336
#   define SYS_unshare   337
#   define SYS_set_robust_list   338
#   define SYS_get_robust_list   339
#   define SYS_splice   340
#   define SYS_sync_file_range2   341
#   define SYS_tee   342
#   define SYS_vmsplice   343
#   define SYS_move_pages   344
#   define SYS_getcpu   345
#   define SYS_epoll_pwait   346
#   define SYS_kexec_load   347
#   define SYS_utimensat   348
#   define SYS_signalfd   349
#   define SYS_timerfd_create   350
#   define SYS_eventfd   351
#   define SYS_fallocate   352
#   define SYS_timerfd_settime   353
#   define SYS_timerfd_gettime   354
#   define SYS_signalfd4   355
#   define SYS_eventfd2   356
#   define SYS_epoll_create1   357
#   define SYS_dup3   358
#   define SYS_pipe2   359
#   define SYS_inotify_init1   360
#   define SYS_preadv   361
#   define SYS_pwritev   362
#   define SYS_rt_tgsigqueueinfo   363
#   define SYS_perf_event_open   364
#   define SYS_recvmmsg   365
#   define SYS_accept4   366
#   define SYS_fanotify_init   367
#   define SYS_fanotify_mark   368
#   define SYS_prlimit64   369
#   define SYS_name_to_handle_at   370
#   define SYS_open_by_handle_at   371
#   define SYS_clock_adjtime   372
#   define SYS_syncfs   373
#   define SYS_sendmmsg   374
#   define SYS_setns   375
#   define SYS_process_vm_readv   376
#   define SYS_process_vm_writev   377
#   define SYS_kcmp   378
#   define SYS_finit_module   379
#   define SYS_sched_setattr   380
#   define SYS_sched_getattr   381
#   define SYS_renameat2   382
#   define SYS_seccomp   383
#   define SYS_getrandom   384
#   define SYS_memfd_create   385
#   define SYS_bpf   386
#   define SYS_execveat   387
#   define SYS_userfaultfd   388
#   define SYS_membarrier   389
#   define SYS_mlock2   390
#endif


// BSD SYSTEM CALLS

#if (defined(OSDRAGONFLYBSD) && defined(ARCHX86_64))
#   define SYS_nosys   0
#   define SYS_umtx_sleep   469
#   define SYS_umtx_wakeup   470
#   define SYS_jail_attach   471
#   define SYS_set_tls_area   472
#   define SYS_get_tls_area   473
#   define SYS_closefrom   474
#   define SYS_stat   475
#   define SYS_fstat   476
#   define SYS_lstat   477
#   define SYS_fhstat   478
#   define SYS_getdirentries   479
#   define SYS_getdents   480
#   define SYS_usched_set   481
#   define SYS_extaccept   482
#   define SYS_extconnect   483
#   define SYS_mcontrol   485
#   define SYS_vmspace_create   486
#   define SYS_vmspace_destroy   487
#   define SYS_vmspace_ctl   488
#   define SYS_vmspace_mmap   489
#   define SYS_vmspace_munmap   490
#   define SYS_vmspace_mcontrol   491
#   define SYS_vmspace_pread   492
#   define SYS_vmspace_pwrite   493
#   define SYS_extexit   494
#   define SYS_lwp_create   495
#   define SYS_lwp_gettid   496
#   define SYS_lwp_kill   497
#   define SYS_lwp_rtprio   498
#   define SYS_pselect   499
#   define SYS_statvfs   500
#   define SYS_fstatvfs   501
#   define SYS_fhstatvfs   502
#   define SYS_getvfsstat   503
#   define SYS_openat   504
#   define SYS_fstatat   505
#   define SYS_fchmodat   506
#   define SYS_fchownat   507
#   define SYS_unlinkat   508
#   define SYS_faccessat   509
#   define SYS_mq_open   510
#   define SYS_mq_close   511
#   define SYS_mq_unlink   512
#   define SYS_mq_getattr   513
#   define SYS_mq_setattr   514
#   define SYS_mq_notify   515
#   define SYS_mq_send   516
#   define SYS_mq_receive   517
#   define SYS_mq_timedsend   518
#   define SYS_mq_timedreceive   519
#   define SYS_ioprio_set   520
#   define SYS_ioprio_get   521
#   define SYS_chroot_kernel   522
#   define SYS_renameat   523
#   define SYS_mkdirat   524
#   define SYS_mkfifoat   525
#   define SYS_mknodat   526
#   define SYS_readlinkat   527
#   define SYS_symlinkat   528
#   define SYS_swapoff   529
#   define SYS_vquotactl   530
#   define SYS_linkat   531
#   define SYS_eaccess   532
#   define SYS_lpathconf   533
#   define SYS_vmm_guest_ctl   534
#   define SYS_vmm_guest_sync_addr   535
#endif

#if (defined(OSFREEBSD) && defined(ARCHX86))
#   define SYS_nosys   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_wait4   7
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_obreak   17
#   define SYS_getpid   20
#   define SYS_mount   21
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_getgid   47
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigaltstack   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_msync   65
#   define SYS_vfork   66
#   define SYS_sbrk   69
#   define SYS_sstk   70
#   define SYS_ovadvise   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_setitimer   83
#   define SYS_swapon   85
#   define SYS_getitimer   86
#   define SYS_getdtablesize   89
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_select   93
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_gettimeofday   116
#   define SYS_getrusage   117
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_settimeofday   122
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_utimes   138
#   define SYS_adjtime   140
#   define SYS_setsid   147
#   define SYS_quotactl   148
#   define SYS_lgetfh   160
#   define SYS_getfh   161
#   define SYS_sysarch   165
#   define SYS_rtprio   166
#   define SYS_freebsd6_pread   173
#   define SYS_freebsd6_pwrite   174
#   define SYS_setfib   175
#   define SYS_ntp_adjtime   176
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_stat   188
#   define SYS_fstat   189
#   define SYS_lstat   190
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_getdirentries   196
#   define SYS_freebsd6_mmap   197
#   define SYS_freebsd6_lseek   199
#   define SYS_freebsd6_truncate   200
#   define SYS_freebsd6_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_futimes   206
#   define SYS_getpgid   207
#   define SYS_poll   209
#   define SYS_clock_gettime   232
#   define SYS_clock_settime   233
#   define SYS_clock_getres   234
#   define SYS_ktimer_create   235
#   define SYS_ktimer_delete   236
#   define SYS_ktimer_settime   237
#   define SYS_ktimer_gettime   238
#   define SYS_ktimer_getoverrun   239
#   define SYS_nanosleep   240
#   define SYS_ffclock_getcounter   241
#   define SYS_ffclock_setestimate   242
#   define SYS_ffclock_getestimate   243
#   define SYS_clock_getcpuclockid2   247
#   define SYS_ntp_gettime   248
#   define SYS_minherit   250
#   define SYS_rfork   251
#   define SYS_openbsd_poll   252
#   define SYS_issetugid   253
#   define SYS_lchown   254
#   define SYS_getdents   272
#   define SYS_lchmod   274
#   define SYS_lutimes   276
#   define SYS_nstat   278
#   define SYS_nfstat   279
#   define SYS_nlstat   280
#   define SYS_preadv   289
#   define SYS_pwritev   290
#   define SYS_fhopen   298
#   define SYS_fhstat   299
#   define SYS_modnext   300
#   define SYS_modstat   301
#   define SYS_modfnext   302
#   define SYS_modfind   303
#   define SYS_kldload   304
#   define SYS_kldunload   305
#   define SYS_kldfind   306
#   define SYS_kldnext   307
#   define SYS_kldstat   308
#   define SYS_kldfirstmod   309
#   define SYS_getsid   310
#   define SYS_setresuid   311
#   define SYS_setresgid   312
#   define SYS_yield   321
#   define SYS_mlockall   324
#   define SYS_munlockall   325
#   define SYS___getcwd   326
#   define SYS_sched_setparam   327
#   define SYS_sched_getparam   328
#   define SYS_sched_setscheduler   329
#   define SYS_sched_getscheduler   330
#   define SYS_sched_yield   331
#   define SYS_sched_get_priority_max   332
#   define SYS_sched_get_priority_min   333
#   define SYS_sched_rr_get_interval   334
#   define SYS_utrace   335
#   define SYS_kldsym   337
#   define SYS_jail   338
#   define SYS_sigprocmask   340
#   define SYS_sigsuspend   341
#   define SYS_sigpending   343
#   define SYS_sigtimedwait   345
#   define SYS_sigwaitinfo   346
#   define SYS___acl_get_file   347
#   define SYS___acl_set_file   348
#   define SYS___acl_get_fd   349
#   define SYS___acl_set_fd   350
#   define SYS___acl_delete_file   351
#   define SYS___acl_delete_fd   352
#   define SYS___acl_aclcheck_file   353
#   define SYS___acl_aclcheck_fd   354
#   define SYS_extattrctl   355
#   define SYS_extattr_set_file   356
#   define SYS_extattr_get_file   357
#   define SYS_extattr_delete_file   358
#   define SYS_getresuid   360
#   define SYS_getresgid   361
#   define SYS_kqueue   362
#   define SYS_kevent   363
#   define SYS_extattr_set_fd   371
#   define SYS_extattr_get_fd   372
#   define SYS_extattr_delete_fd   373
#   define SYS___setugid   374
#   define SYS_eaccess   376
#   define SYS_nmount   378
#   define SYS___mac_get_proc   384
#   define SYS___mac_set_proc   385
#   define SYS___mac_get_fd   386
#   define SYS___mac_get_file   387
#   define SYS___mac_set_fd   388
#   define SYS___mac_set_file   389
#   define SYS_kenv   390
#   define SYS_lchflags   391
#   define SYS_uuidgen   392
#   define SYS_sendfile   393
#   define SYS_mac_syscall   394
#   define SYS_getfsstat   395
#   define SYS_statfs   396
#   define SYS_fstatfs   397
#   define SYS_fhstatfs   398
#   define SYS___mac_get_pid   409
#   define SYS___mac_get_link   410
#   define SYS___mac_set_link   411
#   define SYS_extattr_set_link   412
#   define SYS_extattr_get_link   413
#   define SYS_extattr_delete_link   414
#   define SYS___mac_execve   415
#   define SYS_sigaction   416
#   define SYS_sigreturn   417
#   define SYS_getcontext   421
#   define SYS_setcontext   422
#   define SYS_swapcontext   423
#   define SYS_swapoff   424
#   define SYS___acl_get_link   425
#   define SYS___acl_set_link   426
#   define SYS___acl_delete_link   427
#   define SYS___acl_aclcheck_link   428
#   define SYS_sigwait   429
#   define SYS_thr_create   430
#   define SYS_thr_exit   431
#   define SYS_thr_self   432
#   define SYS_thr_kill   433
#   define SYS__umtx_lock   434
#   define SYS__umtx_unlock   435
#   define SYS_jail_attach   436
#   define SYS_extattr_list_fd   437
#   define SYS_extattr_list_file   438
#   define SYS_extattr_list_link   439
#   define SYS_thr_suspend   442
#   define SYS_thr_wake   443
#   define SYS_kldunloadf   444
#   define SYS_audit   445
#   define SYS_auditon   446
#   define SYS_getauid   447
#   define SYS_setauid   448
#   define SYS_getaudit   449
#   define SYS_setaudit   450
#   define SYS_getaudit_addr   451
#   define SYS_setaudit_addr   452
#   define SYS_auditctl   453
#   define SYS__umtx_op   454
#   define SYS_thr_new   455
#   define SYS_sigqueue   456
#   define SYS_abort2   463
#   define SYS_thr_set_name   464
#   define SYS_rtprio_thread   466
#   define SYS_sctp_peeloff   471
#   define SYS_sctp_generic_sendmsg   472
#   define SYS_sctp_generic_sendmsg_iov   473
#   define SYS_sctp_generic_recvmsg   474
#   define SYS_pread   475
#   define SYS_pwrite   476
#   define SYS_mmap   477
#   define SYS_lseek   478
#   define SYS_truncate   479
#   define SYS_ftruncate   480
#   define SYS_thr_kill2   481
#   define SYS_shm_open   482
#   define SYS_shm_unlink   483
#   define SYS_cpuset   484
#   define SYS_cpuset_setid   485
#   define SYS_cpuset_getid   486
#   define SYS_cpuset_getaffinity   487
#   define SYS_cpuset_setaffinity   488
#   define SYS_faccessat   489
#   define SYS_fchmodat   490
#   define SYS_fchownat   491
#   define SYS_fexecve   492
#   define SYS_fstatat   493
#   define SYS_futimesat   494
#   define SYS_linkat   495
#   define SYS_mkdirat   496
#   define SYS_mkfifoat   497
#   define SYS_mknodat   498
#   define SYS_openat   499
#   define SYS_readlinkat   500
#   define SYS_renameat   501
#   define SYS_symlinkat   502
#   define SYS_unlinkat   503
#   define SYS_posix_openpt   504
#   define SYS_jail_get   506
#   define SYS_jail_set   507
#   define SYS_jail_remove   508
#   define SYS_closefrom   509
#   define SYS_lpathconf   513
#   define SYS_cap_new   514
#   define SYS_cap_getrights   515
#   define SYS_cap_enter   516
#   define SYS_cap_getmode   517
#   define SYS_pdfork   518
#   define SYS_pdkill   519
#   define SYS_pdgetpid   520
#   define SYS_pselect   522
#   define SYS_getloginclass   523
#   define SYS_setloginclass   524
#   define SYS_rctl_get_racct   525
#   define SYS_rctl_get_rules   526
#   define SYS_rctl_get_limits   527
#   define SYS_rctl_add_rule   528
#   define SYS_rctl_remove_rule   529
#   define SYS_posix_fallocate   530
#   define SYS_posix_fadvise   531
#   define SYS_wait6   532
#   define SYS_bindat   538
#   define SYS_connectat   539
#   define SYS_chflagsat   540
#   define SYS_accept4   541
#   define SYS_pipe2   542
#   define SYS_procctl   544
#endif

#if (defined(OSFREEBSD) && defined(ARCHARM))
#   define SYS_nosys   0
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_wait4   7
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_obreak   17
#   define SYS_getpid   20
#   define SYS_mount   21
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_getgid   47
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigaltstack   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_msync   65
#   define SYS_vfork   66
#   define SYS_sbrk   69
#   define SYS_sstk   70
#   define SYS_ovadvise   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_setitimer   83
#   define SYS_swapon   85
#   define SYS_getitimer   86
#   define SYS_getdtablesize   89
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_select   93
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_gettimeofday   116
#   define SYS_getrusage   117
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_settimeofday   122
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_utimes   138
#   define SYS_adjtime   140
#   define SYS_setsid   147
#   define SYS_quotactl   148
#   define SYS_lgetfh   160
#   define SYS_getfh   161
#   define SYS_sysarch   165
#   define SYS_rtprio   166
#   define SYS_freebsd6_pread   173
#   define SYS_freebsd6_pwrite   174
#   define SYS_setfib   175
#   define SYS_ntp_adjtime   176
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_stat   188
#   define SYS_fstat   189
#   define SYS_lstat   190
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_getdirentries   196
#   define SYS_freebsd6_mmap   197
#   define SYS_freebsd6_lseek   199
#   define SYS_freebsd6_truncate   200
#   define SYS_freebsd6_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_futimes   206
#   define SYS_getpgid   207
#   define SYS_poll   209
#   define SYS_clock_gettime   232
#   define SYS_clock_settime   233
#   define SYS_clock_getres   234
#   define SYS_ktimer_create   235
#   define SYS_ktimer_delete   236
#   define SYS_ktimer_settime   237
#   define SYS_ktimer_gettime   238
#   define SYS_ktimer_getoverrun   239
#   define SYS_nanosleep   240
#   define SYS_ffclock_getcounter   241
#   define SYS_ffclock_setestimate   242
#   define SYS_ffclock_getestimate   243
#   define SYS_clock_getcpuclockid2   247
#   define SYS_ntp_gettime   248
#   define SYS_minherit   250
#   define SYS_rfork   251
#   define SYS_openbsd_poll   252
#   define SYS_issetugid   253
#   define SYS_lchown   254
#   define SYS_getdents   272
#   define SYS_lchmod   274
#   define SYS_lutimes   276
#   define SYS_nstat   278
#   define SYS_nfstat   279
#   define SYS_nlstat   280
#   define SYS_preadv   289
#   define SYS_pwritev   290
#   define SYS_fhopen   298
#   define SYS_fhstat   299
#   define SYS_modnext   300
#   define SYS_modstat   301
#   define SYS_modfnext   302
#   define SYS_modfind   303
#   define SYS_kldload   304
#   define SYS_kldunload   305
#   define SYS_kldfind   306
#   define SYS_kldnext   307
#   define SYS_kldstat   308
#   define SYS_kldfirstmod   309
#   define SYS_getsid   310
#   define SYS_setresuid   311
#   define SYS_setresgid   312
#   define SYS_yield   321
#   define SYS_mlockall   324
#   define SYS_munlockall   325
#   define SYS___getcwd   326
#   define SYS_sched_setparam   327
#   define SYS_sched_getparam   328
#   define SYS_sched_setscheduler   329
#   define SYS_sched_getscheduler   330
#   define SYS_sched_yield   331
#   define SYS_sched_get_priority_max   332
#   define SYS_sched_get_priority_min   333
#   define SYS_sched_rr_get_interval   334
#   define SYS_utrace   335
#   define SYS_kldsym   337
#   define SYS_jail   338
#   define SYS_sigprocmask   340
#   define SYS_sigsuspend   341
#   define SYS_sigpending   343
#   define SYS_sigtimedwait   345
#   define SYS_sigwaitinfo   346
#   define SYS___acl_get_file   347
#   define SYS___acl_set_file   348
#   define SYS___acl_get_fd   349
#   define SYS___acl_set_fd   350
#   define SYS___acl_delete_file   351
#   define SYS___acl_delete_fd   352
#   define SYS___acl_aclcheck_file   353
#   define SYS___acl_aclcheck_fd   354
#   define SYS_extattrctl   355
#   define SYS_extattr_set_file   356
#   define SYS_extattr_get_file   357
#   define SYS_extattr_delete_file   358
#   define SYS_getresuid   360
#   define SYS_getresgid   361
#   define SYS_kqueue   362
#   define SYS_kevent   363
#   define SYS_extattr_set_fd   371
#   define SYS_extattr_get_fd   372
#   define SYS_extattr_delete_fd   373
#   define SYS___setugid   374
#   define SYS_eaccess   376
#   define SYS_nmount   378
#   define SYS___mac_get_proc   384
#   define SYS___mac_set_proc   385
#   define SYS___mac_get_fd   386
#   define SYS___mac_get_file   387
#   define SYS___mac_set_fd   388
#   define SYS___mac_set_file   389
#   define SYS_kenv   390
#   define SYS_lchflags   391
#   define SYS_uuidgen   392
#   define SYS_sendfile   393
#   define SYS_mac_syscall   394
#   define SYS_getfsstat   395
#   define SYS_statfs   396
#   define SYS_fstatfs   397
#   define SYS_fhstatfs   398
#   define SYS___mac_get_pid   409
#   define SYS___mac_get_link   410
#   define SYS___mac_set_link   411
#   define SYS_extattr_set_link   412
#   define SYS_extattr_get_link   413
#   define SYS_extattr_delete_link   414
#   define SYS___mac_execve   415
#   define SYS_sigaction   416
#   define SYS_sigreturn   417
#   define SYS_getcontext   421
#   define SYS_setcontext   422
#   define SYS_swapcontext   423
#   define SYS_swapoff   424
#   define SYS___acl_get_link   425
#   define SYS___acl_set_link   426
#   define SYS___acl_delete_link   427
#   define SYS___acl_aclcheck_link   428
#   define SYS_sigwait   429
#   define SYS_thr_create   430
#   define SYS_thr_exit   431
#   define SYS_thr_self   432
#   define SYS_thr_kill   433
#   define SYS__umtx_lock   434
#   define SYS__umtx_unlock   435
#   define SYS_jail_attach   436
#   define SYS_extattr_list_fd   437
#   define SYS_extattr_list_file   438
#   define SYS_extattr_list_link   439
#   define SYS_thr_suspend   442
#   define SYS_thr_wake   443
#   define SYS_kldunloadf   444
#   define SYS_audit   445
#   define SYS_auditon   446
#   define SYS_getauid   447
#   define SYS_setauid   448
#   define SYS_getaudit   449
#   define SYS_setaudit   450
#   define SYS_getaudit_addr   451
#   define SYS_setaudit_addr   452
#   define SYS_auditctl   453
#   define SYS__umtx_op   454
#   define SYS_thr_new   455
#   define SYS_sigqueue   456
#   define SYS_abort2   463
#   define SYS_thr_set_name   464
#   define SYS_rtprio_thread   466
#   define SYS_sctp_peeloff   471
#   define SYS_sctp_generic_sendmsg   472
#   define SYS_sctp_generic_sendmsg_iov   473
#   define SYS_sctp_generic_recvmsg   474
#   define SYS_pread   475
#   define SYS_pwrite   476
#   define SYS_mmap   477
#   define SYS_lseek   478
#   define SYS_truncate   479
#   define SYS_ftruncate   480
#   define SYS_thr_kill2   481
#   define SYS_shm_open   482
#   define SYS_shm_unlink   483
#   define SYS_cpuset   484
#   define SYS_cpuset_setid   485
#   define SYS_cpuset_getid   486
#   define SYS_cpuset_getaffinity   487
#   define SYS_cpuset_setaffinity   488
#   define SYS_faccessat   489
#   define SYS_fchmodat   490
#   define SYS_fchownat   491
#   define SYS_fexecve   492
#   define SYS_fstatat   493
#   define SYS_futimesat   494
#   define SYS_linkat   495
#   define SYS_mkdirat   496
#   define SYS_mkfifoat   497
#   define SYS_mknodat   498
#   define SYS_openat   499
#   define SYS_readlinkat   500
#   define SYS_renameat   501
#   define SYS_symlinkat   502
#   define SYS_unlinkat   503
#   define SYS_posix_openpt   504
#   define SYS_jail_get   506
#   define SYS_jail_set   507
#   define SYS_jail_remove   508
#   define SYS_closefrom   509
#   define SYS_lpathconf   513
#   define SYS_cap_new   514
#   define SYS_cap_getrights   515
#   define SYS_cap_enter   516
#   define SYS_cap_getmode   517
#   define SYS_pdfork   518
#   define SYS_pdkill   519
#   define SYS_pdgetpid   520
#   define SYS_pselect   522
#   define SYS_getloginclass   523
#   define SYS_setloginclass   524
#   define SYS_rctl_get_racct   525
#   define SYS_rctl_get_rules   526
#   define SYS_rctl_get_limits   527
#   define SYS_rctl_add_rule   528
#   define SYS_rctl_remove_rule   529
#   define SYS_posix_fallocate   530
#   define SYS_posix_fadvise   531
#   define SYS_wait6   532
#   define SYS_bindat   538
#   define SYS_connectat   539
#   define SYS_chflagsat   540
#   define SYS_accept4   541
#   define SYS_pipe2   542
#   define SYS_procctl   544
#endif

#if (defined(OSNETBSD) && defined(ARCHX86))
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_break   17
#   define SYS_getpid   20
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_getgid   47
#   define SYS___getlogin   49
#   define SYS___setlogin   50
#   define SYS_acct   51
#   define SYS_ioctl   54
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_vfork   66
#   define SYS_sbrk   69
#   define SYS_sstk   70
#   define SYS_vadvise   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_setsid   147
#   define SYS_sysarch   165
#   define SYS_pread   173
#   define SYS_pwrite   174
#   define SYS_ntp_adjtime   176
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_getpgid   207
#   define SYS_reboot   208
#   define SYS_poll   209
#   define SYS_semget   221
#   define SYS_semop   222
#   define SYS_semconfig   223
#   define SYS_msgget   225
#   define SYS_msgsnd   226
#   define SYS_msgrcv   227
#   define SYS_shmat   228
#   define SYS_shmdt   230
#   define SYS_shmget   231
#   define SYS_timer_create   235
#   define SYS_timer_delete   236
#   define SYS_timer_getoverrun   239
#   define SYS_fdatasync   241
#   define SYS_mlockall   242
#   define SYS_munlockall   243
#   define SYS_sigqueueinfo   245
#   define SYS_modctl   246
#   define SYS___posix_rename   270
#   define SYS_swapctl   271
#   define SYS_minherit   273
#   define SYS_lchmod   274
#   define SYS_lchown   275
#   define SYS___posix_chown   283
#   define SYS___posix_fchown   284
#   define SYS___posix_lchown   285
#   define SYS_getsid   286
#   define SYS___clone   287
#   define SYS_fktrace   288
#   define SYS_preadv   289
#   define SYS_pwritev   290
#   define SYS___getcwd   296
#   define SYS_fchroot   297
#   define SYS_lchflags   304
#   define SYS_issetugid   305
#   define SYS_utrace   306
#   define SYS_getcontext   307
#   define SYS_setcontext   308
#   define SYS__lwp_create   309
#   define SYS__lwp_exit   310
#   define SYS__lwp_self   311
#   define SYS__lwp_wait   312
#   define SYS__lwp_suspend   313
#   define SYS__lwp_continue   314
#   define SYS__lwp_wakeup   315
#   define SYS__lwp_getprivate   316
#   define SYS__lwp_setprivate   317
#   define SYS__lwp_kill   318
#   define SYS__lwp_detach   319
#   define SYS__lwp_unpark   321
#   define SYS__lwp_unpark_all   322
#   define SYS__lwp_setname   323
#   define SYS__lwp_getname   324
#   define SYS__lwp_ctl   325
#   define SYS___sigaction_sigtramp   340
#   define SYS_pmc_get_info   341
#   define SYS_pmc_control   342
#   define SYS_rasctl   343
#   define SYS_kqueue   344
#   define SYS__sched_setparam   346
#   define SYS__sched_getparam   347
#   define SYS__sched_setaffinity   348
#   define SYS__sched_getaffinity   349
#   define SYS_sched_yield   350
#   define SYS_fsync_range   354
#   define SYS_uuidgen   355
#   define SYS_getvfsstat   356
#   define SYS_statvfs1   357
#   define SYS_fstatvfs1   358
#   define SYS_extattrctl   360
#   define SYS_extattr_set_file   361
#   define SYS_extattr_get_file   362
#   define SYS_extattr_delete_file   363
#   define SYS_extattr_set_fd   364
#   define SYS_extattr_get_fd   365
#   define SYS_extattr_delete_fd   366
#   define SYS_extattr_set_link   367
#   define SYS_extattr_get_link   368
#   define SYS_extattr_delete_link   369
#   define SYS_extattr_list_fd   370
#   define SYS_extattr_list_file   371
#   define SYS_extattr_list_link   372
#   define SYS_setxattr   375
#   define SYS_lsetxattr   376
#   define SYS_fsetxattr   377
#   define SYS_getxattr   378
#   define SYS_lgetxattr   379
#   define SYS_fgetxattr   380
#   define SYS_listxattr   381
#   define SYS_llistxattr   382
#   define SYS_flistxattr   383
#   define SYS_removexattr   384
#   define SYS_lremovexattr   385
#   define SYS_fremovexattr   386
#   define SYS_getdents   390
#   define SYS_socket   394
#   define SYS_getfh   395
#   define SYS_mount   410
#   define SYS_mremap   411
#   define SYS_pset_create   412
#   define SYS_pset_destroy   413
#   define SYS_pset_assign   414
#   define SYS__pset_bind   415
#   define SYS_posix_fadvise   416
#   define SYS_select   417
#   define SYS_gettimeofday   418
#   define SYS_settimeofday   419
#   define SYS_utimes   420
#   define SYS_adjtime   421
#   define SYS_futimes   423
#   define SYS_lutimes   424
#   define SYS_setitimer   425
#   define SYS_getitimer   426
#   define SYS_clock_gettime   427
#   define SYS_clock_settime   428
#   define SYS_clock_getres   429
#   define SYS_nanosleep   430
#   define SYS___sigtimedwait   431
#   define SYS__lwp_park   434
#   define SYS_kevent   435
#   define SYS_pselect   436
#   define SYS_pollts   437
#   define SYS_stat   439
#   define SYS_fstat   440
#   define SYS_lstat   441
#   define SYS___semctl   442
#   define SYS_shmctl   443
#   define SYS_msgctl   444
#   define SYS_getrusage   445
#   define SYS_timer_settime   446
#   define SYS_timer_gettime   447
#   define SYS_ntp_gettime   448
#   define SYS_wait4   449
#   define SYS_mknod   450
#   define SYS_fhstat   451
#   define SYS_pipe2   453
#   define SYS_dup3   454
#   define SYS_kqueue1   455
#   define SYS_paccept   456
#   define SYS_linkat   457
#   define SYS_renameat   458
#   define SYS_mkfifoat   459
#   define SYS_mknodat   460
#   define SYS_mkdirat   461
#   define SYS_faccessat   462
#   define SYS_fchmodat   463
#   define SYS_fchownat   464
#   define SYS_fexecve   465
#   define SYS_fstatat   466
#   define SYS_utimensat   467
#   define SYS_openat   468
#   define SYS_readlinkat   469
#   define SYS_symlinkat   470
#   define SYS_unlinkat   471
#   define SYS_futimens   472
#   define SYS___quotactl   473
#   define SYS_posix_spawn   474
#   define SYS_recvmmsg   475
#   define SYS_sendmmsg   476
#endif

#if (defined(OSNETBSD) && defined(ARCHARM))
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_break   17
#   define SYS_getpid   20
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_getppid   39
#   define SYS_dup   41
#   define SYS_pipe   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_getgid   47
#   define SYS___getlogin   49
#   define SYS___setlogin   50
#   define SYS_acct   51
#   define SYS_ioctl   54
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_vfork   66
#   define SYS_sbrk   69
#   define SYS_sstk   70
#   define SYS_vadvise   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_dup2   90
#   define SYS_fcntl   92
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_connect   98
#   define SYS_getpriority   100
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_setsid   147
#   define SYS_sysarch   165
#   define SYS_pread   173
#   define SYS_pwrite   174
#   define SYS_ntp_adjtime   176
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_undelete   205
#   define SYS_getpgid   207
#   define SYS_reboot   208
#   define SYS_poll   209
#   define SYS_semget   221
#   define SYS_semop   222
#   define SYS_semconfig   223
#   define SYS_msgget   225
#   define SYS_msgsnd   226
#   define SYS_msgrcv   227
#   define SYS_shmat   228
#   define SYS_shmdt   230
#   define SYS_shmget   231
#   define SYS_timer_create   235
#   define SYS_timer_delete   236
#   define SYS_timer_getoverrun   239
#   define SYS_fdatasync   241
#   define SYS_mlockall   242
#   define SYS_munlockall   243
#   define SYS_sigqueueinfo   245
#   define SYS_modctl   246
#   define SYS___posix_rename   270
#   define SYS_swapctl   271
#   define SYS_minherit   273
#   define SYS_lchmod   274
#   define SYS_lchown   275
#   define SYS___posix_chown   283
#   define SYS___posix_fchown   284
#   define SYS___posix_lchown   285
#   define SYS_getsid   286
#   define SYS___clone   287
#   define SYS_fktrace   288
#   define SYS_preadv   289
#   define SYS_pwritev   290
#   define SYS___getcwd   296
#   define SYS_fchroot   297
#   define SYS_lchflags   304
#   define SYS_issetugid   305
#   define SYS_utrace   306
#   define SYS_getcontext   307
#   define SYS_setcontext   308
#   define SYS__lwp_create   309
#   define SYS__lwp_exit   310
#   define SYS__lwp_self   311
#   define SYS__lwp_wait   312
#   define SYS__lwp_suspend   313
#   define SYS__lwp_continue   314
#   define SYS__lwp_wakeup   315
#   define SYS__lwp_getprivate   316
#   define SYS__lwp_setprivate   317
#   define SYS__lwp_kill   318
#   define SYS__lwp_detach   319
#   define SYS__lwp_unpark   321
#   define SYS__lwp_unpark_all   322
#   define SYS__lwp_setname   323
#   define SYS__lwp_getname   324
#   define SYS__lwp_ctl   325
#   define SYS___sigaction_sigtramp   340
#   define SYS_pmc_get_info   341
#   define SYS_pmc_control   342
#   define SYS_rasctl   343
#   define SYS_kqueue   344
#   define SYS__sched_setparam   346
#   define SYS__sched_getparam   347
#   define SYS__sched_setaffinity   348
#   define SYS__sched_getaffinity   349
#   define SYS_sched_yield   350
#   define SYS_fsync_range   354
#   define SYS_uuidgen   355
#   define SYS_getvfsstat   356
#   define SYS_statvfs1   357
#   define SYS_fstatvfs1   358
#   define SYS_extattrctl   360
#   define SYS_extattr_set_file   361
#   define SYS_extattr_get_file   362
#   define SYS_extattr_delete_file   363
#   define SYS_extattr_set_fd   364
#   define SYS_extattr_get_fd   365
#   define SYS_extattr_delete_fd   366
#   define SYS_extattr_set_link   367
#   define SYS_extattr_get_link   368
#   define SYS_extattr_delete_link   369
#   define SYS_extattr_list_fd   370
#   define SYS_extattr_list_file   371
#   define SYS_extattr_list_link   372
#   define SYS_setxattr   375
#   define SYS_lsetxattr   376
#   define SYS_fsetxattr   377
#   define SYS_getxattr   378
#   define SYS_lgetxattr   379
#   define SYS_fgetxattr   380
#   define SYS_listxattr   381
#   define SYS_llistxattr   382
#   define SYS_flistxattr   383
#   define SYS_removexattr   384
#   define SYS_lremovexattr   385
#   define SYS_fremovexattr   386
#   define SYS_getdents   390
#   define SYS_socket   394
#   define SYS_getfh   395
#   define SYS_mount   410
#   define SYS_mremap   411
#   define SYS_pset_create   412
#   define SYS_pset_destroy   413
#   define SYS_pset_assign   414
#   define SYS__pset_bind   415
#   define SYS_posix_fadvise   416
#   define SYS_select   417
#   define SYS_gettimeofday   418
#   define SYS_settimeofday   419
#   define SYS_utimes   420
#   define SYS_adjtime   421
#   define SYS_futimes   423
#   define SYS_lutimes   424
#   define SYS_setitimer   425
#   define SYS_getitimer   426
#   define SYS_clock_gettime   427
#   define SYS_clock_settime   428
#   define SYS_clock_getres   429
#   define SYS_nanosleep   430
#   define SYS___sigtimedwait   431
#   define SYS__lwp_park   434
#   define SYS_kevent   435
#   define SYS_pselect   436
#   define SYS_pollts   437
#   define SYS_stat   439
#   define SYS_fstat   440
#   define SYS_lstat   441
#   define SYS___semctl   442
#   define SYS_shmctl   443
#   define SYS_msgctl   444
#   define SYS_getrusage   445
#   define SYS_timer_settime   446
#   define SYS_timer_gettime   447
#   define SYS_ntp_gettime   448
#   define SYS_wait4   449
#   define SYS_mknod   450
#   define SYS_fhstat   451
#   define SYS_pipe2   453
#   define SYS_dup3   454
#   define SYS_kqueue1   455
#   define SYS_paccept   456
#   define SYS_linkat   457
#   define SYS_renameat   458
#   define SYS_mkfifoat   459
#   define SYS_mknodat   460
#   define SYS_mkdirat   461
#   define SYS_faccessat   462
#   define SYS_fchmodat   463
#   define SYS_fchownat   464
#   define SYS_fexecve   465
#   define SYS_fstatat   466
#   define SYS_utimensat   467
#   define SYS_openat   468
#   define SYS_readlinkat   469
#   define SYS_symlinkat   470
#   define SYS_unlinkat   471
#   define SYS_futimens   472
#   define SYS___quotactl   473
#   define SYS_posix_spawn   474
#   define SYS_recvmmsg   475
#   define SYS_sendmmsg   476
#endif

#if (defined(OSOPENBSD) && defined(ARCHX86))
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS___tfork   8
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_wait4   11
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_obreak   17
#   define SYS_getdtablecount  18
#   define SYS_getrusage   19
#   define SYS_getpid   20
#   define SYS_mount   21
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_stat   38
#   define SYS_getppid   39
#   define SYS_lstat   40
#   define SYS_dup   41
#   define SYS_fstatat   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_sigaction   46
#   define SYS_getgid   47
#   define SYS_sigprocmask   48
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigpending   52
#   define SYS_fstat   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_getfsstat   62
#   define SYS_statfs   63
#   define SYS_fstatfs   64
#   define SYS_fhstatfs   65
#   define SYS_vfork   66
#   define SYS_gettimeofday   67
#   define SYS_settimeofday   68
#   define SYS_setitimer   69
#   define SYS_getitimer   70
#   define SYS_select   71
#   define SYS_kevent   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_utimes   76
#   define SYS_futimes   77
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_utimensat   84
#   define SYS_futimens   85
#   define SYS_clock_gettime   87
#   define SYS_clock_settime   88
#   define SYS_clock_getres   89
#   define SYS_dup2   90
#   define SYS_nanosleep   91
#   define SYS_fcntl   92
#   define SYS___thrsleep   94
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getdents   99
#   define SYS_getpriority   100
#   define SYS_sigreturn   103
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_ppoll   109
#   define SYS_pselect   110
#   define SYS_sigsuspend   111
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_adjtime   140
#   define SYS_setsid   147
#   define SYS_quotactl   148
#   define SYS_nfssvc   155
#   define SYS_getfh   161
#   define SYS_sysarch   165
#   define SYS_pread   173
#   define SYS_pwrite   174
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_swapctl   193
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_getpgid   207
#   define SYS_utrace   209
#   define SYS_semget   221
#   define SYS_msgget   225
#   define SYS_msgsnd   226
#   define SYS_msgrcv   227
#   define SYS_shmat   228
#   define SYS_shmdt   230
#   define SYS_minherit   250
#   define SYS_poll   252
#   define SYS_issetugid   253
#   define SYS_lchown   254
#   define SYS_getsid   255
#   define SYS_msync   256
#   define SYS_pipe   263
#   define SYS_fhopen   264
#   define SYS_preadv   267
#   define SYS_pwritev   268
#   define SYS_kqueue   269
#   define SYS_mlockall   271
#   define SYS_munlockall   272
#   define SYS_getresuid   281
#   define SYS_setresuid   282
#   define SYS_getresgid   283
#   define SYS_setresgid   284
#   define SYS_mquery   286
#   define SYS_closefrom   287
#   define SYS_sigaltstack   288
#   define SYS_shmget   289
#   define SYS_semop   290
#   define SYS_fhstat   294
#   define SYS___semctl   295
#   define SYS_shmctl   296
#   define SYS_msgctl   297
#   define SYS_sched_yield   298
#   define SYS_getthrid   299
#   define SYS___thrwakeup   301
#   define SYS___threxit   302
#   define SYS___thrsigdivert  303
#   define SYS___getcwd   304
#   define SYS_adjfreq   305
#   define SYS_setrtable   310
#   define SYS_getrtable   311
#   define SYS_faccessat   313
#   define SYS_fchmodat   314
#   define SYS_fchownat   315
#   define SYS_linkat   317
#   define SYS_mkdirat   318
#   define SYS_mkfifoat   319
#   define SYS_mknodat   320
#   define SYS_openat   321
#   define SYS_readlinkat   322
#   define SYS_renameat   323
#   define SYS_symlinkat   324
#   define SYS_unlinkat   325
#   define SYS___set_tcb   329
#   define SYS___get_tcb   330
#endif

#if (defined(OSOPENBSD) && defined(ARCHARM))
#   define SYS_exit   1
#   define SYS_fork   2
#   define SYS_read   3
#   define SYS_write   4
#   define SYS_open   5
#   define SYS_close   6
#   define SYS_getentropy   7
#   define SYS___tfork   8
#   define SYS_link   9
#   define SYS_unlink   10
#   define SYS_wait4   11
#   define SYS_chdir   12
#   define SYS_fchdir   13
#   define SYS_mknod   14
#   define SYS_chmod   15
#   define SYS_chown   16
#   define SYS_obreak   17
#   define SYS_getdtablecount   18
#   define SYS_getrusage   19
#   define SYS_getpid   20
#   define SYS_mount   21
#   define SYS_unmount   22
#   define SYS_setuid   23
#   define SYS_getuid   24
#   define SYS_geteuid   25
#   define SYS_ptrace   26
#   define SYS_recvmsg   27
#   define SYS_sendmsg   28
#   define SYS_recvfrom   29
#   define SYS_accept   30
#   define SYS_getpeername   31
#   define SYS_getsockname   32
#   define SYS_access   33
#   define SYS_chflags   34
#   define SYS_fchflags   35
#   define SYS_sync   36
#   define SYS_kill   37
#   define SYS_stat   38
#   define SYS_getppid   39
#   define SYS_lstat   40
#   define SYS_dup   41
#   define SYS_fstatat   42
#   define SYS_getegid   43
#   define SYS_profil   44
#   define SYS_ktrace   45
#   define SYS_sigaction   46
#   define SYS_getgid   47
#   define SYS_sigprocmask   48
#   define SYS_getlogin   49
#   define SYS_setlogin   50
#   define SYS_acct   51
#   define SYS_sigpending   52
#   define SYS_fstat   53
#   define SYS_ioctl   54
#   define SYS_reboot   55
#   define SYS_revoke   56
#   define SYS_symlink   57
#   define SYS_readlink   58
#   define SYS_execve   59
#   define SYS_umask   60
#   define SYS_chroot   61
#   define SYS_getfsstat   62
#   define SYS_statfs   63
#   define SYS_fstatfs   64
#   define SYS_fhstatfs   65
#   define SYS_vfork   66
#   define SYS_gettimeofday   67
#   define SYS_settimeofday   68
#   define SYS_setitimer   69
#   define SYS_getitimer   70
#   define SYS_select   71
#   define SYS_kevent   72
#   define SYS_munmap   73
#   define SYS_mprotect   74
#   define SYS_madvise   75
#   define SYS_utimes   76
#   define SYS_futimes   77
#   define SYS_mincore   78
#   define SYS_getgroups   79
#   define SYS_setgroups   80
#   define SYS_getpgrp   81
#   define SYS_setpgid   82
#   define SYS_sendsyslog   83
#   define SYS_utimensat   84
#   define SYS_futimens   85
#   define SYS_clock_gettime   87
#   define SYS_clock_settime   88
#   define SYS_clock_getres   89
#   define SYS_dup2   90
#   define SYS_nanosleep   91
#   define SYS_fcntl   92
#   define SYS_accept4   93
#   define SYS___thrsleep   94
#   define SYS_fsync   95
#   define SYS_setpriority   96
#   define SYS_socket   97
#   define SYS_connect   98
#   define SYS_getdents   99
#   define SYS_getpriority   100
#   define SYS_pipe2   101
#   define SYS_dup3   102
#   define SYS_sigreturn   103
#   define SYS_bind   104
#   define SYS_setsockopt   105
#   define SYS_listen   106
#   define SYS_chflagsat   107
#   define SYS_ppoll   109
#   define SYS_pselect   110
#   define SYS_sigsuspend   111
#   define SYS_getsockopt   118
#   define SYS_readv   120
#   define SYS_writev   121
#   define SYS_fchown   123
#   define SYS_fchmod   124
#   define SYS_setreuid   126
#   define SYS_setregid   127
#   define SYS_rename   128
#   define SYS_flock   131
#   define SYS_mkfifo   132
#   define SYS_sendto   133
#   define SYS_shutdown   134
#   define SYS_socketpair   135
#   define SYS_mkdir   136
#   define SYS_rmdir   137
#   define SYS_adjtime   140
#   define SYS_setsid   147
#   define SYS_quotactl   148
#   define SYS_nfssvc   155
#   define SYS_getfh   161
#   define SYS_sysarch   165
#   define SYS_pread   173
#   define SYS_pwrite   174
#   define SYS_setgid   181
#   define SYS_setegid   182
#   define SYS_seteuid   183
#   define SYS_pathconf   191
#   define SYS_fpathconf   192
#   define SYS_swapctl   193
#   define SYS_getrlimit   194
#   define SYS_setrlimit   195
#   define SYS_mmap   197
#   define SYS_lseek   199
#   define SYS_truncate   200
#   define SYS_ftruncate   201
#   define SYS___sysctl   202
#   define SYS_mlock   203
#   define SYS_munlock   204
#   define SYS_getpgid   207
#   define SYS_utrace   209
#   define SYS_semget   221
#   define SYS_msgget   225
#   define SYS_msgsnd   226
#   define SYS_msgrcv   227
#   define SYS_shmat   228
#   define SYS_shmdt   230
#   define SYS_minherit   250
#   define SYS_poll   252
#   define SYS_issetugid   253
#   define SYS_lchown   254
#   define SYS_getsid   255
#   define SYS_msync   256
#   define SYS_pipe   263
#   define SYS_fhopen   264
#   define SYS_preadv   267
#   define SYS_pwritev   268
#   define SYS_kqueue   269
#   define SYS_mlockall   271
#   define SYS_munlockall   272
#   define SYS_getresuid   281
#   define SYS_setresuid   282
#   define SYS_getresgid   283
#   define SYS_setresgid   284
#   define SYS_mquery   286
#   define SYS_closefrom   287
#   define SYS_sigaltstack   288
#   define SYS_shmget   289
#   define SYS_semop   290
#   define SYS_fhstat   294
#   define SYS___semctl   295
#   define SYS_shmctl   296
#   define SYS_msgctl   297
#   define SYS_sched_yield   298
#   define SYS_getthrid   299
#   define SYS___thrwakeup   301
#   define SYS___threxit   302
#   define SYS___thrsigdivert   303
#   define SYS___getcwd   304
#   define SYS_adjfreq   305
#   define SYS_setrtable   310
#   define SYS_getrtable   311
#   define SYS_faccessat   313
#   define SYS_fchmodat   314
#   define SYS_fchownat   315
#   define SYS_linkat   317
#   define SYS_mkdirat   318
#   define SYS_mkfifoat   319
#   define SYS_mknodat   320
#   define SYS_openat   321
#   define SYS_readlinkat   322
#   define SYS_renameat   323
#   define SYS_symlinkat   324
#   define SYS_unlinkat   325
#   define SYS___set_tcb   329
#   define SYS___get_tcb   330
#endif


// MISCELLANEOUS OS SYSTEM CALLS

#ifdef OSHELENOS
#   define SYS_kio   0
#   define SYS_thread_create   1
#   define SYS_thread_exit   2
#   define SYS_thread_get_id   3
#   define SYS_thread_usleep   4
#   define SYS_thread_udelay   5
#   define SYS_task_get_id   6
#   define SYS_task_set_name   7
#   define SYS_task_kill   8
#   define SYS_task_exit   9
#   define SYS_program_spawn_loader   10
#   define SYS_futex_sleep   11
#   define SYS_futex_wakeup   12
#   define SYS_smc_coherence   13
#   define SYS_smp_memory_barrier   14
#   define SYS_as_area_create   15
#   define SYS_as_area_resize   16
#   define SYS_as_area_change_flags   17
#   define SYS_as_area_destroy   18
#   define SYS_page_find_mapping   19
#   define SYS_ipc_call_async_fast   20
#   define SYS_ipc_call_async_slow   21
#   define SYS_ipc_answer_fast   22
#   define SYS_ipc_answer_slow   23
#   define SYS_ipc_forward_fast   24
#   define SYS_ipc_forward_slow   25
#   define SYS_ipc_wait   26
#   define SYS_ipc_poke   27
#   define SYS_ipc_hangup   28
#   define SYS_ipc_connect_kbox   29
#   define SYS_ipc_event_subscribe   30
#   define SYS_ipc_event_unsubscribe   31
#   define SYS_ipc_event_unmask   32
#   define SYS_perm_grant   33
#   define SYS_perm_revoke   34
#   define SYS_physmem_map   35
#   define SYS_physmem_unmap   36
#   define SYS_dmamem_map   37
#   define SYS_dmamem_unmap   38
#   define SYS_iospace_enable   39
#   define SYS_iospace_disable   40
#   define SYS_ipc_irq_subscribe   41
#   define SYS_ipc_irq_unsubscribe   42
#   define SYS_sysinfo_get_keys_size   43
#   define SYS_sysinfo_get_keys   44
#   define SYS_sysinfo_get_val_type   45
#   define SYS_sysinfo_get_value   46
#   define SYS_sysinfo_get_data_size   47
#   define SYS_sysinfo_get_data   48
#   define SYS_debug_console   49
#   define SYS_klog   50
#   define SYS_end   51
#endif

#ifdef OSPLAN9
#   define SYS_sysr1   0
#   define SYS_bind   2
#   define SYS_chdir   3
#   define SYS_close   4
#   define SYS_dup   5
#   define SYS_alarm   6
#   define SYS_exec   7
#   define SYS_exits   8
#   define SYS_fauth   10
#   define SYS_segbrk   12
#   define SYS_open   14
#   define SYS_oseek   16
#   define SYS_sleep   17
#   define SYS_rfork   19
#   define SYS_pipe   21
#   define SYS_create   22
#   define SYS_fd2path   23
#   define SYS_brk_   24
#   define SYS_remove   25
#   define SYS_notify   28
#   define SYS_noted   29
#   define SYS_segattach   30
#   define SYS_segdetach   31
#   define SYS_segfree   32
#   define SYS_segflush   33
#   define SYS_rendezvous   34
#   define SYS_unmount   35
#   define SYS_semacquire   37
#   define SYS_semrelease   38
#   define SYS_seek   39
#   define SYS_fversion   40
#   define SYS_errstr   41
#   define SYS_stat   42
#   define SYS_fstat   43
#   define SYS_wstat   44
#   define SYS_fwstat   45
#   define SYS_mount   46
#   define SYS_await   47
#   define SYS_pread   50
#   define SYS_pwrite   51
#   define SYS_tsemacquire   52
#   define SYS_nsec   53
#endif


// SYSTEM CALL ALIASES

#if ((!defined(SYS_sysctl)) && defined(SYS__sysctl))
#   define SYS_sysctl   SYS__sysctl
#endif
#if ((!defined(SYS_llseek)) && defined(SYS__llseek))
#   define SYS_llseek   SYS__llseek
#endif


// LEGACY SYSCALL MACROS

#ifdef OSLINUX
#   ifdef SYS_getuid32
#      undef SYS_lchown
#      undef SYS_getuid
#      undef SYS_getgid
#      undef SYS_geteuid
#      undef SYS_getegid
#      undef SYS_setreuid
#      undef SYS_setregid
#      undef SYS_getgroups
#      undef SYS_setgroups
#      undef SYS_fchown
#      undef SYS_setresuid
#      undef SYS_getresuid
#      undef SYS_setresgid
#      undef SYS_getresgid
#      undef SYS_chown
#      undef SYS_setuid
#      undef SYS_setgid
#      undef SYS_setfsuid
#      undef SYS_setfsgid
#      define SYS_lchown   SYS_lchown32
#      define SYS_getuid   SYS_getuid32
#      define SYS_getgid   SYS_getgid32
#      define SYS_geteuid   SYS_geteuid32
#      define SYS_getegid   SYS_getegid32
#      define SYS_setreuid   SYS_setreuid32
#      define SYS_setregid   SYS_setregid32
#      define SYS_getgroups   SYS_getgroups32
#      define SYS_setgroups   SYS_setgroups32
#      define SYS_fchown   SYS_fchown32
#      define SYS_setresuid   SYS_setresuid32
#      define SYS_getresuid   SYS_getresuid32
#      define SYS_setresgid   SYS_setresgid32
#      define SYS_getresgid   SYS_getresgid32
#      define SYS_chown   SYS_chown32
#      define SYS_setuid   SYS_setuid32
#      define SYS_setgid   SYS_setgid32
#      define SYS_setfsuid   SYS_setfsuid32
#      define SYS_setfsgid   SYS_setfsgid32
#   endif  // SYS_getuid32
// Legacy 32-bit-vs-lfs64 Macros
#   ifdef SYS_fcntl64
#      undef SYS_fcntl
#      define SYS_fcntl   SYS_fcntl64
#   endif
#   ifdef SYS_getdents64
#      undef SYS_getdents
#      define SYS_getdents   SYS_getdents64
#   endif
#   ifdef SYS_ftruncate64
#      undef SYS_ftruncate
#      undef SYS_truncate
#      define SYS_ftruncate   SYS_ftruncate64
#      define SYS_truncate   SYS_truncate64
#   endif
#   ifdef SYS_stat64
#      undef SYS_stat
#      define SYS_stat   SYS_stat64
#   endif
#   ifdef SYS_fstat64
#      undef SYS_fstat
#      define SYS_fstat   SYS_fstat64
#   endif
#   ifdef SYS_lstat64
#      undef SYS_lstat
#      define SYS_lstat   SYS_lstat64
#   endif
#   ifdef SYS_statfs64
#      undef SYS_statfs
#      define SYS_statfs   SYS_statfs64
#   endif
#   ifdef SYS_fstatfs64
#      undef SYS_fstatfs
#      define SYS_fstatfs   SYS_fstatfs64
#   endif
#   ifdef SYS_newfstatat
#      undef SYS_fstatat
#      define SYS_fstatat   SYS_newfstatat
#   elif defined(SYS_fstatat64)
#      undef SYS_fstatat
#      define SYS_fstatat   SYS_fstatat64
#   endif
#   ifdef SYS_ugetrlimit
#      undef SYS_getrlimit
#      define SYS_getrlimit   SYS_ugetrlimit
#   endif
#   ifdef SYS__newselect
#      undef SYS_select
#      define SYS_select   SYS__newselect
#   endif
#   ifdef SYS_pread64
#      undef SYS_pread
#      undef SYS_pwrite
#      define SYS_pread   SYS_pread64
#      define SYS_pwrite   SYS_pwrite64
#   endif
#   ifdef SYS_fadvise64_64
#      undef SYS_fadvise
#      define SYS_fadvise   SYS_fadvise64_64
#   elif defined(SYS_fadvise64)
#      undef SYS_fadvise
#      define SYS_fadvise   SYS_fadvise64
#   endif
#   ifdef SYS_sendfile64
#      undef SYS_sendfile
#      define SYS_sendfile   SYS_sendfile64
#   endif
#endif  // LEGACY MACROS


// SOCKETCALL CALLS

#ifdef OSLINUX
#   define SC_socket   1
#   define SC_bind   2
#   define SC_connect   3
#   define SC_listen   4
#   define SC_accept   5
#   define SC_getsockname 6
#   define SC_getpeername 7
#   define SC_socketpair  8
#   define SC_send   9
#   define SC_recv   10
#   define SC_sendto   11
#   define SC_recvfrom   12
#   define SC_shutdown   13
#   define SC_setsockopt  14
#   define SC_getsockopt  15
#   define SC_sendmsg   16
#   define SC_recvmsg   17
#   define SC_accept4   18
#   define SC_recvmmsg   19
#   define SC_sendmmsg   20
#endif


/** @defgroup Syscall_Intrinsics Assembly functions implementing the syscalls
@{ */  // (FB){

/** Return the retval of a syscall and set errno (if needed) */
#define syscall_errno(ret)   do { if (PREDICT_UNLIKELY((unsigned long)ret >= (unsigned long)-4095UL)) { set_errno((int)(-((int)ret))); return (long)-1L; } return (long)ret; } while (0x0)
/** Return the retval of a syscall and set errno (if needed); Use the platform's syscall error flag */
#define syscall_errno2(ret, syserrbit)   do { if (PREDICT_UNLIKELY((syserrbit == -1) && ((unsigned long)r >= (unsigned long)-4095UL))) { set_errno((int)(-((int)ret))); return (long)-1L; } return (long)ret; } while (0x0)


// UNIX X86-64 SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHX86_64))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "syscall;"
#   define SYSCALL_REGS   "%rax, %rdi, %rsi, %rdx, %r10, %r8, %r9"
#   define SYSCALL_RET_REG   "%rax"
#   define SYSCALL_CLOBBERS   "%rcx", "%r11", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long ret;
	vasm("syscall;" : "=a"(ret) : "0"(n) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall1(const long n, const long a1) {
	register long ret;
	vasm("syscall;" : "=a"(ret) : "0"(n), "D"(a1) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall2(const long n, const long a1, const long a2) {
	register long ret;
	vasm("syscall;" : "=a"(ret) : "0"(n), "D"(a1), "S"(a2) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall3(const long n, const long a1, const long a2, const long a3) {
	register long ret;
	vasm("syscall;"
		: "=a"(ret)
		: "0"(n), "D"(a1), "S"(a2), "d"(a3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall4(const long n, const long a1, const long a2, const long a3, const long a4) {
	register long ret;
	register const long r10 asm ("r10") = a4;
	vasm("syscall;"
		: "=a"(ret)
		: "0"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall5(const long n, const long a1, const long a2, const long a3, const long a4, const long a5) {
	register long ret;
	register const long r10 asm ("r10") = a4;
	register const long r8 asm ("r8") = a5;
	vasm("syscall;"
		: "=a"(ret)
		: "0"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall6(const long n, const long a1, const long a2, const long a3, const long a4, const long a5, const long a6) {
	register long ret;
	register const long r10 asm ("r10") = a4;
	register const long r8 asm ("r8") = a5;
	register const long r9 asm ("r9") = a6;
	vasm("syscall;"
		: "=a"(ret)
		: "0"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8), "r"(r9)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


#endif


// UNIX X86-32 SYSCALL INTRINSICS

#if  (defined(OSUNIX) && defined(ARCHX86_32))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "int $0x80;"
#   define SYSCALL_REGS   "%eax, %ebx, %ecx, %edx, %esi, %edi, %ebp"
#   define SYSCALL_RET_REG   "%eax"
#   define SYSCALL_CLOBBERS   "%edi", "%esi", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long ret;
	vasm("int $0x80;" : "=a"(ret) : "0"(n) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall1(const long n, const long a1) {
	register long ret;
	vasm("int $0x80;" : "=a"(ret) : "0"(n), "b"(a1) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall2(const long n, const long a1, const long a2) {
	register long ret;
	vasm("int $0x80;" : "=a"(ret) : "0"(n), "b"(a1), "c"(a2) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall3(const long n, const long a1, const long a2, const long a3) {
	register long ret;
	vasm("int $0x80;"
		: "=a"(ret)
		: "0"(n), "b"(a1), "c"(a2), "d"(a3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall4(const long n, const long a1, const long a2, const long a3, const long a4) {
	register long ret;
	vasm("int $0x80;"
		: "=a"(ret)
		: "0"(n), "b"(a1), "c"(a2), "d"(a3), "S"(a4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall5(const long n, const long a1, const long a2, const long a3, const long a4, const long a5) {
	register long ret;
	vasm("int $0x80;"
		: "=a"(ret)
		: "0"(n), "b"(a1), "c"(a2), "d"(a3), "S"(a4), "D"(a5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall6(const long n, const long a1, const long a2, const long a3, const long a4, const long a5, const long a6) {
	register long ret;
	register long r5 asm ("r5") = a6;
	vasm("int $0x80;"
		: "=a"(ret)
		: "0"(n), "b"(a1), "c"(a2), "d"(a3), "S"(a4), "D"(a5), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


#endif


// UNIX ARM64 SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHAARCH64))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "svc #0;"
#   define SYSCALL_REGS   "%x8, %x0, %x1, %x2, %x3, %x4, %x5"
#   define SYSCALL_RET_REG   "%x0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0");
	vasm("svc #0;" : "=r"(x0) : "r"(x8) : SYSCALL_CLOBBERS);
	syscall_errno(x0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	vasm("svc #0;" : "=r"(x0) : "r"(x8), "0"(x0) : SYSCALL_CLOBBERS);
	syscall_errno(x0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register const long x1 asm ("x1") = b;
	vasm("svc #0;" : "=r"(x0) : "r"(x8), "0"(x0), "r"(x1) : SYSCALL_CLOBBERS);
	syscall_errno(x0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register const long x1 asm ("x1") = b;
	register const long x2 asm ("x2") = c;
	vasm("svc #0;"
		: "=r"(x0)
		: "r"(x8), "0"(x0), "r"(x1), "r"(x2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(x0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register const long x1 asm ("x1") = b;
	register const long x2 asm ("x2") = c;
	register const long x3 asm ("x3") = d;
	vasm("svc #0;"
		: "=r"(x0)
		: "r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(x0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register const long x1 asm ("x1") = b;
	register const long x2 asm ("x2") = c;
	register const long x3 asm ("x3") = d;
	register const long x4 asm ("x4") = e;
	vasm("svc #0;"
		: "=r"(x0)
		: "r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(x0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register const long x1 asm ("x1") = b;
	register const long x2 asm ("x2") = c;
	register const long x3 asm ("x3") = d;
	register const long x4 asm ("x4") = e;
	register const long x5 asm ("x5") = f;
	vasm("svc #0;"
		: "=r"(x0)
		: "r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4), "r"(x5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(x0);
}


#endif


// UNIX ARM32/EABI (THUMB) SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHAARCH32) && defined(ARM_THUMB))


#   define SUPPORTS_SYSCALLS   1
#   define SUPPORTS_SYSCALL7   1
#   define MAX_SYSCALL_PARAMS   7
#   define SYSCALL_ASM_CMD   "swi 0;"
#   define SYSCALL_REGS   "%r7, %r0, %r1, %r2, %r3, %r4, %r5, %r6"
#   define SYSCALL_RET_REG   "%r0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0");
	vasm("swi 0;" : "=r"(r0) : "r"(r7) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	vasm("swi 0;" : "=r"(r0) : "r"(r7), "0"(r0) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	vasm("swi 0;" : "=r"(r0) : "r"(r7), "0"(r0), "r"(r1) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	vasm("swi 0;" : "=r"(r0) : "r"(r7), "0"(r0), "r"(r1), "r"(r2) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	vasm("swi 0;"
		: "=r"(r0)
		: "r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	register const long r4 asm ("r4") = e;
	vasm("swi 0;"
		: "=r"(r0)
		: "r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	register const long r4 asm ("r4") = e;
	register const long r5 asm ("r5") = f;
	vasm("swi 0;"
		: "=r"(r0)
		: "r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall7(const long n, const long a, const long b, const long c, const long d, const long e, const long f, const long g) {
	register const long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	register const long r4 asm ("r4") = e;
	register const long r5 asm ("r5") = f;
	register const long r6 asm ("r6") = g;
	vasm("swi 0;"
		: "=r"(r0)
		: "r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


#endif


// UNIX ARM32/OABI SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHAARCH32) && (!defined(ARM_THUMB)))


#   define SUPPORTS_SYSCALLS   1
#   define SUPPORTS_SYSCALL7   1
#   define MAX_SYSCALL_PARAMS   7
#   define SYSCALL_ASM_CMD   "swi %1;"
#   define SYSCALL_REGS   "rin, %a1, %a2, %a3, %a4, %v1, %v2, %v3"
#   define SYSCALL_RET_REG   "%a1"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	vasm("swi %1;" : "=r"(a1) : "rin"(n) : SYSCALL_CLOBBERS);
	syscall_errno(a1);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long a1 asm ("a1") = a;
	vasm("swi %1;" : "=r"(a1) : "rin"(n), "0"(a1) : SYSCALL_CLOBBERS);
	syscall_errno(a1);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	vasm("swi %1;" : "=r"(a1) : "rin"(n), "0"(a1), "r"(a2) : SYSCALL_CLOBBERS);
	syscall_errno(a1);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	register const long a3 asm ("a3") = c;
	vasm("swi %1;"
		: "=r"(a1)
		: "rin"(n), "0"(a1), "r"(a2), "r"(a3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a1);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	register const long a3 asm ("a3") = c;
	register const long a4 asm ("a4") = d;
	vasm("swi %1;"
		: "=r"(a1)
		: "rin"(n), "0"(a1), "r"(a2), "r"(a3), "r"(a4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a1);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	register const long a3 asm ("a3") = c;
	register const long a4 asm ("a4") = d;
	register const long v1 asm ("v1") = e;
	vasm("swi %1;"
		: "=r"(a1)
		: "rin"(n), "0"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(v1)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a1);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	register const long a3 asm ("a3") = c;
	register const long a4 asm ("a4") = d;
	register const long v1 asm ("v1") = e;
	register const long v2 asm ("v2") = f;
	vasm("swi %1;"
		: "=r"(a1)
		: "rin"(n), "0"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(v1), "r"(v2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a1);
}


LIB_FUNC long syscall7(const long n, const long a, const long b, const long c, const long d, const long e, const long f, const long g) {
	register long a1 asm ("a1") = a;
	register const long a2 asm ("a2") = b;
	register const long a3 asm ("a3") = c;
	register const long a4 asm ("a4") = d;
	register const long v1 asm ("v1") = e;
	register const long v2 asm ("v2") = f;
	register const long v3 asm ("v3") = g;
	vasm("swi %1;"
		: "=r"(a1)
		: "rin"(n), "0"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(v1), "r"(v2), "r"(v3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a1);
}


#endif


// UNIX ALPHA SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHALPHA))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "callsys;"
#   define SYSCALL_REGS   "%v0, %a0, %a1, %a2, %a3, %a4, %a5"
#   define SYSCALL_RET_REG   "%a0"
#   define SYSCALL_CLOBBERS   "%a3", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0");
	register long a3 asm ("a3");  // Error indicator
	vasm("callsys;" : "=r"(a0) : "r"(v0) : SYSCALL_CLOBBERS);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register long a3 asm ("a3");
	vasm("callsys;" : "=r"(a0) : "r"(v0), "0"(a0) : SYSCALL_CLOBBERS);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register const long a1 asm ("a1") = b;
	register long a3 asm ("a3");
	vasm("callsys;" : "=r"(a0) : "r"(v0), "0"(a0), "r"(a1) : SYSCALL_CLOBBERS);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register const long a1 asm ("a1") = b;
	register const long a2 asm ("a2") = c;
	register long a3 asm ("a3");
	vasm("callsys;" : "=r"(a0) : "r"(v0), "0"(a0), "r"(a1), "r"(a2) : SYSCALL_CLOBBERS);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register const long a1 asm ("a1") = b;
	register const long a2 asm ("a2") = c;
	register long a3 asm ("a3") = d;
	vasm("callsys;"
		: "=r"(a0)
		: "r"(v0), "0"(a0), "r"(a1), "r"(a2), "r"(a3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register const long a1 asm ("a1") = b;
	register const long a2 asm ("a2") = c;
	register long a3 asm ("a3") = d;
	register const long a4 asm ("a4") = e;
	vasm("callsys;"
		: "=r"(a0)
		: "r"(v0), "0"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(a0, a3);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long v0 asm ("v0") = n;
	register long a0 asm ("a0") = a;
	register const long a1 asm ("a1") = b;
	register const long a2 asm ("a2") = c;
	register long a3 asm ("a3") = d;
	register const long a4 asm ("a4") = e;
	register const long a5 asm ("a5") = f;
	vasm("callsys;"
		: "=r"(a0)
		: "r"(v0), "0"(a0), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(a0, a3);
}


#endif


// UNIX ARC SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHARC))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "trap 0;"
#   define SYSCALL_REGS   "%r8, %r0, %r1, %r2, %r3, %r4, %r5"
#   define SYSCALL_RET_REG   "%r0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0");
	vasm("trap 0;" : "=r"(r0) : "r"(r8) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	vasm("trap 0;" : "=r"(r0) : "r"(r8), "0"(r0) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	vasm("trap 0;" : "=r"(r0) : "r"(r8), "0"(r0), "r"(r1) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	vasm("trap 0;" : "=r"(r0) : "r"(r8), "0"(r0), "r"(r1), "r"(r2) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	vasm("trap 0;"
		: "=r"(r0)
		: "r"(r8), "0"(r0), "r"(r1), "r"(r2), "r"(r3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	register const long r4 asm ("r4") = e;
	vasm("trap 0;"
		: "=r"(r0)
		: "r"(r8), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r8 asm ("r8") = n;
	register long r0 asm ("r0") = a;
	register const long r1 asm ("r1") = b;
	register const long r2 asm ("r2") = c;
	register const long r3 asm ("r3") = d;
	register const long r4 asm ("r4") = e;
	register const long r5 asm ("r5") = f;
	vasm("trap 0;"
		: "=r"(r0)
		: "r"(r8), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


#endif


// UNIX BLACKFIN SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHBLACKFIN))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "excpt 0;"
#   define SYSCALL_REGS   "%qA, %q0, %q1, %q2, %q3, %q4, %q5"
#   define SYSCALL_RET_REG   "%q0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0");
	vasm("excpt 0;" : "=r"(q0) : "r"(qA) : SYSCALL_CLOBBERS);
	syscall_errno(q0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	vasm("excpt 0;" : "=r"(q0) : "r"(qA), "0"(q0) : SYSCALL_CLOBBERS);
	syscall_errno(q0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	register const long q1 asm ("q1") = b;
	vasm("excpt 0;"
		: "=r"(q0) : "r"(qA), "0"(q0), "r"(q1)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(q0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	register const long q1 asm ("q1") = b;
	register const long q2 asm ("q2") = c;
	vasm("excpt 0;"
		: "=r"(q0) : "r"(qA), "0"(q0), "r"(q1), "r"(q2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(q0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	register const long q1 asm ("q1") = b;
	register const long q2 asm ("q2") = c;
	register const long q3 asm ("q3") = d;
	vasm("excpt 0;"
		: "=r"(q0) : "r"(qA), "0"(q0), "r"(q1), "r"(q2), "r"(q3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(q0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	register const long q1 asm ("q1") = b;
	register const long q2 asm ("q2") = c;
	register const long q3 asm ("q3") = d;
	register const long q4 asm ("q4") = e;
	vasm("excpt 0;"
		: "=r"(q0) : "r"(qA), "0"(q0), "r"(q1), "r"(q2), "r"(q3), "r"(q4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(q0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long qA asm ("qA") = n;
	register long q0 asm ("q0") = a;
	register const long q1 asm ("q1") = b;
	register const long q2 asm ("q2") = c;
	register const long q3 asm ("q3") = d;
	register const long q4 asm ("q4") = e;
	register const long q5 asm ("q5") = f;
	vasm("excpt 0;"
		: "=r"(q0) : "r"(qA), "0"(q0), "r"(q1), "r"(q2), "r"(q3), "r"(q4), "r"(q5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(q0);
}


#endif


// UNIX ITANIUM SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHITANIUM))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "break 0x100000;"
#   define SYSCALL_REGS   "%r15, %out0, %out1, %out2, %out3, %out4, %out5"
#   define SYSCALL_RET_REG   "%r8"
#   define SYSCALL_CLOBBERS   "%r10", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	vasm("break 0x100000;" : "=r"(ret) : "r"(r15) : SYSCALL_CLOBBERS);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	register const long out1 asm ("out1") = b;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0), "r"(out1)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	register const long out1 asm ("out1") = b;
	register const long out2 asm ("out2") = c;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0), "r"(out1), "r"(out2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	register const long out1 asm ("out1") = b;
	register const long out2 asm ("out2") = c;
	register const long out3 asm ("out3") = d;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0), "r"(out1), "r"(out2), "r"(out3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	register const long out1 asm ("out1") = b;
	register const long out2 asm ("out2") = c;
	register const long out3 asm ("out3") = d;
	register const long out4 asm ("out4") = e;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0), "r"(out1), "r"(out2), "r"(out3), "r"(out4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r15 asm ("r15") = n;
	register long ret asm ("r8");
	register long err asm ("r10");
	register const long out0 asm ("out0") = a;
	register const long out1 asm ("out1") = b;
	register const long out2 asm ("out2") = c;
	register const long out3 asm ("out3") = d;
	register const long out4 asm ("out4") = e;
	register const long out5 asm ("out5") = f;
	vasm("break 0x100000;"
		: "=r"(ret) : "r"(r15), "r"(out0), "r"(out1), "r"(out2), "r"(out3), "r"(out4), "r"(out5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(ret, err);
}


#endif


// UNIX M68K SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHM68K))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "trap 0;"
#   define SYSCALL_REGS   "%d0, %d1, %d2, %d3, %d4, %d5, %d6"
#   define SYSCALL_RET_REG   "%d0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long d0 asm ("d0") = n;
	vasm("trap 0;" : "=r"(d0) : "0"(d0) : SYSCALL_CLOBBERS);
	syscall_errno(d0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	vasm("trap 0;" : "=r"(d0) : "0"(d0), "r"(d1) : SYSCALL_CLOBBERS);
	syscall_errno(d0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	register const long d2 asm ("d2") = b;
	vasm("trap 0;" : "=r"(d0) : "0"(d0), "r"(d1), "r"(d2) : SYSCALL_CLOBBERS);
	syscall_errno(d0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	register const long d2 asm ("d2") = b;
	register const long d3 asm ("d3") = c;
	vasm("trap 0;"
		: "=r"(d0)
		: "0"(d0), "r"(d1), "r"(d2), "r"(d3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(d0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	register const long d2 asm ("d2") = b;
	register const long d3 asm ("d3") = c;
	register const long d4 asm ("d4") = d;
	vasm("trap 0;"
		: "=r"(d0)
		: "0"(d0), "r"(d1), "r"(d2), "r"(d3), "r"(d4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(d0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	register const long d2 asm ("d2") = b;
	register const long d3 asm ("d3") = c;
	register const long d4 asm ("d4") = d;
	register const long d5 asm ("d5") = e;
	vasm("trap 0;"
		: "=r"(d0)
		: "0"(d0), "r"(d1), "r"(d2), "r"(d3), "r"(d4), "r"(d5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(d0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long d0 asm ("d0") = n;
	register const long d1 asm ("d1") = a;
	register const long d2 asm ("d2") = b;
	register const long d3 asm ("d3") = c;
	register const long d4 asm ("d4") = d;
	register const long d5 asm ("d5") = e;
	register const long d6 asm ("d6") = f;
	vasm("trap 0;"
		: "=r"(d0)
		: "0"(d0), "r"(d1), "r"(d2), "r"(d3), "r"(d4), "r"(d5), "r"(d6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(d0);
}


#endif


// UNIX METAG SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHMETAG))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "SWITCH  #0x440001;"
#   define SYSCALL_REGS   "%D1Re0, %D1Ar1, %D0Ar2, %D1Ar3, %D0Ar4, %D1Ar5, %D0Ar6"
#   define SYSCALL_RET_REG   "%D0Re0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	vasm("SWITCH  #0x440001;" S: "=d"(__res) : "d"(__call) : SYSCALL_CLOBBERS);
	syscall_errno(__res);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	vasm("SWITCH  #0x440001;" : "=d"(__res) : "d"(__call), "d"(__a) : SYSCALL_CLOBBERS);
	syscall_errno(__res);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	register const long __b asm ("D0Ar2") = b;
	vasm("SWITCH  #0x440001;"
		: "=d"(__res)
		: "d"(__call), "d"(__a), "d"(__b)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(__res);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	register const long __b asm ("D0Ar2") = b;
	register const long __c asm ("D1Ar3") = c;
	vasm("SWITCH  #0x440001;"
		: "=d"(__res)
		: "d"(__call), "d"(__a), "d"(__b), "d"(__c)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(__res);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	register const long __b asm ("D0Ar2") = b;
	register const long __c asm ("D1Ar3") = c;
	register const long __d asm ("D0Ar4") = d;
	vasm("SWITCH  #0x440001;"
		: "=d"(__res)
		: "d"(__call), "d"(__a), "d"(__b), "d"(__c), "d"(__d)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(__res);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	register const long __b asm ("D0Ar2") = b;
	register const long __c asm ("D1Ar3") = c;
	register const long __d asm ("D0Ar4") = d;
	register const long __e asm ("D1Ar5") = e;
	vasm("SWITCH  #0x440001;"
		: "=d"(__res)
		: "d"(__call), "d"(__a), "d"(__b), "d"(__c), "d"(__d), "d"(__e)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(__res);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long __res asm ("D0Re0");
	register const long __call asm ("D1Re0") = n;
	register const long __a asm ("D1Ar1") = a;
	register const long __b asm ("D0Ar2") = b;
	register const long __c asm ("D1Ar3") = c;
	register const long __d asm ("D0Ar4") = d;
	register const long __e asm ("D1Ar5") = e;
	register const long __f asm ("D0Ar6") = f;
	vasm("SWITCH  #0x440001;"
		: "=d"(__res)
		: "d"(__call), "d"(__a), "d"(__b), "d"(__c), "d"(__d), "d"(__e), "d"(__f)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(__res);
}


#endif


// UNIX MICROBLAZE SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHMICROBLAZE))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "brki r14,8;"
#   define SYSCALL_REGS   "%r12, %r5, %r6, %r7, %r8, %r9, %r10"
#   define SYSCALL_RET_REG   "%r3"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	vasm("brki r14,8;" : "=r"(ret) : "r"(r12) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	vasm("brki r14,8;" : "=r"(ret) : "r"(r12), "r"(r5) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	register const long r6 asm ("r6") = b;
	vasm("brki r14,8;"
		: "=r"(ret) : "r"(r12), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	register const long r6 asm ("r6") = b;
	register const long r7 asm ("r7") = c;
	vasm("brki r14,8;"
		: "=r"(ret) : "r"(r12), "r"(r5), "r"(r6), "r"(r7)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	register const long r6 asm ("r6") = b;
	register const long r7 asm ("r7") = c;
	register const long r8 asm ("r8") = d;
	vasm("brki r14,8;"
		: "=r"(ret) : "r"(r12), "r"(r5), "r"(r6), "r"(r7), "r"(r8)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	register const long r6 asm ("r6") = b;
	register const long r7 asm ("r7") = c;
	register const long r8 asm ("r8") = d;
	register const long r9 asm ("r9") = e;
	vasm("brki r14,8;"
		: "=r"(ret) : "r"(r12), "r"(r5), "r"(r6), "r"(r7), "r"(r8), "r"(r9)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r12 asm ("r12") = n;
	register long ret asm ("r3");
	register const long r5 asm ("r5") = a;
	register const long r6 asm ("r6") = b;
	register const long r7 asm ("r7") = c;
	register const long r8 asm ("r8") = d;
	register const long r9 asm ("r9") = e;
	register const long r10 asm ("r10") = f;
	vasm("brki r14,8;"
		: "=r"(ret) : "r"(r12), "r"(r5), "r"(r6), "r"(r7), "r"(r8), "r"(r9), "r"(r10)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


#endif


// UNIX NIOSII SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHNIOS2))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "brki r14,8;"
#   define SYSCALL_REGS   "%r7, %r4, %r5, %r6, %r7, %r8, %r9"
#   define SYSCALL_RET_REG   "%r2"
#   define SYSCALL_CLOBBERS   "%r7", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long ret asm ("r2") = n;
	vasm("trap;" : "=r"(ret) : "0"(ret) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long ret asm ("r2") = n;
	register const long r4 asm ("r4") = a;
	vasm("trap;" : "=r"(ret) : "0"(ret), "r"(r4) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long ret asm ("r2") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	vasm("trap;" : "=r"(ret) : "0"(ret), "r"(r4), "r"(r5) : SYSCALL_CLOBBERS);
	syscall_errno(ret);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long ret asm ("r2") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	vasm("trap;"
		: "=r"(ret)
		: "0"(ret), "r"(r4), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long ret asm ("r2") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register long r7 asm ("r7") = d;
	vasm("trap;"
		: "=r"(ret)
		: "0"(ret), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long ret asm ("r2") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register long r7 asm ("r7") = d;
	register const long r8 asm ("r8") = e;
	vasm("trap;"
		: "=r"(ret)
		: "0"(ret), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "r"(r8)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long ret asm ("r2") = n;  // r2, r4, r5, r6, r7, r8, r9; return on r2; error on r7
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register long r7 asm ("r7") = d;  // Clobbered with syscall error number
	register const long r8 asm ("r8") = e;
	register const long r9 asm ("r9") = f;
	vasm("trap;"
		: "=r"(ret)
		: "0"(ret), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "r"(r8), "r"(r9)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


#endif


// UNIX PARISC/HPPA SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHPARISC))


#   define SUPPORTS_SYSCALLS   1
#   if IS_PIC
#      define K_STW_ASM_PIC   "copy %%r19, %%r4;"
#      define K_LDW_ASM_PIC   "copy %%r4, %%r19;"
#      define K_USING_GR4   "%r4",
#   else
#      define K_STW_ASM_PIC   ""
#      define K_LDW_ASM_PIC   ""
#      define K_USING_GR4
#   endif
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   K_STW_ASM_PIC "copy %1, %%r20; ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
#   define SYSCALL_REGS   "%r20, %r26, %r25, %r24, %r23, %r22, %r21"
#   define SYSCALL_RET_REG   "%r28"
#   define SYSCALL_CLOBBERS   "%r1", "%r2", K_USING_GR4 "%r20", "%r29", "%r31", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register unsigned long ret asm ("r28");
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26)
		: "%r26", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	register unsigned long r25 asm ("r25") = (unsigned long)b;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26), "r"(r25)
		: "%r26", "%r25", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	register unsigned long r25 asm ("r25") = (unsigned long)b;
	register unsigned long r24 asm ("r24") = (unsigned long)c;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26), "r"(r25), "r"(r24)
		: "%r26", "%r25", "%r24", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	register unsigned long r25 asm ("r25") = (unsigned long)b;
	register unsigned long r24 asm ("r24") = (unsigned long)c;
	register unsigned long r23 asm ("r23") = (unsigned long)d;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26), "r"(r25), "r"(r24), "r"(r23)
		: "%r26", "%r25", "%r24", "%r23", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	register unsigned long r25 asm ("r25") = (unsigned long)b;
	register unsigned long r24 asm ("r24") = (unsigned long)c;
	register unsigned long r23 asm ("r23") = (unsigned long)d;
	register unsigned long r22 asm ("r22") = (unsigned long)e;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26), "r"(r25), "r"(r24), "r"(r23), "r"(r22)
		: "%r26", "%r25", "%r24", "%r23", "%r22", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register unsigned long ret asm ("r28");
	register unsigned long r26 asm ("r26") = (unsigned long)a;
	register unsigned long r25 asm ("r25") = (unsigned long)b;
	register unsigned long r24 asm ("r24") = (unsigned long)c;
	register unsigned long r23 asm ("r23") = (unsigned long)d;
	register unsigned long r22 asm ("r22") = (unsigned long)e;
	register unsigned long r21 asm ("r21") = (unsigned long)f;
	vasm(K_STW_ASM_PIC "copy %1, %%r20;" "ble 0x100(%%sr2, %%r0);" K_LDW_ASM_PIC
		: "=r"(ret)
		: "rin"(n), "r"(r26), "r"(r25), "r"(r24), "r"(r23), "r"(r22), "r"(r21)
		: "%r26", "%r25", "%r24", "%r23", "%r22", "%r21", SYSCALL_CLOBBERS
	);
	syscall_errno(ret);
}


#endif


// UNIX POWERPC SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHPOWERPC))


#   define SUPPORTS_SYSCALLS   1
#   define SUPPORTS_SYSCALL7   1
#   define MAX_SYSCALL_PARAMS   7
#   define SYSCALL_ASM_CMD   "sc;"
#   define SYSCALL_REGS   "%r0, %r3, %r4, %r5, %r6, %r7, %r8, %r9"
#   define SYSCALL_RET_REG   "%r3"
#   define SYSCALL_CLOBBERS   "%r0", DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long r0 asm ("r0") = n;
	register long ret asm ("r3");
	vasm("sc;" : "=r"(ret) : "r"(r0) : SYSCALL_CLOBBERS);
	syscall_errno2(ret, r0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	vasm("sc;" : "=r"(r3) : "r"(r0), "0"(r3) : SYSCALL_CLOBBERS);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	register const long r5 asm ("r5") = c;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	register const long r5 asm ("r5") = c;
	register const long r6 asm ("r6") = d;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	register const long r5 asm ("r5") = c;
	register const long r6 asm ("r6") = d;
	register const long r7 asm ("r7") = e;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long r0 asm ("r0") = n;
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	register const long r5 asm ("r5") = c;
	register const long r6 asm ("r6") = d;
	register const long r7 asm ("r7") = e;
	register const long r8 asm ("r8") = f;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "r"(r8)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


LIB_FUNC long syscall7(const long n, const long a, const long b, const long c, const long d, const long e, const long f, const long g) {
	register long r0 asm ("r0") = n;  // error in r0
	register long r3 asm ("r3") = a;
	register const long r4 asm ("r4") = b;
	register const long r5 asm ("r5") = c;
	register const long r6 asm ("r6") = d;
	register const long r7 asm ("r7") = e;
	register const long r8 asm ("r8") = f;
	register const long r9 asm ("r9") = g;
	vasm("sc;"
		: "=r"(r3) : "r"(r0), "0"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "r"(r8), "r"(r9)
		: SYSCALL_CLOBBERS
	);
	syscall_errno2(r3, r0);
}


#endif


// UNIX S390 SYSCALL INTRINSICS

#if (defined(OSUNIX) && (defined(ARCHS390) || defined(ARCHS390X)))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "sc;"
#   define SYSCALL_REGS   "%r1, %r2, %r3, %r4, %r5, %r6, %r7"
#   define SYSCALL_RET_REG   "%r2"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2");
	vasm("svc 0;" : "=r"(r2) : "r"(r1) : SYSCALL_CLOBBERS);
	syscall_errno(r2);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	vasm("svc 0;" : "=r"(r2) : "r"(r1), "0"(r2) : SYSCALL_CLOBBERS);
	syscall_errno(r2);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	register const long r3 asm ("r3") = b;
	vasm("svc 0;" : "=r"(r2) : "r"(r1), "0"(r2), "r"(r3) : SYSCALL_CLOBBERS);
	syscall_errno(r2);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	register const long r3 asm ("r3") = b;
	register const long r4 asm ("r4") = c;
	vasm("svc 0;"
		: "=r"(r2) : "r"(r1), "0"(r2), "r"(r3), "r"(r4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r2);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	register const long r3 asm ("r3") = b;
	register const long r4 asm ("r4") = c;
	register const long r5 asm ("r5") = d;
	vasm("svc 0;"
		: "=r"(r2) : "r"(r1), "0"(r2), "r"(r3), "r"(r4), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r2);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	register const long r3 asm ("r3") = b;
	register const long r4 asm ("r4") = c;
	register const long r5 asm ("r5") = d;
	register const long r6 asm ("r6") = e;
	vasm("svc 0;"
		: "=r"(r2) : "r"(r1), "0"(r2), "r"(r3), "r"(r4), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r2);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r1 asm ("r1") = n;
	register long r2 asm ("r2") = a;
	register const long r3 asm ("r3") = b;
	register const long r4 asm ("r4") = c;
	register const long r5 asm ("r5") = d;
	register const long r6 asm ("r6") = e;
	register const long r7 asm ("r7") = f;
	vasm("svc 0;"
		: "=r"(r2) : "r"(r1), "0"(r2), "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r2);
}


#endif


// UNIX SPARC SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHSPARC))


#   define SUPPORTS_SYSCALLS   1
#   ifdef ARCHSPARC64
#      define SPARC_SYSCALL   "t 0x6d;"
#   else
#      define SPARC_SYSCALL   "t 0x10;"
#   endif
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   SPARC_SYSCALL
#   define SYSCALL_REGS   "%g1, %o0, %o1, %o2, %o3, %o4, %o5"
#   define SYSCALL_RET_REG   "%o0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0");
	vasm(SPARC_SYSCALL : "=r"(O0) : "r"(G1) : SYSCALL_CLOBBERS);
	syscall_errno(O0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	vasm(SPARC_SYSCALL : "=r"(O0) : "r"(G1), "0"(O0) : SYSCALL_CLOBBERS);
	syscall_errno(O0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	register const long O1 asm ("o1") = b;
	vasm(SPARC_SYSCALL
		: "=r"(O0) : "r"(G1), "0"(O0), "r"(O1)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(O0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	register const long O1 asm ("o1") = b;
	register const long O2 asm ("o2") = c;
	vasm(SPARC_SYSCALL
		: "=r"(O0) : "r"(G1), "0"(O0), "r"(O1), "r"(O2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(O0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	register const long O1 asm ("o1") = b;
	register const long O2 asm ("o2") = c;
	register const long O3 asm ("o3") = d;
	vasm(SPARC_SYSCALL
		: "=r"(O0) : "r"(G1), "0"(O0), "r"(O1), "r"(O2), "r"(O3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(O0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	register const long O1 asm ("o1") = b;
	register const long O2 asm ("o2") = c;
	register const long O3 asm ("o3") = d;
	register const long O4 asm ("o4") = e;
	vasm(SPARC_SYSCALL
		: "=r"(O0) : "r"(G1), "0"(O0), "r"(O1), "r"(O2), "r"(O3), "r"(O4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(O0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long G1 asm ("g1") = n;
	register long O0 asm ("o0") = a;
	register const long O1 asm ("o1") = b;
	register const long O2 asm ("o2") = c;
	register const long O3 asm ("o3") = d;
	register const long O4 asm ("o4") = e;
	register const long O5 asm ("o5") = f;
	vasm(SPARC_SYSCALL
		: "=r"(O0) : "r"(G1), "0"(O0), "r"(O1), "r"(O2), "r"(O3), "r"(O4), "r"(O5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(O0);
}


#endif


// UNIX SUPERH SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHSUPERH))


#   define SUPPORTS_SYSCALLS   1
#   define SUPPORTS_SYSCALL7   1
#   define MAX_SYSCALL_PARAMS   7
#   define SYSCALL_ASM_CMD   "trap #0x17;"
#   define SYSCALL_REGS   "%r3, %r4, %r5, %r6, %r7, %r0, %r1, %r2"
#   define SYSCALL_RET_REG   "%r0"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register const long r3 asm ("r3") = n;
	register long r0 asm ("r0");
	vasm("trap #0x11;" : "=r"(r0) : "r"(r3) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register long r0 asm ("r0");
	vasm("trap #0x11;" : "=r"(r0) : "r"(r3), "r"(r4) : SYSCALL_CLOBBERS);
	syscall_errno(r0);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register long r0 asm ("r0");
	vasm("trap #0x12;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register long r0 asm ("r0");
	vasm("trap #0x13;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5), "r"(r6)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register const long r7 asm ("r7") = d;
	register long r0 asm ("r0");
	vasm("trap #0x14;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register const long r7 asm ("r7") = d;
	register long r0 asm ("r0") = e;
	vasm("trap #0x15;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "0"(r0)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register const long r7 asm ("r7") = d;
	register long r0 asm ("r0") = e;
	register const long r1 asm ("r1") = f;
	vasm("trap #0x16;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "0"(r0), "r"(r1)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


LIB_FUNC long syscall7(const long n, const long a, const long b, const long c, const long d, const long e, const long f, const long g) {
	register const long r3 asm ("r3") = n;
	register const long r4 asm ("r4") = a;
	register const long r5 asm ("r5") = b;
	register const long r6 asm ("r6") = c;
	register const long r7 asm ("r7") = d;
	register long r0 asm ("r0") = e;
	register const long r1 asm ("r1") = f;
	register const long r2 asm ("r2") = g;
	vasm("trap #0x17;"
		: "=r"(r0) : "r"(r3), "r"(r4), "r"(r5), "r"(r6), "r"(r7), "0"(r0), "r"(r1), "r"(r2)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(r0);
}


#endif


// UNIX XTENSA SYSCALL INTRINSICS

#if (defined(OSUNIX) && defined(ARCHXTENSA))


#   define SUPPORTS_SYSCALLS   1
#   define MAX_SYSCALL_PARAMS   6
#   define SYSCALL_ASM_CMD   "syscall;"
#   define SYSCALL_REGS   "%a2, %a6, %a3, %a4, %a5, %a8, %a9"
#   define SYSCALL_RET_REG   "%a2"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long a2 asm ("a2") = n;
	vasm("syscall;" : "=r"(a2) : "0"(a2) : SYSCALL_CLOBBERS);
	syscall_errno(a2);
}


LIB_FUNC long syscall1(const long n, const long a) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	vasm("syscall;" : "=r"(a2) : "0"(a2), "r"(a6) : SYSCALL_CLOBBERS);
	syscall_errno(a2);
}


LIB_FUNC long syscall2(const long n, const long a, const long b) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	register const long a3 asm ("a3") = b;
	vasm("syscall;"
		: "=r"(a2) : "0"(a2), "r"(a6), "r"(a3)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a2);
}


LIB_FUNC long syscall3(const long n, const long a, const long b, const long c) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	register const long a3 asm ("a3") = b;
	register const long a4 asm ("a4") = c;
	vasm("syscall;"
		: "=r"(a2) : "0"(a2), "r"(a6), "r"(a3), "r"(a4)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a2);
}


LIB_FUNC long syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	register const long a3 asm ("a3") = b;
	register const long a4 asm ("a4") = c;
	register const long a5 asm ("a5") = d;
	vasm("syscall;"
		: "=r"(a2) : "0"(a2), "r"(a6), "r"(a3), "r"(a4), "r"(a5)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a2);
}


LIB_FUNC long syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	register const long a3 asm ("a3") = b;
	register const long a4 asm ("a4") = c;
	register const long a5 asm ("a5") = d;
	register const long a8 asm ("a8") = e;
	vasm("syscall;"
		: "=r"(a2) : "0"(a2), "r"(a6), "r"(a3), "r"(a4), "r"(a5), "r"(a8)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a2);
}


LIB_FUNC long syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long a2 asm ("a2") = n;
	register const long a6 asm ("a6") = a;
	register const long a3 asm ("a3") = b;
	register const long a4 asm ("a4") = c;
	register const long a5 asm ("a5") = d;
	register const long a8 asm ("a8") = e;
	register const long a9 asm ("a9") = f;
	vasm("syscall;"
		: "=r"(a2) : "0"(a2), "r"(a6), "r"(a3), "r"(a4), "r"(a5), "r"(a8), "r"(a9)
		: SYSCALL_CLOBBERS
	);
	syscall_errno(a2);
}


#endif


// HAIKU X86-64 SYSCALL INTRINSICS

#if (defined(OSHAIKU) && defined(ARCHAARCH64))


#   define SUPPORTS_SYSCALLS   1
#   define SUPPORTS_SYSCALL7   1
#   define SUPPORTS_SYSCALL16   1
#   define MAX_SYSCALL_PARAMS   16
#   define SYSCALL_ASM_CMD   "lea 4(%%esp), %%edx; int $99;"
#   define SYSCALL_REGS   "%r0, %ecx, %esp"
#   define SYSCALL_RET_REG   "%eax"
#   define SYSCALL_CLOBBERS   DEFAULT_SYSCALL_CLOBBERS


LIB_FUNC long syscall0(const long n) {
	register long ret;
	register const long numargs = 0;
	vasm("lea 4(%%esp), %%edx;" "int $99;" : "=a"(ret) : "0"(n), "c"(numargs) : SYSCALL_CLOBBERS);
	return ret;
}


LIB_FUNC long syscall1(const long n, const UNUSED long a) {
	register long ret;
	register const long numargs = 1;
	vasm("lea 4(%%esp), %%edx;" "int $99;" : "=a"(ret) : "0"(n), "c"(numargs) : SYSCALL_CLOBBERS);
	return ret;
}


LIB_FUNC long syscall2(const long n, const UNUSED long a, const UNUSED long b) {
	register long ret;
	register const long numargs = 2;
	vasm("lea 4(%%esp), %%edx;" "int $99;" : "=a"(ret) : "0"(n), "c"(numargs) : SYSCALL_CLOBBERS);
	return ret;
}


LIB_FUNC long syscall3(const long n, const UNUSED long a, const UNUSED long b, const UNUSED long c) {
	register long ret;
	register const long numargs = 3;
	vasm("lea 4(%%esp), %%edx;" "int $99;"
		: "=a"(ret)
		: "0"(n), "c"(numargs)
		: SYSCALL_CLOBBERS
	);
	return ret;
}


LIB_FUNC long syscall4(const long n, const UNUSED long a, const UNUSED long b, const UNUSED long c, const UNUSED long d) {
	register long ret;
	register const long numargs = 4;
	vasm("lea 4(%%esp), %%edx;" "int $99;"
		: "=a"(ret)
		: "0"(n), "c"(numargs)
		: SYSCALL_CLOBBERS
	);
	return ret;
}


LIB_FUNC long syscall5(const long n, const UNUSED long a, const UNUSED long b, const UNUSED long c, const UNUSED long d, const UNUSED long e) {
	register long ret;
	register const long numargs = 5;
	vasm("lea 4(%%esp), %%edx;" "int $99;"
		: "=a"(ret)
		: "0"(n), "c"(numargs)
		: SYSCALL_CLOBBERS
	);
	return ret;
}


LIB_FUNC long syscall6(const long n, const UNUSED long a, const UNUSED long b, const UNUSED long c, const UNUSED long d, const UNUSED long e, const UNUSED long f) {
	register long ret;
	register const long numargs = 6;
	vasm("lea 4(%%esp), %%edx;" "int $99;"
		: "=a"(ret)
		: "0"(n), "c"(numargs)
		: SYSCALL_CLOBBERS
	);
	return ret;
}
#   error   "Add syscall support for Haiku (syscall7() through syscall16())."


#endif


#ifndef SUPPORTS_SYSCALLS
#   error   "Add syscall support for the target system."
#endif
#ifndef SUPPORTS_SYSCALL7
#   define SUPPORTS_SYSCALL7   0
#endif

/** @} */  // }


// SYSCALL MACROS FUNCTIONS

/** Return the retval of a syscall and set errno (if needed) */
#define syscall_ret(r)   syscall_errno((r))
/** Return the retval of a syscall and set errno (if needed) */
#define syscall_exit(r)   syscall_errno((r))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall0void(syscall_num)   (void)syscall0(syscall_num)
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall1void(syscall_num, a)   (void)syscall1(syscall_num, (a))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall2void(syscall_num, a, b)   (void)syscall2(syscall_num, (a), (b))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall3void(syscall_num, a, b, c)   (void)syscall3(syscall_num, (a), (b), (c))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall4void(syscall_num, a, b, c, d)   (void)syscall4(syscall_num, (a), (b), (c), (d))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall5void(syscall_num, a, b, c, d, e)   (void)syscall5(syscall_num, (a), (b), (c), (d), (e))
/** Macros for using a syscall when no output is needed nor wanted */
#define syscall6void(syscall_num, a, b, c, d, e, f)   (void)syscall6(syscall_num, (a), (b), (c), (d), (e), (f))
#if SUPPORTS_SYSCALL7
/** Macros for using a syscall when no output is needed nor wanted */
#   define syscall7void(syscall_num, a, b, c, d, e, f, g)   (void)syscall7(syscall_num, (a), (b), (c), (d), (e), (f), (g))
#endif

#define SYSCALL_DISP(b, ...)   CONCAT(b, NARGS(__VA_ARGS__)) (__VA_ARGS__)
#define __syscall(...)   SYSCALL_DISP(syscall, __VA_ARGS__)
#define __syscall_enter(...)   SYSCALL_DISP(syscall, __VA_ARGS__)
#define __sysenter(...)   SYSCALL_DISP(syscall, __VA_ARGS__)


/** Generic syscall function */
LIB_FUNC long syscall(const long n, ...) {
	va_list ap;
	va_start(ap, n);
	const long a = va_arg(ap, long);
	const long b = va_arg(ap, long);
	const long c = va_arg(ap, long);
	const long d = va_arg(ap, long);
	const long e = va_arg(ap, long);
	const long f = va_arg(ap, long);
#   if SUPPORTS_SYSCALL7
	const long g = va_arg(ap, long);
#   endif
	va_end(ap);
#   if SUPPORTS_SYSCALL7
	const long ret = (long)__syscall(n, a, b, c, d, e, f, g);
#   else
	const long ret = (long)__syscall(n, a, b, c, d, e, f);
#   endif
	syscall_errno(ret);
}
#define syscall_enter(n, ...)   syscall((n), __VA_ARGS__)
#define sysenter(n, ...)   syscall((n), __VA_ARGS__)


// IMPORTANT SYSCALLS

#if ((!defined(sys_open)) && defined(SYS_open))
#   define sys_open(filename, flags, mode)   syscall3(SYS_open, (filename), (flags), (mode))
#   define sys_open2(x, pn, _fl)   syscall2(SYS_open, pn, ((_fl) | O_LARGEFILE))
#   define sys_open3(x, pn, _fl, mo)   syscall3(SYS_open, pn, ((_fl) | O_LARGEFILE), mo)
#else
#   define sys_open(filename, flags, mode)   syscall3(SYS_openat, (filename), (flags), (mode))
#   define sys_open2(x, pn, _fl)   syscall3(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE))
#   define sys_open3(x, pn, _fl, mo)   syscall4(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE), mo)
#endif


LIB_FUNC ssize_t read(const int fd, const void* restrict buf, const size_t count) {
	return (ssize_t)syscall3(SYS_read, fd, (long)buf, (long)count);
}
#define __read(fd, buffer, size)   read((fd), (buffer), (size))


LIB_FUNC ssize_t write(const int fd, const void* restrict buf, const size_t count) {
	return (ssize_t)syscall3(SYS_write, fd, (long)buf, (long)count);
}
#define __write(fd, buffer, size)   write((fd), (buffer), (size))


/** Write a string to `STDOUT` */
LIB_FUNC REGPARM(1) ssize_t __write1(const char* restrict s) {
	return (ssize_t)syscall3(SYS_write, STDOUT_FILENO, (long)s, (long)strlen(s));
}


/** Write a string of the specified length to `STDOUT` */
LIB_FUNC REGPARM(1) ssize_t __write_stdout(const char* restrict str, const size_t len) {
	return (ssize_t)syscall3(SYS_write, STDOUT_FILENO, (long)str, (long)len);
}


/** Write a string to `STDERR` */
LIB_FUNC REGPARM(1) ssize_t __write2(const char* restrict s) {
	return (ssize_t)syscall3(SYS_write, STDERR_FILENO, (long)s, (long)strlen(s));
}


/** Write a string of the specified length to `STDERR` */
LIB_FUNC REGPARM(1) ssize_t __write_stderr(const char* restrict s, const size_t len) {
	return (ssize_t)syscall3(SYS_write, STDERR_FILENO, (long)s, (long)len);
}


/** Write a string of the specified length to the specified file-descriptor */
LIB_FUNC REGPARM(1) ssize_t __write2fd(const char* restrict s, const long fd, const size_t len) {
	return (ssize_t)syscall3(SYS_write, fd, (long)s, (long)len);
}


/** Write a newline character to `STDOUT` */
LIB_FUNC void __write_nl_stdout(void) {
	syscall3void(SYS_write, STDOUT_FILENO, (long)&NEWLINE[1], 1);
}
#define putsnl()   __write_nl_stdout()


/** Write two newline characters to `STDOUT` */
LIB_FUNC void __write_2nl_stdout(void) {
	syscall3void(SYS_write, STDOUT_FILENO, (long)&NEWLINE, 2);
}
#define puts2nl()   __write_2nl_stdout()


LIB_FUNC int close(const int fd) {
	return (int)syscall1(SYS_close, fd);
}
#define __close(fd)   close((fd))


LIB_FUNC off_t lseek(const int fd, const off_t offset, const int whence) {
#   ifdef SYS_llseek
	off_t result;
	return (off_t)(syscall5(SYS_llseek, fd, (long)(offset >> 32), (long)offset, (long)&result, whence) ? -1 : result);
#   else
	return (off_t)syscall3(SYS_lseek, fd, offset, whence);
#   endif
}
#define __lseek(fd, pos, whence)   lseek((fd), (pos), (whence))
#define __lseek64(fd, pos, whence)   lseek((fd), (pos), (whence))
#define lseek64(fd, pos, whence)   lseek((fd), (pos), (whence))


LIB_FUNC off_t lseek_overflow(const loff_t res) {
	const off_t retval = (off_t)res;
	if (retval == res) { return retval; }
	set_errno(EOVERFLOW);
	return (off_t)-1;
}


#endif  // SYSCALL_H


/* X86 INTRINSICS */


#if ((!defined(X86_EXTENSIONS_SEEN)) && defined(ARCHX86))
#define X86_EXTENSIONS_SEEN   (1)


// GET GPU INFO


#ifdef ARCHAMD64
/** Return the name of the system's AMD GPU device (if detected and known) */
LIB_FUNC const char* amd_gpu(void) {
#   ifdef __WinterPark__
	return "WinterPark";
#   elif defined(__BeaverCreek__)
	return "BeaverCreek";
#   elif defined(__Turks__)
	return "Turks";
#   elif defined(__Caicos__)
	return "Caicos";
#   elif defined(__Tahiti__)
	return "Tahiti";
#   elif defined(__Pitcairn__)
	return "Pitcairn";
#   elif defined(__Capeverde__)
	return "Capeverde";
#   elif defined(__Cayman__)
	return "Cayman";
#   elif defined(__Barts__)
	return "Barts";
#   elif defined(__Cypress__)
	return "Cypress";
#   elif defined(__Juniper__)
	return "Juniper";
#   elif defined(__Redwood__)
	return "Redwood";
#   elif defined(__Cedar__)
	return "Cedar";
#   elif defined(__ATI_RV770__)
	return "ATI_RV770";
#   elif defined(__ATI_RV730__)
	return "ATI_RV730";
#   elif defined(__ATI_RV710__)
	return "ATI_RV710";
#   elif defined(__Loveland__)
	return "Loveland";
#   elif defined(__Hawaii__)
	return "Hawaii";
#   else
	return "Unknown";
#   endif
}
#endif


// GET CPU INFO


/** Returns a true boolean value if irq are enabled for the CPU */
LIB_FUNC bool are_interrupts_enabled(void) {
	unsigned long flags = 0;
	vasm("pushf;" "pop %0;" : "=g"(flags));
	return (bool)(flags & 0x200);
}


/** The rdtsc (Read Time-Stamp Counter) instruction is used to determine how many CPU ticks occurred since the processor was reset */
LIB_FUNC unsigned long long rdtsc(void) {
	register unsigned long long cpu_ticks;
	vasm("mfence;" "rdtsc;" "mfence;" : "=A"(cpu_ticks));  // `=A` is `edx:eax`
	return cpu_ticks;
}


/** The rdtscp (Read Time-Stamp Counter) instruction is used to determine how many CPU ticks occurred since the processor was reset */
LIB_FUNC unsigned long long rdtscp(void) {
	register unsigned long long cpu_ticks;
	vasm("mfence;" "rdtscp;" "mfence;" : "=A"(cpu_ticks));
	return cpu_ticks;
}


/** Return the vendor ID of the x86 CPU (Assumes little-endian) */
LIB_FUNC const char* get_vendor_id(void) {
	register int ebx, edx, ecx;
	asm (
		"movl $0,%%eax;"
		"cpuid;"
		"movl %%ecx,%0;"
		"movl %%edx,%1;"
		"movl %%ebx,%2;"
		: "=r"(ebx), "=r"(edx), "=r"(ecx)  // Output C variable
		:  // No input variables
		: "ebx", "edx", "ecx"  // Clobbered Register
	);
	static union char_int_array { char char_arr[16]; int32_t int_arr[4]; } vendor = { .int_arr = { 0 } };
	vendor.int_arr[3] = 0;
	vendor.int_arr[2] = ebx;
	vendor.int_arr[1] = edx;
	vendor.int_arr[0] = ecx;
	return vendor.char_arr;
}


/** Get the stepping value of the CPU */
LIB_FUNC signed int get_cpu_stepping(void) {
	register signed int stepping;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001111,%%eax;"
		"movl %%eax,%0;"
		: "=r"(stepping)
	);
	return stepping;
}


#if CPU_BMI2


/* BOOLEAN TESTS FOR FEATURES */


/** Test if the CPU supports `fpu` */
LIB_FUNC int is_fpu_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `vme` (Virtual 8086 Mode Extensions, such as VIF, VIP, and PIV) */
LIB_FUNC int is_vme_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%edx;"
		"sarl $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `de` (Debugging extensions (CR4 bit 3)) */
LIB_FUNC int is_de_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%edx;"
		"sarl $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pse` (Page Size Extension) */
LIB_FUNC int is_pse_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%edx;"
		"sarl $3,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `tsc` (Time Stamp Counter) */
LIB_FUNC int is_tsc_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%edx;"
		"sarl $4,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `msr` (Model-specific registers) */
LIB_FUNC int is_msr_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%edx;"
		"sarl $5,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pae` (Physical Address Extension) */
LIB_FUNC int is_pae_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000001000000,%%edx;"
		"sarl $6,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `mce` (Machine Check Exception) */
LIB_FUNC int is_mce_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%edx;"
		"sarl $7,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `cx8` (CMPXCHG8/compare-and-swap instruction) */
LIB_FUNC int is_cx8_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%edx;"
		"sarl $8,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `apic` (Onboard Advanced Programmable Interrupt Controller) */
LIB_FUNC int is_apic_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%edx;"
		"sarl $9,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sep` (SYSENTER and SYSEXIT Instructions) */
LIB_FUNC int is_sep_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000100000000000,%%edx;"
		"sarl $11,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `mtrr` (Memory Type Range Registers) */
LIB_FUNC int is_mtrr_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%edx;"
		"sarl $12,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pge` (Page Global Enable bit in CR4) */
LIB_FUNC int is_pge_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $13,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `mca` (Machine check architecture) */
LIB_FUNC int is_mca_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%edx;"
		"sarl $14,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `cmov` (Conditional move and FCMOV instructions) */
LIB_FUNC int is_cmov_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%edx;"
		"sarl $15,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pat` (Page Attribute Table) */
LIB_FUNC int is_pat_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000010000000000000000,%%edx;"
		"sarl $16,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pse-36` (36-bit page size extension) */
LIB_FUNC int is_pse36_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%edx;"
		"sarl $17,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `psn` (Processor Serial Number) */
LIB_FUNC int is_psn_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%edx;"
		"sarl $18,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `clfsh` (CLFLUSH instruction (SSE2)) */
LIB_FUNC int is_clfsh_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%edx;"
		"sarl $19,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `ds` (Debug store: save trace of executed jumps) */
LIB_FUNC int is_ds_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%edx;"
		"sarl $21,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `acpi` (Onboard thermal control MSRs for ACPI) */
LIB_FUNC int is_acpi_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%edx;"
		"sarl $22,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `mmx` (MMX Instructions) */
LIB_FUNC int is_mmx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%edx;"
		"sarl $23,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `fxsr` (FXSAVE, FXRESTOR instructions, CR4 bit 9) */
LIB_FUNC int is_fxsr_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%edx;"
		"sarl $24,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sse` (SSE instructions) */
LIB_FUNC int is_sse_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%edx;"
		"sarl $25,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sse2` (SSE2 Instructions) */
LIB_FUNC int is_sse2_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%edx;"
		"sarl $26,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `ss` (CPU cache supports self-snoop) */
LIB_FUNC int is_ss_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%edx;"
		"sarl $27,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `htt` (Hyper-threading) */
LIB_FUNC int is_htt_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%edx;"
		"sarl $28,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `tm` (Thermal monitor automatically limits temperature) */
LIB_FUNC int is_tm_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%edx;"
		"sarl $29,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `ia64` (IA64 processor emulating x86) */
LIB_FUNC int is_ia64_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%edx;"
		"sarl $30,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pbe` (Pending Break Enable (PBE# pin) wakeup support) */
LIB_FUNC int is_pbe_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%edx;"
		"sarl $31,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sse3` (Prescott New Instructions-SSE3 (PNI)) */
LIB_FUNC int is_sse3_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pclmulqdq` (PCLMULQDQ support) */
LIB_FUNC int is_pclmulqdq_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%edx;"
		"sarl $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `dtes64` (64-bit debug store (edx bit 21)) */
LIB_FUNC int is_dtes64_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%edx;"
		"sarl $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `monitor` (MONITOR and MWAIT instructions (SSE3)) */
LIB_FUNC int is_monitor_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%edx;"
		"sarl $3,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `ds-cpl` (CPL qualified debug store) */
LIB_FUNC int is_dscpl_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%edx;"
		"sarl $4,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `vmx` (Virtual Machine eXtensions) */
LIB_FUNC int is_vmx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%edx;"
		"sarl $5,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `smx` (Safer Mode Extensions (LaGrande)) */
LIB_FUNC int is_smx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000001000000,%%edx;"
		"sarl $6,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `est` (Enhanced SpeedStep) */
LIB_FUNC int is_est_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%edx;"
		"sarl $7,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `tm2` (Thermal Monitor 2) */
LIB_FUNC int is_tm2_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%edx;"
		"sarl $8,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `ssse3` (Supplemental SSE3 Instructions) */
LIB_FUNC int is_ssse3_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%edx;"
		"sarl $9,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `cnxt-id` (L1 Context ID) */
LIB_FUNC int is_cnxtid_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000010000000000,%%edx;"
		"sarl $10,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sdbg` (Silicon Debug interface) */
LIB_FUNC int is_sdbg_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $11,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `fma` (Fused multiply-add (FMA3)) */
LIB_FUNC int is_fma_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%edx;"
		"sarl $12,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `cx16` (CMPXCHG16B Instruction) */
LIB_FUNC int is_cx16_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $13,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `xtpr` (Can disable sending task priority messages) */
LIB_FUNC int is_xtpr_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%edx;"
		"sarl $14,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pdcm` (Perfmon & debug capability) */
LIB_FUNC int is_pdcm_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%edx;"
		"sarl $15,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pcid` (Process context identifiers (CR4 bit 17)) */
LIB_FUNC int is_pcid_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%edx;"
		"sarl $17,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `dca` (Direct cache access for DMA writes) */
LIB_FUNC int is_dca_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%edx;"
		"sarl $18,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sse41` (SSE4.1 Instructions) */
LIB_FUNC int is_sse41_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%edx;"
		"sarl $19,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sse42` (SSE4.2 Instructions) */
LIB_FUNC int is_sse42_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000100000000000000000000,%%edx;"
		"sarl $20,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `x2apic` (x2APIC support) */
LIB_FUNC int is_x2apic_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%edx;"
		"sarl $21,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `movbe` (MOVBE instruction (big-endian)) */
LIB_FUNC int is_movbe_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%edx;"
		"sarl $22,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `popcnt` (POPCNT Instruction) */
LIB_FUNC int is_popcnt_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%edx;"
		"sarl $23,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `tsc-deadline` (APIC supports one-shot operation using a TSC deadline value) */
LIB_FUNC int is_tscdeadline_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%edx;"
		"sarl $24,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `aes` (AES instruction set) */
LIB_FUNC int is_aes_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%edx;"
		"sarl $25,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `xsave` (XSAVE, XRESTOR, XSETBV, XGETBV)xx */
LIB_FUNC int is_xsave_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%edx;"
		"sarl $26,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the OS supports `xsave` (CPU cache supports self-snoop) */
LIB_FUNC int is_osxsave_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%edx;"
		"sarl $27,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx` (Advanced Vector Extensions) */
LIB_FUNC int is_avx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%edx;"
		"sarl $28,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `f16c` (F16C (half-precision) FP support) */
LIB_FUNC int is_f16c_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%edx;"
		"sarl $29,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `rdrnd` (on-chip random number generator instructions) */
LIB_FUNC int is_rdrnd_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%edx;"
		"roll $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the system is running in a hypervisor (always 0 on a real CPU, but also with some hypervisors) */
LIB_FUNC int is_hypervisor_aval(void) {
	register int truth_val;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%edx;"
		"roll $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `fsgsbase` */
LIB_FUNC int is_fsgsbase_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `IA32_TSC_ADJUST` */
LIB_FUNC int is_ia32_tsc_adjust_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%ebx;"
		"sarl $1,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sgx` (Software Guard Extensions) */
LIB_FUNC int is_sgx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%ebx;"
		"sarl $2,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `bmi1` (Bit Manipulation Instruction Set 1) */
LIB_FUNC int is_bmi1_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%ebx;"
		"sarl $3,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `hle` (Bit Manipulation Instruction Set 1) */
LIB_FUNC int is_hle_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%ebx;"
		"sarl $4,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx2` (Advanced Vector Extensions 2) */
LIB_FUNC int is_avx2_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%ebx;"
		"sarl $5,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `smep` (Supervisor-Mode Execution Prevention) */
LIB_FUNC int is_smep_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%ebx;"
		"sarl $7,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `bmi2` (Bit Manipulation Instruction Set 2) */
LIB_FUNC int is_bmi2_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%ebx;"
		"sarl $8,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `erms` (Enhanced REP MOVSB/STOSB) */
LIB_FUNC int is_erms_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%ebx;"
		"sarl $9,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `invpcid` (INVPCID Instruction) */
LIB_FUNC int is_invpcid_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000010000000000,%%ebx;"
		"sarl $10,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `rtm` (Transactional Synchronization Extensions) */
LIB_FUNC int is_rtm_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000100000000000,%%ebx;"
		"sarl $11,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pqm` (Platform Quality of Service Monitoring) */
LIB_FUNC int is_pqm_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%ebx;"
		"sarl $12,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `mpx` (Intel Memory Protection Extensions) */
LIB_FUNC int is_mpx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%ebx;"
		"sarl $14,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pqe` (Platform Quality of Service Enforcement) */
LIB_FUNC int is_pqe_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%ebx;"
		"sarl $15,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512f` (AVX-512) */
LIB_FUNC int is_avx512f_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000010000000000000000,%%ebx;"
		"sarl $16,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512dq` (AVX-512 Doubleword and Quadword Instructions) */
LIB_FUNC int is_avx512dq_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%ebx;"
		"sarl $17,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `rdseed` (RDSEED Instruction) */
LIB_FUNC int is_rdseed_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%ebx;"
		"sarl $18,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `adx` (Intel Multi-Precision Add-Carry Instruction Extensions) */
LIB_FUNC int is_adx_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%ebx;"
		"sarl $19,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `smap` (Supervisor Mode Access Prevention) */
LIB_FUNC int is_smap_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000100000000000000000000,%%ebx;"
		"sarl $20,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512ifma` (AVX-512 Integer Fused Multiply-Add Instructions) */
LIB_FUNC int is_avx512ifma_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%ebx;"
		"sarl $21,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `pcommit` (PCOMMIT Instruction) */
LIB_FUNC int is_pcommit_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%ebx;"
		"sarl $22,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `clflushopt` (CLFLUSHOPT Instruction) */
LIB_FUNC int is_clflushopt_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%ebx;"
		"sarl $23,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `clwb` (CLWB Instruction) */
LIB_FUNC int is_clwb_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%ebx;"
		"sarl $24,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports Intel Processor Trace */
LIB_FUNC int is_processor_trace_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%ebx;"
		"sarl $25,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512pf` (AVX-512 Prefetch Instructions) */
LIB_FUNC int is_avx512pf_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%ebx;"
		"sarl $26,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512er` (AVX-512 Exponential and Reciprocal Instructions) */
LIB_FUNC int is_avx512er_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%ebx;"
		"sarl $27,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512cd` (AVX-512 Conflict Detection Instructions) */
LIB_FUNC int is_avx512cd_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%ebx;"
		"sarl $28,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `sha` (Intel SHA extensions) */
LIB_FUNC int is_sha_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%ebx;"
		"sarl $29,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512bw` (AVX-512 Byte and Word Instructions) */
LIB_FUNC int is_avx512bw_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%ebx;"
		"sarl $30,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512vl` (AVX-512 Vector Length Extensions) */
LIB_FUNC int is_avx512vl_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%ebx;"
		"sarl $31,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `prefetchwt1` (PREFETCHWT1 Instruction) */
LIB_FUNC int is_prefetchwt1_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%ecx;"
		"movl %%ecx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


/** Test if the CPU supports `avx512vbmi` (AVX-512 Vector Bit Manipulation Instructions) */
LIB_FUNC int is_avx512vbmi_aval(void) {
	register int truth_val;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%ecx;"
		"sarl $1,%%ecx;"
		"movl %%ecx,%0;"
		: "=r"(truth_val)
	);
	return truth_val;
}


// GET CPU INFORMATION


/** Get a random number from the rdrand assembly instruction */
LIB_FUNC unsigned long rdrnd(void) {
	if ((is_rdrnd_aval()) == 0) { return (unsigned long)0; }
	register unsigned long rand_num;
	vasm("rdrand %0;" : "=r"(rand_num));
	return rand_num;
}


/** Get the CPU Model */
LIB_FUNC signed int get_cpu_model(void) {
	register signed int model;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000011110000000011110000,%%eax;"
		"shrl $4,%%eax;"
		"xorb %%bl,%%bl;"
		"xchgb %%al,%%bl;"
		"shrl $8,%%eax;"
		"addb %%bl,%%al;"
		"movl %%eax,%0;"
		: "=r"(model)
	);
	return model;
}


/** Get the list of instructions supported by the CPU */
LIB_FUNC unsigned long get_cpu_features(void) {
	register unsigned long features;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"rolq $64,%%rdx;"
		"movq %%rcx,%%rdx;"
		"movq %%rdx,%0;"
		: "=r"(features)
	);
	return features;
}


#endif


/** Test if this library is using BMI2 */
LIB_FUNC int is_bmi2_lib(void) {
	return CPU_BMI2;
}


/** Test if this library is using AVX */
LIB_FUNC int is_avx_lib(void) {
	return CPU_AVX;
}


/** Test if this library is using AVX2 */
LIB_FUNC int is_avx2_lib(void) {
	return CPU_AVX2;
}


/** Test if this library is using XOP */
LIB_FUNC int is_xop_lib(void) {
	return CPU_XOP;
}


/* GENERAL FUNCTIONS */


/** Turn the number to zero in-place */
LIB_FUNC unsigned long long in_place_zero(unsigned long long num) {
	vasm("xor %0,%0;" : "+r"(num) : : );
	return num;
}


/** XOR the two numbers */
LIB_FUNC unsigned long long asm_xor_ull(unsigned long long num1, unsigned long long num2) {
	register unsigned long long xor_num = 0U;
	asm (
		"mov %1,%%rax;"
		"xor %2,%%rax;"
		"mov %%rax,%0;"
		: "=r"(xor_num)
		: "r,i,n"(num1), "r,i,n"(num2)
		:
	);
	return xor_num;
}


// TODO: Add Intel Intrinsics
// #if (CPU_MMX || CPU_SSE2 || defined(INTEL))
// #   include <immintrin.h>
// #endif


#if CPU_MMX  // __MMINTRIN_H <mmintrin.h>

// TODO: Add <mmintrin.h>

#endif


#if CPU_SSE2  // __XMMINTRIN_H <xmmintrin.h>


#define _MM_SHUFFLE(z, y, x, w)   (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))


/** Return the contents of the MXCSR control and status register */
LIB_FUNC unsigned int _mm_getcsr(void) {
	unsigned int retval = 0U;
	vasm("stmxcsr %0;" : "=m"(retval));
	return retval;
}


/** Set the contents of the MXCSR control and status register */
LIB_FUNC void _mm_setcsr(unsigned int val) {
	vasm("ldmxcsr %0;" : : "m"(val));
}


LIB_FUNC __m128 BUILD_SSE _mm_add_ss(__m128 __a, __m128 __b) {
	__a[0] += __b[0];
	return __a;
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_add_ps(__m128 __a, __m128 __b) {
	return __a + __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_sub_ss(__m128 __a, __m128 __b) {
	__a[0] -= __b[0];
	return __a;
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_sub_ps(__m128 __a, __m128 __b) {
	return __a - __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_mul_ss(__m128 __a, __m128 __b) {
	__a[0] *= __b[0];
	return __a;
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_mul_ps(__m128 __a, __m128 __b) {
	return __a * __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_div_ss(__m128 __a, __m128 __b) {
	__a[0] /= __b[0];
	return __a;
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_div_ps(__m128 __a, __m128 __b) {
	return __a / __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_sqrt_ss(__m128 __a) {
	const __m128 __c = __builtin_ia32_sqrtss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_sqrt_ps(__m128 __a) {
	return __builtin_ia32_sqrtps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_rcp_ss(__m128 __a) {
	const __m128 __c = __builtin_ia32_rcpss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_rcp_ps(__m128 __a) {
	return __builtin_ia32_rcpps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_rsqrt_ss(__m128 __a) {
	const __m128 __c = __builtin_ia32_rsqrtss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_rsqrt_ps(__m128 __a) {
	return __builtin_ia32_rsqrtps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_min_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_minss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_min_ps(__m128 __a, __m128 __b) {
	return __builtin_ia32_minps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_max_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_maxss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_max_ps(__m128 __a, __m128 __b) {
	return __builtin_ia32_maxps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_and_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a & (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_andnot_ps(__m128 __a, __m128 __b) {
	return (__m128)(~(__v4si)__a & (__v4si)__b);
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_or_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a | (__v4si)__b);
}


LIB_FUNC MATH_FUNC __m128 BUILD_SSE _mm_xor_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a ^ (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpeq_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpeqss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpeq_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpeqps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmplt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmplt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmple_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpless(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmple_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpleps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpgt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpge_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpleps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpneq_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpneqss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpneq_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpneqps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnlt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnlt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnle_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnless(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnle_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnleps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpngt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltps(__b, __a);
}


#   ifdef COMPILER_CLANG
LIB_FUNC __m128 BUILD_SSE _mm_cmpgt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpltss(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpge_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpless(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpngt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpnltss(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnge_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpnless(__b, __a), 4, 1, 2, 3);
}
#   endif


LIB_FUNC __m128 BUILD_SSE _mm_cmpnge_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnleps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpord_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpordss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpord_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpordps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpunord_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpunordss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpunord_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpunordps(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comieq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comieq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comilt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comilt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comile_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comile(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comigt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comigt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comige_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comige(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comineq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comineq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomieq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomieq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomilt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomilt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomile_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomile(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomigt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomigt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomige_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomige(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomineq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomineq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_cvtss_si32(__m128 __a) {
	return __builtin_ia32_cvtss2si(__a);
}


LIB_FUNC int BUILD_SSE _mm_cvt_ss2si(__m128 __a) {
	return _mm_cvtss_si32(__a);
}


#   ifdef ARCHX86_64
LIB_FUNC long long BUILD_SSE _mm_cvtss_si64(__m128 __a) {
	return __builtin_ia32_cvtss2si64(__a);
}
#   endif


LIB_FUNC __m64 BUILD_SSE _mm_cvtps_pi32(__m128 __a) {
	return (__m64)__builtin_ia32_cvtps2pi(__a);
}


LIB_FUNC __m64 BUILD_SSE _mm_cvt_ps2pi(__m128 __a) {
	return _mm_cvtps_pi32(__a);
}


LIB_FUNC int BUILD_SSE _mm_cvttss_si32(__m128 __a) {
	return (int)__a[0];
}


LIB_FUNC int BUILD_SSE _mm_cvtt_ss2si(__m128 __a) {
	return _mm_cvttss_si32(__a);
}


LIB_FUNC long long BUILD_SSE _mm_cvttss_si64(__m128 __a) {
	return (long long)__a[0];
}


LIB_FUNC __m64 BUILD_SSE _mm_cvttps_pi32(__m128 __a) {
	return (__m64)__builtin_ia32_cvttps2pi(__a);
}


LIB_FUNC __m64 BUILD_SSE _mm_cvtt_ps2pi(__m128 __a) {
	return _mm_cvttps_pi32(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cvtsi32_ss(__m128 __a, int __b) {
	__a[0] = (float)__b;
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_cvt_si2ss(__m128 __a, int __b) {
	return _mm_cvtsi32_ss(__a, __b);
}


#   ifdef ARCHX86_64
LIB_FUNC __m128 BUILD_SSE _mm_cvtsi64_ss(__m128 __a, long long __b) {
	__a[0] = (float)__b;
	return __a;
}
#   endif


LIB_FUNC __m128 BUILD_SSE _mm_cvtpi32_ps(__m128 __a, __m64 __b) {
	return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cvt_pi2ps(__m128 __a, __m64 __b) {
	return _mm_cvtpi32_ps(__a, __b);
}


LIB_FUNC MATH_FUNC float BUILD_SSE _mm_cvtss_f32(__m128 __a) {
	return __a[0];
}


#endif  // __XMMINTRIN_H <xmmintrin.h>


#endif  // X86_EXTENSIONS_SEEN


/* POWERPC INTRINSICS */


#if ((!(defined(_PPU_INTRINSICS_H) || defined(POWERPC_INTRINSICS))) && defined(ARCHPOWERPC))
#define POWERPC_INTRINSICS   (1)
#define _PPU_INTRINSICS_H   (1)
#define SPU_INTRINSICS_H   (1)
#define _SPU_INTRINSICS_H   (1)
#define _SPU_INTRINSICS_H_   (1)
#define VEC_TYPES_H   (1)
#define _VEC_TYPES_H   (1)
#define _VEC_TYPES_H_   (1)


// Vector Datatypes for the SIMD/Vector Multi-media Extension
#define vec_uchar16   attr_vector unsigned char
#define vec_char16   attr_vector signed char
#define vec_bchar16   attr_vector bool char
#define vec_ushort8   attr_vector unsigned short
#define vec_short8   attr_vector signed short
#define vec_bshort8   attr_vector bool short
// TODO: #define vec_pixel8   attr_vector pixel
#define vec_uint4   attr_vector unsigned int
#define vec_int4   attr_vector signed int
#define vec_bint4   attr_vector bool int
#define vec_float4   attr_vector float
#define vec_ullong2   attr_vector bool char
#define vec_llong2   attr_vector bool short
#define vec_double2   attr_vector bool int


/** @defgroup Synergistic_Processing_Unit Synergistic Processing Unit (SPU) Definitions
@{ */  // (FB){

// SPU CHANNEL DEFINES

#define SPU_RdEventStat   0
#define SPU_WrEventMask   1
#define SPU_WrEventAck   2
#define SPU_RdSigNotify1   3
#define SPU_RdSigNotify2   4
#define SPU_WrDec   7
#define SPU_RdDec   8
#define SPU_RdEventMask   11
#define SPU_RdMachStat   13
#define SPU_WrSRR0   14
#define SPU_RdSRR0   15
#define SPU_WrOutMbox   28
#define SPU_RdInMbox   29
#define SPU_WrOutIntrMbox   30


// MFC CHANNEL DEFINES

#define MFC_WrMSSyncReq   9
#define MFC_RdTagMask   12
#define MFC_LSA   16
#define MFC_EAH   17
#define MFC_EAL   18
#define MFC_Size   19
#define MFC_TagID   20
#define MFC_Cmd   21
#define MFC_WrTagMask   22
#define MFC_WrTagUpdate   23
#define MFC_RdTagStat   24
#define MFC_RdListStallStat   25
#define MFC_WrListStallAck   26
#define MFC_RdAtomicStat   27


// BIT FLAG MNEMONICS FOR TEST SPECIAL VALUE

/** Negative denormalized number */
#define SPU_SV_NEG_DENORM   1
/** Positive denormalized number */
#define SPU_SV_POS_DENORM   2
/** Negative zero */
#define SPU_SV_NEG_ZERO   4
/** Positive zero */
#define SPU_SV_POS_ZERO   8
/** Negative infinity */
#define SPU_SV_NEG_INFINITY   0x10
/** Positive infinity */
#define SPU_SV_POS_INFINITY   0x20
/** Not a number */
#define SPU_SV_NAN   0x40

/** @} */  // }


#ifndef __sync
#   define __sync()   vasm("sync;" : : : "memory")
#endif
#define __isync()   vasm("isync;" : : : "memory")
#define __lwsync()   vasm("lwsync;" : : : "memory")
#define __eieio()   vasm("eieio;" : : : "memory")
#define __nop()   vasm("ori 0, 0, 0;" : : : "memory")
#define __cctpl()   vasm("or 1, 1, 1;" : : : "memory")
#define __cctpm()   vasm("or 2, 2, 2;" : : : "memory")
#define __cctph()   vasm("or 3, 3, 3;" : : : "memory")
#define __db8cyc()   vasm("or 28, 28, 28;" : : : "memory")
#define __db10cyc()   vasm("or 29, 29, 29;" : : : "memory")
#define __db12cyc()   vasm("or 30, 30, 30;" : : : "memory")
#define __db16cyc()   vasm("or 31, 31, 31;" : : : "memory")
#define __dcbf(base)   vasm("dcbf %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbz(base)   vasm("dcbz %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbst(base)   vasm("dcbst %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbtst(base)   vasm("dcbtst %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbt(base)   vasm("dcbt %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __icbi(base)   vasm("icbi %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")


LIB_FUNC int mulhw(int a, int b) {
	int result;
	asm ("mulhw %0, %1, %2;"  : "=r"(result) : "r"((int)(a)), "r"((int)(b)));
	return result;
}
#define __mulhw(a, b)   mulhw((a), (b))


LIB_FUNC unsigned int mulhwu(unsigned int a, unsigned int b) {
	unsigned int result;
	asm ("mulhwu %0, %1, %2;" : "=r"(result) : "r"((unsigned int)(a)), "r"((unsigned int)(b)));
	return result;
}
#define __mulhwu(a, b)   mulhwu((a), (b))


#ifdef ARCHPOWERPC64

LIB_FUNC long long mulhd(long long a, long long b) {
	long long result;
	asm ("mulhd %0, %1, %2;" : "=r"(result) : "r"((long long)(a)), "r"((long long)(b)));
	return result;
}
#   define __mulhd(a, b)   mulhd((a), (b))


LIB_FUNC unsigned long long mulhdu(unsigned long long a, unsigned long long b) {
	unsigned long long result;
	asm ("mulhdu %0, %1, %2;" : "=r"(result) : "r"((unsigned long long)(a)), "r"((unsigned long long)(b)));
	return result;
}
#   define __mulhdu(a, b)   mulhdu((a), (b))

#endif


#endif  // POWERPC INTRINSICS


/* BIT-TWIDDLING, BYTESWAP, BITROTATE, & STRING MANIPULATIONS */


#if (!(defined(_BITS_BYTESWAP_H) || defined(BITS_BYTESWAP_H) || defined(_BITSTRING_H_) || defined(_SYS_BITSTRING_H_) || defined(_BITSTRING_H) || defined(_SYS_BITSTRING_H)))  // http://www.cplusplus.com/reference/cstring/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/string.h.html & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/strings.h.html
#define _STRING_H   (1)  // <string.h>
#define _STRING_H_   (1)
#define _STRINGS_H   (1)  // <strings.h>
#define _STRINGS_H_   (1)
#define _DIET_STRING_H_   (1)
#define _BITSTRING_H   (1)  // <bitstring.h>
#define _BITSTRING_H_   (1)
#define _SYS_BITSTRING_H   (1)  // <sys/bitstring.h>
#define _SYS_BITSTRING_H_   (1)
#define _BITROTATE_H   (1)  // <bitrotate.h>
#define _BITROTATE_H_   (1)
#define _GL_BITROTATE_H   (1)
#define _BITS_BYTESWAP_H   (1)  // <bits/byteswap.h>
#define _BITS_BYTESWAP_H_   (1)
#define BITS_BYTESWAP_H   (1)
#define BITS_BYTESWAP_H_   (1)
#define _OS_OSBYTEORDER_H   (1)
#define _OS_OSBYTEORDERI386_H   (1)
#define _OS__OSBYTEORDER_H   (1)
#define _OS__OSBYTEORDERI386_H   (1)
#define _OS_OSBYTEORDERMACHINE_H   (1)
#define BFS_ENDIAN_H   (1)
#define COMMON_UTIL_MEMCPY_H   (1)
#define _COMMON_UTIL_MEMCPY_H   (1)
#define _SYS_BITOPS_H_   (1)
#define _SYS_BITOPS_H   (1)
#define _BITOPS_H_   (1)
#define _BITOPS_H   (1)
#define __ASM_GENERIC_BITOPS_H   (1)
#define __ASM_GENERIC_BITOPS_H_   (1)
#define _ASM_GENERIC_BITOPS_H   (1)
#define _ASM_GENERIC_BITOPS_H_   (1)
#define _ASM_GENERIC_BITOPS_FFS_H_   (1)
#define _ASM_GENERIC_BITOPS___FFS_H_   (1)
#define _ASM_GENERIC_BITOPS_FFZ_H_   (1)
#define _ASM_GENERIC_BITOPS___FFZ_H_   (1)
#define _ASM_GENERIC_BITOPS_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN___FLS_H_   (1)
#define _ASM_GENERIC_BITOPS___FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN_FFS_H_   (1)
#define _ASM_GENERIC_BITOPS_COUNT_ZEROS_H_   (1)
#define _ASM_GENERIC_BITOPS_LE_H_   (1)
#define _GET_ROUNDING_MODE_H   (1)  // <get-rounding-mode.h>
#define _GET_ROUNDING_MODE_H_   (1)
#define GET_ROUNDING_MODE_H   (1)
#define GET_ROUNDING_MODE_H_   (1)
#define SOFT_FP_H   (1)  // <soft-fp.h> & <softfloat-macros.h>
#define SOFT_FP_H_   (1)
#define SOFT_FP_OP_COMMON_H   (1)
#define SOFTFLOAT_H   (1)
#define _SOFTFLOAT_H_   (1)
#define FENV_H   (1)  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fenv.h.html & http://www.cplusplus.com/reference/cfenv/
#define _FENV_H   (1)  // <fenv.h>
#define _FENV_H_   (1)
#define _FENV_LIBC_H   (1)
#define _FENV_LIBC_H_   (1)
#define FENV_PRIVATE_H   (1)
#define FENV_PRIVATE_H_   (1)
#define _FENV_PRIVATE_H_   (1)
#define _LIBM_H   (1)
#define _LIBM_H_   (1)
#define __ZMATH_H   (1)
#define _ZMATH_H   (1)
#define _ZMATH_H_   (1)


// BIT/BYTE SWAPPING

/** @defgroup Bit_and_Byte_Swapping Macros and functions for bit & byte swapping
@{ */  // (FB){

/** Swap the endianness of a byte */
#define byteswap8(x)   ((uint8_t)((x) << (uint8_t)4) | (uint8_t)((x) >> (uint8_t)4))
/** Swap the endianness of a byte */
#define __bswap_8(x)   byteswap8((uint8_t)(x))
/** Swap the endianness of a byte */
#define bswap_8(x)   byteswap8((uint8_t)(x))
/** Swap the endianness of a byte */
#define __swap8gen(x)   byteswap8((x))
/** Swap the endianness of a byte */
#define __swap8(x)   byteswap8((x))
/** Swap the order of all of the bytes in a 8-bit unit */
#define __bswap_constant_8(x)   byteswap8((x))
/** Swap the order of all of the bytes in a 8-bit unit */
#define __bswap_non_constant_8(x)   byteswap8((x))
#define __swab8(x)   byteswap8((x))
#define _OSSwapInt8(x)   byteswap8((x))

/** Swap the order of all of the bytes in a 16-bit unit */
LIB_FUNC ATTR_CF uint16_t bswap16(const uint16_t __bsx) {
#ifdef ARCHITANIUM
	register uint16_t y, x = (uint16_t)__bsx;
	asm ("shl %0 = %1, 48;" "mux1 %0 = %0, @rev;" : "=r"(y) : "r"(x));
	return y;
#elif defined(ARCHX86)
	register uint16_t y, x = (uint16_t)__bsx;
	asm ("rorw $8, %w0;" : "=r"(y) : "0"(x) : "cc");
	return y;
#elif defined(ARCHS390X)
	register uint16_t y, x = (uint16_t)__bsx;
	asm ("lrvh %0, %1;" : "=&d"(y) : "m"(x));
	return y;
#elif defined(ARCHS390)
	register uint16_t y, x = (uint16_t)__bsx;
	asm ("sr %0, %0;" "la 1, %1;" "icm %0, 2, 1(1);" "ic %0, 0(1);" : "=&d"(y) : "m"(x) : "1");
	return y;
#else
	return (uint16_t)((uint16_t)((__bsx >> 8) & 0xffU) | (uint16_t)((__bsx & 0xffU) << 8));
#endif
}
/** Swap the order of all of the bytes in a 16-bit unit */
#define byteswap16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap16gen(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_constant_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_non_constant_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define B_SWAP_INT16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap_int16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define swap_int16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define bswap_16(x)   ((uint16_t)((((x) >> 8) & 0xffU) | (((x) & 0xffU) << 8)))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __nbcompat_bswap16(x)   ((((x) << 8) & 0xff00U) | (((x) >> 8) & 0xffU))
/** Swap the order of all of the bytes in a 16-bit unit */
#define nbcompat_bswap16(x)   __nbcompat_bswap16((x))
#define __swab16(x)   bswap16((x))
#define _OSSwapInt16(x)   bswap16((x))
#define OSSwapInt16(x)   bswap16((x))
#define __swap16_multi(v, n)   do { register size_t __swap16_multi_n = (n); uint16_t* __swap16_multi_v = (v); while (__swap16_multi_n) { *__swap16_multi_v = bswap16(*__swap16_multi_v); ++__swap16_multi_v; --__swap16_multi_n; } } while (0x0)
#define swap16_multi(v, n)   __swap16_multi((v), (n))

/** Swap the order of all of the bytes in a 32-bit unit */
LIB_FUNC ATTR_CF uint32_t bswap32(const uint32_t __bsx) {
#   ifdef ARCHX86
	register uint32_t x = __bsx;
	vasm("bswap %0;" : "+r,m"(x));
	return x;
#   else
	return ((uint32_t)(((__bsx) & 0xff000000U) >> 0x18U) | (((__bsx) & 0xff0000U) >> 8U) | (((__bsx) & 0xff00U) << 8U) | (((__bsx) & 0xffU) << 0x18U));
#   endif
}
/** Swap the order of all of the bytes in a 32-bit unit */
#define byteswap32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define bswapsi2(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswapsi2(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap32gen(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_constant_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_non_constant_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define B_SWAP_INT32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap_int32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define swap_int32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define bswap_32(x)   ((uint32_t)(((x) & 0xff000000U) >> 0x18U) | (((x) & 0xff0000U) >> 8U) | (((x) & 0xff00U) << 8U) | (((x) & 0xffU) << 0x18U))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __nbcompat_bswap32(x)   ((((x) << 0x18) & 0xff000000) | (((x) << 0x8) & 0xff0000) | (((x) >> 0x8) & 0xff00) | (((x) >> 0x18) & 0xff))
/** Swap the order of all of the bytes in a 32-bit unit */
#define nbcompat_bswap32(x)   __nbcompat_bswap32((x))
#define __swab32(x)   bswap32((x))
#define _OSSwapInt32(x)   bswap32(((uint32_t)(x)))
#define OSSwapInt32(x)   _OSSwapInt32((x))

/** Swap the order of all of the bytes in a 64-bit unit */
LIB_FUNC ATTR_CF uint64_t bswap64(const uint64_t __bsx) {
#   ifdef ARCHX86_64
	register uint64_t x = __bsx;
	asm ("bswap %0;" : "+r"(x));
	return x;
#   elif defined(ARCHX86_32)
	register uint64_t x = __bsx;
	asm ("bswap %%eax;" "bswap %%edx;" "xchgl %%eax, %%edx;" : "+A"(x));
	return x;
#   else
	return ((uint64_t)((((__bsx) & 0xff00000000000000ULL) >> 0x38) | (((__bsx) & 0xff000000000000ULL) >> 0x28) | (((__bsx) & 0xff0000000000ULL) >> 0x18) | (((__bsx) & 0xff00000000ULL) >> 8) | (((__bsx) & 0xff000000ULL) << 8) | (((__bsx) & 0xff0000ULL) << 0x18) | (((__bsx) & 0xff00ULL) << 0x28) | (((__bsx) & 0xffULL) << 0x38)));
#   endif
}
/** Swap the order of all of the bytes in a 64-bit unit */
#define byteswap64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define bswapdi2(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswapdi2(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap64gen(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_constant_64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define B_SWAP_INT64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap_int64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define swap_int64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define bswap_64(x)   ((uint64_t)((((x) & 0xff00000000000000ULL) >> 0x38) | (((x) & 0xff000000000000ULL) >> 0x28) | (((x) & 0xff0000000000ULL) >> 0x18) | (((x) & 0xff00000000ULL) >> 8) | (((x) & 0xff000000ULL) << 8) | (((x) & 0xff0000ULL) << 0x18) | (((x) & 0xff00ULL) << 0x28) | (((x) & 0xffULL) << 0x38)))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_non_constant_64(x)   do { union __union_bswap_non_constant_64 { unsigned long long __ll; unsigned int __l[2]; } __w, __r; __w.__ll = (x); __r.__l[0] = bswap32(__w.__l[1]); __r.__l[1] = bswap32(__w.__l[0]); __r.__ll; } while (0x0)
/** Swap the order of all of the bytes in a 64-bit unit */
#define __nbcompat_bswap64(x)   (((uint64_t)bswap32((x)) << 0x20) | ((uint64_t)bswap32((x) >> 0x20)))
/** Swap the order of all of the bytes in a 64-bit unit */
#define nbcompat_bswap64(x)   __nbcompat_bswap64((x))
#define __swab64(x)   bswap64((x))
#define _OSSwapInt64(x)   bswap64(((uint64_t)x))
#define OSSwapInt64(x)   _OSSwapInt64((x))


LIB_FUNC ATTR_CF uint32_t byteswap_uint32_t(const uint32_t data_word, const char should_swap) {
	if (!should_swap) { return data_word; }
	union word_union {
		uint32_t full_word;
		unsigned char bytes[4];
	} old, neww;
	old.full_word = data_word;
	neww.bytes[0] = old.bytes[3];
	neww.bytes[1] = old.bytes[2];
	neww.bytes[2] = old.bytes[1];
	neww.bytes[3] = old.bytes[0];
	return neww.full_word;
}


LIB_FUNC ATTR_CF float swap_float(const float x) {
	const uint32_t temp1 = (uint32_t)x;
	const uint32_t temp2 = (uint32_t)((temp1 >> 24) | ((temp1 >> 8) & 0xff00) | ((temp1 << 8) & 0xff0000) | (temp1 << 24));
	return (float)temp2;
}
#define swap_float_(x)   swap_float((x))
#define __swap_float(x)   swap_float((x))
#define _swap_float_(x)   swap_float((x))
#define _swap_float(x)   swap_float((x))
#define B_SWAP_FLOAT(x)    swap_float((x))


LIB_FUNC ATTR_CF float byteswap_float(const float data_word, const char should_swap) {
	if (!should_swap) { return data_word; }
	union word_union {
		float full_word;
		unsigned char bytes[4];
	} old, neww;
	old.full_word = data_word;
	neww.bytes[0] = old.bytes[3];
	neww.bytes[1] = old.bytes[2];
	neww.bytes[2] = old.bytes[1];
	neww.bytes[3] = old.bytes[0];
	return neww.full_word;
}


LIB_FUNC ATTR_CF double swap_double(const double x) {
	const uint64_t num = DBL_TO_U64(x);
	const double ret = U64_TO_DBL(bswap64(num));
	return ret;
}
#define swap_double_(x)   swap_double((x))
#define __swap_double(x)   swap_double((x))
#define _swap_double_(x)   swap_double((x))
#define _swap_double(x)   swap_double((x))
#define B_SWAP_DOUBLE(x)    swap_double((x))


LIB_FUNC void swap_copy(short* restrict dest, const short* restrict src, int c) {
	register unsigned short sh = 0;
	while (c > 1) {
		sh = (unsigned short)*(src++);
		*(dest++) = (short)((sh << 8) | (sh >> 8));
		c -= 2;
	}
}


/** Encode 16-bits of data in Big-Endian */
LIB_FUNC void be16enc(void* dest, const uint16_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)((u >> 8) & 0xff);
	p[1] = (unsigned char)(u & 0xff);
}


/** Encode 32-bits of data in Big-Endian */
LIB_FUNC void be32enc(void* dest, const uint32_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)((u >> 24) & 0xff);
	p[1] = (unsigned char)((u >> 16) & 0xff);
	p[2] = (unsigned char)((u >> 8) & 0xff);
	p[3] = (unsigned char)(u & 0xff);
}


/** Encode 64-bits of data in Big-Endian */
LIB_FUNC void be64enc(void* dest, const uint64_t u) {
	unsigned char* p = (unsigned char*)dest;
	be32enc(p, ((uint32_t)(u >> 32)));
	be32enc((p + 4), ((uint32_t)(u & UINT32_MAX)));
}


/** Encode 16-bits of data in Little-Endian */
LIB_FUNC void le16enc(void* dest, const uint16_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)(u & 0xff);
	p[1] = (unsigned char)((u >> 8) & 0xff);
}


/** Encode 32-bits of data in Little-Endian */
LIB_FUNC void le32enc(void* dest, const uint32_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)(u & 0xff);
	p[1] = (unsigned char)((u >> 8) & 0xff);
	p[2] = (unsigned char)((u >> 16) & 0xff);
	p[3] = (unsigned char)((u >> 24) & 0xff);
}


/** Encode 64-bits of data in Little-Endian */
LIB_FUNC void le64enc(void* dest, const uint64_t u) {
	unsigned char* p = (unsigned char*)dest;
	le32enc(p, ((uint32_t)(u & UINT32_MAX)));
	le32enc((p + 4), ((uint32_t)(u >> 32)));
}


/** Decode 16-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint16_t be16dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint16_t)((uint16_t)(p[0] << 8) | (uint16_t)p[1]);
}


/** Decode 32-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint32_t be32dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint32_t)((uint32_t)(p[0] << 24) | (uint32_t)(p[1] << 16) | (uint32_t)(p[2] << 8) | (uint32_t)p[3]);
}


/** Decode 64-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint64_t be64dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint64_t)(((uint64_t)be32dec(p) << 32) | (uint64_t)be32dec(p + 4));
}


/** Decode 16-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint16_t le16dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint16_t)((uint16_t)(p[1] << 8) | (uint16_t)p[0]);
}


/** Decode 32-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint32_t le32dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint32_t)((uint32_t)(p[3] << 24) | (uint32_t)(p[2] << 16) | (uint32_t)(p[1] << 8) | (uint32_t)p[0]);
}


/** Decode 64-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint64_t le64dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint64_t)(((uint64_t)le32dec(p + 4) << 32) | (uint64_t)le32dec(p));
}


#define HAVE_DECL_ENC16BE   1
#define HAVE_DECL_ENC32BE   1
#define HAVE_DECL_ENC64BE   1
#define HAVE_DECL_ENC16LE   1
#define HAVE_DECL_ENC32LE   1
#define HAVE_DECL_ENC64LE   1
#define HAVE_DECL_BE16DEC   1
#define HAVE_DECL_BE32DEC   1
#define HAVE_DECL_BE64DEC   1
#define HAVE_DECL_LE16DEC   1
#define HAVE_DECL_LE32DEC   1
#define HAVE_DECL_LE64DEC   1


// BYTE REVERSED LOADS

LIB_FUNC uint16_t OSReadSwapInt16(const volatile void* base, const uintptr_t byteOffset) {
	uint16_t data = *(volatile uint16_t*)((uintptr_t)base + byteOffset);
	return bswap16(data);
}
#define _OSReadSwapInt16(base, bytebyteOffset)   OSReadSwapInt16((base), (bytebyteOffset))


LIB_FUNC uint32_t OSReadSwapInt32(const volatile void* base, const uintptr_t byteOffset) {
	uint32_t data = *(volatile uint32_t*)((uintptr_t)base + byteOffset);
	return bswap32(data);
}
#define _OSReadSwapInt32(base, bytebyteOffset)   OSReadSwapInt32((base), (bytebyteOffset))


LIB_FUNC uint64_t OSReadSwapInt64(const volatile void* base, const uintptr_t byteOffset) {
	uint64_t data = *(volatile uint64_t*)((uintptr_t)base + byteOffset);
	return bswap64(data);
}
#define _OSReadSwapInt64(base, bytebyteOffset)   OSReadSwapInt64((base), (bytebyteOffset))


// BYTE REVERSED STORES

LIB_FUNC void OSWriteSwapInt16(volatile void* base, const uintptr_t byteOffset, const uint16_t data) {
	(*(volatile uint16_t*)((uintptr_t)base + byteOffset) = bswap16(data));
}
#define _OSWriteSwapInt16(base, bytebyteOffset, data)   OSWriteSwapInt16((base), (bytebyteOffset), (data))


LIB_FUNC void OSWriteSwapInt32(volatile void* base, const uintptr_t byteOffset, const uint32_t data) {
	(*(volatile uint32_t*)((uintptr_t)base + byteOffset) = bswap32(data));
}
#define _OSWriteSwapInt32(base, bytebyteOffset, data)   OSWriteSwapInt32((base), (bytebyteOffset), (data))


LIB_FUNC void OSWriteSwapInt64(volatile void* base, const uintptr_t byteOffset, const uint64_t data) {
	(*(volatile uint64_t*)((uintptr_t)base + byteOffset) = bswap64(data));
}
#define _OSWriteSwapInt64(base, bytebyteOffset, data)   OSWriteSwapInt64((base), (bytebyteOffset), (data))


// BIT/BYTE SWAPPING MACROS ALIASES

#if IS_BIG_ENDIAN
#   define htobe16(x)   (x)
#   define htole16(x)   bswap16((x))
#   define be16toh(x)   (x)
#   define le16toh(x)   bswap16((x))
#   define htobe32(x)   (x)
#   define htole32(x)   bswap32((x))
#   define be32toh(x)   (x)
#   define le32toh(x)   bswap32((x))
#   define htobe64(x)   (x)
#   define htole64(x)   bswap64((x))
#   define be64toh(x)   (x)
#   define le64toh(x)   bswap64((x))
#   define ntohl(x)   ((uint32_t)(x))
#   define htonl(x)   ((uint32_t)(x))
#   define htons(x)   ((uint16_t)(x))
#   define ntohll(x)   ((uint64_t)(x))
#   define htonll(x)   ((uint64_t)(x))
#   define NTOHL(x)   (x)
#   define NTOHS(x)   (x)
#   define NTOHLL(x)   (x)
#   define HTONL(x)   (x)
#   define HTONS(x)   (x)
#   define HTONLL(x)   (x)
#   define EndianS16_BtoN(x)   (x)
#   define EndianS16_NtoB(x)   (x)
#   define EndianU16_BtoN(x)   (x)
#   define EndianU16_NtoB(x)   (x)
#   define EndianS32_BtoN(x)   (x)
#   define EndianS32_NtoB(x)   (x)
#   define EndianU32_BtoN(x)   (x)
#   define EndianU32_NtoB(x)   (x)
#   define EndianS64_BtoN(x)   (x)
#   define EndianS64_NtoB(x)   (x)
#   define EndianU64_BtoN(x)   (x)
#   define EndianU64_NtoB(x)   (x)
#   define ntohq(x)   (x)
#   define htonq(x)   (x)
#   define B_HOST_TO_LENDIAN_DOUBLE(arg)   swap_double(arg)
#   define B_HOST_TO_LENDIAN_FLOAT(arg)   swap_float(arg)
#   define B_HOST_TO_LENDIAN_INT64(arg)   bswap64(arg)
#   define B_HOST_TO_LENDIAN_INT32(arg)   bswap32(arg)
#   define B_HOST_TO_LENDIAN_INT16(arg)   bswap16(arg)
#   define B_LENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define B_LENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define B_LENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define B_LENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define B_LENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#   define B_HOST_TO_BENDIAN_DOUBLE(arg)   (double)(arg)
#   define B_HOST_TO_BENDIAN_FLOAT(arg)   (float)(arg)
#   define B_HOST_TO_BENDIAN_INT64(arg)   (uint64_t)(arg)
#   define B_HOST_TO_BENDIAN_INT32(arg)   (uint32_t)(arg)
#   define B_HOST_TO_BENDIAN_INT16(arg)   (uint16_t)(arg)
#   define B_BENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define B_BENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define B_BENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define B_BENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define B_BENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define OSReadBigInt16(base, byteOffset)   OSReadInt16(base, byteOffset)
#   define OSReadBigInt32(base, byteOffset)   OSReadInt32(base, byteOffset)
#   define OSReadBigInt64(base, byteOffset)   OSReadInt64(base, byteOffset)
#   define OSWriteBigInt16(base, byteOffset, data)   OSWriteInt16(base, byteOffset, data)
#   define OSWriteBigInt32(base, byteOffset, data)   OSWriteInt32(base, byteOffset, data)
#   define OSWriteBigInt64(base, byteOffset, data)   OSWriteInt64(base, byteOffset, data)
#   define OSReadLittleInt16(base, byteOffset)   OSReadSwapInt16(base, byteOffset)
#   define OSReadLittleInt32(base, byteOffset)   OSReadSwapInt32(base, byteOffset)
#   define OSReadLittleInt64(base, byteOffset)   OSReadSwapInt64(base, byteOffset)
#   define OSWriteLittleInt16(base, byteOffset, data)   OSWriteSwapInt16(base, byteOffset, data)
#   define OSWriteLittleInt32(base, byteOffset, data)   OSWriteSwapInt32(base, byteOffset, data)
#   define OSWriteLittleInt64(base, byteOffset, data)   OSWriteSwapInt64(base, byteOffset, data)
#   define OSSwapHostToBigConstInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToBigConstInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToBigConstInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToBigInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToBigInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToBigInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToLittleConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapHostToLittleConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapHostToLittleConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapHostToLittleInt16(x)   OSSwapInt16(x)
#   define OSSwapHostToLittleInt32(x)   OSSwapInt32(x)
#   define OSSwapHostToLittleInt64(x)   OSSwapInt64(x)
#   define OSSwapBigToHostConstInt16(x)   ((uint16_t)(x))
#   define OSSwapBigToHostConstInt32(x)   ((uint32_t)(x))
#   define OSSwapBigToHostConstInt64(x)   ((uint64_t)(x))
#   define OSSwapBigToHostInt16(x)   ((uint16_t)(x))
#   define OSSwapBigToHostInt32(x)   ((uint32_t)(x))
#   define OSSwapBigToHostInt64(x)   ((uint64_t)(x))
#   define OSSwapLittleToHostConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapLittleToHostConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapLittleToHostConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapLittleToHostInt16(x)   OSSwapInt16(x)
#   define OSSwapLittleToHostInt32(x)   OSSwapInt32(x)
#   define OSSwapLittleToHostInt64(x)   OSSwapInt64(x)
#elif IS_LITTLE_ENDIAN
#   define htobe16(x)   bswap16((x))
#   define htole16(x)   (x)
#   define be16toh(x)   bswap16((x))
#   define le16toh(x)   (x)
#   define htobe32(x)   bswap32((x))
#   define htole32(x)   (x)
#   define be32toh(x)   bswap32((x))
#   define le32toh(x)   (x)
#   define htobe64(x)   bswap64((x))
#   define htole64(x)   (x)
#   define be64toh(x)   bswap64((x))
#   define le64toh(x)   (x)
#   define htons(x)   bswap16((x))
#   define ntohl(x)   bswap32((x))
#   define htonl(x)   bswap32((x))
#   define ntohll(x)   bswap64((x))
#   define htonll(x)   bswap64((x))
#   define NTOHL(x)   bswap32((x))
#   define NTOHS(x)   bswap16((x))
#   define NTOHLL(x)   bswap64((x))
#   define HTONL(x)   bswap32((x))
#   define HTONS(x)   bswap16((x))
#   define HTONLL(x)   bswap64((x))
#   define EndianS16_LtoN(x)   (x)
#   define EndianS16_NtoL(x)   (x)
#   define EndianU16_LtoN(x)   (x)
#   define EndianU16_NtoL(x)   (x)
#   define EndianS32_LtoN(x)   (x)
#   define EndianS32_NtoL(x)   (x)
#   define EndianU32_LtoN(x)   (x)
#   define EndianU32_NtoL(x)   (x)
#   define EndianS64_LtoN(x)   (x)
#   define EndianS64_NtoL(x)   (x)
#   define EndianU64_LtoN(x)   (x)
#   define EndianU64_NtoL(x)   (x)
#   define ntohq(x)   bswap64((x))
#   define htonq(x)   bswap64((x))
#   define B_HOST_TO_LENDIAN_DOUBLE(arg)   (double)(arg)
#   define B_HOST_TO_LENDIAN_FLOAT(arg)   (float)(arg)
#   define B_HOST_TO_LENDIAN_INT64(arg)   (uint64_t)(arg)
#   define B_HOST_TO_LENDIAN_INT32(arg)   (uint32_t)(arg)
#   define B_HOST_TO_LENDIAN_INT16(arg)   (uint16_t)(arg)
#   define B_LENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define B_LENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define B_LENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define B_LENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define B_LENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define B_HOST_TO_BENDIAN_DOUBLE(arg)   swap_double(arg)
#   define B_HOST_TO_BENDIAN_FLOAT(arg)   swap_float(arg)
#   define B_HOST_TO_BENDIAN_INT64(arg)   bswap64(arg)
#   define B_HOST_TO_BENDIAN_INT32(arg)   bswap32(arg)
#   define B_HOST_TO_BENDIAN_INT16(arg)   bswap16(arg)
#   define B_BENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define B_BENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define B_BENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define B_BENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define B_BENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#   define OSReadBigInt16(base, byteOffset)   OSReadSwapInt16(base, byteOffset)
#   define OSReadBigInt32(base, byteOffset)   OSReadSwapInt32(base, byteOffset)
#   define OSReadBigInt64(base, byteOffset)   OSReadSwapInt64(base, byteOffset)
#   define OSWriteBigInt16(base, byteOffset, data)   OSWriteSwapInt16(base, byteOffset, data)
#   define OSWriteBigInt32(base, byteOffset, data)   OSWriteSwapInt32(base, byteOffset, data)
#   define OSWriteBigInt64(base, byteOffset, data)   OSWriteSwapInt64(base, byteOffset, data)
#   define OSReadLittleInt16(base, byteOffset)   OSReadInt16(base, byteOffset)
#   define OSReadLittleInt32(base, byteOffset)   OSReadInt32(base, byteOffset)
#   define OSReadLittleInt64(base, byteOffset)   OSReadInt64(base, byteOffset)
#   define OSWriteLittleInt16(base, byteOffset, data)   OSWriteInt16(base, byteOffset, data)
#   define OSWriteLittleInt32(base, byteOffset, data)   OSWriteInt32(base, byteOffset, data)
#   define OSWriteLittleInt64(base, byteOffset, data)   OSWriteInt64(base, byteOffset, data)
#   define OSSwapHostToBigConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapHostToBigConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapHostToBigConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapHostToBigInt16(x)   OSSwapInt16(x)
#   define OSSwapHostToBigInt32(x)   OSSwapInt32(x)
#   define OSSwapHostToBigInt64(x)   OSSwapInt64(x)
#   define OSSwapHostToLittleConstInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToLittleConstInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToLittleConstInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToLittleInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToLittleInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToLittleInt64(x)   ((uint64_t)(x))
#   define OSSwapBigToHostConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapBigToHostConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapBigToHostConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapBigToHostInt16(x)   OSSwapInt16(x)
#   define OSSwapBigToHostInt32(x)   OSSwapInt32(x)
#   define OSSwapBigToHostInt64(x)   OSSwapInt64(x)
#   define OSSwapLittleToHostConstInt16(x)   ((uint16_t)(x))
#   define OSSwapLittleToHostConstInt32(x)   ((uint32_t)(x))
#   define OSSwapLittleToHostConstInt64(x)   ((uint64_t)(x))
#   define OSSwapLittleToHostInt16(x)   ((uint16_t)(x))
#   define OSSwapLittleToHostInt32(x)   ((uint32_t)(x))
#   define OSSwapLittleToHostInt64(x)   ((uint64_t)(x))
#else
#   error   "Unknown endianess (OSSwap* Functions)!"
#endif
#define OSReadBigInt(x, y)   OSReadBigInt32(x, y)
#define OSWriteBigInt(x, y, z)   OSWriteBigInt32(x, y, z)
#define OSSwapBigToHostInt(x)   OSSwapBigToHostInt32(x)
#define OSSwapHostToBigInt(x)   OSSwapHostToBigInt32(x)
#define OSReadLittleInt(x, y)   OSReadLittleInt32(x, y)
#define OSWriteLittleInt(x, y, z)   OSWriteLittleInt32(x, y, z)
#define OSSwapHostToLittleInt(x)   OSSwapHostToLittleInt32(x)
#define OSSwapLittleToHostInt(x)   OSSwapLittleToHostInt32(x)
#ifndef B_HOST_TO_BENDIAN_INT32
#   define B_HOST_TO_BENDIAN_INT32(x)   htonl((x))
#   define B_BENDIAN_TO_HOST_INT32(x)   ntohl((x))
#   define B_HOST_TO_BENDIAN_INT16(x)   htons((x))
#   define B_BENDIAN_TO_HOST_INT16(x)   ntohs((x))
#endif
#if ((defined(BFS_LITTLE_ENDIAN_ONLY) && B_HOST_IS_LENDIAN) || (defined(BFS_BIG_ENDIAN_ONLY) && B_HOST_IS_BENDIAN))
#   define BFS_NATIVE_ENDIAN
#   define BFS_ENDIAN_TO_HOST_INT16(value)   value
#   define BFS_ENDIAN_TO_HOST_INT32(value)   value
#   define BFS_ENDIAN_TO_HOST_INT64(value)   value
#   define HOST_ENDIAN_TO_BFS_INT16(value)   value
#   define HOST_ENDIAN_TO_BFS_INT32(value)   value
#   define HOST_ENDIAN_TO_BFS_INT64(value)   value
#elif (defined(BFS_LITTLE_ENDIAN_ONLY) && B_HOST_IS_BENDIAN) || (defined(BFS_BIG_ENDIAN_ONLY) && B_HOST_IS_LENDIAN)
#   define BFS_ENDIAN_TO_HOST_INT16(value)   bswap16((value))
#   define BFS_ENDIAN_TO_HOST_INT32(value)   bswap32((value))
#   define BFS_ENDIAN_TO_HOST_INT64(value)   bswap64((value))
#   define HOST_ENDIAN_TO_BFS_INT16(value)   bswap16((value))
#   define HOST_ENDIAN_TO_BFS_INT32(value)   bswap32((value))
#   define HOST_ENDIAN_TO_BFS_INT64(value)   bswap64((value))
#endif

/** @} */  // }


// INTERLEAVING

/** @defgroup Integer_Interleaving Functions for interleaving integers
@{ */  // (FB){

LIB_FUNC MATH_FUNC uint16_t interleave8(const uint8_t x, const uint8_t y) {
	register uint16_t z = 0;
	for (register uint16_t i = 0; i < 8; i++) {
		z |= (uint16_t)(((x & ((uint16_t)1 << i)) << i) | ((y & ((uint16_t)1 << i)) << (i + 1)));
	}
	return z;
}


LIB_FUNC MATH_FUNC uint32_t interleave16(const uint16_t x, const uint16_t y) {
	register uint32_t z = 0;
	for (register uint32_t i = 0; i < 16; i++) {
		z |= (uint32_t)(((x & ((uint32_t)1 << i)) << i) | ((y & ((uint32_t)1 << i)) << (i + 1)));
	}
	return z;
}


LIB_FUNC MATH_FUNC uint64_t interleave32(const uint32_t x, const uint32_t y) {
	register uint64_t z = 0;
	for (register uint32_t i = 0; i < 32; i++) {
		z |= (uint64_t)(((x & ((uint64_t)1 << i)) << i) | ((y & ((uint64_t)1 << i)) << (i + 1)));
	}
	return z;
}

/** @} */  // }


// ENDIAN MANIPULATION

/** @defgroup Endian_Manipulation Functions and macros for manipulating data endianness
@{ */  // (FB){


// LOADING ENDIAN VALUES

/** Reads a 16-bit integer in big-endian order */
#define READ_UINT16(p)   ((((uint32_t)(p)[0]) << 8) | ((uint32_t)(p)[1]))

/** Reads a 16-bit integer in little-endian order */
#define LE_READ_UINT16(p)   ((((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[0]))

/** Reads a 24-bit integer in big-endian order */
#define READ_UINT24(p)   ((((uint32_t)(p)[0]) << 16) | (((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[2]))

/** Reads a 32-bit integer in big-endian order */
#define READ_UINT32(p)   ((((uint32_t)(p)[0]) << 24) | (((uint32_t)(p)[1]) << 16) | (((uint32_t)(p)[2]) << 8) | ((uint32_t)(p)[3]))

/** Reads a 32-bit integer in little-endian order */
#define LE_READ_UINT32(p)   ((((uint32_t)(p)[3]) << 24) | (((uint32_t)(p)[2]) << 16) | (((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[0]))

/** Reads a 64-bit integer in big-endian order */
#define READ_UINT64(p)   ((((uint64_t)(p)[0]) << 56) | (((uint64_t)(p)[1]) << 48) | (((uint64_t)(p)[2]) << 40) | (((uint64_t)(p)[3]) << 32) | (((uint64_t)(p)[4]) << 24) | (((uint64_t)(p)[5]) << 16) | (((uint64_t)(p)[6]) << 8) | ((uint64_t)(p)[7]))

/** Reads a 64-bit integer in little-endian order */
#define LE_READ_UINT64(p)   ((((uint64_t)(p)[7]) << 56) | (((uint64_t)(p)[6]) << 48) | (((uint64_t)(p)[5]) << 40) | (((uint64_t)(p)[4]) << 32) | (((uint64_t)(p)[3]) << 24) | (((uint64_t)(p)[2]) << 16) | (((uint64_t)(p)[1]) << 8) | ((uint64_t)(p)[0]))


LIB_FUNC uint32_t getle32(void* v) {
	unsigned char* p = (unsigned char*)v;
	return ((uint32_t)(p[3] << 24) | (uint32_t)(p[2] << 16) | (uint32_t)(p[1] << 8) | (uint32_t)p[0]);
}


LIB_FUNC uint16_t OSReadInt16(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint16_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt16(base, bytebyteOffset)   OSReadInt16((base), (bytebyteOffset))


LIB_FUNC uint32_t OSReadInt32(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint32_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt32(base, bytebyteOffset)   OSReadInt32((base), (bytebyteOffset))


LIB_FUNC uint64_t OSReadInt64(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint64_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt64(base, bytebyteOffset)   OSReadInt64((base), (bytebyteOffset))


// STORING ENDIAN VALUES

/** Writes a 16-bit integer in big-endian order */
#define WRITE_UINT16(p, i)   do { (p)[0] = ((i) >> 8) & 0xff; (p)[1] = (i) & 0xff; } while (0x0)

/** Writes a 16-bit integer in little-endian order */
#define LE_WRITE_UINT16(p, i)   do { (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)

/** Writes a 24-bit integer in big-endian order */
#define WRITE_UINT24(p, i)   do { (p)[0] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[2] = (i) & 0xff; } while (0x0)

/** Writes a 32-bit integer in big-endian order */
#define WRITE_UINT32(p, i)   do { (p)[0] = ((i) >> 24) & 0xff; (p)[1] = ((i) >> 16) & 0xff; (p)[2] = ((i) >> 8) & 0xff; (p)[3] = (i) & 0xff; } while (0x0)

/** Writes a 32-bit integer in little-endian order */
#define LE_WRITE_UINT32(p, i)   do { (p)[3] = ((i) >> 24) & 0xff; (p)[2] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)

/** Writes a 64-bit integer in big-endian order */
#define WRITE_UINT64(p, i)   do { (p)[0] = ((i) >> 56) & 0xff; (p)[1] = ((i) >> 48) & 0xff; (p)[2] = ((i) >> 40) & 0xff; (p)[3] = ((i) >> 32) & 0xff; (p)[4] = ((i) >> 24) & 0xff; (p)[5] = ((i) >> 16) & 0xff; (p)[6] = ((i) >> 8) & 0xff; (p)[7] = (i) & 0xff; } while (0x0)

/** Writes a 64-bit integer in little-endian order */
#define LE_WRITE_UINT64(p, i)   do { (p)[7] = ((i) >> 56) & 0xff; (p)[6] = ((i) >> 48) & 0xff; (p)[5] = ((i) >> 40) & 0xff; (p)[4] = ((i) >> 32) & 0xff; (p)[3] = ((i) >> 24) & 0xff; (p)[2] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)


LIB_FUNC void putle32(void* v, const uint32_t i) {
	unsigned char* p = (unsigned char*)v;
	p[0] = (unsigned char)i;
	p[1] = (unsigned char)(i >> 8);
	p[2] = (unsigned char)(i >> 16);
	p[3] = (unsigned char)(i >> 24);
}


LIB_FUNC void OSWriteInt16(volatile void* base, const uintptr_t byteOffset, const uint16_t data) {
	(*(volatile uint16_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt16(base, bytebyteOffset, data)   OSWriteInt16((base), (bytebyteOffset), (data))


LIB_FUNC void _OSWriteInt32(volatile void* base, const uintptr_t byteOffset, const uint32_t data) {
	(*(volatile uint32_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt32(base, bytebyteOffset, data)   OSWriteInt32((base), (bytebyteOffset), (data))


LIB_FUNC void _OSWriteInt64(volatile void* base, const uintptr_t byteOffset, const uint64_t data) {
	(*(volatile uint64_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt64(base, bytebyteOffset, data)   OSWriteInt64((base), (bytebyteOffset), (data))

/** @} */  // }


// WINDOWS MACROS

#define MAKEWORD(bLow, bHigh)   ((uint16_t)(((uint8_t)((DWORD_PTR)(bLow) & 0xff)) | (((uint16_t)((uint8_t)((DWORD_PTR)(bHigh) & 0xff))) << 8)))
#define MAKELONG(wLow, wHigh)   ((uint32_t)(((uint16_t)((DWORD_PTR)(wLow) & UINT16_MAX)) | (((uint32_t)((uint16_t)((DWORD_PTR)(wHigh) & UINT16_MAX))) << 16)))
#define LOWORD(l)   ((uint16_t)((DWORD_PTR)(l) & UINT16_MAX))
#define HIWORD(l)   ((uint16_t)(((DWORD_PTR)(l) >> 16) & UINT16_MAX))
#define LOBYTE(w)   ((uint8_t)((DWORD_PTR)(w) & 0xff))
#define HIBYTE(w)   ((uint8_t)(((DWORD_PTR)(w) >> 8) & 0xff))


// ROTATIONS

/** @defgroup Data_Rotations Functions and macros used to rotate the bits of various datatypes
@{ */  // (FB){


/** Rotate the the 32-bit value to the left `n` number of times */
#define ROTL32(n, x)   (((x) << (n)) | ((x) >> ((-(n) & 31))))
/** Rotate the the 64-bit value to the left `n` number of times */
#define ROTL64(n, x)   (((x) << (n)) | ((x) >> ((-(n)) & 63)))


/** Given an unsigned 64-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the left; `n` must be between 1 and 63 inclusive */
LIB_FUNC ATTR_CF uint64_t rotl64(const uint64_t x, const int n) {
#   if (defined(ARCHX86) && CPU_AVX512F)
	uint64_t res;
	asm ("prolq %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif defined(ARCHX86)
	uint64_t res = x;
	asm ("rolq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint64_t)(((x << n) | (x >> (64 - n))) & (uint64_t)UINT64_MAX);
#endif
}


/** Given an unsigned 64-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the right; `n` must be between 1 to 63 inclusive */
LIB_FUNC ATTR_CF uint64_t rotr64(const uint64_t x, const int n) {
#   if (defined(ARCHX86) && CPU_BMI2)
	uint64_t res;
	asm ("rorx %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif (defined(ARCHX86) && CPU_AVX512F)
	uint64_t res;
	asm ("prorq %1, %2, %0;" : "=X"(res) : "x"(n), "X"(x));
	return res;
#   elif defined(ARCHX86)
	uint64_t res = x;
	asm ("rorq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint64_t)(((x >> n) | (x << (64 - n))) & (uint64_t)UINT64_MAX);
#endif
}


/** Given an unsigned 32-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the left; `n` must be between 1 and 31 inclusive */
LIB_FUNC ATTR_CF uint32_t rotl32(const uint32_t x, const int n) {
#   if (defined(ARCHX86) && CPU_AVX512F)
	uint32_t res;
	asm ("prold %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif defined(ARCHX86)
	uint32_t res = x;
	asm ("rold %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint32_t)(((x << n) | (x >> (32 - n))) & UINT32_MAX);
#endif
}


/** Given an unsigned 32-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the right; `n` must be between 1 to 31 inclusive */
LIB_FUNC ATTR_CF uint32_t rotr32(const uint32_t x, const int n) {
#   if (defined(ARCHX86) && CPU_AVX512F)
	uint32_t res;
	asm ("prord %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif defined(ARCHX86)
	uint32_t res = x;
	asm ("rord %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint32_t)(((x >> n) | (x << (32 - n))) & UINT32_MAX);
#endif
}


/** Given an unsigned 16-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the left; `n` must be between 1 to 15 inclusive, but on most relevant targets `n` can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint16_t rotl16(const uint16_t x, const int n) {
#if defined(ARCHX86)
	uint16_t res = x;
	asm ("rol %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint16_t)(((uint16_t)(x << n) | (uint16_t)(x >> (16 - n))) & (uint16_t)UINT16_MAX);
#endif
}


/** Given an unsigned 16-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the right; `n` must be in 1 to 15 inclusive, but on most relevant targets `n` can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint16_t rotr16(const uint16_t x, const int n) {
#if defined(ARCHX86)
	uint16_t res = x;
	asm ("ror %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint16_t)(((uint16_t)(x >> n) | (uint16_t)(x << (16 - n))) & (uint16_t)UINT16_MAX);
#endif
}


/** Given an unsigned 8-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the left; `n` must be between 1 to 7 inclusive, but on most relevant targets `n` can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint8_t rotl8(const uint8_t x, const int n) {
#if defined(ARCHX86)
	uint8_t res = x;
	asm ("rolb %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint8_t)(((uint8_t)(x << n) | (uint8_t)(x >> (8 - n))) & 0xffU);
#endif
}


/** Given an unsigned 8-bit argument `x`, return the value corresponding to rotating the bits `n` steps to the right; `n` must be in 1 to 7 inclusive, but on most relevant targets `n` can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint8_t rotr8(const uint8_t x, const int n) {
#if defined(ARCHX86)
	uint8_t res = x;
	asm ("rorb %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint8_t)(((uint8_t)(x >> n) | (uint8_t)(x << (8 - n))) & 0xffU);
#endif
}


/** Given a size_t argument `x`, return the value corresponding to rotating the bits `n` steps to the left; `n` must be between 1 and `(CHAR_BIT * sizeof(size_t) - 1)` inclusive */
LIB_FUNC ATTR_CF size_t rotl_sz(const size_t x, const int n) {
#   if ((SIZEOF_SIZE_T == 8) && defined(ARCHX86) && CPU_AVX512F)
	size_t res;
	asm ("prolq %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif ((SIZEOF_SIZE_T == 8) && defined(ARCHX86))
	size_t res = x;
	asm ("rolq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#   elif ((SIZEOF_SIZE_T == 4) && defined(ARCHX86) && CPU_AVX512F)
	size_t res;
	asm ("prolq %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif ((SIZEOF_SIZE_T == 4) && defined(ARCHX86))
	size_t res = x;
	asm ("rolq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (size_t)(((size_t)(x << n) | (size_t)(x >> (BITS_PER_SIZE_T - n))) & SIZE_MAX);
#endif
}


/** Given a size_t argument `x`, return the value corresponding to rotating the bits `n` steps to the right; `n` must be between 1 to `(CHAR_BIT * sizeof(size_t) - 1)` inclusive */
LIB_FUNC ATTR_CF size_t rotr_sz(const size_t x, const int n) {
#   if ((SIZEOF_SIZE_T == 8) && defined(ARCHX86) && CPU_AVX512F)
	size_t res;
	asm ("prorq %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif ((SIZEOF_SIZE_T == 8) && defined(ARCHX86))
	size_t res = x;
	asm ("rorq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#   elif ((SIZEOF_SIZE_T == 4) && defined(ARCHX86) && CPU_AVX512F)
	size_t res;
	asm ("prorq %1, %2, %0;" : "=X"(res) : "X"(n), "X"(x));
	return res;
#   elif ((SIZEOF_SIZE_T == 4) && defined(ARCHX86))
	size_t res = x;
	asm ("rorq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (size_t)(((size_t)(x >> n) | (size_t)(x << (BITS_PER_SIZE_T - n))) & SIZE_MAX);
#endif
}


/** Given an unsigned 64-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the left; `n` must be between 1 and 63 inclusive */
LIB_FUNC ATTR_CF uint64_t a_rotl64(const atomic_uint64_t x, const atomic_int n) {
#   if defined(ARCHX86)
	atomic_uint64_t res = x;
	vasm("lock rolq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint64_t)(((x << n) | (x >> (64 - n))) & UINT64_MAX);
#endif
}


/** Given an unsigned 64-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the right; `n` must be between 1 to 63 inclusive */
LIB_FUNC ATTR_CF uint64_t a_rotr64(const atomic_uint64_t x, const atomic_int n) {
#   if defined(ARCHX86)
	atomic_uint64_t res = x;
	asm ("lock rorq %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint64_t)(((x >> n) | (x << (64 - n))) & UINT64_MAX);
#endif
}


/** Given an unsigned 32-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the left; `n` must be between 1 and 31 inclusive */
LIB_FUNC ATTR_CF uint32_t a_rotl32(const atomic_uint32_t x, const atomic_int n) {
#   if defined(ARCHX86)
	atomic_uint32_t res = x;
	asm ("lock rold %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint32_t)(((x << n) | (x >> (32 - n))) & UINT32_MAX);
#endif
}


/** Given an unsigned 32-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the right; `n` must be between 1 to 31 inclusive */
LIB_FUNC ATTR_CF uint32_t a_rotr32(const atomic_uint32_t x, const atomic_int n) {
#   if defined(ARCHX86)
	atomic_uint32_t res = x;
	asm ("lock rord %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint32_t)(((x >> n) | (x << (32 - n))) & UINT32_MAX);
#endif
}


/** Given an unsigned 16-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the left; `n` must be between 1 to 15 inclusive, but on most relevant targets `n` can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint16_t a_rotl16(const atomic_uint16_t x, const atomic_int n) {
#if defined(ARCHX86)
	atomic_uint16_t res = x;
	asm ("lock rol %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint16_t)(((atomic_uint16_t)(x << n) | (atomic_uint16_t)(x >> (16 - n))) & (atomic_uint16_t)UINT16_MAX);
#endif
}


/** Given an unsigned 16-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the right; `n` must be in 1 to 15 inclusive, but on most relevant targets `n` can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint16_t a_rotr16(const atomic_uint16_t x, const atomic_int n) {
#if defined(ARCHX86)
	atomic_uint16_t res = x;
	asm ("lock ror %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint16_t)(((atomic_uint16_t)(x >> n) | (atomic_uint16_t)(x << (16 - n))) & (atomic_uint16_t)UINT16_MAX);
#endif
}


/** Given an unsigned 8-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the left; `n` must be between 1 to 7 inclusive, but on most relevant targets `n` can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint8_t a_rotl8(const atomic_uint8_t x, const atomic_int n) {
#if defined(ARCHX86)
	atomic_uint8_t res = x;
	asm ("lock rolb %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint8_t)(((atomic_uint8_t)(x << n) | (atomic_uint8_t)(x >> (8 - n))) & 0xffU);
#endif
}


/** Given an unsigned 8-bit argument `x`, return the value corresponding to atomically-rotating the bits `n` steps to the right; `n` must be in 1 to 7 inclusive, but on most relevant targets `n` can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC ATTR_CF uint8_t a_rotr8(const atomic_uint8_t x, const atomic_int n) {
#if defined(ARCHX86)
	atomic_uint8_t res = x;
	asm ("lock rorb %1, %0;" : "+X"(res) : "X"(n));
	return res;
#else
	return (uint8_t)(((atomic_uint8_t)(x >> n) | (atomic_uint8_t)(x << (8 - n))) & 0xffU);
#endif
}

/** @} */  // }


// FINDING BITS

/** @defgroup Finding_Bits Functions and macros used to find certain bits
@{ */  // (FB){

/**
@brief Find last (most-significant) set bit in a long word
@param[in] word The word to search
@return Bit location of the last set bit

@code{.c}
fls(0)  # Output: 0
fls(1)  # Output: 1
fls(0x80000000)  # Output: 32
@endcode
*/
LIB_FUNC ATTR_CF unsigned long fls(const unsigned long word) {
	if (word == 0) { return 0; }
	register int num = (BITS_PER_LONG - 1);
	register unsigned long _word = word;
#   if LONG_EQ_64BITS
	if (!(_word & (~0UL << 32))) { num -= 32; _word <<= 32; }
#   endif
	if (!(_word & (~0UL << (BITS_PER_LONG - 16)))) { num -= 16; _word <<= 16; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 8)))) { num -= 8; _word <<= 8; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 4)))) { num -= 4; _word <<= 4; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 2)))) { num -= 2; _word <<= 2; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 1)))) { num -= 1; }
	return ((unsigned long)num) + 1;
}
#define __fls(x)   fls((x))


/** Find Last (most-significant) Bit Set */
LIB_FUNC ATTR_CF int fls32(const uint32_t xint) {
	if (!xint) { return 0; }
	register int _v = 32;
	register uint32_t x = xint;
	if ((x & 0xffff0000U) == 0) {
		x <<= 16;
		_v -= 16;
	}
	if ((x & 0xff000000U) == 0) {
		x <<= 8;
		_v -= 8;
	}
	if ((x & 0xf0000000U) == 0) {
		x <<= 4;
		_v -= 4;
	}
	if ((x & 0xc0000000U) == 0) {
		x <<= 2;
		_v -= 2;
	}
	if ((x & 0x80000000U) == 0) {
		x <<= 1;
		_v -= 1;
	}
	return _v;
}


/** Find Last (most-significant) Bit Set */
LIB_FUNC ATTR_CF int fls64(const uint64_t xint) {
	if (!xint) { return 0; }
	register int _v = 64;
	register uint64_t x = xint;
	if ((x & 0xffffffff00000000ULL) == 0) {
		x <<= 32;
		_v -= 32;
	}
	if ((x & 0xffff000000000000ULL) == 0) {
		x <<= 16;
		_v -= 16;
	}
	if ((x & 0xff00000000000000ULL) == 0) {
		x <<= 8;
		_v -= 8;
	}
	if ((x & 0xf000000000000000ULL) == 0) {
		x <<= 4;
		_v -= 4;
	}
	if ((x & 0xc000000000000000ULL) == 0) {
		x <<= 2;
		_v -= 2;
	}
	if ((x & 0x8000000000000000ULL) == 0) {
		x <<= 1;
		_v -= 1;
	}
	return _v;
}


/** Find Last (most-significant) Bit Set */
LIB_FUNC ATTR_CF unsigned int fls_long(const unsigned long word) {
#   if LONG_EQ_32BITS
	return (unsigned int)fls(word);
#   else
	return (unsigned int)fls64(word);
#   endif
}


/** Find last (most-significant) set bit in a long word; Undefined if no set bit exists, so code should check against 0 first */
LIB_FUNC ATTR_CF unsigned long flsl(const unsigned long word) {
#   if LONG_EQ_32BITS
	return (unsigned long)fls(word);
#   else
	return (unsigned long)fls64(word);
#   endif
}
#define __flsl(word)   flsl((word))


/** Find first bit set; Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC ATTR_CF int ffs(const int mask) {
	register unsigned int r = (unsigned int)mask;
	register int bit = 0;
	if (!(r & UINT16_MAX)) { bit += 16; r >>= 16; }
	if (!(r & 0xff)) { bit += 8; r >>= 8; }
	if (!(r & 0xf)) { bit += 4; r >>= 4; }
	const signed char t[16] = { -28, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1 };
	return (bit + t[(r & 0xf)]);
}
#define __ffs(mask)   ffs((mask))


// TODO: Add code for non-x86 targets and add code for tzcnt/lzcnt
/** Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC ATTR_CF unsigned long ffs_long(const unsigned long word) {
	if (word == 0) { return 0; }
	unsigned long res;
	asm ("rep;" "bsf %1, %0;" : "=r"(res) : "r"(word));
	return res + 1;
}


/** Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC ATTR_CF int ffsl(const long word) {
	return (int)ffs_long((unsigned long)word);
}
#define __ffsl(x)   ffsl((x))


/** Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC ATTR_CF int ffsll(const long long i) {
#   if LLONG_EQ_32BITS
	return (int)ffs_long((unsigned long)i);
#   else
	register const unsigned long long u = (unsigned long long)i;
	register const unsigned long upper = ((unsigned long)(u >> 32));
	register const unsigned long lower = (unsigned long)u;
	if (lower) { return (int)ffsl((u & UINT32_MAX)); }
	else if (upper) { return (int)(32 + ffs_long(upper)); }
	return 0;
#   endif
}
#define __ffsll(i)   ffsll((i))


/** Find First Set */
LIB_FUNC ATTR_CF int ffs32(const uint32_t xint) {
	if (!xint) { return 0; }
	register int _v = 1;
	register uint32_t x = xint;
	if ((x & UINT16_MAX) == 0) {
		x >>= 16;
		_v += 16;
	}
	if ((x & 0xffU) == 0) {
		x >>= 8;
		_v += 8;
	}
	if ((x & 0xfU) == 0) {
		x >>= 4;
		_v += 4;
	}
	if ((x & 3U) == 0) {
		x >>= 2;
		_v += 2;
	}
	if ((x & 1U) == 0) {
		x >>= 1;
		_v += 1;
	}
	return _v;
}


/** Find First Set */
LIB_FUNC ATTR_CF int ffs64(const uint64_t xint) {
	if (!xint) { return 0; }
	register int _v = 1;
	register uint64_t x = xint;
	if ((x & UINT32_MAX) == 0) {
		x >>= 32;
		_v += 32;
	}
	if ((x & UINT16_MAX) == 0) {
		x >>= 16;
		_v += 16;
	}
	if ((x & 0xffULL) == 0) {
		x >>= 8;
		_v += 8;
	}
	if ((x & 0xfULL) == 0) {
		x >>= 4;
		_v += 4;
	}
	if ((x & 3ULL) == 0) {
		x >>= 2;
		_v += 2;
	}
	if ((x & 1ULL) == 0) {
		x >>= 1;
		_v += 1;
	}
	return _v;
}


/** Find first zero in word; Undefined if no zero exists, so code should check against ~0 first */
LIB_FUNC ATTR_CF int ffz(const int word) {
	if (word == 0) { return -1; }
	return ffs(~word);
}
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0 first */
#define __ffz(x)   ffz((x))


// TODO: Add code for non-x86 targets and add code for tzcnt/lzcnt
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
LIB_FUNC ATTR_CF int ffzl(const unsigned long word) {
	if (word == 0) { return -1; }
	unsigned long _word = (unsigned long)(~word);
	asm ("rep;" "bsf %1, %0;" : "=r"(_word) : "r"(_word));
	return (int)(_word + 1);
}
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
#define __ffzl(x)   ffzl((x))


/** Find first zero in word; Undefined if no zero exists, so code should check against ~0ULL first */
LIB_FUNC ATTR_CF int ffzll(const unsigned long long i) {
	if (i == 0) { return -1; }
	return ffsll((long long)(~i));
}
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0ULL first */
#define __ffzll(x)   ffzll((x))


/** Find the first zero bit in a bit string of `size` bits, starting the search at bit `offset` */
LIB_FUNC unsigned long find_next_zero_bit(const void* restrict addr, const unsigned long size, const unsigned long offset) {
	if (offset >= size) { return size; }
	const unsigned long* p = (((const unsigned long*)addr) + (offset >> 5));
	unsigned long result = offset & (~31UL);
	unsigned long tmp = 0;
	unsigned long bitsize = size - result;
	unsigned long bitoffset = offset & 31UL;
	if (bitoffset) {
			tmp = *(p++);
			tmp |= ((~0UL) >> (32 - bitoffset));
			if (bitsize < 32) {
				tmp |= ((~0UL) << bitsize);
				if (!(~tmp)) { return result + bitsize; }
				return result + (unsigned long)ffzl(tmp);
			}
			else if (~tmp) { return result + (unsigned long)ffzl(tmp); }
			bitsize -= 32;
			result += 32;
	}
	while (bitsize & (~31UL)) {
		if (~(tmp = *(p++))) { return result + (unsigned long)ffzl(tmp); }
		result += 32;
		bitsize -= 32;
	}
	if (!bitsize) { return result; }
	tmp = *p;
	tmp |= ((~0UL) << bitsize);
	if (!(~tmp)) { return result + bitsize; }
	return result + (unsigned long)ffzl(tmp);
}


LIB_FUNC int find_first_zero_bit(const void* restrict buf, const unsigned int len) {
	return (int)find_next_zero_bit(buf, (unsigned long)len, 0);
}


#ifdef ARCHX86_64
LIB_FUNC long find_next_bit(const unsigned long* addr, const long size, const long offset) {
	const unsigned long* p = addr + (offset >> 6);
	register unsigned long set = 0, res = 0;
	register unsigned long bit = (unsigned long)((unsigned long)offset & 63);
	if (bit) {
		vasm("bsfq %1, %0;" "cmoveq %2, %0;" : "=r"(set) : "r,i,n"((*p >> bit)), "r,i,n,J"(64L));
		if (set < (64 - bit)) { return ((long)set + offset); }
		set = 64 - bit;
		p++;
	}
	res = (unsigned long)find_next_bit(p, (size - 64 * (p - addr)), 0);
	return offset + (long)set + (long)res;
}
#elif defined(ARCHX86_32)
LIB_FUNC int find_next_bit(const unsigned long* addr, const int size, const int offset) {
	const unsigned long* p = (addr + (offset >> 5));
	register int set = 0, res = 0;
	register int bit = offset & 31;
	if (bit) {
		vasm("bsfl %1, %0;" "jne 1f;" "movl $32, %0;" "1:" : "=r"(set) : "r,i,n"(*p >> bit));
		if (set < (32 - bit)) { return set + offset; }
		set = 32 - bit;
		p++;
	}
	res = find_next_bit(p, (size - 32 * (p - addr)), 0);
	return offset + set + res;
}
#else
#   error   "find_next_bit() is not supported by the target platform!"
#endif
#define find_first_bit(addr, size)   find_next_bit((addr), (size), 0)
#define for_each_bit(bit, addr, size)   for ((bit) = find_first_bit((addr), (size)); (bit) < (size); (bit) = find_next_bit((addr), (size), (bit) + 1))


#if LITTLE_ENDIAN
#   define BITOP_LE_SWIZZLE   0


LIB_FUNC unsigned long find_next_zero_bit_le(const void* restrict addr, const unsigned long size, const unsigned long offset) {
	return find_next_zero_bit(addr, size, offset);
}


#   ifdef ARCHX86_64
LIB_FUNC unsigned long find_next_bit_le(const void* restrict addr, const unsigned long size, const unsigned long offset) {
	return (unsigned long)find_next_bit(addr, (long)size, (long)offset);
}
#   elif defined(ARCHX86_32)
LIB_FUNC unsigned int find_next_bit_le(const void* restrict addr, const unsigned int size, const unsigned int offset) {
	return (unsigned int)find_next_bit(addr, (int)size, (int)offset);
}
#   endif
#define _find_next_bit_le(addr, size, offset)   find_next_bit_le((addr), (size), (offset))


LIB_FUNC unsigned long find_first_zero_bit_le(const void* restrict addr, unsigned long size) {
	return (unsigned long)find_first_zero_bit(addr, (unsigned int)size);
}


#elif BIG_ENDIAN
#   define BITOP_LE_SWIZZLE   ((BITS_PER_LONG - 1) & (~0x7))


LIB_FUNC unsigned long ext2_swab(const unsigned long y) {
#   if LONG_EQ_64BITS
	return (unsigned long)bswap64((uint64_t)y);
#   elif LONG_EQ_32BITS
	return (unsigned long)bswap32((uint32_t)y);
#   else
#      error   "BITS_PER_LONG is not defined!"
#   endif
}


#   if ((!defined(find_next_bit_le)) || (!defined(find_next_zero_bit_le)))
LIB_FUNC unsigned long find_next_bit_le(const unsigned long* restrict addr, const unsigned long nbits, const unsigned long start, const unsigned long invert) {
	unsigned long tmp = 0;
	if ((!nbits) || (start >= nbits)) { return nbits; }
	tmp = (addr[start / BITS_PER_LONG] ^ invert);
	// Handle 1st word
	unsigned long startcnt = start;
	tmp &= ext2_swab(BITMAP_FIRST_WORD_MASK(startcnt));
	startcnt = round_down(startcnt, BITS_PER_LONG);
	while (!tmp) {
		startcnt += BITS_PER_LONG;
		if (startcnt >= nbits) { return nbits; }
		tmp = (addr[startcnt / BITS_PER_LONG] ^ invert);
	}
	return (unsigned long)min((startcnt + ffs(ext2_swab(tmp))), nbits);
}
#      define _find_next_bit_le(addr, nbits, start, invert)   find_next_bit_le((addr), (nbits), (start), (invert))
#   endif


#   ifndef find_next_zero_bit_le
#      define find_next_zero_bit_le(addr, size, offset)   find_next_bit_le((addr), (size), (offset), (~0UL))
#   endif
#   if ((!defined(find_next_bit_le)) || (!defined(_find_next_bit_le)))
#      define find_next_bit_le(addr, size, offset)   find_next_bit_le((addr), (size), (offset), (0UL))
#      define _find_next_bit_le(addr, size, offset)   find_next_bit_le((addr), (size), (offset))
#   endif
#   ifndef find_first_zero_bit_le
#      define find_first_zero_bit_le(addr, size)   find_next_zero_bit_le((addr), (size), 0)
#   endif


#endif

/** @} */  // }


// BIT COUNTING

/** @defgroup Bit_Counting Functions and macros used to count various bits in data
@{ */  // (FB){

#ifdef ARCHAVR
#   if IS_WORDSIZE_16
#      define COUNT_LEADING_ZEROS_0   16
#   elif IS_WORDSIZE_32
#      define COUNT_LEADING_ZEROS_0   32
#   elif IS_WORDSIZE_64
#      define COUNT_LEADING_ZEROS_0   64
#   endif
#elif defined(__alpha_cix__)
#   define COUNT_LEADING_ZEROS_0   64
#elif defined(ARCHARC)
#   define COUNT_LEADING_ZEROS_0   32
#elif IS_WORDSIZE_32
#   define COUNT_LEADING_ZEROS_0   32
#elif IS_WORDSIZE_64
#   define COUNT_LEADING_ZEROS_0   64
#else
#   define COUNT_LEADING_ZEROS_0   BITS_PER_LONG
#endif
#ifndef COUNT_TRAILING_ZEROS_0
#   define COUNT_TRAILING_ZEROS_0   -1
#endif


static const UNUSED int8_t countLeadingZerosHigh[256] = {
	8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/** Return the number of bits used to represent the given number */
LIB_FUNC ATTR_CF unsigned long long bit_length(const unsigned long long num) {
	register unsigned long long len = 0, x = num;
	while (x != 0) {
		++len;
		x >>= 1;
	}
	return len;
}


#if SUPPORTS_UTITYPE
/** Return the number of bits used to represent the given number */
LIB_FUNC ATTR_CF UTItype bit128_length(const UTItype num) {
	register uint128_t len = 0, x = num;
	while (x != 0) {
		++len;
		x >>= 1;
	}
	return len;
}
#endif


/** Counts the number of `1` bits (32-bit) */
LIB_FUNC ATTR_CF uint32_t popcount32(const uint32_t x) {
	register uint32_t y = (uint32_t)(x - ((x >> 1) & 0x55555555U));
	y = (y & 0x33333333U) + ((y >> 2) & 0x33333333U);
	y = (y + (y >> 4)) & 0x0f0f0f0fU;
	return (uint32_t)((y * 0x01010101U) >> 24);
}
#define popcnt32(x)   popcount32((uint32_t)(x))
#define POPCNT(x)   popcount32((uint32_t)(x))
#define popcnt(x)   popcount32((uint32_t)(x))
#define __popcnt32(x)   popcount32((uint32_t)(x))


/** Counts the number of `1` bits (64-bit) */
LIB_FUNC ATTR_CF uint32_t popcount64(const uint64_t x) {
#   if (SIZE_MAX < UINT64_MAX)
	return popcount32((uint32_t)(x >> 32)) + popcount32((uint32_t)(x & UINT32_MAX));
#   else
	register uint64_t y = (uint32_t)(x - ((x >> 1) & (uint64_t)NUM_5ULL));
	y = (uint64_t)((y & (uint64_t)NUM_3ULL) + ((y >> 2) & (uint64_t)NUM_3ULL));
	y = (uint64_t)(((y + (y >> 4)) & (uint64_t)NUM_0fULL) * (uint64_t)0x0101010101010101ULL);
	return (uint32_t)(y >> 56);
#   endif
}
#define popcnt64(x)   popcount64((uint64_t)(x))
#define __popcnt64(x)   popcount64((uint64_t)(x))


#if (UINT_MAX == UINT32_MAX)
/** Counts the number of `1` bits (32-bit) */
#   define popcount(x)   popcount32((uint32_t)(x))
#endif
/** @def popcountl
Counts the number of `1` bits (long) */
#if LONG_EQ_32BITS
#   define popcountl(x)   popcount32((uint32_t)(x))
#elif LONG_EQ_64BITS
#   define popcountl(x)   popcount64((uint64_t)(x))
#endif
/** @def popcountll
Counts the number of `1` bits (long long) */
#if LLONG_EQ_64BITS
#   define popcountll(x)   popcount64((uint64_t)(x))
#else
#   define popcountll(x)   popcount32((uint32_t)(x))
#endif


/** Returns the number of leading 0 bits before the most-significant 1 bit of `a`; If `a` is zero, 32 is returned */
LIB_FUNC ATTR_CF int8_t countLeadingZeros32(const uint32_t a) {
	register int8_t shiftCount = 0;
	register uint32_t x = a;
	if (x < 0x10000) {
		shiftCount = (int8_t)(shiftCount + (int8_t)16);
		x <<= 16;
	}
	if (x < 0x1000000) {
		shiftCount = (int8_t)(shiftCount + (int8_t)8);
		x <<= 8;
	}
	shiftCount = (int8_t)(shiftCount + ((int8_t)countLeadingZerosHigh[x >> 24]));
	return shiftCount;
}


/**
@brief Count the number of zeros from the MSB towrds the LSB; Like __builtin_clz()
@param[in] x The value to test
@retval 0 BITS_PER_INT
@retval 1 BITS_PER_INT - 1
*/
LIB_FUNC ATTR_CF int clz(const unsigned int x) {
	return (int)(BITS_PER_INT - (int)fls32((uint32_t)x));
}
#define __clz(x)   clz((x))
#define nlz(x)   clz((x))
#define __nlz(x)   clz((x))


/**
@brief Count the number of zeros from the MSB towrds the LSB; Like __builtin_clzl()
@param[in] x The value to test
@retval 0 BITS_PER_LONG
@retval 1 BITS_PER_LONG - 1
*/
LIB_FUNC ATTR_CF int count_leading_zeros(const unsigned long x) {
#   if LONG_EQ_32BITS
	return (int)(BITS_PER_LONG - (int)fls(x));
#   else
	return (int)(BITS_PER_LONG - (int)fls64((uint64_t)x));
#   endif
}
#define clzl(x)   count_leading_zeros((x))
#define cntlzw(x)   count_leading_zeros((x))
#define __cntlzw(x)   count_leading_zeros((x))
#define cntlz(x)   count_leading_zeros((x))
#define __cntlw(x)   count_leading_zeros((x))
#define cntlzd(x)   count_leading_zeros((x))
#define __cntlzd(x)   count_leading_zeros((x))


/** Count the number of zeros from the MSB back; Like `__builtin_clzll()` */
LIB_FUNC ATTR_CF int clzll(const unsigned long long x) {
	return (int)(BITS_PER_LONG_LONG - (int)fls64((uint64_t)x));
}
#define __clzll(x)   clzll((x))


/** Count the number of zeros from the LSB forwards */
LIB_FUNC ATTR_CF int ctz(const unsigned int x) {
	return (int)(ffs((int)x) - 1);
}
#define __ctz(x)   ctz((x))
#define clz_qi2(x)   ctz((x))
#define clz_hi2(x)   ctz((x))


/**
@brief Count the number of zeros from the LSB towrds the MSB
@param[in] x The value to test
@retval 1 0
@retval 0 COUNT_TRAILING_ZEROS_0
*/
LIB_FUNC ATTR_CF int count_trailing_zeros(const unsigned long x) {
#   if LONG_EQ_32BITS
	return (int)(ffs((int)x) - 1);
#   else
	if (x == 1) { return 0; }
	else if (x == 0) { return COUNT_TRAILING_ZEROS_0; }
	return (int)(ffs64((uint64_t)x) - 1);
#   endif
}
#define ctzl(x)   count_trailing_zeros((x))
#define __ctzl(x)   count_trailing_zeros((x))
#define clz_si2(x)   count_trailing_zeros((x))


/** Count the number of zeros from the LSB forwards */
LIB_FUNC ATTR_CF int ctzll(const unsigned long long x) {
	if (x == 1) { return 0; }
	else if (x == 0) { return COUNT_TRAILING_ZEROS_0; }
	return (int)(ffs64((uint64_t)x) - 1);
}
#define __ctzll(x)   ctzll((x))
#define ctz64(x)   ctzll((x))
#define clz_di2(x)   ctzll((x))


/** Count leading redundant sign bits */
LIB_FUNC ATTR_CF int count_leading_sign_bits(const int x) {
	if (x == 0 || x == -1) { return 31; }
	else if (x < 0) { return ((int)(BITS_PER_INT - (int)fls32((uint32_t)~x))) - 1; }
	return ((int)(BITS_PER_INT - (int)fls32((uint32_t)x))) - 1;
}
#define clrsb(x)   count_leading_sign_bits((x))
#define __clrsbSI2(x)   count_leading_sign_bits((x))
#define clrsbsi2(x)   count_leading_sign_bits((x))
#define count_leading_redundant_sign_bits(x)   count_leading_sign_bits((x))


/** Count leading redundant sign bits */
LIB_FUNC ATTR_CF int clrsbl(const long x) {
	if (x == 0L || x == -1L) { return (int)(BITS_PER_LONG - 1); }
	else if (x < 0L) { return ((int)(BITS_PER_LONG - (int)flsl((unsigned long)~x))) - 1; }
	return ((int)(BITS_PER_LONG - (int)flsl((unsigned long)x))) - 1;
}
#define __clrsbl(x)   clrsbl((x))


/** Count leading redundant sign bits */
LIB_FUNC ATTR_CF int clrsbdi2(const long long x) {
	if (x == 0LL || x == -1LL) { return (int)(BITS_PER_LONG_LONG - 1); }
	else if (x < 0LL) { return ((int)(BITS_PER_LONG_LONG - (int)fls64((uint64_t)~x))) - 1; }
	return ((int)(BITS_PER_LONG_LONG - (int)fls64((uint64_t)x))) - 1;
}
#define clrsbll(x)   clrsbdi2((x))
#define __clrsbll(x)   clrsbdi2((x))
#define __clrsbdi2(x)   clrsbdi2((x))
#define __clrsbDI2(x)   clrsbdi2((x))


LIB_FUNC unsigned long count_free(const char* restrict map, const unsigned int numchars) {
	if (!map) { return 0; }
	register unsigned int i = 0;
	register unsigned long sum = 0;
	for (; i < numchars; i++) {
		sum += (unsigned long)(nibblemap[map[i] & 0xf] + nibblemap[(map[i] >> 4) & 0xf]);
	}
	return sum;
}

/** @} */  // }


// DIRECT BIT TESTING

/** @defgroup Direct_Bit_Testing Functions used to test/evaluate certain bits directly
@{ */  // (FB){

/** Test if a particular bit (`pos`) is a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint8_t test_bit8(const uint8_t bits, const uint8_t pos, const uint8_t value) {
	register const uint8_t mask = (uint8_t)((uint8_t)1U << (uint8_t)(pos - 1U));
	if (value) { return ((bits & mask) != 0); }
	else { return ((bits & mask) == 0); }
}


/** Test if a particular bit (`pos`) is a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint16_t test_bit16(const uint16_t bits, const uint8_t pos, const uint8_t value) {
	register const uint16_t mask = (uint16_t)((uint16_t)1U << (uint16_t)(pos - 1U));
	if (value) { return ((bits & mask) != 0); }
	else { return ((bits & mask) == 0); }
}


/** Test if a particular bit (`pos`) is a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint32_t test_bit32(const uint32_t bits, const uint8_t pos, const uint8_t value) {
	register const uint32_t mask = (uint32_t)((uint32_t)1U << (uint32_t)(pos - 1U));
	if (value) { return ((bits & mask) != 0); }
	else { return ((bits & mask) == 0); }
}


/** Test if a particular bit (`pos`) is a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint64_t test_bit64(const uint64_t bits, const uint8_t pos, const uint8_t value) {
	register const uint64_t mask = (uint64_t)((uint64_t)1U << (uint64_t)(pos - 1U));
	if (value) { return ((bits & mask) != 0); }
	else { return ((bits & mask) == 0); }
}


LIB_FUNC int constant_test_bit(const int nr, const volatile void* restrict addr) {
	return ((1UL << (nr & 31)) & (((const volatile unsigned int*)addr)[nr >> 5])) != 0;
}


#ifdef ARCHX86
LIB_FUNC int variable_test_bit(const int nr, volatile void* restrict addr) {
	int oldbit;
	vasm("btl %2,%1;" "sbbl %0, %0;" : "=r,m"(oldbit) : "m,r"((*(volatile long*)addr)), "dI,dr,r,i,n,J,I"(nr));
	return oldbit;
}
#endif


#define test_bit(nr, addr)   (__builtin_constant_p(nr) ? constant_test_bit((nr), (addr)) : variable_test_bit((nr), (addr)))


LIB_FUNC int test_bit_le(const int nr, void* addr) {
	return test_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}

/** @} */  // }


// SETTING BITS DIRECTLY

/** @defgroup Direct_Bit_Settings Functions used to set/change certain bits directly
@{ */  // (FB){

/** Set a particular bit (pos) to a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint8_t set_bit8(const uint8_t bits, const uint8_t pos, const uint8_t value) {
	register const uint8_t mask = (uint8_t)((uint8_t)1U << (uint8_t)(pos - 1U));
	if (value) { return (bits | mask); }
	else { return (bits & (uint8_t)(~mask)); }
}


/** Set a particular bit (pos) to a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint16_t set_bit16(const uint16_t bits, const uint8_t pos, const uint8_t value) {
	register const uint16_t mask = (uint16_t)((uint16_t)1U << (uint16_t)(pos - 1U));
	if (value) { return (bits | mask); }
	else { return (bits & (uint16_t)(~mask)); }
}


/** Set a particular bit (pos) to a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint32_t set_bit32(const uint32_t bits, const uint8_t pos, const uint8_t value) {
	register const uint32_t mask = (uint32_t)((uint32_t)1U << (uint32_t)(pos - 1U));
	if (value) { return (bits | mask); }
	else { return (bits & (uint32_t)(~mask)); }
}


/** Set a particular bit (pos) to a particular `value` (0 or 1) in the named data (`bits`) */
LIB_FUNC ATTR_CF uint64_t set_bit64(const uint64_t bits, const uint8_t pos, const uint8_t value) {
	register const uint64_t mask = (uint64_t)((uint64_t)1U << (pos - 1U));
	if (value) { return (bits | mask); }
	else { return (bits & (uint64_t)(~mask)); }
}


/** Clear least significant bit */
LIB_FUNC ATTR_CF unsigned long long clearlsb(const unsigned long long num) {
	return (num & (num - 1));
}


#ifdef ARCHX86  // clear_bit() and set_bit()


/**
@brief Atomically set a bit in memory
@param[in] nr The bit to set
@param[in,out] addr The address to start counting from
*/
LIB_FUNC void set_bit(const int nr, volatile void* restrict addr) {
	vasm("btsl %1, %0;" : "=m"((*(volatile long*)addr)) : "dI,dr,r,i,n,I,J"(nr) : "memory");
}


/**
@brief Atomically clears a bit in memory
@param[in] nr The bit to clear
@param[in,out] addr Address to start counting from
*/
LIB_FUNC void clear_bit(const int nr, volatile void* restrict addr) {
	vasm("btrl %1, %0;" : "=m"((*(volatile long*)addr)) : "dI,dr,r,i,n,I,J"(nr) : "memory");
}


/**
@brief Atomically toggle a bit in memory
@param[in] nr The bit to toggle
@param[in,addr] addr Address to start counting from
*/
LIB_FUNC void change_bit(const long nr, volatile unsigned long* restrict addr) {
	if ((__builtin_constant_p(nr))) {
		asm volatile(";" "xorb %1, %0;" : "+m"(*(volatile long*)((volatile long*)(addr) + ((nr) >> 3))) : "iq"((uint8_t)(1 << ((nr) & 7))) : "memory");
	} else {
		asm volatile(";" "btc %1, %0;" : "+m"(*(volatile long*)(addr)) : "I,r,i"(nr) : "memory");
	}
}
#   define __change_bit(nr, addr)   change_bit((nr), (addr))
#   define toggle_bit(nr, addr)   change_bit((nr), (addr))
#   define __toggle_bit(nr, addr)   change_bit((nr), (addr))


#else
#   error   "clear_bit() and set_bit() are not supported by the target platform!"
#endif


/**
@brief Clears a bit in memory
@param[in] nr The bit to clear
@param[in,out] addr Address to start counting from
*/
#define clear_bit_unlock(nr, addr)   barrier(); change_bit((nr), (addr))


/**
@brief Clear a bit and return its old value
@param[in] nr The bit to clear
@param[in,out] addr Address to count from
*/
LIB_FUNC int test_and_clear_bit(const int nr, volatile unsigned long* restrict addr) {
	clear_bit(nr, addr);
	return 1;
}


/**
@brief Set a bit and return its old value
@param[in] nr The bit to set
@param[in,out] addr Address to count from
*/
LIB_FUNC int test_and_set_bit(const int nr, volatile unsigned long* restrict addr) {
	set_bit(nr, addr);
	return 1;
}


/**
@brief Set a bit and return its old value for lock
@param[in] nr The bit to set
@param[in,out] addr Address to count from
*/
LIB_FUNC int test_and_set_bit_lock(const long nr, volatile unsigned long* restrict addr) {
	set_bit((int)nr, addr);
	return 1;
}


/**
@brief Set a bit and return its old value
@param[in] nr The bit to set
@param[in,out] addr Address to count from
*/
LIB_FUNC int __test_and_set_bit(const long nr, volatile unsigned long* restrict addr) {
	int oldbit;
	asm ("bts %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long*)(addr)) : "Ir"(nr));
	return oldbit;
}


/**
@brief Clear a bit and return its old value
@param[in] nr The bit to clear
@param[in,out] addr Address to count from
*/
LIB_FUNC int __test_and_clear_bit(const long nr, volatile unsigned long* restrict addr) {
	int oldbit;
	vasm("btr %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long*)(addr)) : "I,J,r,i,n"(nr));
	return oldbit;
}


LIB_FUNC int __test_and_change_bit(const long nr, volatile unsigned long* restrict addr) {
	int oldbit;
	vasm("btc %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long*)(addr)) : "I,J,r,i,n"(nr) : "memory");
	return oldbit;
}


LIB_FUNC void set_bit_le(const int nr, volatile void* addr) {
	set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC void clear_bit_le(const int nr, volatile void* addr) {
	clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int test_and_set_bit_le(const int nr, volatile void* addr) {
	return test_and_set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int test_and_clear_bit_le(const int nr, volatile void* addr) {
	return test_and_clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int __test_and_set_bit_le(const long nr, volatile void* addr) {
	return __test_and_set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int __test_and_clear_bit_le(const long nr, volatile void* addr) {
	return __test_and_clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}

/** @} */  // }


// VECTORIZATION

/** @defgroup Vectorization Functions and macros for vectorized commands
@{ */  // (FB){

LIB_FUNC void xor_8regs_2(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	do {
		p1[0] ^= p2[0];
		p1[1] ^= p2[1];
		p1[2] ^= p2[2];
		p1[3] ^= p2[3];
		p1[4] ^= p2[4];
		p1[5] ^= p2[5];
		p1[6] ^= p2[6];
		p1[7] ^= p2[7];
		p1 += 8;
		p2 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_3(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0];
		p1[1] ^= p2[1] ^ p3[1];
		p1[2] ^= p2[2] ^ p3[2];
		p1[3] ^= p2[3] ^ p3[3];
		p1[4] ^= p2[4] ^ p3[4];
		p1[5] ^= p2[5] ^ p3[5];
		p1[6] ^= p2[6] ^ p3[6];
		p1[7] ^= p2[7] ^ p3[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_4(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3, unsigned long* restrict p4) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0] ^ p4[0];
		p1[1] ^= p2[1] ^ p3[1] ^ p4[1];
		p1[2] ^= p2[2] ^ p3[2] ^ p4[2];
		p1[3] ^= p2[3] ^ p3[3] ^ p4[3];
		p1[4] ^= p2[4] ^ p3[4] ^ p4[4];
		p1[5] ^= p2[5] ^ p3[5] ^ p4[5];
		p1[6] ^= p2[6] ^ p3[6] ^ p4[6];
		p1[7] ^= p2[7] ^ p3[7] ^ p4[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_5(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3, unsigned long* restrict p4, unsigned long* restrict p5) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0] ^ p4[0] ^ p5[0];
		p1[1] ^= p2[1] ^ p3[1] ^ p4[1] ^ p5[1];
		p1[2] ^= p2[2] ^ p3[2] ^ p4[2] ^ p5[2];
		p1[3] ^= p2[3] ^ p3[3] ^ p4[3] ^ p5[3];
		p1[4] ^= p2[4] ^ p3[4] ^ p4[4] ^ p5[4];
		p1[5] ^= p2[5] ^ p3[5] ^ p4[5] ^ p5[5];
		p1[6] ^= p2[6] ^ p3[6] ^ p4[6] ^ p5[6];
		p1[7] ^= p2[7] ^ p3[7] ^ p4[7] ^ p5[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
		p5 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_2(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	unsigned long d0 = 0, d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0, d6 = 0, d7 = 0;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_3(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	unsigned long d0 = 0, d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0, d6 = 0, d7 = 0;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_4(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3, unsigned long* restrict p4) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	unsigned long d0 = 0, d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0, d6 = 0, d7 = 0;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		d0 ^= p4[0];
		d1 ^= p4[1];
		d2 ^= p4[2];
		d3 ^= p4[3];
		d4 ^= p4[4];
		d5 ^= p4[5];
		d6 ^= p4[6];
		d7 ^= p4[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_5(const unsigned long bytes, unsigned long* restrict p1, unsigned long* restrict p2, unsigned long* restrict p3, unsigned long* restrict p4, unsigned long* restrict p5) {
	register long lines = (long)((bytes / SIZEOF_LONG) / 8);
	unsigned long d0 = 0, d1 = 0, d2 = 0, d3 = 0, d4 = 0, d5 = 0, d6 = 0, d7 = 0;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		d0 ^= p4[0];
		d1 ^= p4[1];
		d2 ^= p4[2];
		d3 ^= p4[3];
		d4 ^= p4[4];
		d5 ^= p4[5];
		d6 ^= p4[6];
		d7 ^= p4[7];
		d0 ^= p5[0];
		d1 ^= p5[1];
		d2 ^= p5[2];
		d3 ^= p5[3];
		d4 ^= p5[4];
		d5 ^= p5[5];
		d6 ^= p5[6];
		d7 ^= p5[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
		p5 += 8;
	} while (--lines > 0);
}

/** @} */  // }


// MISCELLANEOUS MATH OPERATIONS

/** @defgroup Low_Level_Math_Operations Miscellaneous bit/byte-level math operations
@{ */  // (FB){


static const UNUSED int16_t sqrtOddAdjustments[16] = {
	0x4, 0x22, 0x5d, 0xb1, 0x11d, 0x19f, 0x236, 0x2e0,
	0x39c, 0x468, 0x545, 0x631, 0x72b, 0x832, 0x946, 0xa67
};


static const UNUSED int16_t sqrtEvenAdjustments[16] = {
	0xa2d, 0x8af, 0x75a, 0x629, 0x51a, 0x429, 0x356, 0x29e,
	0x200, 0x179, 0x109, 0xaf, 0x68, 0x34, 0x12, 0x2
};


static const UNUSED UQItype align64 __clz_tab[256] = { 0 };


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC MATH_FUNC bool eq64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 == b0) && (a1 == b1));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is less than or equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC MATH_FUNC bool le64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 < b0) || ((a0 == b0) && (a1 <= b1)));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is less
than the 64-bit value formed by concatenating `b0` and `b1` Otherwise, returns 0 */
LIB_FUNC MATH_FUNC bool lt64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 < b0) || ((a0 == b0) && (a1 < b1)));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is not equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC MATH_FUNC bool ne64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 != b0) || (a1 != b1));
}


/** Shifts `a` right by the number of bits given in `count`; If any nonzero bits are shifted off, they are jammed into the least significant bit of the result by setting the least significant bit to 1; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 32, the result will be either 0 or 1, depending on whether `a` is zero or nonzero; The result is stored in the location pointed to by `zPtr` */
LIB_FUNC void shift32RightJamming(const uint32_t a, const int16_t count, uint32_t* restrict zPtr) {
	uint32_t z;
	if (count == 0) { z = a; }
	else if (count < 32 ) { z = (a >> count) | ((a << ((-count) & 31)) != 0); }
	else { z = (a != 0); }
	*zPtr = z;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` right by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 64, the result will be 0; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shift64Right(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* restrict z0Ptr, uint32_t* restrict z1Ptr ) {
	uint32_t z0, z1;
	const int8_t negCount = (-count) & 31;
	if (count == 0) {
		z1 = a1;
		z0 = a0;
	} else if (count < 32) {
		z1 = (a0 << negCount) | (a1 >> count);
		z0 = a0 >> count;
	} else {
		z1 = (count < 64) ? (a0 >> (count & 31)) : 0;
		z0 = 0;
	}
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` right by the number of bits given in `count`; If any nonzero bits are shifted off, they are jammed into the least significant bit of the result by setting the least significant bit to 1; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 64, the result will be either 0 or 1, depending on whether the concatenation of `a0` and `a1` is zero or nonzero; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shift64RightJamming(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	uint32_t z0, z1;
	const int8_t negCount = (-count) & 31;
	if (count == 0) {
		z1 = a1;
		z0 = a0;
	} else if (count < 32) {
		z1 = (a0 << negCount) | (a1 >> count) | ((a1 << negCount) != 0);
		z0 = a0 >> count;
	} else {
		if (count == 32) {
			z1 = a0 | (a1 != 0);
		} else if (count < 64) {
			z1 = (a0 >> (count & 31)) | (((a0 << negCount) | a1) != 0);
		} else {
			z1 = ((a0 | a1) != 0);
		}
		z0 = 0;
	}
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 96-bit value formed by concatenating `a0`, `a1`, and `a2` right by 32 _plus_ the number of bits given in `count` */
LIB_FUNC void shift64ExtraRightJamming(const uint32_t a0, const uint32_t a1, uint32_t a2, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	uint32_t z0, z1, z2;
	const int8_t negCount = (int8_t)((-count) & 31);
	if (count == 0) {
		z2 = a2;
		z1 = a1;
		z0 = a0;
	} else {
		if (count < 32) {
			z2 = a1 << negCount;
			z1 = (a0 << negCount) | (a1 >> count);
			z0 = a0 >> count;
		} else {
			if (count == 32) {
				z2 = a1;
				z1 = a0;
			} else {
				a2 |= a1;
				if (count < 64) {
					z2 = a0 << negCount;
					z1 = a0 >> (count & 31);
				} else {
					z2 = (count == 64) ? a0 : (a0 != 0);
					z1 = 0;
				}
			}
			z0 = 0;
		}
		z2 |= (a2 != 0);
	}
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` left by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` must be less than 32; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shortShift64Left(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	*z1Ptr = a1 << count;
	*z0Ptr = (count == 0) ? a0 : (a0 << count) | (a1 >> ((-count) & 31));
}


/** Shifts the 96-bit value formed by concatenating `a0`, `a1`, and `a2` left by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` must be less than 32; The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void shortShift96Left(const uint32_t a0, const uint32_t a1, const uint32_t a2, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	const uint32_t z2 = a2 << count;
	uint32_t z1 = a1 << count;
	uint32_t z0 = a0 << count;
	if (0 < count) {
		register int8_t negCount = ((-count) & 31);
		z1 |= a2 >> negCount;
		z0 |= a1 >> negCount;
	}
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Adds the 64-bit value formed by concatenating `a0` and `a1` to the 64-bit value formed by concatenating `b0` and `b1`; Addition is modulo 2^64, so any carry out is lost; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void add64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* restrict z0Ptr, uint32_t* restrict z1Ptr) {
	const uint32_t z1 = a1 + b1;
	*z1Ptr = z1;
	*z0Ptr = a0 + b0 + (z1 < a1);
}


/** Adds the 96-bit value formed by concatenating `a0`, `a1`, and `a2` to the 96-bit value formed by concatenating `b0`, `b1`, and `b2`; Addition is modulo 2^96, so any carry out is lost; The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void add96(const uint32_t a0, const uint32_t a1, const uint32_t a2, const uint32_t b0, const uint32_t b1, const uint32_t b2, uint32_t* restrict z0Ptr, uint32_t* restrict z1Ptr, uint32_t* restrict z2Ptr) {
	register uint32_t z2 = a2 + b2;
	const uint8_t carry1 = (z2 < a2);
	register uint32_t z1 = a1 + b1;
	const uint8_t carry0 = (z1 < a1);
	register uint32_t z0 = a0 + b0;
	z1 = (uint32_t)(z1 + (uint32_t)carry1);
	z0 += (uint32_t)(z1 < (uint32_t)carry1);
	z0 = (uint32_t)(z0 + (uint32_t)carry0);
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Calculate `x * y` exactly and store the result in `*hi + *lo`; It is given that |X| >= |Y| and the values are small enough that no overflow occurs */
LIB_FUNC void add_split_doubles(double* hi, double* lo, const double x, const double y) {
	*hi = x + y;  // Dekker's algorithm
	*lo = (x - *hi) + y;
}


/** Subtracts the 64-bit value formed by concatenating `b0` and `b1` from the 64-bit value formed by concatenating `a0` and `a1`; Subtraction is modulo 2^64, so any borrow out (carry out) is lost; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void sub64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* restrict z0Ptr, uint32_t* restrict z1Ptr) {
	*z1Ptr = a1 - b1;
	*z0Ptr = (a0 - b0 - (a1 < b1));
}


/** Subtracts the 96-bit value formed by concatenating `b0`, `b1`, and `b2` from the 96-bit value formed by concatenating `a0`, `a1`, and `a2`; Subtraction is modulo 2^96, so any borrow out (carry out) is lost.  The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void sub96(const uint32_t a0, const uint32_t a1, const uint32_t a2, const uint32_t b0, const uint32_t b1, const uint32_t b2, uint32_t* restrict z0Ptr, uint32_t* restrict z1Ptr, uint32_t* restrict z2Ptr) {
	register uint32_t z2 = a2 - b2;
	const uint8_t borrow1 = (a2 < b2);
	register uint32_t z1 = a1 - b1;
	const uint8_t borrow0 = (a1 < b1);
	register uint32_t z0 = a0 - b0;
	z0 -= (uint32_t)(z1 < (uint32_t)borrow1);
	z1 -= (uint32_t)borrow1;
	z0 -= (uint32_t)borrow0;
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Multiply two unsigned integers and return 32 most-significant-bits as if two 64-bit integers were multiplied */
LIB_FUNC MATH_FUNC uint32_t mulhi(const uint32_t a, const uint32_t b) {
	return (uint32_t)(((uint64_t)a * (uint64_t)b) >> 32);
}


/** Multiplies `a` by `b` to obtain a 64-bit product; The product is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void mul32To64(const uint32_t a, const uint32_t b, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	const uint16_t aHigh = (uint16_t)(a >> 16);
	const uint16_t bHigh = (uint16_t)(b >> 16);
	register uint32_t z1 = ((uint32_t)a) * (uint16_t)b;
	register uint32_t zMiddleA = ((uint32_t)a) * (uint32_t)bHigh;
	const uint32_t zMiddleB = ((uint32_t)aHigh) * (uint16_t)b;
	zMiddleA += zMiddleB;
	register uint32_t z0 = (((uint32_t)aHigh) * (uint32_t)bHigh) + (((uint32_t)(zMiddleA < zMiddleB)) << 16) + (zMiddleA >> 16);
	zMiddleA <<= 16;
	*z1Ptr = z1 + zMiddleA;
	*z0Ptr = z0 + (z1 < (uint32_t)zMiddleA);
}


/** Multiplies the 64-bit value formed by concatenating `a0` and `a1` by `b` to obtain a 96-bit product; The product is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void mul64By32To96(const uint32_t a0, const uint32_t a1, const uint32_t b, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr ) {
	uint32_t z0, z1, z2, more1;
	mul32To64(a1, b, &z1, &z2);
	mul32To64(a0, b, &z0, &more1);
	add64(z0, more1, 0, z1, &z0, &z1);
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Multiplies the 64-bit value formed by concatenating `a0` and `a1` to the 64-bit value formed by concatenating `b0` and `b1` to obtain a 128-bit product; The product is broken into four 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, `z2Ptr`, and `z3Ptr` */
LIB_FUNC void mul64To128(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr, uint32_t* z3Ptr) {
	uint32_t z1, z2, z3, more2;
	mul32To64(a1, b1, &z2, &z3);
	mul32To64(a1, b0, &z1, &more2);
	add64(z1, more2, 0, z2, &z1, &z2);
	uint32_t more1, z0;
	mul32To64(a0, b0, &z0, &more1);
	add64(z0, more1, 0, z1, &z0, &z1);
	mul32To64(a0, b1, &more1, &more2);
	add64(more1, more2, 0, z2, &more1, &z2);
	add64(z0, z1, 0, more1, &z0, &z1);
	*z3Ptr = z3;
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Dot Product Algorithm (Array of 32-bit integers) */
LIB_FUNC void dot_product32(const int32_t* restrict _array1, const int32_t* restrict _array2, int32_t* output_array, const size_t _length) {
	output_array = 0;
	for (register uint32_t i = 0; i < _length; i++) { output_array += _array1[i] * _array2[i]; }
}


/** Dot Product Algorithm (Array of 64-bit integers) */
LIB_FUNC void dot_product64(const int64_t* restrict _array1, const int64_t* restrict _array2, int64_t* output_array, const size_t _length) {
	output_array = 0;
	for (register uint64_t i = 0; i < _length; i++) { output_array += _array1[i] * _array2[i]; }
}


/** Return the quotient or modulus of the unsigned division of `num` and `den` */
LIB_FUNC MATH_FUNC unsigned long udivmodsi4(const unsigned long num, const unsigned long den, const int modwanted) {
	register unsigned long bit = 1, res = 0, x = num, y = den;
	while (y < x && bit && (!(y & (1L << 31)))) {
		y <<= 1;
		bit <<= 1;
	}
	while (bit) {
		if (x >= y) {
			x -= y;
			res |= bit;
		}
		bit >>= 1;
		y >>= 1;
	}
	if (modwanted) { return x; }
	return res;
}
#define udivsi3(a, b)   udivmodsi4((a), (b), (0))
#define __udivsi3(a, b)   udivmodsi4((a), (b), (0))
#define umodsi3(a, b)   udivmodsi4((a), (b), (1))
#define __umodsi3(a, b)   udivmodsi4((a), (b), (1))


/** Return the quotient of the signed division of `x` and `y` */
LIB_FUNC MATH_FUNC long __divsi3(const long x, const long y) {
	register int neg = 0;
	register long a = x, b = y;
	if (a < 0) {
		a = -a;
		neg = (!neg);
	}
	if (b < 0) {
		b = -b;
		neg = (!neg);
	}
	register const long res = (long)udivmodsi4((unsigned long)a, (unsigned long)b, 0);
	if (neg) { return (-res); }
	return res;
}
#define divsi3(x, y)   __divsi3((x), (y))


/** Return the modulus of the signed division of `x` and `y` */
LIB_FUNC MATH_FUNC long __modsi3(const long x, const long y) {
	register int neg = 0;
	register long a = x, b = y;
	if (a < 0) {
		a = -a;
		neg = 1;
	}
	if (b < 0) { b = -b; }
	register const long res = (long)udivmodsi4((unsigned long)a, (unsigned long)b, 1);
	if (neg) { return (-res); }
	return res;
}
#define modsi3(x, y)   __modsi3((x), (y))


LIB_FUNC void fast_divide32_prepare(const uint32_t _div, uint32_t* restrict _m, uint8_t* restrict _s1, uint8_t* restrict _s2) {
	register const int _l = fls32(_div - 1);
	*_m = (uint32_t)(((uint64_t)(0x100000000ULL * ((1ULL << _l) - _div))) / _div + 1);
	*_s1 = (uint8_t)((_l > 1) ? 1 : _l);
	*_s2 = (uint8_t)((_l == 0) ? 0 : (_l - 1));
}


LIB_FUNC uint32_t fast_divide32(const uint32_t _v, const UNUSED uint32_t _div, const uint32_t _m, const uint8_t _s1, const uint8_t _s2) {
	register uint32_t _t = (uint32_t)(((uint64_t)_v * _m) >> 32);
	return (uint32_t)((_t + ((_v - _t) >> _s1)) >> _s2);
}


LIB_FUNC uint32_t fast_remainder32(const uint32_t _v, const uint32_t _div, const uint32_t _m, const uint8_t s1, const uint8_t s2) {
	return (uint32_t)(_v - _div * fast_divide32(_v, _div, _m, s1, s2));
}


/** Returns an approximation to the 32-bit integer quotient obtained by dividing `b` into the 64-bit value formed by concatenating `a0` and `a1`; The divisor `b` must be at least 2^31. If q is the exact quotient truncated toward zero, the approximation returned lies between q and q + 2 inclusive; If the exact quotient q is larger than 32 bits, the maximum positive 32-bit unsigned integer is returned */
LIB_FUNC uint32_t estimateDiv64To32(const uint32_t a0, const uint32_t a1, const uint32_t b) {
	if (b <= a0) { return UINT32_MAX; }
	const uint32_t b0 = b >> 16;
	register uint32_t z = (b0 << 16 <= a0) ? 0xffff0000 : (a0 / b0) << 16;
	uint32_t rem0, rem1, term0, term1;
	mul32To64(b, z, &term0, &term1);
	sub64(a0, a1, term0, term1, &rem0, &rem1);
	register uint32_t b1;
	while (((int32_t) rem0) < 0) {
		z -= 0x10000;
		b1 = b << 16;
		add64(rem0, rem1, b0, b1, &rem0, &rem1);
	}
	rem0 = (rem0 << 16) | (rem1 >> 16);
	return z | ((b0 << 16 <= rem0) ? UINT16_MAX : (rem0 / b0));
}


/** Return the sum of division and modulus of the two given numbers */
LIB_FUNC MATH_FUNC int div_and_mod_int(const int num1, const int num2) {
	return (((num1 / num2) + (num1 % num2)));
}


/** Packs the sign `zSign', exponent `zExp', and significand `zSig' into a
single-precision floating-point value */
LIB_FUNC MATH_FUNC float packFloat32(const int zSign, const int16_t zExp, const uint32_t zSig) {
	const float_shape_t num = { .uword = ((((uint32_t)zSign) << 31) + (((uint32_t)zExp) << 23) + zSig) };
	return num.value;
}


/** Convert a signed long long to a float-point */
LIB_FUNC MATH_FUNC SFtype __floatunsisf(const USItype u) {
	const SItype s = (SItype)u;
	if (s < 0) { return (SFtype)2.0 * (SFtype)((SItype)((u & 1) | (u >> 1))); }
	return (SFtype)s;
}


/** Convert a signed long long to a float-point */
LIB_FUNC MATH_FUNC DFtype __floatunsidf(const USItype u) {
	const SItype s = (SItype)u;
	register DFtype r = (DFtype)s;
	if (s < 0) {
		r += (DFtype)2.0 * (DFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}


#if SUPPORTS_XFTYPE
/** Convert a signed long long to a float-point */
LIB_FUNC MATH_FUNC XFtype __floatunsixf(const USItype u) {
	const SItype s = (SItype)u;
	XFtype r = (XFtype)s;
	if (s < 0) {
		r += (XFtype)2.0 * (XFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}
#endif


#if SUPPORTS_TFTYPE
/** Convert a signed long long to a float-point */
LIB_FUNC MATH_FUNC TFtype __floatunsitf(const USItype u) {
	const SItype s = (SItype)u;
	TFtype r = (TFtype)s;
	if (s < 0) {
		r += (TFtype)2.0 * (TFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}
#endif


/** Returns the fraction bits of the single-precision floating-point value `a` */
LIB_FUNC MATH_FUNC int32_t extractFloat32Frac(const float a) {
	return (int32_t)(((int32_t)a) & 0x7fffff);
}


/** Returns the exponent bits of the single-precision floating-point value `a` */
LIB_FUNC MATH_FUNC int16_t extractFloat32Exp(const float a) {
	return (int16_t)(((int16_t)a) >> 23) & 0xff;
}


/** Returns the sign bit of the single-precision floating-point value `a` */
LIB_FUNC MATH_FUNC int extractFloat32Sign(const SFtype a) {
	return (int)(((int32_t)a) >> 31);
}


/** Return 0 if a == b, 1 if a > b, -2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __gtsf2(const SFtype a, const SFtype b) {
	return -(b < a);
}
#define float32_gt(a, b)   __gtff2((a), (b))
#define _softfloat_float32_gt(a, b)   __gtff2((a), (b))


/** Return 0 if a == b, 1 if a > b, -2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __gtdf2(const DFtype a, const DFtype b) {
	return -(b < a);
}
#define float64_gt(a, b)   __gtdf2((a), (b))
#define _softfloat_float64_gt(a, b)   __gtdf2((a), (b))


#if SUPPORTS_TFTYPE
/** Return 0 if a == b, 1 if a > b, -2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __gttf2(const TFtype a, const TFtype b) {
	return -(b < a);
}
#   define float128_gt(a, b)   __gttf2((a), (b))
#   define _softfloat_float128_gt(a, b)   __gttf2((a), (b))
#endif


/** Return 0 if a == b, 1 if a > b, 2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __ltsf2(const SFtype a, const SFtype b) {
	return -(a < b);
}
#define float32_lt(a, b)   __ltsf2((a), (b))
#define _softfloat_float32_lt(a, b)   __ltsf2((a), (b))


/** Return 0 if a == b, 1 if a > b, 2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __ltdf2(const DFtype a, const DFtype b) {
	return -(a < b);
}
#define float64_lt(a, b)   __ltdf2((a), (b))
#define _softfloat_float64_lt(a, b)   __ltdf2((a), (b))


#if SUPPORTS_TFTYPE
/** Return 0 if a == b, 1 if a > b, 2 if a ? b, -1 if a < b */
LIB_FUNC MATH_FUNC int __lttf2(const TFtype a, const TFtype b) {
	return -(a < b);
}
#   define __letf2(a, b)   __lttf2((a), (b))
#   define float128_lt(a, b)   __lttf2((a), (b))
#   define _softfloat_float128_lt(a, b)   __lttf2((a), (b))
#endif


/** Returns an approximation to the square root of the 32-bit significand given by `a`; Considered as an integer, `a` must be at least 2^31; If bit 0 of `aExp` (the least significant bit) is 1, the integer returned approximates 2^31*sqrt(`a`/2^31), where `a` is considered an integer; If bit 0 of `aExp` is 0, the integer returned approximates 2^31*sqrt(`a`/2^30); In either case, the approximation returned lies strictly within +/-2 of the exact value */
LIB_FUNC int32_t estimateSqrt32(const int16_t aExp, const uint32_t a) {
	const int8_t index = (a >> 27) & 15;
	register int32_t z, x = (int32_t)a;
	if (aExp & 1) {
		z = (int32_t)((0x4000 + (a >> 17)) - (uint32_t)sqrtOddAdjustments[index]);
		z = (int32_t)((int32_t)((a / (uint32_t)z) << 14) + (int32_t)(z << 15));
		x >>= 1;
	} else {
		z = (int32_t)((int32_t)(0x8000 + (int32_t)(a >> 17)) - (int32_t)sqrtEvenAdjustments[index]);
		z = (int32_t)((a / (uint32_t)z) + (uint32_t)z);
		z = ((0x20000 <= z) ? (int32_t)0xffff8000 : (int32_t)(z << 15));
		if ((uint32_t)z <= a) { return (int32_t)(a >> 1); }
	}
	return (int32_t)((((int32_t)estimateDiv64To32((uint32_t)x, 0, (uint32_t)z)) >> 1) + (int32_t)(z >> 1));
}


/** Return `x^2 + y^2 - 1`, computed without large cancellation error; It is given that `1 > x >= y >= epsilon / 2`, and that `x^2 + y^2 >= 0.5` */
LIB_FUNC MATH_FUNC float __x2y2m1f(const float x, const float y) {
	const double dx = x, dy = y;
	return (float)((dx - 1.0) * (dx + 1.0) + dy * dy);
}


/** Integer logarithm, returns `-1` on error; Inspired by the Linux version written by David Howells */
#define _ilog2_helper(_n, _x)   ((_n) & (1ULL << (_x))) ? _x :
#define _ilog2_const(_n)   (_ilog2_helper(_n, 63) _ilog2_helper(_n, 62) _ilog2_helper(_n, 61) _ilog2_helper(_n, 60) _ilog2_helper(_n, 59) _ilog2_helper(_n, 58) _ilog2_helper(_n, 57) _ilog2_helper(_n, 56) _ilog2_helper(_n, 55) _ilog2_helper(_n, 54) _ilog2_helper(_n, 53) _ilog2_helper(_n, 52) _ilog2_helper(_n, 51) _ilog2_helper(_n, 50) _ilog2_helper(_n, 49) _ilog2_helper(_n, 48) _ilog2_helper(_n, 47) _ilog2_helper(_n, 46) _ilog2_helper(_n, 45) _ilog2_helper(_n, 44) _ilog2_helper(_n, 43) _ilog2_helper(_n, 42) _ilog2_helper(_n, 41) _ilog2_helper(_n, 40) _ilog2_helper(_n, 39) _ilog2_helper(_n, 38) _ilog2_helper(_n, 37) _ilog2_helper(_n, 36) _ilog2_helper(_n, 35) _ilog2_helper(_n, 34) _ilog2_helper(_n, 33) _ilog2_helper(_n, 32) _ilog2_helper(_n, 31) _ilog2_helper(_n, 30) _ilog2_helper(_n, 29) _ilog2_helper(_n, 28) _ilog2_helper(_n, 27) _ilog2_helper(_n, 26) _ilog2_helper(_n, 25) _ilog2_helper(_n, 24) _ilog2_helper(_n, 23) _ilog2_helper(_n, 22) _ilog2_helper(_n, 21) _ilog2_helper(_n, 20) _ilog2_helper(_n, 19) _ilog2_helper(_n, 18) _ilog2_helper(_n, 17) _ilog2_helper(_n, 16) _ilog2_helper(_n, 15) _ilog2_helper(_n, 14) _ilog2_helper(_n, 13) _ilog2_helper(_n, 12) _ilog2_helper(_n, 11) _ilog2_helper(_n, 10) _ilog2_helper(_n, 9) _ilog2_helper(_n, 8) _ilog2_helper(_n, 7) _ilog2_helper(_n, 6) _ilog2_helper(_n, 5) _ilog2_helper(_n, 4) _ilog2_helper(_n, 3) _ilog2_helper(_n, 2) _ilog2_helper(_n, 1) _ilog2_helper(_n, 0) -1)
#define __ilog2(_n)   (__builtin_constant_p(_n) ? _ilog2_const(_n) : ((sizeof(_n) > 4 ? fls64(_n) : fls32(_n)) - 1))


/** @def add_ssaaaa
`add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1, high_addend_2, low_addend_2)` adds two `UWtype` integers, composed by `sh` and `al`, and `bh` and `bl`, respectively; The result is placed in `sh` and `sl`; Overflow (i.e. carry out) is not stored anywhere and is lost */
/** @def sub_ddmmss
`sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend, high_subtrahend, low_subtrahend)` subtracts two doubleword `UWtype` integers, composed by `high_minuend` and `low_minuend`, and `high_subtrahend` and `low_subtrahend` respectively; The result is placed in `high_difference` and `low_difference`; Overflow (i.e. carry out) is not stored anywhere and is lost */
/** @def umul_ppmm
`umul_ppmm(high_prod, low_prod, multiplier, multiplicand)` multiplies two `UWtype` integers `multiplier` and `multiplicand`, and generates a two-`UWtype` word product in `high_prod` and `low_prod` */
/** @def __umulsidi3
`__umulsidi3(u, v)` multiplies two `UWtype` integers `u` and `v`, and returns a `UDWtype` product; This is a variant of `umul_ppmm()` */
/** @def udiv_qrnnd
`udiv_qrnnd(quotient, remainder, high_numerator, low_numerator, denominator)` divides a `UDWtype` (composed by the `UWtype` integers `high_numerator` and `low_numerator`) by `denominator` and places the quotient in `quotient` and the remainder in `remainder`; `high_numerator` must be less than `denominator` for correct operation; If, in addition, the most significant bit of `denominator` must be 1, then the pre-processor symbol `UDIV_NEEDS_NORMALIZATION` is defined to `1` */
/** @def _FP_STRUCT_LAYOUT
`_FP_STRUCT_LAYOUT` may be defined as an attribute to determine the struct layout variant used for structures where bit-fields are used to access specific parts of binary floating-point numbers */
/** @def HAVE_RM_CTX
Support for rounding mode context */


#ifdef ARCHALPHA  // TODO: Merge most of this code with "FPU CONTROL MACROS" (@defgroup FPU_Control_Macros)
#   define ALPHA_MATH_PRIVATE_H   (1)
#   define _ALPHA_MATH_PRIVATE_H_   (1)
#   define ALPHA_GET_ROUNDING_MODE_H   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, X); R##_c = FP_CLS_NAN; } while (0x0)
#   define FP_INIT_ROUNDMODE   do { if (PREDICT_UNLIKELY(_round == 4)) { unsigned long t; vasm("excb;" "mf_fpcr %0;" : "=f"(t)); _round = (t >> FPCR_ROUND_SHIFT) & 3; } } while (0x0)
#   define FP_HANDLE_EXCEPTIONS   do { if (PREDICT_UNLIKELY(_fex)) { __feraiseexcept(_fex); } } while (0x0)
#   define FP_TRAPPING_EXCEPTIONS   ((__ieee_get_fp_control () & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT)
#   if IS_WORDSIZE_64
#      if IS_NOT_CPLUSPLUS
#         define umul_ppmm(ph, pl, m0, m1)   do { UDItype __m0 = (m0), __m1 = (m1); (ph) = __builtin_alpha_umulh(__m0, __m1); (pl) = __m0 * __m1; } while (0x0)
#         define UMUL_TIME   46
#      endif
#      ifndef LONGLONG_STANDALONE
#         define udiv_qrnnd(q, r, n1, n0, d)   do { UDItype __r; (q) = __udiv_qrnnd(&__r, (n1), (n0), (d)); (r) = __r; } while (0x0)
#         define UDIV_TIME    220
#      endif
#   endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	unsigned long fpcr;
	vasm("excb;" "mf_fpcr %0;" : "=f"(fpcr));
	return (fpcr >> FPCR_ROUND_SHIFT) & 3;
}
#   define GET_ROUNDING_MODE_DEFINED   (1)
#endif


#ifdef ARCHARM
#   define ARM_MATH_PRIVATE_H   (1)
#   define _ARM_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   (1)
#   if IS_NOT_SOFTFP
#      define HAVE_RM_CTX   (1)
#   endif
#   ifdef ARCHAARCH64
#      define AARCH64_MATH_PRIVATE_H   (1)
#      define _AARCH64_MATH_PRIVATE_H_   (1)
#      define _AARCH64_GET_ROUNDING_MODE_H   (1)
#      ifndef HAVE_RM_CTX
#         define HAVE_RM_CTX   (1)
#      endif


typedef struct fenv_struct {
	union __union_fenv_struct {
		struct whole_fpscr { unsigned int __fpscr, __reserved0, __reserved1, __reserved2; };
		struct attr_packed fpscr {
			unsigned int __fpscr_cmp_n:1;
			unsigned int __fpscr_cmp_z:1;
			unsigned int __fpscr_cmp_c:1;
			unsigned int __fpscr_cmp_v:1;
			unsigned int __fpscr_do_not_modify_1:2;
			unsigned int __fpscr_default_nan_mode:1;
			unsigned int __fpscr_flush_to_zero:1;
			unsigned int __fpscr_rounding_mode:2;
			unsigned int __fpscr_stride:2;
			unsigned int __fpscr_do_not_modify_2:1;
			unsigned int __fpscr_len:3;
			unsigned int __fpscr_trap_enable_subnormal:1;
			unsigned int __fpscr_do_not_modfify_3:2;
			unsigned int __fpscr_trap_enable_inexact:1;
			unsigned int __fpscr_trap_enable_underflow:1;
			unsigned int __fpscr_trap_enable_overflow:1;
			unsigned int __fpscr_trap_enable_div_by_zero:1;
			unsigned int __fpscr_trap_enable_invalid:1;
			unsigned int __fpscr_fp_state_flag_subnormal:1;
			unsigned int __fpscr_do_not_modify_4:2;
			unsigned int __fpscr_fp_state_flag_inexact:1;
			unsigned int __fpscr_fp_state_flag_underflow:1;
			unsigned int __fpscr_fp_state_flag_overflow:1;
			unsigned int __fpscr_fp_state_flag_div_by_zero:1;
			unsigned int __fpscr_fp_state_flag_invalid:1;
		};
	};
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


LIB_FUNC void libc_feholdexcept_aarch64(fenv_t* fenvp) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR(fpsr);
	fenvp->__fpcr = fpcr;
	fenvp->__fpsr = fpsr;
	// Clear exception flags and set all exceptions to non-stop
	new_fpcr = fpcr & ~(FE_ALL_EXCEPT << FE_EXCEPT_SHIFT);
	new_fpsr = fpsr & (~FE_ALL_EXCEPT);
	if (PREDICT_UNLIKELY(new_fpcr != fpcr)) { _FPU_SETCW(new_fpcr); }
	if (new_fpsr != fpsr) { _FPU_SETFPSR(new_fpsr); }
}
#      define libc_feholdexcept   libc_feholdexcept_aarch64
#      define libc_feholdexceptf   libc_feholdexcept_aarch64
#      define libc_feholdexceptl   libc_feholdexcept_aarch64


LIB_FUNC void libc_fesetround_aarch64(int round) {
	fpu_control_t fpcr;
	_FPU_GETCW(fpcr);
	// Check whether rounding modes are different
	round = (fpcr ^ round) & _FPU_FPCR_RM_MASK;
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#      define libc_fesetround   libc_fesetround_aarch64
#      define libc_fesetroundf   libc_fesetround_aarch64
#      define libc_fesetroundl   libc_fesetround_aarch64


LIB_FUNC void libc_feholdexcept_setround_aarch64(fenv_t* fenvp, int round) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR (fpsr);
	fenvp->__fpcr = fpcr;
	fenvp->__fpsr = fpsr;
	// Clear exception flags, set all exceptions to non-stop, and set new rounding mode
	new_fpcr = fpcr & ~((FE_ALL_EXCEPT << FE_EXCEPT_SHIFT) | _FPU_FPCR_RM_MASK);
	new_fpcr |= round;
	new_fpsr = fpsr & (~FE_ALL_EXCEPT);
	if (PREDICT_UNLIKELY(new_fpcr != fpcr)) { _FPU_SETCW(new_fpcr); }
	if (new_fpsr != fpsr) { _FPU_SETFPSR(new_fpsr); }
}
#      define libc_feholdexcept_setround   libc_feholdexcept_setround_aarch64
#      define libc_feholdexcept_setroundf   libc_feholdexcept_setround_aarch64
#      define libc_feholdexcept_setroundl   libc_feholdexcept_setround_aarch64


LIB_FUNC int libc_fetestexcept_aarch64(int ex) {
	fpu_fpsr_t fpsr;
	_FPU_GETFPSR(fpsr);
	return ((fpsr & ex) & FE_ALL_EXCEPT);
}
#      define libc_fetestexcept   libc_fetestexcept_aarch64
#      define libc_fetestexceptf   libc_fetestexcept_aarch64
#      define libc_fetestexceptl   libc_fetestexcept_aarch64


LIB_FUNC void libc_fesetenv_aarch64(const fenv_t* fenvp) {
	fpu_control_t fpcr, new_fpcr;
	_FPU_GETCW(fpcr);
	new_fpcr = fenvp->__fpcr;
	if (PREDICT_UNLIKELY(fpcr != new_fpcr)) { _FPU_SETCW(new_fpcr); }
	_FPU_SETFPSR(fenvp->__fpsr);
}
#      define libc_fesetenv   libc_fesetenv_aarch64
#      define libc_fesetenvf   libc_fesetenv_aarch64
#      define libc_fesetenvl   libc_fesetenv_aarch64
#      define libc_feresetround_noex   libc_fesetenv_aarch64
#      define libc_feresetround_noexf   libc_fesetenv_aarch64
#      define libc_feresetround_noexl   libc_fesetenv_aarch64


LIB_FUNC int libc_feupdateenv_test_aarch64(const fenv_t* fenvp, int ex) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	int excepts;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR (fpsr);
	// Merge current exception flags with the saved fenv
	excepts = fpsr & FE_ALL_EXCEPT;
	new_fpcr = fenvp->__fpcr;
	new_fpsr = fenvp->__fpsr | excepts;
	if (PREDICT_UNLIKELY(fpcr != new_fpcr)) { _FPU_SETCW(new_fpcr); }
	if (fpsr != new_fpsr) { _FPU_SETFPSR(new_fpsr); }
	// Raise the exceptions if enabled in the new FP state
	if (PREDICT_UNLIKELY(excepts & (new_fpcr >> FE_EXCEPT_SHIFT))) { __feraiseexcept(excepts); }
	return excepts & ex;
}
#      define libc_feupdateenv_test   libc_feupdateenv_test_aarch64
#      define libc_feupdateenv_testf   libc_feupdateenv_test_aarch64
#      define libc_feupdateenv_testl   libc_feupdateenv_test_aarch64


LIB_FUNC void libc_feupdateenv_aarch64(const fenv_t* fenvp) {
	libc_feupdateenv_test_aarch64(fenvp, 0);
}
#      define libc_feupdateenv   libc_feupdateenv_aarch64
#      define libc_feupdateenvf   libc_feupdateenv_aarch64
#      define libc_feupdateenvl   libc_feupdateenv_aarch64


LIB_FUNC void libc_feholdsetround_aarch64(fenv_t* fenvp, int round) {
	fpu_control_t fpcr;
	fpu_fpsr_t fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR(fpsr);
	fenvp->__fpcr = fpcr;
	fenvp->__fpsr = fpsr;
	// Check whether rounding modes are different
	round = (fpcr ^ round) & _FPU_FPCR_RM_MASK;
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#      define libc_feholdsetround   libc_feholdsetround_aarch64
#      define libc_feholdsetroundf   libc_feholdsetround_aarch64
#      define libc_feholdsetroundl   libc_feholdsetround_aarch64


LIB_FUNC void libc_feresetround_aarch64(fenv_t* fenvp) {
	fpu_control_t fpcr;
	int round;
	_FPU_GETCW(fpcr);
	// Check whether rounding modes are different
	round = (fenvp->__fpcr ^ fpcr) & _FPU_FPCR_RM_MASK;
	// Restore the rounding mode if it was changed
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#      define libc_feresetround   libc_feresetround_aarch64
#      define libc_feresetroundf   libc_feresetround_aarch64
#      define libc_feresetroundl   libc_feresetround_aarch64
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#      define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#      define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      define _FP_QNANNEGATEDP   0
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) | _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs) { R##_s = _FP_NANSIGN_##fs; _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#      define _FP_DECL_EX   fpu_control_t _fcw
#      define FP_ROUNDMODE   (_fcw & _FPU_FPCR_RM_MASK)
#      define FP_INIT_ROUNDMODE   do { _FPU_GETCW (_fcw); } while (0x0)
#      define FP_HANDLE_EXCEPTIONS   do { const float fp_max = __FLT_MAX__; const float fp_min = __FLT_MIN__, const float fp_1e32 = 1.0E+32F, fp_zero = 0.0F, fp_one = 1.0F; unsigned fpsr; if (_fex & FP_EX_INVALID) { vasm("fdivts0, %s0, %s0;" : : "w"(fp_zero) : "s0"); vasm("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_DIVZERO) { vasm("fdivts0, %s0, %s1;" : : "w"(fp_one), "w"(fp_zero) : "s0"); vasm("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_OVERFLOW) { vasm("faddts0, %s0, %s1;" : : "w"(fp_max), "w"(fp_1e32) : "s0"); vasm("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_UNDERFLOW) { vasm("fmults0, %s0, %s0;" : : "w"(fp_min) : "s0"); vasm("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_INEXACT) { vasm("fsubts0, %s0, %s1;" : : "w"(fp_max), "w"(fp_one) : "s0"); vasm("mrst%0, fpsr;" : "=r"(fpsr)); } } while (0x0)
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fpcr;
	_FPU_GETCW(fpcr);
	return (int)(fpcr & _FPU_FPCR_RM_MASK);
}
#      define GET_ROUNDING_MODE_DEFINED   (1)
#   elif defined(ARCHAARCH32)
#      define _ARM_GET_ROUNDING_MODE_H   (1)


typedef unsigned short   fexcept_t;


typedef struct fenv_struct {
	union __union_fenv_struct {
		struct whole_fpscr { unsigned int __fpscr, __reserved0, __reserved1, __reserved2; };
		struct attr_packed fpscr {
			unsigned int __fpscr_cmp_n:1;
			unsigned int __fpscr_cmp_z:1;
			unsigned int __fpscr_cmp_c:1;
			unsigned int __fpscr_cmp_v:1;
			unsigned int __fpscr_do_not_modify_1:2;
			unsigned int __fpscr_default_nan_mode:1;
			unsigned int __fpscr_flush_to_zero:1;
			unsigned int __fpscr_rounding_mode:2;
			unsigned int __fpscr_stride:2;
			unsigned int __fpscr_do_not_modify_2:1;
			unsigned int __fpscr_len:3;
			unsigned int __fpscr_trap_enable_subnormal:1;
			unsigned int __fpscr_do_not_modfify_3:2;
			unsigned int __fpscr_trap_enable_inexact:1;
			unsigned int __fpscr_trap_enable_underflow:1;
			unsigned int __fpscr_trap_enable_overflow:1;
			unsigned int __fpscr_trap_enable_div_by_zero:1;
			unsigned int __fpscr_trap_enable_invalid:1;
			unsigned int __fpscr_fp_state_flag_subnormal:1;
			unsigned int __fpscr_do_not_modify_4:2;
			unsigned int __fpscr_fp_state_flag_inexact:1;
			unsigned int __fpscr_fp_state_flag_underflow:1;
			unsigned int __fpscr_fp_state_flag_overflow:1;
			unsigned int __fpscr_fp_state_flag_div_by_zero:1;
			unsigned int __fpscr_fp_state_flag_invalid:1;
		};
	};
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


extern const UNUSED fenv_t _FE_DFL_ENV = { { 0, 0, 0, 0 } };
/** Pointer to default FP environment */
#      define FE_DFL_ENV   &_FE_DFL_ENV


LIB_FUNC int _fesetexceptflag(const fexcept_t* flagp, const int excepts) {
	register uint32_t _fpscr = GET_FPSCR();
	excepts &= (FE_ALL_EXCEPT | 0x8000);
	_fpscr = ((fpscr & (~excepts)) | (*flagp & excepts));
	SET_FPSCR(_fpscr);
	return 0;
}


LIB_FUNC int _fegetexceptflag(fexcept_t* flagp, const int excepts) {
	register uint32_t _fpscr = GET_FPSCR();
	*flagp = (_fpscr & excepts);
	return 0;
}
#      define fegetexceptflag(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#      define fesetexceptflag(flagp, excepts)   _fesetexceptflag((flagp), (excepts))
#      define fegetexcept(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#      define fesetexcept(flagp, excepts)   _fesetexceptflag((flagp), (excepts))


LIB_FUNC int feclearexcept(const int excepts) {
	fexcept_t zero = 0;
	return _fesetexceptflag(&zero, excepts);
}


LIB_FUNC int feraiseexcept(const int excepts) {
	register int inexact_set = 0;
	if (excepts & FE_OVERFLOW) {
		required_add_float(0x1.0P+127F, 0x1.0P+127F);
		inexact_set = 1;
	}
	if (excepts & FE_UNDERFLOW) {
		required_multiply_float(0x1.0P-126F, 0x1.0P-126F);
		inexact_set = 1;
	}
	if (excepts & FE_INVALID) { required_add_float(INFINITY, (-INFINITY)); }
	if (excepts & FE_DIVBYZERO) { required_divide_float(1.0F, 0.0F); }
	if (0 != (excepts & FE_INEXACT) && 0 == inexact_set) { required_add_float(0x1.0P+127F, 1.0F); }
	return 0;
}


LIB_FUNC int fetestexcept(const int excepts) {
	fexcept_t t = 0;
	_fegetexceptflag(&t, excepts);
	return t;
}


LIB_FUNC int fegetround(void) {
	register int32_t fpscr = GET_FPSCR();
	return (int)(fpscr & FE_ALL_RND);
}


LIB_FUNC int fesetround(const int round) {
	if ((round & FE_ALL_RND) != round) { return round; }
	register int32_t _fpscr = GET_FPSCR();
	_fpscr = ((_fpscr & (~FE_ALL_RND)) | (round & FE_ALL_RND));
	SET_FPSCR(_fpscr);
	return 0;
}


LIB_FUNC int fegetenv(fenv_t* fenvp) {
	fenvp->__fpscr = GET_FPSCR();
	fenvp->__reserved0 = 0;
	fenvp->__reserved1 = 0;
	fenvp->__reserved2 = 0;
	return 0;
}


LIB_FUNC int feholdexcept(fenv_t* fenvp) {
	register uint32_t fpscr = GET_FPSCR();
	fenvp->__fpscr = fpscr;
	fenvp->__reserved0 = 0;
	fenvp->__reserved1 = 0;
	fenvp->__reserved2 = 0;
	_fpscr &= (~(FE_ALL_EXCEPT | (FE_ALL_EXCEPT << 8)));
	SET_FPSCR(_fpscr);
	return 0;
}


LIB_FUNC int fesetenv(const fenv_t* fenvp) {
	SET_FPSCR(fenvp->__fpscr);
	return 0;
}


LIB_FUNC int feupdateenv(const fenv_t* fenvp) {
	register uint32_t oldenv = GET_FPSCR();
	SET_FPSCR(fenvp->__fpscr);
	register int inexact_set = 0;
	if (oldenv & FE_OVERFLOW) {
		required_add_float(0x1.0P+127F, 0x1.0P+127F);
		inexact_set = 1;
	}
	if (oldenv & FE_UNDERFLOW) {
		required_multiply_float(0x1.0P-126F, 0x1.0P-126F);
		inexact_set = 1;
	}
	if (oldenv & FE_INVALID) { required_add_float(INFINITY, (-INFINITY)); }
	if (oldenv & FE_DIVBYZERO) { required_divide_float(1.0F, 0.0F); }
	if (0 != (oldenv & FE_INEXACT) && 0 == inexact_set) { required_add_float(0x1.0P+127F, 1.0F); }
	return 0;
}
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   _FP_QNANBIT_S
#      define _FP_NANFRAC_D   _FP_QNANBIT_D, 0
#      define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0, 0, 0
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      define _FP_QNANNEGATEDP   0
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#      if (defined(ARM_THUMB2) || (!defined(ARM_THUMB1)))
#         define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("adds %1, %4, %5ntadc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%r"((USItype)(ah)), "r,I"((USItype)(bh)), "%r"((USItype)(al)), "r,I"((USItype) (bl)) __CLOBBER_CC)
#         define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("subs %1, %4, %5ntsbc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "r"((USItype)(ah)), "r,I"((USItype)(bh)), "r"((USItype)(al)), "r,I"((USItype)(bl)) __CLOBBER_CC)
#         if (defined(__ARM_ARCH_2__) || defined(__ARM_ARCH_2A__) || defined(__ARM_ARCH_3__))
#            define umul_ppmm(xh, xl, a, b)   do { register USItype __t0, __t1, __t2; asm ("%@ Inlined umul_ppmm;" "mov %2, %5, lsr #      16;" "mov %0, %6, lsr #      16;" "bic %3, %5, %2, lsl #      16;" "bic %4, %6, %0, lsl #      16;" "mul %1, %3, %4;" "mul %4, %2, %4;" "mul %3, %0, %3;" "mul %0, %2, %0;" "adds %3, %4, %3;" "addcs %0, %0, #      65536;" "adds %1, %1, %3, lsl #      16;" "adc %0, %0, %3, lsr #      16;" : "=&r"((USItype)(xh)), "=r"((USItype)(xl)), "=&r"(__t0), "=&r"(__t1), "=r"(__t2) : "r"((USItype)(a)), "r"((USItype)(b)) __CLOBBER_CC ); } while (0x0)
#            define UMUL_TIME   20
#         else
#            define umul_ppmm(xh, xl, a, b)   do { register UDItype __t0 = (UDItype)(USItype)(a) * (USItype)(b); (xl) = (USItype)__t0; (xh) = (USItype)(__t0 >> 32); } while (0x0)
#            define UMUL_TIME   3
#         endif
#         define UDIV_TIME   100
#      endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t _fpscr;
	if (!ARM_HAVE_VFP) { return FE_TONEAREST; }
	_FPU_GETCW(_fpscr);
	return (int)(_fpscr & _FPU_MASK_RM);
}
#      define GET_ROUNDING_MODE_DEFINED   (1)
#   endif
LIB_FUNC void libc_feholdexcept_vfp(fenv_t* fenvp) {
	fpu_control_t _fpscr;
	_FPU_GETCW(_fpscr);
	fenvp->__cw = _fpscr;
	// Clear exception flags and set all exceptions to non-stop
	_fpscr &= (~_FPU_MASK_EXCEPT);
	_FPU_SETCW(_fpscr);
}


LIB_FUNC void libc_fesetround_vfp(int round) {
	fpu_control_t _fpscr;
	_FPU_GETCW(_fpscr);
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY((_fpscr & _FPU_MASK_RM) != round)) { _FPU_SETCW((_fpscr & (~_FPU_MASK_RM)) | round); }
}


LIB_FUNC void libc_feholdexcept_setround_vfp(fenv_t* fenvp, int round) {
	fpu_control_t _fpscr;
	_FPU_GETCW(_fpscr);
	fenvp->__cw = _fpscr;
	// Clear exception flags, set all exceptions to non-stop, and set new rounding mode
	_fpscr &= ~(_FPU_MASK_EXCEPT | _FPU_MASK_RM);
	_FPU_SETCW(_fpscr | round);
}


LIB_FUNC void libc_feholdsetround_vfp (fenv_t* fenvp, int round) {
	fpu_control_t _fpscr;
	_FPU_GETCW(_fpscr);
	fenvp->__cw = _fpscr;
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY((_fpscr & _FPU_MASK_RM) != round)) {
		_FPU_SETCW((_fpscr & ~_FPU_MASK_RM) | round);
	}
}


LIB_FUNC void libc_feresetround_vfp(fenv_t* fenvp) {
	fpu_control_t _fpscr, round;
	_FPU_GETCW(_fpscr);
	// Check whether rounding modes are different
	round = (fenvp->__cw ^ _fpscr) & _FPU_MASK_RM;
	// Restore the rounding mode if it was changed
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(_fpscr ^ round); }
}


LIB_FUNC int libc_fetestexcept_vfp(int ex) {
	fpu_control_t _fpscr;
	_FPU_GETCW(_fpscr);
	return ((_fpscr & ex) & FE_ALL_EXCEPT);
}


LIB_FUNC void libc_fesetenv_vfp(const fenv_t* fenvp) {
	fpu_control_t _fpscr, new_fpscr;
	_FPU_GETCW(_fpscr);
	new_fpscr = fenvp->__cw;
	// Write new FPSCR if different (ignoring NZCV flags)
	if (PREDICT_UNLIKELY(((_fpscr ^ new_fpscr) & (~_FPU_MASK_NZCV)) != 0))
	_FPU_SETCW(new_fpscr);
}


LIB_FUNC int libc_feupdateenv_test_vfp(const fenv_t* fenvp, int ex) {
	fpu_control_t _fpscr, new_fpscr;
	int excepts;
	_FPU_GETCW(_fpscr);
	// Merge current exception flags with the saved fenv
	excepts = _fpscr & FE_ALL_EXCEPT;
	new_fpscr = fenvp->__cw | excepts;
	// Write new FPSCR if different (ignoring NZCV flags)
	if (PREDICT_UNLIKELY(((_fpscr ^ new_fpscr) & (~_FPU_MASK_NZCV)) != 0)) {
		_FPU_SETCW(new_fpscr);
	}
	// Raise the exceptions if enabled in the new FP state
	if (PREDICT_UNLIKELY(excepts & (new_fpscr >> FE_EXCEPT_SHIFT))) {
		__feraiseexcept(excepts);
	}
	return excepts & ex;
}


LIB_FUNC void libc_feupdateenv_vfp(const fenv_t* fenvp) {
	libc_feupdateenv_test_vfp(fenvp, 0);
}


#   if IS_NOT_SOFTFP
#      define libc_feholdexcept   libc_feholdexcept_vfp
#      define libc_feholdexceptf   libc_feholdexcept_vfp
#      define libc_feholdexceptl   libc_feholdexcept_vfp
#      define libc_fesetround   libc_fesetround_vfp
#      define libc_fesetroundf   libc_fesetround_vfp
#      define libc_fesetroundl   libc_fesetround_vfp
#      define libc_feresetround   libc_feresetround_vfp
#      define libc_feresetroundf   libc_feresetround_vfp
#      define libc_feresetroundl   libc_feresetround_vfp
#      define libc_feresetround_noex   libc_fesetenv_vfp
#      define libc_feresetround_noexf   libc_fesetenv_vfp
#      define libc_feresetround_noexl   libc_fesetenv_vfp
#      define libc_feholdexcept_setround   libc_feholdexcept_setround_vfp
#      define libc_feholdexcept_setroundf   libc_feholdexcept_setround_vfp
#      define libc_feholdexcept_setroundl   libc_feholdexcept_setround_vfp
#      define libc_feholdsetround   libc_feholdsetround_vfp
#      define libc_feholdsetroundf   libc_feholdsetround_vfp
#      define libc_feholdsetroundl   libc_feholdsetround_vfp
#      define libc_fetestexcept   libc_fetestexcept_vfp
#      define libc_fetestexceptf   libc_fetestexcept_vfp
#      define libc_fetestexceptl   libc_fetestexcept_vfp
#      define libc_fesetenv   libc_fesetenv_vfp
#      define libc_fesetenvf   libc_fesetenv_vfp
#      define libc_fesetenvl   libc_fesetenv_vfp
#      define libc_feupdateenv   libc_feupdateenv_vfp
#      define libc_feupdateenvf   libc_feupdateenv_vfp
#      define libc_feupdateenvl   libc_feupdateenv_vfp
#      define libc_feupdateenv_test   libc_feupdateenv_test_vfp
#      define libc_feupdateenv_testf   libc_feupdateenv_test_vfp
#      define libc_feupdateenv_testl   libc_feupdateenv_test_vfp
#   endif
#endif


#if (defined(ARCHARC) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add.f %1, %4, %5ntadc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%r"((USItype)(ah)), "rIJ"((USItype)(bh)), "%r"((USItype)(al)), "rIJ"((USItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub.f %1, %4, %5ntsbc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "r"((USItype)(ah)), "rIJ"((USItype)(bh)), "r"((USItype)(al)), "rIJ"((USItype)(bl)))
#   define __umulsidi3(u, v)   ((UDItype)(USItype)u*(USItype)v)
#   if (defined(__ARC_NORM__) && (!defined(count_leading_zeros)))
#      define count_leading_zeros2(count, x)  do { SItype c_; asm ("norm.ft%0, %1ntmov.mit%0,-1;" : "=r"(c_) : "r"(x) : "cc"); (count) = c_ + 1; } while (0x0)
#   endif
#endif


#ifdef ARCHCRIS
#   if (__CRIS_arch_version >= 10)
#      define __umulsidi3(u, v)   ((UDItype)(USItype)(u) * (UDItype)(USItype)(v))
#   endif
#   define umul_ppmm(w1, w0, u, v)   do { const UDItype __x = __umulsidi3(u, v); (w0) = (USItype)(__x); (w1) = (USItype)(__x >> 32); } while (0x0)
#endif


#if (defined(ARCHCOLDFIRE) || defined(ARCHM68K))
#   define COLDFIRE_MATH_PRIVATE_H   (1)
#   define M68K_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   (1)
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) &_FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#endif


#if (defined(ARCHI960) && IS_WORDSIZE_32)
#   define umul_ppmm(w1, w0, u, v)   __extension__ ({ union __union_umul_ppmm { UDItype __ll; struct { USItype __l, __h;} __i; } __xx; asm ("emul %2, %1, %0;" : "=d"(__xx.__ll) : "%dI"((USItype)(u)), "dI"((USItype)(v))); (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
#   define __umulsidi3(u, v)   __extension__ ({ UDItype __w; asm ("emul %2, %1, %0;" : "=d"(__w) : "%dI"((USItype)(u)), "dI"((USItype)(v))); __w; })
#endif


#ifdef ARCHITANIUM
#   define ITANIUM_MATH_PRIVATE_H   (1)
#   define _ITANIUM_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define IA64_GET_ROUNDING_MODE_H   (1)


typedef unsigned long   fexcept_t;
typedef unsigned long   fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#   define FE_DFL_ENV   ((const fenv_t*)0xc009804c0270033fUL)
#   if IS_WORDSIZE_64
#      define sub_ddmmss(sh, sl, ah, al, bh, bl)   do { const UWtype __x = (al) - (bl); if ((al) < (bl)) { (sh) = (ah) - (bh) - 1; } else { (sh) = (ah) - (bh); } (sl) = __x; } while (0x0)
#      define umul_ppmm(ph, pl, m0, m1)   asm ("xma.hu %0 = %2, %3, f0ntxma.l %1 = %2, %3, f0;" : "=&f"(ph), "=f"(pl) : "f"(m0), "f"(m1))
#      define UMUL_TIME   14
#   endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fenv_t fpsr;
	vasm("mov.m %0=ar.fpsr;" : "=r"(fpsr));
	return (int)((fpsr >> 10) & 3);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)
#endif


#ifdef ARCHMICROBLAZE
#   define MICROBLAZE_MATH_PRIVATE_H   (1)
#   define _MICROBLAZE_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   (1)
#   define libc_fesetround(rnd)   __extension__ ({ 0; })
#   define libc_fetestexcept(exc)   __extension__ ({ 0; })
#   define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#   define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#   define feraiseexcept(excepts)   __extension__ ({ 0; })
#   define __feraiseexcept(excepts)   __extension__ ({ 0; })
#   define feclearexcept(exc)   __extension__ ({ 0; })
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) &_FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#endif


#ifdef ARCHMIPS
#   define MIPS_MATH_PRIVATE_H   (1)
#   define _MIPS_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   1
#   define HAVE_RM_CTX   1

#   if IS_HARDFP


LIB_FUNC void libc_feholdexcept_mips(fenv_t* fenvp) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Save the current state
	fenvp->__fp_control_register = cw;
	cw &= (~(_FPU_MASK_ALL));  // Clear all exception enable bits and flags
	_FPU_SETCW (cw);
}
#   define libc_feholdexcept   libc_feholdexcept_mips
#   define libc_feholdexceptf   libc_feholdexcept_mips
#   define libc_feholdexceptl   libc_feholdexcept_mips


LIB_FUNC void libc_fesetround_mips(int round) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Get current state
	cw &= (~_FPU_RC_MASK);  // Set rounding bits
	cw |= round;
	_FPU_SETCW(cw);  // Set new state
}
#   define libc_fesetround   libc_fesetround_mips
#   define libc_fesetroundf   libc_fesetround_mips
#   define libc_fesetroundl   libc_fesetround_mips


LIB_FUNC void libc_feholdexcept_setround_mips(fenv_t* fenvp, const int round) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Save the current state
	fenvp->__fp_control_register = cw;
	cw &= (~(_FPU_MASK_ALL));  // Clear all exception enable bits and flags
	cw &= (~_FPU_RC_MASK);  // Set rounding bits
	cw |= round;
	_FPU_SETCW(cw);  // Set new state
}
#   define libc_feholdexcept_setround   libc_feholdexcept_setround_mips
#   define libc_feholdexcept_setroundf   libc_feholdexcept_setround_mips
#   define libc_feholdexcept_setroundl   libc_feholdexcept_setround_mips
#   define libc_feholdsetround   libc_feholdexcept_setround_mips
#   define libc_feholdsetroundf   libc_feholdexcept_setround_mips
#   define libc_feholdsetroundl   libc_feholdexcept_setround_mips


LIB_FUNC void libc_fesetenv_mips(fenv_t* fenvp) {
	UNUSED fpu_control_t cw;
	_FPU_GETCW(cw);  // Read current state to flush fpu pipeline
	_FPU_SETCW(fenvp->__fp_control_register);
}
#   define libc_fesetenv   libc_fesetenv_mips
#   define libc_fesetenvf   libc_fesetenv_mips
#   define libc_fesetenvl   libc_fesetenv_mips


LIB_FUNC int libc_feupdateenv_test_mips(fenv_t* fenvp, const int excepts) {
	int cw, temp;
	_FPU_GETCW(cw);  // Get current control word
	temp = cw & FE_ALL_EXCEPT;
	temp |= (fenvp->__fp_control_register | (temp << CAUSE_SHIFT));
	_FPU_SETCW(temp);  // Set new state
	return ((cw & excepts) & FE_ALL_EXCEPT);
}
#   define libc_feupdateenv_test   libc_feupdateenv_test_mips
#   define libc_feupdateenv_testf   libc_feupdateenv_test_mips
#   define libc_feupdateenv_testl   libc_feupdateenv_test_mips


LIB_FUNC void libc_feupdateenv_mips(fenv_t* fenvp) {
	libc_feupdateenv_test_mips(fenvp, 0);
}
#   define libc_feupdateenv   libc_feupdateenv_mips
#   define libc_feupdateenvf   libc_feupdateenv_mips
#   define libc_feupdateenvl   libc_feupdateenv_mips
#   define libc_feresetround   libc_feupdateenv_mips
#   define libc_feresetroundf   libc_feupdateenv_mips
#   define libc_feresetroundl   libc_feupdateenv_mips


LIB_FUNC int libc_fetestexcept_mips(const int excepts) {
	int cw;
	_FPU_GETCW(cw);  // Get current control word
	return ((cw & excepts) & FE_ALL_EXCEPT);
}
#   define libc_fetestexcept   libc_fetestexcept_mips
#   define libc_fetestexceptf   libc_fetestexcept_mips
#   define libc_fetestexceptl   libc_fetestexcept_mips


#   endif  // IS_HARDFP

#   ifdef ARCHMIPS64
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#      ifdef __STDC_IEC_559__
#         define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#         define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#         define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#      else
#         define _FP_NANFRAC_S   (_FP_QNANBIT_S - 1)
#         define _FP_NANFRAC_D   (_FP_QNANBIT_D - 1)
#         define _FP_NANFRAC_Q   (_FP_QNANBIT_Q - 1), -1
#      endif
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      ifdef __STDC_IEC_559__
#         define _FP_QNANNEGATEDP   0
#      else
#         define _FP_QNANNEGATEDP   1
#      endif
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_ #      #       fs(X) | _FP_FRAC_HIGH_RAW_ #      #       fs(Y)) & _FP_QNANBIT_ #      #       fs) { R #      #       _s = _FP_NANSIGN_ #      #       fs; _FP_FRAC_SET_ #      #       wc(R, _FP_NANFRAC_ #      #       fs); } else { R #      #       _s = X #      #       _s; _FP_FRAC_COPY_ #      #       wc(R, X); } R #      #       _c = FP_CLS_NAN; } while (0x0)
#      define _FP_DECL_EX   fpu_control_t _fcw
#      define FP_ROUNDMODE   (_fcw & 0x3)
#      if IS_HARDFP
#         define FP_INIT_ROUNDMODE   do { _FPU_GETCW (_fcw); } while (0x0)
#         define FP_HANDLE_EXCEPTIONS   __extension__ ({ if (PREDICT_UNLIKELY(_fex)) { _FPU_SETCW (_fcw | _fex | (_fex << 10)); } })
#         define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 5) & 0x7c)
#      else
#         define FP_INIT_ROUNDMODE   _fcw = FP_RND_NEAREST
#      endif
#   elif defined(ARCHMIPS32)
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(S, R, X, Y)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#      ifdef __STDC_IEC_559__
#         define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#         define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#         define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#      else
#         define _FP_NANFRAC_S   (_FP_QNANBIT_S - 1)
#         define _FP_NANFRAC_D   (_FP_QNANBIT_D - 1), -1
#         define _FP_NANFRAC_Q   (_FP_QNANBIT_Q - 1), -1, -1, -1
#      endif
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      ifdef __STDC_IEC_559__
#         define _FP_QNANNEGATEDP   0
#      else
#         define _FP_QNANNEGATEDP   1
#      endif
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) | _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs) { R##_s = _FP_NANSIGN_ #      #       fs; _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#      define umul_ppmm(w1, w0, u, v)   do { UDItype __x = (UDItype) (USItype) (u) * (USItype) (v); (w1) = (USItype)(__x >> 32); (w0) = (USItype)(__x); } while (0x0)
#      define UMUL_TIME   10
#      define UDIV_TIME   100
#   endif
#endif


#ifdef ARCHNIOS2
#   define NIO2_MATH_PRIVATE_H   (1)
#   define _NIO2_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   (1)
#   define libc_fesetround(rnd)   __extension__ ({ 0; })
#   define libc_fetestexcept(exc)   __extension__ ({ 0; })
#   define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#   define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#   define feraiseexcept(excepts)   __extension__ ({ 0; })
#   define __feraiseexcept(excepts)   __extension__ ({ 0; })
#   define feclearexcept(exc)   __extension__ ({ 0; })
#   define _FP_W_TYPE   unsigned long
#   define _FP_WS_TYPE   signed long
#   define _FP_I_TYPE   long
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_ #   #    fs(X) & _FP_QNANBIT_ #   #    fs) && !(_FP_FRAC_HIGH_RAW_ #   #    fs(Y) & _FP_QNANBIT_ #   #    fs)) { R #   #    _s = Y #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, Y); } else { R #   #    _s = X #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, X); } R #   #    _c = FP_CLS_NAN; } while (0x0)
#   define _FP_TININESS_AFTER_ROUNDING   0
#endif


#ifdef ARCHPARISC
#   define _HPPA_GET_ROUNDING_MODE_H   (1)
#   define HPPA_MATH_PRIVATE_H   (1)
/** One of the few architectures where the meaning of the quiet/signaling bit is inverse to IEEE 754-2008 (as well as common practice for IEEE 754-1985) */
#   define HIGH_ORDER_BIT_IS_SET_FOR_SNAN   (1)
#   if IS_WORDSIZE_32
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add %4, %5, %1ntaddc %2, %3, %0;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%rM"((USItype)(ah)), "rM"((USItype)(bh)), "%rM"((USItype)(al)), "rM"((USItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub %4, %5, %1ntsubb %2, %3, %0;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "rM"((USItype)(ah)), "rM"((USItype)(bh)), "rM"((USItype)(al)), "rM"((USItype)(bl)))
#   ifdef _PA_RISC1_1
#      define umul_ppmm(w1, w0, u, v)   do { union __union_umul_ppmm { UDItype __f; struct { USItype __w1, __w0;} __w1w0; } __t; asm ("xmpyu %1, %2, %0;" : "=x"(__t.__f) : "x"((USItype)(u)), "x"((USItype)(v))); (w1) = __t.__w1w0.__w1; (w0) = __t.__w1w0.__w0; } while (0x0)
#      define UMUL_TIME   8
#   else
#      define UMUL_TIME   30
#   endif
#   define UDIV_TIME   40
#   define count_leading_zeros_hppa(count, x)   do { USItype __tmp; asm ("ldi 1, %0n" "extru,= %1,15,16, %%r0;" "extru,tr %1,15,16, %1;" "ldo 16(%0), %0;" "extru,= %1,23,8, %%r0;" "extru,tr %1,23,8, %1;" "ldo 8(%0), %0;" "extru,= %1,27,4, %%r0;" "extru,tr %1,27,4, %1;" "ldo 4(%0), %0;" "extru,= %1,29,2, %%r0;" "extru,tr %1,29,2, %1;" "ldo 2(%0), %0;" "extru %1,30,1, %1;" "sub %0, %1, %0;" : "=r"(count), "=r"(__tmp) : "1"(x)); } while (0x0)
#   endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fc;
	_FPU_GETCW(fc);
	return (int)(fc & _FPU_HPPA_MASK_RM);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)
#endif


#ifdef ARCHPOWERPC
#   define PPC_MATH_PRIVATE_H   (1)
#   define _PPC_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define _POWERPC_NOFPU_GET_ROUNDING_MODE_H   (1)


#   define HAVE_RM_CTX   (1)


typedef unsigned int   fenv_t;
typedef unsigned int   fexcept_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


/** Default FPU environment object */
extern const UNUSED fenv_t   _FE_DFL_ENV;
typedef union fenv_union {
	fenv_t fenv;
	unsigned long long l;
} fenv_union_t;


/** Pointer to default FPU environment */
#   define FE_DFL_ENV   &_FE_DFL_ENV
/** Alias for the FPU environment object */
#   define __fe_dfl_env   FE_DFL_ENV


LIB_FUNC void libc_feholdexcept_ppc(fenv_t* fenvp) {
	fenv_union_t old, new;
	old.fenv = *fenvp = fegetenv_register();
	new.l = old.l & _FPU_MASK_ROUNDING;
	if ((old.l & _FPU_MASK_ALL) != 0) { (void)__fe_mask_env(); }
	fesetenv_register(new.fenv);
}


LIB_FUNC void libc_fesetround_ppc(int r) {
	__fesetround_inline(r);
}


LIB_FUNC void libc_feholdexcept_setround_ppc(fenv_t* fenvp, const int r) {
	fenv_union_t old, new;
	old.fenv = *fenvp = fegetenv_register();
	new.l = (old.l & _FPU_MASK_ROUNDING) | r;
	if ((old.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(new.fenv);
}


LIB_FUNC int libc_fetestexcept_ppc(int e) {
	fenv_union_t u = { .fenv = fegetenv_register() };
	return u.l & e;
}


LIB_FUNC void libc_fesetenv_ppc(const fenv_t* fenvp) {
	fenv_union_t new = { .fenv = *fenvp };
	fenv_union_t old = { .fenv = fegetenv_register() };
	// If the old env has no enabled exceptions and the new env has any enabled exceptions, then unmask SIGFPE in the MSR FE0/FE1 bits. This will put the hardware into "precise mode" and may cause the FPU to run slower on some hardware
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	// If the old env had any enabled exceptions and the new env has no enabled exceptions, then mask SIGFPE in the MSR FE0/FE1 bits. This may allow the FPU to run faster because it always takes the default action and can not generate SIGFPE
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(*fenvp);
}


LIB_FUNC int libc_feupdateenv_test_ppc(fenv_t* fenvp, int ex) {
	fenv_union_t new = { .fenv = *fenvp };
	fenv_union_t old = { .fenv = fegetenv_register() };
	// Restore rounding mode and exception enable from *fenvp and merge exceptions. Leave fraction rounded/inexact and FP result/CC bits unchanged
	new.l = (old.l & _FPU_MASK_EXCEPT_ROUND) | (new.l & _FPU_MASK_FRAC_INEX_RET_CC);
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(new.fenv);
	return old.l & ex;
}


LIB_FUNC void libc_feupdateenv_ppc(fenv_t* e) {
	libc_feupdateenv_test_ppc(e, 0);
}


LIB_FUNC void libc_feholdsetround_ppc(fenv_t* fenvp, int r) {
	fenv_union_t old = { .fenv = fegetenv_register() };
	/** Clear current precision and set newer one */
	fenv_union_t new = { .l = (old.l & (~3)) | r };
	*fenvp = old.fenv;
	if ((old.l & _FPU_MASK_ALL) != 0)
	(void)__fe_mask_env();
	fesetenv_register(new.fenv);
}


LIB_FUNC void libc_feresetround_ppc(fenv_t* fenvp) {
	fenv_union_t new = { .fenv = *fenvp };
	fenv_union_t old = { .fenv = fegetenv_register() };
	new.l = (old.l & _FPU_MASK_EXCEPT_ROUND) | (new.l & _FPU_MASK_FRAC_INEX_RET_CC);
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	// Atomically enable and raise (if appropriate) exceptions set in `new`
	fesetenv_register(new.fenv);
}
#   define libc_feholdexceptf   libc_feholdexcept_ppc
#   define libc_feholdexcept   libc_feholdexcept_ppc
#   define libc_feholdexcept_setroundf   libc_feholdexcept_setround_ppc
#   define libc_feholdexcept_setround   libc_feholdexcept_setround_ppc
#   define libc_fetestexceptf   libc_fetestexcept_ppc
#   define libc_fetestexcept   libc_fetestexcept_ppc
#   define libc_fesetroundf   libc_fesetround_ppc
#   define libc_fesetround   libc_fesetround_ppc
#   define libc_fesetenvf   libc_fesetenv_ppc
#   define libc_fesetenv   libc_fesetenv_ppc
#   define libc_feupdateenv_testf   libc_feupdateenv_test_ppc
#   define libc_feupdateenv_test   libc_feupdateenv_test_ppc
#   define libc_feupdateenvf   libc_feupdateenv_ppc
#   define libc_feupdateenv   libc_feupdateenv_ppc
#   define libc_feholdsetroundf   libc_feholdsetround_ppc
#   define libc_feholdsetround   libc_feholdsetround_ppc
#   define libc_feresetroundf   libc_feresetround_ppc
#   define libc_feresetround   libc_feresetround_ppc
#   ifdef ARCHPOWERPC64
/** Equivalent to `fegetenv()`, but returns an `unsigned int` or `fenv_t` instead of taking a pointer */
#      define fegetenv_register()   __extension__ ({ fenv_t env; vasm("mffs %0" : "=f"(env)); env; })
/** Equivalent to `fesetenv()`, but takes an `unsigned int` or `fenv_t` instead of a pointer */
#      define fesetenv_register(env)   do { double d = (env); if (GLRO(dl_hwcap) & PPC_FEATURE_HAS_DFP) { vasm(".machine push; " ".machine "power6"; " "mtfsf 0xff,%0,1,0; " ".machine pop" : : "f"(d)); } else { vasm("mtfsf 0xff,%0" : : "f"(d)); } } while (0x0)
/** Sets the rounding mode to 'round to nearest', sets the processor into IEEE mode, and prevents exceptions from being raised for inexact results */
#      define relax_fenv_state()   do { if (GLRO(dl_hwcap) & PPC_FEATURE_HAS_DFP) { asm (".machine push; .machine "power6"; " "mtfsfi 7,0,1; .machine pop"); } asm ("mtfsfi 7,0"); } while (0x0)


LIB_FUNC MATH_FUNC int __fesetround_inline(const int round) {
	if ((unsigned int)round < 2) {
		vasm("mtfsb0 30;");
		if ((unsigned int) round == 0) { vasm("mtfsb0 31;"); }
		else { vasm("mtfsb1 31;"); }
	} else {
		vasm("mtfsb1 30;");
		if ((unsigned int)round == 2) { vasm("mtfsb0 31;"); }
		else { vasm("mtfsb1 31;"); }
	}
	return 0;
}


LIB_FUNC MATH_FUNC int fenv_reg_to_exceptions(const unsigned long long l) {
	register int result = 0;
	if (l & (1 << (31 - FPSCR_XE))) { result |= FE_INEXACT; }
	if (l & (1 << (31 - FPSCR_ZE))) { result |= FE_DIVBYZERO; }
	if (l & (1 << (31 - FPSCR_UE))) { result |= FE_UNDERFLOW; }
	if (l & (1 << (31 - FPSCR_OE))) { result |= FE_OVERFLOW; }
	if (l & (1 << (31 - FPSCR_VE))) { result |= FE_INVALID; }
	return result;
}


#      ifdef _ARCH_PWR6
/** Not supported in ISA 2.05; Provided for source compat only */
#         define FPSCR_NI   29
#      endif
#      define f_wash(x)   __extension__ ({ double d; vasm("fmul %0, %1, %2;" : "=f"(d) : "f"(x), "f"(1.0)); d; })
#      define f_washf(x)   __extension__ ({ float f; vasm("fmuls %0, %1, %2;" : "=f"(f) : "f"(x), "f"(1.0F)); f; })
#   else
/** Equivalent to `fegetenv()`, but returns an `unsigned int` or `fenv_t` instead of taking a pointer */
LIB_FUNC unsigned int fegetenv_register(void) {
	unsigned int fscr = 0;
	vasm("mfspefscr %0;" : "=r"(fscr));
	return fscr;
}


/** Equivalent to `fesetenv()`, but takes an `unsigned int` or `fenv_t` instead of a pointer */
LIB_FUNC void fesetenv_register(unsigned int fscr) {
	vasm("mtspefscr %0;" : : "r"(fscr));
}
#   endif
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_ #   #    fs(X) & _FP_QNANBIT_ #   #    fs) && !(_FP_FRAC_HIGH_RAW_ #   #    fs(Y) & _FP_QNANBIT_ #   #    fs)) { R #   #    _s = Y #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, Y); } else { R #   #    _s = X #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, X); }  R #   #    _c = FP_CLS_NAN; } while (0x0)
#   define _FP_TININESS_AFTER_ROUNDING 0
#   if (defined(__NO_FPRS__) && IS_HARDFP)
#      define _FP_DECL_EX   UNUSED int _spefscr, UNUSED _ftrapex = 0
#      define FP_INIT_ROUNDMODE   do  { int _r; _spefscr = fegetenv_register(); _r = syscall2(SYS_prctl, PR_GET_FPEXC, (long)&_ftrapex); if (((unsigned long)_r >= (unsigned long)(-4095))) { _ftrapex = 0; } } while (0x0)
#      define FP_INIT_EXCEPTIONS
#      define FP_HANDLE_EXCEPTIONS   __feraiseexcept_soft(_fex)
#      define FP_ROUNDMODE   (_spefscr & 3)
#      define FP_TRAPPING_EXCEPTIONS   (_ftrapex & PR_FP_EXC_UND ? FP_EX_UNDERFLOW : 0)
#   else
#      define FP_HANDLE_EXCEPTIONS   __simulate_exceptions(_fex)
#      define FP_ROUNDMODE   __sim_round_mode_thread
#      define FP_TRAPPING_EXCEPTIONS   ((~__sim_disabled_exceptions_thread) & 0x3e000000)
#   endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	return __sim_round_mode_thread;
}
#   define GET_ROUNDING_MODE_DEFINED   (1)
#endif


#ifdef ARCHS390
#   define S390_MATH_PRIVATE_H   (1)
#   define _S390_MATH_PRIVATE_H_   (1)
#   define _S390_GET_ROUNDING_MODE_H   (1)
#   define CPU_MATH_PRIVATE_H   (1)


typedef unsigned int   fexcept_t;  // Size of fpc
typedef struct fenv_struct {
	fexcept_t fpc;
	void* ieee_instruction_pointer;  // Failing instruction for IEEE exceptions
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#   define FE_INVALID   0x80
#   define FE_DIVBYZERO   0x40
#   define FE_OVERFLOW   0x20
#   define FE_UNDERFLOW   0x10
#   define FE_INEXACT   8
#   define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
#   define FE_TONEAREST   0
#   define FE_DOWNWARD   3
#   define FE_UPWARD   2
#   define FE_TOWARDZERO   1
#   define FE_DFL_ENV   ((const fenv_t*)-1)
#   define FPC_EXCEPTION_MASK   0xf8000000
#   define FPC_FLAGS_MASK   0xf80000
#   define FPC_DXC_MASK   0xff00
#   define FPC_RM_MASK   3
#   define FPC_VALID_MASK   ((FPC_EXCEPTION_MASK | FPC_FLAGS_MASK | FPC_DXC_MASK | FPC_RM_MASK))
#   define FPC_EXCEPTION_MASK_SHIFT   24
#   define FPC_FLAGS_SHIFT   16
#   define FPC_DXC_SHIFT   8
#   define FPC_NOT_FPU_EXCEPTION   0x300
#   ifdef ARCHS390X
#      define smul_ppmm(xh, xl, m0, m1)   do { register SItype __r0 asm ("0"); register SItype __r1 asm ("1") = (m0); asm ("mrt%%r0, %3;" : "=r"(__r0), "=r"(__r1) : "r"(__r1),  "r"(m1)); (xh) = __r0; (xl) = __r1; } while (0x0)
#      define sdiv_qrnnd(q, r, n1, n0, d)   do { register SItype __r0 asm ("0") = (n1); register SItype __r1 asm ("1") = (n0); asm ("drt%%r0, %4;" : "=r"(__r0), "=r"(__r1) : "r"(__r0), "r"(__r1), "r"(d)); (q) = __r1; (r) = __r0; } while (0x0)
#   else
#      define smul_ppmm(xh, xl, m0, m1)   do { union __union_smul_ppmm { DItype __ll; struct { USItype __h, __l;} __i; } __x; asm ("lr %N0, %1ntmr %0, %2;" : "=&r"(__x.__ll) : "r"(m0), "r"(m1)); (xh) = __x.__i.__h; (xl) = __x.__i.__l; } while (0x0)
/** sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator, denominator); Like udiv_qrnnd but the numbers are signed; The quotient is rounded towards 0 */
#      define sdiv_qrnnd(q, r, n1, n0, d)   do { union __union_sdiv_qrnnd { DItype __ll; struct { USItype __h, __l;} __i; } __x; __x.__i.__h = n1; __x.__i.__l = n0; asm ("dr %0, %2;" : "=r"(__x.__ll) : "0"(__x.__ll), "r"(d)); (q) = __x.__i.__l; (r) = __x.__i.__h; } while (0x0)
#   endif
/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fc;
	_FPU_GETCW(fc);
	return (int)(fc & FPC_RM_MASK);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)
#endif


#ifdef ARCHSPARC
#   define SPARC_MATH_PRIVATE_H   (1)
#   define _SPARC_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)


typedef unsigned long   fexcept_t;
typedef unsigned long   fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


/** Support for rounding mode context */
#   define HAVE_RM_CTX   (1)
#   define FE_DFL_ENV   ((const fenv_t*)-1)


LIB_FUNC void libc_feholdexcept(fenv_t* fenvp) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*fenvp = etmp;
	etmp = etmp & (~(0xf800000 | FE_ALL_EXCEPT));
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_fesetround(int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp = (etmp & (~__FE_ROUND_MASK)) | r;
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_feholdexcept_setround(fenv_t* fenvp, int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*fenvp = etmp;
	etmp = etmp & (~(0xf800000 | FE_ALL_EXCEPT));
	etmp = (etmp & (~__FE_ROUND_MASK)) | r;
	__fenv_ldfsr(etmp);
}


LIB_FUNC int libc_fetestexcept(int e) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	return etmp & e & FE_ALL_EXCEPT;
}


LIB_FUNC void libc_fesetenv(fenv_t* fenvp) {
	__fenv_ldfsr(*fenvp);
}


LIB_FUNC int libc_feupdateenv_test(fenv_t* fenvp, int ex) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp &= FE_ALL_EXCEPT;
	__fenv_ldfsr(*fenvp);
	__feraiseexcept(etmp);
	return etmp & ex;
}


LIB_FUNC void libc_feupdateenv(fenv_t* fenvp) {
	libc_feupdateenv_test(fenvp, 0);
}


LIB_FUNC void libc_feholdsetround(fenv_t* fenvp, int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*fenvp = etmp;
	etmp = (etmp & (~__FE_ROUND_MASK)) | r;
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_feresetround(fenv_t* fenvp) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp = (etmp & (~__FE_ROUND_MASK)) | (*fenvp & __FE_ROUND_MASK);
	__fenv_ldfsr(etmp);
}


#   define libc_feholdexceptf   libc_feholdexcept
#   define libc_fesetroundf   libc_fesetround
#   define libc_feholdexcept_setroundf libc_feholdexcept_setround
#   define libc_fetestexceptf   libc_fetestexcept
#   define libc_fesetenvf   libc_fesetenv
#   define libc_feupdateenv_testf   libc_feupdateenv_test
#   define libc_feupdateenvf   libc_feupdateenv
#   define libc_feholdsetroundf   libc_feholdsetround
#   define libc_feresetroundf   libc_feresetround
#   define libc_feholdexcept   libc_feholdexcept
#   define libc_fesetround   libc_fesetround
#   define libc_feholdexcept_setround   libc_feholdexcept_setround
#   define libc_fetestexcept   libc_fetestexcept
#   define libc_fesetenv   libc_fesetenv
#   define libc_feupdateenv_test   libc_feupdateenv_test
#   define libc_feupdateenv   libc_feupdateenv
#   define libc_feholdsetround   libc_feholdsetround
#   define libc_feresetround   libc_feresetround
#   define libc_feholdexceptl   libc_feholdexcept
#   define libc_fesetroundl   libc_fesetround
#   define libc_feholdexcept_setroundl   libc_feholdexcept_setround
#   define libc_fetestexceptl   libc_fetestexcept
#   define libc_fesetenvl   libc_fesetenv
#   define libc_feupdateenv_testl   libc_feupdateenv_test
#   define libc_feupdateenvl   libc_feupdateenv
#   define libc_feholdsetroundl   libc_feholdsetround
#   define libc_feresetroundl   libc_feresetround
#   ifdef ARCHSPARC64
/** Helper macros for _FP_MUL_MEAT_2_120_240_double */
#      define _FP_MUL_MEAT_SET_FE_TZ   do { static fpu_control_t _fetz = _FPU_RC_DOWN; _FPU_SETCW(_fetz); } while (0x0)
#      ifndef _FP_MUL_MEAT_RESET_FE
#         define _FP_MUL_MEAT_RESET_FE   _FPU_SETCW(_fcw)
#      endif
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_120_240_double(_FP_WFRACBITS_Q, R, X, Y, _FP_MUL_MEAT_SET_FE_TZ, _FP_MUL_MEAT_RESET_FE)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#      define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#      define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      define _FP_QNANNEGATEDP   0
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_ #      #       fs(Y) & _FP_QNANBIT_ #      #       fs) && !(_FP_FRAC_HIGH_RAW_ #      #       fs(X) & _FP_QNANBIT_ #      #       fs)) { R #      #       _s = X #      #       _s; _FP_FRAC_COPY_ #      #       wc(R, X); } else { R #      #       _s = Y #      #       _s; _FP_FRAC_COPY_ #      #       wc(R, Y); } R #      #       _c = FP_CLS_NAN; } while (0x0)
#      ifndef FP_ROUNDMODE
/** Obtain the current rounding mode */
#         define FP_ROUNDMODE   ((_fcw >> 30) & 0x3)
#      endif
#      define _FP_DECL_EX   UNUSED fpu_control_t _fcw = (FP_RND_NEAREST << 30)
#      define FP_INIT_ROUNDMODE   do { _FPU_GETCW(_fcw); } while (0x0)
#      define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 23) & 0x1f)
#      define FP_INHIBIT_RESULTS   ((_fcw >> 23) & _fex)
#      define FP_HANDLE_EXCEPTIONS   do { if (!_fex) { vasm("fzero %%f62;" "faddd %%f62, %%f62, %%f62;" : : : "f62"); } else { __Qp_handle_exceptions (_fex); } } while (0x0)
#      define QP_HANDLE_EXCEPTIONS(_a)   do { if ((_fcw >> 23) & _fex) { _a; } else { _fcw = (_fcw & ~0x1fL) | (_fex << 5) | _fex; _FPU_SETCW(_fcw); } } while (0x0)
#      define QP_NO_EXCEPTIONS   asm ("fzero %%f62;" "faddd %%f62, %%f62, %%f62;" : : : "f62")
#      define QP_CLOBBER   "memory", "f52", "f54", "f56", "f58", "f60", "f62"
#      define QP_CLOBBER_CC   QP_CLOBBER , "cc"
#   elif defined(ARCHSPARC32)
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_udiv(S, R, X, Y)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#      define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#      define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#      define _FP_NANSIGN_S   0
#      define _FP_NANSIGN_D   0
#      define _FP_NANSIGN_Q   0
#      define _FP_KEEPNANFRACP   1
#      define _FP_QNANNEGATEDP   0
#      define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#      define __FP_FRAC_ADD_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)   asm ("addcc %r7, %8, %2;" "addxcc %r5, %6, %1;" "addx %r3, %4, %0;" : "=r"((USItype)(r2)), "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc")
#      define __FP_FRAC_SUB_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)   asm ("subcc %r7, %8, %2;" "subxcc %r5, %6, %1;" "subx %r3, %4, %0;" : "=r"((USItype)(r2)), "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc")
#      define __FP_FRAC_ADD_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0)   do { register USItype _t1 asm ("g1"), _t2 asm ("g2"); vasm("addcc %r8, %9, %1;" "addxcc %r6, %7, %0;" "addxcc %r4, %5, %%g2;" "addx %r2, %3, %%g1;" : "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x3)), "rI"((USItype)(y3)), "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc", "g1", "g2"); vasm("" : "=r"(_t1), "=r"(_t2)); r3 = _t1; r2 = _t2; } while (0x0)
#      define __FP_FRAC_SUB_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0)   do { register USItype _t1 asm ("g1"), _t2 asm ("g2"); vasm("subcc %r8, %9, %1;" "subxcc %r6, %7, %0;" "subxcc %r4, %5, %%g2;" "subx %r2, %3, %%g1;" : "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x3)), "rI"((USItype)(y3)), "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc", "g1", "g2"); vasm("" : "=r"(_t1), "=r"(_t2)); r3 = _t1; r2 = _t2; } while (0x0)
#      define __FP_FRAC_DEC_3(x2, x1, x0, y2, y1, y0) __FP_FRAC_SUB_3(x2, x1, x0, x2, x1, x0, y2, y1, y0)
#      define __FP_FRAC_DEC_4(x3, x2, x1, x0, y3, y2, y1, y0) __FP_FRAC_SUB_4(x3, x2, x1, x0, x3, x2, x1, x0, y3, y2, y1, y0)
#      define __FP_FRAC_ADDI_4(x3, x2, x1, x0, i)   asm ("addcc %3, %4, %3;" "addxcc %2, %%g0, %2;" "addxcc %1, %%g0, %1;" "addx %0, %%g0, %0;" : "=&r"((USItype)(x3)), "=&r"((USItype)(x2)), "=&r"((USItype)(x1)), "=&r"((USItype)(x0)) : "rI"((USItype)(i)), "0"((USItype)(x3)), "1"((USItype)(x2)), "2"((USItype)(x1)), "3"((USItype)(x0)) : "cc")
#      ifndef FP_ROUNDMODE
#         define FP_ROUNDMODE   ((_fcw >> 30) & 3)
#      endif
#      define _FP_DECL_EX   UNUSED fpu_control_t _fcw = (FP_RND_NEAREST << 30)
#      define FP_INIT_ROUNDMODE   do { _FPU_GETCW(_fcw); } while (0x0)
#      define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 23) & 0x1f)
#      define FP_INHIBIT_RESULTS   ((_fcw >> 23) & _fex)
#      define FP_HANDLE_EXCEPTIONS   do { if (!_fex) { extern unsigned long long ___Q_zero; vasm("ldd [%0], %%f30;" "faddd %%f30, %%f30, %%f30;" : : "r"(&___Q_zero) : "f30"); } else { ___Q_simulate_exceptions (_fex); } } while (0x0)
#   endif
#endif


#ifdef ARCHSUPERH
#   define SH_MATH_PRIVATE_H   (1)
#   define _SH_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define LDBL_CLASSIFY_COMPAT   (1)
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#   define _FP_NANSIGN_S   0
#   define _FP_NANSIGN_D   0
#   define _FP_NANSIGN_Q   0
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_ #   #    fs(X) & _FP_QNANBIT_ #   #    fs) && !(_FP_FRAC_HIGH_RAW_ #   #    fs(Y) & _FP_QNANBIT_ #   #    fs)) { R #   #    _s = Y #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, Y); } else { R #   #    _s = X #   #    _s; _FP_FRAC_COPY_ #   #    wc(R, X); } R #   #    _c = FP_CLS_NAN; } while (0x0)
#   if (defined(__SHMEDIA__) && __SHMEDIA__ && IS_WORDSIZE_32)
#      define __umulsidi3(u, v)   ((UDItype)(USItype)u*(USItype)v)
#   endif
#endif


#ifdef ARCHTILE
#   define TILE_MATH_PRIVATE_H   (1)
#   define _TILE_MATH_PRIVATE_H_   (1)
#   define CPU_MATH_PRIVATE_H   (1)
#   define libc_fesetround(rnd)   0
#   define libc_fetestexcept(exc)   0
#   define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#   define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#   define feraiseexcept(excepts)   0
#   define __feraiseexcept(excepts)   0
#   define feclearexcept(exc)   0
#   define fetestexcept(exc)   0
LIB_FUNC int fegetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __fegetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int fesetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __fesetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int feupdateenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __feupdateenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int fegetround(void) { return FE_TONEAREST; }
LIB_FUNC int __fegetround(void) { return FE_TONEAREST; }
LIB_FUNC int fesetround(const UNUSED int __d) { return 0; }
LIB_FUNC int __fesetround(const UNUSED int __d) { return 0; }
#   define _FP_W_TYPE   unsigned long
#   define _FP_WS_TYPE   signed long
#   define _FP_I_TYPE   long
#   if IS_WORDSIZE_64
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_imm(_FP_WFRACBITS_S, R, X, Y)
#      define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   _FP_QNANBIT_S
#      define _FP_NANFRAC_D   _FP_QNANBIT_D
#      define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0
#   else  // IS_WORDSIZE_32
#      define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#      define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#      define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#      define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#      define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#      define _FP_NANFRAC_S   _FP_QNANBIT_S
#      define _FP_NANFRAC_D   _FP_QNANBIT_D, 0
#      define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0, 0, 0
#   endif
#   define _FP_NANSIGN_S   1
#   define _FP_NANSIGN_D   1
#   define _FP_NANSIGN_Q   1
#   define _FP_KEEPNANFRACP   1
#   define _FP_QNANNEGATEDP   0
#   define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#   define _FP_TININESS_AFTER_ROUNDING   0
#endif


#if (defined(ARCHVAX) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("addl2 %5, %1ntadwc %3, %0;" : "=g"((USItype)(sh)), "=&g"((USItype)(sl)) : "%0"((USItype)(ah)), "g"((USItype)(bh)), "%1"((USItype)(al)), "g"((USItype) (bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("subl2 %5, %1ntsbwc %3, %0;" : "=g"((USItype)(sh)), "=&g"((USItype)(sl)) : "0"((USItype)(ah)), "g"((USItype)(bh)), "1"((USItype)(al)), "g"((USItype)(bl)))
#   define umul_ppmm(xh, xl, m0, m1)   do { union __union_umul_ppmm { UDItype __ll; struct { USItype __l, __h;} __i; } __xx; USItype __m0 = (m0), __m1 = (m1); asm ("emul %1, %2,$0, %0;" : "=r"(__xx.__ll) : "g"(__m0), "g"(__m1)); (xh) = __xx.__i.__h; (xl) = __xx.__i.__l; (xh) += ((((SItype) __m0 >> 31) & __m1) + (((SItype) __m1 >> 31) & __m0)); } while (0x0)
#   define sdiv_qrnnd(q, r, n1, n0, d)   do { union __union_sdiv_qrnnd { DItype __ll; struct { SItype __l, __h;} __i; } __xx; __xx.__i.__h = n1; __xx.__i.__l = n0; asm ("ediv %3, %2, %0, %1;" : "=g"(q), "=g"(r) : "g"(__xx.__ll), "g"(d)); } while (0x0)
#endif


#ifdef ARCHX86
#   define X86_64_MATH_PRIVATE_H   (1)
#   define I386_MATH_PRIVATE_H   (1)
#   define CPU_MATH_PRIVATE_H   (1)


#   define HAVE_RM_CTX   (1)
#   ifndef ARCHX86_64
#      define __mxcsr   __eip
#   endif


typedef struct fenv_struct {
	unsigned short __control;  //!< A direct copy of the floaing point control word
	unsigned short __status;  //!< A direct copy of the floaing point status word
	unsigned int __mxcsr;  //!< A direct copy of the MXCSR
	char __reserved[8];  //!< Reserved for future expansion
} fenv_t;


typedef unsigned short   fexcept_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


extern const UNUSED fenv_t   _FE_DFL_ENV;
#   define FE_DFL_ENV   &_FE_DFL_ENV
extern const UNUSED fenv_t   _FE_DFL_DISABLE_SSE_DENORMS_ENV;
#   define FE_DFL_DISABLE_SSE_DENORMS_ENV   &_FE_DFL_DISABLE_SSE_DENORMS_ENV
const UNUSED fenv_t _FE_DFL_ENV = { DEFAULT_CONTROL, DEFAULT_STATUS, DEFAULT_MXCSR, DEFAULT_RESERVED };
const UNUSED fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV = { DEFAULT_CONTROL, DEFAULT_STATUS, (DEFAULT_MXCSR | 0x8040), DEFAULT_RESERVED };


typedef struct fpustate {
	unsigned short __control, __reserved1, __status, __reserved2;
	unsigned int __private3, __private4, __private5, __private6, __private7;
} __fpustate_t;


/** Raise given exceptions */
LIB_FUNC int __feraiseexcept(const int excepts) {
	fenv_t temp = { 0, 0, 0, { 0 } };
	if ((FE_INVALID & excepts) != 0) {
			float f = 0.0F;
			vasm("divss %0, %0;" : : "x"(f));
			(void)&f;
	}
	if ((FE_DIVBYZERO & excepts) != 0) {
			float f = 1.0F, g = 0.0F;
			vasm("divss %1, %0;" : : "x"(f), "x"(g));
			(void)&f;
	}
	if ((FE_OVERFLOW & excepts) != 0) {
			vasm("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_OVERFLOW;
			vasm("fldenv %0;" : : "m"(*&temp));
			vasm("fwait;");
	}
	if ((FE_UNDERFLOW & excepts) != 0) {
			vasm("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_UNDERFLOW;
			vasm("fldenv %0;" : : "m"(*&temp));
			vasm("fwait;");
	}
	if ((FE_INEXACT & excepts) != 0) {
			vasm("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_INEXACT;
			vasm("fldenv %0;" : : "m"(*&temp));
			vasm("fwait;");
	}
	return 0;
}
#   define feraiseexcept(excepts)   __feraiseexcept((excepts))


LIB_FUNC int _fesetexceptflag(const fexcept_t* flagp, const int excepts) {
	__fpustate_t currfpu = { 0 };
	register unsigned int exceptMask = (excepts & FE_ALL_EXCEPT);
	register unsigned int andMask = (~exceptMask);  // Clear just the bits indicated
	register unsigned int orMask = (*flagp & exceptMask);  // Latch the specified bits
	unsigned int mxcsr = (unsigned int)_mm_getcsr();  // Read the MXCSR state
	vasm("fnstenv %0;" : "=m"(currfpu));  // Read x87 state
	mxcsr = ((mxcsr & andMask) | orMask);  // Fix the MXCSR state
	register int fpstate = (int)((currfpu.__status & andMask) | orMask);  // Fix the x87 state
	currfpu.__status = (short unsigned int)fpstate;
	vasm("ldmxcsr %0;" "fldenv %1;" : : "m,x"(mxcsr), "m,x"(currfpu));  // Store the state
	return 0;
}


LIB_FUNC int _fegetexceptflag(fexcept_t* flagp, const int excepts) {
	unsigned short tmp = 0;
	vasm("fnstsw %0;" : "=m"(tmp) : : "memory");
	fexcept_t fsw = tmp;  // Get the x87 status word
	register unsigned int mxcsr = (unsigned int)_mm_getcsr();  // Get the mxcsr
	fexcept_t result = (unsigned short)(mxcsr | fsw);
	*flagp = (result & (excepts & FE_ALL_EXCEPT));
	return 0;
}
#   define fegetexceptflag(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#   define fesetexceptflag(flagp, excepts)   _fesetexceptflag((flagp), (excepts))
#   define fegetexcept(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#   define fesetexcept(flagp, excepts)   _fesetexceptflag((flagp), (excepts))


LIB_FUNC int feclearexcept(const int excepts) {
	fexcept_t zero = 0;
	return fesetexceptflag(&zero, excepts);
}


LIB_FUNC int fetestexcept(const int excepts) {
	unsigned short tmp = 0;
	vasm("fnstsw %0;" : "=m"(tmp) : : "memory");
	fexcept_t fsw = tmp;  // Get the x87 status word
	register unsigned int mxcsr = _mm_getcsr();  // Get the mxcsr
	return (int)((mxcsr | fsw) & (excepts & FE_ALL_EXCEPT));
}


LIB_FUNC int fegetround(void) {
	unsigned short tmp = 0;
	vasm("fnstcw %0;" : "=m"(tmp) : : "memory");
	return (int)(tmp & FE_ALL_RND);
}


LIB_FUNC int fesetround(const int round) {
	if ((round & (~FE_ALL_RND))) { return 1; }
	unsigned short tmp = 0;
	vasm("fnstcw %0;" : "=m"(tmp) : : "memory");
	register unsigned short fcw = tmp;
	register unsigned int mxcsr = _mm_getcsr();
	fcw = (short unsigned int)((fcw & (short unsigned int)(~FE_ALL_RND)) | round);
	mxcsr = (unsigned int)((unsigned int)(mxcsr & (unsigned int)(~(FE_ALL_RND << 3))) | (unsigned int)(round << 3));
	_mm_setcsr(mxcsr);
	tmp = fcw;
	vasm("fldcw %0;" : : "m"(tmp));
	return 0;
}


LIB_FUNC int fegetenv(fenv_t* fenvp) {
	__fpustate_t currfpu = { 0 };
	register unsigned int mxcsr = _mm_getcsr();
	vasm("fnstenv %0;" : "=m"(currfpu) : : "memory");
	fenvp->__control = currfpu.__control;
	fenvp->__status = currfpu.__status;
	fenvp->__mxcsr = (unsigned int)mxcsr;
	fenvp->__reserved[0] = 0;
	fenvp->__reserved[1] = 0;
	vasm("fldenv %0;" : : "m"(currfpu));
	return 0;
}


LIB_FUNC int feholdexcept(fenv_t* fenvp) {
	__fpustate_t currfpu = { 0 };
	unsigned int mxcsr = _mm_getcsr();
	vasm("fnstenv %0;" : "=m"(*&currfpu) : : "memory");
	fenvp->__control = currfpu.__control;
	fenvp->__status = currfpu.__status;
	fenvp->__mxcsr = mxcsr;
	fenvp->__reserved[0] = 0;
	fenvp->__reserved[1] = 0;
	currfpu.__control |= FE_ALL_EXCEPT;  // FPU shall handle all exceptions
	currfpu.__status &= (short unsigned int)(~FE_ALL_EXCEPT);
	mxcsr = (unsigned int)((mxcsr | (FE_ALL_EXCEPT << 7)) & (unsigned int)(~(FE_ALL_EXCEPT)));  // Left shifted because control mask is <<7 of the flags
	vasm("ldmxcsr %0;" "fldenv %1;" : : "m"(*&mxcsr), "m"(*&currfpu));
	return 0;
}


LIB_FUNC int fesetenv(const fenv_t* fenvp) {
	__fpustate_t currfpu = { 0 };
	vasm("fnstenv %0;" : "=m"(currfpu));
	currfpu.__control = fenvp->__control;
	currfpu.__status = fenvp->__status;
	vasm("ldmxcsr %0;" "fldenv %1;" : : "m"(fenvp->__mxcsr), "m"(currfpu));
	return 0;
}


LIB_FUNC int feupdateenv(const fenv_t* fenvp) {
	__fpustate_t currfpu = { 0 };
	vasm("fnstenv %0;" : "=m"(currfpu));
	currfpu.__control = fenvp->__control;
	currfpu.__status = fenvp->__status;
	vasm("ldmxcsr %0; fldenv %1;" "fwait;" : : "m"(fenvp->__mxcsr), "m"(currfpu));
	return 0;
}


LIB_FUNC int __fegetfltrounds(void) {
	switch ((int)(fegetround())) {
		case FE_TONEAREST: return 1;
		case FE_TOWARDZERO: return 0;
		case FE_UPWARD: return 2;
		case FE_DOWNWARD: return 3;
		default: return -1;
	}
	UNREACHABLE
}
#   define _fegetfltrounds()   __fegetfltrounds()
#   define fegetfltrounds()   __fegetfltrounds()


LIB_FUNC void libc_feholdexcept_sse(fenv_t* e) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0;" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)((mxcsr | 8064) & (unsigned int)0xffffffc0);
	vasm(LDMXCSR " %0;" : : "m"(*&mxcsr));
}


/** Clobber all of the fp registers so that the TOS field is 0 */
LIB_FUNC void libc_feholdexcept_387(fenv_t* e) {
	vasm("fnstenv %0;" "fnclex;" : "=m"(*e) : : "st", "st(1)", "st(2)", "st(3)", "st(4)", "st(5)", "st(6)", "st(7)");
}


LIB_FUNC void libc_fesetround_sse(const int r) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0;" : "=m"(*&mxcsr));
	mxcsr = (unsigned int)((mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(r << 3));
	vasm(LDMXCSR " %0;" : : "m"(*&mxcsr));
}


LIB_FUNC void libc_fesetround_387(const int r) {
	fpu_control_t cw = 0;
	_FPU_GETCW(cw);
	cw = (fpu_control_t)((cw & (fpu_control_t)(~3072)) | (fpu_control_t)r);
	_FPU_SETCW(cw);
}


LIB_FUNC void libc_feholdexcept_setround_sse(fenv_t* e, const int r) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0;" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)(((mxcsr | 8064) & (unsigned int)0xffff9fc0) | (unsigned int)(r << 3));
	vasm(LDMXCSR " %0;" : : "m"(*&mxcsr));
}


LIB_FUNC int libc_fetestexcept_sse(const int e) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0;" : "=m"(*&mxcsr));
	return (((int)mxcsr & e) & FE_ALL_EXCEPT);
}


LIB_FUNC int libc_fetestexcept_387(const int ex) {
	register fexcept_t temp = 0;
	vasm("fnstsw %0;" : "=a"(temp));
	return ((temp & ex) & FE_ALL_EXCEPT);
}


LIB_FUNC void libc_fesetenv_sse(fenv_t* e) {
	vasm(LDMXCSR " %0;" : : "m"(e->__mxcsr));
}


/** Clobber all fp registers so that the TOS value we saved earlier is compatible with the current state of the compiler */
LIB_FUNC void libc_fesetenv_387(fenv_t* e) {
	vasm("fldenv %0;" : : "m"(*e) : "st", "st(1)", "st(2)", "st(3)", "st(4)", "st(5)", "st(6)", "st(7)");
}


LIB_FUNC int libc_feupdateenv_test_sse(fenv_t* e, const int ex) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0" : "=m"(*&mxcsr));
	const unsigned int cur_ex = mxcsr & FE_ALL_EXCEPT;
	// Merge current exceptions with the old environment
	const unsigned int old_mxcsr = e->__mxcsr;
	mxcsr = old_mxcsr | cur_ex;
	vasm(LDMXCSR " %0" : : "m"(*&mxcsr));
	// Raise SIGFPE for any new exceptions since the hold; Expect that the normal environment has all exceptions masked
	if (PREDICT_UNLIKELY(~(old_mxcsr >> 7) & cur_ex)) { __feraiseexcept((int)cur_ex); }
	// Test for exceptions raised since the hold
	return (int)((int)cur_ex & ex);
}


LIB_FUNC int libc_feupdateenv_test_387(fenv_t* e, const int ex) {
	fexcept_t cur_ex = 0;
	// Save current exceptions
	vasm("fnstsw %0;" : "=a"(cur_ex));
	cur_ex &= FE_ALL_EXCEPT;
	libc_fesetenv_387(e);  // Reload original environment
	__feraiseexcept(cur_ex);  // Merge current exceptions
	return (cur_ex & ex);  // Test for exceptions raised since the hold
}


LIB_FUNC void libc_feupdateenv_sse(fenv_t* e) {
	libc_feupdateenv_test_sse(e, 0);
}


LIB_FUNC void libc_feupdateenv_387(fenv_t* e) {
	libc_feupdateenv_test_387(e, 0);
}


LIB_FUNC void libc_feholdsetround_sse(fenv_t* e, const int r) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)(mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(r << 3);
	vasm(LDMXCSR " %0" : : "m"(*&mxcsr));
}


LIB_FUNC void libc_feresetround_sse(fenv_t* e) {
	unsigned int mxcsr = 0;
	vasm(STMXCSR " %0" : "=m"(*&mxcsr));
	mxcsr = (unsigned int)(mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(e->__mxcsr & 0x6000);
	vasm(LDMXCSR " %0" : : "m"(*&mxcsr));
}


#   define libc_feholdexceptl   libc_feholdexcept_387
#   define libc_fesetroundl   libc_fesetround_387
#   define libc_feholdexcept_setroundl   libc_feholdexcept_setround_387
#   define libc_fetestexceptl   libc_fetestexcept_387
#   define libc_fesetenvl   libc_fesetenv_387
#   define libc_feupdateenv_testl   libc_feupdateenv_test_387
#   define libc_feupdateenvl   libc_feupdateenv_387
#   define libc_feholdsetroundl   libc_feholdsetround_387
#   define libc_feresetroundl   libc_feresetround_387
#   ifdef __SSE_MATH__
#      define libc_feholdexcept_setroundf_ctx   libc_feholdexcept_setround_sse_ctx
#      define libc_fesetenvf_ctx   libc_fesetenv_sse_ctx
#      define libc_feupdateenvf_ctx   libc_feupdateenv_sse_ctx
#      define libc_feholdsetroundf_ctx   libc_feholdsetround_sse_ctx
#      define libc_feresetroundf_ctx   libc_feresetround_sse_ctx
#      define libc_feholdexceptf   libc_feholdexcept_sse
#      define libc_fesetroundf   libc_fesetround_sse
#      define libc_feholdexcept_setroundf  libc_feholdexcept_setround_sse
#      define libc_fetestexceptf   libc_fetestexcept_sse
#      define libc_fesetenvf   libc_fesetenv_sse
#      define libc_feupdateenv_testf   libc_feupdateenv_test_sse
#      define libc_feupdateenvf   libc_feupdateenv_sse
#      define libc_feholdsetroundf   libc_feholdsetround_sse
#      define libc_feresetroundf   libc_feresetround_sse
#   else
#      define libc_feholdexcept_setroundf_ctx   libc_feholdexcept_setround_387_ctx
#      define libc_feupdateenvf_ctx   libc_feupdateenv_387_ctx
#      define libc_feholdsetroundf_ctx   libc_feholdsetround_387_ctx
#      define libc_feresetroundf_ctx   libc_feresetround_387_ctx
#      define libc_feholdexceptf   libc_feholdexcept_387
#      define libc_fesetroundf   libc_fesetround_387
#      define libc_feholdexcept_setroundf  libc_feholdexcept_setround_387
#      define libc_fetestexceptf   libc_fetestexcept_387
#      define libc_fesetenvf   libc_fesetenv_387
#      define libc_feupdateenv_testf   libc_feupdateenv_test_387
#      define libc_feupdateenvf   libc_feupdateenv_387
#      define libc_feholdsetroundf   libc_feholdsetround_387
#      define libc_feresetroundf   libc_feresetround_387
#   endif
#   ifdef __SSE2_MATH__
#      define libc_feholdexcept_setround_ctx   libc_feholdexcept_setround_sse_ctx
#      define libc_fesetenv_ctx   libc_fesetenv_sse_ctx
#      define libc_feupdateenv_ctx   libc_feupdateenv_sse_ctx
#      define libc_feholdsetround_ctx   libc_feholdsetround_sse_ctx
#      define libc_feresetround_ctx   libc_feresetround_sse_ctx
#      define libc_feholdsetround_53bit_ctx   libc_feholdsetround_387_53bit_ctx
#      define libc_feresetround_53bit_ctx   libc_feresetround_387_ctx
#      define libc_feholdexcept_setround_53bit   libc_feholdexcept_setround_387_53bit
#      define libc_feholdsetround_53bit   libc_feholdsetround_387_53bit
#      define libc_feholdexcept   libc_feholdexcept_sse
#      define libc_fesetround   libc_fesetround_sse
#      define libc_feholdexcept_setround libc_feholdexcept_setround_sse
#      define libc_fetestexcept   libc_fetestexcept_sse
#      define libc_fesetenv   libc_fesetenv_sse
#      define libc_feupdateenv_test   libc_feupdateenv_test_sse
#      define libc_feupdateenv   libc_feupdateenv_sse
#      define libc_feholdsetround   libc_feholdsetround_sse
#      define libc_feresetround   libc_feresetround_sse
#   else
#      define libc_feholdexcept_setround_ctx   libc_feholdexcept_setround_387_ctx
#      define libc_feupdateenv_ctx   libc_feupdateenv_387_ctx
#      define libc_feholdsetround_ctx   libc_feholdsetround_387_ctx
#      define libc_feresetround_ctx   libc_feresetround_387_ctx
#      define libc_feholdexcept   libc_feholdexcept_387
#      define libc_fesetround   libc_fesetround_387
#      define libc_feholdexcept_setround libc_feholdexcept_setround_387
#      define libc_fetestexcept   libc_fetestexcept_387
#      define libc_fesetenv   libc_fesetenv_387
#      define libc_feupdateenv_test   libc_feupdateenv_test_387
#      define libc_feupdateenv   libc_feupdateenv_387
#      define libc_feholdsetround   libc_feholdsetround_387
#      define libc_feresetround   libc_feresetround_387
#   endif
#   define libc_feholdexcept_setroundl_ctx   libc_feholdexcept_setround_387_ctx
#   define libc_feupdateenvl_ctx   libc_feupdateenv_387_ctx
#   define libc_feholdsetroundl_ctx   libc_feholdsetround_387_ctx
#   define libc_feresetroundl_ctx   libc_feresetround_387_ctx
#   ifdef ARCHX86_32
#      define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add{l} {%5, %1|%1, %5}ntadc{l} {%3, %0|%0, %3};" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%0"((USItype)(ah)), "g"((USItype)(bh)), "%1"((USItype)(al)), "g"((USItype)(bl)))
#      define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub{l} {%5, %1|%1, %5}ntsbb{l} {%3, %0|%0, %3};" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "0"((USItype)(ah)), "g"((USItype)(bh)), "1"((USItype)(al)), "g"((USItype)(bl)))
#      define umul_ppmm(w1, w0, u, v)   asm ("mul{l} %3;" : "=a"((USItype)(w0)), "=d"((USItype)(w1)) : "%0"((USItype)(u)), "rm"((USItype)(v)))
#      define udiv_qrnnd(q, r, n1, n0, dv)   asm ("div{l} %4;" : "=a"((USItype)(q)), "=d"((USItype)(r)) : "0"((USItype)(n0)), "1"((USItype)(n1)), "rm"((USItype)(dv)))
#   elif defined(ARCHX86_64)
#      define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add{q} {%5, %1|%1, %5}ntadc{q} {%3, %0|%0, %3};" : "=r"((UDItype)(sh)), "=&r"((UDItype)(sl)) : "%0"((UDItype)(ah)), "rme"((UDItype)(bh)), "%1"((UDItype)(al)), "rme"((UDItype)(bl)))
#      define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub{q} {%5, %1|%1, %5}ntsbb{q} {%3, %0|%0, %3};" : "=r"((UDItype)(sh)), "=&r"((UDItype)(sl)) : "0"((UDItype)(ah)), "rme"((UDItype)(bh)), "1"((UDItype)(al)), "rme"((UDItype)(bl)))
#      define umul_ppmm(w1, w0, u, v)   asm ("mul{q} %3;" : "=a"((UDItype)(w0)), "=d"((UDItype)(w1)) : "%0"((UDItype)(u)), "rm"((UDItype)(v)))
#      define udiv_qrnnd(q, r, n1, n0, dv)  asm ("div{q} %4;" : "=a"((UDItype)(q)), "=d"((UDItype)(r)) : "0"((UDItype)(n0)), "1"((UDItype)(n1)), "rm"((UDItype)(dv)))
#   endif
#   define UMUL_TIME   40
#   define UDIV_TIME   40
#endif


#if (defined(ARCHXSTORMY) && (!defined(count_leading_zeros)))
#   define count_leading_zeros2(count, x)   do { UHItype size = W_TYPE_SIZE; for ((count) = 0; size; size -= 16) { UHItype c = __clzhi2((x) >> (size - 16)); (count) += c; if (c != 16) { break; } } } while (0x0)
#endif


#if (defined(ARCHXTENSA) && IS_WORDSIZE_32)
#   define umul_ppmm(w1, w0, u, v)   do { const DWunion __w = { .ll = __builtin_umulsidi3(u, v) }; w1 = __w.s.high; w0 = __w.s.low; } while (0x0)
#   define __umulsidi3(u, v)    __builtin_umulsidi3(u, v)
#endif


#if (defined(ARCHZ8000) && IS_WORDSIZE_16)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add %H1, %H5ntadc %H0, %H3;" : "=r"((unsigned int)(sh)), "=&r"((unsigned int)(sl)) : "%0"((unsigned int)(ah)), "r"((unsigned int)(bh)), "%1"((unsigned int)(al)), "rQR"((unsigned int)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub %H1, %H5ntsbc %H0, %H3;" : "=r"((unsigned int)(sh)), "=&r"((unsigned int)(sl)) : "0"((unsigned int)(ah)), "r"((unsigned int)(bh)), "1"((unsigned int)(al)), "rQR"((unsigned int)(bl)))
#   define umul_ppmm(xh, xl, m0, m1)   do { union __union_umul_ppmm {long __ll; struct {unsigned int __h, __l;} __i; } __xx; unsigned int __m0 = (m0), __m1 = (m1); asm ("mult %S0, %H3;" : "=r"(__xx.__i.__h), "=r"(__xx.__i.__l) : "%1"(__m0), "rQR"(__m1)); (xh) = __xx.__i.__h; (xl) = __xx.__i.__l; (xh) += ((((signed int) __m0 >> 15) & __m1) + (((signed int) __m1 >> 15) & __m0)); } while (0x0)
#endif


#ifdef _TMS320C6X
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   do { UDItype __ll = 0; asm ("addu .l1 %1, %2, %0;" : "=a"(__ll) : "a"(al), "a"(bl)); (sl) = (USItype)__ll; (sh) = ((USItype)(__ll >> 32)) + (ah) + (bh); } while (0x0)
#   ifdef _TMS320C6400_PLUS
#      define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
#      define umul_ppmm(w1, w0, u, v)   do { UDItype __x = (UDItype) (USItype) (u) * (USItype) (v); (w1) = (USItype) (__x >> 32); (w0) = (USItype) (__x); } while (0x0)
#   endif
#   define UMUL_TIME   4
#   define UDIV_TIME   40
#endif


#ifndef _FP_W_TYPE
#   define _FP_W_TYPE   UWtype
#endif
#ifndef _FP_WS_TYPE
#   define _FP_WS_TYPE   Wtype
#endif
#ifndef _FP_I_TYPE
#   define _FP_I_TYPE   long long
#endif
#if (defined(__VFP_FP__) || defined(ARM_BIG_ENDIAN) || defined(ARCHSUPERH))
#   define FLOAT64_DEMANGLE(a)   (a)
#   define FLOAT64_MANGLE(a)   (a)
#else
#   define FLOAT64_DEMANGLE(a)   (((a) << 32) | ((a) >> 32))
#   define FLOAT64_MANGLE(a)   FLOAT64_DEMANGLE(a)
#endif
#ifndef FP_RND_NEAREST
#   define FP_RND_NEAREST   0
#   define FP_RND_ZERO   1
#   define FP_RND_PINF   2
#   define FP_RND_MINF   3
#endif
#ifndef FP_ROUNDMODE
#   define FP_ROUNDMODE   FP_RND_NEAREST
#endif
#ifndef FP_EX_INVALID
#   define FP_EX_INVALID   0
#endif
#ifndef FP_EX_OVERFLOW
#   define FP_EX_OVERFLOW   0
#endif
#ifndef FP_EX_UNDERFLOW
#   define FP_EX_UNDERFLOW   0
#endif
#ifndef FP_EX_DIVZERO
#   define FP_EX_DIVZERO   0
#endif
#ifndef FP_EX_INEXACT
#   define FP_EX_INEXACT   0
#endif
#ifndef FP_EX_DENORM
#   define FP_EX_DENORM   0
#endif
#ifndef FP_EX_INVALID_SNAN
#   define FP_EX_INVALID_SNAN   0
#endif
#ifndef FP_EX_INVALID_IMZ
#   define FP_EX_INVALID_IMZ   0
#endif
#ifndef FP_EX_INVALID_IMZ_FMA
#   define FP_EX_INVALID_IMZ_FMA   0
#endif
#ifndef FP_EX_INVALID_ISI
#   define FP_EX_INVALID_ISI   0
#endif
#ifndef FP_EX_INVALID_ZDZ
#   define FP_EX_INVALID_ZDZ   0
#endif
#ifndef FP_EX_INVALID_IDI
#   define FP_EX_INVALID_IDI   0
#endif
#ifndef FP_EX_INVALID_SQRT
#   define FP_EX_INVALID_SQRT   0
#endif
#ifndef FP_EX_INVALID_CVI
#   define FP_EX_INVALID_CVI   0
#endif
#ifndef FP_EX_INVALID_VC
#   define FP_EX_INVALID_VC   0
#endif
#ifndef _FP_STRUCT_LAYOUT
#   define _FP_STRUCT_LAYOUT
#endif
#ifdef _FP_DECL_EX
#   define FP_DECL_EX   int _fex = 0; _FP_DECL_EX
#else
#   define FP_DECL_EX   int _fex = 0
#endif
#ifndef FP_INIT_ROUNDMODE
/** Initialize any machine-specific state used in FP_ROUNDMODE, FP_TRAPPING_EXCEPTIONS or FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_ROUNDMODE   do {} while (0x0)
#endif
#ifndef FP_INIT_TRAPPING_EXCEPTIONS
/** Initialize any machine-specific state used in FP_TRAPPING_EXCEPTIONS or FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_TRAPPING_EXCEPTIONS   FP_INIT_ROUNDMODE
#endif
#ifndef FP_INIT_EXCEPTIONS
/** Initialize any machine-specific state used in FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_EXCEPTIONS   FP_INIT_TRAPPING_EXCEPTIONS
#endif
#ifndef FP_HANDLE_EXCEPTIONS
#   define FP_HANDLE_EXCEPTIONS   do {} while (0x0)
#endif
#ifndef FP_DENORM_ZERO
/** Flush subnormal inputs to zero with the same sign */
#   define FP_DENORM_ZERO   0
#endif
#ifndef FP_INHIBIT_RESULTS
#   define FP_INHIBIT_RESULTS   0
#endif
#define FP_SET_EXCEPTION(ex)  _fex |= (ex)
#define FP_CUR_EXCEPTIONS   (_fex)
#ifndef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#endif
#ifdef FP_NO_EXCEPTIONS
#   undef FP_SET_EXCEPTION
#   define FP_SET_EXCEPTION(ex)   do {} while (0x0)
#   undef FP_CUR_EXCEPTIONS
#   define FP_CUR_EXCEPTIONS   0
#   undef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#   undef FP_ROUNDMODE
#   define FP_ROUNDMODE   FP_RND_ZERO
#   undef _FP_TININESS_AFTER_ROUNDING
#   define _FP_TININESS_AFTER_ROUNDING   0
#endif
#ifdef FP_NO_EXACT_UNDERFLOW
#   undef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#endif

// Define values for FE_* modes not defined for this architecture
#ifdef FE_DOWNWARD
#   define ORIG_FE_DOWNWARD   FE_DOWNWARD
#else
#   define ORIG_FE_DOWNWARD   0
#endif
#ifdef FE_TONEAREST
#   define ORIG_FE_TONEAREST   FE_TONEAREST
#else
#   define ORIG_FE_TONEAREST   0
#endif
#ifdef FE_TOWARDZERO
#   define ORIG_FE_TOWARDZERO   FE_TOWARDZERO
#else
#   define ORIG_FE_TOWARDZERO   0
#endif
#ifdef FE_UPWARD
#   define ORIG_FE_UPWARD   FE_UPWARD
#else
#   define ORIG_FE_UPWARD   0
#endif
#define FE_CONSTRUCT_DISTINCT_VALUE(X, Y, Z)   ((((X) & 1) | ((Y) & 2) | ((Z) & 4)) ^ 7)
#ifndef FE_DOWNWARD
#   define FE_DOWNWARD   (((ORIG_FE_TONEAREST & 1) | (ORIG_FE_TOWARDZERO & 2) | (ORIG_FE_UPWARD & 4)) ^ 7)
#endif
#ifndef FE_TONEAREST
#   define FE_TONEAREST   (((FE_DOWNWARD & 1) | (ORIG_FE_TOWARDZERO & 2) | (ORIG_FE_UPWARD & 4)) ^ 7)
#endif
#ifndef FE_TOWARDZERO
#   define FE_TOWARDZERO   (((FE_DOWNWARD & 1) | (FE_TONEAREST & 2) | (ORIG_FE_UPWARD & 4)) ^ 7)
#endif
#ifndef FE_UPWARD
#   define FE_UPWARD   (((FE_DOWNWARD & 1) | (FE_TONEAREST & 2) | (FE_TOWARDZERO & 4)) ^ 7)
#endif

enum ROUNDING_DIRECTIONS {
	TONEAREST = FE_TONEAREST,
	TOWARDZERO = FE_TOWARDZERO,
	UPWARD = FE_UPWARD,
	DOWNWARD = FE_DOWNWARD
};

// MSVC Aliases
#ifndef _RC_NEAR
#   define _RC_NEAR   FE_TONEAREST
#endif
#ifndef _RC_CHOP
#   define _RC_CHOP   FE_TOWARDZERO
#endif
#ifndef _RC_UP
#   define _RC_UP   FE_UPWARD
#endif
#ifndef _RC_DOWN
#   define _RC_DOWN   FE_DOWNWARD
#endif

#ifndef add_ssaaaa
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   do { const UWtype __x = (al) + (bl); (sh) = (ah) + (bh) + (__x < (al)); (sl) = __x; } while (0x0)
#endif
#ifndef sub_ddmmss
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   do { const UWtype __x = (al) - (bl); (sh) = (ah) - (bh) - (__x > (al)); (sl) = __x; } while (0x0)
#endif
#if ((!defined(umul_ppmm)) && defined(smul_ppmm))
#   define umul_ppmm(w1, w0, u, v)   do { UWtype __w1; UWtype __xm0 = (u), __xm1 = (v); smul_ppmm(__w1, w0, __xm0, __xm1); (w1) = __w1 + (-(__xm0 >> (W_TYPE_SIZE - 1)) & __xm1) + (-(__xm1 >> (W_TYPE_SIZE - 1)) & __xm0); } while (0x0)
#endif
#ifndef umul_ppmm
#   define umul_ppmm(w1, w0, u, v)   do { const UHWtype __ul = __ll_lowpart(u); const UHWtype __uh = __ll_highpart(u); const UHWtype __vl = __ll_lowpart(v); const UHWtype __vh = __ll_highpart(v); UWtype __x0 = (UWtype)(__ul * __vl); register UWtype __x1 = (UWtype)(__ul * __vh); const UWtype __x2 = (UWtype)(__uh * __vl); register UWtype __x3 = (UWtype)(__uh * __vh); __x1 += __ll_highpart(__x0); __x1 += __x2; if (__x1 < __x2) { __x3 += __ll_B; } (w1) = __x3 + __ll_highpart(__x1); (w0) = __ll_lowpart(__x1) * __ll_B + __ll_lowpart(__x0); } while (0x0)
#endif
#ifndef __umulsidi3
#   define __umulsidi3(u, v)   __extension__ ({ DWunion __w = { .ll = 0 }; umul_ppmm(__w.s.high, __w.s.low, u, v); __w.ll; })
#endif
#if (!defined(udiv_qrnnd) && defined(sdiv_qrnnd))
#   define udiv_qrnnd(q, r, nh, nl, d)   do { extern UWtype __udiv_w_sdiv(UWtype*, UWtype, UWtype, UWtype); UWtype __r = 0; (q) = __udiv_w_sdiv(&__r, nh, nl, d); (r) = __r; } while (0x0)
#endif
#ifndef __udiv_qrnnd_c
#   define __udiv_qrnnd_c(q, r, n1, n0, d)   do { const UWtype __d1 = __ll_highpart(d); const UWtype __d0 = __ll_lowpart(d); register UWtype __r1 = (n1) % __d1; const UWtype __q1 = (n1) / __d1; const UWtype __m = (UWtype)(__q1 * __d0); __r1 = __r1 * __ll_B | __ll_highpart(n0); if (__r1 < __m) { __q1--, __r1 += (d); if (__r1 >= (d) && (__r1 < __m)) { __q1--, __r1 += (d); } } __r1 -= __m; register UWtype __r0 = __r1 % __d1; const UWtype __q0 = __r1 / __d1; __m = (UWtype)(__q0 * __d0); __r0 = __r0 * __ll_B | __ll_lowpart(n0); if (__r0 < __m) { __q0--, __r0 += (d); if (__r0 >= (d) && (__r0 < __m)) { __q0--, __r0 += (d); } } __r0 -= __m; (q) = (UWtype)(__q1 * __ll_B | __q0); (r) = __r0; } while (0x0)
#endif
#ifndef udiv_qrnnd
#   define UDIV_NEEDS_NORMALIZATION   1
#   define udiv_qrnnd   __udiv_qrnnd_c
#endif
#ifndef UDIV_NEEDS_NORMALIZATION
#   define UDIV_NEEDS_NORMALIZATION   0
#endif


#if (!(defined(CPU_MATH_PRIVATE_H) || defined(_CPU_MATH_PRIVATE_H_) || defined(GENERIC_MATH_PRIVATE_H) || defined(_GENERIC_MATH_PRIVATE_H_)))  // GENERIC FENV FUNCTIONS
#   define CPU_MATH_PRIVATE_H   (1)
#   define _CPU_MATH_PRIVATE_H_   (1)
#   define GENERIC_MATH_PRIVATE_H   (1)
#   define _GENERIC_MATH_PRIVATE_H_   (1)


#   ifndef FE_ALL_EXCEPT
#      define FE_ALL_EXCEPT   (0)
#   endif
typedef unsigned int   fexcept_t;
typedef struct { fexcept_t __excepts; }   fenv_t;
#   define FE_DFL_ENV   ((const fenv_t*)(-1L))


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


/** Clear given exceptions in current floating-point environment */
LIB_FUNC int feclearexcept(const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Enable floating-point exceptions */
LIB_FUNC int feenableexcept(const int excepts) {
	if (excepts != 0) { return -1; }  // Signal failure if any exception traps are to be enabled
	return 0;
}


/** Disable floating-point exceptions */
LIB_FUNC int fedisableexcept(const int excepts) {
	return (excepts != 0);  // All exception traps are disabled
}


/** Store current floating-point environment */
LIB_FUNC int fegetenv(const fenv_t* restrict fenvp) {
	return fenvp;
}


/** Get floating-point exceptions */
LIB_FUNC int fegetexcept(void) {
	return 0;  // All exception traps are disabled
}


/** Return current rounding direction */
LIB_FUNC int fegetround(void) {
#   ifdef FE_TONEAREST
	return FE_TONEAREST;
#   else
	return 0;
#   endif
}


/** Store current floating-point environment and clear exceptions */
LIB_FUNC int feholdexcept(const fenv_t* restrict fenvp) {
	fegetenv(fenvp);
	fedisableexcept(FE_ALL_EXCEPT);
	feclearexcept(FE_ALL_EXCEPT);
	return 0;
}


/** Initialize the given floating-point environment */
LIB_FUNC int fesetenv(const fenv_t* restrict fenvp) {
#   if (defined(FE_NOMASK_ENV) && (FE_ALL_EXCEPT != 0))
	if (fenvp == FE_NOMASK_ENV) { return 1; }
#   endif
	return fenvp;  // Nothing to do
}


/** Set floating-point environment exception handling */
LIB_FUNC int fesetexcept(const fexcept_t* restrict flagp, const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Set rounding direction */
LIB_FUNC int fesetround(const int round) {
#   ifdef FE_TONEAREST
	return ((round == FE_TONEAREST) ? 0 : 1);
#   else
	return round;  // Unable to set the direction
#   endif
}


/** Raise given exceptions */
LIB_FUNC int feraiseexcept(const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Test exception in current environment */
LIB_FUNC int fetestexcept(const int excepts) {
	return excepts;
}


/** Initialize the given floating-point environment and raise exceptions */
LIB_FUNC int feupdateenv(const fenv_t* restrict fenvp) {
#   if (defined(FE_NOMASK_ENV) && (FE_ALL_EXCEPT != 0))
	if (fenvp == FE_NOMASK_ENV) { return 1; }
#   endif
	return fenvp;  // Nothing to do
}


#   if IS_HARDFP  // E1-16/32X FPU


#      define FE_INEXACT   0x100
#      define FE_UNDERFLOW   0x200
#      define FE_OVERFLOW   0x400
#      define FE_DIVBYZERO   0x800
#      define FE_INVALID   0x1000
#      define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
#      define FE_TONEAREST   0
#      define FE_TOWARDZERO   0x2000
#      define FE_DOWNWARD   0x4000
#      define FE_UPWARD   0x6000


typedef unsigned int   fexcept_t;
typedef struct fenv {
	unsigned int round_mode, trap_enabled, accrued_except, actual_except;
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


static const UNUSED fenv_t FE_DFL_ENV_OBJ = { 0, 0x1c00, 0, 0 };
#      define FE_DFL_ENV   &FE_DFL_ENV_OBJ


/** Clear given exceptions in current floating-point environment */
LIB_FUNC int feclearexcept(const int excepts) {
	int enabled_excepts = 0;
	if (excepts & (~0x1f00)) { return -1; }  // Check that excepts is correctly set
	vasm("mov %0, SR;" : "=l"(enabled_excepts) :);
	enabled_excepts &= 0x1f00;
	int disabled_excepts = (~enabled_excepts);
	disabled_excepts &= 0x1f00;
	enabled_excepts &= excepts;
	disabled_excepts &= excepts;
	vasm(
		"andn G2, %0;" "andn G2, %1;" : /* No Output */
		: "l"(enabled_excepts), "l"((disabled_excepts >> 8))
	);  // Clear accrued exceptions
	return 0;
}


/** Enable floating-point exceptions */
LIB_FUNC int feenableexcept(const int excepts) {
	register int __retval = -1, __pexcepts = 0;
	const int __tmpexcepts = excepts;
	until_break {
		vasm("mov %0, SR;" : "=l"(__pexcepts));
		__pexcepts &= 0x1f00;
		if (__tmpexcepts & (~0x1f00)) {
			fprintf(stderr, "Non valid exception");
			break;
		}
		vasm("or SR, %0;" : : "l,r,i,n"(__tmpexcepts));
		__retval = __pexcepts;
		break;
	}
	return __retval;
}


/** Disable floating-point exceptions */
LIB_FUNC int fedisableexcept(const int excepts) {
	register int __retval = 0, __pexcepts = 0;
	const int __tmpexcepts = excepts;
	until_break {
		vasm("mov %0, SR;" : "=l"(__pexcepts));
		__pexcepts &= 0x1f00;
		if (__tmpexcepts & (int)(~0x1f00)) {
			__retval = -1;
			fprintf(stderr, "Non valid exception");
			break;
		}
		vasm("andn SR, %0;" : : "l,r,i,n"(__tmpexcepts));
		__retval = __pexcepts;
		break;
	}
	return __retval;
}


/** Store current floating-point environment */
LIB_FUNC int fegetenv(fenv_t* restrict fenvp) {
	vasm("mov %0, SR;" "mov %1, SR;" "mov %2, G2;" "mov %3, G2;" : "=l"(fenvp->round_mode), "=l"(fenvp->trap_enabled), "=l"(fenvp->accrued_except), "=l"(fenvp->actual_except) : );
	fenvp->round_mode &= 0x6000;
	fenvp->trap_enabled &= 0x1f00;
	fenvp->accrued_except &= 0x1f;
	fenvp->accrued_except <<= 8;
	fenvp->actual_except &= 0x1f00;
	return 0;
}


/** Get floating-point exceptions */
LIB_FUNC int _fegetexcept(void) {
	register unsigned int tmp;
	vasm("mov %0, SR;" : "=l"(tmp));
	return (tmp & 0x1f00);
}


/** Return current rounding direction */
LIB_FUNC int fegetround(void) {
	register unsigned int tmp;
	vasm("mov %0, SR;" : "=l"(tmp));
	return (tmp & 0x6000);
}


/** Store current floating-point environment and clear exceptions */
LIB_FUNC int feholdexcept(fenv_t* restrict fenvp) {
	fegetenv(fenvp);
	fedisableexcept(FE_ALL_EXCEPT);
	feclearexcept(FE_ALL_EXCEPT);
	return 0;
}


/** Initialize the given floating-point environment */
LIB_FUNC int fesetenv(fenv_t* restrict fenvp) {
	register unsigned long clearSR = 0x7f00;
	vasm("andn SR, %0;" "or SR, %1;" "or SR, %2;" : : "l"(clearSR), "l"(fenvp->round_mode), "l"(fenvp->trap_enabled));
	vasm("andn G2, 0x1f1f;" "or G2, %0;" "or G2, %1;" : : "l"((fenvp->accrued_except >> 8)), "l"(fenvp->actual_except));
	return 0;
}


/** Set rounding direction */
LIB_FUNC int fesetround(const int round) {
	register unsigned int tmp = 0x6000;
	until_break {
		vasm("andn SR, %0;" : : "l"(tmp));
		tmp &= (unsigned int)round;
		if (tmp) {
			tmp = (unsigned int)-1;
			break;
		}
		vasm("or SR, %0;" : : "l"(round));
		tmp = 0;
		break;
	}
	return (int)tmp;
}


/** Raise given exceptions */
LIB_FUNC int feraiseexcept(const int excepts) {
	vasm("or G2, %0;" : : "l"((excepts >> 8)));
	return 0;
}


/** Test exception in current environment */
LIB_FUNC int fetestexcept(const int excepts) {
	register unsigned int G2, G2en, G2dis, enabled_excepts, disabled_excepts;
	if (excepts & (~0x1f00)) { return -1; }
	vasm("mov %0, SR;" : "=l"(enabled_excepts));
	enabled_excepts &= 0x1f00;
	disabled_excepts = (~enabled_excepts);
	disabled_excepts &= 0x1f00;
	vasm("mov %0, G2;" : "=l"(G2));
	G2en = G2 & 0x1f00;
	G2dis = G2 & 0x1f;
	G2en &= enabled_excepts;
	G2dis &= (disabled_excepts >> 8);
	return (int)(G2en | (G2dis << 8));
}


/** Initialize the given floating-point environment and raise exceptions */
LIB_FUNC int feupdateenv(fenv_t* restrict fenvp) {
	register unsigned long clearSR = 0x7f00;
	vasm("or SR, %1;" "or SR, %2;" : : "l"(clearSR), "l"(fenvp->round_mode), "l"(fenvp->accrued_except));
	vasm("or G2, %0;" "or G2, %1;" : : "l"((fenvp->accrued_except >> 8)), "l"(fenvp->actual_except));
	return 0;
}


#   endif  // IS_HARDFP


#   define fegetexceptflag(flagp, excepts)   fegetexcept((flagp), (excepts))
#   define fesetexceptflag(flagp, excepts)   fesetexcept((flagp), (excepts))
#   define _fegetexcept(flagp, excepts)   fegetexcept((flagp), (excepts))
#   define _fesetexcept(flagp, excepts)   fesetexcept((flagp), (excepts))


#endif  // CPU_MATH_PRIVATE_H


#ifndef GET_ROUNDING_MODE_DEFINED


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
#if (defined(_FPU_RC_DOWN) || defined(_FPU_RC_NEAREST) || defined(_FPU_RC_ZERO) || defined(_FPU_RC_UP))
	fpu_control_t fc;
#   ifdef _FPU_RC_DOWN
	const fpu_control_t mask = (0 | _FPU_RC_DOWN);
#   elif defined(_FPU_RC_NEAREST)
	const fpu_control_t mask = (0 | _FPU_RC_NEAREST);
#   elif defined(_FPU_RC_ZERO)
	const fpu_control_t mask = (0 | _FPU_RC_ZERO);
#   elif defined(_FPU_RC_UP)
	const fpu_control_t mask = (0 | _FPU_RC_UP);
#   endif
	_FPU_GETCW(fc);
	switch (fc & mask) {
#   ifdef _FPU_RC_DOWN
		case _FPU_RC_DOWN: return FE_DOWNWARD;
#   endif
#   if defined(_FPU_RC_NEAREST)
		case _FPU_RC_NEAREST: return FE_TONEAREST;
#   endif
#   if defined(_FPU_RC_ZERO)
		case _FPU_RC_ZERO: return FE_TOWARDZERO;
#   endif
#   if defined(_FPU_RC_UP)
		case _FPU_RC_UP: return FE_UPWARD;
#   endif
		default: abort();
	}
	UNREACHABLE
#else
	return FE_TONEAREST;
#endif
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#endif  // get_rounding_mode


/** @defgroup FENV_Aliases Various aliases for fenv-related functions and macros
@{ */  // (FB){

#define FENV_ALIAS_MACROS   (1)


LIB_FUNC void default_libc_feholdexcept(fenv_t* restrict e) {
	(void)feholdexcept(e);
}

#ifndef libc_feholdexcept
#   define libc_feholdexcept   default_libc_feholdexcept
#endif
#ifndef libc_feholdexceptf
#   define libc_feholdexceptf   default_libc_feholdexcept
#endif
#ifndef libc_feholdexceptl
#   define libc_feholdexceptl   default_libc_feholdexcept
#endif

LIB_FUNC void default_libc_fesetround(const int r) {
	(void)fesetround(r);
}

#ifndef libc_fesetround
#   define libc_fesetround   default_libc_fesetround
#endif
#ifndef libc_fesetroundf
#   define libc_fesetroundf   default_libc_fesetround
#endif
#ifndef libc_fesetroundl
#   define libc_fesetroundl   default_libc_fesetround
#endif

LIB_FUNC void default_libc_feholdexcept_setround(fenv_t* restrict e, const int r) {
	feholdexcept(e);
	fesetround(r);
}

#ifndef libc_feholdexcept_setround
#   define libc_feholdexcept_setround   default_libc_feholdexcept_setround
#endif
#ifndef libc_feholdexcept_setroundf
#   define libc_feholdexcept_setroundf   default_libc_feholdexcept_setround
#endif
#ifndef libc_feholdexcept_setroundl
#   define libc_feholdexcept_setroundl   default_libc_feholdexcept_setround
#endif

#ifndef libc_feholdsetround_53bit
#   define libc_feholdsetround_53bit   libc_feholdsetround
#endif

#ifndef libc_fetestexcept
#   define libc_fetestexcept   fetestexcept
#endif
#ifndef libc_fetestexceptf
#   define libc_fetestexceptf   fetestexcept
#endif
#ifndef libc_fetestexceptl
#   define libc_fetestexceptl   fetestexcept
#endif

LIB_FUNC void default_libc_fesetenv(fenv_t* e) {
	 (void)fesetenv(e);
}

#ifndef libc_fesetenv
#   define libc_fesetenv   default_libc_fesetenv
#endif
#ifndef libc_fesetenvf
#   define libc_fesetenvf   default_libc_fesetenv
#endif
#ifndef libc_fesetenvl
#   define libc_fesetenvl   default_libc_fesetenv
#endif

LIB_FUNC void default_libc_feupdateenv(fenv_t* restrict e) {
	(void)feupdateenv(e);
}

#ifndef libc_feupdateenv
#   define libc_feupdateenv   default_libc_feupdateenv
#endif
#ifndef libc_feupdateenvf
#   define libc_feupdateenvf   default_libc_feupdateenv
#endif
#ifndef libc_feupdateenvl
#   define libc_feupdateenvl   default_libc_feupdateenv
#endif

#ifndef libc_feresetround_53bit
#   define libc_feresetround_53bit   libc_feresetround
#endif

LIB_FUNC int default_libc_feupdateenv_test(fenv_t* restrict e, const int ex) {
	int ret = fetestexcept(ex);
	feupdateenv(e);
	return ret;
}

#ifndef libc_feupdateenv_test
#   define libc_feupdateenv_test   default_libc_feupdateenv_test
#endif
#ifndef libc_feupdateenv_testf
#   define libc_feupdateenv_testf   default_libc_feupdateenv_test
#endif
#ifndef libc_feupdateenv_testl
#   define libc_feupdateenv_testl   default_libc_feupdateenv_test
#endif

#ifndef libc_feholdsetround
#   define libc_feholdsetround   libc_feholdexcept_setround
#endif
#ifndef libc_feholdsetroundf
#   define libc_feholdsetroundf   libc_feholdexcept_setroundf
#endif
#ifndef libc_feholdsetroundl
#   define libc_feholdsetroundl   libc_feholdexcept_setroundl
#endif

#ifndef libc_feresetround
#   define libc_feresetround   libc_feupdateenv
#endif
#ifndef libc_feresetroundf
#   define libc_feresetroundf   libc_feupdateenvf
#endif
#ifndef libc_feresetroundl
#   define libc_feresetroundl   libc_feupdateenvl
#endif

#ifndef libc_feresetround_noex
#   define libc_feresetround_noex   libc_fesetenv
#endif
#ifndef libc_feresetround_noexf
#   define libc_feresetround_noexf   libc_fesetenvf
#endif
#ifndef libc_feresetround_noexl
#   define libc_feresetround_noexl   libc_fesetenvl
#endif

#ifndef HAVE_RM_CTX
#   define HAVE_RM_CTX   0
#endif

/** @} */  // }


#ifndef INTTYPE_FUNCTIONS
#define INTTYPE_FUNCTIONS   (1)


/** Return the absolute value; Accepts and returns intmax_t */
#define imaxabs(num)   ((intmax_t)((((intmax_t)(num)) < (intmax_t)0) ? (-(num)) : (num)))
/** Return the absolute value; Accepts and returns intmax_t */
#define __imaxabs(num)   imaxabs((num))
/** Return the absolute value of a long */
#define labs(num)   (long)((num > 0L) ? num : (-(num)))
/** Return the absolute value of a long */
#define __labs(num)   labs((num))
/** Return the absolute value of a long long */
#define llabs(num)   (long long)((num > 0LL) ? num : (-(num)))
/** Return the absolute value of a long long */
#define __llabs(num)   llabs((num))


/** Return the `imaxdiv_t` representation of the value of NUMER over DENOM */
LIB_FUNC imaxdiv_t imaxdiv(const intmax_t __numer, const intmax_t __denom) {
	return (imaxdiv_t){ (__numer / __denom), (__numer % __denom) };
}
#define imaxdiv_r(__numer, __denom)   imaxdiv((__numer), (__denom))


LIB_FUNC short_div_t short_div(const short num, const short den) {
	return (short_div_t) { (short)(num / den), (short)(num % den) };
}
#define short_div_r(__numer, __denom)   short_div((__numer), (__denom))


LIB_FUNC div_t div(const int num, const int den) {
	return (div_t){ (int)(num / den), (int)(num % den) };
}
#define div_r(__numer, __denom)   div((__numer), (__denom))


LIB_FUNC ldiv_t ldiv(const long num, const long den) {
	return (ldiv_t) { (long)(num / den), (long)(num % den) };
}
#define ldiv_r(__numer, __denom)   ldiv((__numer), (__denom))


LIB_FUNC lldiv_t lldiv(const long long num, const long long den) {
	return (lldiv_t){ (long long)(num / den), (long long)(num % den) };
}
#define lldiv_r(__numer, __denom)   lldiv((__numer), (__denom))


LIB_FUNC div8_t div8(const int8_t num, const int8_t den) {
	return (div8_t){ (int8_t)(num / den), (int8_t)(num % den) };
}


LIB_FUNC div16_t div16(const int16_t num, const int16_t den) {
	return (div16_t){ (int16_t)(num / den), (int16_t)(num % den) };
}


LIB_FUNC div32_t div32(const int32_t num, const int32_t den) {
	return (div32_t){ (num / den), (num % den) };
}


LIB_FUNC div64_t div64(const int64_t num, const int64_t den) {
	return (div64_t){ (num / den), (num % den) };
}


#if SUPPORTS_INT128
LIB_FUNC div128_t div128(const int128_t num, const int128_t den) {
	return (div128_t){ (num / den), (num % den) };
}
#endif


/** Use a 16-bit integer as a fraction; The numerator & denominator are each 8-bits */
#define MAKEFRACTION16(num, den)   ((((num) & 0xff) << 8) | ((den) & 0xff))
#define MAKE_FRACTION16(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR16(x)   ((x) & 0xff)
#define GET_NUMERATOR16(x)   (((x) >> 8) & 0xff)
/** Use a 32-bit integer as a fraction; The numerator & denominator are each 16-bits */
#define MAKEFRACTION32(num, den)   ((((num) & UINT16_MAX) << 16) | ((den) & UINT16_MAX))
#define MAKE_FRACTION32(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR32(x)   ((x) & UINT16_MAX)
#define GET_NUMERATOR32(x)   (((x) >> 16) & UINT16_MAX)
/** Use a 64-bit integer as a fraction; The numerator & denominator are each 32-bits */
#define MAKEFRACTION64(num, den)   ((((num) & UINT32_MAX) << 32) | ((den) & UINT32_MAX))
#define MAKE_FRACTION64(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR64(x)   ((x) & UINT32_MAX)
#define GET_NUMERATOR64(x)   (((x) >> 32) & UINT32_MAX)


/** Convert from 'int' to 'double', then from 'double' to 'long double' */
LIB_FUNC void _Qp_itoq(long double* result, const int a) {
	*result = (double)a;
	return;
}


LIB_FUNC size_t three_way_max(const size_t x, const size_t y, const size_t z) {
	if (x >= y && x >= z) { return x; }
	else if (y >= z) { return y; }
	return z;
}


LIB_FUNC size_t three_way_min(const size_t x, const size_t y, const size_t z) {
	if (x <= y && x <= z) { return x; }
	else if (y <= z) { return y; }
	return z;
}


LIB_FUNC size_t four_way_max(const size_t x, const size_t y, const size_t z, const size_t w) {
	if (x >= y && x >= z) { return ((x >= w) ? x : w); }
	else if (y >= z && y >= w) { return y; }
	else if (z >= w) { return z; }
	return w;
}


LIB_FUNC size_t four_way_min(const size_t x, const size_t y, const size_t z, const size_t w) {
	if (x <= y && x <= z) { return ((x <= w) ? x : w); }
	else if (y <= z && y <= w) { return y; }
	else if (z <= w) { return z; }
	return w;
}


#endif  // INTTYPE_FUNCTIONS

/** @} */  // }


// MISCELLANEOUS BIT/BYTE OPERATIONS

#define prefetch(addr, ...)   __builtin_prefetch((addr), __VA_ARGS__)


LIB_FUNC int get_bitmask_order(const unsigned int count) {
	return (int)fls(count);
}


LIB_FUNC int get_count_order(const unsigned int count) {
	register const int order = (int)(fls(count) - 1);
	if (count & (count - 1)) { return order + 1; }
	return order;
}


LIB_FUNC void mi_vector_hash(const void* restrict key, size_t len, const uint32_t seed, uint32_t hashes[3]) {
	const uint32_t mask[4] = { 0xff, 0xffff, 0xffffff, 0xffffffff };
	const uint32_t orig_len = (uint32_t)len;
	register uint32_t a = 0x9e3779b9, b = 0x9e3779b9, c = seed;
	const uint8_t* k;
	if ((uintptr_t)key & 3) {
		k = key;
		while (len >= 12) {
			a += le32dec(k);
			b += le32dec(k + 4);
			c += le32dec(k + 8);
			mix(a, b, c);
			k += 12;
			len -= 12;
		}
		c += orig_len;
		if (len > 8) {
			switch (len) {
				case 11: c += (uint32_t)k[10] << 24;
				case 10: c += (uint32_t)k[9] << 16;
				case 9: c += (uint32_t)k[8] << 8;
				default: break;
			}
			b += le32dec(k + 4);
			a += le32dec(k);
		} else if (len > 4) {
			switch (len) {
				case 8: b += (uint32_t)k[7] << 24;
				case 7: b += (uint32_t)k[6] << 16;
				case 6: b += (uint32_t)k[5] << 8;
				case 5: b += k[4];
				default: break;
			}
			a += le32dec(k);
		} else if (len) {
			switch (len) {
				case 4: a += (uint32_t)k[3] << 24;
				case 3: a += (uint32_t)k[2] << 16;
				case 2: a += (uint32_t)k[1] << 8;
				case 1: a += k[0];
				default: break;
			}
		}
	} else {
		const uint32_t* key32 = key;
		while (len >= 12) {
			a += le32toh(key32[0]);
			b += le32toh(key32[1]);
			c += le32toh(key32[2]);
			mix(a, b, c);
			key32 += 3;
			len -= 12;
		}
		c += orig_len;
		if (len > 8) {
			c += (le32toh(key32[2]) & mask[len - 9]) << 8;
			b += le32toh(key32[1]);
			a += le32toh(key32[0]);
		} else if (len > 4) {
			b += le32toh(key32[1]) & mask[len - 5];
			a += le32toh(key32[0]);
		} else if (len)
			a += le32toh(key32[0]) & mask[len - 1];
	}
	mix(a, b, c);
	hashes[0] = a;
	hashes[1] = b;
	hashes[2] = c;
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight32(const unsigned long w) {
	register unsigned int res = (unsigned int)((w & 0x55555555) + ((w >> 1) & 0x55555555));
	res = (unsigned int)((res & 0x33333333) + ((res >> 2) & 0x33333333));
	res = (unsigned int)((res & 0xf0f0f0f) + ((res >> 4) & 0xf0f0f0f));
	res = (unsigned int)((res & 0xff00ff) + ((res >> 8) & 0xff00ff));
	return (unsigned long)((res & UINT16_MAX) + ((res >> 16) & UINT16_MAX));
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight64(const uint64_t w) {
#   if LONG_EQ_32BITS
	return hweight32((unsigned int)(w >> 32)) + hweight32((unsigned int)w);
#   else
	register uint64_t res = (uint64_t)((w & 0x5555555555555555U) + ((w >> 1) & 0x5555555555555555U));
	res = (uint64_t)((res & 0x3333333333333333U) + ((res >> 2) & 0x3333333333333333U));
	res = (uint64_t)((res & 0xf0f0f0f0f0f0f0fU) + ((res >> 4) & 0xf0f0f0f0f0f0f0fU));
	res = (uint64_t)((res & 0xff00ff00ff00ffU) + ((res >> 8) & 0xff00ff00ff00ffU));
	res = (uint64_t)((res & 0xffff0000ffffU) + ((res >> 16) & 0xffff0000ffffU));
	return (unsigned long)((res & UINT32_MAX) + ((res >> 32) & UINT32_MAX));
#   endif
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight_long(const unsigned long w) {
#   if LONG_EQ_32BITS
	return (unsigned long)hweight32(w);
#   else
	return (unsigned long)hweight64(w);
#   endif
}


// MEMORY & STRING MANIPULATIONS


/** @def GFC
Return first character */
/** @def INCSTR
Move to next character given a bit-pointer */
#if IS_LITTLE_ENDIAN
#   define GFC(x)   ((x) & 0xff)
#   define INCSTR(x)   do { (x) >>= 8; } while (0x0)
#else
#   define GFC(x)   (((x) >> ((sizeof(x) * 8) - 8)) & 0xff)
#   define INCSTR(x)   do { (x) <<= 8; } while (0x0)
#endif
/** @def MKW
Make a word from the given integer */
/** @def STRALIGN
Return the alignment of a given string address */
#if IS_WORDSIZE_64
#   define MKW(x)   (x | x << 8 | x << 16 | x << 24 | x << 32 | x << 40 | x << 48 | x << 56)
#   define STRALIGN(x)   (((unsigned long)x & 7) ? 8 - ((unsigned long)x & 7) : 0)
#else
#   define MKW(x)   (x | x << 8 | x << 16 | x << 24)
#   define STRALIGN(x)   (((unsigned long)x & 3) ? 4 - ((unsigned long)x & 3) : 0)
#endif
/** Make the given string pointer point to the first found occurance of a null character */
#define point2null(str)   while (*str++);


/** Normal */
#define S_N   0
/** Comparing integral part */
#define S_I   3
/** Comparing fractionnal parts */
#define S_F   6
/** idem but with leading Zeroes only */
#define S_Z   9
// Result types
/** CMP: return diff */
#define CMP   2
/** LEN: compare using len_diff/diff */
#define LEN   3


static const UNUSED uint8_t align64 next_state[16] = {
	S_N, S_I, S_Z,  // S_N
	S_N, S_I, S_I,  // S_I
	S_N, S_F, S_F,  // S_F
	S_N, S_F, S_Z  // S_Z
};


static const UNUSED int8_t align64 result_type[36] = {
	CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,  // S_N
	CMP, -1, -1, +1, LEN, LEN, +1, LEN, LEN,  // S_I
	CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,  // S_F
	CMP, +1, +1, -1, CMP, CMP, -1, CMP, CMP  // S_Z
};


/** @defgroup String_Length Functions and macros for getting the length of strings in memory
@{ */  // (FB){

/** Return the length of a string */
LIB_FUNC NOLIBCALL NONNULL ATTR_PURE size_t strlen(const char* restrict str) {
	register const char* restrict s = NULL;
	for (s = str; *s; ++s);
	return (size_t)(s - str);
}
#define __strlen(_str)   strlen((_str))
#define _strlen(_str)   strlen((_str))
#define strlenx(_str)   strlen((_str))


/** Return the length of an unsigned string */
LIB_FUNC NOLIBCALL NONNULL ATTR_PURE size_t ustrlen(const unsigned char* restrict str) {
	register const unsigned char* restrict s = NULL;
	for (s = str; *s; ++s);
	return (size_t)(s - str);
}
#define __ustrlen(_str)   ustrlen((_str))
#define _ustrlen(_str)   ustrlen((_str))
#define ustrlenx(_str)   ustrlen((_str))


LIB_FUNC NOLIBCALL NONNULL ATTR_PURE size_t strnlen(const char* restrict s, const size_t maxlen) {
	register const char* restrict ss = s;
	register size_t len = maxlen;
	while ((len > 0) && *ss) { ++ss; --len; }
	return (size_t)(ss - s);
}


LIB_FUNC size_t ustrnlen(const unsigned char* restrict s, const size_t maxlen) {
	register const unsigned char* restrict ss = s;
	register size_t len = maxlen;
	while ((len > 0) && *ss) { ++ss; --len; }
	return (size_t)(ss - s);
}

/** @} */  // }


/** @defgroup Memory_and_String_Tests_and_Comparisons Functions and macros for testing and comparing memory regions and strings
@{ */  // (FB){

/**
@brief Return true if the two intervals overlap
@param[in] s1 Start address of the first interval
@param[in] sz1 Size of the first interval
@param[in] s2 Start address of the second interval
@param[in] sz2 Size of the second interval
*/
LIB_FUNC ATTR_CF int overlaps(const uint64_t s1, const uint64_t sz1, const uint64_t s2, const uint64_t sz2) {
	// Both sizes are non-zero
	if (sz1 && sz2) { return (int)((s1 <= (s2 + sz2 - 1)) && (s2 <= (s1 + sz1 - 1))); }
	// One size is non-zero
	else if (sz2) { return (int)((s1 >= s2) && (s1 <= (s2 + sz2 - 1))); }
	else if (sz1) { return (int)((s2 >= s1) && (s2 <= (s1 + sz1 - 1))); }
	// Both are zero
	return (int)(s1 == s2);
}


/**
@brief Return true if the second interval is within the first interval
@param[in] s1 Start address of the first interval
@param[in] sz1 Size of the first interval
@param[in] s2 Start address of the second interval
@param[in] sz2 Size of the second interval
*/
LIB_FUNC ATTR_CF int iswithin(const uint64_t s1, const uint64_t sz1, const uint64_t s2, const uint64_t sz2) {
	// Handle the two corner cases when either sz1 or sz2 are zero
	if (sz1 == 0) { return (int)((s1 == s2) && (sz2 == 0)); }
	else if (sz2 == 0) { return (int)((s1 <= s2) && (s2 <= (s1 + sz1 - 1))); }
	return (int)((s1 <= s2) && ((s1 + sz1 - 1) >= (s2 + sz2 - 1)));
}


/** Check for a valid number in `str` */
LIB_FUNC int is_number(const char* restrict str) {
	do { if ((*str - '0') > 9) { return 0; } } while (*++str != '\0');
	return 1;
}


/** Test if `pfx` is a prefix of `_string` */
LIB_FUNC const char* prefix(const char* restrict _string, const char* restrict pfx) {
	while (*pfx) { if (((*pfx++) != (*_string++))) { return 0; } }
	return (const char*)_string;
}


/** Test if two constant strings are the same */
LIB_FUNC NONNULL size_t consttime_memequal(const void* restrict b1, const void* restrict b2, size_t len) {
	const unsigned char *restrict c1 = b1, *restrict c2 = b2;
	register size_t res = 0;
	while (len--) { res |= (*c1++ ^ *c2++); }
	return (!res);
}


/** Compare two blocks of memory; Compares the first num bytes of the block of memory pointed by ptr1 to the first num bytes pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not */
LIB_FUNC int memcmp(const void* restrict ptr1, const void* restrict ptr2, const size_t _num) {
	const unsigned char *restrict l = ptr1, *restrict r = ptr2;
	register size_t num = _num;
	for (; num && (*l == *r); num--, l++, r++);
	return (int)(num ? (*l - *r) : 0);
}


LIB_FUNC int memcmp16(const unsigned short* ptr1, const unsigned short* ptr2, const size_t n) {
	register size_t i = 0;
	for (; i < n; i++) {
		if (*ptr1 != *ptr2) { return *ptr1 - *ptr2; }
		++ptr1;
		++ptr2;
	}
	return 0;
}
#define __memcmp16(ptr1, ptr2, len)   memcmp16((ptr1), (ptr2), (len))


// TODO: Add a function to emulate the VAX `cmpc5` instruction (Compare Character 5)
/** Emulate the VAX `cmpc3` instruction (Compare Character 3) */
LIB_FUNC int bcmp(const void* b1, const void* b2, register size_t len) {
	const char *p1 = b1, *p2 = b2;
	if (b1 == 0 || b2 == 0) { return -1; }
	else if (len == 0) { return 0; }
	do { if (*p1++ != *p2++) { break; } } while (--len);
	return (int)(len != 0);
}
#define cmpc3(b1, b2, len)   bcmp((b1), (b2), (len))


LIB_FUNC int timingsafe_bcmp(const void* b1, const void* b2, const size_t len) {
	const unsigned char *p1 = b1, *p2 = b2;
	register int ret = 0;
	register size_t n = len;
	for (; n > 0; n--) { ret |= ((*p1++) ^ (*p2++)); }
	return (ret != 0);
}


LIB_FUNC int timingsafe_memcmp(const void* b1, const void* b2, const size_t len) {
	const unsigned char *p1 = b1, *p2 = b2;
	register size_t i = 0;
	int res = 0, done = 0, lt = 0, gt = 0;
	for (; i < len; i++) {
		// lt is -1 if p1[i] < p2[i]; else 0
		lt = (int)((p1[i] - p2[i]) >> CHAR_BIT);
		// gt is -1 if p1[i] > p2[i]; else 0
		gt = (int)((p2[i] - p1[i]) >> CHAR_BIT);
		// set res = cmp if !done
		res |= (int)((int)(lt - gt) & (~done));  // `lt - gt` is 1 if p1[i] > p2[i]; -1 if p1[i] < p2[i]; else 0
		// set done if p1[i] != p2[i]
		done |= (int)(lt | gt);
	}
	return (int)res;
}


LIB_FUNC const char* twobyte_memmem(const unsigned char* h, const size_t len, const unsigned char* restrict n) {
	const uint16_t nw = (uint16_t)(n[0] << 8 | n[1]);
	register uint16_t hw = (uint16_t)(h[0] << 8 | h[1]);
	register size_t k = len - 1;
	for (h++; k; --k, (hw = (uint16_t)((hw << 8) | *++h))) { if (hw == nw) { return (const char*)((const char*)h - 1); } }
	return 0;
}


LIB_FUNC const char* threebyte_memmem(const unsigned char* h, const size_t len, const unsigned char* restrict n) {
	const uint32_t nw = (uint32_t)((n[0] << 24) | (n[1] << 16) | (n[2] << 8));
	register uint32_t hw = (uint32_t)((h[0] << 24) | (h[1] << 16) | (h[2] << 8));
	register size_t k = len - 2;
	for (h += 2; k; k--, hw = (uint32_t)((hw | *++h) << 8)) { if (hw == nw) { return (const char*)((const char*)h - 2); } }
	return 0;
}


LIB_FUNC const char* fourbyte_memmem(const unsigned char* h, const size_t len, const unsigned char* restrict n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3]);
	register uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3]);
	register size_t k = len - 3;
	for (h += 3; k; k--, hw = (uint32_t)(hw << 8 | *++h)) { if (hw == nw) { return (const char*)((const char*)h - 3); } }
	return 0;
}


LIB_FUNC const char* twoway_memmem(const unsigned char* h, const unsigned char* z, const unsigned char* n, const size_t l) {
	size_t align64 byteset[32 / SIZEOF_SIZE_T] = { 0 };
	size_t align64 shift[256] = { 0 };
	register size_t i = 0;
	for (; i < l; i++) {
		((byteset)[(size_t)(n[i]) / (8 * sizeof(*(byteset)))] |= (size_t)1 << ((size_t)(n[i]) % (8 * sizeof(*(byteset)))));
		shift[n[i]] = i + 1;
	}
	size_t ip = (size_t)-1;
	size_t jp = 0;
	size_t k = 1;
	size_t p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] > n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	size_t ms = ip;
	size_t p0 = p;
	ip = (size_t)-1;
	jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] < n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip + 1 > ms + 1) { ms = ip; }
	else { p = p0; }
	size_t mem0 = 0;
	if (memcmp(n, (n + p), (size_t)(ms + 1))) {
		p = MAX(ms, (l - ms - 1)) + 1;
	} else { mem0 = l - p; }
	size_t mem = 0;
	loop_forever {  // Search loop
		if ((size_t)(z - h) < l) { return 0; }  // If remainder of haystack is shorter than needle, done
		else if (((byteset)[(size_t)(h[l - 1]) / (8 * sizeof(*(byteset)))] & (size_t)1 << ((size_t)(h[l - 1]) % (8 * sizeof(*(byteset)))))) {  // Check last byte first; advance by shift on mismatch
			k = l - shift[h[l - 1]];
			if (k) {
				if (mem0 && mem && k < p) { k = l - p; }
				h += k;
				mem = 0;
				continue;
			}
		} else {
			h += l;
			mem = 0;
			continue;
		}
		// Compare right half
		for (k = MAX((ms + 1), mem); k < l && n[k] == h[k]; k++);
		if (k < l) {
			h += k - ms;
			mem = 0;
			continue;
		}
		// Compare left half
		for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--);
		if (k <= mem) { return (const char*)h; }
		h += p;
		mem = mem0;
	}
}


LIB_FUNC const void* memmem(const void* h0, const size_t len, const void* n0, const size_t len2) {
	const unsigned char *h = h0, *n = n0;
	register size_t k = len;
	if (!len2) { return (const void*)h; }
	else if (k < len2) { return 0; }
	h = memchr(h0, *n, k);
	if (!h || len2 == 1) { return (const void*)h; }
	k -= (size_t)(h - (const unsigned char*)h0);
	if (len2 == 2) { return (const void*)twobyte_memmem(h, k, n); }
	else if (len2 == 3) { return (const void*)threebyte_memmem(h, k, n); }
	else if (len2 == 4) { return (const void*)fourbyte_memmem(h, k, n); }
	return (const void*)twoway_memmem(h, (h + k), n, len2);
}


LIB_FUNC int cistrcmp(const char* restrict s1, const char* restrict s2) {
	register int c1 = 0, c2 = 0;
	while (*s1) {
		c1 = *(const unsigned char*)s1++;
		c2 = *(const unsigned char*)s2++;
		if (c1 == c2) { continue; }
		else if (c1 >= 'A' && c1 <= 'Z') { c1 -= ('A' - 'a'); }
		if (c2 >= 'A' && c2 <= 'Z') { c2 -= ('A' - 'a'); }
		if (c1 != c2) { return (int)(c1 - c2); }
	}
	return (int)(-(*s2));
}


/** Compare two strings; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC NOLIBCALL NONNULL ATTR_PF int strcmp(const char* restrict s1, const char* restrict s2) {
	register unsigned int c1 = 0, c2 = 0;
	loop_forever {
		c1 = (unsigned int)(*s1++);
		c2 = (unsigned int)(*s2++);
		if (c1 != c2) {
			if (c1 > c2) { return 1; }
			return -1;
		} else if (c1 == 0) { return 0; }
	}
	UNREACHABLE
}
#define equal(s1, s2)   (strcmp(s1, s2) == 0)
#define isstrequal(s1, s2)   (strcmp(s1, s2) == 0)
#define is_str_equal(s1, s2)   (strcmp(s1, s2) == 0)
#define is_same_str(s1, s2)   (strcmp(s1, s2) == 0)


/** Compare two unsigned strings; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC int ustrcmp(const unsigned char* restrict s1, const unsigned char* restrict s2) {
	register unsigned int c1 = 0, c2 = 0;
	loop_forever {
		c1 = (unsigned int)(*s1++);
		c2 = (unsigned int)(*s2++);
		if (c1 != c2) {
			if (c1 > c2) { return 1; }
			return -1;
		} else if (c1 == 0) { return 0; }
	}
	UNREACHABLE
}


/** Compare two strings case-insensitively; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC int strcasecmp(const char* s1, const char* s2) {
	if ((s1 == NULL) || (s2 == NULL)) { return 0; }
	const unsigned char* us1 = (const unsigned char*)s1;
	const unsigned char* us2 = (const unsigned char*)s2;
	while (tolower(*us1) == tolower(*us2)) {
		++us2;
		if (*us1++ == '\0') { return 0; }
	}
	--us2;
	return (int)(tolower(*us1) - tolower((*us2)));
}
#define _stricmp(str1, str2)   strcasecmp((str1), (str2))  // MS-Windows names string functions differently
#define stricmp(str1, str2)   strcasecmp((str1), (str2))  // MS-Windows names string functions differently


LIB_FUNC int strcasecmp_l(const char* l, const char* r, const UNUSED locale_t loc) {
	return strcasecmp(l, r);
}
#define __strcasecmp_l(l, r, loc)   strcasecmp_l((l), (r), (loc))


/** Compare two strings case-insensitively */
LIB_FUNC int strncasecmp(const char* restrict s1, const char* restrict s2, const size_t len) {
	register size_t n = len;
	if ((s1 == NULL) || (s2 == NULL) || (n == 0)) { return 0; }
	else if (n != 0) {
		const unsigned char* restrict us1 = (const unsigned char*)s1;
		const unsigned char* restrict us2 = (const unsigned char*)s2;
		do {
			if (tolower(*us1) != tolower(*us2)) {
				return (tolower(*us1) - tolower(*us2));
			} else if (*us1++ == '\0') { break; }
		} while (--n != 0);
	}
	return 0;
}
#define _strnicmp(str1, str2, length)   strncasecmp((str1), (str2), (length))  // Windows names string functions differently
#define strnicmp(str1, str2, length)   strncasecmp((str1), (str2), (length))  // Windows names string functions differently


LIB_FUNC int strncasecmp_l(const char* restrict l, const char* restrict r, size_t n, const UNUSED locale_t loc) {
	return strncasecmp(l, r, n);
}
#define __strncasecmp_l(l, r, n, loc)   strncasecmp_l((l), (r), (n), (loc))


/** Compare strings according to LC_COLLATE category of current locale */
LIB_FUNC int strcoll(const char* restrict s1, const char* restrict s2, const UNUSED locale_t _lang) {
	return strcmp(s1, s2);
}


/** Compares up to `len` characters of the string s1 to those of s2; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until - the characters differ, a terminating null-character is found, or `len` characters match in both strings */
LIB_FUNC NONNULL ATTR_PF int strncmp(const char* restrict s1, const char* restrict s2, const size_t len) {
	const unsigned char* restrict c1 = (const unsigned char*)s1;
	const unsigned char* restrict c2 = (const unsigned char*)s2;
	register unsigned char ch = 0;
	register int d = 0;
	register size_t n = len;
	while (n--) {
		d = (int)(ch = *c1++) - ((int)*c2++);
		if (d || (!ch)) { break; }
	}
	return d;
}


/** Wrapper around strcmp for `qsort()` and `bsearch()` */
LIB_FUNC int pstrcmp(const void* s1, const void* s2) {
	return strcmp(*(const char *const*)s1, *(const char *const*)s2);
}


/** Compare strings while treating digits characters numerically */
LIB_FUNC int strverscmp(const char* s1, const char* s2) {
	if (s1 == s2) { return 0; }
	const unsigned char* p1 = (const unsigned char*)s1;
	const unsigned char* p2 = (const unsigned char*)s2;
	unsigned char c1 = *p1++;
	unsigned char c2 = *p2++;
	int _state = (int)(S_N + ((c1 == '0') + (isdigit(c1) != 0)));
	register int diff;
	while ((diff = c1 - c2) == 0) {
		if (c1 == '\0') { return diff; }
		_state = next_state[_state];
		c1 = *p1++;
		c2 = *p2++;
		_state += (c1 == '0') + (isdigit(c1) != 0);
	}
	_state = result_type[_state * 3 + (((c2 == '0') + (isdigit(c2) != 0)))];
	switch (_state) {
		case CMP: return diff;
		case LEN:
			while (isdigit(*p1)) { ++p1; if (!(isdigit(*p2))) { return 1; } else { ++p2; } }
			return (isdigit(*p2) ? -1 : diff);
		default: return _state;
	}
}
#define __strverscmp(s1, s2)   strverscmp((s1), (s2))

/** @} */  // }


/** @defgroup Copy_Memory_and_Strings Functions and macros for copying memory and strings
@{ */  // (FB){

/** Copy block of memory; Copies the values of `len` bytes from the location pointed to by source directly to the memory block pointed to by destination */
LIB_FUNC NOLIBCALL NONNULL void* memcpy(void* restrict dest, const void* restrict src, const size_t len) {
	if (len != 0) {
		char* restrict s1 = (char*)dest;
		const char* restrict s2 = (const char*)src;
		register size_t i = len;
		do { *s1++ = *s2++; } while (--i != 0);
	}
	return dest;
}
#define COPY(fp, src, len)   (void)memcpy((void*)fp->rpos, (void*)src, (size_t)(len))


/** Copy block of memory; Copies the values of `len` bytes from the location pointed to by source directly to the memory block pointed to by destination; No value is returned */
LIB_FUNC NOLIBCALL NONNULL void memcpy_no_output(void* restrict dest, const void* restrict src, const size_t len) {
	if (len != 0) {
		char* restrict s1 = (char*)dest;
		const char* restrict s2 = (const char*)src;
		register size_t i = len;
		do { *s1++ = *s2++; } while (--i != 0);
	}
}


/** Copy block of volatile memory; Copies the values of `len` bytes from the location pointed to by source directly to the memory block pointed to by destination; No value is returned */
LIB_FUNC void vmemcpy_no_output(void* restrict dest, const volatile void* restrict src, const size_t len) {
	if (len != 0) {
		char* restrict s1 = dest;
		const volatile char* restrict s2 = src;
		register size_t i = len;
		do { *s1++ = *s2++; } while (--i != 0);
	}
}


LIB_FUNC void* __memcpy_chk(void* restrict dst, const void* restrict src, const size_t len, const size_t slen) {
	if (len > slen) { __chk_fail("*** memcpy() terminated ***"); }
	return memcpy(dst, src, len);
}
#define memcpy_chk(dst, src, len, slen)   __memcpy_chk((dst), (src), (len), (slen))


/** Copy memory to memory until the specified number of bytes has been copied; return pointer to following byte */
LIB_FUNC NOLIBCALL NONNULL void* mempcpy(void* restrict dest, const void* restrict src, const size_t len) {
	return (void*)((size_t*)memcpy(dest, src, len) + len);
}
#define __mempcpy(dest, src, len)   mempcpy((dest), (src), (len))
#define MEMPCPY(dest, src, len)   mempcpy((dest), (src), (len))


/** Copy block of memory; Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination */
LIB_FUNC NOLIBCALL NONNULL void* memccpy(void* restrict dest, const void* restrict src, const int c, const size_t len) {
	register size_t n = len;
	char *restrict q = dest;
	const char* restrict p = src;
	char ch = '\0';
	while (--n) {
		*q++ = ch = *p++;
		if (ch == (char)c) { return q; }
	}
	return NULL;
}


/** Copy the string pointed to by `s` to `buf`; stop at NULL or `maxlen` (whichever occurs first); return the number of bytes copied */
LIB_FUNC NOLIBCALL NONNULL int copystring(char* restrict buf, const unsigned int maxlen, const char* restrict s) {
	register unsigned int i = 0;
	for (; s[i] != '\0' && i < maxlen; ++i) { buf[i] = s[i]; }
	return (int)i;
}


/** Copies `n` bytes from `src` to `dest`; Both areas are allowed to overlap */
LIB_FUNC void bcopy(const void* restrict src, void* dest, register size_t length) {
	const char* f = src;
	char* t = dest;
	while (length-- > 0) { *t++ = *f++; }
	return;
}


LIB_FUNC char* strcpy(char* restrict dest, const char* restrict src) {
	const unsigned char* s = (const unsigned char*)src;
	unsigned char* d = (unsigned char*)dest;
	while ((*d++ = *s++));
	return (char*)dest;
}
#define scopy(s1, s2)   ((void*)strcpy(s2, s1))
#define gnu_strcpy(d, s)   strcpy((d), (s))


LIB_FUNC char* __strcpy_chk(char* restrict dst, const char* restrict src, const size_t slen) {
	const size_t len = strlen(src) + 1;
	if (len > slen) { __chk_fail("*** strcpy() terminated ***"); }
	return memcpy(dst, src, len);
}


LIB_FUNC void strcpy_no_output(char* restrict dest, const char* restrict src) {
	const unsigned char* s = (const unsigned char*)src;
	unsigned char* d = (unsigned char*)dest;
	while ((*d++ = *s++));
}
#define scopy_no_output(s1, s2)   strcpy_no_output(s2, s1)


LIB_FUNC uchar* ustrcpy(uchar* restrict dest, const uchar* restrict src) {
	uchar* d = (uchar*)dest;
	while ((*d++ = *src++));
	return (uchar*)dest;
}


/** Copies the first num characters of source to destination */
LIB_FUNC char* strncpy(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t i = 0;
	char* os1 = dest;
	for (; i < len; i++) {
		if ((*dest++ = *src++) == 0) {
			while (++i < len) { *dest++ = 0; }
			return os1;
		}
	}
	return os1;
}


/** Copies the first num characters of source to destination */
LIB_FUNC void strncpy_no_output(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t i = 0;
	for (; i < len; i++) {
		if ((*dest++ = *src++) == 0) { while (++i < len) { *dest++ = 0; } break; }
	}
}


LIB_FUNC char* strecpy(char* restrict to, char* e, const char* restrict from) {
	if (to >= e) { return to; }
	to = (char*)memccpy(to, from, '\0', (size_t)(e - to));
	if (to == nil) {
		to = (char*)(e - 1);
		*to = '\0';
	} else { --to; }
	return to;
}


LIB_FUNC size_t strlcpy(char* d, const char* s, const size_t len) {
	char* d0 = d;
	size_t* wd = NULL;
	const size_t* ws = NULL;
	register size_t n = len;
	if (!n--) { return (size_t)((size_t)(d - d0) + strlen(s)); }
	else if (((uintptr_t)s & (SIZEOF_SIZE_T - 1)) == ((uintptr_t)d & (SIZEOF_SIZE_T - 1))) {
		for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*d = *s); --n, ++s, ++d);
		if (n && *s) {
			wd = (void*)d;
			ws = (const void*)s;
			for (; n >= SIZEOF_SIZE_T && (!HASZERO(*ws)); n -= SIZEOF_SIZE_T, ws++, wd++) {
				*wd = *ws;
			}
			d = (void*)wd;
			s = (const void*)ws;
		}
	}
	for (; n && (*d = *s); --n, ++s, ++d);
	*d = 0;
	return (size_t)((size_t)(d - d0) + strlen(s));
}


LIB_FUNC char* stpcpy(char* restrict d, const char* restrict s) {
	const size_t* ws = NULL;
	if (((uintptr_t)s % SIZEOF_SIZE_T) == ((uintptr_t)d % SIZEOF_SIZE_T)) {
		for (; ((uintptr_t)s % SIZEOF_SIZE_T); s++, d++) {
			if (!(*d = *s)) { return d; }
		}
		size_t* wd = (void*)d;
		ws = (const void*)s;
		for (; (!HASZERO(*ws)); *wd++ = *ws++);
		d = (void*)wd;
		s = (const void*)ws;
	}
	for (; (*d = *s); s++, d++);
	return d;
}
#define __stpcpy(d, s)   stpcpy((d), (s))


LIB_FUNC char* stpncpy(char* restrict d, const char* restrict s, size_t n) {
	const size_t* ws = NULL;
	if (((uintptr_t)s & (SIZEOF_SIZE_T - 1)) == ((uintptr_t)d & (SIZEOF_SIZE_T - 1))) {
		for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*d = *s); n--, s++, d++);
		if (!n || !*s) { return memset(d, 0, n); }
		size_t* wd = (void*)d;
		ws = (const void*)s;
		for (; n >= SIZEOF_SIZE_T && (!HASZERO(*ws)); n -= SIZEOF_SIZE_T, ws++, wd++) { *wd = *ws; }
		d = (void*)wd;
		s = (const void*)ws;
	}
	for (; n && (*d = *s); n--, s++, d++);
	return memset(d, 0, n);
}
#define __stpncpy(d, s, n)   stpncpy((d), (s), (n))


/** Copy two-bytes at once from `src` to `dest` */
LIB_FUNC void swab(const char* restrict src, char* restrict dest, const ssize_t len) {
	register ssize_t n = len;
	for (; n > 1; n -= 2) {
		dest[0] = src[1];
		dest[1] = src[0];
		dest += 2;
		src += 2;
	}
	return;
}


/** Copy a string from `from` to `to`, truncating the string if necessary; `to` is always NULL terminated, even if truncation is performed; `size` is the size of `to` */
LIB_FUNC void scopyn(const char* restrict from, char* restrict to, register int size) {
	while (--size > 0) { if (((*to++) = (*from++)) == '\0') { return; } }
	*to = '\0';
}

/** @} */  // }


/** @defgroup Move_Memory Functions and macros for moving memory data
@{ */  // (FB){

/** Copies the values of `len` bytes from the location pointed by `src` to the memory block pointed by `dst`; Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap */
LIB_FUNC NOLIBCALL NONNULL void* memmove(void* dst, const void* src, const size_t len) {
	const char* p = src;
	char* q = dst;
	register size_t n = len;
#   ifdef ARCHX86
	if (q < p) {
		vasm("cld;" "rep;" "movsb;" : "+c"(n), "+S"(p), "+D"(q));
	} else {
		p += (n - 1);
		q += (n - 1);
		vasm("std;" "rep;" "movsb;" "cld;" : "+c"(n), "+S"(p), "+D"(q));
	}
#   else
	if (q < p) { while (n--) { *q++ = *p++; } }
	else {
		p += n;
		q += n;
		while (--n) { *--q = *--p; }
	}
#   endif
	return dst;
}
#define COPYSTRING(dest, source, srclen)   ((void*)memmove((void*)(dest), (const void*)(source), (size_t)((size_t)(srclen) + 1)))
#define CONCATSTRING(dest, source, dstlen, srclen)   ((void*)memmove((void*)((dest) + (dstlen)), (const void*)(source), (size_t)((size_t)(srclen) + 1)))


/** Copies the values of `len` bytes from the location pointed by `src` to the memory block pointed by `dst`; Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap */
LIB_FUNC NOLIBCALL NONNULL void memmove_no_output(void* dst, const void* src, const size_t len) {
	const char* p = src;
	char* q = dst;
	register size_t n = len;
#   ifdef ARCHX86
	if (q < p) {
		vasm("cld;" "rep;" "movsb;" : "+c"(n), "+S"(p), "+D"(q));
	} else {
		p += (n - 1);
		q += (n - 1);
		vasm("std;" "rep;" "movsb;" "cld;" : "+c"(n), "+S"(p), "+D"(q));
	}
#   else
	if (q < p) { while (n--) { *q++ = *p++; } }
	else {
		p += n;
		q += n;
		while (--n) { *--q = *--p; }
	}
#   endif
}


LIB_FUNC void* __memmove_chk(void* dst, const void* src, const size_t len, const size_t slen) {
	if (len > slen) { __chk_fail("*** memmove() terminated ***"); }
	return memmove(dst, src, len);
}

/** @} */  // }


/** @defgroup Set_Memory Functions and macros for setting data in memory to a particular value
@{ */  // (FB){

/** Sets the first num bytes of the block of memory pointed by dst to the specified value (interpreted as an unsigned char) */
LIB_FUNC NOLIBCALL NONNULL void* memset(void* restrict dst, const int c, const size_t len) {
	char* restrict q = dst;
	register size_t n = len;
#   ifdef ARCHX86_64
	size_t nl = (len >> 3);
	vasm("cld;" "rep;" "stosq;" "movl %3, %%ecx;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x101010101010101U), "r,i,n"((uint32_t)(n & 7)));
#   elif defined(ARCHX86_32)
	size_t nl = (len >> 2);
	vasm("cld;" "rep;" "stosl;" "movl %3, %0;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x1010101U), "r,i,n"(n & 3));
#   else
	while (n--) { *q++ = c; }
#   endif
	return dst;
}
/** Fill the selected memory area with zeros */
#define ZERO_FILL(x)   memset(&(x), 0, sizeof((x)))
/** Fill the selected memory area with zeros */
#define ZEROFILL(x)   ZERO_FILL((x))
/** Fill the selected memory area with zeros */
#define zero_fill(x)   ZERO_FILL((x))


LIB_FUNC void* __memset_chk(void* restrict dst, const int val, const size_t len, const size_t slen) {
	if (len > slen) { __chk_fail("*** memset() terminated ***"); }
	return memset(dst, val, len);
}
#define memset_chk(dst, val, len, slen)   __memset_chk((dst), (val), (len), (slen))
#define zero_fill_chk(x)   __memset_chk(&(x), 0, sizeof((x)), strlen(&(x)))


/** Sets the first num bytes of the block of memory pointed by `dst` to the specified value (interpreted as an unsigned char); no value is returned */
LIB_FUNC NOLIBCALL NONNULL void memset_no_output(void* restrict dst, const int c, const size_t len) {
	char* restrict q = dst;
	register size_t n = len;
#   ifdef ARCHX86_64
	size_t nl = (len >> 3);
	vasm("cld;" "rep;" "stosq;" "movl %3, %%ecx;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x101010101010101U), "r"((uint32_t)(n & 7)));
#   elif defined(ARCHX86_32)
	size_t nl = (len >> 2);
	vasm("cld;" "rep;" "stosl;" "movl %3, %0;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x1010101U), "r"(n & 3));
#   else
	while (n--) { *q++ = c; }
#   endif
}
/** Sets the first x bytes of the area starting at the specified address to zero */
#define memzero(addr, length)   memset_no_output((addr), 0, (length))
/** Sets the first x bytes of the area starting at the specified address to zero */
#define bzero(addr, length)   memset_no_output((addr), 0, (length))
/** Sets the first x bytes of the area starting at the specified address to zero */
#define explicit_bzero(addr, length)   memset_no_output((addr), 0, (length))


LIB_FUNC NOLIBCALL NONNULL void* memset2(void* restrict ap, const int c, const unsigned long len) {
	char* restrict p = ap;
	register long m = (long)len;
	while (m > 0) { *p++ = (char)c; --m; }
	return ap;
}

/** @} */  // }


/** @defgroup Find_Data_in_Memory Functions and macros for finding data in memory or substrings and characters within strings
@{ */  // (FB){

DIAG_PUSH
IGNORE_WCAST_ALIGN
/** Searches within the first `len` bytes of the block of memory pointed by `ptr` for the first occurrence of `x` (interpreted as an `unsigned char`), and returns a pointer to it */
LIB_FUNC NOLIBCALL const void* memchr(const void* src, const int x, const size_t len) {
	const unsigned char* s = src;
	register unsigned char c = (unsigned char)x;
	register size_t n = len;
	for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*s != c); s++, n--);
	if (n && (*s != c)) {
		const size_t* w;
		register size_t k = (((size_t)-1 / UCHAR_MAX) * c);
		for (w = (const size_t*)s; (n >= SIZEOF_SIZE_T) && (!(HASZERO((*w ^ k)))); ++w, n -= SIZEOF_SIZE_T);
		for (s = (const void*)w; n && (*s != c); ++s, --n);
	}
	return (const void*)(n ? s : 0);
}
DIAG_POP


/** Searches within the first `len` bytes of the block of memory pointed by `ptr` for the first occurrence of `x` (interpreted as an `unsigned char`), and returns a pointer to it */
LIB_FUNC NOLIBCALL void* memchr_nonconst(void* src, const int x, const size_t len) {
	unsigned char* s = src;
	register unsigned char c = (unsigned char)x;
	register size_t n = len;
	for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*s != c); s++, n--);
	if (n && (*s != c)) {
		size_t* w;
		register size_t k = (((size_t)-1 / UCHAR_MAX) * c);
		for (w = (size_t*)s; (n >= SIZEOF_SIZE_T) && (!(HASZERO((*w ^ k)))); ++w, n -= SIZEOF_SIZE_T);
		for (s = (void*)w; n && (*s != c); ++s, --n);
	}
	return (void*)(n ? s : 0);
}


/** Returns a pointer to the first occurrence of `ch` in the buffer `buf` of size `len`, or `buf + len` if `ch` does not occur */
LIB_FUNC void* memscan(void* buf, const unsigned char ch, const size_t len) {
	void* x = memchr_nonconst(buf, ch, len);
	return (void*)(x ? x : ((size_t*)buf + len));
}


LIB_FUNC const void* rawmemchr(const void* s, const int c) {
	const unsigned char* m = s;
	const unsigned char ch = (unsigned char)c;
	while (*m != ch) { ++m; }
	return m;
}


LIB_FUNC const void* memrchr(const void* src, const int x, const size_t len) {
	const unsigned char* s = src;
	register const unsigned char c = (unsigned char)x;
	register size_t n = len;
	while (n--) { if (s[n] == c) { return (const void*)(s + n); } }
	return (const void*)0;
}
#define _memrchr(src, x, len)   memrchr((src), (x), (len))
#define __memrchr(src, x, len)   memrchr((src), (x), (len))


/** Returns a pointer to the first occurrence of character in the C string str */
LIB_FUNC NOLIBCALL ATTR_PF const char* strchr(const char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (const char*)(str - 1);
	}
	register char c1 = 0;
	while ((c1 = *str++)) { if (c1 == chr) { return (const char*)(str - 1); } }
	return (const char*)0;
}
/** Returns a pointer to the first occurrence of character in the C string str */
#define index(str, chr)   strchr((str), (chr))


/** Returns a pointer to the first occurrence of character in the C string str (non-constant output) */
LIB_FUNC char* strchr2(const char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (char*)(uintptr_t)(str - 1);
	}
	register char c1 = 0;
	while ((c1 = *str++)) { if (c1 == chr) { return (char*)(uintptr_t)(str - 1); } }
	return (char*)0;
}


/** Returns a pointer to the first occurrence of character in the C string str (non-constant) */
LIB_FUNC NOLIBCALL ATTR_PF char* strchr_nc(char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (char*)(str - 1);
	}
	register char c1 = 0;
	while ((c1 = *str++)) { if (c1 == chr) { return (char*)(str - 1); } }
	return (char*)0;
}


/** Returns a pointer to the last occurrence of character in the C string str */
LIB_FUNC const char* strrchr(const char* restrict str, const int chr) {
	if (chr == 0) { return (const char*)strchr(str, 0); }
	const char* r = 0;
	while ((str = strchr(str, chr))) { r = (const char*)(str++); }
	return (const char*)r;
}
/** Returns a pointer to the last occurrence of character in the C string str */
#define rindex(str, chr)   strrchr((str), (chr))


/** Return pointer to first occurrence of `s2` in `s1`; Return 0 if none */
LIB_FUNC const char* strstr(const char* restrict s1, const char* restrict s2) {
	if (s2[0] == 0) { return s1; }
	register const int f = s2[0];
	register size_t n = strlen(s2);
	const char* p = NULL;
	for (p = (const char*)(strchr(s1, f)); p; p = (const char*)strchr((p + 1), f)) {
		if (strncmp(p, s2, n) == 0) { return p; }
	}
	return 0;
}


/** Return pointer to first occurrence of `s2` in `s1`; Return 0 if none */
LIB_FUNC char* strstr_nc(char* restrict s1, const char* restrict s2) {
	if (s2[0] == 0) { return s1; }
	register const int f = s2[0];
	register size_t n = strlen(s2);
	char* p = NULL;
	for (p = strchr_nc(s1, f); p; p = strchr_nc((p + 1), f)) {
		if (strncmp(p, s2, n) == 0) { return p; }
	}
	return 0;
}


LIB_FUNC const char* twobyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint16_t nw = (uint16_t)((n[0] << 8) | n[1]);
	uint16_t hw = (uint16_t)((h[0] << 8) | h[1]);
	for (h++; *h && hw != nw; hw = (uint16_t)((hw << 8) | *++h));
	return (*h ? (const char*)h - 1 : 0);
}


LIB_FUNC const char* threebyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8);
	uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8);
	for (h += 2; *h && hw != nw; hw = (uint32_t)((hw | *++h) << 8));
	return (*h ? (const char*)h - 2 : 0);
}


LIB_FUNC const char* fourbyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3]);
	uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3]);
	for (h += 3; *h && hw != nw; hw = (uint32_t)((hw << 8) | *++h));
	return (*h ? (const char*)h - 3 : 0);
}


LIB_FUNC char* twoway_strstr(unsigned char* h, const unsigned char* n) {
	size_t align64 byteset[32 / SIZEOF_SIZE_T] = { 0 };
	size_t align64 shift[256] = { 0 };
	register size_t l = 0;
	for (; n[l] && h[l]; l++) {
		byteset[(size_t)(n[l]) / (8 * SIZEOF_POINTER)] |= (size_t)1U << ((size_t)(n[l]) % (8 * SIZEOF_POINTER));
		shift[n[l]] = l + 1;
	}
	if (n[l]) { return 0; }
	size_t ip = (size_t)-1, jp = 0;
	size_t k = 1;
	size_t p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] > n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	size_t ms = ip;
	size_t p0 = p;
	ip = (size_t)-1;
	jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] < n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip + 1 > ms + 1) { ms = ip; }
	else { p = p0; }
	size_t mem0 = 0;
	if (memcmp(n, (n + p), (ms + 1))) {
		p = MAX(ms, (l - ms - 1)) + 1;
	} else { mem0 = l - p; }
	size_t mem = 0;
	const unsigned char* z = h;
	loop_forever {  // Search loop
		if ((size_t)(z - h) < l) {
			size_t grow = l | 63;
			const unsigned char* z2 = memchr(z, 0, grow);
			if (z2) {
				z = z2;
				if ((size_t)(z - h) < l) { return 0; }
			} else { z += grow; }
		}
		// Check last byte first; advance by shift on mismatch
		if (byteset[(size_t)(h[l - 1]) / (8 * SIZEOF_POINTER)] & (size_t)1U << ((size_t)(h[l - 1]) % (8 * SIZEOF_POINTER))) {
			k = l - shift[h[l - 1]];
			if (k) {
				if (mem0 && mem && k < p) { k = l - p; }
				h += k;
				mem = 0;
				continue;
			}
		} else {
			h += l;
			mem = 0;
			continue;
		}
		// Compare right half
		for (k = MAX((ms + 1), mem); n[k] && n[k] == h[k]; k++);
		if (n[k]) {
			h += (k - ms);
			mem = 0;
			continue;
		}
		// Compare left half
		for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--);
		if (k <= mem) { return (char*)h; }
		h += p;
		mem = mem0;
	}
}


/** Scans `str` for the first occurrence of any of the characters that are part of `reject`, returning the number of characters of `str` read before this first occurrence */
LIB_FUNC NOLIBCALL ATTR_PF size_t strcspn(const char* restrict str, const char* restrict reject) {
	register size_t l = 0;
	register int i = 0;
	for (; *str; ++str) {
		for (i = 0; reject[i]; ++i) { if (*str == reject[i]) { return l; } }
		++l;
	}
	return l;
}


/** Find the first occurrence in `s1` of a character in `s2` */
LIB_FUNC NOLIBCALL NONNULL_IO const char* strpbrk(const char* restrict s1, const char* restrict s2) {
	s1 += strcspn(s1, s2);
	return (const char*)(*s1 ? s1 : 0);
}


LIB_FUNC NOLIBCALL char* strtok(char* restrict s, const char* restrict sep) {
	static char* p = NULL;
	if (!s && !(s = p)) { return NULL; }
	s += strspn(s, sep);
	if (!*s) { p = 0; return 0; }
	p = (s + strcspn(s, sep));
	if (*p) { *p++ = 0; }
	else { p = 0; }
	return s;
}


LIB_FUNC NOLIBCALL char* strtok_r(char* restrict s, const char* restrict sep, char** restrict p) {
	if (!s && !(s = *p)) { return (char*)NULL; }
	s += strspn(s, sep);
	if (!*s) { return *p = 0; }
	*p = (s + strcspn(s, sep));
	if (**p) { *(*p)++ = 0; }
	else { *p = 0; }
	return s;
}
#define _win_strtok_r(s, sep, p)   strtok_r((s), (sep), (p))
#define _strtok_r(s, sep, p)   strtok_r((s), (sep), (p))

/** @} */  // }


/** Converts str to all uppercase */
LIB_FUNC char* strupr(char* restrict str) {
	char* restrict ret = str;
	while ((*str = (char)toupper(*str))) { ++str; }
	return ret;
}


/** Converts str to all lowercase */
LIB_FUNC char* strlwr(char* restrict str) {
	char* restrict ret = str;
	while ((*str = (char)tolower(*str))) { ++str; }
	return ret;
}


/** Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination. */
LIB_FUNC char* strcat(char* restrict dest, const char* restrict src) {
	return strcpy((char*)(dest + (strlen(dest))), src);
}


LIB_FUNC char* strncat(char* restrict dest, const char* restrict src, const size_t len) {
	char* q = strchr_nc(dest, '\0');
	const char* p = src;
	register char ch;
	register size_t n = len;
	while (n--) {
		*q++ = ch = *p++;
		if (!ch) { return dest; }
	}
	*q = '\0';
	return dest;
}


LIB_FUNC size_t strlcat(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t l = strnlen(dest, len);
	if (l == len) { return (l + strlen(src)); }
	return (l + strlcpy((dest + l), src, (len - l)));
}


LIB_FUNC const char* strchrnul(const char* s, const int x) {
	const size_t* w;
	size_t k;
	register unsigned char c = (unsigned char)x;
	if (!c) { return (const char*)(s + strlen(s)); }
	for (; (uintptr_t)s % SIZEOF_SIZE_T; s++) { if (!*s || *(const unsigned char*)s == c) { return (const char*)s; } }
	k = (size_t)((((size_t) - 1) / UCHAR_MAX) * c);
	for (w = (const void*)s; (!(HASZERO(*w))) && (!(HASZERO(*w ^ k))); ++w);
	for (s = (const void*)w; *s && *(const unsigned char*)s != c; ++s);
	return (const char*)s;
}
#define __strchrnul(s, c)   strchrnul((s), (c))


/** Span the string `s1` skipping characters that are in `s2` */
LIB_FUNC NOLIBCALL ATTR_PF size_t strspn(const char* restrict s1, const char* restrict s2) {
	const char *p = s1, *spanp;
	register char c = 0, sc = 0;
	until_break {  // Skip any characters in s2, excluding the terminating \0
		c = *p++;
		for (spanp = s2; (sc = *spanp++) != 0;) {
			if (sc == c) { continue; }
		}
		return (size_t)(p - 1 - s1);
	}
}


/** Extract token from string */
LIB_FUNC char* strsep(char** str, const char* restrict sep) {
	char* s = *str, *end;
	if (!s) { return (char*)NULL; }
	end = (s + strcspn(s, sep));
	if (*end) { *end++ = 0; }
	else { end = 0; }
	*str = end;
	return s;
}
#define _strsep(str, sep)   strsep((str), (sep))
#define __strsep(str, sep)   strsep((str), (sep))


/** Transform `src`, storing the result in `dest`, such that `strcmp()` on transformed strings returns what `strcoll()` returns on the original untransformed strings */
LIB_FUNC size_t strxfrm(char* dest, const char* src, const size_t len) {
	if (len == 0) { return strlen(src); }
	return (size_t)strlcpy(dest, src, len);
}
#define strxfrm_l(dest, src, len, locale)   strxfrm((dest), (src), (len))


// RUNE OPERATIONS

/** @defgroup Rune_Operations Functions and macros for Rune manipulations
@{ */  // (FB){

/** Convert a character to a Rune
* 00000-0007F => T1
* 00080-007FF => T2 0xc0
* 00800-0FFFF => T3 0xc0 0xc0
* 10000-10FFFF => T4 0xc0 0xc0 0xc0
*/
LIB_FUNC int chartorune(Rune* rune, const char* restrict str) {
	int c[UTFmax] = { 0 };
	Rune l = 0;
	c[0] = *(const unsigned char*)(str);
	if (c[0] < 0xc0) {
		*rune = c[0];
		return 1;
	}
	register int i = 1;
	l = c[0];
	for (; i < UTFmax; i++) {
		c[i] = *(const unsigned char*)(str + i);
		c[i] ^= 0xc0;
		if (c[i] & 192) {
			*rune = Bad;
			return 1;
		}
		l = (Rune)((l << 6) | c[i]);
		if (c[0] < set_leading_ones_8bit(i + 2)) {
			l &= RuneX(i + 1);
			if (i == 1) {
				if (c[0] < set_leading_ones_8bit(2) || l <= 127) {
					*rune = Bad;
					return 1;
				}
			} else if (l <= RuneX(i) || l > Runemax || (i == 2 && SurrogateMin <= l && l <= SurrogateMax)) {
				*rune = Bad;
				return 1;
			}
			*rune = l;
			return i + 1;
		}
	}
	return 1;
}


LIB_FUNC const char* utfrune(const char* restrict str, const long c) {
	if (c < Runesync) { return (const char*)strchr(str, (int)c); }  // Not part of UTF sequence
	Rune r = 0;
	register long c1 = 0;
	register int n = 0;
	loop_forever {
		c1 = *(const unsigned char*)str;
		if (c1 < Runeself) {  // One byte rune
			if (c1 == 0) { return 0; }
			else if (c1 == c) { return str; }
			++str;
			continue;
		}
		n = chartorune(&r, str);
		if (r == c) { return str; }
		str += n;
	}
	UNREACHABLE
}


/** Convert a Rune to a character
One character sequence
	00000-0007f => 00-7f
Two character sequence
	0080-07ff => T2 0xc0
Three character sequence
	0800-ffff => T3 0xc0 0xc0
Four character sequence (21-bit value)
	10000-1fffff => T4 0xc0 0xc0 0xc0
If the Rune is out of range or a surrogate half, convert it to the error rune
*/
LIB_FUNC int runetochar(char* str, const Rune* rune) {
	Rune c = *rune;
	if (c <= 127) {
		str[0] = (char)c;
		return 1;
	}
	register int i = 2, j = 1;
	for (; i < UTFmax + 1; i++) {
		if (i == 3) {
			if (c > Runemax) { c = Runeerror; }
			if (SurrogateMin <= c && c <= SurrogateMax) { c = Runeerror; }
		}
		if (c <= RuneX(i) || i == UTFmax ) {
			str[0] = (char)(set_leading_ones_8bit(i) |  (c >> (i - 1) * 6));
			for (j = 1; j < i; j++) {
				str[j] = (char)(0xc0 | ((c >> (i - j - 1) * 6) & 63));
			}
			return i;
		}
	}
	return UTFmax;
}


LIB_FUNC int runelen(const long c) {
	Rune _rune = (Rune)c;
	char str[10] = { 0 };
	return runetochar(str, &_rune);
}


LIB_FUNC int runenlen(const Rune* restrict r, int nrune) {
	register int nb = 0, i = 2;
	register Rune c = 0;
	while (nrune--) {
		c = *r++;
		if (c <= 127) { nb++; }
		else {
			for (i = 2; i < (UTFmax + 1); i++) {
				if (c <= RuneX(i) || i == UTFmax) {
					nb += i;
					break;
				}
			}
		}
	}
	return nb;
}


LIB_FUNC long runestrlen(const Rune* restrict str) {
	register long i = 0;
	while (*str++) { ++i; }
	return i;
}


LIB_FUNC const Rune* runestrchr(const Rune* restrict str, Rune c) {
	Rune c0 = c, c1 = 0;
	if (c == 0) {
		while (*str++);
		return (const Rune*)(str - 1);
	}
	while ((c1 = *str++)) { if (c1 == c0) { return (const Rune*)(str - 1); } }
	return 0;
}


LIB_FUNC int fullrune(const char* restrict str, const int n) {
	if (n <= 0) { return 0; }
	Rune c = *(const uchar*)str;
	if (c < 0xc0) { return 1; }
	register int i = 3;
	for (; i < (int)(UTFmax + 1); i++) {
		if (c < set_leading_ones_8bit(i)) { return (int)(n >= i - 1); }
	}
	return (int)(n >= UTFmax);
}

/** @} */  // }


#endif  // BIT-TWIDDLING


/* HIGH PRECISION, LOW OVERHEAD TIMING FUNCTIONS (<hp-timing.h>) */


#if (!(defined(HP_TIMING_H) || defined(_HP_TIMING_H) || defined(_HP_TIMING_H_)))
#define HP_TIMING_H   (1)
#define _HP_TIMING_H   (1)
#define _HP_TIMING_H_   (1)


/** Compute the difference between START and END, storing into DIFF */
#define HP_TIMING_DIFF(Diff, Start, End)   ((Diff) = (End) - (Start))
/** Accumulate ADD into SUM; No attempt is made to be thread-safe */
#define HP_TIMING_ACCUM_NT(Sum, Diff)   ((Sum) += (Diff))
/** Write a decimal representation of the timing value into the given string */
#define HP_TIMING_PRINT(Dest, Len, Val)   do { char align16 __buf[20] = { 0 }; char* __dest = (Dest); const size_t __len = (Len); char* __cp = itoa2((Val), (__buf + sizeof(__buf))); const size_t __cp_len = MIN((__buf + sizeof(__buf) - __cp), __len); memcpy_no_output(__dest, __cp, __cp_len); memcpy_no_output(__dest + __cp_len, " cycles", MIN(__len - __cp_len, 7)); __dest[__len - 1] = '\0'; } while (0x0)


/** @def HP_TIMING_AVAIL
Test for the availability of high-precision timing */
/** @def HP_TIMING_INLINE
This macro is non-zero if the functionality is not implemented using function calls but instead uses some inlined code which might simply consist of a few assembler instructions */
#ifdef ARCHALPHA


#define HP_TIMING_AVAIL   (0)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
/** The `rpcc` instruction returns a 32-bit counting half and a 32-bit "virtual cycle counter displacement"; Subtracting the two gives us a virtual cycle count */
#define HP_TIMING_NOW(VAR)   do { unsigned long x_; vasm("rpcc %0;" : "=r"(x_)); (VAR) = (int)(x_) - (int)(x_ >> 32); } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned long x_;
	vasm("rpcc %0;" : "=r"(x_));
	return (hp_timing_t)((int)(x_) - (int)(x_ >> 32));
}


#elif defined(ARCHX86_64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { unsigned int _hi, _lo; vasm("mfence;" "rdtscp;" "mfence;" : "=a"(_lo), "=d"(_hi)); (Var) = ((unsigned long long)_hi << 32) | _lo; } while (0x0)  // The "=A" constraint used in 32-bit mode does not work in 64-bit mode
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned int _hi, _lo;
	vasm("mfence;" "rdtscp;" "mfence;" : "=a"(_lo), "=d"(_hi));
	return (hp_timing_t)(((unsigned long long)_hi << 32) | (unsigned long long)_lo);
}


#elif defined(ARCHX86_32)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
/** Use the `rdtsc` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `cpuid` right before the `rdtsc` instruction */
#define HP_TIMING_NOW(Var)   vasm("mfence;" "rdtscp;" "mfence;" : "=A"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtsc_val;
	vasm("mfence;" "rdtscp;" "mfence;" : "=A"(rdtsc_val));
	return (hp_timing_t)rdtsc_val;
}
#define rdtscl(low)   vasm("mfence;" "rdtscp;" "mfence;" : "=a"(low) : : "ecx", "edx")


#elif defined(ARCHITANIUM)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { unsigned long __itc; do { vasm("mov %0 = ar.itc;" : "=r"(__itc) : : "memory"); } while (PREDICT_UNLIKELY((long)__itc == -1)); Var = __itc; } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t __itc;
	do {
		vasm("mov %0 = ar.itc;" : "=r"(__itc) : : "memory");
	} while (PREDICT_UNLIKELY((long)__itc == -1));
	return (hp_timing_t)__itc;
}


#elif defined(ARCHSPARC64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   vasm("rd %%tick, %0;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtick;
	vasm("rd %%tick, %0;" : "=r"(rdtick));
	return (hp_timing_t)rdtick;
}


#elif defined(ARCHSPARC32)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { vasm("rd %%tick, %L0;" "srlx %L0, 32, %H0;" : "=r"(Var)); } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtick;
	vasm("rd %%tick, %L0;" "srlx %L0, 32, %H0;" : "=r"(rdtick));
	return (hp_timing_t)rdtick;
}


#elif defined(ARCHPOWERPC64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)

/** @def HP_TIMING_NOW
Use the `mftb` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `lwsync` right before the `mftb` instruction */
#ifdef _ARCH_PWR4
#   define HP_TIMING_NOW(Var)   vasm("mfspr %0, 268;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t mfspr_val;
	vasm("mfspr %0, 268;" : "=r"(mfspr_val));
	return (hp_timing_t)mfspr_val;
}
#else
#   define HP_TIMING_NOW(Var)   vasm("mftb %0;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t mftb_val;
	vasm("mftb %0;" : "=r"(mftb_val));
	return (hp_timing_t)mftb_val;
}
#endif


#elif defined(ARCHPOWERPC32)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
/** @def HP_TIMING_NOW
Use the `mftb` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `lwsync` right before the `mftb` instruction */
#define HP_TIMING_NOW(Var)   do { unsigned int hi, lo, tmp; vasm("1: mfspr %0, 269;" "mfspr %1, 268;" "mfspr %2, 269;" "cmpw %0, %2;" "bne 1b;" : "=&r"(hi), "=&r"(lo), "=&r"(tmp) : : "cr0"); Var = ((hp_timing_t)hi << 32) | lo; } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned int hi, lo, tmp;
	vasm("1: mfspr %0, 269;" "mfspr %1, 268;" "mfspr %2, 269;" "cmpw %0, %2;" "bne 1b;" : "=&r"(hi), "=&r"(lo), "=&r"(tmp) : : "cr0");
	return (hp_timing_t)(((hp_timing_t)hi << 32) | (hp_timing_t)lo);
}


#else


// Provide dummy definitions
#define HP_TIMING_AVAIL   (0)
#define HP_SMALL_TIMING_AVAIL   (0)
#define HP_TIMING_INLINE   (0)
#define HP_TIMING_NOW(var)
#define HP_TIMING(var)   (hp_timing_t)(1)
#define HP_TIMING_NONAVAIL   (1)


#endif  // ARCH


#endif  // HP_TIMING_H


/* VECTOR I/O OPERATIONS (<sys/uio.h>) */


#if ((!(defined(SYS_UIO_H) || defined(_SYS_UIO_H) || defined(_SYS_UIO_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_uio.h.html
#define SYS_UIO_H   (1)
#define _SYS_UIO_H   (1)
#define _SYS_UIO_H_   (1)


#define UIO_MAXIOV   1024


LIB_FUNC ssize_t readv(const long fd, const struct iovec* iov, const long count) {
	return (ssize_t)syscall3(SYS_readv, fd, (long)iov, count);
}
#define _readv(fd, iov, count)   readv((fd), (iov), (count))
#define __readv(fd, iov, count)   readv((fd), (iov), (count))


LIB_FUNC ssize_t preadv(const long fd, const struct iovec* iov, const long count, const off_t ofs) {
	return (ssize_t)syscall5(SYS_preadv, fd, (long)iov, count, (long)(ofs), (long)(ofs >> 32));
}
#define preadv64(fd, iov, count, ofs)   preadv((fd), (iov), (count), (ofs))


LIB_FUNC ssize_t process_vm_readv(const pid_t pid, const struct iovec* lvec, const unsigned long liovcnt, const struct iovec* rvec, const unsigned long riovcnt, const unsigned long flags) {
	return (ssize_t)syscall6(SYS_process_vm_readv, (long)pid, (long)lvec, (long)liovcnt, (long)rvec, (long)riovcnt, (long)flags);
}


LIB_FUNC ssize_t writev(const long fd, const struct iovec* iov, const long count) {
	return (ssize_t)syscall3(SYS_writev, fd, (long)iov, count);
}


LIB_FUNC ssize_t pwritev(const long fd, const struct iovec* iov, const long count, const off_t ofs) {
	return (ssize_t)syscall5(SYS_pwritev, fd, (long)iov, count, (long)(ofs), (long)(ofs >> 32));
}
#define pwritev64(fd, iov, count, ofs)   pwritev((fd), (iov), (count), (ofs))


LIB_FUNC ssize_t process_vm_writev(const pid_t pid, const struct iovec* lvec, const unsigned long liovcnt, const struct iovec* rvec, const unsigned long riovcnt, const unsigned long flags) {
	return (ssize_t)syscall6(SYS_process_vm_writev, (long)pid, (long)lvec, (long)liovcnt, (long)rvec, (long)riovcnt, (long)flags);
}


#endif  // SYS_UIO_H


/* SEND FILE (<sys/sendfile.h>) */


#if ((!(defined(SYS_SENDFILE_H) || defined(_SYS_SENDFILE_H) || defined(_SYS_SENDFILE_H_))) && defined(OSLINUX))
#define SYS_SENDFILE_H   (1)
#define _SYS_SENDFILE_H   (1)
#define _SYS_SENDFILE_H_   (1)


LIB_FUNC ssize_t sendfile(const long out_fd, const long in_fd, off_t* ofs, const size_t count) {
	return (ssize_t)syscall4(SYS_sendfile, (long)out_fd, (long)in_fd, (long)ofs, (long)count);
}
#define sendfile64(out_fd, in_fd, ofs, count)   sendfile((out_fd), (in_fd), (ofs), (count))


#endif  // SYS_SENDFILE_H


/* EVENT FILE DESCRIPTOR (<sys/eventfd.h>) */


#if ((!(defined(SYS_EVENTFD_H) || defined(_SYS_EVENTFD_H) || defined(_SYS_EVENTFD_H_))) && defined(OSLINUX))
#define SYS_EVENTFD_H   (1)
#define _SYS_EVENTFD_H   (1)
#define _SYS_EVENTFD_H_   (1)


#define EFD_SEMAPHORE   1
#define EFD_CLOEXEC   O_CLOEXEC
#define EFD_NONBLOCK   O_NONBLOCK


/** Return file descriptor for generic event channel; Set initial value to `count` */
LIB_FUNC int eventfd(const unsigned int count, const int flags) {
	int r = (int)syscall2(SYS_eventfd2, count, flags);
#   ifdef SYS_eventfd
	if (eq_errno(ENOSYS) && !flags) { r = (int)syscall1(SYS_eventfd, count); }
#   endif
	return r;
}


/** Read event counter and possibly wait for events */
LIB_FUNC int eventfd_read(const int fd, const eventfd_t* restrict value) {
	return ((sizeof(*value) == read(fd, value, sizeof(*value))) ? 0 : -1);
}


/** Increment event counter */
LIB_FUNC int eventfd_write(const int fd, const eventfd_t value) {
	return ((sizeof(value) == write(fd, &value, sizeof(value))) ? 0 : -1);
}


#endif  // SYS_EVENTFD_H


/* EVENTPOLL (<sys/epoll.h>) */


#if ((!(defined(SYS_EPOLL_H) || defined(_SYS_EPOLL_H) || defined(_SYS_EPOLL_H_))) && defined(OSLINUX))
#define SYS_EPOLL_H   (1)
#define _SYS_EPOLL_H   (1)
#define _SYS_EPOLL_H_   (1)


#ifndef __EPOLL_PACKED
#   define __EPOLL_PACKED
#endif


enum EPOLL_EVENTS {
	EPOLLIN = 1,
	EPOLLPRI = 2,
	EPOLLOUT = 4,
	EPOLLERR = 8,
	EPOLLHUP = 0x10,
	EPOLLRDNORM = 0x40,
	EPOLLRDBAND = 0x80,
	EPOLLWRNORM = 0x100,
	EPOLLWRBAND = 0x200,
	EPOLLMSG = 0x400,
	EPOLLRDHUP = 0x2000,
	EPOLLONESHOT = 0x40000000,
	EPOLLET = (int)0x80000000
};


/** Valid opcodes ("op" parameter) to issue to epoll_ctl() */
enum EPOLL_CTL_OPCODES {
/** Add a file descriptor to the interface */
	EPOLL_CTL_ADD = 1,
/** Remove a file descriptor from the interface */
	EPOLL_CTL_DEL = 2,
/** Change file descriptor epoll_event structure */
	EPOLL_CTL_MOD = 3
};


typedef union epoll_data {
	void* ptr;
	int fd;
	uint32_t _u32;
	uint64_t _u64;
} epoll_data_t;


typedef struct attr_packed epoll_event {
	uint32_t events;  //!< Epoll events
	epoll_data_t data;  //!< User data variable
} epoll_event_t;


/** Same as epoll_create but with a `flags` parameter */
LIB_FUNC int epoll_create1(const int flags) {
#   ifdef SYS_epoll_create
	register int r = (int)syscall1(SYS_epoll_create1, flags);
	if (eq_errno(ENOSYS) && (!flags)) { r = (int)syscall1(SYS_epoll_create, 1); }
	return r;
#   else
	return (int)syscall1(SYS_epoll_create1, flags);
#   endif
}


/** Creates an epoll instance; Returns an file-descriptor for the new instance */
LIB_FUNC int epoll_create(const UNUSED int size) {
	return epoll_create1(0);
}


/** Manipulate an epoll instance "epfd". Returns `0` in case of success, `-1` in case of error (the `errno` variable will contain the specific error code) */
LIB_FUNC int epoll_ctl(const int fd, const int op, const int fd2, struct epoll_event* ev) {
	return (int)syscall4(SYS_epoll_ctl, fd, op, fd2, (long)ev);
}


/** Same as `epoll_wait()`, but the thread's signal mask is temporarily and atomically replaced with the one provided as parameter */
LIB_FUNC int epoll_pwait(const int fd, const struct epoll_event* restrict ev, const int cnt, const int to, const sigset_t* sigs) {
#   ifdef SYS_epoll_wait
	register int r = (int)syscall6(SYS_epoll_pwait, fd, (long)ev, cnt, to, (long)sigs, (long)NSIG_S3);
	if (eq_errno(ENOSYS) && (!sigs)) { r = (int)syscall4(SYS_epoll_wait, fd, (long)ev, cnt, to); }
	return r;
#   else
	return (int)syscall6(SYS_epoll_pwait, fd, (long)ev, cnt, to, (long)sigs, (long)NSIG_S3);
#   endif
}


/** Wait for events on an epoll instance "epfd"; Returns the number of triggered events returned in `events` buffer, or `-1` in case of error (the `errno` variable will contain the specific error code) */
LIB_FUNC int epoll_wait(const int fd, const struct epoll_event* restrict ev, const int cnt, const int to) {
	return (int)epoll_pwait(fd, ev, cnt, to, 0);
}


#endif  // SYS_EPOLL_H


/* POLL (<poll.h>) */


#if ((!(defined(POLL_H) || defined(_POLL_H) || defined(_POLL_H_) || defined(_SYS_POLL_H) || defined(_SYS_POLL_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/poll.h.html
#define POLL_H   (1)
#define _POLL_H   (1)
#define _POLL_H_   (1)
#define _SYS_POLL_H   (1)
#define _SYS_POLL_H_   (1)
#define __ASM_GENERIC_POLL_H   (1)


#ifndef INFTIM
#   define INFTIM   -1
#endif
/** @def MSG_PEEK
BeOS does not have `MSG_PEEK` */
#if ((!defined(MSG_PEEK)) && defined(OSBEOS))
#   define MSG_PEEK   0
#elif (!defined(MSG_PEEK))
#   define MSG_PEEK   2
#endif
/** Event types that can be polled; These bits may be set in `events` to indicate the interesting event types; they will appear in `revents` to indicate the status of the file descriptor */
enum POLL_EVENTS {
/** There is data to read */
	POLLIN = 1,
/** There is urgent data to read */
	POLLPRI = 2,
/** Writing will not block */
	POLLOUT = 4
};
// These values are defined in XPG4.2 and later
/** Normal data may be read */
#define POLLRDNORM   POLLIN
/** Priority data may be read */
#define POLLRDBAND   POLLPRI
/** Writing will not block */
#define POLLWRNORM   POLLOUT
/** Priority data may be written */
#define POLLWRBAND   POLLOUT
/** Polling Errors */
enum POLL_ERRORS {
/** Error condition */
	POLLERR = 010,
/** Hung up */
	POLLHUP = 020,
/** Invalid polling request */
	POLLNVAL = 040,
	POLLREMOVE = 0x1000,
	POLLRDHUP = 0x2000,
	POLLFREE = 0x4000
};
#define LIBC_CANCEL_ASYNC(val)   (0)
#define CANCEL_ASYNC(val)   (0)
#define LIBC_CANCEL_RESET(val)   ((void)(val))
#define CANCEL_RESET(val)   ((void)(val))


/** Poll File-Descriptor */
typedef struct pollfd {
	int fd;  //!< File descriptor
	short events;  //!< Events to look for
	short revents;  //!< Events returned
} pollfd_t;


LIB_FUNC int poll(struct pollfd* p, const nfds_t nfds, const int timeout) {
	fd_set rd, wr, except;
	struct timeval tv = { 0 };
	FD_ZERO(&rd);
	FD_ZERO(&wr);
	FD_ZERO(&except);
	register nfds_t i = 0;
	register int highfd = -1;
	for (; i < nfds; i++) {
		if (p[i].fd < 0) { continue; }
		else if (p[i].fd >= BITS_PER_FD_SET) { set_errno(EINVAL); return -1; }
		else if (p[i].fd > highfd) { highfd = p[i].fd; }
		if (p[i].events & (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) { FD_SET(p[i].fd, &rd); }
		if (p[i].events & (POLLOUT | POLLWRNORM | POLLWRBAND)) { FD_SET(p[i].fd, &wr); }
		FD_SET(p[i].fd, &except);
	}
	tv.tv_sec = timeout / 1000;
	tv.tv_usec = (timeout % 1000) * 1000;
	int rval = select((highfd + 1), &rd, &wr, &except, (timeout == -1 ? NULL : &tv));
	if (rval <= 0) { return rval; }
	rval = 0;
	for (i = 0; i < nfds; i++) {
		p[i].revents = 0;
		if (FD_ISSET(p[i].fd, &rd)) { p[i].revents |= (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI); }
		if (FD_ISSET(p[i].fd, &wr)) { p[i].revents |= (POLLOUT | POLLWRNORM | POLLWRBAND); }
		if (FD_ISSET(p[i].fd, &except)) { p[i].revents |= POLLERR; }
		if (p[i].revents != 0) { rval++; }
	}
	return rval;
}
#define __poll(p, nfds, timeout)   poll((p), (nfds), (timeout))


LIB_FUNC int ppoll(struct pollfd* fds, const nfds_t nfds, const struct timespec* timeout, const sigset_t* sigmask) {
	struct timespec tval = { 0 };
	if (timeout != NULL) { tval = *timeout; timeout = &tval; }
#   if IS_REENTRANT
	return (int)syscall6(SYS_ppoll, 5, (long)fds, (long)nfds, (long)timeout, (long)sigmask, NSIG_S3);
#   else
	const int oldtype = LIBC_CANCEL_ASYNC();
	register int result = (int)syscall6(SYS_ppoll, 5, (long)fds, (long)nfds, (long)timeout, (long)sigmask, NSIG_S3);
	LIBC_CANCEL_RESET(oldtype);
	return result;
#   endif
}


LIB_FUNC int __poll_chk(struct pollfd* fds, const nfds_t nfds, const int timeout, const size_t fdslen) {
	if (fdslen / sizeof(*fds) < nfds) { __chk_fail("poll() failed in __poll_chk()!"); }
	return poll(fds, nfds, timeout);
}


LIB_FUNC int __ppoll_chk(struct pollfd* fds, const nfds_t nfds, const struct timespec* timeout, const sigset_t* ss, const size_t fdslen) {
	if (fdslen / sizeof(*fds) < nfds) { __chk_fail("ppoll() failed in __ppoll_chk()!"); }
	return ppoll(fds, nfds, timeout, ss);
}


LIB_FUNC void zero_fd_set(const unsigned long nr, unsigned long* fdset) {
	memset_no_output(fdset, 0, FDS_BYTES(nr));
}


#endif  // POLL_H


/* FUTEX (<futex.h>) */


#if ((!(defined(_INTERNAL_FUTEX_H) || defined(_INTERNAL_FUTEX_H_) || defined(_FUTEX_H) || defined(_FUTEX_H_))) && defined(OSLINUX))
#define _INTERNAL_FUTEX_H   (1)
#define _INTERNAL_FUTEX_H_   (1)
#define _FUTEX_H   (1)
#define _FUTEX_H_   (1)


enum FUTEX_FLAGS {
	FUTEX_WAIT = 0,
	FUTEX_WAKE = 1,
	FUTEX_FD = 2,
	FUTEX_REQUEUE = 3,
	FUTEX_CMP_REQUEUE = 4,
	FUTEX_WAKE_OP = 5,
	FUTEX_LOCK_PI = 6,
	FUTEX_UNLOCK_PI = 7,
	FUTEX_TRYLOCK_PI = 8,
	FUTEX_WAIT_BITSET = 9,
	FUTEX_PRIVATE = 128,
	FUTEX_CLOCK_REALTIME = 256
};


/** A method for a program to wait for a value at a given address to change and to wake up any process waiting on a particular address */
LIB_FUNC int futex(volatile int* restrict addr, const int op, const int val, void* restrict ts) {
	return (int)syscall4((long)SYS_futex, (long)addr, (long)op, (long)val, (long)ts);
}
#define _futex(addr, op, val, ts)   futex((addr), (op), (val), (ts))
#define __futex(addr, op, val, ts)   futex((addr), (op), (val), (ts))


#endif  // FUTEX_H


/* FANOTIFY (<sys/fanotify.h>) */


#if ((!(defined(SYS_FANOTIFY_H) || defined(_SYS_FANOTIFY_H) || defined(_SYS_FANOTIFY_H_))) && defined(OSLINUX))
#define SYS_FANOTIFY_H   (1)
#define _SYS_FANOTIFY_H   (1)
#define _SYS_FANOTIFY_H_   (1)


typedef struct fanotify_event_metadata {
	unsigned event_len;
	unsigned char vers, reserved;
	unsigned short metadata_len;
#   if IS_GNUC
	unsigned long long align8 mask;
#   else
	unsigned long long mask;
#   endif
	int fd, pid;
} fanotify_event_metadata_t;

typedef struct fanotify_response {
	int fd;
	unsigned response;
} fanotify_response_t;


#define FAN_ACCESS   1
#define FAN_MODIFY   2
#define FAN_CLOSE_WRITE   8
#define FAN_CLOSE_NOWRITE   0x10
#define FAN_OPEN   0x20
#define FAN_Q_OVERFLOW   0x4000
#define FAN_OPEN_PERM   0x10000
#define FAN_ACCESS_PERM   0x20000
#define FAN_ONDIR   0x40000000
#define FAN_EVENT_ON_CHILD   0x8000000
#define FAN_CLOSE   (FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE)
enum FANOTIFY_INIT_FLAGS {
	FAN_CLOEXEC = 1,
	FAN_NONBLOCK = 2,
	FAN_CLASS_NOTIF = 0,
	FAN_CLASS_CONTENT = 4,
	FAN_CLASS_PRE_CONTENT = 8,
	FAN_ALL_CLASS_BITS = (FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | FAN_CLASS_PRE_CONTENT),
	FAN_UNLIMITED_QUEUE = 0x10,
	FAN_UNLIMITED_MARKS = 0x20
};
#define FAN_ALL_INIT_FLAGS   (FAN_CLOEXEC | FAN_NONBLOCK | FAN_ALL_CLASS_BITS | FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS)
enum FANOTIFY_MARK_FLAGS {
	FAN_MARK_ADD = 1,
	FAN_MARK_REMOVE = 2,
	FAN_MARK_DONT_FOLLOW = 4,
	FAN_MARK_ONLYDIR = 8,
	FAN_MARK_MOUNT = 0x10,
	FAN_MARK_IGNORED_MASK = 0x20,
	FAN_MARK_IGNORED_SURV_MODIFY = 0x40,
	FAN_MARK_FLUSH = 0x80
};
#define FAN_ALL_MARK_FLAGS   (FAN_MARK_ADD | FAN_MARK_REMOVE | FAN_MARK_DONT_FOLLOW | FAN_MARK_ONLYDIR | FAN_MARK_MOUNT | FAN_MARK_IGNORED_MASK | FAN_MARK_IGNORED_SURV_MODIFY | FAN_MARK_FLUSH)
#define FAN_ALL_EVENTS   (FAN_ACCESS | FAN_MODIFY | FAN_CLOSE | FAN_OPEN)
#define FAN_ALL_PERM_EVENTS   (FAN_OPEN_PERM | FAN_ACCESS_PERM)
#define FAN_ALL_OUTGOING_EVENTS   (FAN_ALL_EVENTS | FAN_ALL_PERM_EVENTS | FAN_Q_OVERFLOW)
#define FANOTIFY_METADATA_VERSION   3
#define FAN_ALLOW   1
#define FAN_DENY   2
#define FAN_NOFD   -1
#define FAN_EVENT_METADATA_LEN   (sizeof(struct fanotify_event_metadata))
#define FAN_EVENT_NEXT(meta, len)   ((len) -= (meta)->event_len, (struct fanotify_event_metadata*)(((char*)(meta)) + (meta)->event_len))
#define FAN_EVENT_OK(meta, len)   ((long)(len) >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len <= (long)(len))


/** Create and initialize fanotify group */
LIB_FUNC int fanotify_init(const unsigned int flags, const unsigned int event_f_flags) {
	return (int)syscall2(SYS_fanotify_init, flags, event_f_flags);
}


/** Add, remove, or modify an fanotify mark on a filesystem object */
LIB_FUNC int fanotify_mark(const int fanotify_fd, const unsigned int flags, const unsigned long long mask, const int dfd, const char* restrict pathname) {
	return (int)syscall5(SYS_fanotify_mark, (long)fanotify_fd, (long)flags, (long)mask, (long)dfd, (long)pathname);
}


#endif  // SYS_FANOTIFY_H


/* INOTIFY (<sys/inotify.h>) */


#if ((!(defined(SYS_INOTIFY_H) || defined(_SYS_INOTIFY_H) || defined(_SYS_INOTIFY_H_))) && defined(OSLINUX))
#define SYS_INOTIFY_H   (1)
#define _SYS_INOTIFY_H   (1)
#define _SYS_INOTIFY_H_   (1)


/** Structure describing an inotify event */
typedef struct inotify_event {
	int wd;  //!< Watch descriptor
	uint32_t mask;  //!< Watch mask
	uint32_t cookie;  //!< Cookie to synchronize two events
	uint32_t len;  //!< Length (including NULs) of name
	char name __flexarr;  //!< Name
} inotify_event_t;

// Supported events suitable for the `mask` parameter of `inotify_add_watch()`
enum INOTIFY_ADD_WATCH_MASKS {
/** File was accessed */
	IN_ACCESS = 1,
/** File was modified */
	IN_MODIFY = 2,
/** Metadata changed */
	IN_ATTRIB = 4,
/** Writtable file was closed */
	IN_CLOSE_WRITE = 8,
/** Unwrittable file closed */
	IN_CLOSE_NOWRITE = 0x10,
/** Close */
	IN_CLOSE = (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE),
/** File was opened */
	IN_OPEN = 0x20,
/** File was moved from X */
	IN_MOVED_FROM = 0x40,
/** File was moved to Y */
	IN_MOVED_TO = 0x80,
/** Moves */
	IN_MOVE = (IN_MOVED_FROM | IN_MOVED_TO),
/** Subfile was created */
	IN_CREATE = 0x100,
/** Subfile was deleted */
	IN_DELETE = 0x200,
/** Self was deleted */
	IN_DELETE_SELF = 0x400,
/** Self was moved */
	IN_MOVE_SELF = 0x800,
// Events sent by the kernel
/** Backing fs was unmounted */
	IN_UNMOUNT = 0x2000,
/** Event queued overflowed */
	IN_Q_OVERFLOW = 0x4000,
/** File was ignored */
	IN_IGNORED = 0x8000,
// Special flags
/** Only watch the path if it is a directory */
	IN_ONLYDIR = 0x1000000,
/** Do not follow a sym link */
	IN_DONT_FOLLOW = 0x2000000,
/** Exclude events on unlinked objects */
	IN_EXCL_UNLINK = 0x4000000,
/** Add to the mask of an already existing watch */
	IN_MASK_ADD = 0x20000000,
/** Event occurred against dir */
	IN_ISDIR = (int)0x40000000,
/** Only send event once */
	IN_ONESHOT = (int)0x80000000
};
/** All events which a program can wait on */
#define IN_ALL_EVENTS   (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_CREATE | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF)


/** Create and initialize inotify instance */
LIB_FUNC int inotify_init1(const int flags) {
#   ifdef SYS_inotify_init
	register int r = (int)syscall1(SYS_inotify_init1, flags);
	if (eq_errno(ENOSYS) && !flags) { r = (int)syscall0(SYS_inotify_init); }
	return r;
#   else
	return (int)syscall1(SYS_inotify_init1, flags);
#   endif
}


/** Create and initialize inotify instance */
LIB_FUNC int inotify_init(void) {
	return inotify_init1(0);
}


/** Add watch of object to inotify instance `fd`; Notify about events specified by `mask` */
LIB_FUNC int inotify_add_watch(const int fd, const char* restrict pathname, const long mask) {
	return (int)syscall3(SYS_inotify_add_watch, fd, (long)pathname, (long)mask);
}


/** Remove the watch specified by `wd` from the inotify instance `fd` */
LIB_FUNC int inotify_rm_watch(const int fd, const int wd) {
	return (int)syscall2(SYS_inotify_rm_watch, fd, wd);
}


#endif  // SYS_INOTIFY_H


/* TIMER FILE DESCRIPTOR (<sys/timerfd.h>) */


#if ((!(defined(SYS_TIMERFD_H) || defined(_SYS_TIMERFD_H) || defined(_SYS_TIMERFD_H_))) && defined(OSLINUX))
#define SYS_TIMERFD_H   (1)
#define _SYS_TIMERFD_H   (1)
#define _SYS_TIMERFD_H_   (1)


// Bits to be set in the `flags` parameter of `timerfd_create()`
#ifdef ARCHALPHA
#   define TFD_CLOEXEC   010000000
#   define TFD_NONBLOCK   04
#elif defined(ARCHMIPS)
#   define TFD_CLOEXEC   02000000
#   define TFD_NONBLOCK   0200
#elif defined(ARCHSPARC)
#   define TFD_CLOEXEC   0x400000
#   define TFD_NONBLOCK   0x4000
#else
#   define TFD_CLOEXEC   02000000
#   define TFD_NONBLOCK   04000
#endif
#define TFD_TIMER_ABSTIME   1


/** Return file descriptor for new interval timer source */
LIB_FUNC int timerfd_create(const int clockid, const int flags) {
	return (int)syscall2(SYS_timerfd_create, (long)clockid, flags);
}


/** Set next expiration time of interval timer source UFD to UTMR; If `flags` has the `TFD_TIMER_ABSTIME` flag set, then the timeout value is absolute; Optionally return the old expiration time in OTMR */
LIB_FUNC int timerfd_settime(const int fd, const int flags, const struct itimerspec* restrict new, struct itimerspec* restrict old) {
	return (int)syscall4(SYS_timerfd_settime, fd, flags, (long)new, (long)old);
}


/** Return the next expiration time of UFD */
LIB_FUNC int timerfd_gettime(const int fd, struct itimerspec* restrict cur) {
	return (int)syscall2(SYS_timerfd_gettime, fd, (long)cur);
}


#endif  // SYS_TIMERFD_H


/* WAITING (<sys/wait.h>) */


#if ((!(defined(SYS_WAIT_H) || defined(_SYS_WAIT_H) || defined(_SYS_WAIT_H_) || defined(_BSD_SYS_WAIT_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html
#define SYS_WAIT_H   (1)
#define _SYS_WAIT_H   (1)
#define _SYS_WAIT_H_   (1)
#define _BSD_SYS_WAIT_H_   (1)


/** Do not block waiting */
#define WNOHANG   1
/** Report status of stopped children */
#define WUNTRACED   2
/** Report stopped child (same as `WUNTRACED`) */
#define WSTOPPED   2
/** Report dead child */
#define WEXITED   4
/** Report continued child */
#define WCONTINUED   8
/** Do not reap, just poll status */
#define WNOWAIT   0x1000000
/** Do not wait on children of other threads in this group */
#define __WNOTHREAD   0x20000000
/** Wait for any child */
#define __WALL   0x40000000
/** Wait for cloned process */
#define __WCLONE   0x80000000
#define WEXITSTATUS(s)   (((s) & 0xff00) >> 8)
#define WTERMSIG(s)   ((s) & 0x7f)
#define WSTOPSIG(s)   WEXITSTATUS(s)
#define WCOREDUMP(s)   ((s) & 0x80)
#define WIFEXITED(s)   (!WTERMSIG(s))
#define WIFSTOPPED(s)   ((short)((((s) & UINT16_MAX) * 0x10001) >> 8) > 0x7f00)
#define WIFSIGNALED(s)   (((s) & UINT16_MAX) - 1U < 0xffU)
#define WIFCONTINUED(s)   ((s) == UINT16_MAX)


/** Suspends execution of the calling process until a child specified by `pid` has changed state */
LIB_FUNC pid_t waitpid(const pid_t pid, const int* restrict status, const int options) {
	return (pid_t)syscall4(SYS_wait4, (long)pid, (long)status, (long)options, (long)0);
}


/** Suspends execution of the calling process until a child specified by the `_id` argument has changed state */
LIB_FUNC int waitid(const idtype_t type, const id_t _id, const siginfo_t* restrict info, const int options) {
	return (int)syscall5(SYS_waitid, (long)type, (long)_id, (long)info, (long)options, 0);
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC pid_t wait(const int* restrict status) {
	return waitpid((pid_t)-1, status, 0);
}


LIB_FUNC pid_t wait4(const pid_t pid, const int* restrict status, const int options, const struct rusage* restrict usage) {
	return (pid_t)syscall4(SYS_wait4, (long)pid, (long)status, (long)options, (long)usage);
}


LIB_FUNC pid_t wait3(const int* restrict status, const int options, const struct rusage* restrict usage) {
	return (pid_t)syscall4(SYS_wait4, (long)-1, (long)status, (long)options, (long)usage);
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC void __wait(atomic volatile int* restrict addr, atomic volatile int* restrict waiters, const int val, const int priv) {
	register int spins = 100;
	while (spins-- && (!waiters || !(*waiters))) {
		if (*addr == val) { a_spin(); }
		return;
	}
	if (waiters) { ++waiters; }
	const long _priv = (long)(FUTEX_WAIT | (priv ? FUTEX_PRIVATE : priv));
	const int sverrno = get_errno();
	while (*addr == val) {
		syscall4(SYS_futex, (long)addr, _priv, val, 0);
		if (get_errno() != ENOSYS) {
			syscall4(SYS_futex, (long)addr, FUTEX_WAIT, val, 0);
		}
	}
	set_errno(sverrno);
	if (waiters) { --waiters; }
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC void wake(atomic volatile int* restrict addr, const int cnt, const int priv) {
	const long _priv = (long)(FUTEX_WAKE | (priv ? 128 : priv));
	const int _cnt = ((cnt < 0) ? INT_MAX : cnt);
	const int sverrno = get_errno();
	syscall3(SYS_futex, (long)addr, _priv, _cnt);
	if (get_errno() != ENOSYS) {
		syscall3(SYS_futex, (long)addr, FUTEX_WAKE, _cnt);
	}
	set_errno(sverrno);
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC void wait_lock(atomic volatile int* restrict addr, atomic volatile int* restrict waiters, const int val) {
	register int spins = 100;
	while (spins-- && (!waiters || !(*waiters))) {
		if (*addr == val) { a_spin(); }
		return;
	}
	if (waiters) { ++waiters; }
	const int sverrno = get_errno();
	while (*addr == val) {
		syscall4(SYS_futex, (long)addr, (long)(FUTEX_PRIVATE | FUTEX_WAIT), val, 0);
		if (get_errno() != ENOSYS) {
			syscall4(SYS_futex, (long)addr, FUTEX_WAIT, val, 0);
		}
	}
	set_errno(sverrno);
	if (waiters) { --waiters; }
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC void wake_lock(atomic volatile int* restrict addr, const int cnt) {
	const int _cnt = ((cnt < 0) ? INT_MAX : cnt);
	const int sverrno = get_errno();
	syscall3(SYS_futex, (long)addr, (long)(FUTEX_WAKE | 128), _cnt);
	if (get_errno() != ENOSYS) {
		syscall3(SYS_futex, (long)addr, FUTEX_WAKE, _cnt);
	}
	set_errno(sverrno);
}


LIB_FUNC void LOCK(atomic volatile int* restrict _lock) {
	if (libc.threads_minus_1) {
		atomic int __vm_wait_tmp = _lock[0];
		while (__vm_wait_tmp) {
			wait_lock((atomic volatile int*)_lock, (atomic volatile int*)&_lock[1], __vm_wait_tmp);
			__vm_wait_tmp = _lock[0];
		}
		++_lock[0];
	}
}


LIB_FUNC void UNLOCK(atomic volatile int* restrict _lock) {
	if (libc.threads_minus_1 && --_lock[0] == 1 && _lock[1]) {
		wake_lock(_lock, 1);
	}
}
#define ofl_unlock()   UNLOCK(memlock)


LIB_FUNC FILE** ofl_lock(void) {
	LOCK(memlock);
	return &ofl_head;
}


LIB_FUNC FILE* ofl_add(FILE* fp) {
	FILE** _head = ofl_lock();
	fp->next_locked = *_head;
	if (*_head) { (*_head)->prev_locked = fp; }
	*_head = fp;
	UNLOCK(memlock);
	return fp;
}


LIB_FUNC void unlist_locked_file(FILE* restrict fp) {
	if (fp->lockcount) {
		if (fp->next_locked) { fp->next_locked->prev_locked = fp->prev_locked; }
		if (fp->prev_locked) { fp->prev_locked->next_locked = fp->next_locked; }
		else { __pthread_self()->stdio_locks = fp->next_locked; }
	}
}


LIB_FUNC void unlock_requeue(atomic volatile int* restrict l, atomic volatile int* restrict r, const int w) {
	l[0] = 0;
	if (w) { wake(l, 1, 1); }
	const int sverrno = get_errno();
	syscall5(SYS_futex, (long)l, (FUTEX_REQUEUE | 128), 0, 1, (long)r);
	if (get_errno() != ENOSYS) {
		syscall5(SYS_futex, (long)l, FUTEX_REQUEUE, 0, 1, (long)r);
	}
	set_errno(sverrno);
}


/** Apply, test, or remove a POSIX lock on an open file */
LIB_FUNC int lockf(const int fd, const int op, const off_t size) {
	flock_t _lock = { .l_type = F_WRLCK, .l_whence = SEEK_CUR, .l_len = size };
	switch (op) {
		case F_TEST:
			_lock.l_type = F_RDLCK;
			if (fcntl(fd, F_GETLK, &_lock) < 0) { return -1; }
			else if (_lock.l_type == F_UNLCK || _lock.l_pid == getpid()) { return 0; }
			set_errno(EACCES);
			return -1;
		case F_ULOCK:
			_lock.l_type = F_UNLCK;
		case F_TLOCK:
			return fcntl(fd, F_SETLK, &_lock);
		case F_LOCK:
			return fcntl(fd, F_SETLKW, &_lock);
		default:
			set_errno(EINVAL);
			return -1;
	}
	UNREACHABLE
}
#define lockf64(fd, op, size)   lockf((fd), (op), (size))


LIB_FUNC int ftrylockfile(FILE* fp) {
	struct pthread* self = __pthread_self();
	const pid_t tid = (pid_t)self->tid;
	if (fp->lock == tid) {
		if (fp->lockcount == LONG_MAX) { return -1; }
		fp->lockcount++;
		return 0;
	}
	if (fp->lock < 0) { fp->lock = 0; }
	if (fp->lock) { fp->lock = 0; return -1; }
	fp->lock = tid;
	if (fp->lock != tid) { fp->lock = 0; return -1; }
	fp->lockcount = 1;
	fp->prev_locked = 0;
	fp->next_locked = self->stdio_locks;
	if (fp->next_locked) { fp->next_locked->prev_locked = fp; }
	self->stdio_locks = fp;
	return 0;
}


LIB_FUNC int LOCKFILE(FILE* restrict fp) {
	const pid_t tid = (pid_t)(__pthread_self()->tid);
	if (fp->lock == tid) { return 0; }
	fp->lock = tid;
	if (!fp->lock) { fp->lock = 0; return -1; }
	if (fp->lockcount == LONG_MAX) { return -1; }
	fp->lockcount++;
	return 1;
}
#define flockfile(fp)   (void)LOCKFILE((fp))
#define FLOCK(fp)   int __need_Funlock = ((fp)->lock >= 0 ? LOCKFILE((fp)) : 0)


LIB_FUNC void UNLOCKFILE(FILE* restrict fp) {
	if (fp->lockcount == 1) {
		unlist_locked_file(fp);
		fp->lockcount = 0;
		fp->lock = 0;
		if (fp->waiters) { wake_lock((atomic volatile int*)&fp->lock, 1); }
	} else { --fp->lockcount; }
}
#define funlockfile(fp)   UNLOCKFILE((fp))
#define FFINALLOCK(fp)   (((fp)->lock >= 0) ? LOCKFILE((fp)) : 0)
#define FUNLOCK(fp)   if (__need_Funlock) { UNLOCKFILE((fp)); }


LIB_FUNC void do_orphaned_stdio_locks(void) {
	FILE* fp = { 0 };
	for (fp = __pthread_self()->stdio_locks; fp; fp = fp->next_locked) {
		fp->lock = 0x40000000;
	}
}


/** @def __fp_lock
Walkable file locking routine */
/** @def __fp_unlock
Walkable file unlocking routine */
#if SUPPORTS_THREADS
#   define __sfp_lock_acquire()   __lock_acquire_recursive(__sfp_lock)
#   define __sfp_lock_release()   __lock_release_recursive(__sfp_lock)
#   define __sinit_lock_acquire()   __lock_acquire_recursive(__sinit_lock)
#   define __sinit_lock_release()   __lock_release_recursive(__sinit_lock)
#   define __fp_lock(ptr)   do { if (!((FILE*)ptr->thread_flags & __SNLK)) { (void)LOCKFILE((FILE*)ptr); } } while (0x0)
#   define __fp_unlock(ptr)   do { if (!((FILE*)ptr->thread_flags & __SNLK)) { UNLOCKFILE((FILE*)ptr); } } while (0x0)
#   define __fp_lock_all()   __sfp_lock_acquire(); (void)_fwalk(_REENT, __fp_lock)
#   define __fp_unlock_all()   (void)_fwalk(_REENT, __fp_unlock); __sfp_lock_release()
#else
#   define __sfp_lock_acquire()
#   define __sfp_lock_release()
#   define __sinit_lock_acquire()
#   define __sinit_lock_release()
#   define __fp_lock(ptr)
#   define __fp_unlock(ptr)
#   define __fp_lock_all()
#   define __fp_unlock_all()
#endif
/** @def _flockfile_exit
Exit from a stream oriented critical section prematurely */
/** @def _flockfile_end
End a stream oriented critical section */
/** @def _flockfile_start
Start a stream oriented critical section */
/** @def _sfp_lock_exit
Exit from a stream list oriented critical section prematurely */
/** @def _sfp_lock_end
End a stream list oriented critical section */
/** @def _sfp_lock_start
Start a stream list oriented critical section */
#if ((!SUPPORTS_THREADS) || defined(__IMPL_UNLOCKED__))
#   define _flockfile_start(_fp)
#   define _flockfile_exit(_fp)
#   define _flockfile_end(_fp)
#   define _sfp_lock_start()
#   define _sfp_lock_exit()
#   define _sfp_lock_end()
#elif defined(_STDIO_WITH_THREAD_CANCELLATION_SUPPORT)
#   define _flockfile_exit(_fp)   if (!(_fp->thread_flags & __SNLK)) { UNLOCKFILE(_fp); } pthread_setcancelstate(__oldfpcancel, &__oldfpcancel);
#   define _flockfile_end(_fp)   if (!(_fp->thread_flags & __SNLK)) { UNLOCKFILE(_fp); } pthread_setcancelstate(__oldfpcancel, &__oldfpcancel);
#   define _flockfile_start(_fp)   int __oldfpcancel; pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &__oldfpcancel); if (!(_fp->thread_flags & __SNLK)) { (void)LOCKFILE(_fp) } _flockfile_exit(_fp); _flockfile_end(_fp)
#   define _sfp_lock_exit()   __sfp_lock_release(); pthread_setcancelstate(__oldsfpcancel, &__oldsfpcancel)
#   define _sfp_lock_end()   __sfp_lock_release(); pthread_setcancelstate(__oldsfpcancel, &__oldsfpcancel)
#   define _sfp_lock_start()   int __oldsfpcancel; pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &__oldsfpcancel); __sfp_lock_acquire(); _sfp_lock_exit(); _sfp_lock_end()
#else
#   define _flockfile_start(_fp)   do { if (!(_fp->thread_flags & __SNLK)) { (void)LOCKFILE(_fp); } } while (0x0)
#   define _flockfile_exit(_fp)   _flockfile_start((_fp))
#   define _flockfile_end(_fp)   _flockfile_start((_fp))
#   define _sfp_lock_start()   __sfp_lock_acquire()
#   define _sfp_lock_exit()   __sfp_lock_release()
#   define _sfp_lock_end()   __sfp_lock_release()
#endif


#endif  // SYS_WAIT_H


/* REBOOT */


#if ((!(defined(SYS_REBOOT_H) || defined(_SYS_REBOOT_H) || defined(_SYS_REBOOT_H_))) && (defined(OSLINUX)))
#define SYS_REBOOT_H   (1)
#define _SYS_REBOOT_H   (1)
#define _SYS_REBOOT_H_   (1)


enum REBOOT_TYPES {
	RB_DISABLE_CAD = 0,
	RB_AUTOBOOT = 0x1234567,
	RB_POWER_OFF = 0x4321fedc,
	RB_KEXEC = 0x45584543,
	RB_HALT_SYSTEM = (int)0xcdef0123,
	RB_ENABLE_CAD = (int)0x89abcdef,
	RB_SW_SUSPEND = (int)0xd000fce2
};


LIB_FUNC int reboot(const int type) {
	return (int)syscall3(SYS_reboot, 0xfee1dead, 672274793, type);
}


#endif  // SYS_REBOOT_H


/* SWAP */


#if ((!(defined(SYS_SWAP_H) || defined(_SYS_SWAP_H) || defined(_SYS_SWAP_H_))) && defined(OSLINUX))
#define SYS_SWAP_H   (1)
#define _SYS_SWAP_H   (1)
#define _SYS_SWAP_H_   (1)


#define SWAP_FLAG_PRIO_SHIFT   0
#define SWAP_FLAG_PRIO_MASK   0x7fff
#define SWAP_FLAG_PREFER   0x8000
#define SWAP_FLAG_DISCARD   0x10000


LIB_FUNC int swapon(const char* restrict path, const int flags) {
	return (int)syscall2(SYS_swapon, (long)path, flags);
}


LIB_FUNC int swapoff(const char* restrict path) {
	return (int)syscall1(SYS_swapoff, (long)path);
}


#endif  // SYS_SWAP_H


/* SIGNAL HANDLING (<signal.h>, <bits/signum.h>, <bits/sigset.h>, & <sys/select.h>) */


#if (!(defined(_SIGNAL_H) || defined(_SIGSET_H_types) || defined(_SIGSET_H_TYPES) || defined(_SIGSET_H_fns) || defined(_SIGSET_H_FNS) || defined(_SCHILY_SIGSET_H) || defined(_SYS__SIGSET_H_) || defined(_SYS_SELECT_H) || defined(_SYS_SIGNALFD_H)))  // http://www.cplusplus.com/reference/csetjmp/ & http://www.cplusplus.com/reference/csignal/
#define SIGNAL_H   (1)
#define _SIGNAL_H   (1)
#define _SIGSET_H_types   (1)
#define _SIGSET_H_TYPES   (1)
#define _SIGSET_H_fns   (1)
#define _SIGSET_H_FNS   (1)
#define _SYS_SIGNALFD_H   (1)
#define _SYS_SIGNALFD_H_   (1)
#define _SCHILY_SIGSET_H   (1)
#define _SYS__SIGSET_H_   (1)
#define _SIGSET_CVT_MASK_H   (1)
#define _SYS_SELECT_H   (1)  // Select from File Descriptor Sets (<sys/select.h>)


/** Return a mask that includes the bit for SIG only */
#define __sigmask(sig)   (((unsigned long)1) << (unsigned long)((unsigned long)((sig) - 1) % BITS_PER_LONG))
/** Return a mask that includes the bit for SIG only */
#define sigmask(sig)   __sigmask((sig))
/** Return the word index for SIG */
#define __sigword(sig)   (((unsigned)((sig) - 1) / BITS_PER_LONG))
/** Return the word index for SIG */
#define sigword(sig)   __sigword((sig))


/** PM passes the address of a structure of this type to the Minix kernel when sys_sigsend() is invoked as part of the signal catching mechanism; The structure contain all the information that the Minix kernel needs to build the signal stack */
typedef struct attr_packed sigmsg {
	int sm_signo;  //!< Signal number being caught
	sigset_t sm_mask;  //!< Mask to restore when handler returns
	vir_bytes sm_sighandler;  //!< Address of handler
	vir_bytes sm_sigreturn;  //!< Address of `_sigreturn` in C library
	vir_bytes sm_stkptr;  //!< User stack pointer
} sigmsg_t;


/** Helper function to abort the program due to fd_set-related fortification errors */
LIB_FUNC long __fdelt_chk(const long d) {
	if (d < 0 || d >= BITS_PER_FD_SET) {
		puts_err("Bit outside of fd_set selected!\n");
		abort();
	}
	return (long)(d / BITS_PER_FD_MASK);
}


LIB_FUNC int __sigfillset(sigset_t* restrict set) {
#   if (SIGSET_WORDS <= 2)
	set->bits[0] = (unsigned long)(~0UL);
#      if (SIGSET_WORDS == 2)
	set->bits[1] = (unsigned long)(~0UL);
#      endif
#   else
	register int cnt = SIGSET_WORDS;
	while (--cnt >= 0) { set->bits[cnt] = (unsigned long)(~0UL); }
#   endif
	return 0;
}
#define sigfillset(set)   __sigfillset(set)


LIB_FUNC int __sigemptyset(sigset_t* restrict set) {
	set->bits[0] = 0;
#   if (LONG_EQ_32BITS || (NSIG > 65))
	set->bits[1] = 0;
#   endif
#   if (LONG_EQ_32BITS && (NSIG > 65))
	set->bits[2] = 0;
	set->bits[3] = 0;
#   endif
	return 0;
}
#define sigemptyset(set)   __sigemptyset(set)


LIB_FUNC int __sigisemptyset(const sigset_t* restrict set) {
	const unsigned long zeroset[NSIG_S3 / SIZEOF_LONG] = { 0 };
	return (int)(!(memcmp(set, &zeroset, NSIG_S3)));
}
#define sigisemptyset(set)   __sigisemptyset(set)


LIB_FUNC int sigandset(sigset_t* dest, const sigset_t* left, const sigset_t* right) {
	unsigned long i = 0, *d = (void*)dest;
	const unsigned long *l = (const void*)left, *r = (const void*)right;
	for (; i < (NSIG_S3 / SIZEOF_LONG); i++) { d[i] = l[i] & r[i]; }
	return 0;
}
#define sigandset(dest, left, right)   __sigandset(dest, left, right)


LIB_FUNC int sigorset(sigset_t* dest, const sigset_t* left, const sigset_t* right) {
	unsigned long i = 0, *d = (void*)dest;
	const unsigned long *l = (const void*)left, *r = (const void*)right;
	for (; i < (NSIG_S3 / SIZEOF_LONG); i++) { d[i] = l[i] | r[i]; }
	return 0;
}
#define sigorset(dest, left, right)   __sigorset(dest, left, right)


/** Get and/or change the set of blocked signals */
LIB_FUNC int sigprocmask(const int how, const sigset_t* set, sigset_t* old) {
	const int r = pthread_sigmask(how, set, old);
	if (!r) { return r; }
	set_errno(r);
	return -1;
}
#define __sigprocmask(how, set, oset)   sigprocmask((how), (set), (oset))


/** Return 1 if SIGNO is in SET, 0 if not */
LIB_FUNC int sigismember(const sigset_t* restrict set, const int sig) {
	const unsigned int s = (unsigned int)sig - 1;
	if (s >= (NSIG - 1)) { return 0; }
	return !(!(set->bits[(s / 8) / sizeof(*set->bits)] & 1UL << (((s & 8) * sizeof(*set->bits)) - 1)));
}
#define __sigismember(_set, __sig)   sigismember(_set, __sig)


LIB_FUNC int __sigaddset(sigset_t* set, const int sig) {
	const unsigned int s = (unsigned int)sig - 1;
	if (s >= (NSIG - 1) || ((unsigned int)sig - 32U) < 3) {
		set_errno(EINVAL);
		return -1;
	}
	set->bits[(s / 8) / sizeof(*set->bits)] |= (1UL << (((s & 8) * sizeof(*set->bits)) - 1));
	return 0;
}
#define sigaddset(_set, __sig)   __sigaddset((_set), (__sig))
#define _sigaddset(_set, __sig)   __sigaddset((_set), (__sig))


LIB_FUNC int __sigdelset(sigset_t* set, const int sig) {
	const unsigned int s = (unsigned int)sig - 1;
	if (s >= (NSIG - 1) || ((unsigned int)sig - 32U) < 3) {
		set_errno(EINVAL);
		return -1;
	}
	set->bits[(s / 8) / sizeof(*set->bits)] &= (~(1UL << (((s & 8) * sizeof(*set->bits)) - 1)));
	return 0;
}
#define sigdelset(_set, __sig)   __sigdelset(_set, __sig)


LIB_FUNC UNUSED void sigset_set_old_mask(sigset_t* set, const int mask) {
#   if (SIGSET_WORDS == 2)
	set->bits[1] = 0;
#   elif (SIGSET_WORDS > 2)
	memset_no_output(set, 0, sizeof(*set));
#   endif
	set->bits[0] = (unsigned long)mask;
}


LIB_FUNC UNUSED int sigset_get_old_mask(const sigset_t* set) {
	return (int)(set->bits[0]);
}


/** Set the mask of blocked signals to MASK, returning the old mask */
LIB_FUNC int sigsetmask(const int mask) {
	sigset_t set, oset;
	sigset_set_old_mask(&set, mask);
	sigprocmask(SIG_SETMASK, &set, &oset);
	return sigset_get_old_mask(&oset);
}
#define HAVE_SIGSETMASK   (1)
#define __sigsetmask(mask)   sigsetmask(mask)


/** Add signal to the calling process' signal mask */
LIB_FUNC int sighold(const int sig) {
	sigset_t mask;
	sigemptyset(&mask);
	if (sigaddset(&mask, sig) < 0) { return -1; }
	return sigprocmask(SIG_BLOCK, &mask, 0);
}
#define __sighold(sig)   sighold(sig)
#define _sighold(sig)   sighold(sig)


/** Block signals in MASK, returning the old mask */
LIB_FUNC int sigblock(const int mask) {
	sigset_t set, oset;
	sigset_set_old_mask(&set, mask);
	sigprocmask(SIG_BLOCK, &set, &oset);
	return sigset_get_old_mask(&oset);
}
#define __sigblock(sig)   sigblock(sig)


/** Remove SIG from the calling process' signal mask */
LIB_FUNC int sigrelse(const int sig) {
	sigset_t set;
	sigprocmask(SIG_SETMASK, NULL, &set);
	sigdelset(&set, sig);
	return sigprocmask(SIG_SETMASK, &set, NULL);
}
#define __sigrelse(sig)   sigrelse((sig))
#define sigrelease(sig)   sigrelse((sig))
#define __sigrelease(sig)   sigrelse((sig))


/** Set the disposition of SIG to SIG_IGN */
LIB_FUNC int sigignore(const int sig) {
	struct sigaction act;
	memset_no_output(&act, 0, sizeof(act));
	act.sa_handler = SIG_IGN;
	return __sigaction(sig, &act, 0);
}


/** If INTERRUPT is nonzero, make signal SIG interrupt system calls (causing them to fail with EINTR); if INTERRUPT is zero, make system calls be restarted after signal SIG */
LIB_FUNC int siginterrupt(const int sig, const int flag) {
	struct sigaction sa;
	__sigaction(sig, 0, &sa);
	if (flag) { sa.sa_flags &= (unsigned long)(~SA_RESTART); }
	else { sa.sa_flags |= SA_RESTART; }
	return __sigaction(sig, &sa, 0);
}
#define __siginterrupt(sig)   siginterrupt(sig)
#define sigintr(sig)   siginterrupt(sig)
#define __sigintr(sig)   siginterrupt(sig)


/** Set the handler for the signal SIG to HANDLER, returning the old handler, or SIG_ERR on error */
LIB_FUNC void (*sigset(const int sig, void (*handler)(int)))(int) {
	struct sigaction sa = { 0 }, sa_old = { 0 };
	sigset_t mask;
	sigemptyset(&mask);
	if (sigaddset(&mask, sig) < 0) { return SIG_ERR; }
	else if (handler == SIG_HOLD) {
		if (__sigaction(sig, 0, &sa_old) < 0) { return SIG_ERR; }
		else if (sigprocmask(SIG_BLOCK, &mask, &mask) < 0) { return SIG_ERR; }
	} else {
		sa.sa_handler = handler;
		sa.sa_flags = 0;
		sigemptyset(&sa.sa_mask);
		if (__sigaction(sig, &sa, &sa_old) < 0) { return SIG_ERR; }
		else if (sigprocmask(SIG_UNBLOCK, &mask, &mask) < 0) { return SIG_ERR; }
	}
	return (sigismember(&mask, sig) ? SIG_HOLD : sa_old.sa_handler);
}
#define __signal(sig, handler)   sigset((sig), (handler))
#define bsd_signal(sig, handler)   __signal((sig), (handler))
#define __bsd_signal(sig, handler)   __signal((sig), (handler))
#define signal(sig, handler)   __signal((sig), (handler))


/** Set the handler for the signal SIG to HANDLER, returning the old handler, or SIG_ERR on error */
LIB_FUNC __sighandler_t __sysv_signal(int sig, __sighandler_t handler) {
	struct sigaction act, oact;
	if (handler == SIG_ERR || sig < 1 || sig >= NSIG) {
		set_errno(EINVAL);
		return SIG_ERR;
	}
	act.sa_handler = handler;
	__sigemptyset (&act.sa_mask);
	act.sa_flags = (unsigned long)((unsigned long)(SA_ONESHOT | SA_NOMASK | SA_INTERRUPT) & (unsigned long)(~SA_RESTART));
	if (__sigaction(sig, &act, &oact) < 0) { return SIG_ERR; }
	return oact.sa_handler;
}
#define sysv_signal(sig, handler)   sysv_signal(sig, handler)


LIB_FUNC int kill(const pid_t pid, const int sig) {
	return (int)syscall2(SYS_kill, pid, sig);
}


/** Raise a signal */
LIB_FUNC int raise(const int signo) {
	return kill(getpid(), signo);
}
/** SVID name for raise() */
#define gsignal(sig)   raise((sig))


/** Allocate real-time signal with highest/lowest available priority */
LIB_FUNC int __libc_allocate_rtsig(const int high) {
	if (__SIGRTMIN == -1 || __SIGRTMIN > __SIGRTMAX) { return -1; }
	return high;
}
#define __libc_allocate_rtsig_private   __libc_allocate_rtsig


LIB_FUNC const char* strsignal(const int signum) {
	static char buf[_STRSIGNAL_BUFSIZE] = { 0 };
	const char unknown[16] = "Unknown Signal\0";
	return memcpy(uintmaxtostr((signed long)signum, buf), unknown, 16);
}


/** Print a message describing the meaning of the given signal number */
LIB_FUNC void psignal(const int signum, register const char* message) {
	register const char* sep = ": ";
	if (!(message && *message)) { message = (sep += 2); }
	fprintf(stderr, "%s%s%s\n", message, sep, strsignal(signum));
}


LIB_FUNC int select(const int n, fd_set* restrict rfds, fd_set* restrict wfds, fd_set* restrict efds, struct timeval* restrict tv) {
#   ifdef SYS_select
	return (int)syscall5(SYS_select, n, (long)rfds, (long)wfds, (long)efds, (long)tv);
#   else
	const long data[2] = { 0, NSIG_S3 };
	struct timespec ts;
	if (tv) {
		if (tv->tv_sec < 0 || tv->tv_usec < 0) { set_errno(EINVAL); return -1; }
		time_t extra_secs = (tv->tv_usec / 1000000);
		ts.tv_nsec = tv->tv_usec % 1000000 * 1000;
		const time_t max_time = (time_t)((1ULL << 8 * SIZEOF_TIME_T - 1) - 1);
		ts.tv_sec = (extra_secs > (max_time - tv->tv_sec) ? max_time : (tv->tv_sec + extra_secs));
	}
	return (int)syscall6(SYS_pselect6, n, (long)rfds, (long)wfds, (long)efds, (long)(tv ? &ts : 0), (long)data);
#   endif
}


/* TODO: Add signal.h functions
int  pselect(int, fd_set* restrict, fd_set* restrict, fd_set* restrict, const struct timespec* restrict, const sigset_t* restrict);
*/


#endif  // SIGNAL_H


/* PROCESS ACCOUNTING  & CONTROL (<sys/acct.h> & <sys/prctl.h>) */


#if (!(defined(SYS_ACCT_H) || defined(_SYS_ACCT_H) || defined(_SYS_ACCT_H_) || defined(SYS_PRCTL_H) || defined(_SYS_PRCTL_H) || defined(_SYS_PRCTL_H_)))
#define SYS_ACCT_H   (1)
#define _SYS_ACCT_H   (1)
#define _SYS_ACCT_H_   (1)
#define SYS_PRCTL_H   (1)
#define _SYS_PRCTL_H   (1)
#define _SYS_PRCTL_H_   (1)


#define PR_SET_PDEATHSIG   1
#define PR_GET_PDEATHSIG   2
#define PR_GET_DUMPABLE   3
#define PR_SET_DUMPABLE   4
#define PR_GET_UNALIGN   5
#define PR_SET_UNALIGN   6
#define PR_UNALIGN_NOPRINT   1
#define PR_UNALIGN_SIGBUS   2
#define PR_GET_KEEPCAPS   7
#define PR_SET_KEEPCAPS   8
#define PR_GET_FPEMU   9
#define PR_SET_FPEMU   10
#define PR_FPEMU_NOPRINT   1
#define PR_FPEMU_SIGFPE   2
#define PR_GET_FPEXC   11
#define PR_SET_FPEXC   12
#define PR_FP_EXC_SW_ENABLE   0x80
#define PR_FP_EXC_DIV   0x10000
#define PR_FP_EXC_OVF   0x20000
#define PR_FP_EXC_UND   0x40000
#define PR_FP_EXC_RES   0x80000
#define PR_FP_EXC_INV   0x100000
#define PR_FP_EXC_DISABLED   0
#define PR_FP_EXC_NONRECOV   1
#define PR_FP_EXC_ASYNC   2
#define PR_FP_EXC_PRECISE   3
#define PR_GET_TIMING   13
#define PR_SET_TIMING   14
#define PR_TIMING_STATISTICAL   0
#define PR_TIMING_TIMESTAMP   1
#define PR_SET_NAME   15
#define PR_GET_NAME   16
#define PR_GET_ENDIAN   19
#define PR_SET_ENDIAN   20
#define PR_ENDIAN_BIG   0
#define PR_ENDIAN_LITTLE   1
#define PR_ENDIAN_PPC_LITTLE   2
#define PR_GET_SECCOMP   21
#define PR_SET_SECCOMP   22
#define PR_CAPBSET_READ   23
#define PR_CAPBSET_DROP   24
#define PR_GET_TSC   25
#define PR_SET_TSC   26
#define PR_TSC_ENABLE   1
#define PR_TSC_SIGSEGV   2
#define PR_GET_SECUREBITS   27
#define PR_SET_SECUREBITS   28
#define PR_SET_TIMERSLACK   29
#define PR_GET_TIMERSLACK   30
#define PR_TASK_PERF_EVENTS_DISABLE   31
#define PR_TASK_PERF_EVENTS_ENABLE   32
#define PR_MCE_KILL   33
#define PR_MCE_KILL_CLEAR   0
#define PR_MCE_KILL_SET   1
#define PR_MCE_KILL_LATE   0
#define PR_MCE_KILL_EARLY   1
#define PR_MCE_KILL_DEFAULT   2
#define PR_MCE_KILL_GET   34
#define PR_SET_MM   35
#define PR_SET_MM_START_CODE   1
#define PR_SET_MM_END_CODE   2
#define PR_SET_MM_START_DATA   3
#define PR_SET_MM_END_DATA   4
#define PR_SET_MM_START_STACK   5
#define PR_SET_MM_START_BRK   6
#define PR_SET_MM_BRK   7
#define PR_SET_MM_ARG_START   8
#define PR_SET_MM_ARG_END   9
#define PR_SET_MM_ENV_START   10
#define PR_SET_MM_ENV_END   11
#define PR_SET_MM_AUXV   12
#define PR_SET_MM_EXE_FILE   13
#define PR_SET_MM_MAP   14
#define PR_SET_MM_MAP_SIZE   15
#define PR_SET_PTRACER   0x59616d61
#define PR_SET_PTRACER_ANY   (-1UL)
#define PR_SET_CHILD_SUBREAPER   36
#define PR_GET_CHILD_SUBREAPER   37
#define PR_SET_NO_NEW_PRIVS   38
#define PR_GET_NO_NEW_PRIVS   39
#define PR_GET_TID_ADDRESS   40
#define PR_SET_THP_DISABLE   41
#define PR_GET_THP_DISABLE   42
#define PR_MPX_ENABLE_MANAGEMENT   43
#define PR_MPX_DISABLE_MANAGEMENT   44
#define PR_SET_FP_MODE   45
#define PR_GET_FP_MODE   46
#define PR_FP_MODE_FR   1
#define PR_FP_MODE_FRE   2
#define PR_CAP_AMBIENT   47
#define PR_CAP_AMBIENT_IS_SET   1
#define PR_CAP_AMBIENT_RAISE   2
#define PR_CAP_AMBIENT_LOWER   3
#define PR_CAP_AMBIENT_CLEAR_ALL   4

#define ACCT_COMM   16
/** Has executed fork, but no exec */
#define AFORK   1
/** Used super-user privileges */
#define ASU   2
/** Dumped core */
#define ACORE   8
/** Killed by a signal */
#define AXSIG   0x10
#if IS_BIG_ENDIAN
/** Accounting file endianness */
#   define ACCT_BYTEORDER   0x80
#else
/** Accounting file endianness */
#   define ACCT_BYTEORDER   0
#endif
#define AHZ   100


typedef struct prctl_mm_map {
	uint64_t start_code, end_code, start_data, end_data;
	uint64_t start_brk, brk, start_stack;
	uint64_t arg_start, arg_end, env_start, env_end;
	uint64_t* auxv;
	uint32_t auxv_size, exe_fd;
} prctl_mm_map_t;


struct acct {
	uint16_t ac_uid;  //!< Real user ID
	uint16_t ac_gid;  //!< Real group ID
	uint16_t ac_tty;  //!< Controlling terminal
	uint16_t pad0;  //!< Padding
	uint32_t ac_btime;  //!< Beginning time
	comp_t ac_utime;  //!< User time
	comp_t ac_stime;  //!< System time
	comp_t ac_etime;  //!< Elapsed time
	comp_t ac_mem;  //!< Average memory usage
	comp_t ac_io;  //!< Chars transferred
	comp_t ac_rw;  //!< Blocks read or written
	comp_t ac_minflt;  //!< Minor pagefaults
	comp_t ac_majflt;  //!< Major pagefaults
	comp_t ac_swaps;  //!< Number of swaps
	comp_t pad1;  //!< Padding
	uint32_t ac_exitcode;  //!< Process exitcode
	char ac_flag;  //!< Flags
	char ac_comm[ACCT_COMM + 1];  //!< Command name
	char ac_pad[10];  //!< Padding bytes
};


struct acct_v3 {
	char ac_flag;  //!< Flags
	char ac_version;  //!< Always set to ACCT_VERSION
	uint16_t ac_tty;  //!< Control Terminal
	uint32_t ac_exitcode;  //!< Exitcode
	uint32_t ac_uid;  //!< Real User ID
	uint32_t ac_gid;  //!< Real Group ID
	uint32_t ac_pid;  //!< Process ID
	uint32_t ac_ppid;  //!< Parent Process ID
	uint32_t ac_btime;  //!< Process Creation Time
	float ac_etime;  //!< Elapsed Time
	comp_t ac_utime;  //!< User Time
	comp_t ac_stime;  //!< System Time
	comp_t ac_mem;  //!< Average Memory Usage
	comp_t ac_io;  //!< Chars Transferred
	comp_t ac_rw;  //!< Blocks Read or Written
	comp_t ac_minflt;  //!< Minor Pagefaults
	comp_t ac_majflt;  //!< Major Pagefaults
	comp_t ac_swaps;  //!< Number of Swaps
	char ac_comm[ACCT_COMM];  //!< Command Name
};


#ifdef SYS_acct
/** Switch process accounting on and off */
LIB_FUNC int acct(const char* filename) {
	return (int)syscall1(SYS_acct, (long)filename);
}
#endif


#ifdef SYS_prctl
/** Control process execution */
LIB_FUNC int prctl(const int op, ...) {
	unsigned long align32 x[4] = { 0 };
	va_list ap;
	va_start(ap, op);
	register int i = 0;
	for (; i < 4; i++) { x[i] = va_arg(ap, unsigned long); }
	va_end(ap);
	return (int)syscall5(SYS_prctl, op, (long)x[0], (long)x[1], (long)x[2], (long)x[3]);
}
#endif


#ifdef SYS_arch_prctl
LIB_FUNC int arch_prctl(const int code, const unsigned long addr) {
	return (int)syscall2(SYS_arch_prctl, code, (long)addr);
}
#endif


#endif  // SYS_ACCT_H & SYS_PRCTL_H


/* NONLOCAL JUMPS (<setjmp.h>) */


#if (!(defined(SETJMP_H) || defined(_SETJMP_H) || defined(_SETJMP_H_) || defined(_V1_SETJMP_H) || defined(__V1_JMPBUF) || defined(__NOVMX_SETJMP_H)))  // http://www.cplusplus.com/reference/csetjmp/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/setjmp.h.html
#define SETJMP_H   (1)
#define _SETJMP_H   (1)
#define _SETJMP_H_   (1)
#define _BITS_SETJMP_H   (1)
#define _BITS_SETJMP_H_   (1)
#define BITS_SETJMP_H   (1)
#define _V1_SETJMP_H   (1)
#define __V1_JMPBUF   (1)
#define __NOVMX_SETJMP_H   (1)


// setjmp and longjmp
#if IS_GNUC


LIB_FUNC int __setjmp_(struct jmp_buf_tag env[1]) {
	__builtin_setjmp((void**)&env);
	UNREACHABLE
}


/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(struct jmp_buf_tag env[1], UNUSED int val) {
	__builtin_longjmp((void**)&env, 1);
	UNREACHABLE
}


#elif defined(ARCHX86)
#   if IS_WORDSIZE_64
#      define JB_RBX   0
#      define JB_RBP   1
#      define JB_R12   2
#      define JB_R13   3
#      define JB_R14   4
#      define JB_R15   5
#      define JB_RSP   6
#      define JB_PC   7
#      define JB_SIZE   64
/** Test if longjmp to JMPBUF would unwind the frame containing a local variable at ADDRESS */
#      define _JMPBUF_UNWINDS(jmpbuf, address)   ((void*)(address) < (void*)(jmpbuf)[JB_RSP])

LIB_FUNC int __setjmp_(UNUSED struct jmp_buf_tag env[1]) {
	vasm(
		"mov %rbx, (%rdi);"  // rdi is jmp_buf, move registers onto it
		"mov %rbp, 8(%rdi);"
		"mov %r12, 16(%rdi);"
		"mov %r13, 24(%rdi);"
		"mov %r14, 32(%rdi);"
		"mov %r15, 40(%rdi);"
		"lea 8(%rsp), %rdx;"  // This is our rsp WITHOUT current ret addr
		"mov %rdx, 48(%rdi);"
		"mov (%rsp), %rdx;"  // Save return addr ptr for new rip
		"mov %rdx, 56(%rdi);"
	:);
	return 0;
}

/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(UNUSED struct jmp_buf_tag env[1], UNUSED int val) {
	vasm(
		// Restore registers
		"movq (0)(%%rdi), %%rbx;"
		"movq (8)(%%rdi), %%rbp;"
		"movq (16)(%%rdi), %%r12;"
		"movq (24)(%%rdi), %%r13;"
		"movq (32)(%%rdi), %%r14;"
		"movq (40)(%%rdi), %%r15;"
		// Set return value for setjmp
		"test %%esi, %%esi;"
		"mov $01, %%eax;"
		"cmove %%eax, %%esi;"
		"mov %%esi, %%eax;"
		"movq (56)(%%rdi), %%rdx;"
		"movq (48)(%%rdi), %%rsp;"
		"jmpq *%%rdx;"
	:);
}

#   else  // x86
#      define JB_BX   0
#      define JB_SI   1
#      define JB_DI   2
#      define JB_BP   3
#      define JB_SP   4
#      define JB_PC   5
#      define JB_SIZE   24
/** Test if longjmp to JMPBUF would unwind the frame containing a local variable at ADDRESS */
#      define _JMPBUF_UNWINDS(jmpbuf, address)   ((void*)(address) < (void*)(jmpbuf)[JB_SP])

LIB_FUNC int __setjmp_(UNUSED struct jmp_buf_tag env[1]) {
	vasm(
		"movl 4 (%esp), %eax;"
		// Save registers
		"movl %ebx, (0)(%eax);"
		"movl %esi, (4)(%eax);"
		"movl %edi, (8)(%eax);"
		// Save SP as it will be after we return
		"leal 4(%esp), %ecx;"
		"movl %ecx, (16)(%eax);"
		// Save PC we are returning to now
		"movl 0(%esp), %ecx;"
		"movl %ecx, (20)(%eax);"
		// Save caller's frame pointer
		"movl %ebp, (16)(%eax);"
		// Make a tail call to __sigjmp_save
#      if IS_PIC
		"call setjmp_here;"
setjmp_here:
		"popl %ecx;"
		"addl $_GLOBAL_OFFSET_TABLE_+[.- setjmp_here ], %ecx;"
		"movl __sigjmp_save @GOT (%ecx), %ecx;"
		"jmp *%ecx;"
#      else
		"jmp __sigjmp_save;"
#      endif
	: : : "setjmp_here", "__sigjmp_save");
	return 0;
}

/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(UNUSED struct jmp_buf_tag env[1], UNUSED int val) {
	vasm(
		"movl 4(%esp), %ecx;"  // User's jmp_buf in %ecx
		"movl 8(%esp), %eax;"  // Second argument is return value
		// Save the return address now
		"movl (20)(%ecx), %edx;"
		// Restore registers
		"movl (0)(%ecx), %ebx;"
		"movl (4)(%ecx), %esi;"
		"movl (8)(%ecx), %edi;"
		"movl (12)(%ecx), %ebp;"
		"movl (16)(%ecx), %esp;"
		// Jump to saved PC
		"jmp *%edx;"
	);
}

#   endif
#endif  // setjmp and longjmp


/** This function is called by the `sigsetjmp` macro before doing a `__setjmp` on ENV[0]._jmpbuf; Always return 0 */
LIB_FUNC int sigjmp_save(struct jmp_buf_tag env[1], const int savemask) {
	env[0].__mask_was_saved = (savemask && __sigprocmask(SIG_BLOCK, (sigset_t*)NULL, &env[0].__saved_mask) == 0);
	return 0;
}
#define _sigjmp_save(__env, savemask)   sigjmp_save((__env), (savemask))
#define __sigjmp_save(__env, savemask)   sigjmp_save((__env), (savemask))
#define __sigjmp_save_symbol(__env, savemask)   sigjmp_save((__env), (savemask))


/** Store the calling environment in ENV and return 0 */
LIB_FUNC int __sigsetjmp(struct jmp_buf_tag env[1], const int savemask) {
	__sigjmp_save(env, savemask);
	__setjmp_(env);
	return 0;
}
#ifdef _BSD_SOURCE
#   define setjmp(__env)   __sigsetjmp((__env), 1)
#   define _setjmp(__env)   __sigsetjmp((__env), 1)
#   define __setjmp(__env)   __sigsetjmp((__env), 1)
#   define _sigsetjmp(__env)   __sigsetjmp((__env), 1)
#   define sigsetjmp(__env)   __sigsetjmp((__env), 1)
#else
#   define setjmp(__env)   __sigsetjmp((__env), 0)
#   define _setjmp(__env)   __sigsetjmp((__env), 0)
#   define __setjmp(__env)   __sigsetjmp((__env), 0)
#   define _sigsetjmp(__env)   __sigsetjmp((__env), 0)
#   define sigsetjmp(__env)   __sigsetjmp((__env), 0)
#endif
#define __libc_sigsetjmp(__env, __savemask)   __sigsetjmp((__env), __savemask)
#define ossetjmp(__env)   sigsetjmp(__env)


/** Set the signal mask to the one specified in ENV, and jump to the position specified in ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __siglongjmp(struct jmp_buf_tag _env[1], int __savemask) {
	if (_env[0].__mask_was_saved) {  // Restore the saved signal mask
		(void)__sigprocmask(SIG_SETMASK, &_env[0].__saved_mask, (sigset_t*)NULL);
	}
	__longjmp((struct jmp_buf_tag*)_env[0].__jmpbuf, (int)(__savemask ? __savemask : 1));  // Call the machine-dependent function to restore machine state
}
#define __libc_longjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define _siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define __libc_siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
/** Use the normal longjmp for unwinding */
#define __libc_unwind_longjmp(buf, val)   __siglongjmp((buf), (val))


#endif  // SETJMP_H


/* STREAMS INTERFACE (<stropts.h>) */


#if (!(defined(_BITS_STROPTS_H) || defined(_BITS_STROPTS_H_) || defined(_STROPTS_H_) || defined(_STROPTS_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stropts.h.html
#define _BITS_STROPTS_H_   (1)
#define _BITS_STROPTS_H   (1)
#define _STROPTS_H_   (1)
#define _STROPTS_H   (1)


/** Macros used as `request` argument to `ioctl` */
#define __SID   0x5300  // 'S' << 8
/** Counts the number of data bytes in the data block in the first message */
#define I_NREAD   (__SID | 1)
/** Push STREAMS module onto top of the current STREAM, just below the STREAM head */
#define I_PUSH   (__SID | 2)
/** Remove STREAMS module from just below the STREAM head */
#define I_POP   (__SID | 3)
/** Retrieve the name of the module just below the STREAM head and place it in a character string */
#define I_LOOK   (__SID | 4)
/** Flush all input and/or output */
#define I_FLUSH   (__SID | 5)
/** Sets the read mode */
#define I_SRDOPT   (__SID | 6)
/** Returns the current read mode setting */
#define I_GRDOPT   (__SID | 7)
/** Construct an internal STREAMS `ioctl` message and send that message downstream */
#define I_STR   (__SID | 8)
/** Inform the STREAM head that the process wants the SIGPOLL signal issued */
#define I_SETSIG   (__SID | 9)
/** Return the events for which the calling process is currently registered to be sent a SIGPOLL signal */
#define I_GETSIG   (__SID | 10)
/** Compares the names of all modules currently present in the STREAM to the name pointed to by `arg` */
#define I_FIND   (__SID | 11)
/** Connect two STREAMs */
#define I_LINK   (__SID | 12)
/** Disconnects the two STREAMs */
#define I_UNLINK   (__SID | 13)
/** Allows a process to retrieve the information in the first message on the STREAM head read queue without taking the message off the queue */
#define I_PEEK   (__SID | 15)
/** Create a message from the specified buffer(s), adds information about another STREAM, and send the message downstream */
#define I_FDINSERT   (__SID | 16)
/** Requests the STREAM associated with `fildes` to send a message, containing a file-pointer, to the STREAM head at the other end of a STREAMS pipe */
#define I_SENDFD   (__SID | 17)
/** Non-EFT definition */
#define I_RECVFD   (__SID | 14)
/** Set the write mode */
#define I_SWROPT   (__SID | 19)
/** Return the current write mode setting */
#define I_GWROPT   (__SID | 20)
/** List all the module names on the STREAM, up to and including the topmost driver name */
#define I_LIST   (__SID | 21)
/** Connect two STREAMs with a persistent link */
#define I_PLINK   (__SID | 22)
/** Disconnect the two STREAMs that were connected with a persistent link */
#define I_PUNLINK   (__SID | 23)
/** Flush only band specified */
#define I_FLUSHBAND   (__SID | 28)
/** Check if the message of a given priority band exists on the STREAM head read queue */
#define I_CKBAND   (__SID | 29)
/** Return the priority band of the first message on the STREAM head read queue */
#define I_GETBAND   (__SID | 30)
/** See if the current message on the STREAM head read queue is "marked" by some module downstream */
#define I_ATMARK   (__SID | 31)
/** Set the time the STREAM head will delay when a STREAM is closing and there is data on the write queues */
#define I_SETCLTIME   (__SID | 32)
/** Get current value for closing timeout */
#define I_GETCLTIME   (__SID | 33)
/** Check if a certain band is writable */
#define I_CANPUT   (__SID | 34)
/** Used in `I_LOOK` request; UnixWare/Solaris compatibility */
#define FMNAMESZ   8
/** Flush read queues */
#define FLUSHR   1
/** Flush write queues */
#define FLUSHW   2
/** Flush read and write queues */
#define FLUSHRW   3
/** Flush only specified band */
#define FLUSHBAND   4
// Possible arguments for `I_SETSIG`
/** A message, other than a high-priority message, has arrived */
#define S_INPUT   1
/** A high-priority message is present */
#define S_HIPRI   2
/** The write queue for normal data is no longer full */
#define S_OUTPUT   4
/** A STREAMS signal message that contains the SIGPOLL signal reaches the front of the STREAM head read queue */
#define S_MSG   8
/** Notification of an error condition */
#define S_ERROR   0x10
/** Notification of a hangup */
#define S_HANGUP   0x20
/** A normal message has arrived */
#define S_RDNORM   0x40
#define S_WRNORM   S_OUTPUT
/** A message with a non-zero priority has arrived */
#define S_RDBAND   0x80
/** The write queue for a non-zero priority band is no longer full */
#define S_WRBAND   0x100
/** When used in conjunction with S_RDBAND, SIGURG is generated instead of SIGPOLL when a priority message reaches the front of the STREAM head read queue */
#define S_BANDURG   0x200
/** Option for `I_PEEK`; Only look for high-priority messages */
#define RS_HIPRI   1
// Options for `I_SRDOPT`
/** Byte-STREAM mode, the default */
#define RNORM   0
/** Message-discard mode */
#define RMSGD   1
/** Message-nondiscard mode */
#define RMSGN   2
/** Deliver the control part of a message as data */
#define RPROTDAT   4
/** Discard the control part of a message, delivering any data part */
#define RPROTDIS   8
/** Fail `read` with EBADMSG if a message containing a control part is at the front of the STREAM head read queue */
#define RPROTNORM   0x10
/** The RPROT bits */
#define RPROTMASK   0x1c
// Possible modes for `I_SWROPT`
/** Send a zero-length message downstream when a `write` of 0 bytes occurs */
#define SNDZERO   1
/** Send SIGPIPE on write and putmsg if sd_werror is set */
#define SNDPIPE   2
// Arguments for `I_ATMARK`
/** Check if the message is marked */
#define ANYMARK   1
/** Check if the message is the last one marked on the queue */
#define LASTMARK   2
/** Argument for `I_UNLINK`; Unlink all STREAMs linked to the STREAM associated with `fildes` */
#define MUXID_ALL   -1
/** Send/receive high priority message */
#define MSG_HIPRI   1
/** Receive any message */
#define MSG_ANY   2
/** Receive message from specified band */
#define MSG_BAND   4
/** More control information is left in message; returned by getmsg and getpmsg */
#define MORECTL   1
/** More data is left in message; returned by getmsg and getpmsg */
#define MOREDATA   2


/** Structure used for the I_FLUSHBAND ioctl on streams */
typedef struct attr_packed bandinfo {
	unsigned char bi_pri;
	int bi_flag;
} bandinfo_t;


typedef struct strbuf {
	int maxlen;  //!< Maximum buffer length
	int len;  //!< Length of data
	char* buf;  //!< Pointer to buffer
} strbuf_t;


typedef struct strpeek {
	struct strbuf ctlbuf, databuf;
	t_uscalar_t flags;  //!< UnixWare/Solaris compatibility
} strpeek_t;


typedef struct strfdinsert {
	struct strbuf ctlbuf, databuf;
	t_uscalar_t flags;  //!< UnixWare/Solaris compatibility
	int fildes, offset;
} strfdinsert_t;


typedef struct attr_packed strioctl {
	int ic_cmd, ic_timout, ic_len;
	char* ic_dp;
} strioctl_t;


typedef struct strrecvfd {
	int fd;
	uid_t uid;
	gid_t gid;
	char __fill[8];  //!< UnixWare/Solaris compatibility
} strrecvfd_t;


typedef struct str_mlist { char l_name[FMNAMESZ + 1]; }   str_mlist_t;


typedef struct str_list {
	const char* str;
	size_t len;
	struct str_list* next;
} str_list_t;


/* TODO: Add fcntl
// Test if the file-descriptor belongs to a stream
LIB_FUNC int isastream(const int fd) {
	return (int)((fcntl(fd, F_GETFD) < 0) ? -1 : 0);
}
int fattach(int, const char*);
int fdetach(const char*);
int getmsg(int, struct strbuf* restrict, struct strbuf* restrict, int* restrict);
int getpmsg(int, struct strbuf* restrict, struct strbuf* restrict, int* restrict, int* restrict);
int ioctl(int, int, ...);
int putmsg(int, const struct strbuf*, const struct strbuf*, int);
int putpmsg(int, const struct strbuf*, const struct strbuf*, int, int);
*/


#endif  // STROPTS_H


/* SYSCTL (<sysctl.h>) */


#if ((!(defined(SYS_SYSCTL_H) || defined(_SYS_SYSCTL_H) || defined(_SYS_SYSCTL_H_))) && (defined(OSPOSIX) || defined(OSUNIX)))
#define SYS_SYSCTL_H   (1)
#define _SYS_SYSCTL_H   (1)
#define _SYS_SYSCTL_H_   (1)


/** Unused */
#define CTL_UNSPEC   0
/** "High kernel": proc, limits */
#define CTL_KERN   1
/** Virtual memory */
#define CTL_VM   2
/** File system, mount type is next */
#define CTL_VFS   3
/** Network */
#define CTL_NET   4
/** Debugging parameters */
#define CTL_DEBUG   5
/** Generic CPU/IO */
#define CTL_HW   6
/** Machine dependent */
#define CTL_MACHDEP   7
/** User-level */
#define CTL_USER   8
/** In-kernel debugger */
#define CTL_DDB   9
/** Per-proc attr */
#define CTL_PROC   10
/** Vendor-specific data */
#define CTL_VENDOR   11
/** Emulation-specific data */
#define CTL_EMUL   12
/** Security */
#define CTL_SECURITY   13
/** Number of valid top-level ids */
#define CTL_MAXID   14
/** Largest number of components supported */
#define CTL_MAXNAME   12
/** Longest name allowed for a node */
#define SYSCTL_NAMELEN   32
/** Start of dynamic mib allocation */
#define CREATE_BASE   1024
/** Initial size of a child set */
#define SYSCTL_DEFSIZE   8

typedef struct attr_packed __sysctl_args {
	int* name;  //!< Name of the system parameter
	int nlen;  //!< Length of `name`
	void* oldval;  //!< Pointer to the previous value
	size_t* oldlenp;  //!< Pointer to the length of `oldval`
	void* newval;  //!< Pointer to the new value
	size_t newlen;  //!< Length of `newval`
	unsigned long unused[4];
} sysctl_arg_t;


/** Read/Write system parameters */
LIB_FUNC int sysctl(int* restrict name, const int nlen, void* restrict oldval, size_t* restrict oldlenp, void* restrict newval, const size_t newlen) {
	struct __sysctl_args ctl_args = {
		.name = name,
		.nlen = nlen,
		.oldval = oldval,
		.oldlenp = oldlenp,
		.newval = newval,
		.newlen = newlen
	};
	return (int)syscall2(SYS_sysctl, 1, (long)&ctl_args);
}


/** Read/Write system parameters */
LIB_FUNC int _sysctl(struct __sysctl_args* restrict ctl_args) {
	return (int)syscall2(SYS_sysctl, 1, (long)ctl_args);
}


#endif  // SYS_SYSCTL_H


/* STAT (<sys/stat.h>) */


#if (!(defined(_SYS_STAT_H) || defined(STAT_H) || defined(_BITS_STAT_STRUCT_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html
#define SYS_STAT_H   (1)
#define _SYS_STAT_H   (1)
#define _SYS_STAT_H_   (1)
#define STAT_H   (1)
#define _BITS_STAT_STRUCT_H   (1)


// Versions of the `struct stat` data structure
#ifndef _STAT_VER_LINUX_OLD
#   define _STAT_VER_LINUX_OLD   1
#endif
#ifndef _STAT_VER_KERNEL
#   define _STAT_VER_KERNEL   1
#endif
#ifndef _STAT_VER_SVR4
#   define _STAT_VER_SVR4   2
#endif
#ifndef _STAT_VER_LINUX
#   define _STAT_VER_LINUX   3
#endif
#if ((!defined(_STAT_VER)) && defined(OSLINUX))
#   define _STAT_VER   _STAT_VER_LINUX
#elif (!defined(_STAT_VER))
#   define _STAT_VER   _STAT_VER_SVR4
#endif
// Versions of the `xmknod` interface
#define _MKNOD_VER_LINUX   1
#define _MKNOD_VER_SVR4   2
#define _MKNOD_VER   _MKNOD_VER_LINUX


/** For 32-bit architectures, this struct is similar to `stat64`, but it uses 32-bit members along with 32-bit padding. For 64-bit architectures, this struct is exactly the same as `stat64` */
typedef struct stat {
#ifndef USE_FILE_OFFSET64
#   if IS_LITTLE_ENDIAN
	unsigned long st_dev;  //!< Device
	unsigned long __pad1;
	unsigned long st_ino;  //!< 32-bit file serial number
	unsigned long __pad2;
	unsigned int st_mode;  //!< File mode
	unsigned int st_nlink;  //!< Link count
	unsigned int st_uid;  //!< User ID of the file's owner
	unsigned int st_gid;  //!< Group ID of the file's group
	unsigned long st_rdev;  //!< Device number (if applicable)
	unsigned long __pad3;
	unsigned long long __pad4;
	long st_size;  //!< Size of file (in bytes)
	long __pad5;
	int st_blksize;  //!< Optimal block size for I/O
	int __pad6;
	long st_blocks;  //!< Number 512-byte blocks allocated
	long __pad7;
#   else
	unsigned long __pad1;
	unsigned long st_dev;  //!< Device
	unsigned long __pad2;
	unsigned long st_ino;  //!< 32-bit file serial number
	unsigned int st_mode;  //!< File mode
	unsigned int st_nlink;  //!< Link count
	unsigned int st_uid;  //!< User ID of the file's owner
	unsigned int st_gid;  //!< Group ID of the file's group
	unsigned long __pad3;
	unsigned long st_rdev;  //!< Device number (if applicable)
	unsigned long long __pad4;
	long __pad5;
	long st_size;  //!< Size of file (in bytes)
	int st_blksize;  //!< Optimal block size for I/O
	int __pad6;
	long __pad7;
	long st_blocks;  //!< Number 512-byte blocks allocated
#   endif  // LITTLE_ENDIAN
#else
	unsigned long long st_dev;  //!< Device
	unsigned long long st_ino;  //!< 32-bit file serial number
	unsigned int st_mode;  //!< File mode
	unsigned int st_nlink;  //!< Link count
	unsigned int st_uid;  //!< User ID of the file's owner
	unsigned int st_gid;  //!< Group ID of the file's group
	unsigned long long st_rdev;  //!< Device number (if applicable)
	unsigned long long _pad1;
	long long st_size;  //!< Size of file, in bytes
	int st_blksize;  //!< Optimal block size for I/O
	int __pad2;
	long long st_blocks;  //!< Number 512-byte blocks allocated
#endif
#ifdef __USE_MISC
#   ifndef USE_FILE_OFFSET64
	long st_atime;  //!< Time of last access
	unsigned long st_atime_nsec;
	long st_mtime;  //!< Time of last modification
	unsigned long st_mtime_nsec;
	long st_ctime;  //!< Time of last status change
	unsigned long st_ctime_nsec;
#   else
	int st_atime;  //!< Time of last access
	unsigned int st_atime_nsec;
	int st_mtime;  //!< Time of last modification
	unsigned int st_mtime_nsec;
	int st_ctime;  //!< Time of last status change
	unsigned int st_ctime_nsec;
#   endif
#else
	struct timespec st_atim;  //!< Time of last access
	struct timespec st_mtim;  //!< Time of last modification
	struct timespec st_ctim;  //!< Time of last status change
#   define st_atime   st_atim.tv_sec
#   define st_mtime   st_mtim.tv_sec
#   define st_ctime   st_ctim.tv_sec
#endif
	unsigned int __unused4, __unused5;
} stat_t;
#if SUPPORTS_LARGEFILE64  // stat64
typedef struct stat64 {
	unsigned long long st_dev;  //!< Device
	unsigned long long st_ino;  //!< 32-bit file serial number
	unsigned int st_mode;  //!< File mode
	unsigned int st_nlink;  //!< Link count
	unsigned int st_uid;  //!< User ID of the file's owner
	unsigned int st_gid;  //!< Group ID of the file's group
	unsigned long long st_rdev;  //!< Device number (if applicable)
	unsigned long long __pad3;
	long long st_size;  //!< Size of file (in bytes)
	int st_blksize;  //!< Optimal block size for I/O
	int __pad4;
	long long st_blocks;  //!< Number 512-byte blocks allocated
#   ifdef __USE_MISC
	int st_atime;  //!< Time of last access
	unsigned int st_atime_nsec;
	int st_mtime;  //!< Time of last modification
	unsigned int st_mtime_nsec;
	int st_ctime;  //!< Time of last status change
	unsigned int st_ctime_nsec;
#   else
	struct timespec st_atim;  //!< Time of last access
	struct timespec st_mtim;  //!< Time of last modification
	struct timespec st_ctim;  //!< Time of last status change
#   endif
	unsigned int __unused4, __unused5;
} stat64_t;
#   define kernel_stat64   stat64
#else
#   define kernel_stat64   stat
#   define stat64   stat
#endif  // stat64
// Tell code we have these members
#define _STATBUF_ST_BLKSIZE
#define _STATBUF_ST_RDEV
/** Nanosecond resolution time values are supported */
#define _STATBUF_ST_NSEC


static const UNUSED char* const mode_rwa[16] = {
	"r", "rb", "r+", "rb+", "r+b",
	"w", "wb", "w+", "wb+", "w+b",
	"a", "ab", "a+", "ab+", "a+b",
	NULL
};
static const UNUSED char* const mode_r[8] = { "r", "rb", "r+", "rb+", "r+b", NULL };
static const UNUSED char* const mode_w[8] = { "w", "wb", "w+", "wb+", "w+b", NULL };
static const UNUSED char* const mode_a[8] = { "a", "ab", "a+", "ab+", "a+b", NULL };


#if IS_WORDSIZE_32
/** Get information about the file `fd` in `buf` */
LIB_FUNC NONNULL int fxstat(const int vers, const int fd, struct stat* restrict buf) {
	if (vers == _STAT_VER_KERNEL) {
		return (int)syscall2(SYS_fstat64, fd, (long)buf);
	}
	set_errno(EINVAL);
	return -1;
}
#elif IS_WORDSIZE_64
/** Get information about the file `fd` in `buf` */
LIB_FUNC NONNULL int fxstat(const int vers, const int fd, struct stat* restrict buf) {
	if (vers == _STAT_VER_KERNEL || vers == _STAT_VER_LINUX) {
		return (int)syscall2(SYS_fstat, fd, (long)buf);
	}
	set_errno(EINVAL);
	return -1;
}
#   define fxstat64(vers, fd, buf)   fxstat((vers), (fd), (buf))
#   define _fxstat64(vers, fd, buf)   fxstat((vers), (fd), (buf))
#   define __fxstat64(vers, fd, buf)   fxstat((vers), (fd), (buf))
#endif
#define _fxstat(vers, fd, buf)   fxstat((vers), (fd), (buf))
#define __fxstat(vers, fd, buf)   fxstat((vers), (fd), (buf))


LIB_FUNC NONNULL int fstat(const int fd, struct stat* restrict buf) {
	return fxstat(_STAT_VER, fd, buf);
}


LIB_FUNC NONNULL int fstat64(const int fd, struct stat64* restrict buf) {
	return fxstat64(_STAT_VER, fd, buf);
}
#define fstat(f, _buf)   fstat64((f), (_buf))
#define __fstat(f, _buf)   fstat64((f), (_buf))


/** Get information about the file `name` in `buf` */
LIB_FUNC NONNULL int xstat64(const UNUSED int vers, const char* restrict name, struct stat64* restrict buf) {
	return (int)syscall2(SYS_stat, (long)name, (long)buf);
}
#define ___xstat64(vers, name, buf)   xstat64((vers), (name), (buf))
#define __xstat64(vers, name, buf)   xstat64((vers), (name), (buf))
#define __xstat(vers, name, buf)   xstat64((vers), (name), (buf))
#define xstat(vers, name, buf)   xstat64((vers), (name), (buf))


/** Get file information about `file` in `buf`; If `file` is a symbolic link, do not follow it */
LIB_FUNC NONNULL int lxstat64(const int vers, const char* restrict file, struct stat64* restrict buf) {
	return xstat64(vers, file, buf);
}
#define ___lxstat64(vers, name, buf)   lxstat64((vers), (name), (buf))
#define __lxstat64(vers, name, buf)   lxstat64((vers), (name), (buf))
#define __lxstat(vers, name, buf)   lxstat64((vers), (name), (buf))
#define lxstat(vers, name, buf)   lxstat64((vers), (name), (buf))


LIB_FUNC NONNULL int stat64(const char* restrict file, struct stat64* restrict buf) {
	return xstat64(_STAT_VER, file, buf);
}


LIB_FUNC NONNULL int lstat64(const char* restrict file, struct stat64* restrict buf) {
	return xstat64(_STAT_VER, file, buf);
}


/* TODO: Add sys/stat functions
int chmod(const char*, mode_t);
int fchmod(int, mode_t);
int fchmodat(int, const char*, mode_t, int);
int fstatat(int, const char* restrict, struct stat* restrict, int);
int futimens(int, const struct timespec[2]);
int lstat(const char* restrict, struct stat* restrict);
int mkdir(const char*, mode_t);
int mkdirat(int, const char*, mode_t);
int mkfifo(const char*, mode_t);
int mkfifoat(int, const char*, mode_t);
int mknod(const char*, mode_t, dev_t);
int mknodat(int, const char*, mode_t, dev_t);
int stat(const char* restrict, struct stat* restrict);
mode_t umask(mode_t);
int utimensat(int, const char*, const struct timespec[2], int);
*/


#endif  // SYS_STAT_H


/* PRE-TERMIOS TERMINAL IOCTLS DATATYPES (<ioctl.h>, <saioctl.h>, <ttycom.h>, <termios.h> & <bits/ioctl-types.h>) */


#if (!(defined(_IOCTL_TYPES_H) || defined(_IOCTL_TYPES_H_) || defined(_SYS_IOCTL_H) || defined(_SYS_IOCTL_H_) || defined(_SYS_TTYCOM_H_) || defined(TERMIOS_H) || defined(_TERMIOS_H_)))
#define IOCTL_TYPES_H   (1)
#define _IOCTL_TYPES_H   (1)
#define _IOCTL_TYPES_H_   (1)
#define BITS_IOCTLS_H   (1)
#define _BITS_IOCTLS_H   (1)
#define _BITS_IOCTLS_H_   (1)
#define __BITS_IOCTLS_H   (1)
#define __BITS_IOCTLS_H_   (1)
#define SYS_IOCTL_H   (1)
#define _SYS_IOCTL_H   (1)
#define _SYS_IOCTL_H_   (1)
#define _SYS_TTYCOM_H_   (1)
#define TERMIOS_H   (1)
#define _TERMIOS_H_   (1)


/** Modem lines */
enum MODEM_LINES {
#   ifdef ARCHMIPS
	TIOCM_LE = 1,
	TIOCM_DTR = 2,
	TIOCM_RTS = 4,
	TIOCM_ST = 0x10,
	TIOCM_SR = 0x20,
	TIOCM_CTS = 0x40,
	TIOCM_CAR = 0x100,
#      define TIOCM_CD   TIOCM_CAR
	TIOCM_RNG = 0x200,
#      define TIOCM_RI   TIOCM_RNG
	TIOCM_DSR = 0x400,
	TIOCM_OUT1 = 0x2000,
	TIOCM_OUT2 = 0x4000,
	TIOCM_LOOP = 0x8000
#   else
	TIOCM_LE = 1,
	TIOCM_DTR = 2,
	TIOCM_RTS = 4,
	TIOCM_ST = 8,
	TIOCM_SR = 0x10,
	TIOCM_CTS = 0x20,
	TIOCM_CAR = 0x40,
#      define TIOCM_CD   TIOCM_CAR
	TIOCM_RNG = 0x80,
#      define TIOCM_RI   TIOCM_RNG
	TIOCM_DSR = 0x100,
	TIOCM_OUT1 = 0x2000,
	TIOCM_OUT2 = 0x4000,
	TIOCM_LOOP = 0x8000
#   endif
};

/** `C_CC` CHARACTERS */
enum C_CC_CHARS {
#   ifdef ARCHALPHA
	VEOF = 0,
	VEOL = 1,
	VEOL2 = 2,
	VERASE = 3,
	VWERASE = 4,
	VKILL = 5,
	VREPRINT = 6,
	VSWTC = 7,
	VINTR = 8,
	VQUIT = 9,
	VSUSP = 10,
	VSTART = 12,
	VSTOP = 13,
	VLNEXT = 14,
	VDISCARD = 15,
	VMIN = 16,
	VTIME = 17
#   elif defined(ARCHMIPS)
	VINTR = 0,
	VQUIT = 1,
	VERASE = 2,
	VKILL = 3,
	VMIN = 4,
	VTIME = 5,
	VEOL2 = 6,
	VSWTC = 7,
#      define VSWTCH   VSWTC
	VSTART = 8,
	VSTOP = 9,
	VSUSP = 10,
	VREPRINT = 12,
	VDISCARD = 13,
	VWERASE = 14,
	VLNEXT = 15,
	VEOF = 16,
	VEOL = 17
#   elif defined(ARCHPOWERPC)
	VINTR = 0,
	VQUIT = 1,
	VERASE = 2,
	VKILL = 3,
	VEOF = 4,
	VMIN = 5,
	VEOL = 6,
	VTIME = 7,
	VEOL2 = 8,
	VSWTC = 9,
	VWERASE = 10,
	VREPRINT = 11,
	VSUSP = 12,
	VSTART = 13
	VSTOP = 14,
	VLNEXT = 15,
	VDISCARD = 16
#   elif defined(ARCHSPARC)
	VINTR = 0,
	VQUIT = 1,
	VERASE = 2,
	VKILL = 3,
	VEOF = 4,
	VEOL = 5,
	VEOL2 = 6,
	VSWTC = 7,
	VSTART = 8,
	VSTOP = 9,
	VSUSP = 10,
	VDSUSP = 11,
	VREPRINT = 12,
	VDISCARD = 13,
	VWERASE = 14,
	VLNEXT = 15,
#      define VMIN   VEOF
#      define VTIME   VEOL
#   else
	VINTR = 0,
	VQUIT = 1,
	VERASE = 2,
	VKILL = 3,
	VEOF = 4,
	VTIME = 5,
	VMIN = 6,
	VSWTC = 7,
	VSTART = 8,
	VSTOP = 9,
	VSUSP = 10,
	VEOL = 11,
	VREPRINT = 12,
	VDISCARD = 13,
	VWERASE = 14,
	VLNEXT = 15,
	VEOL2 = 16
#   endif
};

/** Line Disciplines */
enum LINE_DISCIPLINES {
	N_TTY = 0,
	N_SLIP = 1,
	N_MOUSE = 2,
	N_PPP = 3,
	N_STRIP = 4,
	N_AX25 = 5,
/** X.25 async */
	N_X25 = 6,
	N_6PACK = 7,
/** Reserved for Mobitex module */
	N_MASC = 8,
/** Reserved for Simatic R3964 module */
	N_R3964 = 9,
/** Reserved for Profibus */
	N_PROFIBUS_FDL = 10,
/** Linux IR */
	N_IRDA = 11,
/** SMS block mode; talking to GSM data cards about SMS messages */
	N_SMSBLOCK = 12,
/** Synchronous HDLC */
	N_HDLC = 13,
/** Synchronous PPP */
	N_SYNC_PPP = 14,
/** Bluetooth HCI UART */
	N_HCI = 15
};

/** `C_IFLAG` bits */
enum C_IFLAG_BITS {
	IGNBRK = 1,
	BRKINT = 2,
	IGNPAR = 4,
	PARMRK = 010,
	INPCK = 020,
	ISTRIP = 040,
	INLCR = 0100,
	IGNCR = 0200,
	ICRNL = 0400,
	IUCLC = 01000,
	IXON = 02000,
	IXANY = 04000,
	IXOFF = 010000,
	IMAXBEL = 020000,
	IUTF8 = 040000
};

// `C_OFLAG` BITS
#define OPOST   1
#define OLCUC   2
#define ONLCR   4
#define OCRNL   010
#define ONOCR   020
#define ONLRET   040
#define OFILL   0100
#define OFDEL   0200
#define NLDLY   0400
#define NL0   0
#define NL1   0400
#define CRDLY   03000
#define CR0   0
#define CR1   01000
#define CR2   02000
#define CR3   03000
#define TABDLY   014000
#define TAB0   0
#define TAB1   04000
#define TAB2   010000
#define TAB3   014000
#define XTABS   014000
#define BSDLY   020000
#define BS0   0
#define BS1   020000
#define VTDLY   040000
#define VT0   0
#define VT1   040000
#define FFDLY   0100000
#define FF0   0
#define FF1   0100000

// `C_CFLAG` BIT MEANING
#define CBAUD   010017
#define B0   0
#define B50   1
#define B75   2
#define B110   3
#define B134   4
#define B150   5
#define B200   6
#define B300   7
#define B600   010
#define B1200   011
#define B1800   012
#define B2400   013
#define B4800   014
#define B9600   015
#define B19200   016
#define B38400   017
#define EXTA   B19200
#define EXTB   B38400
#define CSIZE   060
#define CS5   0
#define CS6   020
#define CS7   040
#define CS8   060
#define CSTOPB   0100
#define CREAD   0200
#define PARENB   0400
#define PARODD   01000
#define HUPCL   02000
#define CLOCAL   04000
#define CBAUDEX   010000
#define B57600   010001
#define B115200   010002
#define B230400   010003
#define B460800   010004
#define B500000   010005
#define B576000   010006
#define B921600   010007
#define B1000000   010010
#define B1152000   010011
#define B1500000   010012
#define B2000000   010013
#define B2500000   010014
#define B3000000   010015
#define B3500000   010016
#define B4000000   010017
/** Input baud rate (not used) */
#define CIBAUD   002003600000
/** Mark or space (stick) parity */
#define CMSPAR   010000000000
/** Flow control */
#define CRTSCTS   020000000000

// `C_LFLAG` BITS
#if (defined(ARCHALPHA) || defined(ARCHPOWERPC))
#   define ISIG   0x80
#   define ICANON   0x100
#   define XCASE   0x4000
#   define ECHO   8
#   define ECHOE   2
#   define ECHOK   4
#   define ECHONL   0x10
#   define NOFLSH   0x80000000
#   define TOSTOP   0x400000
#   define ECHOCTL   0x40
#   define ECHOPRT   0x20
#   define ECHOKE   1
#   define FLUSHO   0x800000
#   define IEXTEN   0x400
#   define PENDIN   0x20000000
#else
#   define ISIG   1
#   define ICANON   2
#   define XCASE   4
#   define ECHO   010
#   define ECHOE   020
#   define ECHOK   040
#   define ECHONL   0100
#   define NOFLSH   0200
#   define ECHOCTL   01000
#   define ECHOPRT   02000
#   define ECHOKE   04000
#endif

// ACTION FLAGS
#ifdef ARCHMIPS
#   define IEXTEN   0400
#   define FLUSHO   020000
#   define TOSTOP   0100000
#   define TCSANOW   0x540e
/** The change occurs after all output written to a file-descriptor has been transmitted */
#   define TCSADRAIN   0x540f
/** The change occurs after all output written to the object referred by to a file-descriptor has been transmitted, and all input that has been received (but not read) will be discarded before the change is made */
#   define TCSAFLUSH   0x5410
#else
#   define TOSTOP   0400
#   define FLUSHO   010000
#   define IEXTEN   0100000
#   define TCSANOW   0
/** The change occurs after all output written to a file-descriptor has been transmitted */
#   define TCSADRAIN   1
/** The change occurs after all output written to the object referred to by a file-descriptor has been transmitted, and all input that has been received (but not read) will be discarded before the change is made */
#   define TCSAFLUSH   2
/** The values of the `c_cflag`, `c_ispeed`, and `c_ospeed` fields are ignored */
#   define TCSASOFT   0x10
#endif
#define PENDIN   040000
#define TCOOFF   0
#define TCOON   1
#define TCIOFF   2
#define TCION   3
/** Values for the `queue_selector` argument to `tcflush` */
enum QUEUE_SELECTOR {
/** Flushes data received but not read */
	TCIFLUSH = 0,
/** Flushes data written but not transmitted */
	TCOFLUSH = 1,
/** Flushes both unread received data and untransmitted written data */
	TCIOFLUSH = 2
};


/** Number of Control Characters */
#define NCC   8
struct attr_packed termio {
	uint16_t c_iflag;  //!< Input mode flags
	uint16_t c_oflag;  //!< Output mode flags
	uint16_t c_cflag;  //!< Control mode flags
	uint16_t c_lflag;  //!< Local mode flags
	unsigned char c_line;  //!< Line discipline
	unsigned char c_cc[NCC];  //!< Control characters
};


struct termios {
	tcflag_t c_iflag;  //!< Input mode flags
	tcflag_t c_oflag;  //!< Output mode flags
	tcflag_t c_cflag;  //!< Control mode flags
	tcflag_t c_lflag;  //!< Local mode flags
	cc_t c_line;  //!< Line discipline
#   if (defined(ARCHX86) || defined(ARCHARM) || defined(ARCHITANIUM) || defined(ARCHPARISC) || defined(ARCHS390))
#      define NCCS   19
	cc_t c_cc[NCCS];  //!< Control characters
#   elif defined(ARCHMIPS)
#      define NCCS   23
	cc_t c_cc[NCCS];  //!< Control characters
#   elif (defined(ARCHPOWERPC) || defined(ARCHALPHA))
#      define NCCS   19
	cc_t c_cc[NCCS];  //!< Control characters
	cc_t c_line;  //!< Line discipline
	speed_t c_ispeed;  //!< Input speed
	speed_t c_ospeed;  //!< Output speed
#   elif defined(ARCHSPARC)
#      define NCCS   17
	cc_t c_cc[NCCS];  //!< Control characters
#   else
#      error   "`struct termios` is undefined for the target architecture!"
#   endif
};


typedef enum __ioctl_dir {
	IOC_VOID = 0,  //!< No parameters
	IOC_OUT = 1,  //!< Data is written into the user's buffer
	IOC_IN = 2,  //!< Data is read from the user's buffer
	IOC_INOUT = 3
} ioctl_dir_t;


typedef enum __ioctl_datum { IOC_8, IOC_16, IOC_32, IOC_64 }   ioctl_datum_t;


typedef struct ioctl_pt {
	unsigned long com;
	void* data;
} ioctl_pt_t;


/** For /dev/ptm pty getting `ioctl()` `TIOCPTMGET` and `TIOCPTSNAME` */
typedef struct ptmget {
	int cfd, sfd;
	char cn[PATH_MAX];
	char sn[PATH_MAX];
} ptmget_t;


/** The maximum length of a line discipline's name */
#define TTLINEDNAMELEN   32
typedef char    linedn_t[TTLINEDNAMELEN];
/** Termios tty line discipline */
#define TTYDISC   0
/** Tablet discipline */
#define TABLDISC   3
/** Serial IP discipline */
#define SLIPDISC   4
/** PPP discipline */
#define PPPDISC   5
/** Metricom wireless IP discipline */
#define STRIPDISC   6
/** HDLC discipline */
#define HDLCDISC   9
/** Next I/O includes header */
#define SAIOHDR   25601
/** Next I/O checks data */
#define SAIOCHECK   25602
/** Next I/O checks header & data */
#define SAIOHCHECK   25603
/** Inhibit bad sector forwarding */
#define SAIONOBAD   25604
/** Enable bad sector forwarding */
#define SAIODOBAD   25605
/** Set limit to ecc correction, bits */
#define SAIOECCLIM   25606
/** Use standard ecc procedures */
#define SAIOECCUNL   25607
/** Set retry count for unit */
#define SAIORETRIES   25608
/** Get pointer to pack label */
#define SAIODEVDATA   25609
/** Set skip sector inhibit */
#define SAIOSSI   25610
/** Inhibit skip sector handling */
#define SAIONOSSI   25611
/** Is device skip sector type? */
#define SAIOSSDEV   25612
/** Enable/disable debugging */
#define SAIODEBUG   25613
/** Get bad-sector table */
#define SAIOGBADINFO   25614

/** @def _IOC
Construct an ioctl from constructed type plus other fields */
#ifdef ARCHX86
#   define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   0U
#   define _IOC_WRITE   1U
#   define _IOC_READ   2U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define TCGETS   0x5401
#   define TCSETS   0x5402
#   define TCSETSW   0x5403
#   define TCSETSF   0x5404
#   define TCGETA   0x5405
#   define TCSETA   0x5406
#   define TCSETAW   0x5407
#   define TCSETAF   0x5408
#   define TCSBRK   0x5409
#   define TCXONC   0x540a
#   define TCFLSH   0x540b
#   define TIOCEXCL   0x540c
#   define TIOCNXCL   0x540d
#   define TIOCSCTTY   0x540e
#   define TIOCGPGRP   0x540f
#   define TIOCSPGRP   0x5410
#   define TIOCOUTQ   0x5411
#   define TIOCSTI   0x5412
#   define TIOCGWINSZ   0x5413
#   define TIOCSWINSZ   0x5414
#   define TIOCMGET   0x5415
#   define TIOCMBIS   0x5416
#   define TIOCMBIC   0x5417
#   define TIOCMSET   0x5418
#   define TIOCGSOFTCAR   0x5419
#   define TIOCSSOFTCAR   0x541a
#   define FIONREAD   0x541b
#   define TIOCINQ   FIONREAD
#   define TIOCLINUX   0x541c
#   define TIOCCONS   0x541d
#   define TIOCGSERIAL   0x541e
#   define TIOCSSERIAL   0x541f
#   define TIOCPKT   0x5420
#   define FIONBIO   0x5421
#   define TIOCNOTTY   0x5422
#   define TIOCSETD   0x5423
#   define TIOCGETD   0x5424
#   define TCSBRKP   0x5425
#   define TIOCTTYGSTRUCT   0x5426
#   define TIOCSBRK   0x5427
#   define TIOCCBRK   0x5428
#   define TIOCGSID   0x5429
#   define TIOCGPTN   0x80045430
#   define TIOCSPTLCK   0x40045431
#   define TCGETX   0x5432
#   define TCSETX   0x5433
#   define TCSETXF   0x5434
#   define TCSETXW   0x5435
#   define FIONCLEX   0x5450
#   define FIOCLEX   0x5451
#   define FIOASYNC   0x5452
#   define TIOCSERCONFIG   0x5453
#   define TIOCSERGWILD   0x5454
#   define TIOCSERSWILD   0x5455
#   define TIOCGLCKTRMIOS   0x5456
#   define TIOCSLCKTRMIOS   0x5457
#   define TIOCSERGSTRUCT   0x5458
#   define TIOCSERGETLSR   0x5459
#   define TIOCSERGETMULTI   0x545a
#   define TIOCSERSETMULTI   0x545b
#   define TIOCMIWAIT   0x545c
#   define TIOCGICOUNT   0x545d
#   define TIOCGHAYESESP   0x545e
#   define TIOCSHAYESESP   0x545f
#   define FIOQSIZE   0x5460
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCSER_TEMT   1
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define FIOSETOWN   0x8901
#   define SIOCSPGRP   0x8902
#   define FIOGETOWN   0x8903
#   define SIOCGPGRP   0x8904
#   define SIOCATMARK   0x8905
#   define SIOCGSTAMP   0x8906
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#elif defined(ARCHAARCH64)
#   define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   0U
#   define _IOC_WRITE   1U
#   define _IOC_READ   2U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define TCGETS   0x5401
#   define TCSETS   0x5402
#   define TCSETSW   0x5403
#   define TCSETSF   0x5404
#   define TCGETA   0x5405
#   define TCSETA   0x5406
#   define TCSETAW   0x5407
#   define TCSETAF   0x5408
#   define TCSBRK   0x5409
#   define TCXONC   0x540a
#   define TCFLSH   0x540b
#   define TIOCEXCL   0x540c
#   define TIOCNXCL   0x540d
#   define TIOCSCTTY   0x540e
#   define TIOCGPGRP   0x540f
#   define TIOCSPGRP   0x5410
#   define TIOCOUTQ   0x5411
#   define TIOCSTI   0x5412
#   define TIOCGWINSZ   0x5413
#   define TIOCSWINSZ   0x5414
#   define TIOCMGET   0x5415
#   define TIOCMBIS   0x5416
#   define TIOCMBIC   0x5417
#   define TIOCMSET   0x5418
#   define TIOCGSOFTCAR   0x5419
#   define TIOCSSOFTCAR   0x541a
#   define FIONREAD   0x541b
#   define TIOCINQ   FIONREAD
#   define TIOCLINUX   0x541c
#   define TIOCCONS   0x541d
#   define TIOCGSERIAL   0x541e
#   define TIOCSSERIAL   0x541f
#   define TIOCPKT   0x5420
#   define FIONBIO   0x5421
#   define TIOCNOTTY   0x5422
#   define TIOCSETD   0x5423
#   define TIOCGETD   0x5424
#   define TCSBRKP   0x5425
#   define TIOCTTYGSTRUCT   0x5426
#   define TIOCSBRK   0x5427
#   define TIOCCBRK   0x5428
#   define TIOCGSID   0x5429
#   define TIOCGRS485   0x542e
#   define TIOCSRS485   0x542f
#   define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#   define TIOCSPTLCK   _IOW('T', 0x31, int)
#   define TIOCGDEV   _IOR('T', 0x32, unsigned int)
#   define TCGETX   0x5432
#   define TCSETX   0x5433
#   define TCSETXF   0x5434
#   define TCSETXW   0x5435
#   define TIOCSIG   0x40045436
#   define TIOCVHANGUP   0x5437
#   define TIOCGPKT   0x80045438
#   define TIOCGPTLCK   0x80045439
#   define TIOCGEXCL   0x80045440
#   define FIONCLEX   0x5450
#   define FIOCLEX   0x5451
#   define FIOASYNC   0x5452
#   define TIOCSERCONFIG   0x5453
#   define TIOCSERGWILD   0x5454
#   define TIOCSERSWILD   0x5455
#   define TIOCGLCKTRMIOS   0x5456
#   define TIOCSLCKTRMIOS   0x5457
#   define TIOCSERGSTRUCT   0x5458
#   define TIOCSERGETLSR   0x5459
#   define TIOCSERGETMULTI   0x545a
#   define TIOCSERSETMULTI   0x545b
#   define TIOCMIWAIT   0x545c
#   define TIOCGICOUNT   0x545d
#   define FIOQSIZE   0x5460
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCSER_TEMT   1
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define N_GIGASET_M101   16
#   define N_SLCAN   17
#   define N_PPS   18
#   define N_V253   19
#   define N_CAIF   20
#   define N_GSM0710   21
#   define N_TI_WL   22
#   define N_TRACESINK   23
#   define N_TRACEROUTER   24
#   define FIOSETOWN   0x8901
#   define SIOCSPGRP   0x8902
#   define FIOGETOWN   0x8903
#   define SIOCGPGRP   0x8904
#   define SIOCATMARK   0x8905
#   define SIOCGSTAMP   0x8906
#   define SIOCGSTAMPNS   0x8907
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#elif defined(ARCHMIPS)
#   define _IOC(a, b, c, d)   (((a) << 29) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   1U
#   define _IOC_READ   2U
#   define _IOC_WRITE   4U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define TCGETA   0x5401
#   define TCSETA   0x5402
#   define TCSETAW   0x5403
#   define TCSETAF   0x5404
#   define TCSBRK   0x5405
#   define TCXONC   0x5406
#   define TCFLSH   0x5407
#   define TCGETS   0x540d
#   define TCSETS   0x540e
#   define TCSETSW   0x540f
#   define TCSETSF   0x5410
#   define TIOCEXCL   0x740d
#   define TIOCNXCL   0x740e
#   define TIOCOUTQ   0x7472
#   define TIOCSTI   0x5472
#   define TIOCMGET   0x741d
#   define TIOCMBIS   0x741b
#   define TIOCMBIC   0x741c
#   define TIOCMSET   0x741d
#   define TIOCPKT   0x5470
#   define TIOCSWINSZ   _IOW('t', 103, struct winsize)
#   define TIOCGWINSZ   _IOR('t', 104, struct winsize)
#   define TIOCNOTTY   0x5471
#   define TIOCSETD   0x7401
#   define TIOCGETD   0x7400
#   define FIOCLEX   0x6601
#   define FIONCLEX   0x6602
#   define FIOASYNC   0x667d
#   define FIONBIO   0x667e
#   define FIOQSIZE   0x667f
#   define TIOCGLTC   0x7474
#   define TIOCSLTC   0x7475
#   define TIOCSPGRP   _IOW('t', 118, int)
#   define TIOCGPGRP   _IOR('t', 119, int)
#   define TIOCCONS   _IOW('t', 120, int)
#   define FIONREAD   0x467f
#   define TIOCINQ   FIONREAD
#   define TIOCGETP   0x7408
#   define TIOCSETP   0x7409
#   define TIOCSETN   0x740a
#   define TIOCSBRK   0x5427
#   define TIOCCBRK   0x5428
#   define TIOCGSID   0x7416
#   define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#   define TIOCSPTLCK   _IOW('T', 0x31, int)
#   define TIOCSCTTY   0x5480
#   define TIOCGSOFTCAR   0x5481
#   define TIOCSSOFTCAR   0x5482
#   define TIOCLINUX   0x5483
#   define TIOCGSERIAL   0x5484
#   define TIOCSSERIAL   0x5485
#   define TCSBRKP   0x5486
#   define TIOCSERCONFIG   0x5488
#   define TIOCSERGWILD   0x5489
#   define TIOCSERSWILD   0x548a
#   define TIOCGLCKTRMIOS   0x548b
#   define TIOCSLCKTRMIOS   0x548c
#   define TIOCSERGSTRUCT   0x548d
#   define TIOCSERGETLSR   0x548e
#   define TIOCSERGETMULTI   0x548f
#   define TIOCSERSETMULTI   0x5490
#   define TIOCMIWAIT   0x5491
#   define TIOCGICOUNT   0x5492
#   define TIOCGHAYESESP   0x5493
#   define TIOCSHAYESESP   0x5494
#   define TIOCTTYGSTRUCT   0x5426
#   define TCGETX   0x5432
#   define TCSETX   0x5433
#   define TCSETXF   0x5434
#   define TCSETXW   0x5435
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCSER_TEMT   1
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define FIOSETOWN   0x8901
#   define SIOCSPGRP   0x8902
#   define FIOGETOWN   0x8903
#   define SIOCGPGRP   0x8904
#   define SIOCATMARK   0x8905
#   define SIOCGSTAMP   0x8906
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#elif defined(ARCHPOWERPC)
#   define _IOC(a, b, c, d)   (((a) << 29) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   1U
#   define _IOC_WRITE   4U
#   define _IOC_READ   2U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define FIONCLEX   _IO('f', 2)
#   define FIOCLEX   _IO('f', 1)
#   define FIOASYNC   _IOW('f', 125, int)
#   define FIONBIO   _IOW('f', 126, int)
#   define FIONREAD   _IOR('f', 127, int)
#   define TIOCINQ   FIONREAD
#   define FIOQSIZE   _IOR('f', 128, char[8])
#   define TIOCGETP   _IOR('t', 8, char[6])
#   define TIOCSETP   _IOW('t', 9, char[6])
#   define TIOCSETN   _IOW('t', 10, char[6])
#   define TIOCSETC   _IOW('t', 17, char[6])
#   define TIOCGETC   _IOR('t', 18, char[6])
#   define TCGETS   _IOR('t', 19, char[44])
#   define TCSETS   _IOW('t', 20, char[44])
#   define TCSETSW   _IOW('t', 21, char[44])
#   define TCSETSF   _IOW('t', 22, char[44])
#   define TCGETA   _IOR('t', 23, char[20])
#   define TCSETA   _IOW('t', 24, char[20])
#   define TCSETAW   _IOW('t', 25, char[20])
#   define TCSETAF   _IOW('t', 28, char[20])
#   define TCSBRK   _IO('t', 29)
#   define TCXONC   _IO('t', 30)
#   define TCFLSH   _IO('t', 31)
#   define TIOCSWINSZ   _IOW('t', 103, char[8])
#   define TIOCGWINSZ   _IOR('t', 104, char[8])
#   define TIOCSTART   _IO('t', 110)
#   define TIOCSTOP   _IO('t', 111)
#   define TIOCOUTQ   _IOR('t', 115, int)
#   define TIOCGLTC   _IOR('t', 116, char[6])
#   define TIOCSLTC   _IOW('t', 117, char[6])
#   define TIOCSPGRP   _IOW('t', 118, int)
#   define TIOCGPGRP   _IOR('t', 119, int)
#   define TIOCEXCL   0x540c
#   define TIOCNXCL   0x540d
#   define TIOCSCTTY   0x540e
#   define TIOCSTI   0x5412
#   define TIOCMGET   0x5415
#   define TIOCMBIS   0x5416
#   define TIOCMBIC   0x5417
#   define TIOCMSET   0x5418
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCGSOFTCAR   0x5419
#   define TIOCSSOFTCAR   0x541a
#   define TIOCLINUX   0x541c
#   define TIOCCONS   0x541d
#   define TIOCGSERIAL   0x541e
#   define TIOCSSERIAL   0x541f
#   define TIOCPKT   0x5420
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCNOTTY   0x5422
#   define TIOCSETD   0x5423
#   define TIOCGETD   0x5424
#   define TCSBRKP   0x5425
#   define TIOCSBRK   0x5427
#   define TIOCCBRK   0x5428
#   define TIOCGSID   0x5429
#   define TIOCGRS485   0x542e
#   define TIOCSRS485   0x542f
#   define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#   define TIOCSPTLCK   _IOW('T', 0x31, int)
#   define TIOCGDEV   _IOR('T', 0x32, unsigned int)
#   define TIOCSIG   _IOW('T', 0x36, int)
#   define TIOCVHANGUP   0x5437
#   define TIOCSERCONFIG   0x5453
#   define TIOCSERGWILD   0x5454
#   define TIOCSERSWILD   0x5455
#   define TIOCGLCKTRMIOS   0x5456
#   define TIOCSLCKTRMIOS   0x5457
#   define TIOCSERGSTRUCT   0x5458
#   define TIOCSERGETLSR   0x5459
#   define TIOCSER_TEMT   1
#   define TIOCSERGETMULTI   0x545a
#   define TIOCSERSETMULTI   0x545b
#   define TIOCMIWAIT   0x545c
#   define TIOCGICOUNT   0x545d
#   define TIOCTTYGSTRUCT   0x5426
#   define TCGETX   0x5432
#   define TCSETX   0x5433
#   define TCSETXF   0x5434
#   define TCSETXW   0x5435
#   define TIOCGHAYESESP   0x545e
#   define TIOCSHAYESESP   0x545f
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define FIOSETOWN   0x8901
#   define SIOCSPGRP   0x8902
#   define FIOGETOWN   0x8903
#   define SIOCGPGRP   0x8904
#   define SIOCATMARK   0x8905
#   define SIOCGSTAMP   0x8906
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#elif defined(ARCHSUPERH)
#   define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   0U
#   define _IOC_WRITE   1U
#   define _IOC_READ   2U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define FIOCLEX   _IO('f',  1)
#   define FIONCLEX   _IO('f',  2)
#   define FIOASYNC   _IOW('f', 125, int)
#   define FIONBIO   _IOW('f', 126, int)
#   define FIONREAD   _IOR('f', 127, int)
#   define TIOCINQ   FIONREAD
#   define FIOQSIZE   _IOR('f', 128, char[8])
#   define TCGETA   _IOR('t', 23, char[18])
#   define TCSETA   _IOW('t', 24, char[18])
#   define TCSETAW   _IOW('t', 25, char[18])
#   define TCSETAF   _IOW('t', 28, char[18])
#   define TCSBRK   _IO('t', 29)
#   define TCXONC   _IO('t', 30)
#   define TCFLSH   _IO('t', 31)
#   define TIOCSWINSZ   _IOW('t', 103, char[8])
#   define TIOCGWINSZ   _IOR('t', 104, char[8])
#   define TIOCSTART   _IO('t',  110)
#   define TIOCSTOP   _IO('t',  111)
#   define TIOCOUTQ   _IOR('t', 115, int)
#   define TIOCSPGRP   _IOW('t', 118, int)
#   define TIOCGPGRP   _IOR('t', 119, int)
#   define TIOCEXCL   _IO('T', 12)
#   define TIOCNXCL   _IO('T', 13)
#   define TIOCSCTTY   _IO('T', 14)
#   define TIOCSTI   _IOW('T', 18, char)
#   define TIOCMGET   _IOR('T', 21, unsigned int)
#   define TIOCMBIS   _IOW('T', 22, unsigned int)
#   define TIOCMBIC   _IOW('T', 23, unsigned int)
#   define TIOCMSET   _IOW('T', 24, unsigned int)
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCGSOFTCAR   _IOR('T', 25, unsigned int)
#   define TIOCSSOFTCAR   _IOW('T', 26, unsigned int)
#   define TIOCLINUX   _IOW('T', 28, char)
#   define TIOCCONS   _IO('T',  29)
#   define TIOCGSERIAL   _IOR('T', 30, char[60])
#   define TIOCSSERIAL   _IOW('T', 31, char[60])
#   define TIOCPKT   _IOW('T', 32, int)
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCNOTTY   _IO('T',  34)
#   define TIOCSETD   _IOW('T', 35, int)
#   define TIOCGETD   _IOR('T', 36, int)
#   define TCSBRKP   _IOW('T', 37, int)
#   define TIOCSBRK   _IO('T',  39)
#   define TIOCCBRK   _IO('T',  40)
#   define TIOCGSID   _IOR('T', 41, int)
#   define TCGETS   _IO('T', 1)
#   define TCSETS   _IO('T', 2)
#   define TCSETSW   _IO('T', 3)
#   define TCSETSF   _IO('T', 4)
#   define TCGETS2   _IOR('T', 42, char[44])
#   define TCSETS2   _IOW('T', 43, char[44])
#   define TCSETSW2   _IOW('T', 44, char[44])
#   define TCSETSF2   _IOW('T', 45, char[44])
#   define TIOCGPTN   _IOR('T', 48, unsigned int)
#   define TIOCSPTLCK   _IOW('T', 49, int)
#   define TIOCGDEV   _IOR('T', 50, unsigned int)
#   define TIOCSIG   _IOW('T', 54, int)
#   define TIOCVHANGUP   _IO('T',  55)
#   define TIOCGPKT   _IOR('T', 56, int)
#   define TIOCGPTLCK   _IOR('T', 57, int)
#   define TIOCGEXCL   _IOR('T', 64, int)
#   define TIOCSERCONFIG   _IO('T',  83)
#   define TIOCSERGWILD   _IOR('T', 84, int)
#   define TIOCSERSWILD   _IOW('T', 85, int)
#   define TIOCGLCKTRMIOS   _IO('T',  86)
#   define TIOCSLCKTRMIOS   _IO('T',  87)
#   define TIOCSERGSTRUCT   _IOR('T', 88, char[216])
#   define TIOCSERGETLSR   _IOR('T', 89, unsigned int)
#   define TIOCSER_TEMT   1
#   define TIOCSERGETMULTI   _IOR('T', 90, char[168])
#   define TIOCSERSETMULTI   _IOW('T', 91, char[168])
#   define TIOCMIWAIT   _IO('T', 92)
#   define TIOCGICOUNT   _IO('T', 93)
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define FIOGETOWN   _IOR('f', 123, int)
#   define FIOSETOWN   _IOW('f', 124, int)
#   define SIOCATMARK   _IOR('s', 7, int)
#   define SIOCSPGRP   _IOW('s', 8, int)
#   define SIOCGPGRP   _IOW('s', 9, int)
#   define SIOCGSTAMP   _IOR('s', 100, char[8])
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#else
#   define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#   define _IOC_NONE   0U
#   define _IOC_WRITE   1U
#   define _IOC_READ   2U
#   define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#   define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#   define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#   define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#   define TCGETS   0x5401
#   define TCSETS   0x5402
#   define TCSETSW   0x5403
#   define TCSETSF   0x5404
#   define TCGETA   0x5405
#   define TCSETA   0x5406
#   define TCSETAW   0x5407
#   define TCSETAF   0x5408
#   define TCSBRK   0x5409
#   define TCXONC   0x540a
#   define TCFLSH   0x540b
#   define TIOCEXCL   0x540c
#   define TIOCNXCL   0x540d
#   define TIOCSCTTY   0x540e
#   define TIOCGPGRP   0x540f
#   define TIOCSPGRP   0x5410
#   define TIOCOUTQ   0x5411
#   define TIOCSTI   0x5412
#   define TIOCGWINSZ   0x5413
#   define TIOCSWINSZ   0x5414
#   define TIOCMGET   0x5415
#   define TIOCMBIS   0x5416
#   define TIOCMBIC   0x5417
#   define TIOCMSET   0x5418
#   define TIOCGSOFTCAR   0x5419
#   define TIOCSSOFTCAR   0x541a
#   define FIONREAD   0x541b
#   define TIOCINQ   FIONREAD
#   define TIOCLINUX   0x541c
#   define TIOCCONS   0x541d
#   define TIOCGSERIAL   0x541e
#   define TIOCSSERIAL   0x541f
#   define TIOCPKT   0x5420
#   define FIONBIO   0x5421
#   define TIOCNOTTY   0x5422
#   define TIOCSETD   0x5423
#   define TIOCGETD   0x5424
#   define TCSBRKP   0x5425
#   define TIOCTTYGSTRUCT   0x5426
#   define TIOCSBRK   0x5427
#   define TIOCCBRK   0x5428
#   define TIOCGSID   0x5429
#   define TIOCGPTN   0x80045430
#   define TIOCSPTLCK   0x40045431
#   define TCGETX   0x5432
#   define TCSETX   0x5433
#   define TCSETXF   0x5434
#   define TCSETXW   0x5435
#   define FIONCLEX   0x5450
#   define FIOCLEX   0x5451
#   define FIOASYNC   0x5452
#   define TIOCSERCONFIG   0x5453
#   define TIOCSERGWILD   0x5454
#   define TIOCSERSWILD   0x5455
#   define TIOCGLCKTRMIOS   0x5456
#   define TIOCSLCKTRMIOS   0x5457
#   define TIOCSERGSTRUCT   0x5458
#   define TIOCSERGETLSR   0x5459
#   define TIOCSERGETMULTI   0x545a
#   define TIOCSERSETMULTI   0x545b
#   define TIOCMIWAIT   0x545c
#   define TIOCGICOUNT   0x545d
#   define TIOCGHAYESESP   0x545e
#   define TIOCSHAYESESP   0x545f
#   define FIOQSIZE   0x5460
#   define TIOCPKT_DATA   0
#   define TIOCPKT_FLUSHREAD   1
#   define TIOCPKT_FLUSHWRITE   2
#   define TIOCPKT_STOP   4
#   define TIOCPKT_START   8
#   define TIOCPKT_NOSTOP   16
#   define TIOCPKT_DOSTOP   32
#   define TIOCPKT_IOCTL   64
#   define TIOCSER_TEMT   1
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#   define TIOCM_MODEM_BITS   TIOCM_OUT2
#   define N_TTY   0
#   define N_SLIP   1
#   define N_MOUSE   2
#   define N_PPP   3
#   define N_STRIP   4
#   define N_AX25   5
#   define N_X25   6
#   define N_6PACK   7
#   define N_MASC   8
#   define N_R3964   9
#   define N_PROFIBUS_FDL   10
#   define N_IRDA   11
#   define N_SMSBLOCK   12
#   define N_HDLC   13
#   define N_SYNC_PPP   14
#   define N_HCI   15
#   define FIOSETOWN   0x8901
#   define SIOCSPGRP   0x8902
#   define FIOGETOWN   0x8903
#   define SIOCGPGRP   0x8904
#   define SIOCATMARK   0x8905
#   define SIOCGSTAMP   0x8906
#   define SIOCADDRT   0x890b
#   define SIOCDELRT   0x890c
#   define SIOCRTMSG   0x890d
#   define SIOCGIFNAME   0x8910
#   define SIOCSIFLINK   0x8911
#   define SIOCGIFCONF   0x8912
#   define SIOCGIFFLAGS   0x8913
#   define SIOCSIFFLAGS   0x8914
#   define SIOCGIFADDR   0x8915
#   define SIOCSIFADDR   0x8916
#   define SIOCGIFDSTADDR   0x8917
#   define SIOCSIFDSTADDR   0x8918
#   define SIOCGIFBRDADDR   0x8919
#   define SIOCSIFBRDADDR   0x891a
#   define SIOCGIFNETMASK   0x891b
#   define SIOCSIFNETMASK   0x891c
#   define SIOCGIFMETRIC   0x891d
#   define SIOCSIFMETRIC   0x891e
#   define SIOCGIFMEM   0x891f
#   define SIOCSIFMEM   0x8920
#   define SIOCGIFMTU   0x8921
#   define SIOCSIFMTU   0x8922
#   define SIOCSIFHWADDR   0x8924
#   define SIOCGIFENCAP   0x8925
#   define SIOCSIFENCAP   0x8926
#   define SIOCGIFHWADDR   0x8927
#   define SIOCGIFSLAVE   0x8929
#   define SIOCSIFSLAVE   0x8930
#   define SIOCADDMULTI   0x8931
#   define SIOCDELMULTI   0x8932
#   define SIOCGIFINDEX   0x8933
#   define SIOGIFINDEX   SIOCGIFINDEX
#   define SIOCSIFPFLAGS   0x8934
#   define SIOCGIFPFLAGS   0x8935
#   define SIOCDIFADDR   0x8936
#   define SIOCSIFHWBROADCAST   0x8937
#   define SIOCGIFCOUNT   0x8938
#   define SIOCGIFBR   0x8940
#   define SIOCSIFBR   0x8941
#   define SIOCGIFTXQLEN   0x8942
#   define SIOCSIFTXQLEN   0x8943
#   define SIOCDARP   0x8953
#   define SIOCGARP   0x8954
#   define SIOCSARP   0x8955
#   define SIOCDRARP   0x8960
#   define SIOCGRARP   0x8961
#   define SIOCSRARP   0x8962
#   define SIOCGIFMAP   0x8970
#   define SIOCSIFMAP   0x8971
#   define SIOCADDDLCI   0x8980
#   define SIOCDELDLCI   0x8981
#   define SIOCDEVPRIVATE   0x89f0
#   define SIOCPROTOPRIVATE   0x89e0
#endif  // ARCH

#ifndef _IOC
#   define _IOC(inout, _group, num, type)   ((num) | ((((_group) - 'f') | ((type) | (inout) << 19) << 4) << 7))
#endif

/** Dissect an ioctl into its component fields */
#define _IOC_INOUT(request)   (((unsigned int)(request) >> 30) & IOC_INOUT)
#define _IOC_GROUP(request)   ('f' + (((unsigned int)(request) >> 7) & 0xf))
#define _IOC_COMMAND(request)   ((unsigned int)(request) & 0x7f)
#define _IOC_TYPE(request)   (((unsigned int)(request) >> 11) & 0x7ffff)
#define _IOC_NOTYPE(request)   ((unsigned int)(request) & 0x3ff)
/** Construct a type information field from the broken-out type and count fields */
#define _IOT(t0, c0, t1, c1, t2, c2)   ((c2) | (((c1) | ((c0) | ((t2) | ((t1) | (t0) << 2) << 2) << 5) << 5) << 3))
/** Dissect a type information field into the type and count fields */
#define _IOT_TYPE0(type)   (((unsigned int)(type) >> 17) & 3)
#define _IOT_TYPE1(type)   (((unsigned int)(type) >> 15) & 3)
#define _IOT_TYPE2(type)   (((unsigned int)(type) >> 13) & 3)
#define _IOT_COUNT0(type)   (((unsigned int)(type) >> 8) & 0x1f)
#define _IOT_COUNT1(type)   (((unsigned int)(type) >> 3) & 0x1f)
#define _IOT_COUNT2(type)   (((unsigned int)(type) >> 0) & 7)
/** Construct an ioctl from all the broken-out fields */
#define _IOCT(inout, _group, num, t0, c0, t1, c1, t2, c2)   _IOC((inout), (_group), (num), _IOT((t0), (c0), (t1), (c1), (t2), (c2)))
/** Construct an individual type field for TYPE */
#define _IOTS(type)   ((sizeof(type) == 8) ? IOC_64 : (enum __ioctl_datum)(sizeof(type) >> 1))
/** Construct a type information field for a single argument of the scalar TYPE */
#define _IOT_SIMPLE(type)   _IOT(_IOTS(type), 1, 0, 0, 0, 0)
#define _IOC_ENCODE_TYPE(typespec)   _IOC_ENCODE_TYPE_1(_IOTBASE_ ## typespec)
#define _IOC_ENCODE_TYPE_1(typespec)   _IOC_ENCODE_TYPE_2(typespec)
#define _IOC_ENCODE_TYPE_2(typespec)   _IOT_ ## typespec
#ifndef _IOIW
#   define _IOIW(g, n, t)   _IOC(IOC_VOID, (g), (n), _IOC_ENCODE_TYPE(t))
#endif
#define PTIOCNETBSD   _IOW('Z', 0, struct ioctl_pt)
#define PTIOCSUNOS   _IOW('Z', 1, struct ioctl_pt)
#define PTIOCSVR4   _IOW('Z', 2, struct ioctl_pt)
#define PTIOCLINUX   _IOW('Z', 3, struct ioctl_pt)
#define PTIOCFREEBSD   _IOW('Z', 4, struct ioctl_pt)
#define PTIOCOSF1   _IOW('Z', 5, struct ioctl_pt)
#define PTIOCULTRIX   _IOW('Z', 6, struct ioctl_pt)
#define PTIOCWIN32   _IOW('Z', 7, struct ioctl_pt)
#define TIOCGRANTPT   _IO('t', 71)
/** Hurd ioctl type field for tchars */
#define _IOT_tchars   _IOT(_IOTS(char), 6, 0, 0, 0, 0)
/** Hurd ioctl type field for ltchars */
#define _IOT_ltchars   _IOT(_IOTS(char), 6, 0, 0, 0, 0)
/** Hurd ioctl type field for sgttyb */
#define _IOT_sgttyb   _IOT(_IOTS(char), 4, _IOTS(short), 1, 0, 0)
/** Hurd ioctl type field for winsize */
#define _IOT_winsize   _IOT(_IOTS(unsigned short), 4, 0, 0, 0, 0)
#define _IOT_ttysize   _IOT_winsize

// Basic C Datatypes
#define _IOT_char   _IOT_SIMPLE(char)
#define _IOT_short   _IOT_SIMPLE(short)
#define _IOT_int   _IOT_SIMPLE(int)
#define _IOT_long   _IOT_SIMPLE(long)
#define _IOT_long_long   _IOT_SIMPLE(long long)
#define _IOT_int8_t   _IOT_SIMPLE(int8_t)
#define _IOT_uint8_t   _IOT_SIMPLE(uint8_t)
#define _IOT_int16_t   _IOT_SIMPLE(int16_t)
#define _IOT_uint16_t   _IOT_SIMPLE(uint16_t)
#define _IOT_int32_t   _IOT_SIMPLE(int32_t)
#define _IOT_uint32_t   _IOT_SIMPLE(uint32_t)
#define _IOT_int64_t   _IOT_SIMPLE(int64_t)
#define _IOT_uint64_t   _IOT_SIMPLE(uint64_t)
#define _IOT_size_t   _IOT_SIMPLE(size_t)
#define _IOT_ssize_t   _IOT_SIMPLE(ssize_t)

// Routing table calls
/** Add routing table entry */
#define SIOCADDRT   0x890b
/** Delete routing table entry */
#define SIOCDELRT   0x890c
/** Call to routing system */
#define SIOCRTMSG   0x890d

// Socket configuration controls
/** Get iface name */
#define SIOCGIFNAME   0x8910
/** Set iface channel */
#define SIOCSIFLINK   0x8911
/** Get iface list */
#define SIOCGIFCONF   0x8912
/** Get flags */
#define SIOCGIFFLAGS   0x8913
/** Set flags */
#define SIOCSIFFLAGS   0x8914
/** Get PA address */
#define SIOCGIFADDR   0x8915
/** Set PA address */
#define SIOCSIFADDR   0x8916
/** Get remote PA address */
#define SIOCGIFDSTADDR   0x8917
/** Set remote PA address */
#define SIOCSIFDSTADDR   0x8918
/** Get broadcast PA address */
#define SIOCGIFBRDADDR   0x8919
/** Set broadcast PA address */
#define SIOCSIFBRDADDR   0x891a
/** Get network PA mask */
#define SIOCGIFNETMASK   0x891b
/** Set network PA mask */
#define SIOCSIFNETMASK   0x891c
/** Get metric */
#define SIOCGIFMETRIC   0x891d
/** Set metric */
#define SIOCSIFMETRIC   0x891e
/** Get memory address (BSD) */
#define SIOCGIFMEM   0x891f
/** Set memory address (BSD) */
#define SIOCSIFMEM   0x8920
/** Get MTU size */
#define SIOCGIFMTU   0x8921
/** Set MTU size */
#define SIOCSIFMTU   0x8922
/** Set interface name */
#define SIOCSIFNAME   0x8923
/** Set hardware address */
#define SIOCSIFHWADDR   0x8924
/** Get/Set encapsulations */
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
/** Get hardware address */
#define SIOCGIFHWADDR   0x8927
/** Driver slaving support */
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
/** Multicast address lists */
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
/** name -> if_index mapping */
#define SIOCGIFINDEX   0x8933
/** misprint compatibility */
#define SIOGIFINDEX  SIOCGIFINDEX
/** Set/Get extended flags set */
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
/** Delete PA address */
#define SIOCDIFADDR   0x8936
/** Set hardware broadcast addr */
#define SIOCSIFHWBROADCAST   0x8937
/** Get number of devices */
#define SIOCGIFCOUNT   0x8938
/** Bridging support */
#define SIOCGIFBR   0x8940
/** Set bridging options */
#define SIOCSIFBR   0x8941
/** Get the tx queue length */
#define SIOCGIFTXQLEN   0x8942
/** Set the tx queue length */
#define SIOCSIFTXQLEN   0x8943

// ARP cache control calls
/** Delete ARP table entry */
#define SIOCDARP   0x8953
/** Get ARP table entry */
#define SIOCGARP   0x8954
/** Set ARP table entry */
#define SIOCSARP   0x8955

// RARP cache control calls
/** Delete RARP table entry */
#define SIOCDRARP   0x8960
/** Get RARP table entry */
#define SIOCGRARP   0x8961
/** Set RARP table entry */
#define SIOCSRARP   0x8962

// Driver configuration calls
/** Get device parameters */
#define SIOCGIFMAP   0x8970
/** Set device parameters */
#define SIOCSIFMAP   0x8971

// DLCI configuration calls
/** Create new DLCI device */
#define SIOCADDDLCI   0x8980
/** Delete DLCI device */
#define SIOCDELDLCI   0x8981

// Device private ioctl calls
/** These 16 ioctls are available to devices via the `do_ioctl()` device vector; Each device should include this file and redefine these names as their own */
#define SIOCDEVPRIVATE   0x89f0  // to 89ff
/** Protocol private */
#define SIOCPROTOPRIVATE   0x89e0  // to 89ef


#ifdef SYS_ioctl

/** Manipulates the underlying device parameters of special files */
LIB_FUNC int ioctl(const int fd, const int req, ...) {
	va_list ap;
	va_start(ap, req);
	void* arg = va_arg(ap, void*);
	va_end(ap);
	return (int)syscall3(SYS_ioctl, fd, req, (long)arg);
}
#define HAVE_IOCTL   1


/** Version of ioctl that retries after a signal is caught */
LIB_FUNC int xioctl(const int fd, const int request, char* restrict arg) {
	register int i = 0;
	while ((i = ioctl(fd, request, arg)) == -1 && eq_errno(EINTR));
	return i;
}

#endif


/** Get the parameters associated with the terminal */
LIB_FUNC int tcgetattr(const int fildes, struct termios* restrict termios_p) {
	return ioctl(fildes, TCGETS, termios_p);
}


/** Set the parameters associated with the terminal */
LIB_FUNC int tcsetattr(const int fd, const int act, const struct termios* restrict tio) {
	if ((act < 0) || (act > 2)) {
		set_errno(EINVAL);
		return -1;
	}
	return ioctl(fd, (int)(TCSETS + act), tio);
}


/** Test whether a file descriptor refers to a terminal */
LIB_FUNC int isatty(const int fd) {
	register const int sverrno = get_errno();
	struct termios term = { 0 };
	register const int is_tty = (ioctl(fd, TCGETS, &term) == 0);
	set_errno(sverrno);
	return is_tty;
}


#endif  // IOCTL_TYPES_H


/* FILE CONTROL (<fcntl.h>) */


#if (!(defined(FCNTL_H) || defined(_FCNTL_H) || defined(_FCNTL_H_) || defined(_INC_FCNTL)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html
#define FCNTL_H   (1)
#define _FCNTL_H   (1)
#define _FCNTL_H_   (1)
#define _INC_FCNTL   (1)
#define _LIBC_FCNTL_H_   (1)


typedef struct f_owner_ex { int type; pid_t pid; }   f_owner_ex_t;
typedef struct attr_packed Radvisory { int64_t Offset; int32_t Count; }   Radvisory_t;
typedef struct attr_packed Log2phys { uint32_t Flags; int64_t Contigbytes, Devoffset; }   Log2phys_t;

typedef struct Fstore {
	uint32_t Flags;
	int32_t Posmode;
	int64_t Offset, Length, Bytesalloc;
} Fstore_t;


/** Manipulate file descriptor */
LIB_FUNC int fcntl64(const int fd, const int cmd, ...) {
	va_list list;
	va_start(list, cmd);
	long arg = va_arg(list, long);
	va_end(list);
	return (int)syscall3(SYS_fcntl64, fd, cmd, arg);
}


/** Manipulate file descriptor */
LIB_FUNC int __fcntl(const int fd, const int cmd, ...) {
	va_list ap;
	va_start(ap, cmd);
	void* arg = va_arg(ap, void*);
	va_end(ap);
	return fcntl64(fd, cmd, arg);
}


/** Manipulate file descriptor */
LIB_FUNC int fcntl(const int fd, const int cmd, ...) {
	va_list ap;
	va_start(ap, cmd);
	unsigned long arg = va_arg(ap, unsigned long);
	va_end(ap);
	if (cmd == F_SETFL) { arg |= O_LARGEFILE; }
	if (cmd == F_SETLKW) { return (int)syscall3(SYS_fcntl, (long)fd, (long)cmd, (long)arg); }
	else if (cmd == F_GETOWN) {
		struct f_owner_ex ex = { 0 };
		int ret = (int)syscall3(SYS_fcntl, (long)fd, F_GETOWN_EX, (long)&ex);
		if (eq_errno(EINVAL)) { return (int)syscall3(SYS_fcntl, (long)fd, (long)cmd, (long)arg); }
		else if (ret) { return ret; }
		else { return (int)((ex.type == F_OWNER_PGRP) ? -ex.pid : ex.pid); }
	} else if (cmd == F_DUPFD_CLOEXEC) {
		int ret = (int)syscall3(SYS_fcntl, (long)fd, F_DUPFD_CLOEXEC, (long)arg);
		if (neq_errno(EINVAL)) {
			if (ret >= 0) { syscall3(SYS_fcntl, (long)ret, F_SETFD, FD_CLOEXEC); }
			return ret;
		}
		ret = (int)syscall3(SYS_fcntl, (long)fd, F_DUPFD_CLOEXEC, 0);
		if (neq_errno(EINVAL)) {
			if (ret >= 0) { syscall1(SYS_close, ret); }
			set_errno(EINVAL);
			return -1;
		}
		ret = (int)syscall3(SYS_fcntl, (long)fd, F_DUPFD, (long)arg);
		if (ret >= 0) { syscall3(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC); }
		return ret;
	}
	switch (cmd) {
		case F_SETLK:
		case F_GETLK:
		case F_GETOWN_EX:
		case F_SETOWN_EX:
			return (int)syscall3(SYS_fcntl, (long)fd, (long)cmd, (long)arg);
		default:
			return (int)syscall3(SYS_fcntl, (long)fd, (long)cmd, (long)arg);
	}
	UNREACHABLE
}


/** Preallocate space to a file */
LIB_FUNC int fallocate(const int fd, const int mode, const off_t base, const off_t len) {
	return (int)syscall4(SYS_fallocate, (long)fd, (long)mode, (long)base, (long)len);
}
#define fallocate64(fd, mode, base, len)   fallocate((fd), (mode), (base), (len))


/** Preallocate space to a file */
LIB_FUNC int posix_fallocate(const int fd, const off_t base, const off_t len) {
	const int sverrno = get_errno();
	register int ret = (int)syscall4(SYS_fallocate, (long)fd, (long)0, (long)base, (long)len);
	if (ret == -1) {
		ret = get_errno();
		set_errno(sverrno);
		return ret;
	}
	set_errno(sverrno);
	return 0;
}
#define posix_fallocate64(fd, base, len)   fallocate((fd), (base), (len))


/** Perform file readahead into page cache */
LIB_FUNC ssize_t readahead(const int fd, const off_t pos, const size_t len) {
	return (ssize_t)syscall3(SYS_readahead, (long)fd, (long)pos, (long)len);
}


/** Sync a file segment with disk */
LIB_FUNC int sync_file_range(const int fd, const off_t pos, const off_t len, const unsigned int flags) {
#   ifdef SYS_sync_file_range2
	return (int)syscall4(SYS_sync_file_range2, (long)fd, (long)flags, (long)pos, (long)len);
#   elif defined(SYS_sync_file_range)
	return (int)syscall4(SYS_sync_file_range, (long)fd, (long)pos, (long)len, (long)flags);
#   else
	set_errno(ENOSYS);
	return -1;
#   endif
}


/** Splice user pages into a pipe */
LIB_FUNC ssize_t vmsplice(const int fd, const struct iovec* restrict iov, const size_t cnt, const unsigned int flags) {
	return (ssize_t)syscall4(SYS_vmsplice, fd, (long)iov, (long)cnt, flags);
}


/** Splice data to/from a pipe */
LIB_FUNC ssize_t splice(const int fd_in, const off_t* restrict off_in, const int fd_out, const off_t* restrict off_out, const size_t len, const unsigned int flags) {
	return (ssize_t)syscall6(SYS_splice, (long)fd_in, (long)off_in, (long)fd_out, (long)off_out, (long)len, flags);
}


/** Duplicating pipe content */
LIB_FUNC ssize_t tee(const int src, const int dest, const size_t len, const unsigned int flags) {
	return (ssize_t)syscall4(SYS_tee, src, dest, (long)len, (long)flags);
}


/** Open and possibly create a file */
LIB_FUNC int open(const char* restrict filename, const int flags, ...) {
	register mode_t mode = 0;
	if ((flags & O_CREAT) || (flags & O_TMPFILE) == O_TMPFILE) {
		va_list ap;
		va_start(ap, flags);
		mode = va_arg(ap, mode_t);
		va_end(ap);
	}
	register const int fd = (int)syscall3(SYS_open, (long)filename, (long)flags, (long)mode);
	if (fd >= 0 && (flags & O_CLOEXEC)) {
		syscall3(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
		return fd;
	} else { return -1; }
}
#define _open(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))
#define __open(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))
#define open64(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))


/** Open and possibly create a file */
LIB_FUNC int openat(const int fd, const char* restrict filename, const int flags, ...) {
	register mode_t mode = 0;
	if ((flags & O_CREAT) || (flags & O_TMPFILE) == O_TMPFILE) {
		va_list ap;
		va_start(ap, flags);
		mode = va_arg(ap, mode_t);
		va_end(ap);
	}
	return (int)syscall4(SYS_openat, (long)fd, (long)filename, (long)(flags | O_LARGEFILE), (long)mode);
}
#define _openat(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))
#define __openat(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))
#define openat64(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))


/** Open and possibly create a file */
LIB_FUNC int creat(const char* restrict filename, const mode_t mode) {
	return (int)open(filename, (int)(O_CREAT | O_WRONLY | O_TRUNC), mode);
}
#define _creat(filename, mode)   creat((filename), (mode))
#define creat64(filename, mode)   creat((filename), (mode))


/** Predeclare an access pattern for file data */
LIB_FUNC int posix_fadvise(const int fd, const off_t base, const off_t len, const int advice) {
	const int sverrno = get_errno();
	register int ret = (int)syscall4(SYS_fadvise, (long)fd, (long)base, (long)len, (long)advice);
	if (ret == -1) {
		ret = get_errno();
		set_errno(sverrno);
		return ret;
	}
	set_errno(sverrno);
	return 0;
}
#define _fadvise(fd, base, len, advice)   posix_fadvise((fd), (base), (len), (advice))
#define posix_fadvise64(fd, base, len, advice)   posix_fadvise((fd), (base), (len), (advice))


#endif  // FCNTL_H


/* LOCALIZATION (<locale.h> and <xlocale.h>) */


#if (!(defined(LOCALE_H) || defined(_LOCALE_H) || defined(_LOCALE_H_) || defined(_UCLIBC_LOCALE_H) || defined(_XLOCALE_H) || defined(_BITS_LOCALE_H)))  // http://www.cplusplus.com/reference/clocale/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/locale.h.html
#define LOCALE_H   (1)
#define _LOCALE_H   (1)
#define _LOCALE_H_   (1)
#define _UCLIBC_LOCALE_H   (1)
#define _UCLIBC_LOCALE_H_   (1)
#define __PDCLIB_LOCALE_H   (1)
#define __PDCLIB_LOCALE_H_   (1)
#define XLOCALE_H   (1)
#define _XLOCALE_H   (1)
#define _XLOCALE_H_   (1)
#define _BITS_LOCALE_H   (1)  // <bits/locale.h>


// These are the bits that can be set in the CATEGORY_MASK argument for `newlocale`
#define LC_CTYPE_MASK   (1 << __LC_CTYPE)
#define LC_NUMERIC_MASK   (1 << __LC_NUMERIC)
#define LC_TIME_MASK   (1 << __LC_TIME)
#define LC_COLLATE_MASK   (1 << __LC_COLLATE)
#define LC_MONETARY_MASK   (1 << __LC_MONETARY)
#define LC_MESSAGES_MASK   (1 << __LC_MESSAGES)
#ifdef LC_PAPER
#   define LC_PAPER_MASK   (1 << __LC_PAPER)
#   define LC_NAME_MASK   (1 << __LC_NAME)
#   define LC_ADDRESS_MASK   (1 << __LC_ADDRESS)
#   define LC_TELEPHONE_MASK   (1 << __LC_TELEPHONE)
#   define LC_MEASUREMENT_MASK   (1 << __LC_MEASUREMENT)
#   define LC_IDENTIFICATION_MASK   (1 << __LC_IDENTIFICATION)
#   define LC_ALL_MASK   (LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK | LC_PAPER_MASK | LC_NAME_MASK | LC_ADDRESS_MASK | LC_TELEPHONE_MASK | LC_MEASUREMENT_MASK | LC_IDENTIFICATION_MASK)
#else  // LC_PAPER
#   define LC_ALL_MASK    (LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK)
#endif  // LC_PAPER
#define LOCALE_STRING_SIZE   14
/** Special weight constant for the collation data */
#define IGNORE_CHAR   2
#define MAX_USAGE_COUNT   (UINT_MAX - 1)
#define UNDELETABLE   UINT_MAX
#define LOCFILE_ALIGN   BYTES_PER_INT
#define LOCFILE_ALIGN_MASK   (LOCFILE_ALIGN - 1)
#define LOCFILE_ALIGN_UP(x)   (((x) + (LOCFILE_ALIGN_MASK)) & (~(LOCFILE_ALIGN_MASK)))
#define LOCFILE_ALIGNED_P(x)   (((x) & (LOCFILE_ALIGN_MASK)) == 0)
/** This value can be passed to `uselocale` and may be returned by it; Passing this value to any other function has undefined behavior */
#define LC_GLOBAL_LOCALE   ((__locale_t)-1L)
#define __LOCALE_PARAM   , __locale_t locale_arg
#define __LOCALE_ARG   , locale_arg
#define __LOCALE_PTR   locale_arg
#define NMBSTATET   10
/** Magic number at the beginning of a locale data file for CATEGORY */
#define LIMAGIC(category)   (category == LC_COLLATE ? ((unsigned int)(0x20051014 ^ (category))) : category == LC_CTYPE ? ((unsigned int)(0x20090720 ^ (category))) : ((unsigned int)(0x20031115 ^ (category))))
// Definitions for `era` information from LC_TIME
#define ERA_NAME_FORMAT_MEMBERS   (4)
#define ERA_M_NAME   (0)
#define ERA_M_FORMAT   (1)
#define ERA_W_NAME   (2)
#define ERA_W_FORMAT   (3)
#define _LOCALE_METHOD_TSS   't'
#define _LOCALE_METHOD_THREAD_LOCAL   'T'
#ifndef _LOCALE_METHOD
#   define _LOCALE_METHOD   't'
#endif
#define MB_CUR_MAX   (5)
#define __ctype_get_mb_cur_max()   ((size_t)5)
#define LOCALE_NAME_MAX   15


/** Structure to access `era` information from LC_TIME */
typedef struct attr_packed era_entry {
	uint32_t direction;  //!< Contains '+' or '-'
	int32_t offset;
	int32_t start_date[3];
	int32_t stop_date[3];
	const char* era_name;
	const char* era_format;
	const wchar_t* era_wname;
	const wchar_t* era_wformat;
	int absolute_direction;  //!< `+1` indicates that year number is higher in the future (like A.D.); `-1` indicates that year number is higher in the past (like B.C.)
} era_entry_t;


/** Structure caching computed data about information from LC_TIME; The `private.time` member of `struct __locale_data` points to this */
typedef struct attr_packed lc_time_data {
	struct era_entry* eras;
	size_t num_eras;
	int era_initialized;
	const char** alt_digits;
	const wchar_t** walt_digits;
	int alt_digits_initialized, walt_digits_initialized;
} lc_time_data_t;


struct __locale_map {
	const void* map;
	size_t map_size;
	char name[LOCALE_NAME_MAX + 1];
	const struct __locale_map* next;
};


// LOCALE FUNCTIONS


LIB_FUNC const char* __lctrans(const char* restrict msg, const UNUSED int cat, const UNUSED locale_t loc) {
	return msg;
}
#define lctrans(msg, cat, loc)   __lctrans((msg), (cat), (loc))
#define LCTRANS(msg, cat, loc)   __lctrans((msg), (cat), (loc))


LIB_FUNC const char* __lctrans_cur(const char* restrict msg) {
	return msg;
}
#define lctrans_cur(msg)   __lctrans_cur((msg))
#define LCTRANS_CUR(msg)   __lctrans_cur((msg))


/** Return the numeric/monetary information for the current locale */
LIB_FUNC struct lconv* localeconv(void) {
	return &locale_table;
}


/** Charset name normalization */
LIB_FUNC void strip(char* restrict wp, const char* restrict s) {
	register int slash_count = 0;
	while (*s != '\0') {
		if (isalnum_l(*s, current_locale_ptr) || *s == '_' || *s == '-' || *s == '.' || *s == ',' || *s == ':') { *wp++ = (char)toupper_l(*s, current_locale_ptr); }
		else if (*s == '/') { if (++slash_count == 3) { break; } else { *wp++ = '/'; } }
		++s;
	}
	while (slash_count++ < 2) { *wp++ = '/'; }
	*wp = '\0';
}


LIB_FUNC ATTR_NONNULL(1) char* upstr(char* restrict dst, const char* restrict str) {
	char* restrict cp = dst;
	while ((*cp = (char)toupper_l(*str, current_locale_ptr)) != '\0') { ++cp; ++str; };
	return dst;
}


/** Return a pointer to the current locale */
LIB_FUNC locale_t locale_ptr(locale_t loc) {
	NORMALIZE_LOCALE(loc);
	return loc;
}


/** Set and/or return the current locale */
LIB_FUNC const char* setlocale(const UNUSED int __category, const char* restrict __locale) {
	lc_ctype = CT_8BIT;
	if (PREDICT_LIKELY(__locale && (__category == LC_ALL || __category == LC_CTYPE))) {
		if (!*__locale) {
			const char* x = getenv("LC_CTYPE");
			if (!x) { x = getenv("LC_ALL"); }
			if (!x) { x = "C"; }
			__locale = x;
		}
	}
	if (__locale) {
		if (strstr(__locale, ".UTF-8") || strstr(__locale, ".UTF8")) { lc_ctype = CT_UTF8; }
		if (__locale[0] != 'C' || __locale[1]) { return (const char*)0; }
	}
	return (const char*)"C";
}


/** Test if the current locale is UTF8 */
LIB_FUNC int islocale_utf8(void) {
	const char* restrict __locale = getenv("LANG");
	if ((!__locale) && (strstr(__locale, ".UTF8") || strstr(__locale, ".UTF-8"))) { return 1; }
	__locale = getenv("LC_ALL");
	if ((!__locale) && (strstr(__locale, ".UTF8") || strstr(__locale, ".UTF-8"))) { return 1; }
	return 0;
}


/** Test if the current locale is UTF8 */
LIB_FUNC int islocale_utf32(void) {
	const char* restrict __locale = getenv("LANG");
	if ((!__locale) && (strstr(__locale, ".UTF32") || strstr(__locale, ".UTF-32"))) { return 1; }
	__locale = getenv("LC_ALL");
	if ((!__locale) && (strstr(__locale, ".UTF32") || strstr(__locale, ".UTF-32"))) { return 1; }
	return 0;
}


LIB_FUNC int alias_compare(const struct alias_map* restrict map1, const struct alias_map* restrict map2) {
	if (map1->alias == map2->alias) { return 0; }
	const unsigned char* p1 = (const unsigned char*)map1->alias;
	const unsigned char* p2 = (const unsigned char*)map2->alias;
	register unsigned char c1, c2;
	do {
		c1 = (unsigned char)(((0x40 < *p1) && (*p1 < 0x5b)) ? (*p1 + 0x20) : *p1);
		c2 = (unsigned char)(((0x40 < *p2) && (*p2 < 0x5b)) ? (*p2 + 0x20) : *p2);
		if (c1 == '\0') { break; }
		++p1;
		++p2;
	} while (c1 == c2);
	return (int)(c1 - c2);
}


/* TODO: Add locale functions
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char*, locale_t);
locale_t uselocale(locale_t);
*/


#endif  // LOCALE_H


/* LANGUAGE INFORMATION CONSTANTS (<langinfo.h> & <nl_types.h>) */


#if (!(defined(NL_TYPES_H) || defined(_NL_TYPES_H) || defined(_NL_TYPES_H_) || defined(_LANGINFO_H) || defined(_LANGINFO_H_) || defined(_POSIX_LANGINFO_H) || defined(_LIBC_LANGINFO_H_)))  //  http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/nl_types.h.html & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html
#define NL_TYPES_H   (1)
#define _NL_TYPES_H   (1)
#define _NL_TYPES_H_   (1)
#define _LIBC_NL_TYPES_H_   (1)
#define LANGINFO_H   (1)
#define _LANGINFO_H   (1)
#define _LANGINFO_H_   (1)
#define _POSIX_LANGINFO_H   (1)
#define _POSIX_LANGINFO_H_   (1)
#define _LIBC_LANGINFO_H_   (1)


/** The default message set used by the gencat program */
#define NL_SETD   (1)
/** Value for FLAG parameter of `catgets` to set XPG4 compliance */
#define NL_CAT_LOCALE   (1)
/** Construct an `nl_item` value for `nl_langinfo` from a locale category (LC_*) and an item index within the category; Some code may depend on the item values within a category increasing monotonically with the indices */
#define _NL_ITEM(category, index)   (((category) << 0x10) | (index))
/** Extract the category and item index from a constructed `nl_item` value */
#define _NL_ITEM_CATEGORY(item)   ((int)(item) >> 0x10)
/** Extract the category and item index from a constructed `nl_item` value */
#define _NL_ITEM_INDEX(item)   ((int)(item) & UINT16_MAX)
// The abbreviated seven days of the week
/** Sunday */
#define ABDAY_1   0x20000
#define ABDAY_2   0x20001
#define ABDAY_3   0x20002
#define ABDAY_4   0x20003
#define ABDAY_5   0x20004
#define ABDAY_6   0x20005
#define ABDAY_7   0x20006
// The seven days of the week
/** Sunday */
#define DAY_1   0x20007
/** Monday */
#define DAY_2   0x20008
/** Tuesday */
#define DAY_3   0x20009
/** Wednesday */
#define DAY_4   0x2000a
/** Thursday */
#define DAY_5   0x2000b
/** Friday */
#define DAY_6   0x2000c
/** Saturday */
#define DAY_7   0x2000d
// The abbreviated twelve months
/** Jan */
#define ABMON_1   0x2000e
#define ABMON_2   0x2000f
#define ABMON_3   0x20010
#define ABMON_4   0x20011
#define ABMON_5   0x20012
#define ABMON_6   0x20013
#define ABMON_7   0x20014
#define ABMON_8   0x20015
#define ABMON_9   0x20016
#define ABMON_10   0x20017
#define ABMON_11   0x20018
/** Dec */
#define ABMON_12   0x20019
// The full names of the twelve months
/** January */
#define MON_1   0x2001a
#define MON_2   0x2001b
/** March */
#define MON_3   0x2001c
/** April */
#define MON_4   0x2001d
/** May */
#define MON_5   0x2001e
/** June */
#define MON_6   0x2001f
/** July */
#define MON_7   0x20020
#define MON_8   0x20021
#define MON_9   0x20022
#define MON_10   0x20023
#define MON_11   0x20024
/** December */
#define MON_12   0x20025
// Format date and time
/** AM string */
#define AM_STR   0x20026
/** PM string */
#define PM_STR   0x20027
/** String for formatting date and time */
#define D_T_FMT   0x20028
/** Date format */
#define D_FMT   0x20029
/** Time format */
#define T_FMT   0x2002a
/** AM or PM time format string */
#define T_FMT_AMPM   0x2002b
/** Era description segments */
#define ERA   0x2002c
#define ERA_D_FMT   0x2002e
/** Alternative symbols for digits */
#define ALT_DIGITS   0x2002f
#define ERA_D_T_FMT   0x20030
#define ERA_T_FMT   0x20031
/** Codeset name */
#define CODESET   14
/** Currency symbol */
#define CRNCYSTR   0x4000f
/** Radix character */
#define RADIXCHAR   0x10000
/** Separator for thousand */
#define THOUSEP   0x10001
#define YESEXPR   0x50000
#define NOEXPR   0x50001
/** Affirmative response for yes/no queries */
#define YESSTR   0x50002
/** Negative response for yes/no queries */
#define NOSTR   0x50003
#ifndef MAXSTRMSG
/** Maximum number of strings in langinfo */
#   define MAXSTRMSG   58
#endif


static const UNUSED char c_time[316] = "Sun\0Mon\0Tue\0Wed\0Thu\0Fri\0Sat\0Sunday\0Monday\0Tuesday\0Wednesday\0Thursday\0Friday\0Saturday\0Jan\0Feb\0Mar\0Apr\0May\0Jun\0Jul\0Aug\0Sep\0Oct\0Nov\0Dec\0January\0February\0March\0April\0May\0June\0July\0August\0September\0October\0November\0December\0AM\0PM\0%a %b %e %T %Y\0%m/%d/%y\0%H:%M:%S\0%I:%M:%S %p\0\0\0%m/%d/%y\00123456789\0%a %b %e %T %Y\0%H:%M:%S";


static const UNUSED char align32 c_messages[32] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
static const UNUSED char align8 c_numeric[4] = ".\0" "";
static const UNUSED char align32 sweekdays[8][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "\0" };


static const UNUSED char align64 weekdays[8][16] = {
	"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "\0"
};


static const UNUSED char align64 smonths[16][4] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "\0", "\0", "\0", "\0"
};


static const UNUSED char align64 months[16][16] = {
	"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "\0", "\0", "\0", "\0"
};


/** Open a message catalog */
LIB_FUNC nl_catd catopen(const UNUSED char* restrict name, const UNUSED int oflag) {
	return ((nl_catd)-1);
}


/** Read a program message */
LIB_FUNC const char* catgets(const UNUSED nl_catd catd, const UNUSED int set_id, const UNUSED int msg_id, const UNUSED char* restrict s) {
	return (const char*)s;
}


/** Close a message catalog descriptor */
LIB_FUNC int catclose(const UNUSED nl_catd catd) {
	return 0;
}


/** Get a string from the database */
LIB_FUNC const char* nl_langinfo_l(const nl_item item, const locale_t loc) {
	if (item == CODESET) { return ((MB_CUR_MAX == 1) ? "ASCII" : "UTF-8"); }
	const int cat = (int)(item >> 16);
	register int idx = (int)(item & 65535);
	const char* str;
	switch (cat) {
		case LC_NUMERIC:
			if (idx > 1) { return ""; }
			str = c_numeric;
			break;
		case LC_TIME:
			if (idx > 0x31) { return ""; }
			str = c_time;
			break;
		case LC_MONETARY:
			if (idx > 0) { return ""; }
			str = "";
			break;
		case LC_MESSAGES:
			if (idx > 3) { return ""; }
			str = c_messages;
			break;
		default: return "";
	}
	for (; idx; idx--, str++) { for (; *str; str++); }
	if ((cat != LC_NUMERIC) && *str) { str = lctrans(str, cat, loc); }
	return (const char*)str;
}
#define __nl_langinfo_l(item, loc)   nl_langinfo_l((item), (loc))


/** Return a string with the data for locale-dependent parameter ITEM */
LIB_FUNC const char* nl_langinfo(const nl_item item) {
	return nl_langinfo_l(item, __global_locale);
}
#define __nl_langinfo(item)   nl_langinfo((item))


LIB_FUNC const char* get_codeset(void) {
	if (lc_ctype == CT_UTF8) { return "UTF-8"; }
	else { return "ISO-8859-1"; }
	const char* s = getenv("LC_CTYPE");
	if (!s) { return getenv("LC_ALL"); }
	return s;
}


LIB_FUNC const char* nl_langinfo_fast(const nl_item x) {
	if (x >= DAY_1 && x <= DAY_7) { return weekdays[x - DAY_1]; }
	else if (x >= ABDAY_1 && x <= ABDAY_7) { return sweekdays[x - ABDAY_1]; }
	else if (x >= MON_1 && x <= MON_12) { return months[x - MON_1]; }
	else if (x >= ABMON_1 && x <= ABMON_12) { return smonths[x - ABMON_1]; }
	switch (x) {
		case CODESET: return get_codeset();
		case D_T_FMT: return "%b %a %d %k:%M:%S %Z %Y";
		case D_FMT: return "%b %a %d";
		case T_FMT: return "%H:%M";
		case T_FMT_AMPM: return "%I:%M:%S %p";
		case AM_STR: return "am";
		case PM_STR: return "pm";
		case ERA: return 0;
		case ERA_D_FMT:
		case ERA_D_T_FMT:
		case ERA_T_FMT:
		case ALT_DIGITS: return "";
		case RADIXCHAR: return ".";
		case THOUSEP: return "";
		case YESEXPR: return "^[yY]";
		case NOEXPR: return "^[nN]";
		case CRNCYSTR: return "$";
		default: return NULL;
	}
	UNREACHABLE
}


#endif  // NL_TYPES_H


/* MONETARY VALUE FORMATTING FUNCTIONS (<monetary.h>) */


#if (!(defined(_MONETARY_H) || defined(_MONETARY_H_) || defined(_LMONETARY_H_) || defined(_XLOCALE__MONETARY_H_)))
#define MONETARY_H   (1)
#define _MONETARY_H   (1)
#define _MONETARY_H_   (1)
#define _LMONETARY_H_   (1)
#define _XLOCALE__MONETARY_H_   (1)
#define _XLOCALE_MONETARY_H_   (1)


static const UNUSED uint32_t align32 conversion_rate[2] = { 1, 1 };
static const UNUSED char align16 numempty[2] = { CHAR_MAX, '\0'};


typedef struct lc_monetary_T {
	const char* int_curr_symbol;
	const char* currency_symbol;
	const char* mon_decimal_point;
	const char* mon_thousands_sep;
	const char* mon_grouping;
	const char* positive_sign;
	const char* negative_sign;
	const char* int_frac_digits;
	const char* frac_digits;
	const char* p_cs_precedes;
	const char* p_sep_by_space;
	const char* n_cs_precedes;
	const char* n_sep_by_space;
	const char* p_sign_posn;
	const char* n_sign_posn;
#   ifdef __HAVE_LOCALE_INFO_EXTENDED__
	const char* int_p_cs_precedes;
	const char* int_p_sep_by_space;
	const char* int_n_cs_precedes;
	const char* int_n_sep_by_space;
	const char* int_p_sign_posn;
	const char* int_n_sign_posn;
	const char* codeset;  //!< Codeset for mbtowc conversion
	const wchar_t* wint_curr_symbol;
	const wchar_t* wcurrency_symbol;
	const wchar_t* wmon_decimal_point;
	const wchar_t* wmon_thousands_sep;
	const wchar_t* wpositive_sign;
	const wchar_t* wnegative_sign;
#   endif
} lc_monetary_T;


/** The real definition of the struct for the LC_MONETARY locale */
typedef struct attr_packed locale_monetary_t {
	const char* int_curr_symbol;
	const char* currency_symbol;
	const char* mon_decimal_point;
	const char* mon_thousands_sep;
	uint32_t mon_decimal_point_wc, mon_thousands_sep_wc;
	char* mon_grouping;
	size_t mon_grouping_len;
	const char* positive_sign;
	const char* negative_sign;
	signed char int_frac_digits, frac_digits;
	signed char p_cs_precedes, p_sep_by_space;
	signed char n_cs_precedes, n_sep_by_space;
	signed char p_sign_posn, n_sign_posn;
	signed char int_p_cs_precedes, int_p_sep_by_space;
	signed char int_n_cs_precedes, int_n_sep_by_space;
	signed char int_p_sign_posn, int_n_sign_posn;
	const char* duo_int_curr_symbol;
	const char* duo_currency_symbol;
	signed char duo_int_frac_digits, duo_frac_digits;
	signed char duo_p_cs_precedes, duo_p_sep_by_space;
	signed char duo_n_cs_precedes, duo_n_sep_by_space;
	signed char duo_p_sign_posn, duo_n_sign_posn;
	signed char duo_int_p_cs_precedes, duo_int_p_sep_by_space;
	signed char duo_int_n_cs_precedes, duo_int_n_sep_by_space;
	signed char duo_int_p_sign_posn, duo_int_n_sign_posn;
	uint32_t uno_valid_from, uno_valid_to, duo_valid_from, duo_valid_to;
	uint32_t conversion_rate[2];
	char* crncystr;
} locale_monetary_t;


#define LCMONETARY_SIZE_FULL   (sizeof(struct lc_monetary_T) / SIZEOF_POINTER)
#ifdef __HAVE_LOCALE_INFO_EXTENDED__
#   define LCMONETARY_SIZE_MIN   (offsetof(struct lc_monetary_T, wnegative_sign) / SIZEOF_POINTER)
#else
#   define LCMONETARY_SIZE_MIN   (offsetof(struct lc_monetary_T, n_sign_posn) / SIZEOF_POINTER)
#endif

#include "iso-4217.h"

#define NR_VALID_INT_CURR   ((sizeof(valid_int_curr) / sizeof(valid_int_curr[0])))


static const UNUSED struct lc_monetary_T _C_monetary_locale = {
	empty,  //!< int_curr_symbol
	empty,  //!< currency_symbol
	empty,  //!< mon_decimal_point
	empty,  //!< mon_thousands_sep
	empty,  //!< mon_grouping
	empty,  //!< positive_sign
	empty,  //!< negative_sign
	empty,  //!< int_frac_digits
	empty,  //!< frac_digits
	empty,  //!< p_cs_precedes
	empty,  //!< p_sep_by_space
	empty,  //!< n_cs_precedes
	empty,  //!< n_sep_by_space
	empty,  //!< p_sign_posn
	empty,  //!< n_sign_posn
#   ifdef __HAVE_LOCALE_INFO_EXTENDED__
	empty,  //!< int_p_cs_precedes
	empty,  //!< int_n_cs_precedes
	empty,  //!< int_p_sep_by_space
	empty,  //!< int_n_sep_by_space
	empty,  //!< int_p_sign_posn
	empty,  //!< int_n_sign_posn
	empty,  //!< codeset
	wempty,  //!< wint_curr_symbol
	wempty,  //!< wcurrency_symbol
	wempty,  //!< wmon_decimal_point
	wempty,  //!< wmon_thousands_sep
	wempty,  //!< wpositive_sign
	wempty  //!< wnegative_sign
#   endif
};


LIB_FUNC char cnv(const char* restrict str) {
	register int i = (int)atoi(str);
	if (i == -1) { i = CHAR_MAX; }
	return (char)i;
}


LIB_FUNC int curr_strcmp(const char* restrict s1, const char** restrict s2) {
	return strcmp(s1, *s2);
}


/* TODO: Add monetary functions
// Formatting a monetary value according to the current locale
ssize_t strfmon(char *restrict __s, size_t __maxsize, const char *restrict __format, ...) __attribute_format_strfmon__(3, 4);
// Formatting a monetary value according to the current locale
ssize_t strfmon_l(char *restrict __s, size_t __maxsize, __locale_t __loc, const char *restrict __format, ...) __attribute_format_strfmon__ (4, 5);
ssize_t __vstrfmon_l(char *s, size_t maxsize, __locale_t loc, const char *format, va_list ap);
const char * __fix_locale_grouping_str(const char *);
struct lc_monetary_T* __get_current_monetary_locale(locale_t);
int __monetary_load_locale(const char *, locale_t);
static void monetary_startup(struct linereader* lr, struct localedef_t* locale, int ignore_content);

*/


#endif  // MONETARY_H


/* STANDARD I/O (<stdio.h>) */


#if (!(defined(_STDIO_H) || defined(_STDIO_H_) || defined(_STDIO_IMPL_H) || defined(_STDIO_IMPL_H_) || defined(_STDIO_EXT_H) || defined(_STDIO_EXT_H_)))  // http://www.cplusplus.com/reference/cstdio/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html
#define _STDIO_H   (1)
#define _STDIO_H_   (1)
#define _STDIO_IMPL_H   (1)
#define _STDIO_IMPL_H_   (1)
#define _STDIO_EXT_H   (1)
#define _STDIO_EXT_H_   (1)
#define __STDIO_H__   (1)
#define H_STDIO   (1)
#define _IO_STDIO_H   (1)
#define _G_config_h   (1)


#ifndef _READ_WRITE_RETURN_TYPE
#   define _READ_WRITE_RETURN_TYPE   size_t
#endif
#ifndef _READ_WRITE_BUFSIZE_TYPE
#   define _READ_WRITE_BUFSIZE_TYPE   size_t
#endif
#ifdef __TANDEM  // NonStop Kernel
#   ifndef _IOERR
#      define _IOERR   0x40
#      define _IOREAD   0x80
#      define _IOWRT   4
#      define _IORW   0x100
#   endif
#endif
#define CVT_BUF_SIZE   128
#define NDYNAMIC   4
#define L_tmpnam   1024
#define TMP_MAX   308915776
/** Size for ctermid(); PATH_MAX */
#define L_ctermid   1024
/** Size for cuserid(); UT_NAMESIZE + 1 */
#define L_cuserid   9
static UNUSED FILE* volatile dummy = 0;
enum FPARSELN {
	FPARSELN_UNESCESC = 1,
	FPARSELN_UNESCCONT = 2,
	FPARSELN_UNESCCOMM = 4,
	FPARSELN_UNESCREST = 8,
	FPARSELN_UNESCALL = 0xf
};
// Convenient bit representation for modifier flags
#define ALT_FORM   (1U << ('#' - ' '))
#define ZERO_PAD   (1U << ('0' - ' '))
#define LEFT_ADJ   (1U << ('-' - ' '))
#define PAD_POS   (1U << (' ' - ' '))
#define MARK_POS   (1U << ('+' - ' '))
#define GROUPED   (1U << ('\'' - ' '))
#define FLAGMASK   (ALT_FORM | ZERO_PAD | LEFT_ADJ | PAD_POS | MARK_POS | GROUPED)
#define OOB(x)   (((unsigned)(x) - 'A') > ('z' - 'A'))


// I/O MANIPULATION MACROS

/** Clear the file's error and EOF indicators */
#define __sclearerr(fp)   ((void)((fp)->flags &= (~(__SERR | __SEOF))))
/** Clear the file's error and EOF indicators */
#define __CLEARERR_UNLOCKED(fp)   __sclearerr((fp))
/** Clear the file's error and EOF indicators */
#define clearerr_unlocked(fp)   __sclearerr((fp))


// I/O MACROS TESTS

/** Return the file's descriptor number */
#define __sfileno(fp)   ((fp)->fd >= 0 ? (int)(fp)->fd : -1)
/** Check if a file error occurred */
#define chk_ferr(fp)   (((fp)->flags & (unsigned int)__SERR) != 0)
/** Check if a file error occurred */
#define __sferror(fp)   chk_ferr((fp))
/** Check if a file error occurred */
#define __FERROR_UNLOCKED(fp)   chk_ferr((fp))
/** Check if file errors have not occurred */
#define no_ferr(fp)   (((fp)->flags & (unsigned int)__SERR) == 0)
/** Check if the file's EOF indicator is set */
#define chk_feof(fp)   (((fp)->flags & (unsigned int)__SEOF) != 0)
/** Check if the file's EOF indicator is set */
#define __sfeof(fp)   chk_feof((fp))
/** Check if the file's EOF indicator is set */
#define __FEOF_UNLOCKED(fp)   chk_feof((fp))
/** Check if the file's EOF indicator is set */
#define feof_unlocked(fp)   chk_feof((fp))
/** Check if the file's EOF indicator is set */
#define _IO_feof_unlocked(fp)   chk_feof((fp))
/** Check if the file pointer is NULL */
#define null_fp(fp)   ((fp) == (FILE*)0)
/** Test if reading the file pointer is not possible */
#define cantread(fp)   ((((fp)->flags & (unsigned int)__SRD) == 0) || ((fp)->buf == NULL))
/** Test if reading the file pointer is possible */
#define canread(fp)   ((((fp)->flags & (unsigned int)__SRD) != 0) && ((fp)->buf != NULL))
/** Test if writing to the file pointer is not possible */
#define cantwrite(fp)   ((((fp)->flags & (unsigned int)__SWR) == 0) || ((fp)->buf == NULL))
/** Test if writing to the file pointer is possible */
#define canwrite(fp)   ((((fp)->flags & (unsigned int)__SWR) != 0) && ((fp)->buf != NULL))
/** Test if reading and writing to the file pointer is not possible */
#define cantreadwrite(fp)   ((((fp)->flags & (unsigned int)__SRW) == 0) || ((fp)->buf == NULL))
/** Test if reading and writing to the file pointer is possible */
#define canreadwrite(fp)   ((((fp)->flags & (unsigned int)__SRW) != 0) && ((fp)->buf != NULL))
/** Get size of shared area */
#define shcnt(fp)   ((fp)->shcnt + (off_t)((fp)->rpos - (fp)->rend))
/** Set pointer back if it has reached the end of the shared area */
#define shunget(fp)   ((fp)->shend ? (void)(fp)->rpos-- : (void)0)
/** Test whether the given stdio file has an active `ungetc()` buffer; release such a buffer, without restoring ordinary unread data */
#define HASUB(fp)   ((fp)->ub_base != NULL)
#define FREEUB(fp)   if ((fp)->ub_base != (fp)->ubuf) { free((fp)->ub_base); } (fp)->ub_base = NULL
/** Test for an `fgetln()` buffer */
#define HASLB(fp)   ((fp)->lb_base != NULL)
#define FREELB(fp)   free((char*)(fp)->lb_base); (fp)->lb_base = NULL


// TYPES USED IN POSITIONAL ARGUMENT SUPPORT IN VFPRINF/VFWPRINTF

typedef enum __CH_CLASS {
	CH_ZERO,  //!< '0'
	DIGIT,  //!< '1-9'
	DOLLAR,  //!< '$'
	MODFR,  //!< spec modifier
	SPEC,  //!< format specifier
	DOT,  //!< '.'
	STAR,  //!< '*'
	FLAG,  //!< format flag
	OTHER,  //!< All other chars
	MAX_CH_CLASS  //!< Place-holder
} CH_CLASS_T;

typedef enum __STATE {
	START,  //!< Start
	SFLAG,  //!< Seen a flag
	WDIG,  //!< Seen digits in width area
	WIDTH,  //!< Processed width
	SMOD,  //!< Seen spec modifier
	SDOT,  //!< Seen dot
	VARW,  //!< Have variable width specifier
	VARP,  //!< Have variable precision specifier
	PREC,  //!< Processed precision
	VWDIG,  //!< Have digits in variable width specification
	VPDIG,  //!< Have digits in variable precision specification
	DONE,  //!< Done
	MAX_STATE  //!< Place-holder
} STATE_T;

typedef enum __ACTION {
	NOOP,  //!< Do nothing
	NUMBER,  //!< Build a number from digits
	SKIPNUM,  //!< Skip over digits
	GETMOD,  //!< Get and process format modifier
	GETARG,  //!< Get and process argument
	GETPW,  //!< Get variable precision or width
	GETPWB,  //!< Get variable precision or width and pushback fmt char
	GETPOS,  //!< Get positional parameter value
	PWPOS  //!< Get positional parameter value for variable width or precision
} ACTION_T;

static const UNUSED char sizeprefix['y' - 'a'] = {
	['a' - 'a'] = 'L', ['e' - 'a'] = 'L',
	['f' - 'a'] = 'L', ['g' - 'a'] = 'L',
	['d' - 'a'] = 'j', ['i' - 'a'] = 'j',
	['o' - 'a'] = 'j', ['u' - 'a'] = 'j',
	['x' - 'a'] = 'j', ['p' - 'a'] = 'j'
};

/** State machine to accept length modifiers + conversion specifiers; Result is 0 on failure, or an argument type to pop on success */
enum PRINTF_ENUM_VALUES {
	PRINTF_BARE, PRINTF_LPRE, PRINTF_LLPRE, PRINTF_HPRE, PRINTF_HHPRE, PRINTF_BIGLPRE, PRINTF_ZTPRE, PRINTF_JPRE,
	PRINTF_STOP,
	PRINTF_PTR, PRINTF_INT, PRINTF_UINT, PRINTF_ULLONG,
#   if LONG_EQ_INT
#      define PRINTF_LONG   PRINTF_INT
#      define PRINTF_ULONG   PRINTF_UINT
#   else
	PRINTF_LONG, PRINTF_ULONG,
#   endif
	PRINTF_SHORT, PRINTF_USHORT, PRINTF_CHAR, PRINTF_UCHAR,
#   ifdef ODD_TYPES
	PRINTF_LLONG, PRINTF_SIZET, PRINTF_IMAX, PRINTF_UMAX, PRINTF_PDIFF, PRINTF_UIPTR,
#   else
#      define PRINTF_LLONG   PRINTF_ULLONG
#      define PRINTF_SIZET   PRINTF_ULONG
#      define PRINTF_IMAX   PRINTF_LLONG
#      define PRINTF_UMAX   PRINTF_ULLONG
#      define PRINTF_PDIFF   PRINTF_LONG
#      define PRINTF_UIPTR   PRINTF_ULONG
#   endif
	PRINTF_DBL, PRINTF_LDBL,
	PRINTF_NOARG, PRINTF_MAXSTATE
};

#define sub_ascii_a(x)   [(x) - 'A']
static const UNUSED unsigned char printf_states[8][('z' - 'A') + 1] = {
	{  // 0: bare types
		sub_ascii_a('d') = PRINTF_INT,
		sub_ascii_a('i') = PRINTF_INT,
		sub_ascii_a('o') = PRINTF_UINT,
		sub_ascii_a('u') = PRINTF_UINT,
		sub_ascii_a('x') = PRINTF_UINT,
		sub_ascii_a('X') = PRINTF_UINT,
		sub_ascii_a('e') = PRINTF_DBL,
		sub_ascii_a('f') = PRINTF_DBL,
		sub_ascii_a('g') = PRINTF_DBL,
		sub_ascii_a('a') = PRINTF_DBL,
		sub_ascii_a('E') = PRINTF_DBL,
		sub_ascii_a('F') = PRINTF_DBL,
		sub_ascii_a('G') = PRINTF_DBL,
		sub_ascii_a('A') = PRINTF_DBL,
		sub_ascii_a('c') = PRINTF_CHAR,
		sub_ascii_a('C') = PRINTF_INT,
		sub_ascii_a('s') = PRINTF_PTR,
		sub_ascii_a('S') = PRINTF_PTR,
		sub_ascii_a('p') = PRINTF_UIPTR,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('m') = PRINTF_NOARG,
		sub_ascii_a('l') = PRINTF_LPRE,
		sub_ascii_a('h') = PRINTF_HPRE,
		sub_ascii_a('L') = PRINTF_BIGLPRE,
		sub_ascii_a('z') = PRINTF_ZTPRE,
		sub_ascii_a('j') = PRINTF_JPRE,
		sub_ascii_a('t') = PRINTF_ZTPRE
	}, {  // 1: l-prefixed
		sub_ascii_a('d') = PRINTF_LONG,
		sub_ascii_a('i') = PRINTF_LONG,
		sub_ascii_a('o') = PRINTF_ULONG,
		sub_ascii_a('u') = PRINTF_ULONG,
		sub_ascii_a('x') = PRINTF_ULONG,
		sub_ascii_a('X') = PRINTF_ULONG,
		sub_ascii_a('e') = PRINTF_DBL,
		sub_ascii_a('f') = PRINTF_DBL,
		sub_ascii_a('g') = PRINTF_DBL,
		sub_ascii_a('a') = PRINTF_DBL,
		sub_ascii_a('E') = PRINTF_DBL,
		sub_ascii_a('F') = PRINTF_DBL,
		sub_ascii_a('G') = PRINTF_DBL,
		sub_ascii_a('A') = PRINTF_DBL,
		sub_ascii_a('c') = PRINTF_INT,
		sub_ascii_a('s') = PRINTF_PTR,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('l') = PRINTF_LLPRE
	}, {  // 2: ll-prefixed
		sub_ascii_a('d') = PRINTF_LLONG,
		sub_ascii_a('i') = PRINTF_LLONG,
		sub_ascii_a('o') = PRINTF_ULLONG,
		sub_ascii_a('u') = PRINTF_ULLONG,
		sub_ascii_a('x') = PRINTF_ULLONG,
		sub_ascii_a('X') = PRINTF_ULLONG,
		sub_ascii_a('n') = PRINTF_PTR
	}, {  // 3: h-prefixed
		sub_ascii_a('d') = PRINTF_SHORT,
		sub_ascii_a('i') = PRINTF_SHORT,
		sub_ascii_a('o') = PRINTF_USHORT,
		sub_ascii_a('u') = PRINTF_USHORT,
		sub_ascii_a('x') = PRINTF_USHORT,
		sub_ascii_a('X') = PRINTF_USHORT,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('h') = PRINTF_HHPRE
	}, {  // 4: hh-prefixed
		sub_ascii_a('d') = PRINTF_CHAR,
		sub_ascii_a('i') = PRINTF_CHAR,
		sub_ascii_a('o') = PRINTF_UCHAR,
		sub_ascii_a('u') = PRINTF_UCHAR,
		sub_ascii_a('x') = PRINTF_UCHAR,
		sub_ascii_a('X') = PRINTF_UCHAR,
		sub_ascii_a('n') = PRINTF_PTR
	}, {  // 5: L-prefixed
		sub_ascii_a('e') = PRINTF_LDBL,
		sub_ascii_a('f') = PRINTF_LDBL,
		sub_ascii_a('g') = PRINTF_LDBL,
		sub_ascii_a('a') = PRINTF_LDBL,
		sub_ascii_a('E') = PRINTF_LDBL,
		sub_ascii_a('F') = PRINTF_LDBL,
		sub_ascii_a('G') = PRINTF_LDBL,
		sub_ascii_a('A') = PRINTF_LDBL,
		sub_ascii_a('n') = PRINTF_PTR
	}, {  // 6: z- or t-prefixed (assumed to be same size)
		sub_ascii_a('d') = PRINTF_PDIFF,
		sub_ascii_a('i') = PRINTF_PDIFF,
		sub_ascii_a('o') = PRINTF_SIZET,
		sub_ascii_a('u') = PRINTF_SIZET,
		sub_ascii_a('x') = PRINTF_SIZET,
		sub_ascii_a('X') = PRINTF_SIZET,
		sub_ascii_a('n') = PRINTF_PTR
	}, {  // 7: j-prefixed
		sub_ascii_a('d') = PRINTF_IMAX,
		sub_ascii_a('i') = PRINTF_IMAX,
		sub_ascii_a('o') = PRINTF_UMAX,
		sub_ascii_a('u') = PRINTF_UMAX,
		sub_ascii_a('x') = PRINTF_UMAX,
		sub_ascii_a('X') = PRINTF_UMAX,
		sub_ascii_a('n') = PRINTF_PTR
	}
};


// WRITE FUNCTIONS

LIB_FUNC ATTR_PF NONNULL int __towrite(FILE* restrict fp) {
	fp->mode |= (int)(fp->mode - 1);
	if (cantwrite(fp)) {
		fp->flags |= (unsigned int)(__SERR);
		return EOF;
	}
	fp->rpos = fp->rend = 0U;
	fp->wpos = fp->wbase = fp->buf;
	fp->wend = (fp->buf + fp->buf_size);
	return 0;
}


LIB_FUNC ATTR_PF NONNULL int __overflow(FILE* restrict fp, const int _c) {
	const unsigned char c = (unsigned char)_c;
	if ((!fp->wend) && __towrite(fp)) { return EOF; }
	else if ((fp->wpos < fp->wend) && (c != fp->lbf)) { return *fp->wpos++ = c; }
	else if (fp->write(fp, &c, 1) != 1) { return EOF; }
	return (int)c;
}


/** Get a single character and convert it to a literal integer */
LIB_FUNC ATTR_PF int getint(const char** restrict s) {
	register int i;
	for (i = 0; isdigit(**s); (*s)++) { i = (10 * i + (**s - '0')); }
	return i;
}


/** Get a single character and convert it to a literal integer */
LIB_FUNC ATTR_PF int getint_nonconst(char** restrict s) {
	register int i;
	for (i = 0; isdigit(**s); (*s)++) { i = (10 * i + (**s - '0')); }
	return i;
}


/** Get a single wide character and convert it to a literal integer */
LIB_FUNC ATTR_PF int getintw(wchar_t** s) {
	register int i;
	for (i = 0; iswdigit(**s); (*s)++) { i = 10 * i + (**s - '0'); }
	return i;
}


LIB_FUNC ATTR_NONNULL(1) size_t wrap_write(void* fp, const unsigned char* restrict buf, const size_t len) {
	return __stdio_write((FILE*)fp, buf, len);
}


LIB_FUNC ATTR_NONNULL(1) size_t sn_write(FILE* restrict fp, const unsigned char* restrict s, const size_t len) {
	register size_t k = (size_t)((fp->wend) - (fp->wpos));
	if (k > len) { k = len; }
	memcpy_no_output(fp->wpos, s, k);
	fp->wpos += k;
	return len;
}


LIB_FUNC ATTR_NONNULL(1) size_t sw_write(FILE* fp, const unsigned char* restrict s, const size_t len) {
	register size_t l1 = len, i = 0;
	if ((s != fp->wbase) && (sw_write(fp, fp->wbase, (size_t)(fp->wpos - fp->wbase)) == (size_t)-1)) {
		return (size_t)-1;
	}
	while (fp->wbuf_size && l1 && (i = (size_t)(mbtowc(fp->wbuf, (const void*)s, l1) >= 0))) {
		s += i;
		l1 -= i;
		fp->wbuf_size--;
		fp->wbuf++;
	}
	*fp->wbuf = 0;
	return (size_t)(i <= 1 ? i : len);
}


LIB_FUNC ATTR_NONNULL(1) size_t sw_write_helper(void* fp, const unsigned char* restrict buf, const size_t len) {
	return sw_write((FILE*)fp, buf, len);
}


/** Writes to file, but requires that the string end in '\n' (not counting the NULL terminator) */
LIB_FUNC NONNULL size_t fwritex(const unsigned char* restrict s, const size_t len, FILE* restrict fp) {
	register size_t l = len, i = 0;
	if (!fp->wend && __towrite(fp)) { return 0; }
	else if (l > (size_t)(fp->wend - fp->wpos)) { return fp->write(fp, s, l); }
	else if (fp->lbf >= 0) {
		for (i = l; i && (s[i - 1] != '\n'); i--);
		if (i) {
			const size_t n = fp->write(fp, s, i);
			if (n < i) { return n; }
			s += i;
			l -= i;
		}
	}
	memcpy_no_output(fp->wpos, s, l);
	fp->wpos += l;
	return (size_t)(l + i);
}


/** Writes an array of `nmemb` elements, each one with a size of `size` bytes, from the block of memory pointed by `src` to the current position in `fp` */
LIB_FUNC ATTR_NONNULL(4) size_t fwrite(const void* restrict src, const size_t size, const size_t nmemb, FILE* restrict fp) {
	if (chk_ferr(fp)) { return 0; }
	register size_t l = (size * nmemb), _nmemb = nmemb;
	if (!size) { _nmemb = 0; }
	FLOCK(fp);
	register const size_t k = __stdio_write(fp, src, l);
	FUNLOCK(fp);
	return (size_t)(k == l ? _nmemb : (k / size));
}
#define fwrite_unlocked(src, size, nmemb, fp)   fwrite((src), (size), (nmemb), (fp))


LIB_FUNC ATTR_NONNULL(3) int __fwrite(const void* restrict ptr, const size_t nmemb, FILE* restrict fp) {
	return (int)fwrite(ptr, 1, nmemb, fp);
}


LIB_FUNC ATTR_NONNULL(3) int __fwrite_helper(const void* restrict ptr, const size_t nmemb, void* restrict fp) {
	return (int)fwrite((const void* restrict)ptr, 1, nmemb, (FILE* restrict)fp);
}


/** Version of write which resumes after a signal is caught */
LIB_FUNC NONNULL int xwrite(const int fd, const char* restrict buf, const int nbytes) {
	register int ntry = 0, i, n = nbytes;
	loop_forever {
		i = (int)write(fd, buf, (size_t)n);
		if (i > 0) {
			if ((n -= i) <= 0) { return nbytes; }
			buf += i;
			ntry = 0;
		} else if (i == 0) {
			if (++ntry > 10) { return nbytes - n; }
		} else if (neq_errno(EINTR)) { return -1; }
	}
}


/** Output a string of characters of the specified length to the file pointer if no errors have occurred with that file pointer */
LIB_FUNC NONNULL void out_char(FILE* restrict fp, const char* restrict s, const size_t len) {
	if (no_ferr(fp)) { __stdio_write(fp, (const unsigned char*)s, len); }
}


/** Output a string of wide characters of the specified length to the file pointer if no errors have occurred with that file pointer */
LIB_FUNC NONNULL void out_wchar(FILE* restrict fp, const wchar_t* restrict s, size_t l) {
	while (l-- && no_ferr(fp)) { fputwc(*s++, fp); }
}


LIB_FUNC NONNULL void pad_char(FILE* restrict fp, const char c, const int w, const int len, const int _fl) {
	if (_fl & (int)(LEFT_ADJ | ZERO_PAD) || len >= w) { return; }
	char align64 pad[256] = { 0 };
	register size_t l = (size_t)(w - len);
	memset_no_output(pad, c, (size_t)(l > sizeof(pad) ? sizeof(pad) : l));
	for (; l >= sizeof(pad); l -= sizeof(pad)) { out_char(fp, pad, sizeof(pad)); }
	out_char(fp, pad, l);
}


// RUNE FUNCTIONS

LIB_FUNC ATTR_PF Rune* runefmtstrflush(Fmt* restrict f) {
	if (f->start == NULL) { return NULL; }
	*(Rune*)f->to = '\0';
	return f->start;
}


LIB_FUNC ATTR_PF char* fmtstrflush(Fmt* restrict f) {
	if (f->start == NULL) { return NULL; }
	*(char*)f->to = '\0';
	return (char*)f->start;
}


LIB_FUNC int runeFmtStrFlush(Fmt* f) {
	Rune* s;
	register size_t n = (size_t)f->farg;
	n += 256;
	f->farg = (void*)n;
	s = (Rune*)f->start;
	f->start = realloc(s, (size_t)(SIZEOF_RUNE * n));
	if (f->start == NULL) {
		f->start = s;
		return 0;
	}
	f->to = (Rune*)f->start + ((Rune*)f->to - s);
	f->stop = (Rune*)f->start + n - 1;
	return 1;
}


LIB_FUNC int fmtStrFlush(Fmt* f) {
	register size_t n = (size_t)f->farg;
	n += 256;
	f->farg = (void*)n;
	char* s = (char*)f->start;
	f->start = realloc(s, n);
	if (f->start == NULL) {
		f->start = s;
		return 0;
	}
	f->to = (char*)f->start + ((char*)f->to - s);
	f->stop = (char*)f->start + n - 1;
	return 1;
}


LIB_FUNC int runefmtstrinit(Fmt* f) {
	f->runes = 1;
	const size_t n = 32;
	f->start = malloc((size_t)(SIZEOF_RUNE * n));
	if (f->start == NULL) { return -1; }
	f->to = f->start;
	f->stop = (Rune*)f->start + n - 1;
	f->flush = runeFmtStrFlush;
	f->farg = (void*)n;
	f->nfmt = 0;
	return 0;
}


LIB_FUNC int fmtstrinit(Fmt* f) {
	f->runes = 0;
	const size_t n = 32;
	f->start = malloc(n);
	if (f->start == NULL) { return -1; }
	f->to = f->start;
	f->stop = (char*)f->start + n - 1;
	f->flush = fmtStrFlush;
	f->farg = (void*)n;
	f->nfmt = 0;
	return 0;
}


// PRINTF FUNCTIONS

#ifndef _PRINTF_H
#define _PRINTF_H   (1)


#ifndef BLOCK_OUT
#   define BLOCK_OUT   (-2)
#endif
#define _G_HAVE_MMAP   1
#define _G_HAVE_MREMAP   1
#define _G_IO_IO_FILE_VERSION   0x20001
#define _G_HAVE_ST_BLKSIZE   _STATBUF_ST_BLKSIZE
#define _G_BUFSIZ   8192
#define _IOS_INPUT   1
#define _IOS_OUTPUT   2
#define _IOS_ATEND   4
#define _IOS_APPEND   8
#define _IOS_TRUNC   16
#define _IOS_NOCREATE   32
#define _IOS_NOREPLACE   64
#define _IOS_BIN   128
#define _IO_UNIFIED_JUMPTABLES   1
/** Magic number */
#define _IO_MAGIC   0xfbad0000
/** Emulate old stdio */
#define _OLD_STDIO_MAGIC   0xfabc0000
#define _IO_MAGIC_MASK   0xffff0000
/** Do not call close(_fileno) on cleanup */
#define _IO_DELETE_DONT_CLOSE   0x40
/** Set if linked (using _chain) to streambuf::_list_all */
#define _IO_LINKED   0x80
#define _IO_IN_BACKUP   0x100
/** Set if put and get pointer logicly tied */
#define _IO_TIED_PUT_GET   0x400
#define _IO_CURRENTLY_PUTTING   0x800
#define _IO_IS_APPENDING   0x1000
#define _IO_IS_FILEBUF   0x2000
#define _IO_BAD_SEEN   0x4000
#define _IO_USER_LOCK   0x8000
#define _IO_FLAGS2_MMAP   1
#define _IO_FLAGS2_NOTCANCEL   2
#define _IO_FLAGS2_FORTIFY   4
#define _IO_FLAGS2_USER_WBUF   8
#define _IO_FLAGS2_SCANF_STD   16
#define _IO_FLAGS2_NOCLOSE   32
#define _IO_FLAGS2_CLOEXEC   64
#define _IO_SKIPWS   1
#define _IO_LEFT   2
#define _IO_RIGHT   4
#define _IO_INTERNAL   010
#define _IO_DEC   020
#define _IO_OCT   040
#define _IO_HEX   0100
#define _IO_SHOWBASE   0200
#define _IO_SHOWPOINT   0400
#define _IO_UPPERCASE   01000
#define _IO_SHOWPOS   02000
#define _IO_SCIENTIFIC   04000
#define _IO_FIXED   010000
#define _IO_UNITBUF   020000
#define _IO_STDIO   040000
#define _IO_DONT_CLOSE   0100000
#define _IO_BOOLALPHA   0200000
// Flag bits that can be set in a type returned by `parse_printf_format`
#define PA_FLAG_MASK   (0xff00)
#define PA_FLAG_LONG_LONG   (0x100)
#define PA_FLAG_LONG_DOUBLE   PA_FLAG_LONG_LONG
#define PA_FLAG_LONG   (0x200)
#define PA_FLAG_SHORT   (0x400)
#define PA_FLAG_PTR   (0x800)
#define _G_IO_NO_BACKWARD_COMPAT   1
#define _IO_JUMPS_OFFSET   0
#define _IO_HAVE_ST_BLKSIZE   _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ   _G_BUFSIZ


typedef union printf_arg {
	uintmax_t i;
	long double f;
	void* p;
} printf_arg_t;


struct arg_printf {
	void* data;
	int (*putb)(const int8_t, FILE*);
	int (*putc)(const int, FILE*);
	wint_t (*putwc)(const wchar_t, FILE*);
	int (*puts)(const void*, const size_t, void*);
	int (*putws)(const wchar_t*, FILE*);
};


/** Find location of "%" in string */
LIB_FUNC ATTR_PF ssize_t skip_to(const char* restrict format) {
	register ssize_t nr;
	for (nr = 0; format[nr] && (format[nr] != '%'); ++nr);
	return nr;
}


#undef PRINTF_BUF_SIZE
#ifdef PRINTF_BUF32
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   32
#elif defined(PRINTF_BUF64)
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   64
#elif defined(PRINTF_BUF128)
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   128
#elif defined(PRINTF_BUF256)
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   256
#elif defined(PRINTF_BUF512)
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   512
#elif (defined(PRINTF_BUF1024) || defined(PRINTF_BUF1K))
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   1024
#else
/** Size of the internal printf buffer */
#   define PRINTF_BUF_SIZE   128
#endif


#if IS_WORDSIZE_32
/** Flag used in __v_printf() to properly set internal flags for platform-specific datatypes */
#   define PRINTF_LONG_FLAG   2
#elif IS_WORDSIZE_64
/** Flag used in __v_printf() to properly set internal flags for platform-specific datatypes */
#   define PRINTF_LONG_FLAG   1
#else
#   error   "__v_printf() does not support the target platform!"
#endif


/** Write the __v_printf() buffer */
#define __v_printf_write_buf()   do { if (((tmpi = fn->puts((const void*)buf, (size_t)((PRINTF_BUF_SIZE - 1) - buf_space_left), fn->data)) == -1) || ((buf_space_left + (ssize_t)tmpi) != (PRINTF_BUF_SIZE - 1))) { return -1; } bufptr = buf; buf_space_left = PRINTF_BUF_SIZE - 1; bzero(buf, PRINTF_BUF_SIZE); } while (0x0)


/** Write the __v_printf() buffer if full */
#define __v_printf_write_if_full(next_str_size)   do { if (PREDICT_UNLIKELY(((ssize_t)(next_str_size)) < 0)) { return -1; } else if (PREDICT_UNLIKELY((buf_space_left - (ssize_t)(next_str_size)) < 0)) { __v_printf_write_buf(); } } while (0x0)


/** Tasks performed after writing the __v_printf() buffer */
#define __v_printf_write_epilogue(length)   do { len += (ssize_t)(length); bufptr += (size_t)(length); buf_space_left -= (ssize_t)(length); } while (0x0)


/**
@brief Main printf function

@section Format Specifiers
Format specifiers follow this layout: %[flags][width][.precision][length]specifier

@section Defines
 - NO_PRINT_ACTION: Disable the `%n` (printf action) symbol
 - NO_PRINT_M: Disable the `%m` (error code) symbol
 - NO_PRINT_CHARS: Disable all character-related symbols
 - NO_PRINT_FLOATS: Disable the `%f` and `%g` (float-points) symbols
 - NO_PRINT_INTS: Disable all integer-related symbols
 - NO_PRINT_STRINGS: Disable all string-related symbols
 - NO_PRINT_WIDTH_PREC: Disable all width and precision related symbols
 - PRINTF_BUF32: Set the size of the internal printf buffer to 32-bytes
 - PRINTF_BUF64: Set the size of the internal printf buffer to 64-bytes
 - PRINTF_BUF128: Set the size of the internal printf buffer to 128-bytes
 - PRINTF_BUF256: Set the size of the internal printf buffer to 256-bytes
 - PRINTF_BUF512: Set the size of the internal printf buffer to 512-bytes
*/
LIB_FUNC NOLIBCALL ATTR_PRINTF(2, 0) int __v_printf(const struct arg_printf* restrict fn, const char* format, va_list arg_ptr) {
	ssize_t len = 0;
	char align32 buf[PRINTF_BUF_SIZE] = { 0 };
	char* restrict bufptr = buf;
	ssize_t buf_space_left = PRINTF_BUF_SIZE - 1;
	char align32 xbuf[PRINTF_BUF_SIZE] = { 0 };  // Extra buffer
	UNUSED char* restrict xptr = xbuf;
	int tmpi = 0;
	while (*format) {
		ssize_t fmt_flag_pos = skip_to(format);  // Location of "%" in string
		// Test if "%" is in the format string
		if (fmt_flag_pos) {
			if (fmt_flag_pos < 1) { return -1; }  // If there is nothing to write, return -1
			__v_printf_write_if_full(fmt_flag_pos);
			memcpy_no_output(bufptr, format, (size_t)fmt_flag_pos);
			format += (size_t)fmt_flag_pos;
			__v_printf_write_epilogue(fmt_flag_pos);
		}
		// Create new string based on the format string (using "%")
		if (*format == '%') {
			unsigned char _ch = 0;
#   if (!(defined(NO_PRINT_FLOATS) && defined(NO_PRINT_INTS)))
			signed char flag_ex_sign = 0;
			unsigned char flag_base = 0, flag_hash = 0, flag_space = 0, flag_upcase = 0;
			unsigned int base = 10;
#   endif
#   ifndef NO_PRINT_WIDTH_PREC
			unsigned char padwith = ' ', flag_dot = 0, flag_justify = 0;
			long tmpl = 0;
#   endif
#   if (!(defined(NO_PRINT_FLOATS) && defined(NO_PRINT_WIDTH_PREC)))
		size_t preci = 0, width = 0;
#   endif
#   ifndef NO_PRINT_FLOATS
			unsigned char flag_mantissa = 0;
#   endif
			unsigned char flag_sign = 0;
			signed char flag_long = 0;
			++format;
goto_parse_printf:  // Parse printf "%" syntax
			switch (_ch = (unsigned char)(*format++)) {  // Get character after "%"
				case 0:
#   ifdef WANT_NULL_PRINTF
					if (fn->puts((const void*)"(NULL)", 6, fn->data) == -1) { return -1; }
					return 6;
#   else
					return -1;
#   endif
					break;
				case '%':  // Write a literal %
					if (buf_space_left < 1) { __v_printf_write_buf(); }
					*bufptr++ = '%';
					++len;
					--buf_space_left;
					break;
				// Action Specifiers
#   ifndef NO_PRINT_ACTION
				case 'n':  // Store the number of characters written so far
					goto goto_action_printf;
#   endif
#   if (!(defined(NO_PRINT_FLOATS) && defined(NO_PRINT_INTS)))
				case 'B':  // Change the output of the flag to the literal binary representation (e.g. `%Bf`)
					flag_base = 2;
					goto goto_parse_printf;
				case 'H':  // Change the output of the flag to the literal hex representation (e.g. `%Hf`)
					if (flag_base == 16) { flag_upcase = 1; }  // %HHf uses uppercase hex
					flag_base = 16;
					goto goto_parse_printf;
#   endif
				// Flags & Width Specifiers
#   if (!(defined(NO_PRINT_FLOATS) && defined(NO_PRINT_INTS)))
				case '#':  // Prefix binary, hex, and octal integers or use explicit decimal point
					flag_hash = 1;
					goto goto_parse_printf;
				case ' ':  // If no sign, then a blank space is inserted before the value
					flag_space = 1;
					goto goto_parse_printf;
				case '+':  // Preceed the result with a plus or minus sign explicitly
					flag_ex_sign = 1;
					goto goto_parse_printf;
#   endif
#   ifndef NO_PRINT_WIDTH_PREC
				case '-':  // Left-justify (right-justify is the default)
					flag_justify = 1;
					goto goto_parse_printf;
				case '*':  // Width is specified as a preceding integer value
					if ((tmpi = (int)va_arg(arg_ptr, int)) < 0) {
						flag_justify = 1;
						tmpi *= -1;
					}
					if ((width = (size_t)((tmpi <= 0) ? 0 : tmpi)) > (PRINTF_BUF_SIZE - 1)) { return -1; }
					goto goto_parse_printf;
				case '0':  // Minimum number of characters to write; May be padded
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					width = xatoul((format - 1));
					for (; isdigit(*format); ++format);
					if (width > (PRINTF_BUF_SIZE - 1)) { return -1; }
					else if (_ch == '0' && (!flag_justify)) { padwith = '0'; }
					goto goto_parse_printf;
#   endif
				// Precision Specifiers
#   ifndef NO_PRINT_WIDTH_PREC
				case '.':  // Minimum number of characters; Never truncated, but may be padded
					flag_dot = 1;
					if (*format == '*') {  // Precision is specified as a preceding integer value
						tmpi = (int)va_arg(arg_ptr, int);
						preci = (size_t)((tmpi <= 0) ? 0 : tmpi);
						++format;
					} else if (!isdigit(*format)) {
						preci = 0;
					} else {
						tmpl = xatol(format);
						preci = (size_t)((tmpl <= 0) ? 0 : tmpl);
						for (; isdigit(*format); ++format);
					}
					if (preci > (PRINTF_BUF_SIZE - 1)) { return -1; }
					goto goto_parse_printf;
#   endif
				// Length Specifiers
				case 'h':  // short integer
					--flag_long;
					if (flag_long < -2) { return -1; }  // No more than two "h" flags
					goto goto_parse_printf;
				case 'l':  // long integer
					++flag_long;
					if (flag_long > 2) { return -1; }  // No more than two "l" flags
					goto goto_parse_printf;
				case 'I':  // 64-bit integer
					if ((*format == '3') && (*(format + 1) == '2')) {  // I32
						flag_long = 0;
						format += 2;
					} else if (((*format == '6') && (*(format + 1) == '4')) || (*format == 'I')) {  // I64 & II
						flag_long = PRINTF_LONG_FLAG;
						format += 2;
					} else { flag_long = PRINTF_LONG_FLAG; }
					goto goto_parse_printf;
				case 'j':  // intmax_t & uintmax_t
				case 't':  // ptrdiff_t
				case 'z':  // size_t & ssize_t
					flag_long = PRINTF_LONG_FLAG;
					goto goto_parse_printf;
				case 'q':  // BSD extension for 64-bit integer
					flag_long = 2;
					goto goto_parse_printf;
				case 'L':  // long double
					++flag_long;
					if (flag_long > 2) { return -1; }  // No more than two "l" flags
					goto goto_parse_printf;
				// Type Specifiers
#   ifndef NO_PRINT_CHARS
				case 'c':  // Write a char
					goto goto_char_printf;
				case 'w':  // Write a wide-character
					flag_long = 1;
					if (*format == 'c') { ++format; }
					goto goto_char_printf;
				case 'U':  // Write a Unicode, UCS-4, or UTF-32 character
					flag_long = 2;
					if (*format == 'c') { ++format; }
					goto goto_char_printf;
#   endif
#   ifndef NO_PRINT_STRINGS
#      ifndef NO_PRINT_M  // Write an error message string
				case 'm':
					flag_long = 0;
					flag_sign = 'm';
					goto goto_string_printf;
#      endif
				case 'S':  // Write a unicode/UCS-4 string
					flag_long = 2;  attr_fallthrough
				case 's':  // Write a string
					flag_sign = 's';
					goto goto_string_printf;
#   endif
#   ifndef NO_PRINT_INTS  // Write an integer value
				case 'p':  // Pointer address
					base = 16;  // TODO: %pI4 prints an IPV4 address in dotted-decimal form
					flag_hash = 2;
					flag_long = PRINTF_LONG_FLAG;
					flag_sign = 0;
					flag_upcase = 0;
					goto goto_inum_printf;
				case 'P':  // Pointer address (uppercase hexadecimal)
					base = 16;
					flag_hash = 2;
					flag_long = PRINTF_LONG_FLAG;
					flag_sign = 0;
					flag_upcase = 1;
					goto goto_inum_printf;
				case 'b':  // Integer in binary format
					base = 2;
					flag_sign = 0;
					flag_ex_sign = 0;
					goto goto_inum_printf;
				case 'X':  // Unsigned hexadecimal integer (uppercase)
					flag_upcase = 1;  attr_fallthrough
				case 'x':  // Unsigned hexadecimal integer (lowercase)
					base = 16;
					goto goto_inum_printf;
				case 'O':  // Signed octal integer
					flag_sign = 1;  attr_fallthrough
				case 'o':  // Unsigned octal integer
					base = 8;
					goto goto_inum_printf;
				case 'D':  // Signed decimal integer (Apple extension)
				case 'd':  // Signed decimal integer
				case 'i':  // Signed decimal integer
					base = 10;
					flag_sign = 1;
					goto goto_inum_printf;
				case 'u':  // Unsigned decimal integer
					base = 10;
					flag_sign = 0;
					goto goto_inum_printf;
#   endif
#   ifndef NO_PRINT_FLOATS  // Write a floating-point
				case 'A':  // Uppercase hexadecimal floating-point
					flag_upcase = 1;  attr_fallthrough
				case 'a':  // Lowercase hexadecimal floating-point
					base = 16;
					goto goto_float_printf;
				case 'E':  // Uppercase scientific notation (mantissa/exponent)
					flag_upcase = 1;  attr_fallthrough
				case 'e':  // Lowercase scientific notation (mantissa/exponent)
					flag_mantissa = 1;
					goto goto_float_printf;
				case 'F':  // Uppercase decimal floating-point
					flag_upcase = 1;  attr_fallthrough
				case 'f':  // Lowercase decimal floating-point
					base = 10;
					flag_mantissa = 0;
					goto goto_float_printf;
				case 'G':  // Use the shortest representation: %E or %F
					flag_upcase = 1;  attr_fallthrough
				case 'g':  // Use the shortest representation: %e or %f
					flag_mantissa = 2;
					goto goto_float_printf;
#   endif
#   ifndef NO_PRINT_CHARS  // Prepare char output
goto_char_printf:
				{
					// Character width padding
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY((width > 0) && !flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
					if (buf_space_left < 4) { __v_printf_write_buf(); }
#      endif
					// Character type
					if (flag_long == 1 || flag_long == 2) {  // Wide/UCS-4/UTF-32/Unicode character
						const utf8_t utfchar = { .whole = (ucs4_t)utf32c2utf8c((ucs4_t)va_arg(arg_ptr, ucs4_t)) };
						if (PREDICT_UNLIKELY(utfchar.bytes.byte4 != 0)) {  // Four-byte UTF-8 symbol
							*bufptr++ = utfchar.chars.byte1;
							*bufptr++ = utfchar.chars.byte2;
							*bufptr++ = utfchar.chars.byte3;
							*bufptr++ = utfchar.chars.byte4;
							buf_space_left -= 4;
							len += 4;
						} else if (utfchar.bytes.byte3 != 0) {  // Three-byte UTF-8 symbol
							*bufptr++ = utfchar.chars.byte1;
							*bufptr++ = utfchar.chars.byte2;
							*bufptr++ = utfchar.chars.byte3;
							buf_space_left -= 3;
							len += 3;
						} else if (utfchar.bytes.byte2 != 0) {  // Two-byte UTF-8 symbol
							*bufptr++ = utfchar.chars.byte1;
							*bufptr++ = utfchar.chars.byte2;
							buf_space_left -= 2;
							len += 2;
						} else if (PREDICT_LIKELY(utfchar.bytes.byte1 != 0)) {  // Single-byte UTF-8 symbol
							*bufptr++ = utfchar.chars.byte1;
							--buf_space_left;
							++len;
						} else { return -1; }
					} else {  // ASCII character
						*bufptr++ = (char)va_arg(arg_ptr, unsigned int);
						--buf_space_left;
						++len;
					}
					// Character width padding & left-justify
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY((width > 0) && flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
#      endif
					break;
				}
#   endif
#   ifndef NO_PRINT_STRINGS  // Prepare string output
goto_string_printf:
				{
					union __union_v_printf_buf { char* str; const char* cstr; } u_str;
					switch (flag_sign) {
#      ifndef NO_PRINT_M
						case 'm':  // Write an error message
							u_str.str = strerror(get_errno());
							break;
#      endif
						case 's':  // Write a string
							u_str.str = va_arg(arg_ptr, char*);
#      ifdef WANT_NULL_PRINTF
							if (!u_str.cstr) { u_str.cstr = "(NULL)"; }
#      endif
							break;
						default: return -1;
					}
					// Prepare string width & precision padding
#      ifndef NO_PRINT_WIDTH_PREC
					register int flag_preci = 0;
#      endif
					register size_t outstrlen = 0;
					if (PREDICT_UNLIKELY(flag_long == 2)) {
						outstrlen = utf32len((const ucs4_t*)u_str.cstr);
					} else { outstrlen = utf8len(u_str.cstr); }
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY(flag_dot && (preci == 0))) {
						*u_str.str = '\0';
						outstrlen = 0;
						flag_preci = 1;
					} else if (preci >= outstrlen) { preci = 0; }
					else if ((preci != 0) && (preci < outstrlen)) {
						flag_preci = 2;
						outstrlen = preci;
						memcpy_no_output(&xbuf, u_str.cstr, outstrlen);
						xptr += outstrlen;
						*++xptr = '\0';
						u_str.str = xbuf;
					}
					if (PREDICT_UNLIKELY(width >= outstrlen)) { width -= outstrlen; }
					else { width = 0; }
					if ((preci > (PRINTF_BUF_SIZE - 1)) || (width > (PRINTF_BUF_SIZE - 1))) { return -1; }
					// String width padding
					if (PREDICT_UNLIKELY((width > 0) && !flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
					// String precision padding
					if (PREDICT_UNLIKELY(flag_dot && (preci > 0) && (flag_preci == 0))) {
						__v_printf_write_if_full(preci);
						memset_no_output(bufptr, ' ', preci);
						__v_printf_write_epilogue(preci);
					}
#      endif
					// Write string
					if (PREDICT_UNLIKELY((flag_long == 1) && (outstrlen != 0))) {
						__v_printf_write_if_full(outstrlen);
						memcpy_no_output(bufptr, u_str.cstr, outstrlen);
						__v_printf_write_epilogue(outstrlen);
					} else if ((flag_long == 2) && (outstrlen != 0)) {  // UTF32
						register const size_t utflen = utf32toutf8((const ucs4_t*)u_str.cstr, (unsigned char*)xbuf);
						__v_printf_write_if_full(utflen);
						memcpy_no_output(bufptr, &xbuf, utflen);
						__v_printf_write_epilogue(utflen);
					} else if (PREDICT_LIKELY(outstrlen != 0)) {  // ASCII/UTF8
						__v_printf_write_if_full(outstrlen);
						memcpy_no_output(bufptr, u_str.cstr, outstrlen);
						__v_printf_write_epilogue(outstrlen);
					}
					// String width padding & left-justify
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY((width > 0) && flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
#      endif
					break;
				}
#   endif
#   ifndef NO_PRINT_INTS  // Prepare integer output
goto_inum_printf:
				{
					union printf_number {
						char cnumber;
						short snumber;
						int inumber;
						long lnumber;
						long long llnumber;
						unsigned char ucnumber;
						unsigned short usnumber;
						unsigned int unumber;
						unsigned long ulnumber;
						unsigned long long ullnumber;
					} pfmtnum = { .ullnumber = 0 };
					char align32 prefix_buf[4] = { 0 };
					char* restrict prefix_ptr = prefix_buf;
					char align32 suffix_buf[4] = { 0 };
					char* restrict suffix_ptr = suffix_buf;
					// Integer length & sign
					switch (flag_long) {
						case 2:
							if (flag_sign) {
								pfmtnum.llnumber = (long long)va_arg(arg_ptr, long long);
								if (pfmtnum.llnumber < 0) {
									pfmtnum.ullnumber = (unsigned long long)-pfmtnum.llnumber;
									flag_ex_sign = '-';
								} else { pfmtnum.ullnumber = (unsigned long long)pfmtnum.llnumber; }
							} else {
								pfmtnum.ullnumber = (unsigned long long)va_arg(arg_ptr, unsigned long long);
							}
							break;
						case 1:
							if (flag_sign) {
								pfmtnum.lnumber = (long)va_arg(arg_ptr, long);
								if (pfmtnum.lnumber < 0) {
									pfmtnum.ulnumber = (unsigned long)-pfmtnum.lnumber;
									flag_ex_sign = '-';
								} else { pfmtnum.ulnumber = (unsigned long)pfmtnum.lnumber; }
							} else {
								pfmtnum.ulnumber = (unsigned long)va_arg(arg_ptr, unsigned long);
							}
							break;
						case 0:
							if (flag_sign) {
								pfmtnum.inumber = (int)va_arg(arg_ptr, int);
								if (pfmtnum.inumber < 0) {
									pfmtnum.unumber = (unsigned int)-pfmtnum.inumber;
									flag_ex_sign = '-';
								} else { pfmtnum.unumber = (unsigned int)pfmtnum.inumber; }
							} else {
								pfmtnum.unumber = (unsigned int)va_arg(arg_ptr, unsigned int);
							}
							break;
						case -1:
							if (flag_sign) {
								pfmtnum.snumber = (short)va_arg(arg_ptr, int);
								if (pfmtnum.snumber < 0) {
									pfmtnum.usnumber = (unsigned short)-pfmtnum.snumber;
									flag_ex_sign = '-';
								} else { pfmtnum.usnumber = (unsigned short)pfmtnum.snumber; }
							} else {
								pfmtnum.usnumber = (unsigned short)va_arg(arg_ptr, unsigned int);
							}
							break;
						case -2:
							if (flag_sign) {
								pfmtnum.cnumber = (char)va_arg(arg_ptr, int);
								if (pfmtnum.cnumber < 0) {
									pfmtnum.ucnumber = (unsigned char)-pfmtnum.cnumber;
									flag_ex_sign = '-';
								} else { pfmtnum.ucnumber = (unsigned char)pfmtnum.cnumber; }
							} else {
								pfmtnum.ucnumber = (unsigned char)va_arg(arg_ptr, unsigned int);
							}
							break;
						default: return -1;
					}
					// Set sign character in buffer
					bzero(xbuf, PRINTF_BUF_SIZE);
					xptr = xbuf;
					if (flag_sign && flag_ex_sign == '-') {
						*prefix_ptr++ = '-';
					} else if (PREDICT_UNLIKELY(flag_ex_sign == 1 || flag_space)) {
						*prefix_ptr++ = ((flag_ex_sign == 1) ? '+' : ' ');
					} else {
						flag_sign = 0;
						flag_ex_sign = 0;
					}
					// Integer base
					if (flag_base != 0) { base = flag_base; }
					switch (base) {
						case 2:  // Binary
							if (PREDICT_LIKELY(flag_hash)) {  // Append integer prefix
								*prefix_ptr++ = '0';
								*prefix_ptr++ = 'b';
							}
							if (flag_long == 2) {
								bit64tostr((uint64_t)pfmtnum.ullnumber, xptr);
							} else if (flag_long == 1) {
								bitlongtostr((unsigned long)pfmtnum.ulnumber, xptr);
							} else if (flag_long == 0) {
								bit32tostr((uint32_t)pfmtnum.unumber, xptr);
							} else if (flag_long == -1) {
								bit16tostr((uint16_t)pfmtnum.usnumber, xptr);
							} else if (flag_long == -2) {
								bit8tostr((uint8_t)pfmtnum.ucnumber, xptr);
							} else { return -1; }
							flag_ex_sign = 0;
							flag_sign = 0;
							break;
						case 8:  // Octal
							if (PREDICT_LIKELY(flag_hash)) {  // Append integer prefix
								*prefix_ptr++ = '0';
							}
							if (flag_long == 2) {
								ulltooct((unsigned long long)pfmtnum.ullnumber, xptr);
							} else if (flag_long == 1) {
								ultooct((unsigned long)pfmtnum.ulnumber, xptr);
							} else if (flag_long == 0) {
								utooct((unsigned int)pfmtnum.unumber, xptr);
							} else if (flag_long == -1) {
								uhtooct((unsigned short)pfmtnum.usnumber, xptr);
							} else if (flag_long == -2) {
								u8tooct((uint8_t)pfmtnum.ucnumber, xptr);
							} else { return -1; }
							break;
						case 10:  // Decimal
							if (PREDICT_UNLIKELY(flag_hash)) {  // Append decimal-point
								*suffix_ptr++ = '.';
								*suffix_ptr++ = '0';
							}
							if (flag_long == 2) {
								ulltodec((unsigned long long)pfmtnum.ullnumber, xptr);
							} else if (flag_long == 1) {
								ultodec((unsigned long)pfmtnum.ulnumber, xptr);
							} else if (flag_long == 0) {
								utodec((unsigned int)pfmtnum.unumber, xptr);
							} else if (flag_long == -1) {
								uhtodec((unsigned short)pfmtnum.usnumber, xptr);
							} else if (flag_long == -2) {
								u8todec((uint8_t)pfmtnum.ucnumber, xptr);
							} else { return -1; }
							break;
						case 16:  // Hexadecimal
							if (PREDICT_LIKELY(flag_hash)) {  // Append integer prefix
								*prefix_ptr++ = '0';
								*prefix_ptr++ = (char)(flag_upcase ? 'X' : 'x');
							}
							if (flag_long == 2) {
								ulltohex((unsigned long long)pfmtnum.ullnumber, (int)flag_upcase, xptr);
							} else if (flag_long == 1) {
								ultohex((unsigned long)pfmtnum.ulnumber, (int)flag_upcase, xptr);
							} else if (flag_long == 0) {
								utohex((unsigned int)pfmtnum.unumber, (int)flag_upcase, xptr);
							} else if (flag_long == -1) {
								uhtohex((unsigned short)pfmtnum.usnumber, (int)flag_upcase, xptr);
							} else if (flag_long == -2) {
								u8tohex((uint8_t)pfmtnum.ucnumber, (int)flag_upcase, xptr);
							} else { return -1; }
							break;
						default: return -1;
					}
					// Setup integer precision & width padding
					xptr = xbuf;
#      ifndef NO_PRINT_WIDTH_PREC
					register int flag_preci = 0;
#      endif
					register size_t prefixlen = strlen(prefix_buf);
					register size_t suffixlen = strlen(suffix_buf);
					register size_t numstrlen = strlen(xptr);
					if (PREDICT_UNLIKELY((numstrlen == 0 || prefixlen > 3 || suffixlen > 2))) { return -1; }
#      ifndef NO_PRINT_WIDTH_PREC
					else if (PREDICT_UNLIKELY(flag_dot && (preci == 0))) { flag_preci = 1; }
					else if (preci >= numstrlen) { preci -= numstrlen; }
					if (width >= (prefixlen + preci + numstrlen + suffixlen)) {
						width -= (prefixlen + preci + numstrlen + suffixlen);
					} else { width = 0; }
					if ((preci > (PRINTF_BUF_SIZE - 1)) || (width > (PRINTF_BUF_SIZE - 1))) { return -1; }
					// Integer width padding
					if (PREDICT_UNLIKELY((width > 0) && !flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
#      endif
					// Integer prefix string
					if (prefixlen > 0) {
						__v_printf_write_if_full(prefixlen);
						memcpy_no_output(bufptr, &prefix_buf, prefixlen);
						__v_printf_write_epilogue(prefixlen);
					}
					// Integer precision padding
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY(flag_preci)) {  // If `preci` is 0, then do not write number
						*xptr = '\0';
					} else if (flag_dot && (preci > 0)) {  // Write precision padding
						__v_printf_write_if_full(preci);
						memset_no_output(bufptr, '0', preci);
						__v_printf_write_epilogue(preci);
					}
#      endif
					// Write integer string
					if (PREDICT_UNLIKELY((numstrlen > 0) && (*xptr != '\0'))) {
						if (((buf_space_left - (ssize_t)numstrlen) - (ssize_t)suffixlen) < 0) {
							__v_printf_write_buf();
						}
						memcpy_no_output(bufptr, &xbuf, numstrlen);
						__v_printf_write_epilogue(numstrlen);
						if (PREDICT_UNLIKELY(suffixlen > 0)) {  // Write suffix string
							memcpy_no_output(bufptr, &suffix_buf, suffixlen);
							__v_printf_write_epilogue(suffixlen);
						}
					}
					// Integer width padding & left-justify
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY((width > 0) && flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
#      endif
					break;
				}
#   endif
#   ifndef NO_PRINT_FLOATS  // Prepare float output
goto_float_printf:
				{
					if (flag_long > 1 || flag_long < 0) { return -1; }
					flag_sign = 1;
					union printf_float {
						float sfloat;  // flag_long == 0
						double dfloat;
						long double lfloat;
					} pffloat = { .dfloat = 0.0 };
					// Float length & sign
					switch (flag_long) {  // FIXME: Add support for long double
						// case 1:
						// 	pffloat.lfloat = (long double)va_arg(arg_ptr, long double);
						// 	if (pffloat.lfloat > 0.0L) { flag_sign = 0; }
						// 	break;
						case 0:
						case 1:
							pffloat.dfloat = (double)va_arg(arg_ptr, double);
							if (pffloat.dfloat > 0.0) { flag_sign = 0; }
							break;
						default: return -1;
					}
					// Set sign character in buffer
					bzero(xbuf, PRINTF_BUF_SIZE);
					xptr = xbuf;
					// Float format
					if (PREDICT_UNLIKELY(flag_base > 1 && base == 2)) {  // Binary representation
						if (flag_sign) { *xptr++ = '-'; }
						else if (PREDICT_UNLIKELY((flag_ex_sign == 1) || flag_space)) {
							*xptr++ = ((flag_ex_sign == 1) ? '+' : ' ');
						} else {
							flag_sign = 0;
							flag_ex_sign = 0;
						}
						if (PREDICT_LIKELY(flag_hash)) {  // Append integer prefix
							*xptr++ = '0';
							*xptr++ = 'b';
						}
						if (flag_long == 0) {
							floatbittostr(pffloat.sfloat, xptr);
							xptr += BITS_PER_FLOAT;
						} else if (flag_long == 1) {
							doublebittostr(pffloat.dfloat, xptr);
							xptr += BITS_PER_DOUBLE;
						} else { return -1; }
						flag_sign = 0;
						flag_base = 0;
					} else if (PREDICT_UNLIKELY(flag_base > 1)) { return -1; }
					else if (PREDICT_LIKELY(flag_mantissa == 0 && base == 10)) {  // %f & %F
						if ((tmpi = dtostr(pffloat.dfloat, xptr, width, preci, (flag_upcase > 0 ? 'F' : 'f'))) < 1) { return -1; }
						xptr += tmpi;
					} else if (PREDICT_UNLIKELY(base == 16)) {  // %a & %A
						if ((tmpi = dtostr(pffloat.dfloat, xptr, width, preci, (flag_upcase > 0 ? 'A' : 'a'))) < 1) { return -1; }
						xptr += tmpi;
					} else if (PREDICT_UNLIKELY(flag_mantissa == 1 && base == 10)) {  // %e & %E
						if ((tmpi = dtostr(pffloat.dfloat, xptr, width, preci, (flag_upcase > 0 ? 'E' : 'e'))) < 1) { return -1; }
						xptr += tmpi;
					} else if (PREDICT_UNLIKELY(flag_mantissa == 2 && base == 10)) {  // %g & %G
						if ((tmpi = dtostr(pffloat.dfloat, xptr, width, preci, (flag_upcase > 0 ? 'G' : 'g'))) < 1) { return -1; }
						xptr += tmpi;
					} else { return -1; }
					// Write float-point
					const size_t outstrlen = strlen(xbuf);
					__v_printf_write_if_full(outstrlen);
					memcpy_no_output(bufptr, &xbuf, outstrlen);
					__v_printf_write_epilogue(outstrlen);
					// Float-point width padding & left-justify
#      ifndef NO_PRINT_WIDTH_PREC
					if (PREDICT_UNLIKELY((width > 0) && flag_justify)) {
						__v_printf_write_if_full(width);
						memset_no_output(bufptr, padwith, width);
						__v_printf_write_epilogue(width);
					}
#      endif
					break;
				}
#   endif
#   ifndef NO_PRINT_ACTION  // Flags that trigger an action
goto_action_printf:
				{
					union printf_pointer {
						unsigned char* cptr;
						unsigned short* sptr;
						unsigned int* iptr;
						unsigned long* lptr;
						unsigned long long* llptr;
						uintptr_t uptr;
					} pfptr = { .iptr = NULL };
					switch (flag_long) {
						case 2:
							pfptr.uptr = va_arg(arg_ptr, uintptr_t);
							*pfptr.llptr = (unsigned long long)len;
							break;
						case 1:
							pfptr.uptr = va_arg(arg_ptr, uintptr_t);
							*pfptr.lptr = (unsigned long)len;
							break;
						case 0:
							pfptr.uptr = va_arg(arg_ptr, uintptr_t);
							*pfptr.iptr = (unsigned int)len;
							break;
						case -1:
							pfptr.uptr = va_arg(arg_ptr, uintptr_t);
							*pfptr.sptr = (unsigned short)len;
							break;
						case -2:
							pfptr.uptr = va_arg(arg_ptr, uintptr_t);
							*pfptr.cptr = (unsigned char)len;
							break;
						default: return -1;
					}
					break;
				}  // End of goto_action_printf
#   endif
				default: break;
			}  // End of printf format syntax switch-statement
		}  // End of `if (*format == '%')`
	}  // End of `while (*format)`
	// Ensure that the buffer has been written before ending function
	register const size_t tmpsz = strlen(buf);
	if (tmpsz > 0) {
		if (((tmpi = fn->puts((const void*)buf, tmpsz, fn->data)) == -1) || ((buf_space_left + (ssize_t)tmpi) != (PRINTF_BUF_SIZE - 1))) { return -1; }
		bzero(buf, PRINTF_BUF_SIZE);
	}
	return (int)len;
}
#undef __v_printf_write_buf
#undef __v_printf_write_if_full
#undef __v_printf_write_epilogue
#undef PRINTF_BUF_SIZE
#undef PRINTF_LONG_FLAG


/** Writes the C string pointed by format to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by `ap` instead of additional function arguments */
LIB_FUNC ATTR_PRINTF(2, 0) int vfprintf(FILE* stream, const char* format, va_list arg_ptr) {
	const struct arg_printf ap = { stream, &putb, &putc, &fputwc, &__fwrite_helper, &fputws };
	return __v_printf(&ap, format, arg_ptr);
}


/** Writes the C string pointed by fmt to the stream; If fmt includes format specifiers (subsequences beginning with %), the additional arguments following fmt are formatted and inserted in the resulting string replacing their respective specifiers */
LIB_FUNC ATTR_NONNULL(1) ATTR_PRINTF(2, 3) int fprintf(FILE* restrict fp, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	const struct arg_printf ap2 = { fp, &putb, &putc, &fputwc, &__fwrite_helper, &fputws };
	register const int ret = __v_printf(&ap2, fmt, ap);
	va_end(ap);
	return ret;
}
#define __fprintf(fp, fmt, ...)   fprintf((fp), (fmt), (__VA_ARGS__))


/** Write formatted output to stdout according to the format string FORMAT, using the argument list in ARG */
LIB_FUNC ATTR_PRINTF(1, 0) int vprintf(const char* format, va_list arg) {
	const struct arg_printf ap = { stdout, &putb, &putc, &fputwc, &__fwrite_helper, &fputws };
	return __v_printf(&ap, format, arg);
}
#define __vprintf(format, arg)   vprintf((format), (arg))
#define __vprintfW(format, arg)   vprintf((format), (arg))


/** Write formatted output to stdout from the format string FORMAT */
LIB_FUNC ATTR_PRINTF(1, 2) int printf(const char* restrict format, ...) {
	va_list arg;
	va_start(arg, format);
	const struct arg_printf ap2 = { stdout, &putb, &putc, &fputwc, &__fwrite_helper, &fputws };
	register const int done = __v_printf(&ap2, format, arg);
	va_end(arg);
	fflush(stdout);
	return done;
}
#define __printf(format, ...)   printf((format), (__VA_ARGS__))
#define __printfW(format, ...)   printf((format), (__VA_ARGS__))
#define _IO_printf(format, ...)   printf((format), (__VA_ARGS__))


LIB_FUNC ATTR_PRINTF(2, 0) int vdprintf(const int fd, char* restrict fmt, va_list ap) {
	FILE fp = {
		.fd = fd,
		.lbf = EOF,
		.write = &wrap_write,
		.buf = (void*)fmt,
		.buf_size = 0,
		.lock = -1
	};
	return vfprintf(&fp, fmt, ap);
}


LIB_FUNC ATTR_PRINTF(2, 3) int dprintf(const int fd, char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vdprintf(fd, fmt, ap);
	va_end(ap);
	return ret;
}


/** Print formatted output to string STR; Similar to vsprintf, but additional length SIZE limit how much is written into STR; Returns string length of formatted string (which may be larger than SIZE); STR may be NULL, in which case nothing will be written; On error, return a negative value */
LIB_FUNC ATTR_PRINTF(3, 0) int vsnprintf(char* restrict str, const size_t size, const char* restrict fmt, va_list ap) {
	register size_t maxlen = size;
	char dummy;
	FILE fp = { 0 };
	fp.fgetstr_len = 0;
	fp.fgetstr_buf = NULL;
	if (maxlen > INT_MAX) { maxlen = INT_MAX; }
	if (maxlen == 0) {
		str = &dummy;
		maxlen = 1;
	}
	fp.fd = -1;
	fp.flags = (__SWR | __SSTR);
	fp.buf = fp.rpos = (unsigned char*)str;
	fp.wspace = (int)(maxlen - 1);
	fp.buf_size = (size_t)fp.wspace;
	const int ret = vfprintf(&fp, fmt, ap);
	*fp.rpos = '\0';
	return ret;
}
#define _IO_vsnprintf(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))
#define __vsnprintf(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))
#define __vsnprintfW(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))


/** Write formatted output into S, according to the format string FORMAT, writing no more than MAXLEN characters */
LIB_FUNC ATTR_PRINTF(3, 4) int snprintf(char* restrict s, const size_t maxlen, const char* restrict format, ...) {
	va_list arg;
	va_start(arg, format);
	register const int done = vsnprintf(s, maxlen, format, arg);
	va_end(arg);
	return done;
}
#define __snprintf(s, maxlen, format, ...)   snprintf((s), (maxlen), (format), (__VA_ARGS__))
#define __snprintfW(s, maxlen, format, ...)   snprintf((s), (maxlen), (format), (__VA_ARGS__))


/** Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by `ap` instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by `s` */
LIB_FUNC ATTR_PRINTF(2, 0) int vsprintf(char* restrict s, const char* restrict fmt, va_list ap) {
	return (int)vsnprintf(s, INT_MAX, fmt, ap);
}


/** Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by `s` */
LIB_FUNC ATTR_PRINTF(2, 3) int sprintf(char* restrict s, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = (int)vsnprintf(s, INT_MAX, fmt, ap);
	va_end(ap);
	return ret;
}
#define SPRINTF(s, fmt, ...)   sprintf((s), (fmt), __VA_ARGS__)


LIB_FUNC ATTR_PRINTF(2, 0) int vasprintf(char** s, const char* restrict fmt, va_list ap) {
	va_list ap2;
	va_copy(ap2, ap);
	register const int l = vsnprintf(0, 0, fmt, ap2);
	va_end(ap2);
	if (l < 0 || (!(*s = malloc((size_t)(l + 1))))) { return -1; }
	return vsnprintf(*s, (size_t)(l + 1), fmt, ap);
}
#define _IO_vasprintf(result_ptr, format, args)   vasprintf((result_ptr), (format), (args))


LIB_FUNC ATTR_PRINTF(2, 3) int asprintf(char** s, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vasprintf(s, fmt, ap);
	va_end(ap);
	return ret;
}
#define ASPRINTF(s, fmt, ...)   asprintf((s), (fmt), __VA_ARGS__)


#endif  // PRINTF_H


/** Create shared area */
LIB_FUNC NONNULL void shlim(FILE* restrict fp, const off_t lim) {
	fp->shlim = lim;
	fp->shcnt = (fp->rend - fp->rpos);
	if (lim && (fp->shcnt > lim)) { fp->shend = (fp->rpos + lim); }
	else { fp->shend = fp->rend; }
}


/** Get a character from the shared area */
LIB_FUNC int shgetc(FILE* restrict fp) {
	register int c;
	if ((fp->shlim && (fp->shcnt >= fp->shlim)) || (c = __uflow(fp)) < 0) {
		fp->shend = 0;
		return EOF;
	} else if (fp->shlim && ((fp->rend - fp->rpos) > (fp->shlim - fp->shcnt - 1))) {
		fp->shend = (fp->rpos + (fp->shlim - fp->shcnt - 1));
	} else { fp->shend = fp->rend; }
	if (fp->rend) { fp->shcnt += fp->rend - fp->rpos + 1; }
	if (fp->rpos[-1] != c) { fp->rpos[-1] = (unsigned char)c; }
	return c;
}


LIB_FUNC int sflush(FILE* fp) {
	if (cantwrite(fp)) { return 0; }
	unsigned char* p = fp->buf;
	register int n = (int)(fp->rpos - p);
	fp->rpos = p;
	fp->wspace = ((fp->flags & (unsigned int)(__SLBF | __SNBF)) ? 0 : (int)fp->buf_size);
	register int t = (int)(fp->flags);
	for (; n > 0; n -= t, p += t) {
		t = (int)((*fp->write)(fp, (unsigned char*)p, (size_t)n));
		if (t <= 0) {
			fp->flags |= (unsigned int)__SERR;
			return EOF;
		}
	}
	return 0;
}


LIB_FUNC int sflush_locked(FILE* fp) {
	FLOCK(fp);
	const int r = sflush(fp);
	FUNLOCK(fp);
	return r;
}


LIB_FUNC int _fwalk(int (*function)(FILE*)) {
	FILE* fp;
	register int n;
	struct glue* g;
	register int ret = 0;
	for (g = &__sglue; g != NULL; g = g->next) {
		for (fp = g->iobs, n = g->niobs; --n >= 0; fp++) {
			if ((fp->flags != 0) && ((fp->flags & (unsigned int)__SIGN) == 0)) {
				ret |= (*function)(fp);
			}
		}
	}
	return ret;
}


LIB_FUNC int fflush_unlocked(FILE* fp) {
	if (fp->wpos > fp->wbase) {
		fp->write(fp, 0, 0);
		if (!fp->wpos) { return EOF; }
	}
	if (fp->rpos < fp->rend) { fp->seek(fp, fp->rpos - fp->rend, SEEK_CUR); }
	fp->wpos = fp->wbase = fp->wend = 0;
	fp->rpos = fp->rend = 0;
	return 0;
}


/** Flush a single file, or (if `fp` is NULL) all files */
LIB_FUNC int fflush(FILE* fp) {
	if (fp) {
		FLOCK(fp);
		const int r = fflush_unlocked(fp);
		FUNLOCK(fp);
		return r;
	}
	register int r = (int)(STDOUT ? fflush(STDOUT) : 0);
	for (fp = *ofl_lock(); fp; fp = fp->next_locked) {
		FLOCK(fp);
		if (fp->wpos > fp->wbase) { r |= fflush_unlocked(fp); }
		FUNLOCK(fp);
	}
	UNLOCK(memlock);
	return r;
}
#define _IO_fflush(fp)   fflush((fp))


LIB_FUNC int lflush(FILE* restrict fp) {
	if (null_fp(fp)) { return __SERR; }
	else if ((fp->flags & (unsigned int)(__SLBF | __SWR)) == (unsigned int)(__SLBF | __SWR)) { return sflush(fp); }
	return 0;
}


LIB_FUNC ATTR_NONNULL(2) int sread(FILE* fp, const char* restrict buf, const int bufsize) {
	register const int ret = (int)read(fp->fd, buf, (size_t)bufsize);
	if (ret >= 0) { fp->offset += ret; }
	else { fp->flags &= (unsigned int)(~__SOFF); }
	return ret;
}
#define _sread(fp, buf, bufsize)   sread((fp), (buf), (bufsize))
#define __sread(fp, buf, bufsize)   sread((fp), (buf), (bufsize))


LIB_FUNC ATTR_NONNULL(2) int swrite(FILE* fp, const char* restrict buf, const int bufsize) {
	if (fp->flags & (unsigned int)__SAPP) { (void)lseek(fp->fd, (off_t)0, SEEK_END); }
	fp->flags &= (unsigned int)(~__SOFF);
	return (int)write(fp->fd, buf, (size_t)bufsize);
}
#define _swrite(fp, buf, bufsize)   swrite((fp), (buf), (bufsize))
#define __swrite(fp, buf, bufsize)   swrite((fp), (buf), (bufsize))


LIB_FUNC fpos_t sseek(FILE* fp, const fpos_t offset, const int whence) {
	register const off_t ret = lseek(fp->fd, (off_t)offset, whence);
	if (ret == (off_t)-1) { fp->flags &= (unsigned int)(~__SOFF); }
	else {
		fp->flags |= (unsigned int)__SOFF;
		fp->offset = ret;
	}
	return (fpos_t)ret;
}
#define _sseek(fp, offset, whence)   sseek((fp), (offset), (whence))
#define __sseek(fp, offset, whence)   sseek((fp), (offset), (whence))


LIB_FUNC int sclose(const void* restrict fp) {
	return close(((const FILE*)fp)->fd);
}
#define _sclose(fp)   sclose((fp))
#define __sclose(fp)   sclose((fp))


/** Write byte to stream */
LIB_FUNC int putb(const int8_t _byte, FILE* fp) {
	if (ferror(fp)) { return EOF; }
	FLOCK(fp);
	register const int ret = (int)fp->write(fp, (const unsigned char*)&_byte, SIZEOF_CHAR);
	FUNLOCK(fp);
	if (ret) { return ret; }
	return EOF;
}
/** Write byte to stream */
#define fputb(_byte, fp)   putb((_byte), (fp))
/** Write byte to stdout */
#define putbyte(_byte)   putb(_byte, stdout)
#define putbyte_unlocked(_byte)   putb(_byte, stdout)


/** Write byte to stream */
LIB_FUNC void putb_no_output(const int8_t _byte, FILE* fp) {
	if (ferror(fp)) { return; }
	FLOCK(fp);
	(void)fp->write(fp, (const unsigned char*)&_byte, SIZEOF_CHAR);
	FUNLOCK(fp);
}


/** Write character to stream */
LIB_FUNC int putc(const int _char, FILE* fp) {
	if (ferror(fp)) { return EOF; }
	FLOCK(fp);
	register const int ret = (int)fp->write(fp, (const unsigned char*)&_char, SIZEOF_INT);
	FUNLOCK(fp);
	if (ret) { return ret; }
	return EOF;
}
/** Write character to stdout */
#define putchar(_char)   putc(_char, stdout)
#define putchar_unlocked(_char)   putc(_char, stdout)
#define outchar(_char)   putc(((_char) & 0177), stdout)


/** Write character to stream */
LIB_FUNC void putc_no_output(const int _char, FILE* fp) {
	if (ferror(fp)) { return; }
	FLOCK(fp);
	(void)fp->write(fp, (const unsigned char*)&_char, SIZEOF_INT);
	FUNLOCK(fp);
}


/** Get a character from the file stream `fp` */
LIB_FUNC int getc(FILE* fp) {
	if (ferror(fp)) { return EOF; }
	int _char = EOF;
	FLOCK(fp);
	fp->readc(fp->fd, fp->nbuf, SIZEOF_INT);
	_char = (int)*fp->nbuf;
	FUNLOCK(fp);
	return _char;
}
#define _IO_getc(fp)   getc((fp))
#define fgetc(fp)   getc((fp))
#define getc_unlocked(fp)   getc((fp))


/** Get a character from stdin */
LIB_FUNC int getchar(void) {
	if (chk_ferr(stdin)) { return EOF; }
	int c = EOF;
	FLOCK(stdin);
	stdin->readc(STDIN_FILENO, stdin->nbuf, SIZEOF_INT);
	c = (int)*stdin->nbuf;
	FUNLOCK(stdin);
	return c;
}
#define __getchar()   getchar()


/** Pause program execution until a keyboard button is pressed */
LIB_FUNC void pause(void) {
	until_break { if (getchar() != EOF) { break; } }
}


/** Display a prompt and pause program execution until the ENTER key is pressed */
LIB_FUNC void pause_prompt(void) {
	if (chk_ferr(stdout)) { return; }
	FLOCK(stdout);
	(void)__stdio_write(stdout, (const unsigned char*)"Press enter to continue: ", 25);
	FUNLOCK(stdout);
	until_break { if (getchar() != EOF) { break; } }
}


/** Display a prompt asking a yes/no question; Return "1" for "yes", "0" for "no", "-1" (or EOF) invalid input, and "-2" for I/O errors */
LIB_FUNC int prompt_yn(const char* restrict question) {
	if (chk_ferr(stdout) || chk_ferr(stdin)) { return -2; }
	else if (question == NULL) { return -1; }
	FLOCK(stdout);
	register int ch = EOF;
	do {
		(void)__stdio_write(stdout, (const unsigned char*)ANSI_SGR_FG_BCYAN , ANSI_SGR_FG_BOLD_LEN);
		(void)__stdio_write(stdout, (const unsigned char*)question, strlen(question));
		(void)__stdio_write(stdout, (const unsigned char*)" [Y/n]: " ANSI_SGR_END, (8 + ANSI_SGR_END_LEN));
		ch = getchar();
		if ((ch == 0) || (ch == 0xa) || (ch == 0xc) || (ch == 0xd)) { ch = 1; break; }
		else if ((ch < 0x20) || (ch > 0x7e)) { ch = -1; break; }
		switch (ch) {
			case 'y':
			case 'Y':
			case '1':
				ch = 1;
				break;
			case 'n':
			case 'N':
			case '0':
				ch = 0;
				break;
			default:
				if ((ch != '0' && ch != 'N' && ch != 'n' && ch != '1' && ch != 'Y' && ch != 'y') && ((ch >= 0x20) && (ch <= 0x7e))) {
					ch = 127; break;  // Ask again due to invalid letter
				} else { ch = -1; break; }
		}
	} while (ch == 127 || !((ch == EOF) || (ch == 0) || (ch == 1)));
	FUNLOCK(stdout);
	return ch;
}


/** Display a prompt asking a yes/no question with a quit option; Return "1" for "yes", "0" for "no", "-1" (or EOF) invalid input, and "-2" for I/O errors; "quit" will close the whole program */
LIB_FUNC int prompt_ynq(const char* restrict question) {
	if (chk_ferr(stdout) || chk_ferr(stdin)) { return -2; }
	else if (question == NULL) { return -1; }
	FLOCK(stdout);
	register int ch = EOF;
	do {
		(void)__stdio_write(stdout, (const unsigned char*)ANSI_SGR_FG_BCYAN , ANSI_SGR_FG_BOLD_LEN);
		(void)__stdio_write(stdout, (const unsigned char*)question, strlen(question));
		(void)__stdio_write(stdout, (const unsigned char*)" [Y/n/q]: " ANSI_SGR_END, (10 + ANSI_SGR_END_LEN));
		ch = getchar();
		if ((ch == 0) || (ch == 0xa) || (ch == 0xc) || (ch == 0xd)) { ch = 1; break; }
		else if ((ch < 0x20) || (ch > 0x7e)) { ch = -1; break; }
		switch (ch) {
			case 'y':
			case 'Y':
			case '1':
				ch = 1;
				break;
			case 'n':
			case 'N':
			case '0':
				ch = 0;
				break;
			case 'q':
			case 'Q':
				_Exit(EXIT_SUCCESS);
				break;
			default:
				if ((ch != '0' && ch != 'N' && ch != 'n' && ch != '1' && ch != 'Y' && ch != 'y' && ch != 'Q' && ch != 'q') && ((ch >= 0x20) && (ch <= 0x7e))) {
					ch = 127; break;  // Ask again due to invalid letter
				} else { ch = -1; break; }
		}
	} while (ch == 127 || !((ch == EOF) || (ch == 0) || (ch == 1)));
	FUNLOCK(stdout);
	return ch;
}


/** Read characters from the file stream and store them as a string (in str) until either `num - 1` characters have been read, a newline is read, or the end-of-file is reached (whichever happens first) */
LIB_FUNC char* fgets(char* restrict str, const int num, FILE* restrict fp) {
	register int c = EOF;
	char* s = str;
	register int _num = num;
	while (_num > 1 && ((c = getc(fp)) != EOF)) {
		*s++ = (char)c;
		--_num;
		if (c == '\n') { break; }
	}
	if ((c == EOF && s == str) || ferror(fp)) { return NULL; }
	else if (_num) { *s = '\0'; }
	return str;
}
#define fgets_unlocked(buffer, bufsiz, stream)   fgets((buffer), (bufsiz), (stream))
#define __fgets_unlocked(buffer, bufsiz, stream)   fgets((buffer), (bufsiz), (stream))


LIB_FUNC char* __fgets_chk(char* buf, int len, const size_t slen, FILE* fp) {
	if (slen >= (size_t)INT_MAX) { return fgets(buf, len, fp); }
	if (len >= 0 && (size_t)len > slen) { __chk_fail("*** fgets() terminated ***"); }
	return fgets(buf, len, fp);
}


/** Checks whether the EOF indicator associated with `fp` is set; Returns a non-zero value if the EOF indicator is set */
LIB_FUNC int feof(FILE* restrict fp) {
	if (null_fp(fp)) { return __SERR; }
	FLOCK(fp);
	register const int ret = chk_feof(fp);
	FUNLOCK(fp);
	return ret;
}
#define __FEOF(fp)   feof((fp))


/** Return the file's descriptor number */
LIB_FUNC int fileno(FILE* restrict fp) {
	return (int)(fp->fd >= 0 ? (int)fp->fd : -1);
}
#define fileno_unlocked(fp)   fileno((fp))
#define __fileno_unlocked(fp)   fileno((fp))
#define __fileno(fp)   fileno((fp))


/** Clear the file's error and EOF indicators */
LIB_FUNC void clearerr(FILE* fp) {
	FLOCK(fp);
	fp->flags &= (unsigned int)(~(__SEOF | __SERR));
	FUNLOCK(fp);
}
#define __CLEARERR(fp)   clearerr((fp))


/** Checks whether the error indicator associated with `fp` is set; Returns a non-zero value if the error indicator is set */
LIB_FUNC int ferror(FILE* restrict fp) {
	if (null_fp(fp)) { return __SERR; }
	FLOCK(fp);
	register const int ret = chk_ferr(fp);
	FUNLOCK(fp);
	return ret;
}
#define _IO_ferror_unlocked(fp)   ferror((fp))
#define ferror_unlocked(fp)   ferror((fp))
#define __FERROR(fp)   ferror((fp))


LIB_FUNC int set_flags(FILE* restrict stream, const int flags) {
	switch (flags) {
		case _IONBF:
			stream->flags = (unsigned int)(stream->flags & (unsigned int)(~(__SLBF))) | __SNBF;
			break;
		case _IOLBF:
			stream->flags = (unsigned int)(stream->flags & (unsigned int)(~(__SNBF))) | __SLBF;
			break;
		case _IOFBF:
			stream->flags = stream->flags & (unsigned int)(~(__SNBF | __SLBF));
			break;
		default: return -1;
	}
	return 0;
}


LIB_FUNC int setvbuf_unlocked(FILE* restrict stream, char* restrict buf, const int flags, const size_t size) {
	if (buf) {
		if (!(stream->flags & __SNBF)) { free(stream->buf); }
		stream->buf = (unsigned char*)buf;
	} else {
		unsigned char* tmp;
		if (!size) { return set_flags(stream, flags); }
		else if (!(tmp = malloc(size))) { return -1; }
		else if (!(stream->flags & __SNBF)) { free(stream->buf); }
		stream->buf = tmp;
	}
	stream->flags &= (unsigned int)(~__SNBF);
	stream->buf_size = size;
	return set_flags(stream, flags);
}
#define _IO_setvbuf(fp, buf, mode, size)   setvbuf_unlocked((fp), (buf), (mode), (size))
#define setvbuf(fp, buf, mode, size)   setvbuf_unlocked((fp), (buf), (mode), (size))


LIB_FUNC void setbuf(FILE* restrict fp, char* restrict buf) {
	setvbuf(fp, buf, (buf ? _IOFBF : _IONBF), BUFSIZ);
}


LIB_FUNC void setbuffer(FILE* restrict fp, char* restrict buf, const size_t size) {
	setvbuf(fp, buf, (buf ? _IOFBF : _IONBF), size);
}


LIB_FUNC void setlinebuf(FILE* restrict fp) {
	setvbuf(fp, 0, _IOLBF, 0);
}


/** Store the value of `i` to the specified destination (not type specific) */
LIB_FUNC void store_int(void* dest, const int size, const unsigned long long i) {
	if (!dest) { return; }
	switch (size) {
		case SIZE_hh:
		case BITS_PER_CHAR:
			*(char*)dest = (char)i;
			return;
		case SIZE_h:
		case BITS_PER_SHORT:
			*(short*)dest = (short)i;
			return;
		case SIZE_def:
		case BITS_PER_INT:
			*(int*)dest = (int)i;
			return;
		case SIZE_l:
			*(long*)dest = (long)i;
			return;
		case SIZE_ll:
		case BITS_PER_LONG_LONG:
			*(long long*)dest = (long long)i;
			return;
		default: return;
	}
	UNREACHABLE
}


LIB_FUNC void* arg_n(va_list ap, const unsigned int n) {
	register unsigned int i;
	va_list ap2;
	va_copy(ap2, ap);
	for (i = n; i > 1; i--) { va_arg(ap2, void*); }
	void* p = va_arg(ap2, void*);
	va_end(ap2);
	return p;
}


LIB_FUNC ATTR_NONNULL(1) size_t do_read(FILE* restrict fp, unsigned char* buf, const size_t len) {
	const UNUSED wchar_t wcstr[2] = L"@";
	if ((!(fp->wbuf[0]))) { fp->wbuf = UNCONST(wcstr); }
	register size_t i;
	for (i = 0; i < fp->wbuf_size && fp->wbuf[i]; i++) { fp->buf[i] = (unsigned char)(fp->wbuf[i] < 128 ? fp->wbuf[i] : '@'); }
	fp->rpos = fp->buf;
	fp->rend = fp->buf + i;
	fp->wbuf = (wchar_t*)(fp->wbuf + i);
	if (i && len) { *buf = *fp->rpos++; return 1; }
	return 0;
}


LIB_FUNC ATTR_NONNULL(1) size_t do_read_helper(void* restrict fp, unsigned char* buf, const size_t len) {
	return do_read((FILE*)fp, buf, len);
}


LIB_FUNC size_t string_read(FILE* fp, unsigned char* buf, const size_t len) {
	register size_t k = len + 256;
	fp->buf_size = len;
	char* end = memchr_nonconst(fp->buf, 0, k);
	if (end) { k = (size_t)(end - (char*)fp->buf); }
	if (k < fp->buf_size) { fp->buf_size = k; }
	memcpy_no_output(buf, fp->buf, fp->buf_size);
	fp->rpos = (void*)(fp->buf + fp->buf_size);
	fp->rend = (void*)(fp->buf + k);
	fp->buf = fp->buf + k;
	return fp->buf_size;
}


/**
@brief Reads data from the stream and stores them according to parameter `fmt` into the locations pointed by the elements in the variable argument list identified by `ap`

@section Defines
 - NO_SCAN_FLOATS: The `f` and `g` (float-points) symbols are disabled
*/
LIB_FUNC int vfscanf(FILE* restrict f, const char* restrict fmt, va_list ap) {
	int width, size, alloc, base, c, t, invert, matches = 0;
	const unsigned char* p;
	char* s = 0;
	wchar_t* wcs = 0;
	mbstate_t st;
	void* dest = NULL;
	unsigned long long x;
#   ifndef NO_SCAN_FLOATS
	long double y;
#   endif
	register off_t pos = 0;
	unsigned char scanset[257] = { 0 };
	size_t i, k;
	wchar_t wc;
	FLOCK(f);
	for (p = (const unsigned char*)fmt; *p; p++) {
		alloc = 0;
		if (isspace(*p)) {
			while (isspace(p[1])) { p++; }
			shlim(f, 0);
			while (isspace(shgetc(f)));
			shunget(f);
			pos += shcnt(f);
			continue;
		} else if (*p != '%' || p[1] == '%') {
			p += (*p == '%');
			shlim(f, 0);
			c = shgetc(f);
			if (c != *p) {
				shunget(f);
				if (c < 0) { goto goto_input_fail; }
				goto goto_match_fail;
			}
			++pos;
			continue;
		}
		++p;
		if (*p == '*') { dest = 0; p++; }
		else if (isdigit(*p) && p[1] == '$') { dest = arg_n(ap, (unsigned int)(*p - '0')); p += 2; }
		else { dest = va_arg(ap, void*); }
		for (width = 0; isdigit(*p); p++) { width = (10 * width + *p - '0'); }
		if (*p == 'm') {
			wcs = 0;
			s = 0;
			alloc = !!dest;
			++p;
		} else { alloc = 0; }
		size = SIZE_def;
		switch (*p++) {
			case 'h':
				if (*p == 'h') { ++p; size = SIZE_hh; }
				else { size = SIZE_h; }
				break;
			case 'l':
				if (*p == 'l') { ++p; size = SIZE_ll; }
				else { size = SIZE_l; }
				break;
			case 'j':
				size = SIZE_ll;
				break;
			case 'z':
			case 't':
				size = SIZE_l;
				break;
			case 'L':
				size = SIZE_L;
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 's':
			case 'c':
			case '[':
			case 'S':
			case 'C':
			case 'p':
			case 'n':
				--p;
				break;
			default: goto goto_fmt_fail;
		}
		t = *p;
		if ((t & 0x2f) == 3) {
			t |= 32;
			size = SIZE_l;
		}
		switch (t) {
			case 'c':
				if (width < 1) { width = 1; }
			case '[':
				break;
			case 'n':
				store_int(dest, size, (unsigned long long)pos);
				continue;
			default:
				shlim(f, 0);
				while (isspace(shgetc(f)));
				shunget(f);
				pos += shcnt(f);
		}
		shlim(f, width);
		if (shgetc(f) < 0) { goto goto_input_fail; }
		shunget(f);
		switch (t) {
			case 's':
			case 'c':
			case '[':
				if (t == 'c' || t == 's') {
					memset_no_output(scanset, -1, sizeof(scanset));
					scanset[0] = 0;
					if (t == 's') {
						scanset[1 + '\t'] = 0;
						scanset[1 + '\n'] = 0;
						scanset[1 + '\v'] = 0;
						scanset[1 + '\f'] = 0;
						scanset[1 + '\r'] = 0;
						scanset[1 + ' '] = 0;
					}
				} else {
					if (*++p == '^') { p++, invert = 1; }
					else { invert = 0; }
					memset_no_output(scanset, invert, sizeof(scanset));
					scanset[0] = 0;
					if (*p == '-') { ++p; scanset[1 + '-'] = (unsigned char)(1 - invert); }
					else if (*p == ']') { ++p; scanset[1 + ']'] = (unsigned char)(1 - invert); }
					for (; *p != ']'; p++) {
						if (!*p) { goto goto_fmt_fail; }
						else if (*p == '-' && p[1] && p[1] != ']') {
							for (c = p++[-1]; c < *p; c++) { scanset[1 + c] = (unsigned char)(1 - invert); }
						}
						scanset[1 + *p] = (unsigned char)(1 - invert);
					}
				}
				wcs = 0;
				s = 0;
				i = 0;
				k = (size_t)(t == 'c' ? ((unsigned int)width + 1U) : 31);
				if (size == SIZE_l) {
					if (alloc) {
						wcs = malloc(k * SIZEOF_WCHAR_T);
						if (!wcs) { goto goto_alloc_fail; }
					} else { wcs = dest; }
					st = (mbstate_t) { 0 };
					while (scanset[(c = shgetc(f)) + 1]) {
						switch (mbrtowc(&wc, (char*)&c, 1, &st)) {
							case (size_t)-1: goto goto_input_fail;
							default: continue;
						}
						if (wcs) { wcs[i++] = wc; }
						if (alloc && i == k) {
							k += (k + 1);
							wchar_t* tmp = realloc(wcs, (k * SIZEOF_WCHAR_T));
							if (!tmp) { goto goto_alloc_fail; }
							wcs = tmp;
						}
					}
					if (!mbsinit(&st)) { goto goto_input_fail; }
				} else if (alloc) {
					s = malloc(k);
					if (!s) { goto goto_alloc_fail; }
					while (scanset[(c = shgetc(f)) + 1]) {
						s[i++] = (char)c;
						if (i == k) {
							k += (k + 1);
							char* tmp = realloc(s, k);
							if (!tmp) { goto goto_alloc_fail; }
							s = tmp;
						}
					}
				} else if ((s = dest)) { while (scanset[(c = shgetc(f)) + 1]) { s[i++] = (char)c; } }
				else { while (scanset[(c = shgetc(f)) + 1]); }
				shunget(f);
				if (!shcnt(f)) { goto goto_match_fail; }
				else if (t == 'c' && shcnt(f) != width) { goto goto_match_fail; }
				else if (alloc) {
					if (size == SIZE_l) { *(wchar_t**)dest = wcs; }
					else { *(char**)dest = s; }
				}
				if (t != 'c') {
					if (wcs) { wcs[i] = 0; }
					if (s) { s[i] = 0; }
				}
				break;
			case 'p':
			case 'X':
			case 'x':
				base = 16;
				goto goto_int_common;
			case 'o':
				base = 8;
				goto goto_int_common;
			case 'd':
			case 'u':
				base = 10;
				goto goto_int_common;
			case 'i':
				base = 0;
goto_int_common:
				x = intscan(f, (unsigned int)base, 0, ULLONG_MAX);
				if (!shcnt(f)) { goto goto_match_fail; }
				if (t == 'p' && dest) { *(void**)dest = (void*)(uintptr_t)x; }
				else { store_int(dest, size, x); }
				break;
#   ifndef NO_SCAN_FLOATS
			case 'a':
			case 'A':
			case 'e':
			case 'E':
			case 'f':
			case 'F':
			case 'g':
			case 'G':
				y = __floatscan(f, size, 0);
				if (!shcnt(f)) { goto goto_match_fail; }
				else if (dest) {
					switch (size) {
						case SIZE_def: *(float*)dest = (float)y; break;
						case SIZE_l: *(double*)dest = (double)y; break;
						case SIZE_L: *(long double*)dest = (long double)y; break;
						default: goto goto_match_fail;
					}
				}
				break;
#   endif
			default: goto goto_match_fail;
		}
		pos += shcnt(f);
		if (dest) { ++matches; }
	}
	if (0) {
goto_fmt_fail:
goto_alloc_fail:
goto_input_fail:
		if (!matches) { --matches; }
goto_match_fail:
		if (alloc) {
			free(s);
			free(wcs);
		}
	}
	FUNLOCK(f);
	return matches;
}
#define __isoc99_vfscanf(f, fmt, ap)   vfscanf((f), (fmt), (ap))
#define isoc99_vfscanf(f, fmt, ap)   vfscanf((f), (fmt), (ap))


/** Reads data from the stream and stores them according to the parameter `format` into the locations pointed by the additional arguments */
LIB_FUNC int fscanf(FILE* stream, const char* format, ...) {
	va_list args;
	va_start(args, format);
	const int retval = vfscanf(stream, format, args);
	va_end(args);
	return retval;
}
#define __isoc99_fscanf(stream, format, ...)   fscanf((stream), (format), (__VA_ARGS__))
#define isoc99_fscanf(stream, format, ...)   fscanf((stream), (format), (__VA_ARGS__))


/** Reads data from the standard input (stdin) and stores them according to parameter `format` into the locations pointed by the elements in the variable argument list identified by `args` */
LIB_FUNC int vscanf(const char* format, va_list args) {
	return vfscanf(stdin, format, args);
}
#define __isoc99_vscanf(format, args)   vscanf((format), (args))
#define isoc99_vscanf(format, args)   vscanf((format), (args))


/** Reads data from stdin and stores them according to the parameter `format` into the locations pointed by the additional arguments */
LIB_FUNC int scanf(const char* format, ...) {
	va_list args;
	va_start(args, format);
	const int retval = vfscanf(stdin, format, args);
	va_end(args);
	return retval;
}
#define __isoc99_scanf(format, ...)   scanf((format), (__VA_ARGS__))
#define isoc99_scanf(format, ...)   scanf((format), (__VA_ARGS__))


DIAG_PUSH
IGNORE_WSTACK_PROTECTOR


/** Reads data from s and stores them according to parameter `fmt` into the locations pointed by the elements in the variable argument list identified by `ap` */
LIB_FUNC int vsscanf(char* restrict s, const char* restrict fmt, va_list ap) {
	FILE f = {
		.buf = (void*)s,
		.read = &do_read_helper,
		.lock = -1
	};
	return vfscanf(&f, fmt, ap);
}
#define __isoc99_vsscanf(s, fmt, ap)   vsscanf((s), (fmt), (ap))
#define isoc99_vsscanf(s, fmt, ap)   vsscanf((s), (fmt), (ap))


DIAG_POP


/** Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin) */
LIB_FUNC int sscanf(char* restrict s, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vsscanf(s, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_sscanf(s, fmt, ...)   sscanf((s), (fmt), (__VA_ARGS__))
#define isoc99_sscanf(s, fmt, ...)   sscanf((s), (fmt), (__VA_ARGS__))


LIB_FUNC int ungetc(const int c, FILE* fp) {
	if (c == EOF) { return c; }
	FLOCK(fp);
	if (!fp->rpos) { __toread(fp); }
	if (!fp->rpos || fp->rpos <= (fp->buf - UNGET)) {
		FUNLOCK(fp);
		return EOF;
	}
	*--fp->rpos = (unsigned char)c;
	fp->flags &= (unsigned int)(~__SEOF);
	FUNLOCK(fp);
	return c;
}


#define putc_unlocked(c, f)   ((((unsigned char)(c) != (f)->lbf) && ((f)->wpos < (f)->wend)) ? *(f)->wpos++ = (unsigned char)(c) : __overflow((f), (int)(c)))
#define fputc_unlocked(c, f)   putc_unlocked((f), (c))
#define _IO_putc_unlocked(c, f)   putc_unlocked((f), (c))


/** Write the given string to the given file */
LIB_FUNC NONNULL int fputs(const char* restrict s, FILE* restrict fp) {
	if (ferror(fp)) { return EOF; }
	register const size_t nmemb = strlen(s);
	FLOCK(fp);
	register const size_t size_written = __stdio_write(fp, (const unsigned char*)s, nmemb);
	const int r = -((((size_written == nmemb ? nmemb : size_written) == nmemb) - 1) || (putc_unlocked(fp->lbf, fp) < 0));
	FUNLOCK(fp);
	return r;
}


LIB_FUNC NONNULL int fputs_unlocked(register const char* restrict s, FILE* restrict stream) {
	register const size_t n = strlen(s);
	return ((fwrite_unlocked(s, 1, n, stream) == n) ? (int)n : (int)EOF);
}


/** Write string to stdout */
LIB_FUNC int puts(const char* restrict src) {
	if (ferror(stdout)) { return EOF; }
	register const size_t nmemb = strlen(src);
	FLOCK(stdout);
	register const size_t size_written = (size_t)__write_stdout(src, nmemb);
	const int r = -((((size_written == nmemb ? nmemb : size_written) == nmemb) - 1) || (putc_unlocked(stdout->lbf, stdout) < 0));
	FUNLOCK(stdout);
	return r;
}


/** Write string to stdout without a newline */
LIB_FUNC int puts2(const char* restrict src) {
	if (ferror(stdout)) { return EOF; }
	register const size_t nmemb = strlen(src);
	FLOCK(stdout);
	register const size_t size_written = (size_t)__write_stdout(src, nmemb);
	const int r = -(((size_written == nmemb ? nmemb : size_written) == nmemb) - 1);
	FUNLOCK(stdout);
	return r;
}


/** Write string to stdout and do not return any value */
LIB_FUNC void puts_no_output(const char* restrict src) {
	if (ferror(stdout)) { return; }
	FLOCK(stdout);
	(void)__write_stdout(src, strlen(src));
	(void)__write_stdout((const char*)&stdout->lbf, 1);
	FUNLOCK(stdout);
}


/** Write string to stderr */
LIB_FUNC int puts_err(const char* src) {
	if (ferror(stderr)) { return EOF; }
	register const size_t nmemb = strlen(src);
	FLOCK(stderr);
	register const size_t size_written = (size_t)__write_stderr(src, nmemb);
	const int r = -((((size_written == nmemb ? nmemb : size_written) == nmemb) - 1) || (putc_unlocked(stderr->lbf, stderr) < 0));
	FUNLOCK(stderr);
	return r;
}


/** Write string to stderr and do not return any value */
LIB_FUNC void puts_err_no_output(const char* src) {
	if (ferror(stderr)) { return; }
	FLOCK(stderr);
	(void)__write_stderr(src, strlen(src));
	(void)__write_stderr((const char*)&stderr->lbf, 1);
	FUNLOCK(stderr);
}


/** Print an integer to stdout as a string */
LIB_FUNC void puti(const int num) {
	if (ferror(stdout)) { return; }
	char align32 puti_tmpbuf[__UIM_BUFLEN_INT + 2] = { 0 };
	char* restrict p = puti_tmpbuf;
	register int i = num;
	if (num < 0) { *p++ = '-'; i = -i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = stdout->lbf;
	const size_t len = (size_t)(1 + (size_t)p - (size_t)&puti_tmpbuf);
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	FLOCK(stdout);
	(void)__write_stdout(puti_tmpbuf, len);
	FUNLOCK(stdout);
}


/** Print a signed 64-bit integer to stdout as a string */
LIB_FUNC void puti64(const int64_t num) {
	if (ferror(stdout)) { return; }
	char align64 tmpbuf[__UIM_BUFLEN_INT64 + 2] = { 0 };
	char* restrict p = tmpbuf;
	register int64_t i = num;
	if (num < 0) { *p++ = '-'; i = -i; }
	register uint64_t shifter = (uint64_t)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = stdout->lbf;
	const size_t len = (size_t)(1 + (size_t)p - (size_t)&tmpbuf);
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	FLOCK(stdout);
	(void)__write_stdout((const char*)tmpbuf, len);
	FUNLOCK(stdout);
}


/** Print an unsigned 64-bit integer to stdout as a string */
LIB_FUNC void putu64(const uint64_t num) {
	if (ferror(stdout)) { return; }
	char align64 tmpbuf[__UIM_BUFLEN_UINT64 + 2] = { 0 };
	char* restrict p = tmpbuf;
	register uint64_t i = num;
	register uint64_t shifter = i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = stdout->lbf;
	const size_t len = (size_t)(1 + (size_t)p - (size_t)&tmpbuf);
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	FLOCK(stdout);
	(void)__write_stdout((const char*)tmpbuf, len);
	FUNLOCK(stdout);
}


LIB_FUNC ssize_t getdelim(char** restrict s, size_t* restrict n, const int delim, FILE* restrict fp) {
	char* tmp;
	unsigned char* z;
	size_t k, i = 0;
	int c;
	FLOCK(fp);
	if (!n || !s) {
		fp->flags |= (unsigned int)__SERR;
		FUNLOCK(fp);
		set_errno(EINVAL);
		return -1;
	}
	if (!*s) { *n = 0; }
	loop_forever {
		z = (unsigned char*)memchr_nonconst(fp->rpos, delim, (size_t)(fp->rend - fp->rpos));
		k = (size_t)(z ? (z - fp->rpos + 1) : (fp->rend - fp->rpos));
		if ((i + k + 1) >= *n) {
			if (k >= SIZE_MAX / 2 - i) { goto goto_getdelim_oom; }
			size_t m = (i + k + 2);
			if (!z && (m < (SIZE_MAX / 4))) { m += (size_t)(m / 2); }
			tmp = realloc(*s, m);
			if (!tmp) {
				m = i + k + 2;
				tmp = realloc(*s, m);
				if (!tmp) { goto goto_getdelim_oom; }
			}
			*s = tmp;
			*n = m;
		}
		memcpy_no_output(*s + i, fp->rpos, k);
		fp->rpos += k;
		i += k;
		if (z) { break; }
		else if ((c = getc_unlocked(fp)) == EOF) {
			if (!i || (!feof(fp))) {
				FUNLOCK(fp);
				return -1;
			}
			break;
		}
		if (((*s)[i++] = (char)c) == delim) { break; }
	}
	(*s)[i] = 0;
	FUNLOCK(fp);
	return (ssize_t)i;
goto_getdelim_oom:
	fp->flags |= (unsigned int)__SERR;
	FUNLOCK(fp);
	set_errno(ENOMEM);
	return -1;
}
#define __getdelim(s, n, delim, fp)   getdelim((s), (n), (delim), (fp))


LIB_FUNC ssize_t getline(char** restrict s, size_t* restrict n, FILE* restrict fp) {
	return getdelim(s, n, '\n', fp);
}


LIB_FUNC int __toread(FILE* fp) {
	fp->mode |= (int)(fp->mode - 1);
	if (fp->wpos > fp->buf) { fp->write(fp, 0, 0); }
	fp->wpos = fp->wbase = fp->wend = 0;
	if (cantread(fp)) {
		fp->flags |= (unsigned int)__SERR;
		return EOF;
	}
	fp->rpos = fp->rend = (fp->buf + fp->buf_size);
	return (chk_feof(fp) ? EOF : 0);
}


LIB_FUNC int __uflow(FILE* fp) {
	unsigned char c;
	if (!__toread(fp) && fp->read(fp, &c, 1) == 1) { return c; }
	return EOF;
}


LIB_FUNC int dup3(const int old, const int new, const int flags) {
	long r;
#   ifdef SYS_dup2
	if (old == new) { set_errno(EINVAL); return -1; }
	else if (flags & O_CLOEXEC) {
		while (r = syscall3(SYS_dup3, old, new, flags), eq_errno(EBUSY));
		if (neq_errno(ENOSYS) && is_errno_not_zero()) { return -1; }
	}
	while (r = syscall2(SYS_dup2, old, new), eq_errno(EBUSY));
	if (flags & O_CLOEXEC) { r = syscall3(SYS_fcntl, (long)new, F_SETFD, FD_CLOEXEC); }
#   else
	while ((r = syscall3(SYS_dup3, (long)old, (long)new, (long)flags)), eq_errno(EBUSY));
#   endif
	return (int)r;
}
#define __dup3(old, new, flags)   dup3((old), (new), (flags))


LIB_FUNC ssize_t readlink(const char* restrict path, char* restrict buf, size_t bufsize) {
#   ifdef SYS_readlink
	return (ssize_t)syscall3(SYS_readlink, (long)path, (long)buf, (long)bufsize);
#   else
	return (ssize_t)syscall4(SYS_readlinkat, AT_FDCWD, (long)path, (long)buf, (long)bufsize);
#   endif
}


LIB_FUNC ssize_t readlinkat(const int fd, const char* restrict path, char* restrict buf, const size_t bufsize) {
	return (ssize_t)syscall4(SYS_readlinkat, fd, (long)path, (long)buf, (long)bufsize);
}


LIB_FUNC int symlink(const char* existing, const char* new) {
#   ifdef SYS_symlink
	return (int)syscall2(SYS_symlink, (long)existing, (long)new);
#   else
	return (int)syscall3(SYS_symlinkat, (long)existing, AT_FDCWD, (long)new);
#   endif
}
#define __symlink(from, to)   symlink((from), (to))


LIB_FUNC int symlinkat(const char* existing, const int fd, const char* new) {
	return (int)syscall3(SYS_symlinkat, (long)existing, fd, (long)new);
}


LIB_FUNC int unlink(const char* path) {
#   ifdef SYS_unlink
	return (int)syscall1(SYS_unlink, (long)path);
#   else
	return (int)syscall3(SYS_unlinkat, AT_FDCWD, (long)path, 0);
#   endif
}
#define __unlink(buf)   unlink((buf))


LIB_FUNC int unlinkat(const int fd, const char* path, const int flag) {
	return (int)syscall3(SYS_unlinkat, fd, (long)path, flag);
}


LIB_FUNC int link(const char* existing, const char* new) {
#   ifdef SYS_link
	return (int)syscall2(SYS_link, (long)existing, (long)new);
#   else
	return (int)syscall5(SYS_linkat, AT_FDCWD, (long)existing, AT_FDCWD, (long)new, 0);
#   endif
}


LIB_FUNC int linkat(const int fd1, const char* existing, const int fd2, const char* new, const int flag) {
	return (int)syscall5(SYS_linkat, fd1, (long)existing, fd2, (long)new, flag);
}


/** Opens the file (given by the file descriptor) and associates a stream to the file */
LIB_FUNC FILE* fdopen(const int fd, const char* mode) {
	FILE* f;
	struct winsize wsz;
	// Check for valid initial mode character
	if (!strchr("rwa", *mode)) {
		set_errno(EINVAL);
		return 0;
	}
	// Allocate FILE+buffer or fail
	if (!(f = malloc(sizeof(*f) + UNGET + BUFSIZ))) { return 0; }
	// Zero-fill only the struct, not the buffer
	memset_no_output(f, 0, sizeof(*f));
	// Impose mode restrictions
	if (!strchr(mode, '+')) { f->flags = (unsigned int)((*mode == 'r') ? __SRD : __SWR); }
	// Apply close-on-exec flag
	if (strchr(mode, 'e')) { syscall3(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC); }
	// Set append mode on fd if opened for append
	if (*mode == 'a') {
		int flags = (int)syscall2(SYS_fcntl, fd, F_GETFL);
		if (!(flags & O_APPEND)) { syscall3(SYS_fcntl, fd, F_SETFL, (flags | O_APPEND)); }
		f->flags |= (unsigned int)__SAPP;
	}
	f->fd = fd;
	f->buf = (unsigned char*)f + sizeof(*f) + UNGET;
	f->buf_size = BUFSIZ;
	// Activate line buffered mode for terminals
	f->lbf = EOF;
	long wsz_addr = (long)(&wsz);
	if (cantwrite(f) && (!syscall3(SYS_ioctl, fd, TIOCGWINSZ, (long)wsz_addr))) { f->lbf = '\n'; }
	// Initialize op ptrs
	f->read = &__stdio_read_helper;
	f->write = &__stdio_write_helper;
	f->seek = &__stdio_seek_helper;
	f->close = &__stdio_close_helper;
	if (!libc.threaded) { f->lock = -1; }
	return ofl_add(f);
}
#define _fdopen(fd, m)   fdopen((fd), (m))
#define __fdopen(fd, m)   fdopen((fd), (m))
#define _IO_fdopen(fd, m)   fdopen((fd), (m))


/** Opens the file (given by the string) and associates a stream to the file */
LIB_FUNC FILE* fopen(const char* restrict filename, const char* restrict mode) {
	FILE* f;
	if (!(strchr("rwa", *mode))) { set_errno(EINVAL);; return 0; }
	const int flags = fmodeflags(mode);
	int fd = (int)syscall3(SYS_open, (long)filename, (long)flags, (long)0666);
	if (fd < 0) { return 0; }
	else if (flags & O_CLOEXEC) { syscall3(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC); }
	f = fdopen(fd, mode);
	if (f) { return f; }
	syscall1(SYS_close, fd);
	return 0;
}
#define fopen64(filename, mode)   fopen((filename), (mode))
#define _IO_fopen(filename, mode)   fopen((filename), (mode))
#define _fopen(filename, mode)   fopen((filename), (mode))
#define __fopen(filename, mode)   fopen((filename), (mode))


/** Close a stream */
LIB_FUNC int fclose(FILE* fp) {
	int r, perm;
	FLOCK(fp);
	unlist_locked_file(fp);
	if (!(perm = (int)(fp->flags & (unsigned int)__SLBF))) {
		FILE** head = ofl_lock();
		if (fp->prev_locked) { fp->prev_locked->next_locked = fp->next_locked; }
		if (fp->next_locked) { fp->next_locked->prev_locked = fp->prev_locked; }
		if (*head == fp) { *head = fp->next_locked; }
		UNLOCK(memlock);
	}
	r = fflush(fp);
	r |= fp->close(fp);
	if (fp->lb_base) { free(fp->lb_base); }
	if (!perm) { free(fp); }
	else { FUNLOCK(fp); }
	return r;
}


LIB_FUNC int __fclose_ca(FILE* fp) {
	return fp->close(fp);
}


/** Reuses stream to either open the file specified by filename or to change its access mode */
LIB_FUNC FILE* freopen(const char* restrict filename, const char* restrict mode, FILE* restrict fp) {
	int _fl = fmodeflags(mode);
	FLOCK(fp);
	fflush(fp);
	if (!filename) {
		if (_fl & O_CLOEXEC) { syscall3(SYS_fcntl, fp->fd, F_SETFD, FD_CLOEXEC); }
		_fl &= (int)(~(O_CREAT | O_EXCL | O_CLOEXEC));
		if (syscall3(SYS_fcntl, fp->fd, F_SETFL, _fl) < 0) { fclose(fp); return NULL; }
	} else {
		FILE* fp2 = fopen(filename, mode);
		if (!fp2) { fclose(fp); return NULL; }
		else if (fp2->fd == fp->fd) { fp2->fd = -1; }
		else if ((__dup3(fp2->fd, fp->fd, (_fl & O_CLOEXEC)) < 0)) { fclose(fp2); fclose(fp); return NULL; }
		fp->flags = (unsigned int)((fp->flags & (unsigned int)__SLBF) | (unsigned int)fp2->flags);
		fp->read = fp2->read;
		fp->write = fp2->write;
		fp->seek = fp2->seek;
		fp->close = fp2->close;
		fclose(fp2);
	}
	FUNLOCK(fp);
	return fp;
}
#define freopen64(filename, mode, fp)   freopen((filename), (mode), (fp))


LIB_FUNC FILE* funopen(void* stream, size_t (*readfn)(void*, unsigned char*, const size_t), size_t (*writefn)(void*, const unsigned char*, const size_t), off_t (*seekfn)(void*, const off_t, const int), int (*closefn)(void*)) {
	FILE* restrict fp = { 0 };
	register int flags;
	if (readfn == NULL) {
		if (writefn == NULL) { set_errno(EINVAL);; return NULL; }  // Illegal
		else { flags = __SWR; }  // Write-only
	} else {
		if (writefn == NULL) { flags = __SRD; }  // Read-only
		else { flags = __SRW; }  // Read-write
	}
	fp->flags = (unsigned int)flags;
	fp->fd = -1;
	fp->buf = (unsigned char*)stream;
	fp->read = readfn;
	fp->write = writefn;
	fp->seek = seekfn;
	fp->close = closefn;
	return fp;
}
#define fropen(stream, fn)   funopen((stream), (fn), (0), (0), (0))
#define fwopen(stream, fn)   funopen((stream), (0), (fn), (0), (0))


LIB_FUNC void __stdio_exit(void) {
	FILE* fp;
	for (fp = *ofl_lock(); fp; fp = fp->next_locked) { __stdio_close(fp); }
	__stdio_close(STDIN);
	__stdio_close(STDOUT);
}
#define stdio_exit()   __stdio_exit()
#define __stdio_exit_needed()   __stdio_exit()
#define stdio_exit_needed()   __stdio_exit()
#define __toread_needs_stdio_exit()   __stdio_exit()
#define __towrite_needs_stdio_exit()   __stdio_exit()


LIB_FUNC int __aio_close(const int fd) {
	return fd;
}


LIB_FUNC int __stdio_close(FILE* fp) {
	return (int)syscall1(SYS_close, __aio_close(fp->fd));
}
#define close_file(fp)   __stdio_close((fp))
#define stdio_close(fp)   __stdio_close((fp))


LIB_FUNC int __stdio_close_helper(void* fp) {
	return __stdio_close((FILE*)fp);
}


LIB_FUNC off_t __stdio_seek(FILE* fp, const off_t off, const int whence) {
	off_t ret;
#   ifdef SYS__llseek
	if (syscall5(SYS__llseek, (long)fp->fd, (long)(off >> 32), (long)off, (long)&ret, whence) < 0) { ret = -1; }
#   else
	ret = (off_t)syscall3(SYS_lseek, fp->fd, (long)off, whence);
#   endif
	return ret;
}


LIB_FUNC off_t __stdio_seek_helper(void* fp, const off_t off, const int whence) {
	return __stdio_seek((FILE*)fp, off, whence);
}


LIB_FUNC ATTR_NONNULL(2) size_t __stdio_read(FILE* fp, unsigned char* buf, const size_t len) {
	const struct iovec align32 iov[2] = { { .iov_base = buf, .iov_len = len - (!!(fp->buf_size)) }, { .iov_base = fp->buf, .iov_len = fp->buf_size } };
	register ssize_t cnt = (ssize_t)syscall3(SYS_readv, fp->fd, (long)iov, 2);
	if (cnt <= 0) { fp->flags |= (unsigned int)(__SEOF ^ ((__SERR ^ __SEOF) & cnt)); return (size_t)cnt; }
	else if ((size_t)cnt <= iov[0].iov_len) { return (size_t)cnt; }
	cnt -= (ssize_t)iov[0].iov_len;
	fp->rpos = fp->buf;
	fp->rend = (fp->buf + cnt);
	if (fp->buf_size) { buf[len - 1] = *fp->rpos++; }
	return len;
}


LIB_FUNC ATTR_NONNULL(2) size_t __stdio_read_helper(void* fp, unsigned char* buf, const size_t len) {
	return __stdio_read((FILE*)fp, buf, len);
}


LIB_FUNC ATTR_NONNULL(2) ssize_t __stdio_readc_helper(const int fd, unsigned char* restrict buf, const size_t len) {
	return read(fd, buf, len);
}


LIB_FUNC ATTR_NONNULL(1) size_t __stdio_write(FILE* fp, const unsigned char* buf, const size_t len) {
	struct iovec align32 iovs[2] = { { .iov_base = fp->wbase, .iov_len = (unsigned long)(fp->wpos - fp->wbase) }, { .iov_base = (const void*)buf, .iov_len = len } };
	struct iovec* iov = iovs;
	register size_t rem = iov[0].iov_len + iov[1].iov_len;
	register int iovcnt = 2;
	register ssize_t cnt;
	loop_forever {
		cnt = (ssize_t)syscall3(SYS_writev, fp->fd, (long)iov, (long)iovcnt);
		if ((size_t)cnt == rem) {
			fp->wend = (fp->buf + fp->buf_size);
			fp->wpos = fp->wbase = fp->buf;
			return len;
		} else if (cnt < 0) {
			fp->wpos = fp->wbase = fp->wend = 0;
			fp->flags |= (unsigned int)__SERR;
			return (iovcnt == 2 ? 0 : (len - iov[0].iov_len));
		}
		rem -= (size_t)cnt;
		if ((size_t)cnt > iov[0].iov_len) { cnt -= (ssize_t)iov[0].iov_len; iov++; iovcnt--; }
		iov[0].iov_base = (const char*)iov[0].iov_base + cnt;
		iov[0].iov_len -= (unsigned long)cnt;
	}
}


LIB_FUNC ATTR_NONNULL(1) size_t __stdio_write_helper(void* fp, const unsigned char* buf, const size_t len) {
	return __stdio_write((FILE*)fp, buf, len);
}


LIB_FUNC NONNULL size_t __stdout_write(UNUSED FILE* fp, const unsigned char* restrict buf, const size_t len) {
	fp->write = &__stdio_write_helper;
	return (size_t)syscall3(SYS_write, STDOUT_FILENO, (long)buf, (long)len);
}


LIB_FUNC NONNULL size_t __stdout_write_helper(UNUSED void* fp, const unsigned char* restrict buf, const size_t len) {
	return (size_t)syscall3(SYS_write, STDOUT_FILENO, (long)buf, (long)len);
}


/** Sets the position indicator associated with stream to the beginning of the file */
LIB_FUNC void rewind(FILE* f) {
	FLOCK(f);
	fseeko_unlocked(f, 0, SEEK_SET);
	f->flags &= (unsigned int)(~__SERR);
	FUNLOCK(f);
}


LIB_FUNC NOLIBCALL ATTR_PF int fmodeflags(const char* restrict mode) {
	register int flags;
	if (strchr(mode, '+')) { flags = O_RDWR; }
	else if (*mode == 'r') { flags = O_RDONLY; }
	else { flags = O_WRONLY; }
	if (strchr(mode, 'x')) { flags |= O_EXCL; }
	if (strchr(mode, 'e')) { flags |= O_CLOEXEC; }
	if (*mode != 'r') { flags |= O_CREAT; }
	if (*mode == 'w') { flags |= O_TRUNC; }
	if (*mode == 'a') { flags |= O_APPEND; }
	return flags;
}
#define __fmodeflags(mode)   fmodeflags((mode))


LIB_FUNC int fseeko_unlocked(FILE* f, off_t off, const int whence) {
	if (whence == SEEK_CUR) { off -= f->rend - f->rpos; }
	if (f->wpos > f->wbase) {  // Flush write buffer, and report error on failure
		f->write(f, 0, 0);
		if (!f->wpos) { return -1; }
	}
	f->wpos = f->wbase = f->wend = 0;  // Leave writing mode
	if (f->seek(f, off, whence) < 0) { return -1; }  // Perform the underlying seek
	f->rpos = f->rend = 0;  // If seek succeeded, file is seekable and we discard read buffer
	f->flags &= (unsigned int)(~__SEOF);
	return 0;
}
#define __fseeko_unlocked(f, off, whence)   fseeko_unlocked((f), (off), (whence))


LIB_FUNC int fseeko(FILE* f, off_t off, const int whence) {
	FLOCK(f);
	const int result = fseeko_unlocked(f, off, whence);
	FUNLOCK(f);
	return result;
}
#define __fseeko(f, off, whence)   fseeko((f), (off), (whence))
#define __fseeko64(f, off, whence)   fseeko((f), (off), (whence))
#define fseeko64(f, off, whence)   fseeko((f), (off), (whence))


/** Sets the file position indicator to the desired point */
LIB_FUNC int fseek(FILE* f, long off, const int whence) {
	return fseeko(f, off, whence);
}
#define __fseek(f, off, whence)   fseek((f), (off), (whence))
#define __fseek64(f, off, whence)   fseek((f), (off), (whence))
#define fseek64(f, off, whence)   fseek((f), (off), (whence))


/** Get the current file position */
LIB_FUNC int fgetpos(FILE* restrict f, fpos_t* restrict pos) {
	const off_t off = ftello(f);
	if (off < 0) { return -1; }
	*(off_t*)pos = off;
	return 0;
}
#define fgetpos64(f, pos)   fgetpos((f), (pos))


/** Set the current file position */
LIB_FUNC int fsetpos(FILE* f, const fpos_t* pos) {
	return __fseeko(f, *(const off_t*)pos, SEEK_SET);
}
#define fsetpos64(f, pos)   fsetpos((f), (pos))


LIB_FUNC off_t __ftello_unlocked(FILE* f) {
	const off_t pos = f->seek(f, 0, ((f->flags & __SAPP) && f->wpos > f->wbase ? SEEK_END : SEEK_CUR));
	if (pos < 0) { return pos; }
	return (off_t)(pos - (f->rend - f->rpos) + (f->wpos - f->wbase));
}


/** Returns the current value of the file position indicator */
LIB_FUNC off_t ftello(FILE* f) {
	FLOCK(f);
	const off_t pos = __ftello_unlocked(f);
	FUNLOCK(f);
	return pos;
}
#define __ftello(f)   ftello((f))
#define __ftello64(f)   ftello((f))
#define ftello64(f)   ftello((f))


/** Returns the current value of the file position indicator */
LIB_FUNC long ftell(FILE* f) {
	const off_t pos = ftello(f);
	if (pos > LONG_MAX) {
		set_errno(EOVERFLOW);
		return -1;
	}
	return pos;
}


/** Set and determine the orientation of a FILE stream */
LIB_FUNC int fwide(FILE* fp, const int mode) {
	register int _mode = mode;
	FLOCK(fp);
	if (_mode == _O_BINARY) { fp->mode = _O_BYTE; }
	else if (_mode) { if (!fp->mode) { fp->mode = (int)(_mode > 0 ? _O_WIDE : _O_BYTE); } }
	_mode = fp->mode;
	FUNLOCK(fp);
	return _mode;
}


/** @def ORIENT
Set the orientation for a stream */
#ifdef _WIDE_ORIENT
#   define ORIENT(fp, mode)   fwide((fp), (mode))
#else
#   define ORIENT(fp, mode)
#endif


/** Deletes a file or directory from the file system */
LIB_FUNC int remove(const char* path) {
#   ifdef SYS_unlink
	int r = (int)syscall1(SYS_unlink, (long)path);
#   else
	int r = (int)syscall3(SYS_unlinkat, AT_FDCWD, (long)path, 0);
#   endif
#   ifdef SYS_rmdir
	if (eq_errno(EISDIR)) { r = (int)syscall1(SYS_rmdir, (long)path); }
#   else
	if (eq_errno(EISDIR)) { r = (int)syscall3(SYS_unlinkat, AT_FDCWD, (long)path, AT_REMOVEDIR); }
#   endif
	return r;
}


/** Renames a file or directory on the file system */
LIB_FUNC int rename(const char* old, const char* new) {
#   ifdef SYS_rename
	return (int)syscall2(SYS_rename, (long)old, (long)new);
#   else
	return (int)syscall4(SYS_renameat, AT_FDCWD, (long)old, AT_FDCWD, (long)new);
#   endif
}


/** Rename a file relative to directory file descriptors */
LIB_FUNC int renameat(const int oldfd, const char* old, const int newfd, const char* new) {
	return (int)syscall4(SYS_renameat, oldfd, (long)old, newfd, (long)new);
}


LIB_FUNC const char* trailsl(const char *f) {
	const char* s = f;
	while (*s) { s++; }
	return ((f != s && s[-1] == '/') ? (const char*)"" : (const char*)"/");
}


#ifndef TMPFILE_MAXTRIES
#   define TMPFILE_MAXTRIES   4
#endif


LIB_FUNC FILE* tmpfile(void) {
	char align32 s[32] = "/tmp/tmpfile_XXXXXX\0";
	int fd;
	FILE* f;
	register int try;
	for (try = 0; try < TMPFILE_MAXTRIES; try++) {
		randname(s + 13);
		fd = (int)syscall3(SYS_open, (long)&s, (long)(O_RDWR | O_CREAT | O_EXCL), (long)0600);
		if (fd >= 0) {
#   ifdef SYS_unlink
			syscall1(SYS_unlink, (long)&s);
#   else
			syscall3(SYS_unlinkat, AT_FDCWD, s, 0);
#   endif
			f = fdopen(fd, "w+");
			if (!f) { syscall1(SYS_close, fd); }
			return f;
		}
	}
	return 0;
}
#define tmpfile64()   tmpfile()


LIB_FUNC char* tmpnam(char* buf) {
	char align32 s[32] = "/tmp/tmpnam_XXXXXX\0";
	int try, r;
	for (try = 0; try < TMPFILE_MAXTRIES; try++) {
		randname(s + 12);
#   ifdef SYS_lstat
		r = (int)syscall2(SYS_lstat, (long)&s, (long)&(struct stat){0});
#   else
		r = (int)syscall4(SYS_fstatat, AT_FDCWD, s, (long)&(struct stat){0}, AT_SYMLINK_NOFOLLOW);
#   endif
		if (r == -ENOENT) { return strcpy(buf, s); }
	}
	return 0;
}


LIB_FUNC char* tempnam(const char* dir, const char* pfx) {
	char s[PATH_MAX];
	int try, r;
	if (!dir) { dir = P_tmpdir; }
	if (!pfx) { pfx = "temp"; }
	const size_t dl = strlen(dir);
	const size_t pl = strlen(pfx);
	size_t l = dl + pl + 8;
	if (l >= PATH_MAX) {
		set_errno(ENAMETOOLONG);
		return 0;
	}
	memcpy_no_output(s, dir, dl);
	s[dl] = '/';
	memcpy_no_output(s + dl + 1, pfx, pl);
	s[dl + 1 + pl] = '_';
	s[l] = 0;
	for (try = 0; try < 100; try++) {
		randname(s + l - 6);
#   ifdef SYS_lstat
		r = (int)syscall2(SYS_lstat, (long)s, (long)&(struct stat){0});
#   else
		r = (int)syscall4(SYS_fstatat, AT_FDCWD, (long)s, (long)&(struct stat){0}, AT_SYMLINK_NOFOLLOW);
#   endif
		if (r == -ENOENT) { return strdup(s); }
	}
	return 0;
}


/** Return the name of the controlling terminal. If S is not NULL, the name is copied into it (it should be at least L_ctermid bytes long), otherwise we return a pointer to a non-const but read-only string literal, that POSIX states the caller must not modify */
LIB_FUNC char* ctermid(char* s) {
	static char def[16] = _PATH_TTY;
	if (s) {
		strncpy_no_output(s, def, (size_t)L_ctermid);
		return s;
	}
	return def;
}


/** Test if the given string is found in the specified file; `0` and `1` are used to indicate `false` and `true`, respectively, while `-1` indicates failure */
LIB_FUNC int file_contains_string(const char* file_path, const char* char_string) {
	FILE* file_ptr = fopen(file_path, "r");
	if (!file_ptr) { return -1; }
	char buffer[8192] = { 0 };
	while (fgets(buffer, 8192, file_ptr) != NULL) {
		if (strstr(buffer, char_string)) {
			fclose(file_ptr);
			return 1;
		}
	}
	fclose(file_ptr);
	return 0;
}


/* TODO: Add stdio functions
FILE* fmemopen(void* restrict, size_t, const char* restrict);
int pclose(FILE*);
FILE* popen(const char*, const char*);
*/


#endif  // STDIO_H


/* POSIX 1003.1B-1993 (POSIX 4) SCHEDULING INTERFACE (<bits/sched.h>) */


#if (!(defined(SCHED_H) || defined(_SCHED_H) || defined(_SCHED_H_)))
#define SCHED_H   (1)
#define _SCHED_H   (1)
#define _SCHED_H_   (1)


// CPU SCHEDULING ALGORITHMS
#define SCHED_OTHER   0
#define SCHED_FIFO   1
#define SCHED_RR   2
#define SCHED_BATCH   3
#define SCHED_IDLE   5
#define SCHED_RESET_ON_FORK   0x40000000

// CPU SIGNALS
/** Signal mask to be sent at exit */
#define CSIGNAL   0xff
/** Set if VM shared between processes */
#define CLONE_VM   0x100
/** Set if fs info shared between processes */
#define CLONE_FS   0x200
/** Set if open files shared between processes */
#define CLONE_FILES   0x400
/** Set if signal handlers shared */
#define CLONE_SIGHAND   0x800
/** Set if tracing continues on the child */
#define CLONE_PTRACE   0x2000
/** Set if the parent wants the child to wake it up on mm_release */
#define CLONE_VFORK   0x4000
/** Set if we want to have the same parent as the cloner */
#define CLONE_PARENT   0x8000
/** Set to add to same thread group */
#define CLONE_THREAD   0x10000
/** Set to create new namespace */
#define CLONE_NEWNS   0x20000
/** Set to shared SVID SEM_UNDO semantics */
#define CLONE_SYSVSEM   0x40000
/** Set TLS info */
#define CLONE_SETTLS   0x80000
/** Store TID in userlevel buffer before MM copy */
#define CLONE_PARENT_SETTID   0x100000
/** Register exit futex and memory location to clear */
#define CLONE_CHILD_CLEARTID   0x200000
/** Create clone detached */
#define CLONE_DETACHED   0x400000
/** Set if the tracing process cannot force CLONE_PTRACE on this clone */
#define CLONE_UNTRACED   0x800000
/** Store TID in userlevel buffer in the child */
#define CLONE_CHILD_SETTID   0x1000000
/** New utsname group */
#define CLONE_NEWUTS   0x4000000
/** New ipcs */
#define CLONE_NEWIPC   0x8000000
/** New user namespace */
#define CLONE_NEWUSER   0x10000000
/** New pid namespace */
#define CLONE_NEWPID   0x20000000
/** New network namespace */
#define CLONE_NEWNET   0x40000000
/** Clone I/O context */
#define CLONE_IO   0x80000000


// FUNCTIONS FOR CPU MASKS & SETS

#define CPUELT(cpu)   ((cpu) / BITS_PER_CPU_MASK_T)
#define CPUMASK(cpu)   ((cpu_mask_t)1 << ((cpu) % BITS_PER_CPU_MASK_T))
/** Return the size (in bytes) of the CPU set that would be needed to hold CPUs in the range 0 to num_cpus-1 */
#define CPU_ALLOC_SIZE(num_cpus)   ((((num_cpus) + BITS_PER_CPU_MASK_T - 1) / BITS_PER_CPU_MASK_T) * SIZEOF_LONG)
/** Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */
#define sched_cpualloc(num_cpus)   ((cpu_set_t*)malloc(CPU_ALLOC_SIZE(num_cpus)))
/** Allocate a CPU set large enough to hold CPUs in the range 0 to num_cpus-1 */
#define CPU_ALLOC(num_cpus)   sched_cpualloc(num_cpus)
/** Free a CPU set previously allocated by CPU_ALLOC() */
#define CPU_FREE(cpuset)   free(cpuset)
/** Free a CPU set previously allocated by CPU_ALLOC() */
#define sched_cpufree(__set)   free(__set)


/** Add CPU cpu to set */
LIB_FUNC void CPU_SET_S(const int cpu, const size_t setsize, cpu_set_t* restrict cpusetp) {
	const size_t _cpu = (size_t)cpu;
	if ((_cpu >> 3) < setsize) {
		cpusetp->bits[CPUELT(_cpu)] |= (CPUMASK(_cpu));
	}
}
/** Add CPU cpu to set */
#define CPU_SET(cpu, cpusetp)   CPU_SET_S((cpu), SIZEOF_LONG, (cpusetp))


/** Remove CPU cpu from set */
LIB_FUNC void CPU_CLR_S(const int cpu, const size_t setsize, cpu_set_t* restrict cpusetp) {
	register const size_t _cpu = (size_t)cpu;
	if ((_cpu >> 3) < setsize) {
		cpusetp->bits[CPUELT(_cpu)] &= (~(CPUMASK(_cpu)));
	}
}
/** Remove CPU cpu from set */
#define CPU_CLR(cpu, cpusetp)   CPU_CLR_S((cpu), SIZEOF_LONG, (cpusetp))


/** Clears set, so that it contains no CPUs */
LIB_FUNC void CPU_ZERO_S(const size_t setsize, cpu_set_t* restrict cpusetp) {
	register const size_t imax = (setsize / SIZEOF_LONG);
	register size_t i;
	for (i = 0; i < imax; ++i) { cpusetp->bits[i] = 0; }
}
/** Clears set, so that it contains no CPUs */
#define CPU_ZERO(cpusetp)   CPU_ZERO_S(SIZEOF_LONG, (cpusetp))


/** Return the number of CPUs in set */
LIB_FUNC ATTR_PF int sched_cpucount(const size_t setsize, const cpu_set_t* cpusetp) {
	const cpu_mask_t* p = cpusetp->bits;
	const cpu_mask_t* end = &cpusetp->bits[setsize / SIZEOF_CPU_MASK_T];
	register int s = 0;
	register cpu_mask_t l;
	while (p < end) {
		l = *p++;
		s += (int)popcount32((uint32_t)l);
	}
	return s;
}
/** Return the number of CPUs in set */
#define CPU_COUNT(cpusetp)  sched_cpucount(SIZEOF_LONG, (cpusetp))
/** Return the number of CPUs in set */
#define CPU_COUNT_S(setsize, cpusetp)  sched_cpucount((setsize), (cpusetp))
/** Return the number of CPUs in set */
#define __sched_cpucount(setsize, cpusetp)   sched_cpucount((setsize), (cpusetp))


/** Test to see if CPU cpu is a member of set */
LIB_FUNC ATTR_CF int CPU_ISSET_S(const int cpu, const size_t setsize, const cpu_set_t* restrict cpusetp) {
	register const size_t _cpu = (size_t)cpu;
	if ((_cpu >> 3) < setsize) {
		return (int)((cpusetp->bits[CPUELT(_cpu)] & CPUMASK(_cpu)) != (cpu_mask_t)0);
	}
	return 0;
}
/** Test to see if CPU cpu is a member of set */
#define CPU_ISSET(cpu, cpusetp)   CPU_ISSET_S((cpu), SIZEOF_LONG, (cpusetp))


/** Test whether two CPU set contain exactly the same CPUs */
LIB_FUNC int CPU_EQUAL_S(const size_t setsize, const cpu_set_t* restrict cpusetp1, const cpu_set_t* restrict cpusetp2) {
	return (int)(memcmp(cpusetp1, cpusetp2, setsize) == 0);
}
/** Test whether two CPU set contain exactly the same CPUs */
#define CPU_EQUAL(cpusetp1, cpusetp2)   __CPU_EQUAL_S(SIZEOF_LONG, (cpusetp1), (cpusetp2))


/** Store the intersection of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets) */
LIB_FUNC void CPU_AND_S(const size_t setsize, cpu_set_t* restrict destset, const cpu_set_t* restrict srcset1, const cpu_set_t* restrict srcset2) {
	register const size_t imax = (setsize / SIZEOF_LONG);
	register size_t i;
	for (i = 0; i < imax; ++i) { destset->bits[i] = (srcset1->bits[i] & srcset2->bits[i]); }
}
/** Store the intersection of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets) */
#define CPU_AND(destset, srcset1, srcset2)   CPU_AND_S(SIZEOF_LONG, (destset), (srcset1), (srcset2))


/** Store the union of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets) */
LIB_FUNC void CPU_OR_S(const size_t setsize, cpu_set_t* restrict destset, const cpu_set_t* restrict srcset1, const cpu_set_t* restrict srcset2) {
	register const size_t imax = (setsize / SIZEOF_LONG);
	register size_t i;
	for (i = 0; i < imax; ++i) { destset->bits[i] = (srcset1->bits[i] | srcset2->bits[i]); }
}
/** Store the union of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets) */
#define CPU_OR(destset, srcset1, srcset2)   CPU_OR_S(SIZEOF_LONG, (destset), (srcset1), (srcset2))


/** Store the XOR of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets); The XOR means the set of CPUs that are in either `srcset1` or `srcset2`, but not both */
LIB_FUNC void CPU_XOR_S(const size_t setsize, cpu_set_t* restrict destset, const cpu_set_t* restrict srcset1, const cpu_set_t* restrict srcset2) {
	register const size_t imax = (setsize / SIZEOF_LONG);
	register size_t i;
	for (i = 0; i < imax; ++i) { destset->bits[i] = (srcset1->bits[i] ^ srcset2->bits[i]); }
}
/** Store the XOR of the sets `srcset1` and `srcset2` in `destset` (which may be one of the source sets); The XOR means the set of CPUs that are in either `srcset1` or `srcset2`, but not both */
#define CPU_XOR(destset, srcset1, srcset2)   CPU_XOR_S(SIZEOF_LONG, (destset), (srcset1), (srcset2))


// SCHEDULING FUNCTIONS

LIB_FUNC int sched_yield(void) {
	return (int)syscall1(SYS_sched_yield, 0);
}


/** Signal handler datatype */
typedef void (*handler_t)(int signal);
/** Set of current actions; If sa_handler for an entry is NULL, then that signal is not currently handled by the sigaction handler */
static UNUSED struct sigaction volatile action_array[NSIG];


LIB_FUNC int rt_sigaction(const int signum, const struct sigaction* act, struct sigaction* oldact, const size_t size) {
	return (int)syscall4(SYS_rt_sigaction, signum, (long)act, (long)oldact, (long)size);
}


LIB_FUNC int sched_get_priority_max(const int policy) {
	return (int)syscall1(SYS_sched_get_priority_max, (long)policy);
}


LIB_FUNC int sched_get_priority_min(const int policy) {
	return (int)syscall1(SYS_sched_get_priority_min, (long)policy);
}


/** Signal handler that is installed for signals */
LIB_FUNC void sigaction_handler(int sig) {
	handler_t handler;
	sigset_t mask, oldmask;
	int sverrno = get_errno();
	if (sig < 0 || NSIG <= sig || (!action_array[sig].sa_handler)) {
			if (sig == SIGABRT) { signal(SIGABRT, SIG_DFL); }
			abort();
		}
	// Reinstall the signal handler when required; otherwise update the bookkeeping
	handler = action_array[sig].sa_handler;
	if ((action_array[sig].sa_flags & SA_RESETHAND) == 0) { signal(sig, sigaction_handler); }
	else { action_array[sig].sa_handler = NULL; }
	// Block appropriate signals
	mask = action_array[sig].sa_mask;
	if ((action_array[sig].sa_flags & SA_NODEFER) == 0) { sigaddset(&mask, sig); }
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	// Invoke the user's handler, then restore prior mask
	set_errno(sverrno);
	handler(sig);
	sverrno = get_errno();
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	set_errno(sverrno);
}


#ifdef ARCHX86
UNUSED void __restore_rt(void);
asm (".text;" ".align 16;" "__restore_rt:" "movq $15, %rax;" "syscall;" "hlt;");
#endif


LIB_FUNC int __rt_sigaction(const int signum, const struct sigaction* act, struct sigaction* oldact, const long nr) {
	return (int)syscall4(SYS_rt_sigaction, signum, (long)act, (long)oldact, nr);
}


/** If ACT is not NULL, change the action for SIG to *ACT; If OACT is not NULL, put the old action for SIG in *OACT */
LIB_FUNC int __sigaction(const int _sig, const struct sigaction* act, struct sigaction* oact) {
	struct sigaction* newact = (struct sigaction*)UNCONST(act);
	if (act) {
		newact->sa_handler = act->sa_handler;
		newact->sa_flags = (act->sa_flags | SA_RESTORER);
		newact->sa_restorer = &__restore_rt;
		newact->sa_mask = act->sa_mask;
	}
	return (int)syscall4(SYS_rt_sigaction, (long)_sig, (long)newact, (long)oact, NSIG_S3);
}
#define __libc_sigaction(sig, act, oact)   __sigaction((sig), (act), (oact))


LIB_FUNC int sched_getparam(const pid_t pid, struct sched_param* p) {
	return (int)syscall2(SYS_sched_getparam, (long)pid, (long)p);
}


LIB_FUNC int sched_setparam(const pid_t pid, const struct sched_param* p) {
	return (int)syscall2(SYS_sched_setparam, (long)pid, (long)p);
}


/** Get the CPU affinity for a task */
LIB_FUNC int sched_getaffinity(const pid_t pid, const size_t cpusetsize, cpu_set_t* cpuset) {
	register int res = (int)syscall3(SYS_sched_getaffinity, (long)pid, (long)MIN((long)INT_MAX, (long)cpusetsize), (long)cpuset);
	if (res != -1) {
		memset_no_output((char*)(cpuset + res), '\0', (size_t)(cpusetsize - (size_t)res));
		res = 0;
	}
	return res;
}


#if IS_STACK_DIRECTION_DOWN
#   define extend_alloca(buf, len, newlen)   __extension__ ((typeof(buf)) ({ size_t __newlen = (newlen); char* __newbuf = alloca(__newlen); if ((__newbuf + __newlen) == (char*)buf) { len += __newlen; } else { len = __newlen; } __newbuf; }))
#elif IS_STACK_DIRECTION_UP
#   define extend_alloca(buf, len, newlen)   __extension__ ((typeof(buf)) ({ size_t __newlen = (newlen); char* __newbuf = alloca(__newlen); char* __buf = (buf); if ((__buf + __newlen) == __newbuf) { len += __newlen; __newbuf = __buf; } else { len = __newlen; } __newbuf; }))
#else
#   define extend_alloca(buf, len, newlen)   alloca(((len) = (newlen)))
#endif


static UNUSED size_t __kernel_cpumask_size;
/** Set the CPU affinity for a task */
LIB_FUNC int sched_setaffinity(const pid_t pid, const size_t cpusetsize, const cpu_set_t* cpuset) {
	if (PREDICT_UNLIKELY(__kernel_cpumask_size == 0)) {
		int res = 0;
		size_t psize = 128;
		void* p = alloca(psize);
		while (res = (int)syscall3(SYS_sched_getaffinity, (long)getpid(), (long)psize, (long)p), ((unsigned long)res >= (unsigned long)(-4095)) && ((-res) == EINVAL)) {
			p = extend_alloca(p, psize, (2 * psize));
		}
		if (res == 0 || ((unsigned long)res >= (unsigned long)(-4095))) {
			set_errno((-res));
			return -1;
		}
		__kernel_cpumask_size = (size_t)res;
	}
	size_t cnt = __kernel_cpumask_size;
	for (; cnt < cpusetsize; ++cnt)
		if (((const char*)cpuset)[cnt] != '\0') {
			set_errno(EINVAL);
			return -1;
		}
	return (int)syscall3(SYS_sched_setaffinity, (long)pid, (long)cpusetsize, (long)cpuset);
}


LIB_FUNC int sched_getscheduler(const pid_t pid) {
	return (int)syscall1(SYS_sched_getscheduler, (long)pid);
}


LIB_FUNC int sched_setscheduler(const pid_t pid, const int policy, const struct sched_param* p) {
	return (int)syscall3(SYS_sched_setscheduler, (long)pid, policy, (long)p);
}


LIB_FUNC int sched_rr_get_interval(const pid_t pid, struct timespec* tp) {
	return (int)syscall2(SYS_sched_rr_get_interval, (long)pid, (long)tp);
}


LIB_FUNC int sched_getcpu(void) {
	unsigned int cpu;
	register int r = (int)syscall4(SYS_getcpu, 3, (long)&cpu, (long)NULL, (long)NULL);
	return ((r == -1) ? r : (int)cpu);
}


#ifndef FORK
#   define FORK()   syscall4(SYS_clone, 3, (int)(CLONE_PARENT_SETTID | SIGCHLD), 0, (long)&pid)
#endif


#endif  // SCHED_H


/* XSI RESOURCE OPERATIONS (<sys/resource.h> & <ulimit.h>) */


#if (!(defined(SYS_RESOURCE_H) || defined(_SYS_RESOURCE_H) || defined(_SYS_RESOURCE_H_) || defined(_ULIMIT_H) || defined(_ULIMIT_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_resource.h.html
#define SYS_RESOURCE_H   (1)
#define _SYS_RESOURCE_H   (1)
#define _SYS_RESOURCE_H_   (1)
#define _ASM_GENERIC_RESOURCE_H   (1)
#define ULIMIT_H   (1)
#define _ULIMIT_H   (1)
#define _ULIMIT_H_   (1)


#define PRIO_MIN   (-20)
#define PRIO_MAX   20
#define PRIO_PROCESS   0
#define PRIO_PGRP   1
#define PRIO_USER   2
#define RUSAGE_SELF   0
#define RUSAGE_CHILDREN   1
#define RLIM_SAVED_CUR   RLIM_INFINITY
#define RLIM64_SAVED_CUR   RLIM64_INFINITY
#define RLIM_SAVED_MAX   RLIM_INFINITY
#define RLIM64_SAVED_MAX   RLIM64_INFINITY
#define RLIMIT_CPU   0
#define RLIMIT_FSIZE   1
#define RLIMIT_DATA   2
#define RLIMIT_STACK   3
#define RLIMIT_CORE   4
#ifdef ARCHMIPS
#   define RLIMIT_NOFILE   5
#   define RLIMIT_AS   6
#   define RLIMIT_RSS   7
#   define RLIMIT_NPROC   8
#   define RLIMIT_MEMLOCK   9
#else
#   define RLIMIT_RSS   5
#   define RLIMIT_NPROC   6
#   define RLIMIT_NOFILE   7
#   define RLIMIT_MEMLOCK   8
#   define RLIMIT_AS   9
#endif
#define RLIMIT_LOCKS   10
#define RLIMIT_SIGPENDING   11
#define RLIMIT_MSGQUEUE   12
#define RLIMIT_NICE   13
#define RLIMIT_RTPRIO   14
#define RLIMIT_NLIMITS   15
#define RLIM_NLIMITS   RLIMIT_NLIMITS
#ifndef _STK_LIM_MAX
#   define _STK_LIM_MAX   RLIM_INFINITY
#endif
#define fix__rlimit(x)   do { if ((x) >= SYSCALL_RLIM_INFINITY) { (x) = RLIM_INFINITY; } } while (0x0)


typedef struct rlimit { rlim_t rlim_cur, rlim_max; }   rlimit_t;
typedef struct ctx { int _id, eid, sid, nr, err; }   ctx_t;

typedef struct ctx_rlimit {
	const struct rlimit* rlim;
	int res, err;
} ctx_rlimit_t;


static const UNUSED unsigned long sigs_all_mask[] = {
#   if (LONG_EQ_32BITS && (NSIG == 129))
	-1UL, -1UL, -1UL, -1UL
#   elif LONG_EQ_32BITS
	-1UL, -1UL
#   else
	-1UL
#   endif
};


static const UNUSED unsigned long sigs_app_mask[] = {
#   if LONG_EQ_32BITS
#      if (NSIG == 65)
	0x7fffffff, 0xfffffffc
#      else
	0x7fffffff, 0xfffffffc, -1UL, -1UL
#      endif
#   else
#      if (NSIG == 65)
	0xfffffffc7fffffff
#      else
	0xfffffffc7fffffff, -1UL
#      endif
#   endif
};


LIB_FUNC void __block_all_sigs(void* set) {
	syscall4(SYS_rt_sigprocmask, SIG_BLOCK, (long)&sigs_all_mask, (long)set, NSIG_S3);
}


LIB_FUNC void __block_app_sigs(void* set) {
	syscall4(SYS_rt_sigprocmask, SIG_BLOCK, (long)&sigs_app_mask, (long)set, NSIG_S3);
}


LIB_FUNC void __restore_sigs(void* set) {
	syscall4(SYS_rt_sigprocmask, SIG_SETMASK, (long)set, 0, NSIG_S3);
}


LIB_FUNC int getrlimit(const int resource, struct rlimit* rlim) {
	unsigned long k_rlim[2] = { 0 };
	int ret = (int)syscall4(SYS_prlimit64, 0, resource, 0, (long)rlim);
	if (!ret) {
		fix__rlimit(rlim->rlim_cur);
		fix__rlimit(rlim->rlim_max);
	}
	if (!ret || neq_errno(ENOSYS)) { return ret; }
	else if (syscall2(SYS_getrlimit, resource, (long)&k_rlim) < 0) { return -1; }
	rlim->rlim_cur = ((k_rlim[0] == -1UL) ? RLIM_INFINITY : k_rlim[0]);
	rlim->rlim_max = ((k_rlim[1] == -1UL) ? RLIM_INFINITY : k_rlim[1]);
	fix__rlimit(rlim->rlim_cur);
	fix__rlimit(rlim->rlim_max);
	return 0;
}
#define getrlimit64(resource, rlim)   getrlimit((resource), (rlim))


LIB_FUNC int __setrlimit(const int resource, const struct rlimit* rlim) {
	unsigned long k_rlim[2] = { 0 };
	struct rlimit tmp;
	if (SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		tmp = *rlim;
		fix__rlimit(tmp.rlim_cur);
		fix__rlimit(tmp.rlim_max);
		rlim = &tmp;
	}
	const int ret = (int)syscall4(SYS_prlimit64, 0, resource, (long)&rlim, 0);
	if (ret != -ENOSYS) { return ret; }
	k_rlim[0] = MIN(rlim->rlim_cur, MIN(-1UL, SYSCALL_RLIM_INFINITY));
	k_rlim[1] = MIN(rlim->rlim_max, MIN(-1UL, SYSCALL_RLIM_INFINITY));
	return (int)syscall2(SYS_setrlimit, resource, (long)&k_rlim);
}


LIB_FUNC void do_setrlimit(void* restrict p) {
	struct ctx_rlimit* restrict c = p;
	if (c->err > 0) { return; }
	c->err = (-__setrlimit(c->res, c->rlim));
}


LIB_FUNC int syscall_setrlimit(const int resource, const struct rlimit* restrict rlim) {
	return (int)syscall2(SYS_setrlimit, resource, (long)rlim);
}


LIB_FUNC int setrlimit(rlimit_resource_t resource, const struct rlimit* rlimits) {
	struct rlimit rlimits_small;
	if (rlimits == NULL) {
		set_errno(EINVAL);
		return -1;
	}
	rlimits_small.rlim_cur = MIN((unsigned long)rlimits->rlim_cur, (unsigned long)(RLIM_INFINITY >> 1));
	rlimits_small.rlim_max = MIN((unsigned long)rlimits->rlim_max, (unsigned long)(RLIM_INFINITY >> 1));
	return (int)syscall_setrlimit(resource, &rlimits_small);
}
#define setrlimit64(resource, rlim)   setrlimit((resource), (rlim))


LIB_FUNC void do_setxid(void* restrict p) {
	struct ctx* restrict c = p;
	if (c->err > 0) { return; }
	const int ret = -(int)syscall3(c->nr, c->_id, c->eid, c->sid);
	if (ret && !(c->err)) {
		__block_all_sigs(0);
		syscall2(SYS_kill, ((int)syscall0(SYS_getpid)), SIGKILL);
	}
	c->err = ret;
}


LIB_FUNC int getrusage(const int who, struct rusage* restrict ru) {
	return (int)syscall2(SYS_getrusage, who, (long)ru);
}


LIB_FUNC int getpriority(const int which, const id_t who) {
	register const int ret = (int)syscall2(SYS_getpriority, which, (long)who);
	if (ret < 0) { return ret; }
	return (20 - ret);
}


LIB_FUNC int setpriority(const int which, const id_t who, const int prio) {
	return (int)syscall3(SYS_setpriority, which, (long)who, prio);
}


LIB_FUNC int prlimit(const pid_t pid, const int resource, const struct rlimit* new_limit, struct rlimit* old_limit) {
	struct rlimit tmp;
	if (new_limit && SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		tmp = *new_limit;
		fix__rlimit(tmp.rlim_cur);
		fix__rlimit(tmp.rlim_max);
		new_limit = &tmp;
	}
	const int r = (int)syscall4(SYS_prlimit64, (long)pid, resource, (long)new_limit, (long)old_limit);
	if (!r && old_limit && SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		fix__rlimit(old_limit->rlim_cur);
		fix__rlimit(old_limit->rlim_max);
	}
	return r;
}
#define prlimit64(pid, resource, new_limit, old_limit)   prlimit((pid), (resource), (new_limit), (old_limit))


#endif  // SYS_RESOURCE_H


/* XSI INTERPROCESS COMMUNICATION ACCESS STRUCTURE (<sys/ipc.h>) */


#if (!(defined(SYS_IPC_H) || defined(_SYS_IPC_H) || defined(_SYS_IPC_H_) || defined(_IPC_H) || defined(_IPC_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_ipc.h.html
#define SYS_IPC_H   (1)
#define _SYS_IPC_H   (1)
#define _SYS_IPC_H_   (1)
#define IPC_H   (1)
#define _IPC_H   (1)
#define _IPC_H_   (1)


#define IPCOP_semop   1
#define IPCOP_semget   2
#define IPCOP_semctl   3
#define IPCOP_semtimedop   4
#define IPCOP_msgsnd   11
#define IPCOP_msgrcv   12
#define IPCOP_msgget   13
#define IPCOP_msgctl   14
#define IPCOP_shmat   21
#define IPCOP_shmdt   22
#define IPCOP_shmget   23
#define IPCOP_shmctl   24
/** Create entry if key does not exist */
#define IPC_CREAT   01000
/** Fail if key exists */
#define IPC_EXCL   02000
/** Error if request must wait */
#define IPC_NOWAIT   04000
/** Remove identifier */
#define IPC_RMID   0
/** Set options */
#define IPC_SET   1
/** Get options */
#define IPC_STAT   2
#define IPC_INFO   3
/** Private key */
#define IPC_PRIVATE   ((key_t)0)


#ifdef ARCHX86_64
typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
} ipc_perm_t;
#   define IPC_64   0
#elif defined(ARCHX86_32)
typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	long long __pad1, __pad2;
} ipc_perm_t;
#   define IPC_64   0
#elif defined(ARCHPOWERPC)
typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	int __pad1;
	long long __pad2, __pad3;
} ipc_perm_t;
#   define IPC_64   0x100
#elif defined(ARCHAARCH64)
typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	unsigned short ipc_perm_seq;
	unsigned long __pad1, __pad2;
} ipc_perm_t;
#   define IPC_64   0
#else
typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	long __pad1, __pad2;
} ipc_perm_t;
#   define IPC_64   0x100
#endif  // ARCH


/** Convert a pathname and a project identifier to a System V IPC key */
LIB_FUNC key_t ftok(const char* pathname, const int proj_id) {
	struct stat st;
	if (stat64(pathname, &st) < 0) { return (key_t)-1; }
	const key_t key = (key_t)((key_t)(st.st_ino & UINT16_MAX) | (key_t)((st.st_dev & 0xff) << 16) | (key_t)((proj_id & 0xff) << 24));
	return key;
}


#endif  // SYS_IPC_H


/* XSI SEMAPHORE FACILITY (<sys/sem.h>) */


#if (!(defined(SYS_SEM_H) || defined(_SYS_SEM_H) || defined(_SYS_SEM_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_sem.h.html
#define SYS_SEM_H   (1)
#define _SYS_SEM_H   (1)
#define _SYS_SEM_H_   (1)


#define SEM_UNDO   0x1000
#define GETPID   11
#define GETVAL   12
#define GETALL   13
#define GETNCNT   14
#define GETZCNT   15
#define SETVAL   16
/** Set all cases of `semval` */
#define SETALL   17
#define SEM_STAT   18
#define SEM_INFO   19
#define _SEM_SEMUN_UNDEFINED   1


typedef struct seminfo {
	int semmap, semmni, semmns, semmnu, semmsl, semopm, semume, semusz, semvmx, semaem;
} seminfo_t;


typedef struct sembuf {
	unsigned short sem_num;
	short sem_op, sem_flg;
} sembuf_t;


#ifdef ARCHAARCH64  // semid_ds


typedef struct semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, sem_ctime;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
	time_t __unused3, __unused4;
} semid_t;


#elif defined(ARCHMIPS)


typedef struct semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, sem_ctime;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
	time_t __unused3, __unused4;
} semid_t;


#else


typedef struct attr_packed semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, __unused1, sem_ctime, __unused2;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
} semid_t;


#endif  // semid_ds


/** semctl(2)'s argument structure */
typedef union semun {
	int val;
	struct semid_ds* buf;  //!< Buffer for `IPC_STAT` & `IPC_SET`
	unsigned short* array;  //!< Array for `GETALL` & `SETALL`
} semun_t;
#define __semun   semun


LIB_FUNC int semctl(const int _id, const int num, const int cmd, ...) {
	union semun arg = { 0 };
	va_list ap;
	va_start(ap, cmd);
	arg = va_arg(ap, union semun);
	va_end(ap);
#   ifdef SYS_semctl
	return (int)syscall4(SYS_semctl, _id, num, (cmd | IPC_64), (long)arg.buf);
#   else
	return (int)syscall5(SYS_ipc, IPCOP_semctl, _id, num, (cmd | IPC_64), (long)arg.buf);
#   endif
}


LIB_FUNC int semget(const key_t key, const int n, const int _fl) {
	if ((unsigned int)n > USHRT_MAX) { set_errno(EINVAL); return -1; }
#   ifdef SYS_semget
	return (int)syscall3(SYS_semget, (long)key, (long)n, (long)_fl);
#   else
	return (int)syscall4(SYS_ipc, IPCOP_semget, (long)key, (long)n, (long)_fl);
#   endif
}


LIB_FUNC int semop(const int _id, struct sembuf* buf, const size_t n) {
#   ifdef SYS_semop
	return (int)syscall3(SYS_semop, (long)_id, (long)buf, (long)n);
#   else
	return (int)syscall5(SYS_ipc, IPCOP_semop, (long)_id, (long)n, 0, (long)buf);
#   endif
}


LIB_FUNC int semtimedop(const int _id, struct sembuf* buf, const size_t n, const struct timespec* ts) {
#   ifdef SYS_semtimedop
	return (int)syscall4(SYS_semtimedop, _id, (long)buf, (long)n, (long)ts);
#   else
	return (int)syscall6(SYS_ipc, IPCOP_semtimedop, _id, (long)n, 0, (long)buf, (long)ts);
#   endif
}


#endif  // SYS_SEM_H


/* XSI SHARED MEMORY FACILITY (<sys/shm.h>) */


#if (!(defined(SHM_H) || defined(_SHM_H) || defined(_SHM_H_) || defined(_SYS_SHM_H) || defined(_SYS_SHM_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_shm.h.html
#define SHM_H   (1)
#define _SHM_H   (1)
#define _SHM_H_   (1)
#define SYS_SHM_H   (1)
#define _SYS_SHM_H   (1)
#define _SYS_SHM_H_   (1)


#define SHM_R   0400
#define SHM_W   0200
/** Attach read-only (else read-write) */
#define SHM_RDONLY   010000
/** Round attach address to SHMLBA */
#define SHM_RND   020000
#define SHM_REMAP   040000
#define SHM_EXEC   0100000
#define SHM_LOCK   11
#define SHM_UNLOCK   12
#define SHM_STAT   13
#define SHM_INFO   14
#define SHM_DEST   01000
#define SHM_LOCKED   02000
#define SHM_HUGETLB   04000
#define SHM_NORESERVE   010000


/** Unsigned integer used for the number of current attaches */
typedef unsigned long   shmatt_t;


/** @def SHMLBA
Segment low boundary address multiple */
#ifdef ARCHX86_64
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	int pad0;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall;
} shminfo_t;
typedef struct shm_info {
	int used_ids, pad0;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;
#elif defined(ARCHAARCH64)
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;
#elif defined(ARCHMIPS)
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;
#elif defined(ARCHPOWERPC)
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	int __unused1;
	time_t shm_atime;
	int __unused2;
	time_t shm_dtime;
	int __unused3;
	time_t shm_ctime;
	int __unused4;
	size_t shm_segsz;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swpm, swap_attempts, swap_successes;
} shm_info_t;
#elif defined(ARCHSUPERH)
#   define SHMLBA   16384
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime;
	int __unused1;
	time_t shm_dtime;
	int __unused2;
	time_t shm_ctime;
	int __unused3;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;
#elif defined(ARCHX86_32)
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad0;
	unsigned long long __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, __pad0, shmmin, __pad1, shmmni, __pad2, shmseg, __pad3, shmall, __pad4;
	unsigned long long __unused[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids, __pad_ids;
	unsigned long shm_tot, __pad0, shm_rss, __pad1, shm_swp, __pad2, swap_attempts, __pad3, swap_successes, __pad4;
} align8 shm_info_t;
#else
#   define SHMLBA   4096
typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime;
	int __unused1;
	time_t shm_dtime;
	int __unused2;
	time_t shm_ctime;
	int __unused3;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;
typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;
typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;
#endif  // ARCH


LIB_FUNC void* shmat(const int _id, const void* addr, const int flag) {
#ifdef SYS_shmat
	long ret = (long)syscall3(SYS_shmat, (long)_id, (long)addr, (long)flag);
	return (void*)ret;
#else
	unsigned long ret = (unsigned long)syscall5(SYS_ipc, (long)IPCOP_shmat, (long)_id, (long)flag, (long)&addr, (long)addr);
	return ((ret > -(unsigned long)SHMLBA) ? (void*)ret : (void*)addr);
#endif
}


LIB_FUNC int shmctl(const int _id, int cmd, struct shmid_ds* buf) {
#ifdef SYS_shmctl
	return (int)syscall3(SYS_shmctl, (long)_id, (long)(cmd | IPC_64), (long)buf);
#else
	return (int)syscall3(SYS_ipc, (long)IPCOP_shmctl, (long)_id, (long)(cmd | IPC_64), 0, (long)buf, 0);
#endif
}


LIB_FUNC int shmdt(const void* addr) {
#ifdef SYS_shmdt
	return (int)syscall1(SYS_shmdt, (long)addr);
#else
	return (int)syscall5(SYS_ipc, IPCOP_shmdt, 0, 0, 0, (long)addr);
#endif
}


LIB_FUNC int shmget(const key_t key, const size_t __size, const int flag) {
	size_t maxlen = __size;
	if (maxlen > PTRDIFF_MAX) { maxlen = SIZE_MAX; }
#   ifdef SYS_shmget
	return (int)syscall3(SYS_shmget, (long)key, (long)maxlen, flag);
#   else
	return (int)syscall4(SYS_ipc, IPCOP_shmget, (long)key, (long)maxlen, flag);
#   endif
}


#endif  // SYS_SHM_H


/* POSIX THREADS (<pthread.h>) */


#if (!(defined(PTHREAD_H) || defined(_PTHREAD_H) || defined(_PTHREAD_H_) || defined(_PTHREAD_IMPL_H) || defined(_PTHREAD_IMPL_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html
#define PTHREAD_H   (1)
#define _PTHREAD_H   (1)
#define _PTHREAD_H_   (1)
#define _PTHREAD_IMPL_H   (1)
#define _PTHREAD_IMPL_H_   (1)
#define _PDCLIB_THREADCONFIG_H   (1)
#define _SYS_SEMAPHORE_H_   (1)
#define SYS_SEMAPHORE_H   (1)
#define SEMAPHORE_H   (1)
#define __SEMAPHORE_H__   (1)
#define _SYS_SPAWN_H_   (1)
#define SYS_SPAWN_H   (1)
#define SPAWN_H   (1)
#define _SPAWN_H_   (1)
#define AIO_MISC_H   (1)
#define _AIO_MISC_H_   (1)
#define _AIO_MISC_H   (1)


#define PTHREAD_CREATE_JOINABLE   0
#define PTHREAD_CREATE_DETACHED   1
#define PTHREAD_MUTEX_NORMAL   0
#define PTHREAD_MUTEX_DEFAULT   0
#define PTHREAD_MUTEX_RECURSIVE   1
#define PTHREAD_MUTEX_ERRORCHECK   2
#define PTHREAD_MUTEX_STALLED   0
#define PTHREAD_MUTEX_ROBUST   1
#define PTHREAD_PRIO_NONE   0
#define PTHREAD_PRIO_INHERIT   1
#define PTHREAD_PRIO_PROTECT   2
#define PTHREAD_INHERIT_SCHED   0
#define PTHREAD_EXPLICIT_SCHED   1
#define PTHREAD_SCOPE_SYSTEM   0
#define PTHREAD_SCOPE_PROCESS   1
#define PTHREAD_PROCESS_PRIVATE   0
#define PTHREAD_PROCESS_SHARED   1
/** Initial value of a spinlock; Most platforms should use zero, unless they only implement a "test and clear" operation instead of the usual "test and set" */
#define __LT_SPINLOCK_INIT   (0)
#define __LOCK_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define __ALT_LOCK_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define __ATOMIC_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define PTHREAD_RWLOCK_INITIALIZER   {{ 0 }}
#define PTHREAD_COND_INITIALIZER   {{ 0 }}
#define PTHREAD_MUTEX_INITIALIZER   { {PTHREAD_SPIN_UNLOCKED}, 0, PTHREAD_MUTEX_FAST_NP, 0 }
#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { 0 } }}
#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, 0, { 0 } }}
#define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { 0 } }}
#define PTHREAD_ONCE_INIT   0
#define PTHREAD_CANCEL_ENABLE   0
#define PTHREAD_CANCEL_DISABLE   1
#define PTHREAD_CANCEL_MASKED   2
#define PTHREAD_CANCEL_DEFERRED   0
#define PTHREAD_CANCEL_ASYNCHRONOUS   1
#define PTHREAD_CANCELED   ((void*)-1)
#define PTHREAD_BARRIER_SERIAL_THREAD   -1
#define MUTEX_INITIALIZER   PTHREAD_MUTEX_INITIALIZER
#define MUTEX_TYPE_NORMAL   PTHREAD_MUTEX_NORMAL
#define MUTEX_TYPE_ERRORCHECK   PTHREAD_MUTEX_ERRORCHECK
#define MUTEX_TYPE_RECURSIVE   PTHREAD_MUTEX_RECURSIVE
#define COND_INITIALIZER   PTHREAD_COND_INITIALIZER
#define RWLOCK_INITIALIZER   PTHREAD_RWLOCK_INITIALIZER
#define ONCE_INITIALIZER   PTHREAD_ONCE_INIT
#define POSIX_SPAWN_RESETIDS   1
#define POSIX_SPAWN_SETPGROUP   2
#ifdef OSBSD
#   define POSIX_SPAWN_SETSCHEDPARAM   4
#   define POSIX_SPAWN_SETSCHEDULER   8
#   define POSIX_SPAWN_SETSIGDEF   0x10
#   define POSIX_SPAWN_SETSIGMASK   0x20
#else
#   define POSIX_SPAWN_SETSIGDEF   4
#   define POSIX_SPAWN_SETSIGMASK   8
#   define POSIX_SPAWN_SETSCHEDPARAM   0x10
#   define POSIX_SPAWN_SETSCHEDULER   0x20
#endif
#ifdef __USE_GNU
#   define POSIX_SPAWN_USEVFORK   0x40
#elif defined(_NETBSD_SOURCE)
#   define POSIX_SPAWN_RETURNERROR   0x40
#endif
#define SPAWN_XFLAGS_USE_PATH   1
#define SPAWN_XFLAGS_TRY_SHELL   2
#define PTHREAD_THREADS_MAX   1024
#define MAX_SPIN_COUNT   50
#define SPIN_SLEEP_DURATION   2000001
#define PTHREAD_STACK_SIZE   16384
#if (defined(ARCHALPHA) || defined(ARCHX86_64) || defined(ARCHSPARC64))
#   define PTHREAD_STACK_MAXSIZE   (33554432)
#elif defined(ARCHITANIUM)
#   define PTHREAD_STACK_MAXSIZE   (16777216)
#else
#   define PTHREAD_STACK_MAXSIZE   (8388608)
#endif
#define PTHREAD_STACK_MINSIZE   16384
/** Operation codes for `aio_lio_opcode` */
enum LIO_OP_CODES { LIO_READ, LIO_WRITE, LIO_NOP };
/** Synchronization options for `lio_listio` function */
enum LIO_SYNC_CODES { LIO_WAIT, LIO_NOWAIT };
/** Extended LIO operations */
enum LIO_OPS {
	LIO_DSYNC = LIO_NOP + 1,
	LIO_SYNC,
	LIO_READ64 = (LIO_READ | 128),
	LIO_WRITE64 = (LIO_WRITE | 128)
};
/** Status of a request */
enum AIO_REQUEST { aio_no, aio_queued, aio_yes, aio_allocated, aio_done };


typedef struct attr_packed __timer { int timerid; pthread_t thread; }   pthread_timer_t;


typedef struct sem_struct { volatile unsigned int count; }   sem_t;
#define SEM_FAILED   ((sem_t*)-1)
/* FIXME: typedef struct {
	pthread_mutex_t lock;
	pthread_cond_t cond;
	int value;
	uint32_t magic;
} sem_t; */


/** Asynchronous I/O control block */
struct attr_packed aiocb {
	int aio_fildes, aio_lio_opcode, aio_reqprio;
	volatile void* aio_buf;
	size_t aio_nbytes;
	struct sigevent aio_sigevent;
	struct aiocb* __next_prio;
	int __abs_prio, __policy, __error_code;
	ssize_t __return_value;
#ifndef USE_FILE_OFFSET64
	off_t aio_offset;
#else
	off64_t aio_offset;
#endif
};


struct attr_packed aiocb64 {
	int aio_fildes, aio_lio_opcode, aio_reqprio;
	volatile void* aio_buf;
	size_t aio_nbytes;
	struct sigevent aio_sigevent;
	struct aiocb* __next_prio;
	int __abs_prio, __policy, __error_code;
	ssize_t __return_value;
	off64_t aio_offset;
};


struct attr_packed aio_args {
	struct aiocb* cb;
	int op, err;
	sem_t sem;
};


struct attr_packed aio_thread {
	pthread_t td;
	struct aiocb* cb;
	struct aio_thread *next, *prev;
	struct aio_queue* q;
	volatile int running;
	int err, op;
	ssize_t ret;
};


struct aio_queue {
	int fd, seekable, append, ref, init;
	pthread_mutex_t lock;
	pthread_cond_t cond;
	struct aio_thread* head;
};


/** Union of the two request types */
typedef union __aiocb_union {
	struct aiocb aiocb;
	struct aiocb64 aiocb64;
} aiocb_union;


struct waitlist {
	struct waitlist* next;
#   ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t* cond;
#   endif
	int* result;
	volatile unsigned int* counterp;
	struct sigevent* sigevp;
#   ifdef BROKEN_THREAD_SIGNALS
	pid_t caller_pid;
#   endif
};


struct attr_packed requestlist {
	int running;
	struct requestlist *last_fd, *next_fd, *next_prio, *next_run;
	aiocb_union* aiocbp;
#   ifdef BROKEN_THREAD_SIGNALS
	pid_t caller_pid;
#   endif
	struct waitlist* waiting;
};


typedef struct attr_packed lio_state {
	struct sigevent* sev;
	int cnt;
	struct aiocb* cbs[];
} lio_state_t;


struct attr_packed clparam {
	struct aiocb* __list;
	struct waitlist* __waitlist;
	struct requestlist** __requestlist;
#   ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t* cond;
#   endif
	int nent;
};


struct attr_packed _thread_key { int used; void (*destructor)(void*); };


struct posix_spawn_args {
	int p[2];
	sigset_t oldmask;
	const char* path;
	int (*exec)(const char*, char *const*, char *const*);
	const posix_spawn_file_actions_t* fa;
	const posix_spawnattr_t* restrict attr;
	char *const* argv, *const* envp;
};


static UNUSED struct _pthread_descr_struct _main_thread = {
	.stack_begin = 0,
	.stack_end = (void*)(~0),
	.lock = { PTHREAD_SPIN_UNLOCKED }
};
static UNUSED pthread_rwlock_t maplock = { 0 };
static UNUSED struct aio_queue***** map;
static volatile UNUSED int aio_fd_cnt;
static volatile UNUSED int __aio_fut;
static UNUSED _pthread_descr manager_thread = NULL;
static UNUSED pthread_once_t __thread_started = PTHREAD_ONCE_INIT;
static UNUSED unsigned long __thread_pagesize;
static UNUSED int __manager_pipe[2] = { -1, -1 };
#define mgr_recv_fd   __manager_pipe[0]
#define mgr_send_fd   __manager_pipe[1]


/** @def __pthread_self
Main POSIX Thread object */
#ifdef ARCHI386
LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self = NULL;
	vasm("movl %%gs:0, %0;" : "=r"(self));
	return self;
}
#   define TP_ADJ(p)   (p)
#   define MC_PC   gregs[REG_EIP]
#elif defined(ARCHX86)
LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self = NULL;
	vasm("mov %%fs:0, %0;" : "=r,m"(self));
	return self;
}
#   define TP_ADJ(p)   (p)
#   define MC_PC   gregs[REG_RIP]
#   define CANARY   canary2
#elif defined(ARCHSUPERH)
LIB_FUNC struct pthread* __pthread_self(void) {
	char* self = NULL;
	vasm("stc gbr, %0;" : "=r"(self));
	return (struct pthread*)(self + 0x8000 - sizeof(struct pthread));
}
#   define TLS_ABOVE_TP
#   define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 0x8000)
#   define MC_PC   sc_pc
#elif defined(ARCHPOWERPC)
LIB_FUNC struct pthread* __pthread_self(void) {
#   ifdef COMPILER_CLANG
	char* tp = NULL;
	vasm("mr %0, 2;" : "=r"(tp));
#   else
	register char* tp asm ("r2") = NULL;
	vasm(";" : "=r"(tp));
#   endif
	return (pthread_t)(tp - 0x7000 - sizeof(struct pthread));
}
#   define TLS_ABOVE_TP
#   define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) + 0x7000)
#   define DTP_OFFSET   0x8000
#   define MC_PC   gregs[32]
#   define CANARY   canary_at_end
#elif defined(ARCHMICROBLAZE)
LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self = NULL;
	vasm("ori %0, r21, 0;" : "=r"(self));
	return self;
}
#   define TP_ADJ(p)   (p)
#   define MC_PC   regs.pc
#elif defined(ARCHAARCH64)
LIB_FUNC struct pthread* __pthread_self(void) {
	char* self = NULL;
	vasm("mrs %0, tpidr_el0;" : "=r"(self));
	return (void*)(self + 16 - sizeof(struct pthread));
}
#   define TLS_ABOVE_TP
#   define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 16)
#   define MC_PC   pc
#elif defined(ARCHAARCH32)
#   if ((defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6ZK__)) && (!defined(ARM_THUMB))) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || (__ARM_ARCH >= 7)
LIB_FUNC pthread_t __pthread_self(void) {
	char* p = NULL;
	vasm("mrc p15, 0, %0, c13, c0, 3;" : "=r"(p));
	return (void*)(p + 0x8000 - sizeof(struct pthread));
}
#   else
LIB_FUNC pthread_t __pthread_self(void) {
#      ifdef COMPILER_CLANG
	char* p = NULL;
	vasm("bl __a_gettp;" "mov %0, r0;" : "=r"(p) : : "cc", "r0", "lr");
#      else
	register char* p asm ("r0") = NULL;
	vasm("bl __a_gettp;" : "=r"(p) : : "cc", "lr");
#      endif
	return (void*)(p + 0x8000 - sizeof(struct pthread));
}
#   endif
#   define TLS_ABOVE_TP
#   define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 0x8000)
#   define MC_PC   arm_pc
#elif defined(ARCHMIPS)
LIB_FUNC struct pthread* __pthread_self(void) {
#   ifdef COMPILER_CLANG
	char* tp = NULL;
	vasm(".word 0x7c03e83b;" "move %0, $3;" : "=r"(tp) : : "$3");
#   else
	register char* tp asm ("$3") = NULL;
	vasm(".word 0x7c03e83b;" : "=r"(tp));
#   endif
	return (pthread_t)(tp - 0x7000 - sizeof(struct pthread));
}
#   define TLS_ABOVE_TP
#   define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) + 0x7000)
#   define DTP_OFFSET   8
#   define MC_PC   pc
#else
#   error   "This library does not support POSIX-Threads for the target system!"
#endif  // __pthread_self


LIB_FUNC struct pthread* __pthread_self_internal(void) {
	return (struct pthread*)__pthread_self();
}
#define thrd_current()   __pthread_self_internal()
#define __thrd_current()   __pthread_self_internal()
#define pthread_self_internal()   __pthread_self_internal()


#define PTHREAD_SIG_RESTART   (SIGRTMAX)
#define PTHREAD_SIG_CANCEL   (SIGRTMAX - 1)
#define DEFAULT_STACK_SIZE   (81920)
#define DEFAULT_GUARD_SIZE   (PAGE_SIZE)
#define __ATTRP_C11_THREAD   ((void*)(uintptr_t)-1)
#ifndef CANARY
#   define CANARY   canary
#endif
#ifndef DTP_OFFSET
#   define DTP_OFFSET   (0)
#endif
#define SIGTIMER   (32)
#define SIGCANCEL   (33)
#define SIGSYNCCALL   (34)
#define __SU   (SIZEOF_SIZE_T / SIZEOF_INT)
#define _a_stacksize   __u.__s[0]
#define _a_guardsize   __u.__s[1]
#define _a_stackaddr   __u.__s[2]
#define _a_detach   __u.__i[3 * __SU]
#define _a_sched   __u.__i[3 * __SU + 1]
#define _a_policy   __u.__i[3 * __SU + 2]
#define _a_prio   __u.__i[3 * __SU + 3]
#define _m_type   __u.__i[0]
#define _m_lock   __u.__vi[1]
#define _m_waiters   __u.__vi[2]
#define _m_prev   __u.__p[3]
#define _m_next   __u.__p[4]
#define _m_count   __u.__i[5]
#define _c_shared   __u.__p[0]
#define _c_seq   __u.__vi[2]
#define _c_waiters   __u.__vi[3]
#define _c_clock   __u.__i[4]
#define _c_lock   __u.__vi[8]
#define _c_head   __u.__p[1]
#define _c_tail   __u.__p[5]
#define _rw_lock   __u.__vi[0]
#define _rw_waiters   __u.__vi[1]
#define _rw_shared   __u.__i[2]
#define _b_lock   __u.__vi[0]
#define _b_waiters   __u.__vi[1]
#define _b_limit   __u.__i[2]
#define _b_count   __u.__vi[3]
#define _b_waiters2   __u.__vi[4]
#define _b_inst   __u.__p[3]
#define SIGALL_SET   ((const sigset_t*)(const unsigned long long [2]) { (unsigned long long)-1, (unsigned long long)-1 })
#define SIGPT_SET   ((sigset_t*)(const unsigned long [NSIG_S3 / SIZEOF_LONG]) { [LONG_EQ_32BITS] = 3UL << (32 * (SIZEOF_LONG > 4)) })
#define SIGTIMER_SET   ((sigset_t*)(const unsigned long [NSIG_S3 / SIZEOF_LONG]) { 0x80000000 })
#define thread_sig_mask   jmp_exit->__saved_mask
#define NR_BUCKETS   256
static UNUSED _pthread_descr align64 _thread_hash_tid[256] = { 0 };
/** Lock for global I/O list of requests */
static UNUSED pthread_mutex_t __aio_requests_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
static UNUSED pthread_cond_t __aio_new_request_notification = PTHREAD_COND_INITIALIZER;
/** Number of threads currently running */
static UNUSED int nthreads = 0;
/** Number of threads waiting for work to arrive */
static UNUSED int idle_thread_count = 0;
/** List of available entries */
static UNUSED struct requestlist* freelist = NULL;
/** List of request waiting to be processed */
static UNUSED struct requestlist* runlist = NULL;
/** Structure list of all currently processed requests */
static UNUSED struct requestlist* requests = NULL;


LIB_FUNC unsigned long hash_tid(const int tid) {
	return (unsigned long)(tid & (NR_BUCKETS - 1));
}


LIB_FUNC int pthread_sigmask(const int how, const sigset_t* restrict set, sigset_t* restrict old) {
	if ((unsigned int)how - SIG_BLOCK > 2U) { return EINVAL; }
	const int ret = (int)(-((int)syscall4(SYS_rt_sigprocmask, (long)how, (long)set, (long)old, NSIG_S3)));
	if ((!ret) && old) {
		if (sizeof(old->bits[0]) == 8) {
			old->bits[0] &= (unsigned long)(~0x380000000ULL);
		} else {
			old->bits[0] &= (unsigned long)(~0x80000000UL);
#if (SIGSET_WORDS > 1)
			old->bits[1] &= (unsigned long)(~0x3UL);
#endif
		}
	}
	return ret;
}


/** Find thread by Thread ID */
LIB_FUNC REGPARM(1) _pthread_descr __thread_find_(const int pid) {
	if (__thread_started == PTHREAD_ONCE_INIT) {
		LOCK((atomic volatile int*)&_main_thread);
		return &_main_thread;
	}
	atomic _pthread_descr cur = _thread_hash_tid[hash_tid(pid)];
	atomic _pthread_descr next;
	while (cur) {
		next = cur->next;
		if (pid == cur->pid) { LOCK((atomic volatile int*)cur); break; }
		cur = next;
	}
	return cur;
}
/** Find thread by Thread ID */
#define __thread_find(pid)   __thread_find_((pid))


/** Get thread-self descriptor */
LIB_FUNC _pthread_descr __thread_self(void) {
#ifdef ARCHALPHA
	register _pthread_descr cur asm ("$0");
	asm ("call_pal 158;" : "=r"(cur));
#else
	register _pthread_descr cur = 0;
#   ifdef ARCHSPARC
	asm ("mov %%g6, %0;" : "=r"(cur));
#   elif defined(ARCHS390)
	asm ("ear %0, %%a0;" : "=d"(cur));
#   elif defined(ARCHITANIUM)
	asm ("mov %0 = r13;" : "=r"(cur));
#   elif defined(ARCHX86_64)
	asm ("mov %%fs:(16), %0;" : "=r"(cur));
#   elif defined(ARCHX86_32)
	asm ("mov %%gs:(8), %0;" : "=r"(cur));
#   else
	cur = __thread_find_(getpid());
	if (cur) { UNLOCK((atomic volatile int*)cur); }
#   endif
#endif
	return (_pthread_descr)(cur ? cur : &_main_thread);
}


/** Set canceltype of thread */
LIB_FUNC int __thread_setcanceltype(const int type, int* oldtype, _pthread_descr td) {
	if ((type != PTHREAD_CANCEL_DEFERRED) && (type != PTHREAD_CANCEL_ASYNCHRONOUS)) { return EINVAL; }
	if (oldtype) { *oldtype = td->canceltype; }
	td->canceltype = (unsigned char)type;
	return 0;
}


#define __NO_ASYNC_CANCEL_BEGIN_(t)   int __oldtype__; __thread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &__oldtype__, (t))
#define __NO_ASYNC_CANCEL_END_(t)   __thread_setcanceltype(__oldtype__, 0, (t)); __thread_testcancel((t))
#define __NO_ASYNC_CANCEL_STOP


/** Exit a thread */
LIB_FUNC void pthread_exit(void* retval) {
	atomic _pthread_descr this = __thread_self();
	if (this == &_main_thread) { _Exit((int)SYS_exit); }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	LOCK((atomic volatile int*)this);
	this->cancelstate = PTHREAD_CANCEL_DISABLE;
	this->retval = retval;
	UNLOCK((atomic volatile int*)this);
	siglongjmp(this->jmp_exit, 1);
}
#define __pthread_exit(retval)   pthread_exit((retval))


/** Test canceled */
LIB_FUNC void __thread_testcancel(_pthread_descr td) {
	register int cancel = 0;
	if (td && (td->cancelstate == PTHREAD_CANCEL_ENABLE)) { cancel = td->canceled; }
	if (cancel) { __pthread_exit(PTHREAD_CANCELED); }
}
#define pthread_testcancel()   __thread_testcancel(__thread_self())
#define __TEST_CANCEL_(t)   __thread_testcancel((t))
#define __TEST_CANCEL()   pthread_testcancel()


LIB_FUNC int pthread_setcancelstate(const int new, int* old) {
	if (new > 2) { return EINVAL; }
	struct pthread* self = __pthread_self();
	if (old) { *old = self->canceldisable; }
	self->canceldisable = new;
	return 0;
}
#define __pthread_setcancelstate(new, old)   pthread_setcancelstate((new), (old))


LIB_FUNC int pthread_setcanceltype(const int new, int* old) {
	struct pthread* self = __pthread_self();
	if (new > 1) { return EINVAL; }
	if (old) { *old = self->cancelasync; }
	self->cancelasync = new;
	if (new) { pthread_testcancel(); }
	return 0;
}


LIB_FUNC int __thread_mutex_lock(pthread_mutex_t* mutex, const _pthread_descr this) {
	if (mutex->__data.__owner != this) {
		LOCK((atomic volatile int*)&mutex);
		mutex->__data.__owner = this;
		mutex->__data.__count = 0;
	}
	else if (mutex->__data.__kind == PTHREAD_MUTEX_ERRORCHECK_NP) { return EDEADLK; }
	if (mutex->__data.__kind == PTHREAD_MUTEX_RECURSIVE_NP) { ++(mutex->__data.__count); }
	return 0;
}
#define __pthread_mutex_lock(mutex, this)   __thread_mutex_lock((mutex), (this))


LIB_FUNC int pthread_mutex_lock(pthread_mutex_t* mutex) {
	return __thread_mutex_lock(mutex, __thread_self());
}


LIB_FUNC int __thread_mutex_unlock(pthread_mutex_t* mutex, const _pthread_descr this) {
	if (mutex->__data.__owner == this) {
		if (mutex->__data.__kind == PTHREAD_MUTEX_RECURSIVE_NP) {
			if (--(mutex->__data.__count)) { return 0; }
		}
		mutex->__data.__owner = 0;
		UNLOCK((atomic volatile int*)&mutex);
	}
	else if (mutex->__data.__kind == PTHREAD_MUTEX_ERRORCHECK_NP) { return EPERM; }
	return 0;
}
#define __pthread_mutex_unlock(mutex, this)   __thread_mutex_unlock((mutex), (this))


LIB_FUNC int pthread_mutex_unlock(pthread_mutex_t* mutex) {
	return __thread_mutex_unlock(mutex, __thread_self());
}


LIB_FUNC void pthread_cleanup_push(void(*func)(void*), void* arg) {
	atomic _pthread_descr this = __thread_self();
	struct thread_cleanup_t* tmp;
	__NO_ASYNC_CANCEL_BEGIN_(this);
	tmp = (struct thread_cleanup_t*)malloc(sizeof(struct thread_cleanup_t));
	tmp->func = func;
	tmp->arg = arg;
	LOCK((atomic volatile int*)this);
	tmp->next = this->cleanup_stack;
	this->cleanup_stack = tmp;
	free(tmp);
	UNLOCK((atomic volatile int*)this);
}


LIB_FUNC void pthread_cleanup_pop(int execute) {
	atomic _pthread_descr this = __thread_self();
	struct thread_cleanup_t* tmp;
	__NO_ASYNC_CANCEL_BEGIN_(this);
	LOCK((atomic volatile int*)this);
	tmp = this->cleanup_stack;
	this->cleanup_stack = tmp->next;
	UNLOCK((atomic volatile int*)this);
	if (execute) { tmp->func(tmp->arg); }
	tmp = (struct thread_cleanup_t*)NULL;
}


LIB_FUNC void __pthread_lock(struct _pthread_fastlock* restrict lock) {
	register int cnt = 0;
	struct timespec tm = { 0 };
	while (atomic_test_and_set(&lock->__spinlock)) {
		if (cnt < MAX_SPIN_COUNT) {
			sched_yield();
			cnt++;
		} else {
			tm.tv_sec = 0;
			tm.tv_nsec = SPIN_SLEEP_DURATION;
			nanosleep(&tm, 0);
			cnt = 0;
		}
	}
}


LIB_FUNC int __pthread_trylock(struct _pthread_fastlock* restrict lock) {
	return atomic_test_and_set(&lock->__spinlock);
}
#define TRYLOCK(td)   __pthread_trylock(&((td)->lock))


LIB_FUNC int __pthread_unlock(struct _pthread_fastlock* restrict lock) {
	lock->__spinlock = PTHREAD_SPIN_UNLOCKED;
	return 0;
}


/** Sleep a little (reschedule for this time) */
LIB_FUNC void __thread_sleep(void) {
	struct timespec reg = { 0 };
	reg.tv_sec = 0;
	reg.tv_nsec = SPIN_SLEEP_DURATION;
	nanosleep(&reg, 0);
}


/** Cleanup / remove zombie thread */
LIB_FUNC int __thread_cleanup(_pthread_descr td) {
	register int cnt = 0;
	do {
		++cnt;
		sched_yield();
		__thread_sleep();
		sched_yield();
	} while (TRYLOCK(td) && (cnt < MAX_SPIN_COUNT));
	if (td->stack_free) { munmap(td->stack_begin, td->stack_size); }
	return 0;
}


/** Cleanup / remove zombie thread */
LIB_FUNC void __thread_cleanup_helper(void* restrict td) {
	register int cnt = 0;
	do {
		++cnt;
		sched_yield();
		__thread_sleep();
		sched_yield();
	} while (TRYLOCK((_pthread_descr)td) && (cnt < MAX_SPIN_COUNT));
	if (((_pthread_descr)td)->stack_free) { munmap(((_pthread_descr)td)->stack_begin, ((_pthread_descr)td)->stack_size); }
}


/** Suspend until timeout or restart signal */
LIB_FUNC int __thread_suspend_till(_pthread_descr this, int cancel, const struct timespec* restrict abstime) {
	sigset_t newmask, oldmask;
	struct timeval tv = { 0 };
	struct timespec reg = { 0 };
	int retval = 0;
	gettimeofday(&tv, 0);
	reg.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
	reg.tv_sec = abstime->tv_sec - tv.tv_sec;
	if (reg.tv_nsec < 0) {
		reg.tv_nsec += 1000000000;
		reg.tv_sec -= 1;
	}
	this->p_sig = 0;
	sigemptyset(&newmask);
	if (sigaddset(&newmask, PTHREAD_SIG_RESTART) < 0) { return -1; }
	sigprocmask(SIG_UNBLOCK, &newmask, &oldmask);
	while (this->p_sig != PTHREAD_SIG_RESTART) {
		if (cancel && (this->cancelstate == PTHREAD_CANCEL_ENABLE) && this->canceled) { break; }
		if (reg.tv_sec < 0 || nanosleep(&reg, &reg) == 0) {
			retval = ETIMEDOUT;
			break;
		}
	}
	sigprocmask(SIG_SETMASK, &oldmask, 0);
	return retval;
}


LIB_FUNC int __rt_sigsuspend(const sigset_t* restrict mask, const long nr) {
	return (int)syscall2(SYS_rt_sigsuspend, (long)mask, nr);
}


LIB_FUNC int sigsuspend(const sigset_t* restrict mask) {
	return __rt_sigsuspend(mask, NSIG_S3);
}
#define __libc_sigsuspend(mask)   sigsuspend((mask))


/** Suspend until restart signal */
LIB_FUNC void __thread_suspend(_pthread_descr this, const int cancel) {
	sigset_t mask;
	this->p_sig = 0;
	sigprocmask(SIG_SETMASK, 0, &mask);
	sigdelset(&mask, PTHREAD_SIG_RESTART);
	while (this->p_sig != PTHREAD_SIG_RESTART) {
		if (cancel && (this->cancelstate == PTHREAD_CANCEL_ENABLE) && this->canceled) { break; }
		sigsuspend(&mask);
	}
}


/** Restart a thread */
LIB_FUNC void __thread_restart(_pthread_descr td) {
	kill(td->pid, PTHREAD_SIG_RESTART);
	sched_yield();
	sched_yield();
}


/** Restart signal handler */
LIB_FUNC void pthread_handle_sigrestart(const int sig) {
	_pthread_descr this = __thread_self();
	this->p_sig = (char)sig;
}


/** Dispatch a signal to ALL threads used for SIG{SEGV, FPE, ...} and main thread exits */
LIB_FUNC void kill_all_threads(const int sig, const int main2) {
	if (main2) { kill(_main_thread.pid, sig); }
	_pthread_descr cur;
	register int i;
	for (i = 0; i < NR_BUCKETS; ++i) {
		cur = _thread_hash_tid[i];
		for (; (cur && (cur != manager_thread)); cur = cur->next) { kill(cur->pid, sig); }
	}
}


/** Cancel signal */
LIB_FUNC void pthread_handle_sigcancel(const UNUSED int sig, const siginfo_t* restrict info, const UNUSED void* restrict arg) {
	_pthread_descr this = __thread_self();
	if (this == manager_thread) {
		const int pid = info->si_pid;
		if (pid == _main_thread.pid) {
			sched_yield();
			kill_all_threads(PTHREAD_SIG_CANCEL, 0);
			sched_yield();
			__thread_sleep();
			kill_all_threads(SIGKILL, 0);
			__thread_sleep();
			_Exit(0);
		}
	} else if (this == &_main_thread) {
		kill(manager_thread->pid, PTHREAD_SIG_CANCEL);
		waitpid(manager_thread->pid, 0, (int)(WNOHANG | __WCLONE));
		siglongjmp(_main_thread.jmp_exit, 1);
	} else if (this->cancelstate == PTHREAD_CANCEL_ENABLE) {
		this->canceled = 1;
		if (this->canceltype == PTHREAD_CANCEL_ASYNCHRONOUS) { __pthread_exit(PTHREAD_CANCELED); }
	}
}


/** NOP function */
LIB_FUNC int __thread_nop(void) {
	nop();
	return 0;
}


LIB_FUNC int pthread_condattr_init(const UNUSED pthread_condattr_t* attr) {
	return 0;
}


LIB_FUNC int pthread_condattr_destroy(const UNUSED pthread_condattr_t* attr) {
	return 0;
}


LIB_FUNC void __thread_start__key(const UNUSED _pthread_descr td) {
	return;
}


LIB_FUNC void __thread_exit__key(const UNUSED _pthread_descr td) {
	return;
}


/** Machine depending thread register */
LIB_FUNC _pthread_descr __thread_set_register(void* arg) {
#ifdef ARCHALPHA
	vasm("call_pal 159;" : : "r,i,n"(arg) );
#elif defined(ARCHSPARC)
	vasm("mov %0, %%g6;" : : "r,i,n"(arg) );
#elif defined(ARCHS390)
	vasm("sar %%a0, %0;" : : "d"(arg) );
#elif defined(ARCHITANIUM)
	vasm("mov r13 = %0;" : : "r,i,n"(arg) );
#endif
	return (_pthread_descr)arg;
}


LIB_FUNC int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex) {
	_pthread_descr this = __thread_self();
	_pthread_descr* tmp;
	if (mutex->__data.__owner != this) { return EINVAL; }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	LOCK((atomic volatile int*)cond);
	tmp = &(cond->__data.wait_chain);
	this->waitnext = 0;
	while (*tmp) { tmp = &((*tmp)->waitnext); }
	this->waitprev = tmp;
	*tmp = this;
	UNLOCK((atomic volatile int*)cond);
	pthread_mutex_unlock(mutex);
	__thread_suspend(this, 1);
	pthread_mutex_lock(mutex);
	LOCK((atomic volatile int*)cond);
	if (this->waitnext) {
		this->waitnext->waitprev = this->waitprev;
		*(this->waitprev) = this->waitnext;
	}
	else { *(this->waitprev) = 0; }
	UNLOCK((atomic volatile int*)cond);
	return 0;
}


LIB_FUNC int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* restrict mutex, const struct timespec* restrict abstime) {
	_pthread_descr this = __thread_self();
	_pthread_descr* tmp;
	if (mutex->__data.__owner != this) { return EINVAL; }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	LOCK((atomic volatile int*)cond);
	tmp = &(cond->__data.wait_chain);
	this->waitnext = 0;
	while (*tmp) { tmp = &((*tmp)->waitnext); }
	this->waitprev = tmp;
	*tmp = this;
	UNLOCK((atomic volatile int*)cond);
	pthread_mutex_unlock(mutex);
	const int retval = __thread_suspend_till(this, 1, abstime);
	pthread_mutex_lock(mutex);
	LOCK((atomic volatile int*)cond);
	if (this->waitnext) {
		this->waitnext->waitprev = this->waitprev;
		*(this->waitprev) = this->waitnext;
	} else { *(this->waitprev) = 0; }
	UNLOCK((atomic volatile int*)cond);
	__NO_ASYNC_CANCEL_END_(this);
	return retval;
}


LIB_FUNC int pthread_cond_destroy(pthread_cond_t* restrict c) {
	if (c->__data.__lock && c->__data.__nwaiters) {
		a_or((volatile int*)&c->__data.__nwaiters, (int)0x80000000);
		a_inc((volatile int*)&c->__data.__broadcast_seq);
		wake((atomic volatile int*)&c->__data.__broadcast_seq, -1, 0);
		int cnt;
		while ((cnt = (int)c->__data.__nwaiters) & 0x7fffffff) {
			__wait((atomic volatile int*)&c->__data.__nwaiters, 0, cnt, 0);
		}
	}
	return 0;
}


LIB_FUNC int posix_spawnattr_init(posix_spawnattr_t* attr) {
	*attr = (posix_spawnattr_t) { .__sd.bits = { 0 }, .__ss.bits = { 0 }, 0, { 0 }, 0, 0, 0 };
	return 0;
}


LIB_FUNC int posix_spawnattr_destroy(const UNUSED posix_spawnattr_t* attr) {
	return 0;
}


LIB_FUNC int posix_spawnattr_setflags(posix_spawnattr_t* attr, const short flags) {
	attr->__flags = flags;
	return 0;
}


LIB_FUNC int posix_spawnattr_setsigdefault(posix_spawnattr_t* restrict attr, const sigset_t* restrict def) {
	attr->__sd = *def;
	return 0;
}


LIB_FUNC int posix_spawnattr_setsigmask(posix_spawnattr_t* restrict attr, const sigset_t* restrict mask) {
	attr->__ss = *mask;
	return 0;
}


LIB_FUNC int __timedwait_cp(volatile int* restrict addr, const int val, const clockid_t clk, const struct timespec* restrict at, const int priv) {
	register int _priv = priv;
	struct timespec to = { 0 }, *top = 0;
	if (_priv) { _priv = 128; }
	if (at) {
		if ((unsigned long)at->tv_nsec >= 1000000000UL) { return EINVAL; }
		else if (clock_gettime(clk, &to)) { return EINVAL; }
		to.tv_sec = at->tv_sec - to.tv_sec;
		if ((to.tv_nsec = at->tv_nsec - to.tv_nsec) < 0) {
			to.tv_sec--;
			to.tv_nsec += 1000000000;
		}
		if (to.tv_sec < 0) { return ETIMEDOUT; }
		top = &to;
	}
	int r = -(int)syscall4(SYS_futex, (long)addr, (FUTEX_WAIT | _priv), val, (long)top);
	if (r == ENOSYS) { r = -(int)(syscall4(SYS_futex, (long)addr, FUTEX_WAIT, val, (long)top)); }
	if (r != EINTR && r != ETIMEDOUT && r != ECANCELED) { r = 0; }
	return r;
}


LIB_FUNC int __timedwait(volatile int*restrict addr, const int val, const clockid_t clk, const struct timespec* restrict at, const int priv) {
	int cs;
	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	const int r = __timedwait_cp(addr, val, clk, at, priv);
	__pthread_setcancelstate(cs, 0);
	return r;
}


/** Return error status of asynchronous I/O request */
LIB_FUNC int aio_error(const struct aiocb* restrict aiocbp) {
	pthread_mutex_lock(&__aio_requests_mutex);
	const int ret = aiocbp->__error_code;
	pthread_mutex_unlock(&__aio_requests_mutex);
	return ret;
}
#define aio_error64(aiocbp)   aio_error((aiocbp))


LIB_FUNC struct requestlist* __aio_find_req(aiocb_union* elem) {
	struct requestlist* runp = requests;
	int fildes = elem->aiocb.aio_fildes;
	while (runp != NULL && runp->aiocbp->aiocb.aio_fildes < fildes) { runp = runp->next_fd; }
	if (runp != NULL) {
		if (runp->aiocbp->aiocb.aio_fildes != fildes) { runp = NULL; }
		else { while (runp != NULL && runp->aiocbp != elem) { runp = runp->next_prio; } }
	}
	return runp;
}


LIB_FUNC struct requestlist* __aio_find_req_fd(int fildes) {
	struct requestlist* runp = requests;
	while (runp != NULL && runp->aiocbp->aiocb.aio_fildes < fildes) { runp = runp->next_fd; }
	return (struct requestlist*)((runp != NULL) && (runp->aiocbp->aiocb.aio_fildes == fildes) ? runp : NULL);
}


LIB_FUNC void __aio_free_request(struct requestlist* elem) {
	elem->running = no;
	elem->next_prio = freelist;
	freelist = elem;
}


/** Suspend until termination of a requests */
LIB_FUNC int aio_suspend(struct aiocb* list[], int nent, const struct timespec* timeout) {
	if (PREDICT_UNLIKELY(nent < 0)) {
		set_errno(EINVAL);
		return -1;
	}
	struct waitlist _waitlist[nent];
	struct requestlist* _requestlist[nent];
#   ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
#   endif
	bool any = false;
	int result = 0, cnt;
	unsigned int cntr = 1;
	pthread_mutex_lock(&__aio_requests_mutex);
	for (cnt = 0; cnt < nent; ++cnt) {
		if (list[cnt] != NULL) {
			if (list[cnt]->__error_code == EINPROGRESS) {
				_requestlist[cnt] = __aio_find_req((aiocb_union*)list[cnt]);
				if (_requestlist[cnt] != NULL) {
#   ifndef DONT_NEED_AIO_MISC_COND
					_waitlist[cnt].cond = &cond;
#   endif
					_waitlist[cnt].result = NULL;
					_waitlist[cnt].next = _requestlist[cnt]->waiting;
					_waitlist[cnt].counterp = &cntr;
					_waitlist[cnt].sigevp = NULL;
#   ifdef BROKEN_THREAD_SIGNALS
					_waitlist[cnt].caller_pid = 0;
#   endif
					_requestlist[cnt]->waiting = &_waitlist[cnt];
					any = true;
				} else { break; }
			} else { break; }
		}
	}
	if (cnt == nent && any) {
		struct clparam _clparam = {
			.__list = (struct aiocb*)&list,
			.__waitlist = _waitlist,
			.__requestlist = _requestlist,
#   ifndef DONT_NEED_AIO_MISC_COND
			.cond = &cond,
#   endif
			.nent = nent
		};
		pthread_cleanup_push(__thread_cleanup_helper, &_clparam);
#   ifdef DONT_NEED_AIO_MISC_COND
		result = do_aio_misc_wait(&cntr, timeout);
#   else
		if (timeout == NULL) {
			result = pthread_cond_wait(&cond, &__aio_requests_mutex);
		} else {
			struct timeval now;
			struct timespec abstime;
			gettimeofday(&now, NULL);
			abstime.tv_nsec = timeout->tv_nsec + now.tv_usec * 1000;
			abstime.tv_sec = timeout->tv_sec + now.tv_sec;
			if (abstime.tv_nsec >= 1000000000) {
				abstime.tv_nsec -= 1000000000;
				abstime.tv_sec += 1;
			}
			result = pthread_cond_timedwait(&cond, &__aio_requests_mutex, &abstime);
		}
#   endif
		pthread_cleanup_pop(0);
	}
	while (cnt-- > 0) {
		if (list[cnt] != NULL && list[cnt]->__error_code == EINPROGRESS) {
			struct waitlist** listp;
			assert(_requestlist[cnt] != NULL);
			listp = &_requestlist[cnt]->waiting;
			while (*listp != NULL && *listp != &_waitlist[cnt]) { listp = &(*listp)->next; }
			if (*listp != NULL) { *listp = (*listp)->next; }
		}
	}
#   ifndef DONT_NEED_AIO_MISC_COND
	if (PREDICT_UNLIKELY(pthread_cond_destroy(&cond) != 0)) { abort(); }
#   endif
	if (result != 0) {
#   ifndef DONT_NEED_AIO_MISC_COND
		if (result == ETIMEDOUT) { set_errno(EAGAIN); }
		else
#   endif
		set_errno(result);
		result = -1;
	}
	pthread_mutex_unlock(&__aio_requests_mutex);
	return result;
}
#define aio_suspend64(list, nent, timeout)   aio_suspend((list), (nent), (timeout))


LIB_FUNC int lio_wait(struct lio_state* st) {
	int i, err, got_err = 0;
	int cnt = st->cnt;
	struct aiocb** cbs = st->cbs;
	loop_forever {
		for (i = 0; i < cnt; i++) {
			if (!cbs[i]) continue;
			err = aio_error(cbs[i]);
			if (err == EINPROGRESS) { break; }
			else if (err) { got_err = 1; }
			cbs[i] = 0;
		}
		if (i == cnt) {
			if (got_err) { set_errno(EIO); return -1; }
			return 0;
		} else if (aio_suspend((void*)cbs, cnt, 0)) return -1; }
}


LIB_FUNC void notify_signal(const struct sigevent* restrict sev) {
	siginfo_t si = {
		.si_signo = sev->sigev_signo,
		.si_value = sev->sigev_value,
		.si_code = SI_ASYNCIO,
		.si_pid = getpid(),
		.si_uid = getuid()
	};
	syscall3(SYS_rt_sigqueueinfo, (long)si.si_pid, (long)si.si_signo, (long)&si);
}


LIB_FUNC void* wait_thread(void* p) {
	struct lio_state* st = p;
	struct sigevent* sev = st->sev;
	lio_wait(st);
	free(st);
	switch (sev->sigev_notify) {
		case SIGEV_SIGNAL:
			notify_signal(sev);
			return 0;
		case SIGEV_THREAD:
			sev->sigev_notify_function(sev->sigev_value);
			return 0;
		default: return 0;
	}
	UNREACHABLE
}


/* TODO: Add PTHREAD functions
int pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void *(*)(void*), void *restrict);
int pthread_detach(pthread_t);
noreturn void pthread_exit(void*);
int pthread_join(pthread_t, void **);
pthread_t pthread_self(void);
#if IS_NOT_CPLUSPLUS
#   define pthread_equal(x, y)   ((x)==(y))
#else
int pthread_equal(pthread_t, pthread_t);
#endif
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
void pthread_testcancel(void);
int pthread_cancel(pthread_t);
int pthread_getschedparam(pthread_t, int *restrict, struct sched_param *restrict);
int pthread_setschedparam(pthread_t, int, const struct sched_param *);
int pthread_setschedprio(pthread_t, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_mutex_init(pthread_mutex_t *restrict, const pthread_mutexattr_t *restrict);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_timedlock(pthread_mutex_t *restrict, const struct timespec *restrict);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_consistent(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict, int *restrict);
int pthread_mutex_setprioceiling(pthread_mutex_t *restrict, int, int *restrict);
int pthread_cond_init(pthread_cond_t *restrict, const pthread_condattr_t *restrict);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_wait(pthread_cond_t *restrict, pthread_mutex_t *restrict);
int pthread_cond_timedwait(pthread_cond_t *restrict, pthread_mutex_t *restrict, const struct timespec *restrict);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_rwlock_init(pthread_rwlock_t *restrict, const pthread_rwlockattr_t *restrict);
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict, const struct timespec *restrict);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict, const struct timespec *restrict);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_spin_init(pthread_spinlock_t *, int);
int pthread_spin_destroy(pthread_spinlock_t *);
int pthread_spin_lock(pthread_spinlock_t *);
int pthread_spin_trylock(pthread_spinlock_t *);
int pthread_spin_unlock(pthread_spinlock_t *);
int pthread_barrier_init(pthread_barrier_t *restrict, const pthread_barrierattr_t *restrict, unsigned);
int pthread_barrier_destroy(pthread_barrier_t *);
int pthread_barrier_wait(pthread_barrier_t *);
int pthread_key_create(pthread_key_t *, void (*)(void*));
int pthread_key_delete(pthread_key_t);
void *pthread_getspecific(pthread_key_t);
int pthread_setspecific(pthread_key_t, const void *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getguardsize(const pthread_attr_t *restrict, size_t *restrict);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_getstacksize(const pthread_attr_t *restrict, size_t *restrict);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_attr_getstack(const pthread_attr_t *restrict, void **restrict, size_t *restrict);
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int pthread_attr_getscope(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_getschedpolicy(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_getschedparam(const pthread_attr_t *restrict, struct sched_param *restrict);
int pthread_attr_setschedparam(pthread_attr_t *restrict, const struct sched_param *restrict);
int pthread_attr_getinheritsched(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_condattr_getclock(const pthread_condattr_t *restrict, clockid_t *restrict);
int pthread_condattr_getpshared(const pthread_condattr_t *restrict, int *restrict);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict, int *restrict);
int pthread_barrierattr_destroy(pthread_barrierattr_t *);
int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict, int *restrict);
int pthread_barrierattr_init(pthread_barrierattr_t *);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
int pthread_getconcurrency(void);
int pthread_setconcurrency(int);
int pthread_getcpuclockid(pthread_t, clockid_t *);
void _pthread_cleanup_push(struct __ptcb *, void (*)(void*), void *);
void _pthread_cleanup_pop(struct __ptcb *, int);
#define pthread_cleanup_push(f, x)   do { struct __ptcb __cb; _pthread_cleanup_push(&__cb, f, x);
#define pthread_cleanup_pop(r)   _pthread_cleanup_pop(&__cb, (r)); } while(0x0)
int pthread_getaffinity_np(pthread_t, size_t, struct cpu_set_t *);
int pthread_setaffinity_np(pthread_t, size_t, const struct cpu_set_t *);
int pthread_getattr_np(pthread_t, pthread_attr_t *);
pthread_t __pthread_self_init(void);
int __clone(int (*)(void*), void *, int, void *, ...);
int __set_thread_area(void*);
int __libc_sigprocmask(int, const sigset_t *, sigset_t *);
void __unmapself(void *, size_t);
int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
void __wait(volatile int *, volatile int *, int, int);
void __acquire_ptc(void);
void __release_ptc(void);
void __inhibit_ptc(void);
void __block_all_sigs(void*);
void __block_app_sigs(void*);
*/


#endif  // PTHREAD_H


/* LINKAGE SYMBOLS */


#ifndef STANDARDLIB_H
#define STANDARDLIB_H   (1)


#define __ssp_overlap(a, b, l)   (((a) <= (b) && (b) < (a) + (l)) || ((b) <= (a) && (a) < (b) + (l)))


#ifdef MAIN_AUXVEC_ARG
#   define MAIN_AUXVEC_DECL   , void*
#   define MAIN_AUXVEC_PARAM   , auxvec
#else
#   define MAIN_AUXVEC_DECL
#   define MAIN_AUXVEC_PARAM
#endif


static UNUSED void (*funcs[32])(void);
typedef int (*cmpfun)(const void*, const void*);


static UNUSED struct fl {
	struct fl* next;
	void (*f[32])(void*);
	void *a[32];
} exit_struct, *head;


LIB_FUNC void call(void* p) {
	((void(*)(void))(uintptr_t)p)();
}


LIB_FUNC noreturn COLD void _Exit(const int code) {
	syscall1void(SYS_exit_group, code);
	loop_forever { syscall1void(SYS_exit, code); }
	UNREACHABLE
}
#define quick_exit(code)   _Exit((code)); UNREACHABLE
#define _exit(code)   _Exit((code)); UNREACHABLE
#define exit(code)   _Exit((code)); UNREACHABLE
#define TWO_ARGS_REQUIRED   do { if (PREDICT_UNLIKELY(argc != 2)) { puts_err_no_output("Expected one parameter!"); exit(EXIT_FAILURE); } } while (0x0)


LIB_FUNC noreturn COLD void fast_exit(const int code) {
	syscall1void(SYS_exit, code);
	UNREACHABLE
}
#define TWO_ARGS_REQUIRED_F   do { if (PREDICT_UNLIKELY(argc != 2)) { puts_err_no_output("Expected one parameter!"); fast_exit(EXIT_FAILURE); } } while (0x0)


LIB_FUNC void __funcs_on_exit(void) {
	void (*func)(void*), *arg;
	LOCK(memlock);
	for (; head; head = head->next, progslot = 32) {
		while ((progslot--) > 0) {
			func = head->f[progslot];
			arg = head->a[progslot];
			UNLOCK(memlock);
			func(arg);
			LOCK(memlock);
		}
	}
}


LIB_FUNC int __cxa_atexit(void (*func)(void*), void* arg, const UNUSED void* dso) {
	LOCK(memlock);
	if (!head) { head = &exit_struct; }
	if (progslot == 32) {
		struct fl* new_fl = calloc(sizeof(struct fl), 1);
		if (!new_fl) { UNLOCK(memlock); return -1; }
		new_fl->next = head;
		head = new_fl;
		progslot = 0;
	}
	head->f[progslot] = func;
	head->a[progslot] = arg;
	++progslot;
	UNLOCK(memlock);
	return 0;
}


#ifdef ARCHARM
LIB_FUNC int __aeabi_atexit(void* obj, void (*func)(void*), void* d) {
	return __cxa_atexit(func, obj, d);
}
#endif


LIB_FUNC int atexit(void (*func)(void)) {
	return __cxa_atexit(call, (void*)(uintptr_t)func, 0);
}


LIB_FUNC void __funcs_on_quick_exit(void) {
	void (*func)(void);
	LOCK(memlock);
	while (exit_counter > 0) {
		func = funcs[--exit_counter];
		UNLOCK(memlock);
		func();
		LOCK(memlock);
	}
}


LIB_FUNC int at_quick_exit(void (*func)(void)) {
	if (exit_counter == 32) { return -1; }
	LOCK(memlock);
	funcs[exit_counter++] = func;
	UNLOCK(memlock);
	return 0;
}


#if (defined(USE_BAREBONES) && (__STDC_HOSTED__ == 1))
#   error   "`USE_BAREBONES` cannot be defined while `__STDC_HOSTED__ == 1`"
#elif (defined(USE_BAREBONES) && (__STDC_HOSTED__ == 0))


#define rargc   const int argc
#define rargv   const char* restrict argv[]
#define renvp   const char* restrict envp[]
#define mainargs   const int argc, const char* restrict argv[]
#define mainargsenv   const int argc, const char* restrict argv[], const char* restrict envp[]
#define mainargsapple   const int argc, const char* restrict argv[], const char* restrict envp[], const char* restrict apple[]
#define rargc_t   const int
#define rargv_t   const char* restrict
#define renvp_t   const char* restrict
extern UNUSED int __libc_multiple_libcs;
UNUSED attr_hidden int __libc_argc;
UNUSED attr_hidden char* restrict * __libc_argv;
extern UNUSED attr_hidden void (*__preinit_array_start[])(rargc_t, rargv_t*, renvp_t*);
extern UNUSED attr_hidden void (*__preinit_array_end[])(rargc_t, rargv_t*, renvp_t*);
extern UNUSED attr_hidden void (*__init_array_start[])(rargc_t, rargv_t*, renvp_t*);
extern UNUSED attr_hidden void (*__init_array_end[])(rargc_t, rargv_t*, renvp_t*);
extern UNUSED void (*__fini_array_start[])(void) attr_hidden;
extern UNUSED void (*__fini_array_end[])(void) attr_hidden;
extern noreturn void _start(void);
//extern noreturn void weak_function main(void);
//extern int weak_function main(void);
//extern int weak_function main(int argc, char* argv[]);
//extern int weak_function main(int argc, char* argv[], char* env[]);
//extern int weak_function main(int argc, char* argv[], char* env[]);
//extern int weak_function main(int argc, char* argv[], char* env[], char* apple[]);
#ifndef NO_INITFINI
extern __attribute__((__constructor__)) void _init(void);
extern __attribute__((__destructor__)) void _fini(void);
#endif


extern noreturn void __stack_chk_fail(void);
noreturn void __stack_chk_fail(void) {
	const char align32 msg[32] = "*** STACK SMASHING DETECTED ***";
	puts_err_no_output(msg);
	abort();
}
#define __stack_chk_fail_local()   __stack_chk_fail()


extern void __libc_csu_init(rargc_t argc, rargv_t* argv, renvp_t* envp);
void __libc_csu_init(rargc_t argc, rargv_t* argv, renvp_t* envp) {
#   ifndef LIBC_NONSHARED  // For static executables, preinit happens right before init
	const size_t size_pre = (size_t)(__preinit_array_end - __preinit_array_start);
	for (register size_t i = 0; i < size_pre; i++) {
		(*__preinit_array_start[i]) (argc, argv, envp);
	}
#   endif
#   ifndef NO_INITFINI
	_init();
#   endif
	const size_t size = (size_t)(__init_array_end - __init_array_start);
	for (register size_t i = 0; i < size; i++) {
		(*__init_array_start[i]) (argc, argv, envp);
	}
}


extern void __libc_csu_fini(void);
void __libc_csu_fini(void) {
#   ifndef LIBC_NONSHARED
	register size_t i = (size_t)(__fini_array_end - __fini_array_start);
	while (i-- > 0) { (*__fini_array_start[i]) (); }
#      ifndef NO_INITFINI
	_fini();
#      endif
#   endif
}


/* FIXME: static UNUSED void libc_start_init(void) {
#   ifndef NO_INITFINI
	_init();
#   endif
	register uintptr_t a = (uintptr_t)&__init_array_start;
	for (; a < (uintptr_t)&__init_array_end; a += sizeof(void(*)())) {
		(*(void(**)())a)();
	}
}
#define __libc_start_init()   libc_start_init()
*/


extern UNUSED noreturn void __libc_start_main(int (*main)(rargc_t, rargv_t*, renvp_t*), rargc_t argc, rargv_t* argv);
UNUSED noreturn void __libc_start_main(int (*main)(rargc_t, rargv_t*, renvp_t*), rargc_t argc, rargv_t* argv) {
	renvp_t* envp = argc + argv + 1;
	// __init_libc(envp, argv[0]);
	// libc_start_init();
	_Exit(main(argc, argv, envp));
}
#ifndef LIBC_START_MAIN
#   define LIBC_START_MAIN   __libc_start_main
#endif


#ifdef NEEDS_STARTUP


#ifndef SHARED
#   ifndef THREAD_SET_STACK_GUARD
/** Only exported for architectures that do not store the stack guard canary in thread local area */
extern UNUSED uintptr_t attr_relro __stack_chk_guard;
#   endif
#   ifndef THREAD_SET_POINTER_GUARD
/** Only exported for architectures that do not store the pointer guard value in thread local area */
uintptr_t attr_relro attr_hidden attr_nocommon __pointer_chk_guard_local;
#   endif
#endif
#define DEFINE_INIT   1
#define DEFINE_FINI   1
UNUSED int __data_start = 0;
#define data_start   __data_start


extern noreturn void _dl_start(void);
noreturn void _dl_start(void) {
	abort();
}


extern noreturn void __libc_main(void);
noreturn void __libc_main(void) {
	_Exit(EXIT_SUCCESS);
}


LIB_FUNC void __init_ssp(const void* restrict entropy) {
	if (entropy) { memcpy_no_output(&__stack_chk_guard, entropy, SIZEOF_UINTPTR_T); }
	else { __stack_chk_guard = (uintptr_t)&__stack_chk_guard * 1103515245; }
	struct pthread* restrict pself = __pthread_self();
	pself->CANARY = (uintptr_t)__stack_chk_guard;
}


#endif  // NEEDS_STARTUP


#endif  // USE_BAREBONES


#endif


/* STANDARD LIBRARY DEFINITIONS (<stdlib.h>) */


#if (!(defined(_STDLIB_H) || defined(_STDLIB_H_) || defined(_STDLIB_IMPL_H) || defined(_STDLIB_IMPL_H_) || defined(_STDLIB_EXT_H) || defined(_STDLIB_EXT_H_) || defined(ITOA_H) || defined(_ITOA_H) || defined(_ITOA_H_)))  // http://www.cplusplus.com/reference/cstdlib/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdlib.h.html
#define STDLIB_H   (1)
#define _STDLIB_H   (1)
#define _STDLIB_H_   (1)
#define _STDLIB_IMPL_H   (1)
#define _STDLIB_IMPL_H_   (1)
#define _STDLIB_EXT_H   (1)
#define _STDLIB_EXT_H_   (1)
#define ITOA_H   (1)  // <itoa.h>
#define _ITOA_H   (1)
#define _ITOA_H_   (1)
#define YESNO_H_   (1)
#define _PTY_H   (1)
#define PTY_H   (1)
#define SYS_PTY_H   (1)
#define _SYS_PTY_H_   (1)


#define FSETLOCKING_QUERY   0
#define FSETLOCKING_INTERNAL   1
#define FSETLOCKING_BYCALLER   2
#define FDOP_CLOSE   1
#define FDOP_DUP2   2
#define FDOP_OPEN   3
#define TIME_UTC   (1)
#define CLOCK_REALTIME   (0)


typedef struct attr_packed fdop {
	struct fdop *next, *prev;
	int cmd, fd, srcfd, oflag;
	mode_t mode;
	char path[];
} fdop_t;


#ifndef PTYNAME1
/** Letters indicating a series of pseudo terminals */
#   define PTYNAME1   "pqrsPQRS"
#endif
#ifndef PTYNAME2
/** Letters indicating the position within a series */
#   define PTYNAME2   "0123456789abcdefghijklmnopqrstuv"
#endif
const UNUSED attr_hidden char __libc_ptyname1[16] = PTYNAME1;
const UNUSED attr_hidden char __libc_ptyname2[64] = PTYNAME2;


// BIT <-> STRING CONVERSIONS

/** Convert a literal byte to a string */
LIB_FUNC NONNULL void bit8tostr(const uint8_t bits, char* restrict outstr) {
	register uint8_t i, k;
	for (i = 8, k = 0; ((i != 0) && k != 9); i--, k++) {
		if (test_bit8(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[9] = '\0';
}


/** Convert two literal bytes (uint16_t) to a string */
LIB_FUNC NONNULL void bit16tostr(const uint16_t bits, char* restrict outstr) {
	register uint8_t i, k;
	for (i = 16, k = 0; ((i != 0) && k != 17); i--, k++) {
		if (test_bit16(bits, i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[17] = '\0';
}


/** Convert four literal bytes (uint32_t) to a string */
LIB_FUNC NONNULL void bit32tostr(const uint32_t bits, char* restrict outstr) {
	register uint8_t i, k;
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[33] = '\0';
}


/** Convert eight literal bytes (64-bit value) to a string */
LIB_FUNC NONNULL void bit64tostr(const uint64_t bits, char* restrict outstr) {
	register uint8_t i, k;
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[65] = '\0';
}


/** Convert a long integer into a string of literal bytes */
LIB_FUNC NONNULL void bitlongtostr(const unsigned long bits, char* restrict outstr) {
#   if LONG_EQ_INT
	bit32tostr((uint32_t)bits, outstr);
#   else
	bit64tostr((uint64_t)bits, outstr);
#   endif
}


/** Convert a 32-bit float as literal bits to a string */
LIB_FUNC NONNULL void floatbittostr(const float fbits, char* restrict outstr) {
	register uint8_t i, k;
	register const uint32_t bits = FLT_TO_U32(fbits);
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[33] = '\0';
}


/** Convert a double (64-bit float-point) as literal bits to a string */
LIB_FUNC NONNULL void doublebittostr(const double dbits, char* restrict outstr) {
	register uint8_t i, k;
	register const uint64_t bits = DBL_TO_U64(dbits);
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[65] = '\0';
}


#if SUPPORTS_COMPLEX
/** Convert a complex float (64-bit value) as literal bits to a string */
LIB_FUNC NONNULL void cfloatbittostr(const complex_float cbits, char* restrict outstr) {
	register uint8_t i, k;
	register const uint64_t bits = (uint64_t)CFLT_TO_U64(cbits);
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[65] = '\0';
}
#endif


#if SUPPORTS_DECIMAL32
/** Convert a decimal32 as literal bits to a string */
LIB_FUNC NONNULL void decimal32bittostr(const decimal32 dbits, char* restrict outstr) {
	register uint8_t i, k;
	register const uint32_t bits = (uint32_t)DEC32_TO_U32(dbits);
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[33] = '\0';
}
#endif


#if SUPPORTS_DECIMAL64
/** Convert a decimal64 as literal bits to a string */
LIB_FUNC NONNULL void decimal64bittostr(const decimal64 dbits, char* restrict outstr) {
	register uint8_t i, k;
	register const uint64_t bits = (uint64_t)DEC64_TO_U64(dbits);
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	outstr[65] = '\0';
}
#endif


// PRINT LITERAL BIT VALUES AS STRING

/** Convert a literal byte to a string and print the value */
LIB_FUNC void printbit8(const uint8_t bits) {
	register uint8_t i, k;
	char align16 outstr[9] = { 0 };
	for (i = 8, k = 0; ((i != 0) && k != 9); i--, k++) {
		if (test_bit8(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


/** Convert two literal bytes (16-bit value) to a string and print the value */
LIB_FUNC void printbit16(const uint16_t bits) {
	register uint8_t i, k;
	char align16 outstr[17] = { 0 };
	for (i = 16, k = 0; ((i != 0) && k != 17); i--, k++) {
		if (test_bit16(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


/** Convert four literal bytes (32-bit value) to a string and print the value */
LIB_FUNC void printbit32(const uint32_t bits) {
	register uint8_t i, k;
	char align32 outstr[33] = { 0 };
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


/** Convert eight literal bytes (64-bit value) to a string and print the value */
LIB_FUNC void printbit64(const uint64_t bits) {
	register uint8_t i, k;
	char align64 outstr[65] = { 0 };
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


/** Convert a float-point (32-bit value) into a literal binary string and print the string */
LIB_FUNC void printfloatbit(const float fbits) {
	register uint8_t i, k;
	register const uint32_t bits = FLT_TO_U32(fbits);
	char align32 outstr[33] = { 0 };
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


/** Convert a double (64-bit float-point value) into a literal binary string and print the string */
LIB_FUNC void printdoublebit(const double dbits) {
	register uint8_t i, k;
	register const uint64_t bits = DBL_TO_U64(dbits);
	char align64 outstr[65] = { 0 };
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}


#if SUPPORTS_COMPLEX
/** Convert a complex float (64-bit value) into a literal binary string and print the string */
LIB_FUNC void printcfloatbit(const complex_float cbits) {
	register uint8_t i, k;
	register const uint64_t bits = CFLT_TO_U64(cbits);
	char align64 outstr[65] = { 0 };
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}
#endif


#if SUPPORTS_DECIMAL32
/** Convert a decimal32 into a literal bit string and print the string */
LIB_FUNC void printdecimal32bit(const decimal32 dbits) {
	register uint8_t i, k;
	register const uint32_t bits = (uint32_t)DEC32_TO_U32(dbits);
	char align32 outstr[33] = { 0 };
	for (i = 32, k = 0; ((i != 0) && k != 33); i--, k++) {
		if (test_bit32(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}
#endif


#if SUPPORTS_DECIMAL64
/** Convert a decimal64 into a literal bit string and print the string */
LIB_FUNC void printdecimal64bit(const decimal64 dbits) {
	register uint8_t i, k;
	register const uint64_t bits = (uint64_t)DEC64_TO_U64(dbits);
	char align64 outstr[65] = { 0 };
	for (i = 64, k = 0; ((i != 0) && k != 65); i--, k++) {
		if (test_bit64(bits, (uint8_t)i, (uint8_t)1U)) { outstr[k] = '1'; }
		else { outstr[k] = '0'; }
	}
	puts_no_output(outstr);
}
#endif


// DATATYPE <-> STRING CONVERSIONS

#define ITOA_T   unsigned long long
#define _ITOA_WORD_TYPE   ITOA_T
#ifndef _ITOA_NEEDED
#   define _ITOA_NEEDED    (LONG_MAX != LLONG_MAX)
#endif


LIB_FUNC ATTR_CF int digitval(const int ch) {
	if (ch >= '0' && ch <= '9') { return (int)(ch - '0'); }
	else if (ch >= 'A' && ch <= 'Z') { return (int)(ch - 'A' + 10); }
	else if (ch >= 'a' && ch <= 'z') { return (int)(ch - 'a' + 10); }
	return -1;
}


LIB_FUNC ATTR_CF int hexval(const unsigned int x) {
	if ((x - '0') < 10) { return (int)(x - '0'); }
	register const unsigned int y = x | 32;
	if ((y - 'a') < 6) { return (int)(y - ('a' + 10)); }
	return -1;
}


LIB_FUNC ATTR_CF int digittoint(const char ch) {
	register int d = (int)(ch - '0');
	if ((unsigned)d < 10) { return d; }
	d = (int)(ch - 'a');
	if ((unsigned)d < 6) { return (int)(d + 10); }
	d = (int)(ch - 'A');
	if ((unsigned)d < 6) { return (int)(d + 10); }
	return -1;
}


/** Convert an unsigned char value into a char value without relying on signed overflow behavior */
LIB_FUNC ATTR_CF char wrapv(const unsigned char ch) {
	if (((unsigned int)ch) >= 0x80U) { return (char)(ch - 0x100); }
	return (char)ch;
}


/** Convert string to int8_t */
LIB_FUNC NONNULL ATTR_PF int8_t ato8(const char* restrict s) {
	register int8_t n = 0;
	register int neg = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (int8_t)((10 * n) + (*s++ - '0')); }
	return (int8_t)(neg ? -n : n);
}


/** Convert string to int8_t (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF int8_t xato8(const char* restrict s) {
	register int8_t n = 0;
	register int neg = 0;
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (int8_t)((10 * n) + (*s++ - '0')); }
	return (int8_t)(neg ? -n : n);
}


/** Convert string to uint8_t */
LIB_FUNC NONNULL ATTR_PF uint8_t atou8(const char* restrict s) {
	register uint8_t n = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (uint8_t)((10 * n) + (*s++ - '0')); }
	return n;
}


/** Convert string to uint8_t (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF uint8_t xatou8(const char* restrict s) {
	register uint8_t n = 0;
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (uint8_t)((10 * n) + (*s++ - '0')); }
	return n;
}


/** Convert string to short */
LIB_FUNC NONNULL ATTR_PF short atos(const char* restrict s) {
	register short n = 0;
	register int neg = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (short)((10 * n) + (*s++ - '0')); }
	return (short)(neg ? -n : n);
}


/** Convert string to short (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF short xatos(const char* restrict s) {
	register short n = 0;
	register int neg = 0;
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (short)((10 * n) + (*s++ - '0')); }
	return (short)(neg ? -n : n);
}


/** Convert string to unsigned short */
LIB_FUNC NONNULL ATTR_PF unsigned short atous(const char* restrict s) {
	register unsigned short n = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned short)((10 * n) + (*s++ - '0')); }
	return n;
}


/** Convert string to unsigned short (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF unsigned short xatous(const char* restrict s) {
	register unsigned short n = 0;
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned short)((10 * n) + (*s++ - '0')); }
	return n;
}


/** Convert string to int */
LIB_FUNC NONNULL ATTR_PF int atoi(const char* restrict s) {
	register int n = 0, neg = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (int)((10 * n) - (*s++ + '0')); }
	return (int)(neg ? -n : n);
}


/** Convert string to int (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF int xatoi(const char* restrict s) {
	register int n = 0, neg = 0;
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (int)((10 * n) + (*s++ - '0')); }
	return (int)(neg ? -n : n);
}


/** Convert string to unsigned int */
LIB_FUNC NONNULL ATTR_PF unsigned int atoui(const char* restrict s) {
	register unsigned int n = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned int)((10 * n) + (unsigned int)(*s++ - '0')); }
	return n;
}


/** Convert string to unsigned int (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF unsigned int xatoui(const char* restrict s) {
	register unsigned int n = 0;
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned int)((10 * n) + (unsigned int)(*s++ - '0')); }
	return n;
}


/** Convert string to long long */
LIB_FUNC NONNULL ATTR_PF long long atoll(const char* restrict s) {
	register long long n = 0;
	register int neg = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (long long)((10 * n) + (*s++ - '0')); }
	return (long long)(neg ? -n : n);
}


/** Convert string to long long (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF long long xatoll(const char* restrict s) {
	register long long n = 0;
	register int neg = 0;
	switch (*s) {
		case '-': neg = 1;  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (long long)((10 * n) + (*s++ - '0')); }
	return (long long)(neg ? -n : n);
}


/** Convert string to unsigned long long */
LIB_FUNC NONNULL ATTR_PF unsigned long long atoull(const char* restrict s) {
	register unsigned long long n = 0;
	while (PREDICT_UNLIKELY(isspace(*s))) { ++s; }
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned long long)((10 * n) + (unsigned long long)(*s++ - '0')); }
	return n;
}


/** Convert string to unsigned long long (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF unsigned long long xatoull(const char* restrict s) {
	register unsigned long long n = 0;
	switch (*s) {
		case '-':  attr_fallthrough
		case '+': ++s;  attr_fallthrough
		default: break;
	}
	while (PREDICT_LIKELY(isdigit(*s))) { n = (unsigned long long)((10 * n) + (unsigned long long)(*s++ - '0')); }
	return n;
}


/** Convert string to long */
LIB_FUNC NONNULL ATTR_PF long atol(const char* restrict s) {
#   if LONG_EQ_INT
	return (long)atoi(s);
#   else
	return (long)atoll(s);
#   endif
}


/** Convert string to long (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF long xatol(const char* restrict s) {
#   if LONG_EQ_INT
	return (long)xatoi(s);
#   else
	return (long)xatoll(s);
#   endif
}


/** Convert string to unsigned long */
LIB_FUNC NONNULL ATTR_PF unsigned long atoul(const char* restrict s) {
#   if LONG_EQ_INT
	return (unsigned long)atoui(s);
#   else
	return (unsigned long)atoull(s);
#   endif
}


/** Convert string to unsigned long (the string must only contain "0"-"9", "-", & "+") */
LIB_FUNC NONNULL ATTR_PF unsigned long xatoul(const char* restrict s) {
#   if LONG_EQ_INT
	return (unsigned long)xatoui(s);
#   else
	return (unsigned long)xatoull(s);
#   endif
}


LIB_FUNC NONNULL long a64l(const char* restrict s) {
	register int e = 0;
	register uint32_t x = 0;
	for (; e < 36 && *s; e += 6, s++) { x |= (uint32_t)((strchr(a64l_digits, *s) - a64l_digits) << e); }
	return (long)x;
}


/** Convert an integer to a string */
LIB_FUNC NONNULL ATTR_PF char* itoa(int value, char* result, const int base) {
	if (base < 2 || base > 36) { *result = '\0'; return result; }
	char *ptr = result, *ptr1 = result, tmp_char;
	register int tmp_value;
	do {
		tmp_value = value;
		value /= base;
		*ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - value * base)];
	} while (value);
	// Apply negative sign
	if (tmp_value < 0) { *ptr++ = '-'; }
	*ptr-- = '\0';
	while (ptr1 < ptr) {
		tmp_char = *ptr;
		*ptr-- = *ptr1;
		*ptr1++ = tmp_char;
	}
	return result;
}
#define _itoa(i, b)   itoa((i), (b))


/** Convert an integer to a string */
LIB_FUNC NONNULL ATTR_PF char* itoa2(int i, char b[]) {
	char* restrict p = b;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	return b;
}


/** Convert an unsigned 32-bit integer to a string */
LIB_FUNC NONNULL char* u32toa(const uint32_t value, char* restrict _string, const int radix) {
	char align64 buffer[33] = { 0 };
	char* restrict pos = &buffer[32];
	register int _digit;
	register uint32_t _value = value;
	do {
		_digit = (int)((int)_value % radix);
		_value = (uint32_t)((int)_value / radix);
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (_value != 0L);
	return memcpy(_string, pos, (size_t)(&buffer[32] - pos + 1));
}
#define _u32toa(value, _string, radix)   u32toa((value), (_string), (radix))


/** Convert an signed 64-bit integer to a string */
LIB_FUNC NONNULL char* i64toa(const int64_t value, char* restrict _string, const int radix) {
	register unsigned long long val;
	register int negative;
	char align64 buffer[66] = { 0 };
	char* restrict pos = &buffer[65];
	register int _digit;
	if (value < 0 && radix == 10) {
		negative = 1;
		val = (unsigned long long)-value;
	} else {
		negative = 0;
		val = (unsigned long long)value;
	}
	do {
		_digit = (int)((int)val % radix);
		val = val / (unsigned long long)radix;
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (val != 0L);
	if (negative) { *--pos = '-'; }
	return memcpy(_string, pos, (size_t)(&buffer[65] - pos + 1));
}


/** Convert an unsigned 64-bit integer to a string */
LIB_FUNC NONNULL char* ui64toa(const uint64_t value, char* restrict str, const int radix) {
	char align64 buffer[65] = { 0 };
	char* restrict pos = &buffer[64];
	register uint64_t _digit;
	register uint64_t _value = value;
	do {
		_digit = (uint64_t)(_value % (uint64_t)radix);
		_value = (uint64_t)(_value / (uint64_t)radix);
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (_value != (uint64_t)0);
	return memcpy(str, pos, (size_t)(&buffer[64] - pos + 1));
}


LIB_FUNC NONNULL int l64a(const long value, char* restrict buffer, const int buflen) {
	char* restrict s = buffer;
	register int len = buflen;
	unsigned long v = (unsigned long)value;
	_DIAGASSERT(buffer != NULL);
	if (value == 0UL) {
		*s = '\0';
		return (v == 0UL ? 0 : -1);
	}
	register int _digit;
	for (; v != 0 && len > 1; s++, len--) {
		_digit = (int)(v & 0x3f);
		if (_digit < 2) { *s = (char)(_digit + '.'); }
		else if (_digit < 12) { *s = (char)(_digit + '0' - 2); }
		else if (_digit < 38) { *s = (char)(_digit + 'A' - 12); }
		else { *s = (char)(_digit + 'a' - 38); }
		v >>= 6;
	}
	*s = '\0';
	return (v == 0UL ? 0 : -1);
}
#define _l64a(value, buffer, buflen)   l64a((value), (buffer), (buflen))


LIB_FUNC NONNULL char* l64a_r(const long value) {
	static char align64 buf[__UIM_BUFLEN_LONG] = { 0 };
	(void)l64a(value, buf, __UIM_BUFLEN_LONG);
	return buf;
}
#define _l64a_r(value)   l64a_r((value))


/** Convert an int8_t to a decimal string */
LIB_FUNC NONNULL void i8todec(const int8_t num, char* restrict result) {
	char* restrict p = result;
	register int8_t i = num;
	if (i < 0) { *p++ = '-'; i = (int8_t)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert an uint8_t to a decimal string */
LIB_FUNC NONNULL void u8todec(const uint8_t num, char* restrict result) {
	char* restrict p = result;
	register uint8_t i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert a short integer to a decimal string */
LIB_FUNC NONNULL void htodec(const short num, char* restrict result) {
	char* restrict p = result;
	register short i = num;
	if (i < 0) { *p++ = '-'; i = (short)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert an unsigned short integer to a decimal string */
LIB_FUNC NONNULL void uhtodec(const unsigned short num, char* restrict result) {
	char* restrict p = result;
	register unsigned short i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert an integer to a decimal string */
LIB_FUNC NONNULL void itodec(const int num, char* restrict result) {
	char* restrict p = result;
	register int i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert an unsigned integer to a decimal string */
LIB_FUNC NONNULL void utodec(const unsigned int num, char* restrict result) {
	char* restrict p = result;
	register unsigned int i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert a long long integer to a decimal string */
LIB_FUNC NONNULL void lltodec(const long long num, char* restrict result) {
	char* restrict p = result;
	register long long i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert an unsigned long long integer to a decimal string */
LIB_FUNC NONNULL void ulltodec(const unsigned long long num, char* restrict result) {
	char* restrict p = result;
	register unsigned long long i = num;
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
}


/** Convert a long integer to a decimal string */
LIB_FUNC NONNULL void ltodec(const long num, char* restrict result) {
#   if LONG_EQ_INT
	itodec((int)num, result);
#   else
	lltodec((long long)num, result);
#   endif
}


/** Convert an unsigned long integer to a decimal string */
LIB_FUNC NONNULL void ultodec(const unsigned long num, char* restrict result) {
#   if LONG_EQ_INT
	utodec((unsigned int)num, result);
#   else
	ulltodec((unsigned long long)num, result);
#   endif
}


/** Convert an int8_t to an octal string */
LIB_FUNC ATTR_PF char* i8tooctstr(const int8_t num) {
	static char align16 buf[__UIM_BUFLEN_INT8_OCT] = { 0 };
	char* restrict p = buf;
	register int8_t i = num;
	if (i < 0) { *p++ = '-'; i = (int8_t)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an int8_t to an octal string */
LIB_FUNC NONNULL void i8tooct(const int8_t num, char* restrict result) {
	char* restrict p = result;
	register int8_t i = num;
	if (i < 0) { *p++ = '-'; i = (int8_t)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert an uint8_t to an octal string */
LIB_FUNC ATTR_PF char* u8tooctstr(const uint8_t num) {
	static char align16 buf[__UIM_BUFLEN_UINT8_OCT] = { 0 };
	char* restrict p = buf;
	register uint8_t i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an uint8_t to an octal string */
LIB_FUNC NONNULL void u8tooct(const uint8_t num, char* restrict result) {
	char* restrict p = result;
	register uint8_t i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert a short integer to an octal string */
LIB_FUNC ATTR_PF char* htooctstr(const short num) {
	static char align16 buf[__UIM_BUFLEN_SHRT_OCT] = { 0 };
	char* restrict p = buf;
	register short i = num;
	if (i < 0) { *p++ = '-'; i = (short)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert a short integer to an octal string */
LIB_FUNC NONNULL void htooct(const short num, char* restrict result) {
	char* restrict p = result;
	register short i = num;
	if (i < 0) { *p++ = '-'; i = (short)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert an unsigned short integer to an octal string */
LIB_FUNC ATTR_PF char* uhtooctstr(const unsigned short num) {
	static char align16 buf[__UIM_BUFLEN_USHRT_OCT] = { 0 };
	char* restrict p = buf;
	register unsigned short i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an unsigned short integer to an octal string */
LIB_FUNC NONNULL void uhtooct(const unsigned short num, char* restrict result) {
	char* restrict p = result;
	register unsigned short i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert an integer to an octal string */
LIB_FUNC ATTR_PF char* itooctstr(const int num) {
	static char align16 buf[__UIM_BUFLEN_INT_OCT] = { 0 };
	char* restrict p = buf;
	register int i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an integer to an octal string */
LIB_FUNC NONNULL void itooct(const int num, char* restrict result) {
	char* restrict p = result;
	register int i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert an unsigned integer to an octal string */
LIB_FUNC ATTR_PF char* utooctstr(const unsigned int num) {
	static char align16 buf[__UIM_BUFLEN_UINT_OCT] = { 0 };
	char* restrict p = buf;
	register unsigned int i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an unsigned integer to an octal string */
LIB_FUNC NONNULL void utooct(const unsigned int num, char* restrict result) {
	char* restrict p = result;
	register unsigned int i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert a long long integer to an octal string */
LIB_FUNC ATTR_PF char* lltooctstr(const long long num) {
	static char align32 buf[__UIM_BUFLEN_LLONG_OCT] = { 0 };
	char* restrict p = buf;
	register long long i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert a long long integer to an octal string */
LIB_FUNC NONNULL void lltooct(const long long num, char* restrict result) {
	char* restrict p = result;
	register long long i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert an unsigned long long integer to an octal string */
LIB_FUNC ATTR_PF char* ulltooctstr(const unsigned long long num) {
	static char align32 buf[__UIM_BUFLEN_ULLONG_OCT] = { 0 };
	char* restrict p = buf;
	register unsigned long long i = num;
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
	return buf;
}


/** Convert an unsigned long long integer to an octal string */
LIB_FUNC NONNULL void ulltooct(const unsigned long long num, char* restrict result) {
	char* restrict p = result;
	register unsigned long long i = num;
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 8;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = octal_digits[i % 8];
		i /= 8;
	} while (i);
}


/** Convert a long integer to an octal string */
LIB_FUNC ATTR_PF char* ltooctstr(const long num) {
#   if LONG_EQ_INT
	return itooctstr((int)num);
#   else
	return lltooctstr((long long)num);
#   endif
}


/** Convert a long integer to an octal string */
LIB_FUNC NONNULL void ltooct(const long num, char* restrict result) {
#   if LONG_EQ_INT
	itooct((int)num, result);
#   else
	lltooct((long long)num, result);
#   endif
}


/** Convert an unsigned long integer to an octal string */
LIB_FUNC ATTR_PF char* ultooctstr(const unsigned long num) {
#   if LONG_EQ_INT
	return utooctstr((unsigned int)num);
#   else
	return ulltooctstr((unsigned long long)num);
#   endif
}


/** Convert an unsigned long integer to an octal string */
LIB_FUNC NONNULL void ultooct(const unsigned long num, char* restrict result) {
#   if LONG_EQ_INT
	utooct((unsigned int)num, result);
#   else
	ulltooct((unsigned long long)num, result);
#   endif
}


/** Convert an int8_t to a hexadecimal string */
LIB_FUNC ATTR_PF char* i8tohexstr(const int8_t num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_INT8_HEX] = { 0 };
	char* restrict p = buf;
	register int8_t i = num;
	if (i < 0) { *p++ = '-'; i = (int8_t)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an int8_t to a hexadecimal string */
LIB_FUNC NONNULL void i8tohex(const int8_t num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register int8_t i = num;
	if (i < 0) { *p++ = '-'; i = (int8_t)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert an uint8_t to a hexadecimal string */
LIB_FUNC ATTR_PF char* u8tohexstr(const uint8_t num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_UINT8_HEX] = { 0 };
	char* restrict p = buf;
	register uint8_t i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an uint8_t to a hexadecimal string */
LIB_FUNC NONNULL void u8tohex(const uint8_t num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register uint8_t i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert a short integer to a hexadecimal string */
LIB_FUNC ATTR_PF char* htohexstr(const short num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_SHRT_HEX] = { 0 };
	char* restrict p = buf;
	register short i = num;
	if (i < 0) { *p++ = '-'; i = (short)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert a short integer to a hexadecimal string */
LIB_FUNC NONNULL void htohex(const short num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register short i = num;
	if (i < 0) { *p++ = '-'; i = (short)-i; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert an unsigned short integer to a hexadecimal string */
LIB_FUNC ATTR_PF char* uhtohexstr(const unsigned short num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_USHRT_HEX] = { 0 };
	char* restrict p = buf;
	register unsigned short i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an unsigned short integer to a hexadecimal string */
LIB_FUNC NONNULL void uhtohex(const unsigned short num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register unsigned short i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert an integer to a hexadecimal string */
LIB_FUNC ATTR_PF char* itohexstr(const int num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_INT_HEX] = { 0 };
	char* restrict p = buf;
	register int i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an integer to a hexadecimal string */
LIB_FUNC NONNULL void itohex(const int num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register int i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert an unsigned integer to a hexadecimal string */
LIB_FUNC ATTR_PF char* utohexstr(const unsigned int num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_UINT_HEX] = { 0 };
	char* restrict p = buf;
	register unsigned int i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an unsigned integer to a hexadecimal string */
LIB_FUNC NONNULL void utohex(const unsigned int num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register unsigned int i = num;
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert a long long to a hexadecimal string */
LIB_FUNC ATTR_PF char* lltohexstr(const long long num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_LLONG_HEX] = { 0 };
	char* restrict p = buf;
	register long long i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert a long long to a hexadecimal string */
LIB_FUNC NONNULL void lltohex(const long long num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register long long i = num;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert an unsigned long long to a hexadecimal string */
LIB_FUNC ATTR_PF char* ulltohexstr(const unsigned long long num, const int use_upper) {
	static char align16 buf[__UIM_BUFLEN_ULLONG_HEX] = { 0 };
	char* restrict p = buf;
	register unsigned long long i = num;
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
	return buf;
}


/** Convert an unsigned long long to a hexadecimal string */
LIB_FUNC NONNULL void ulltohex(const unsigned long long num, const int use_upper, char* restrict result) {
	char* restrict p = result;
	register unsigned long long i = num;
	register unsigned long long shifter = (unsigned long long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 16;
	} while (shifter);
	*p = '\0';
	if (use_upper) {
		do {  // Move back, inserting digits
			*--p = xdigits_u[i % 16];
			i /= 16;
		} while (i);
	} else {
		do {  // Move back, inserting digits
			*--p = xdigits_l[i % 16];
			i /= 16;
		} while (i);
	}
}


/** Convert a long to a hexadecimal string */
LIB_FUNC ATTR_PF char* ltohexstr(const long num, const int use_upper) {
#   if LONG_EQ_INT
	return itohexstr((int)num, use_upper);
#   else
	return lltohexstr((long long)num, use_upper);
#   endif
}


/** Convert a long to a hexadecimal string */
LIB_FUNC NONNULL void ltohex(const long num, const int use_upper, char* restrict result) {
#   if LONG_EQ_INT
	itohex((int)num, use_upper, result);
#   else
	lltohex((long long)num, use_upper, result);
#   endif
}


/** Convert an unsigned long to a hexadecimal string */
LIB_FUNC ATTR_PF char* ultohexstr(const unsigned long num, const int use_upper) {
#   if LONG_EQ_INT
	return utohexstr((unsigned int)num, use_upper);
#   else
	return ulltohexstr((unsigned long long)num, use_upper);
#   endif
}


/** Convert an unsigned long to a hexadecimal string */
LIB_FUNC NONNULL void ultohex(const unsigned long num, const int use_upper, char* restrict result) {
#   if LONG_EQ_INT
	utohex((unsigned int)num, use_upper, result);
#   else
	ulltohex((unsigned long long)num, use_upper, result);
#   endif
}


/** Convert unsigned long long to string given the value, string buffer, and number base */
LIB_FUNC void ulltostr(const uint64_t value, char* restrict str_buf, const int base) {
	register int count = 0;
	if (NULL == str_buf) { return; }
	else if (value == 0) { ++count; }
	register uint64_t t = 0, tmp = value, tmpval = value;
	while (tmp > 0) {
		tmp = tmp / (uint64_t)base;
		++count;
	}
	str_buf += count;
	*str_buf = '\0';
	register uint64_t res = 0;
	do {
		res = tmpval - (uint64_t)base * (t = tmpval / (uint64_t)base);
		if (res < 10) { *--str_buf = (char)('0' + res); }
		else if ((res >= 10) && (res < 16)) { *--str_buf = (char)((uint64_t)('A' - 10) + res); }
	} while ((tmpval = t) != 0);
}
#define ulltoa(value, str_buf, base)   ulltostr((value), (str_buf), (base))


/** Convert unsigned long to string given the value, string buffer, and number base */
LIB_FUNC void ultostr(const unsigned long value, char* restrict str_buf, const int base) {
	ulltostr((uint64_t)value, str_buf, base);
}
#define ultoa(value, str_buf, base)   ultostr((value), (str_buf), (base))


/** Convert unsigned long to string */
LIB_FUNC int __ltostr(char* s, unsigned int size, unsigned long i, const unsigned int base, const int UpCase) {
	register unsigned int j = 0, _base = base;
	s[--size] = 0;
	char* tmp = s + size;
	if ((base == 0) || (base > 36)) { _base = 10; }
	j = 0;
	if (!i) {
		*(--tmp) = '0';
		j = 1;
	}
	register char tmpc;
	while ((tmp > s) && i) {
		tmp--;
		if ((*tmp = (char)(i % (unsigned long)_base + '0')) > '9') {
			tmpc = (char)((UpCase ? 'A' : 'a') - '9' - (char)1);
			*tmp = (char)(*tmp + tmpc);
		}
		i = i / (unsigned long)_base;
		j++;
	}
	memmove_no_output(s, tmp, (size_t)(j + 1));
	return (int)j;
}


/** Convert unsigned long long to string */
LIB_FUNC int __lltostr(char* s, int size, unsigned long long i, const int base, const char UpCase) {
	register unsigned int j = 0;
	register int _base = base;
	s[--size] = 0;
	char* tmp = s + size;
	if ((base == 0) || (base > 36)) { _base = 10; }
	if (!i) {
		*(--tmp) = '0';
		j = 1;
	}
	register char tmpc;
	while ((tmp > s) && i) {
		tmp--;
		if ((*tmp = (char)(i % (unsigned long long)_base + '0')) > '9') {
			tmpc = (char)((UpCase ? 'A' : 'a') - '9' - 1);
			*tmp = (char)(*tmp + tmpc);
		}
		i = i / (unsigned long long)_base;
		j++;
	}
	memmove_no_output(s, tmp, (size_t)(j + 1));
	return (int)j;
}
#define lltostr(s, size, i, base, UpCase)   __lltostr((s), (size), (i), (base), (UpCase))


/** Convert a float-point to a string */
LIB_FUNC NONNULL int ftoa(const float n, char* restrict res, const int32_t prec) {
	if (__isinff(n) == 1) { return copystring(res, 3, "inf"); }
	else if (__isinff(n) == -1) { return copystring(res, 4, "-inf"); }
	else if (__isnanf(n)) { return copystring(res, 3, "nan"); }
	else if (n == HUGEF) { return copystring(res, 7, HUGEF_STR); }
	else if (n == TINYF) { return copystring(res, 7, TINYF_STR); }
	const float n_abs = fabsf(n);
	const uint64_t ipart = (uint64_t)n_abs;
	if (n != n_abs) { res[0] = '-'; ulltodec(ipart, &res[1]); }
	else { ulltodec(ipart, res); }
	int i = (int)strlen(res);
	const int32_t afterpoint = (prec < 0 ? 6 : prec);
	if (afterpoint > 0) {
		const float fpart = (n_abs - (float)ipart) * iexpf((int)afterpoint);
		char align16 ftoa_fractbuf[16] = { 0 };
		ulltodec((uint64_t)fpart, ftoa_fractbuf);
		const uint32_t frctstrlen = (uint32_t)strlen(ftoa_fractbuf);
		res[i++] = '.';
		register int32_t plczeros = (int32_t)(afterpoint - (int32_t)frctstrlen);
		while (plczeros > 0) { res[i++] = '0'; --plczeros; }
		memcpy_no_output(&res[i], ftoa_fractbuf, frctstrlen);
		return (int)(i + (int)frctstrlen - 1);
	} else { return i; }
}


/** Convert a double to a string */
LIB_FUNC NONNULL int dtoa(const double n, char* restrict res, const int32_t prec) {
	if (__isinf(n) == 1) { return copystring(res, 3, "inf"); }
	else if (__isinf(n) == -1) { return copystring(res, 4, "-inf"); }
	else if (__isnan(n)) { return copystring(res, 3, "nan"); }
	else if (n == HUGE) { return copystring(res, 8, HUGE_STR); }
	else if (n == TINY) { return copystring(res, 8, TINY_STR); }
	const double n_abs = fabs(n);
	const uint64_t ipart = (uint64_t)n_abs;
	if (n != n_abs) { res[0] = '-'; ulltodec(ipart, &res[1]); }
	else { ulltodec(ipart, res); }
	int i = (int)strlen(res);
	const int32_t afterpoint = (prec < 0 ? 6 : prec);
	if (afterpoint > 0) {
		const double fpart = (n_abs - (double)ipart) * iexp((int)afterpoint);
		char align32 dtoa_fractbuf[32] = { 0 };
		ulltodec((uint64_t)fpart, dtoa_fractbuf);
		const uint32_t frctstrlen = (uint32_t)strlen(dtoa_fractbuf);
		res[i++] = '.';
		register int32_t plczeros = (int32_t)(afterpoint - (int32_t)frctstrlen);
		while (plczeros > 0) { res[i++] = '0'; --plczeros; }
		memcpy_no_output(&res[i], dtoa_fractbuf, frctstrlen);
		return (int)(i + (int)frctstrlen - 1);
	} else { return i; }
}


/** Convert a double to a string as scientific notation */
LIB_FUNC NONNULL int dtoe(const double n, char* restrict res, const int32_t prec) {
	if (__isinf(n) == 1) { return copystring(res, 3, "inf"); }
	else if (__isinf(n) == -1) { return copystring(res, 4, "-inf"); }
	else if (__isnan(n)) { return copystring(res, 3, "nan"); }
	else if (n == HUGE) { return copystring(res, 8, HUGE_STR); }
	else if (n == TINY) { return copystring(res, 8, TINY_STR); }
	const double n_abs = fabs(n);
	const int64_t exponent = get_dbl_expo(n_abs);
	const uint64_t ipart = (uint64_t)n_abs;
	if (n != n_abs) { res[0] = '-'; ulltodec(ipart, &res[1]); }
	else { ulltodec(ipart, res); }
	int i = (int)strlen(res);
	res[i++] = '.';
	const int32_t afterpoint = (prec < 1 ? (prec == 0 ? 1 : 6) : prec);
	const double frctpart = (n_abs - (double)ipart) * iexp(afterpoint);
	char align32 dtoe_buf[32] = { 0 };
	ulltodec((uint64_t)frctpart, dtoe_buf);
	const uint32_t frctstrlen = (uint32_t)strlen(dtoe_buf);
	register int32_t plczeros = (int32_t)(afterpoint - (int32_t)frctstrlen);
	while (plczeros > 0) { res[i++] = '0'; --plczeros; }
	i += copystring(&res[i], frctstrlen, dtoe_buf);
	res[i++] = 'e';
	lltodec(exponent, dtoe_buf);
	const uint32_t expostrlen = (uint32_t)strlen(dtoe_buf);
	i += copystring(&res[i], expostrlen, dtoe_buf);
	return (int)(--i);
}


/** Convert double to string; return the number of characters written to `buf`; if an error occurred, return -1 */
LIB_FUNC NOLIBCALL int dtostr(const double num, char* restrict buf, const size_t width, const size_t prec, const char format) {
	register double d = num;
	double_shape_t num_shape = { .value = d };
	// INF & NAN
	if (format == 'E' || format == 'F' || format == 'G') {  // Uppercase
		if (__isinf(d) == 1) { return copystring(buf, 3, "INF"); }
		else if (__isinf(d) == -1) { return copystring(buf, 4, "-INF"); }
		else if (__isnan(d) && (num_shape.uword & 1) == 1) { return copystring(buf, 4, "-NAN"); }
		else if (__isnan(d)) { return copystring(buf, 3, "NAN"); }
	} else {  // Lowercase
		if (__isinf(d) == 1) { return copystring(buf, 4, "inf"); }
		else if (__isinf(d) == -1) { return copystring(buf, 5, "-inf"); }
		else if (__isnan(d) && (num_shape.uword & 1) == 1) { return copystring(buf, 5, "-nan"); }
		else if (__isnan(d)) { return copystring(buf, 4, "nan"); }
	}
	// Values equal to or less than 0.0
	const size_t buf_start = (size_t)buf;
	size_t _prec = prec;
	if ((d == 0.0) || (d == -0.0)) {  // 0.0
		if (PREDICT_UNLIKELY(num_shape.sword < 0)) { _prec = ((_prec == 0) ? 2 : _prec + 3); }
		else { _prec = ((_prec == 0) ? 1 : _prec + 2); }
		unsigned int j = 0;
		if (num_shape.sword < 0) { buf[0] = '-'; ++j; }
		for (; j < _prec; ++j) { buf[j] = '0'; }
		buf[((buf[0] == '0') ? 1 : 2)] = '.';
		buf[j] = 0;
		return (int)j;
	} else if (d < 0.0) { d = -d; *buf = '-'; ++buf; }  // Add negative sign
	// Add digits before decimal-point
	if (d >= 1.0) {
		const uint64_t value = (uint64_t)d;
		ulltodec(value, buf);
		buf += strlen(buf);
		d -= (double)value;
		num_shape.value = d;
	} else if (d < 1.0) { *buf = '0'; ++buf; }
	// Extract sign, mantissa, & exponent
	register const signed long e = (signed long)(((num_shape.uword >> 52) & 0x7ff) - 1023);
	signed long e10 = 1 + (signed long)(e * (signed long)LOG2_DIV_LOG10);  // log(2)
	// Perform rounding
	double tmp = 0.5;
	unsigned int j = 0;
	if (_prec > 0) { for (; j < _prec; j++) { tmp *= 0.1; } }
	d += tmp;
	register char _digit;
	if (e10 > 0) {
		tmp = 10.0;
		j = (unsigned int)e10;
		while (j > 10) { tmp *= 10000000000.0; j -= 10; }
		while (j > 1) { tmp *= 10; --j; }
		while (tmp > 0.9) {
			_digit = (char)(d / tmp);
			d -= (_digit * tmp);
			tmp /= 10.0;
		}
	} else { tmp = 0.1; }
	// Add digits after decimal-point
	register size_t _width = width;
	if (_prec) {
		*buf = '.';
		++buf;
		const size_t cur_len = (size_t)(buf - buf_start - _prec);
		_width = (cur_len > _width ? 0 : (_width - cur_len));
		// Add digits and (if needed) trailing zeros
		while (_prec > 0) {
			_digit = (char)(d / tmp);
			*buf = (char)(_digit + '0');
			++buf;
			d -= _digit * tmp;
			tmp /= 10.0;
			--_prec;
		}
	} else {
		const size_t cur_len = (size_t)(buf - buf_start);
		_width = (cur_len > _width ? 0 : (_width - cur_len));
	}
	// Finish result
	*buf = 0;
	return (int)((size_t)buf - buf_start);
}


/** Convert a floating-point number to a string; similar to using "%e" in printf() */
LIB_FUNC NONNULL_IO char* ecvt(const double x, int n, int* dp, int* sign) {
	static char align64 buf[16] = { 0 };
	char align64 tmp[32] = { 0 };
	register int i, j;
	if ((n - 1) > 15) { n = 15; }
	sprintf(tmp, "%.*e", n - 1, x);
	i = *sign = (tmp[0] == '-');
	for (j = 0; tmp[i] != 'e'; j += (tmp[i++] != '.')) { buf[j] = tmp[i]; }
	buf[j] = 0;
	*dp = atoi(tmp + i + 1) + 1;
	return buf;
}


/** Convert a floating-point number to a string; similar to using "%f" in printf() */
LIB_FUNC NONNULL_IO const char* fcvt(const double x, int n, int* dp, int* sign) {
	char align64 tmp[1500] = { 0 };
	register int i, lz;
	if (n > 1400) { n = 1400; }
	sprintf(tmp, "%.*f", n, x);
	i = (tmp[0] == '-');
	if (tmp[i] == '0') { lz = (int)strspn((tmp + i + 2), "0"); }
	else { lz = (int)(-(int)strcspn((tmp + i), ".")); }
	if (n <= lz) {
		*sign = i;
		*dp = 1;
		if (n > 14) { n = 14; }
		return (const char*)(fcvt_zeros + 14 - n);
	}
	return (const char*)ecvt(x, (n - lz), dp, sign);
}


/** Converts a number to a minimal length null-terminated ASCII string and stores the result in b; similar to using "%g" in printf() */
LIB_FUNC NONNULL_IO char* gcvt(const double x, int n, char* b) {
	sprintf(b, "%.*g", n, x);
	return b;
}


/** Convert string to float */
LIB_FUNC float strtof(const char* restrict ptr, const char** endptr) {
	if (ptr == NULL) { *endptr = NULL; return 0.0F; }  // Return 0.0 if ptr is NULL
	while (isspace(*ptr)) { ptr++; }  // Skip spaces
	register float sign = 1.0F;
	switch (*ptr) {  // Sign
		case '-': sign = -1.0F; attr_fallthrough;
		case '+': ++ptr; attr_fallthrough;
		default: break;
	}
	switch (*ptr) {  // NAN & INF
		case 'N':  // NAN
		case 'n': ++ptr;
			switch (*ptr) {
				case 'A':
				case 'a': ++ptr;
					switch (*ptr) {
						case 'N':
						case 'n':
							if (sign == -1.0F) { return NANSF; }
							return NANF;
						default: return 0.0F;
					}
				default: return 0.0F;
			}
		case 'I':  // INF
		case 'i': ++ptr;
			switch (*ptr) {
				case 'N':
				case 'n': ++ptr;
					switch (*ptr) {
						case 'F':
						case 'f':
							if (sign == -1.0F) { return NINFF; }
							return INFF;
						default: return 0.0F;
					}
				default: return 0.0F;
			}
		default: break;
	}
	register float value = 0.0F;
	// Create numbers before decimal-point
	while ((unsigned int)(*ptr - '0') < 10U) { value = (float)(((int)value) * 10 + ((*ptr++) - '0')); }
	// Create numbers after decimal-point
	register float factor;
	if (*ptr == '.') {  // Decimal-point
		factor = 1.0F;
		++ptr;
		while ((unsigned int)(*ptr - '0') < 10U) {
			factor *= 0.1F;
			value += (((float)(*ptr++ - '0')) * factor);
		}
	}
	// Read exponent specifier & add to float-point
	if ((*ptr | 32) == 'e') {
		register unsigned int expo = 0;
		factor = 10.0F;
		switch (*++ptr) {
			case '-': factor = 0.1F; attr_fallthrough;
			case '+': ++ptr; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				if (endptr != NULL) { *endptr = ptr; }
				return (0.0F * sign);
		}
		while ((unsigned int)(*ptr - '0') < 10U) { expo = ((10 * expo) + (unsigned int)(*ptr++ - '0')); }
		until_break {
			if (expo & 1) { value *= factor; }
			if ((expo >>= 1) == 0) { break; }
			factor *= factor;
		}
	}
	// Finished parsing float-point
	if (endptr != NULL) { *endptr = ptr; }
	return value * sign;
}
#define STRTOF(_string, endptr)   strtof((_string), (endptr))
#define __strtof_l(_string, endptr, locale)   strtof((_string), (endptr))
#define __strtof_internal(_string, endptr)   strtof((_string), (endptr))
#define STRTOF_L(_string, endptr, locale)   strtof((_string), (endptr))
#define strtof_l(_string, endptr, locale)   strtof((_string), (endptr))
#define stof(_string)   strtof((_string), 0)


/** Convert string to double */
LIB_FUNC ATTR_PURE double strtod(const char* restrict ptr, const char** endptr) {
	if (ptr == NULL) { *endptr = NULL; return 0.0; }  // Return 0.0 if ptr is NULL
	while (isspace(*ptr)) { ptr++; }  // Skip spaces
	register double sign = 1.0;
	switch (*ptr) {  // Sign
		case '-': sign = -1.0; attr_fallthrough;
		case '+': ++ptr; attr_fallthrough;
		default: break;
	}
	switch (*ptr) {  // NAN & INF
		case 'N':  // NAN
		case 'n': ++ptr;
			switch (*ptr) {
				case 'A':
				case 'a': ++ptr;
					switch (*ptr) {
						case 'N':
						case 'n':
							if (sign == -1.0) { return NANS; }
							return NAN;
						default: return 0.0;
					}
				default: return 0.0;
			}
		case 'I':  // INF
		case 'i': ++ptr;
			switch (*ptr) {
				case 'N':
				case 'n': ++ptr;
					switch (*ptr) {
						case 'F':
						case 'f':
							if (sign == -1.0) { return NINF; }
							return INF;
						default: return 0.0;
					}
				default: return 0.0;
			}
		default: break;
	}
	register double value = 0.0;
	// Create numbers before decimal-point
	while ((unsigned int)(*ptr - '0') < 10U) { value = (double)(((int)value) * 10 + ((*ptr++) - '0')); }
	// Create numbers after decimal-point
	register double factor;
	if (*ptr == '.') {  // Decimal-point
		factor = 1.0;
		++ptr;
		while ((unsigned int)(*ptr - '0') < 10U) {
			factor *= 0.1;
			value += (((double)(*ptr++ - '0')) * factor);
		}
	}
	// Read exponent specifier & add to float-point
	if ((*ptr | 32) == 'e') {
		register unsigned int expo = 0;
		factor = 10.0;
		switch (*++ptr) {
			case '-': factor = 0.1; attr_fallthrough;
			case '+': ++ptr; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				if (endptr != NULL) { *endptr = ptr; }
				return (0.0 * sign);
		}
		while ((unsigned int)(*ptr - '0') < 10U) { expo = ((10 * expo) + (unsigned int)(*ptr++ - '0')); }
		until_break {
			if (expo & 1) { value *= factor; }
			if ((expo >>= 1) == 0) { break; }
			factor *= factor;
		}
	}
	// Finished parsing float-point
	if (endptr != NULL) { *endptr = ptr; }
	return (value * sign);
}
#define STRTOD(_string, endptr)   strtod((_string), (endptr))
#define __strtod_l(_string, endptr, locale)   strtod((_string), (endptr))
#define STRTOD_L(_string, endptr, locale)   strtod((_string), (endptr))
#define strtod_l(_string, endptr, locale)   strtod((_string), (endptr))
#define strtod_internal(_string, endptr)   strtod((_string), (endptr))
/** Convert a string to a float */
#define atof(_string)   strtod((_string), 0)
/** Convert a string to a float */
#define _atof(_string)   strtod((_string), 0)
/** Convert a string to a double */
#define atod(_string)   strtod((_string), 0)
/** Convert a string to a double */
#define _atod(_string)   strtod((_string), 0)


/** Convert string to long double */
LIB_FUNC long double strtox(const char* restrict ptr, const char** endptr, const int prec) {
	if (ptr == NULL) { *endptr = NULL; return 0.0L; }  // Return 0.0 if ptr is NULL
	while (isspace(*ptr)) { ptr++; }  // Skip spaces
	register long double sign = 1.0L;
	switch (*ptr) {  // Sign
		case '-': sign = -1.0L; attr_fallthrough;
		case '+': ++ptr; attr_fallthrough;
		default: break;
	}
	switch (*ptr) {  // NAN & INF
		case 'N':  // NAN
		case 'n': ++ptr;
			switch (*ptr) {
				case 'A':
				case 'a': ++ptr;
					switch (*ptr) {
						case 'N':
						case 'n':
							if (sign == -1.0L) { return NANSL; }
							return NANL;
						default: return 0.0L;
					}
				default: return 0.0L;
			}
		case 'I':  // INF
		case 'i': ++ptr;
			switch (*ptr) {
				case 'N':
				case 'n': ++ptr;
					switch (*ptr) {
						case 'F':
						case 'f':
							if (sign == -1.0L) { return NINFL; }
							return INFL;
						default: return 0.0L;
					}
				default: return 0.0L;
			}
		default: break;
	}
	register long double value = 0.0L;
	// Create numbers before decimal-point
	while ((unsigned int)(*ptr - '0') < 10U) { value = (long double)(((int)value) * 10 + ((*ptr++) - '0')); }
	// Create numbers after decimal-point
	register long double factor;
	register int _prec = prec;
	if (*ptr == '.') {  // Decimal-point
		factor = 1.0L;
		++ptr;
		while (((unsigned int)(*ptr - '0') < 10U) && _prec > 0) {
			factor *= 0.1L;
			value += (((long double)(*ptr++ - '0')) * factor);
			--_prec;
		}
	}
	// Read exponent specifier & add to float-point
	if ((*ptr | 32) == 'e') {
		register unsigned int expo = 0;
		factor = 10.0L;
		switch (*++ptr) {
			case '-': factor = 0.1L; attr_fallthrough;
			case '+': ++ptr; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				if (endptr != NULL) { *endptr = ptr; }
				return (0.0L * sign);
		}
		while ((unsigned int)(*ptr - '0') < 10U) { expo = ((10 * expo) + (unsigned int)(*ptr++ - '0')); }
		until_break {
			if (expo & 1) { value *= factor; }
			if ((expo >>= 1) == 0) { break; }
			factor *= factor;
		}
	}
	// Finished parsing float-point
	if (endptr != NULL) { *endptr = ptr; }
	return (value * sign);
}
#define strtold(_string, endptr)   strtox((_string), (endptr), 0)
#define strtold_internal(_string, endptr)   strtox((_string), (endptr), 0)
#define STRTOLD(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtold_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOLD_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtold_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolQ(_string, endptr)   strtox((_string), (endptr), 0)
#define strtolq(_string, endptr)   strtox((_string), (endptr), 0)
#define STRTOLQ(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtolQ_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define __strtolq_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOLQ_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolQ_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolq_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOX(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtox_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOX_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtox_l(_string, endptr, locale)   strtox((_string), (endptr), 0)


/** Convert string to long */
LIB_FUNC long strtol(const char* restrict nptr, const char** restrict endptr, const int _base) {
	const char* p = nptr;
	register long n = 0, nn;
	register int c, v, neg = 0, base = _base;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	if (base == 0) {  // Base
		if (*p != '0') { base = 10; }
		else {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else if (base == 16 && *p == '0') {
		if (p[1] == 'x' || p[1] == 'X') { p += 2; }
	} else if (base < 0 || 36 < base) {
		p = nptr;
		if (endptr) { *endptr = p; }
		return (neg ? -n : n);
	}
	register int ovfl = 0, ndig = 0;
	for (;; p++, ndig++) {  // Non-empty sequence of digits
		c = *p;
		v = base;
		if (('0' <= c) && (c <= '9')) { v = c - '0'; }
		else if (('a' <= c) && (c <= 'z')) { v = (c - 'a') + 10; }
		else if (('A' <= c) && (c <= 'Z')) { v = (c - 'A') + 10; }
		if (v >= base) { break; }
		nn = (n * base) + v;
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) {
		if (neg) { return LONG_MIN; }
		return LONG_MAX;
	}
	return (neg ? -n : n);
}


LIB_FUNC long strtol_l(const char* restrict nptr, const char** restrict endptr, int base, const UNUSED locale_t _lang) {
	return strtol(nptr, endptr, base);
}


/** Convert string to long long */
LIB_FUNC long long strtoll(const char* restrict nptr, const char** restrict endptr, int base) {
	const char* p = nptr;
	register long long n = 0, nn, m;
	register int c, ovfl = 0, v, neg = 0, ndig = 0;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	if (base == 0) {  // Base
		base = 10;
		if (*p == '0') {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
		p += 2;
	} else if (base < 0 || 36 < base) {
		if (ndig == 0) { p = nptr; }
		if (endptr) { *endptr = p; }
		if (ovfl) {
			if (neg) { return VLONG_MIN; }
			return VLONG_MAX;
		} else if (neg) { return -n; }
		return n;
	}
	// Non-empty sequence of digits
	m = (VLONG_MAX / base);
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = (long long)((n * base) + v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) {
		if (neg) { return VLONG_MIN; }
		return VLONG_MAX;
	} else if (neg) { return -n; }
	return n;
}


LIB_FUNC long long strtoll_l(const char* restrict nptr, const char** restrict endptr, int base, const UNUSED locale_t _lang) {
	return strtoll(nptr, endptr, base);
}


/** Convert a string to an unsigned long; Ignores locale; Assumes that the upper and lower case alphabets and digits are each contiguous */
LIB_FUNC unsigned long strtoul(const char* restrict nptr, const char** restrict endptr, const int _base) {
	const char* p = nptr;
	register unsigned long n = 0, nn, m;
	register int c, ovfl = 0, neg = 0, v, ndig = 0, base = _base;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	// Base
	if (base == 0) {
		if (*p != '0') { base = 10; }
		else {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') { base = 16; }
		}
	} else if (base < 2 || 36 < base) {
		if (ndig == 0) { p = nptr; }
		if (endptr) { *endptr = p; }
		if (ovfl) { return ULONG_MAX; }
		else if (neg) { return -n; }
		return n;
	}
	if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
		if (('0' <= p[2] && p[2] <= '9') || ('a' <= p[2] && p[2] <= 'f') || ('A' <= p[2] && p[2] <= 'F')) { p += 2; }
	}
	// Non-empty sequence of digits
	n = 0;
	m = (ULONG_MAX / (unsigned long)base);
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = (unsigned long)((n * (unsigned long)base) + (unsigned long)v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) { return ULONG_MAX; }
	else if (neg) { return -n; }
	return n;
}


LIB_FUNC unsigned long strtoul_l(const char* restrict nptr, const char** restrict endptr, int base, const UNUSED locale_t _lang) {
	return strtoul(nptr, endptr, base);
}


/** Convert a string to a unsigned long long */
LIB_FUNC unsigned long long strtoull(const char* restrict nptr, const char** restrict endptr, int base) {
	const char* p = nptr;
	register unsigned long long n = 0;
	register int c, ovfl = 0, v, neg = 0, ndig = 0;
	while (isspace(*p)) { ++p; }
	if (*p == '+') { ++p; }  // Sign
	if (base == 0) {  // Base
		base = 10;
		if (*p == '0') {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else {
		if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
			p += 2;
		} else if (base < 0 || 36 < base) {
			if (ndig == 0) { p = nptr; }
			if (endptr) { *endptr = p; }
			if (ovfl) { return ULLONG_MAX; }
			else if (neg) { return -n; }
			return n;
		}
	}
	// Non-empty sequence of digits
	register unsigned long long m = ULLONG_MAX / (unsigned long long)base;
	register unsigned long long nn = 0;
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = ((n * (unsigned long long)base) + (unsigned long long)v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) { return ULLONG_MAX; }
	return n;
}


LIB_FUNC unsigned long long strtoull_l(const char* restrict nptr, const char** restrict endptr, int base, const UNUSED locale_t _lang) {
	return strtoull(nptr, endptr, base);
}


/** Convert a number string to `uintmax_t` */
LIB_FUNC uintmax_t strntoumax(const char* restrict nptr, const char** restrict endptr, const int base, size_t n) {
	while (n && ((((unsigned char)*nptr) == 0x20U) | ((0x8U < ((unsigned char)*nptr)) & (((unsigned char)*nptr) < 0xeU)))) { ++nptr; --n; }
	register int minus = (*nptr == '-');
	int _base = base;
	if (n && (minus || *nptr == '+')) { ++nptr; --n; }  // Single optional + or -
	if (base == 0) {
		if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) { n -= 2; nptr += 2; _base = 16; }  // Hex
		else if ((n >= 1) && (nptr[0] == '0')) { --n; ++nptr; _base = 8; }  // Octal
		else { _base = 10; }  // Decimal
	} else if (base == 16) {
		if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) { n -= 2; nptr += 2; }  // Hex
	} else if ((base == 8) && (n >= 1) && (nptr[0] == '0')) {  // Octal
		--n; ++nptr;
	}
	register int d;
	register uintmax_t v = 0;
	while (n && ((d = digitval(*nptr)) >= 0) && (d < _base)) {
		v = (uintmax_t)(v * (uintmax_t)(_base + d));
		--n;
		++nptr;
	}
	if (endptr) { *endptr = nptr; }
	return (uintmax_t)(minus ? (-v) : v);
}


/** Convert a number string to `intmax_t` */
LIB_FUNC intmax_t strntoimax(const char* restrict nptr, const char** restrict endptr, const int base, size_t n) {
	return (intmax_t)strntoumax(nptr, endptr, base, n);
}


/** Like `strtol` but convert to `intmax_t` */
LIB_FUNC intmax_t strtoimax(const char* restrict nptr, const char** restrict endptr, const int base) {
	return (intmax_t)strtol(nptr, endptr, base);
}


/** Like `strtoul` but convert to `uintmax_t` */
LIB_FUNC uintmax_t strtoumax(const char* restrict nptr, const char** restrict endptr, const int base) {
	return (uintmax_t)strtoul(nptr, endptr, base);
}


/** Convert an integer to a string */
LIB_FUNC char* uintmaxtostr(const signed long _num, char b[]) {
	register signed long i = _num;
	char* p = b;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned long shifter = (unsigned long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = digits[i % 10];
		i /= 10;
	} while (i);
	return b;
}
#define _uintmaxtostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define _int10tostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define _inttostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define inttostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define int2str(bufend, intval)   uintmaxtostr((intval), (bufend))


LIB_FUNC unsigned int char2uint(const char* cnum) {
	return (unsigned int)strtol(cnum, (const char**)NULL, 10);
}


/** Convert a string into an integer of type intmax_t; Allow trailing spaces */
LIB_FUNC intmax_t atomax(const char* s, const int base) {
	const char** restrict p = NULL;
	clr_errno();
	register const intmax_t r = strtoimax(s, p, base);
	if (is_errno_not_zero() || (size_t)p == (size_t)(s && base)) { abort(); }
	while (isspace((unsigned char)**p)) { p++; }
	if (**p) { abort(); }
	return r;
}


LIB_FUNC intmax_t atomax2(const char* s) {
	return atomax(s, 2);
}


LIB_FUNC intmax_t atomax8(const char* s) {
	return atomax(s, 8);
}


LIB_FUNC intmax_t atomax10(const char* s) {
	return atomax(s, 10);
}


/** Convert a string of digits to an integer, printing an error message on failure */
LIB_FUNC int number(const char* s) {
	const intmax_t n = atomax(s, 10);
	if (n < 0 || n > INT_MAX) { abort(); }
	return (int)n;
}


/** Convert a C-style string to a Pascal-style string */
LIB_FUNC void cstr2pstr(const char* restrict cstr, char* restrict pstr) {
	register int i;
	for (i = 0; cstr[i]; i++) { pstr[i + 1] = cstr[i]; }
	pstr[0] = (char)i;
}


/** Convert a Pascal-style string to a C-style string */
LIB_FUNC void pstr2cstr(const char* restrict pstr, char* restrict cstr) {
	register int i;
	for (i = 0; i < pstr[0]; i++) { cstr[i] = pstr[i + 1]; }
	cstr[i] = (char)0;
}


// BSEARCH FUNCTIONS

/** Searches the given key in the array pointed to by base (which is formed by nmemb elements, each of size bytes), and returns a void* pointer to a matching element, if found */
LIB_FUNC void* bsearch(const void* key, const void* base, const size_t nmemb, const size_t size, int (*compar)(const void*, const void*)) {
	register long i, bot = 0, top, new;
	void* p;
	top = (long)(bot + (long)(nmemb - 1));
	while (bot <= top) {
		new = (long)((top + bot) / 2L);
		p = (char*)(&base + (((size_t)new) * size));
		i = (long)((int)((*compar)(key, p)));
		if (i == 0) { return p; }
		else if (i > 0) { bot = new + 1; }
		else { top = new - 1; }
	}
	return 0;
}
#define xbsearch(key, base, nmemb, size, func)   bsearch((key), (base), (nmemb), (size), (func))


LIB_FUNC Rune* _runebsearch(Rune c, Rune* t, int n, const int ne) {
	Rune* p;
	register int m;
	while (n > 1) {
		m = n / 2;
		p = (t + (m * ne));
		if (c >= p[0]) {
			t = p;
			n = n - m;
		} else { n = m; }
	}
	if (n && c >= t[0]) { return t; }
	return 0;
}


LIB_FUNC int pntz(size_t p[2]) {
	register int r = ntz(p[0] - 1);
	if (r != 0 || (r = (BITS_PER_SIZE_T + ntz(p[1]))) != BITS_PER_SIZE_T) { return r; }
	return 0;
}


LIB_FUNC void cycle(const size_t width, unsigned char* ar[], const int n) {
	if (n < 2) { return; }
	unsigned char tmp[256] = { 0 };
	ar[n] = tmp;
	register int i;
	register size_t l, len = width;
	while (len) {
		l = (sizeof(tmp) < len ? sizeof(tmp) : len);
		memcpy_no_output(ar[n], ar[0], l);
		for (i = 0; i < n; i++) { memcpy_no_output(ar[i], ar[i + 1], l); ar[i] += l; }
		len -= l;
	}
}


LIB_FUNC void shl(size_t p[2], int n) {
	if (n >= BITS_PER_SIZE_T) {
		n -= BITS_PER_SIZE_T;
		p[1] = p[0];
		p[0] = 0;
	}
	p[1] <<= n;
	p[1] |= p[0] >> (BITS_PER_SIZE_T - n);
	p[0] <<= n;
}


LIB_FUNC void shr(size_t p[2], int n) {
	if (n >= BITS_PER_SIZE_T) {
		n -= BITS_PER_SIZE_T;
		p[0] = p[1];
		p[1] = 0;
	}
	p[0] >>= (size_t)n;
	p[0] |= (size_t)(p[1] << (BITS_PER_SIZE_T - n));
	p[1] >>= (size_t)n;
}


LIB_FUNC void sift(unsigned char* _head, const size_t width, cmpfun cmp, int pshift, size_t lp[]) {
	unsigned char *rt, *lf;
	unsigned char* ar[(14 * SIZEOF_SIZE_T) + 1] = { _head, 0 };
	register int i = 1;
	while (pshift > 1) {
		rt = (_head - width);
		lf = rt - lp[pshift - 2];
		if ((*cmp)(ar[0], lf) >= 0 && (*cmp)(ar[0], rt) >= 0) { break; }
		else if ((*cmp)(lf, rt) >= 0) {
			ar[i++] = lf;
			_head = lf;
			pshift -= 1;
		} else {
			ar[i++] = rt;
			_head = rt;
			pshift -= 2;
		}
	}
	cycle(width, ar, i);
}


LIB_FUNC void trinkle(unsigned char* _head, const size_t width, cmpfun cmp, size_t pp[2], int pshift, int trusty, size_t lp[]) {
	unsigned char *stepson, *rt, *lf;
	size_t p[2] = { pp[0], pp[1] };
	unsigned char* ar[14 * SIZEOF_SIZE_T + 1] = { _head, 0 };
	register int i = 1, trail;
	while (p[0] != 1 || p[1] != 0) {
		stepson = _head - lp[pshift];
		if ((*cmp)(stepson, ar[0]) <= 0) { break; }
		else if (!trusty && pshift > 1) {
			rt = (_head - width);
			lf = rt - lp[pshift - 2];
			if ((*cmp)(rt, stepson) >= 0 || (*cmp)(lf, stepson) >= 0) { break; }
		}
		ar[i++] = stepson;
		_head = stepson;
		trail = pntz(p);
		shr(p, trail);
		pshift += trail;
		trusty = 0;
	}
	if (!trusty) { cycle(width, ar, i); sift(_head, width, cmp, pshift, lp); }
}


LIB_FUNC void qsort(void* base, const size_t nel, const size_t width, cmpfun cmp) {
	size_t lp[12 * SIZEOF_SIZE_T] = { 0 };
	register size_t i, size = width * nel;
	unsigned char *_head, *high;
	size_t p[2] = { 1, 0 };
	register int pshift = 1, trail;
	if (!size) { return; }
	_head = base;
	high = ((_head + size) - width);
	// Precompute Leonardo numbers, scaled by element width
	for (lp[0] = lp[1] = width, i = 2; (lp[i] = (lp[i - 2] + lp[i - 1] + width)) < size; i++);
	while (_head < high) {
		if ((p[0] & 3) == 3) {
			sift(_head, width, cmp, pshift, lp);
			shr(p, 2);
			pshift += 2;
		} else {
			if (lp[pshift - 1] >= (size_t)(high - _head)) { trinkle(_head, width, cmp, p, pshift, 0, lp); }
			else { sift(_head, width, cmp, pshift, lp); }
			if (pshift == 1) { shl(p, 1); pshift = 0; }
			else { shl(p, pshift - 1); pshift = 1; }
		}
		p[0] |= 1;
		_head += width;
	}
	trinkle(_head, width, cmp, p, pshift, 0, lp);
	while (pshift != 1 || p[0] != 1 || p[1] != 0) {
		if (pshift <= 1) {
			trail = pntz(p);
			shr(p, trail);
			pshift += trail;
		} else {
			shl(p, 2);
			pshift -= 2;
			p[0] ^= 7;
			shr(p, 1);
			trinkle((_head - lp[pshift] - width), width, cmp, p, (pshift + 1), 1, lp);
			shl(p, 1);
			p[0] |= 1;
			trinkle((_head - width), width, cmp, p, pshift, 1, lp);
		}
		_head -= width;
	}
}


// ENVIRONMENT FUNCTIONS

/** Returns the PID of the current process */
LIB_FUNC pid_t getpid(void) {
	return (pid_t)syscall0(SYS_getpid);
}


/** Returns the UID of the current process */
LIB_FUNC uid_t getuid(void) {
	return (uid_t)syscall0(SYS_getuid);
}


/** Returns the process group ID of the process whose process ID is equal to `pid`, or if `pid` is equal to zero, getpgid() returns the process group ID of the calling process */
LIB_FUNC pid_t getpgid(const pid_t pid) {
	return (pid_t)syscall1(SYS_getpgid, (long)pid);
}


/** Returns the session ID of the process whose process ID is equal to `pid`, or if `pid` is equal to zero, getsid() returns the process group ID of the calling process */
LIB_FUNC pid_t getsid(const pid_t pid) {
	return (pid_t)syscall1(SYS_getsid, (long)pid);
}


/** Sets the SID of the current process */
LIB_FUNC pid_t setsid(void) {
	return (pid_t)syscall0(SYS_setsid);
}


/** Determine if the str is in an environment string; Return 0 if the name is not valid */
LIB_FUNC size_t envvarnamelen(const char* str, const bool withequal) {
	if (str == NULL) { return 0; }
	register size_t l_name = strcspn(str, "=");
	if (l_name == 0) { return 0; }
	else if (withequal) { if (str[l_name] != '=') { return 0; } }
	else if (str[l_name] == '=') { return 0; }
	return l_name;
}
#define __envvarnamelen(str, withequal)   envvarnamelen((str), (withequal))


LIB_FUNC int clearenv(void) {
	__environ[0] = 0;
	return 0;
}


/** Returns an environment variable given by `name` */
LIB_FUNC const char* getenv(const char* restrict name) {
	register size_t l = strlen(name);
	if ((!__environ) || !(*name) || strchr(name, '=')) { return NULL; }
	register int i;
	for (i = 0; __environ[i] && (strncmp(name, __environ[i], l) || __environ[i][l] != '='); i++);
	if (__environ[i]) { return (__environ[i] + l + 1); }
	return NULL;
}


LIB_FUNC int unsetenv(const char* name) {
	if (!*name || (strchr(name, '='))) { set_errno(EINVAL); return -1; }
	register int i, j;
	register size_t l = strlen(name);
goto_unsetenv_again:
	for (i = 0; __environ[i] && (memcmp(name, __environ[i], l) || __environ[i][l] != '='); i++);
	if (__environ[i]) {
		if (__env_map) {
			for (j = 0; __env_map[j] && __env_map[j] != __environ[i]; j++);
			free(__env_map[j]);
			for (; __env_map[j]; j++) { __env_map[j] = __env_map[j + 1]; }
		}
		for (; __environ[i]; i++) { __environ[i] = __environ[i + 1]; }
		goto goto_unsetenv_again;
	}
	return 0;
}


LIB_FUNC int __putenv(char* s, const int a) {
	const char* z = (const char*)strchr(s, '=');
	if (!z) { return unsetenv(s); }
	else if (z == s) { return -1; }
	register int i = 0, j = 0;
	for (; __environ[i] && memcmp(s, __environ[i], (size_t)((size_t)(z - s) + 1)); i++);
	char** newmap = 0;
	if (a) {
		if (!__env_map) {
			__env_map = calloc(2, SIZEOF_POINTER);
			if (__env_map) { __env_map[0] = s; }
		} else {
			for (; __env_map[j] && __env_map[j] != __environ[i]; j++);
			if (!__env_map[j]) {
				newmap = realloc(__env_map, (size_t)(SIZEOF_POINTER * (size_t)(j + 2)));
				if (newmap) {
					__env_map = newmap;
					__env_map[j] = s;
					__env_map[j + 1] = NULL;
				}
			} else { free(__env_map[j]); }
		}
	}
	static char** oldenv;
	char** newenv = 0;
	if (!__environ[i]) {
		newenv = malloc((size_t)(SIZEOF_POINTER * (size_t)(i + 2)));
		if (!newenv) {
			if (a && __env_map) __env_map[j] = 0;
			return -1;
		}
		memcpy_no_output(newenv, __environ, (size_t)(SIZEOF_POINTER * (size_t)i));
		newenv[i] = s;
		newenv[i + 1] = 0;
		__environ = newenv;
		free(oldenv);
		oldenv = __environ;
	}
	__environ[i] = s;
	return 0;
}
#define putenv(_str)   ((int)__putenv(_str, 0))


LIB_FUNC int setenv(const char* var, const char* value, const int overwrite) {
	if (!var || !(*var) || strchr(var, '=')) { set_errno(EINVAL); return -1; }
	else if (!overwrite && getenv(var)) { return 0; }
	register size_t l1 = strlen(var), l2 = strlen(value);
	char* s = malloc(l1 + l2 + 2);
	if (s) {
		memcpy_no_output(s, var, l1);
		s[l1] = '=';
		memcpy_no_output((s + l1 + 1), value, l2);
		s[l1 + l2 + 1] = 0;
		if (!(__putenv(s, 1))) { return 0; }
	}
	free(s);
	return -1;
}


/* RANDOM (<sys/random.h>) */


#if (!(defined(_RANDOM_H) || defined(_RANDOM_H_) || defined(_SYS_RANDOM_H) || defined(_SYS_RANDOM_H_)))
#define RANDOM_H   (1)
#define _RANDOM_H   (1)
#define _RANDOM_H_   (1)
#define SYS_RANDOM_H   (1)
#define _SYS_RANDOM_H   (1)
#define _SYS_RANDOM_H_   (1)
#define RAND48_H   (1)
#define _RAND48_H_   (1)


/** Do not block; return EAGAIN instead */
#define GRND_NONBLOCK   1
/** Use the /dev/random pool instead of /dev/urandom */
#define GRND_RANDOM   2


typedef struct arc4_stream { uint8_t i, j; uint8_t s[256]; }   arc4_stream_t;


/** Data structure for communication with thread safe versions */
struct drand48_data {
	unsigned short __x[3];   // Current state
	unsigned short __old_x[3];   // Old state
	unsigned short __c;   // Additive const. in congruential formula
	unsigned short __init;   // Flag for initializing
	unsigned long long __a;   // Factor in congruential formula
};


static volatile UNUSED int rand_n = 31;
static volatile UNUSED int rand_i = 3;
static volatile UNUSED int rand_j = 0;
static UNUSED pid_t arc4_stir_pid;
static UNUSED int arc4_count;
static UNUSED struct arc4_stream rs;
static volatile UNUSED uint64_t seed = 7385;
static volatile UNUSED unsigned short __seed48[8] = { 0, 0, 0, 0xe66d, 0xdeec, 5, 0xb };
static UNUSED smallint rs_initialized;
/** Global state for non-reentrant functions */
UNUSED struct drand48_data __libc_drand48_data;
static volatile UNUSED uint32_t align64 rand_init[32] = {
	0, 0x5851f42d, 0xc0b18ccf, 0xcbb5f646,
	0xc7033129, 0x30705b04, 0x20fd5db4, 0x9a8b7f78,
	0x502959d8, 0xab894868, 0x6c0356a7, 0x88cdb7ff,
	0xb477d43f, 0x70a3a52b, 0xa8e4baf1, 0xfd8341fc,
	0x8ae16fd9, 0x742d2f7a, 0x0d1f0796, 0x76035e09,
	0x40f7702c, 0x6fa72ca5, 0xaaa84157, 0x58a0df74,
	0xc74a0364, 0xae533cc4, 0x04185faf, 0x6de3b115,
	0xcab8628, 0xf043bfa4, 0x398150e9, 0x37521657
};
static volatile UNUSED uint32_t* restrict rand_x = (rand_init + 1);


#define lcg31(x)   ((1103515245 * (uint32_t)(x) + 12345) & 0x7fffffff)
#define lcg64(x)   (6364136223846793005ULL * (uint64_t)(x) + 1)


LIB_FUNC void __srandom(const unsigned int seed) {
	register uint64_t s = (seed + (unsigned int)getpid()) * (unsigned int)HP_TIMING();
	if (rand_n == 0) {
		rand_x[0] = (uint32_t)s;
		return;
	}
	rand_i = ((rand_n == 31 || rand_n == 7) ? 3 : 1);
	rand_j = 0;
	register int k;
	for (k = 0; k < rand_n; k++) {
		s = lcg64(s);
		rand_x[k] = (uint32_t)(s >> 32);
	}
	rand_x[0] |= (uint32_t)1;
}


LIB_FUNC void srandom(const unsigned int seed) {
	LOCK(memlock);
	__srandom(seed);
	UNLOCK(memlock);
}


LIB_FUNC void loadstate(volatile uint32_t* _state) {
	rand_x = (_state + 1);
	rand_n = (int)(rand_x[-1] >> 16);
	rand_i = (int)((rand_x[-1] >> 8) & 0xff);
	rand_j = (int)(rand_x[-1] & 0xff);
}


LIB_FUNC volatile void* savestate(void) {
	rand_x[-1] = (uint32_t)((rand_n << 16) | (rand_i << 8) | rand_j);
	return (rand_x - 1);
}


LIB_FUNC volatile char* initstate(const unsigned int seed, char* _state, const size_t size) {
	if (size < 8) { return 0; }
	LOCK(memlock);
	volatile void* old = savestate();
	if (size < 32) { rand_n = 0; }
	else if (size < 64) { rand_n = 7; }
	else if (size < 128) { rand_n = 15; }
	else if (size < 256) { rand_n = 31; }
	else { rand_n = 63; }
	rand_x = (uint32_t*)_state + 1;
	__srandom(seed);
	savestate();
	UNLOCK(memlock);
	return old;
}


LIB_FUNC volatile char* setstate(char* _state) {
	LOCK(memlock);
	volatile void* old = savestate();
	loadstate((uint32_t*)_state);
	UNLOCK(memlock);
	return old;
}


LIB_FUNC unsigned int temper(unsigned int x) {
	x ^= (unsigned int)(x >> 11);
	x ^= (unsigned int)((x << 7) & 0x9d2c5680);
	x ^= (unsigned int)((x << 15) & 0xefc60000);
	x ^= (unsigned int)(x >> 18);
	return x;
}


LIB_FUNC int lcong48_r(const unsigned short param[7], struct drand48_data* buffer) {
	memcpy_no_output(buffer->__x, &param[0], sizeof(buffer->__x));
	buffer->__a = ((uint64_t)param[5] << 32 | (uint32_t)param[4] << 16 | param[3]);
	buffer->__c = param[6];
	buffer->__init = 1;
	return 0;
}
#define __lcong48_r(param, buffer)   lcong48_r((param), (buffer))


LIB_FUNC void lcong48(const unsigned short param[7]) {
	(void)lcong48_r(param, &__libc_drand48_data);
}


LIB_FUNC uint64_t __rand48_step(volatile unsigned short* restrict xi, volatile unsigned short* restrict lc) {
	const uint64_t a = (uint64_t)(lc[0] | ((lc[1] + 0U) << 16) | ((lc[2] + 0ULL) << 32));
	const uint64_t x = a * (uint64_t)(xi[0] | ((xi[1] + 0U) << 16) | ((xi[2] + 0ULL) << 32)) + lc[3];
	xi[0] = (unsigned short)x;
	xi[1] = (unsigned short)(x >> 16);
	xi[2] = (unsigned short)(x >> 32);
	return (uint64_t)(x & 0xffffffffffffULL);
}


/** Returns a non-negative long integer uniformly distributed over the interval [0, 2^31] */
LIB_FUNC long nrand48(volatile unsigned short s[3]) {
	return (long)(__rand48_step(s, (__seed48 + 3)) >> 17);
}


/** Returns a non-negative long integer uniformly distributed over the interval [0, 2^31] */
LIB_FUNC long lrand48(void) {
	return nrand48(__seed48);
}


LIB_FUNC unsigned short* seed48(unsigned short* s) {
	static unsigned short p[3] = { 0 };
	vmemcpy_no_output(p, __seed48, sizeof(SIZEOF_SHORT * 3));
	memcpy_no_output(UNVOLATILE(__seed48), s, sizeof(SIZEOF_SHORT * 3));
	return p;
}


/** Returns a pseudo-random integral number */
LIB_FUNC long random(void) {
	rand_x[((rand_i + (int)getpid()) % 32)] += rand_x[((rand_j ^ (int)HP_TIMING()) % 32)];
	if (++rand_i == rand_n) { rand_i = 0; }
	if (++rand_j == rand_n) { rand_j = 0; }
	register long x = ((long)rand_x[((rand_j + (int)HP_TIMING()) % 32)]) - (long)HP_TIMING();
	register long t = ((16807 * (x % 127773)) - (2836 * (long)(x / 127773)));
	if (t < 0) { return ((long)t * -1L); }
	return (long)t;
}


/** Initialize random number generator */
LIB_FUNC void srand48(const long seed) {
	register const long tmppid = ((long)getpid() * (long)HP_TIMING());
	seed48((unsigned short [3]) { (unsigned short)HP_TIMING(), (unsigned short)(seed - tmppid), (unsigned short)(seed >> 16) });
}


/** Initialize random number generator */
LIB_FUNC void srand(const unsigned int s) {
	srand48((long)s);
}


/** Returns a pseudo-random integral number in the range between 0 and RAND_MAX */
LIB_FUNC int rand(void) {
	register const uint64_t tmppid = ((uint64_t)getpid() * (uint64_t)HP_TIMING());
	seed = (uint64_t)(6364136223846793005ULL * seed + tmppid);
	const int result = (((int)(seed >> 33)) + (int)tmppid);
	if (result < 0) { return (result * -1); }
	return result;
}
/** Returns a pseudo-random integral number in the range between 0 and 100 */
#define rand100()   ((int)(rand() % 100))


LIB_FUNC int rand_r(unsigned int* seed) {
	return (int)(temper(*seed = (*seed * 1103515245) + 12345) >> 1);
}


LIB_FUNC int __drand48_iterate(unsigned short xsubi[3], struct drand48_data* buffer) {
	if (PREDICT_UNLIKELY(!buffer->__init)) {
		buffer->__a = 0x5deece66dULL;
		buffer->__c = 0xb;
		buffer->__init = 1;
	}
	const uint64_t drand48_X = (uint64_t)xsubi[2] << 32 | (uint32_t)xsubi[1] << 16 | xsubi[0];
	const uint64_t result = (uint64_t)(drand48_X * buffer->__a + buffer->__c);
	xsubi[0] = (unsigned short)(result & (uint64_t)0xffffU);
	xsubi[1] = (unsigned short)((result >> 16) & (uint64_t)0xffffU);
	xsubi[2] = (unsigned short)((result >> 32) & (uint64_t)0xffffU);
	return 0;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC int erand48_r(unsigned short xsubi[3], struct drand48_data* buffer, double* result) {
	if (__drand48_iterate(xsubi, buffer) < 0) { return -1; }
	union ieee754_double temp;
	temp.ieee.negative = 0;
	temp.ieee.exponent = IEEE754_DOUBLE_BIAS;
	temp.ieee.mantissa0 = ((unsigned short)(xsubi[2] << 4) | (unsigned short)(xsubi[1] >> 12));
	temp.ieee.mantissa1 = ((unsigned int)(((xsubi[1] & 0xfff) << 20) | (xsubi[0] << 4)));
	*result = temp.d - 1.0;
	return 0;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC double erand48(unsigned short xsubi[3]) {
	double result;
	(void)erand48_r(xsubi, &__libc_drand48_data, &result);
	return result;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC double drand48(void) {
	double result;
	(void)erand48_r(__libc_drand48_data.__x, &__libc_drand48_data, &result);
	return result;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC int drand48_r(struct drand48_data* buffer, double* result) {
	return erand48_r(buffer->__x, buffer, result);
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
LIB_FUNC int jrand48_r(unsigned short xsubi[3], struct drand48_data* buffer, long* result) {
	if (__drand48_iterate(xsubi, buffer) < 0) { return -1; }
	*result = ((xsubi[2] << 16) | xsubi[1]) & 0xffffffffL;
	return 0;
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
LIB_FUNC long jrand48(unsigned short xsubi[3]) {
	long result;
	(void)jrand48_r(xsubi, &__libc_drand48_data, &result);
	return result;
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
#define mrand48()   (long)jrand48(__seed48)


LIB_FUNC void arc4_init(struct arc4_stream* as) {
	register int n;
	for (n = 0; n < 256; n++) { as->s[n] = (uint8_t)n; }
	as->i = 0;
	as->j = 0;
}


LIB_FUNC uint8_t arc4_getbyte(struct arc4_stream* as) {
	uint8_t si, sj;
	as->i = (uint8_t)(as->i + 1);
	si = as->s[as->i];
	as->j = (uint8_t)(as->j + si);
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (uint8_t)(as->s[(si + sj) & 0xff]);
}


LIB_FUNC void arc4_addrandom(struct arc4_stream* as, uchar* dat, const int datlen) {
	register int n;
	register uint8_t si;
	as->i--;
	for (n = 0; n < 256; n++) {
		as->i = (uint8_t)(as->i + 1);
		si = as->s[as->i];
		as->j = (uint8_t)(as->j + si + dat[n % datlen]);
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
	}
	as->j = as->i;
}


LIB_FUNC void arc4_stir(struct arc4_stream* as) {
	int n;
	unsigned char rnd[128] = { 0 };
	struct timeval tv;
#   ifndef __ARC4RANDOM_USES_NODEV__
	const int fd = open("/dev/urandom", O_RDONLY);
	if (fd != -1) { read(fd, rnd, sizeof(rnd)); close(fd); }
	else
#   endif
	if (gettimeofday(&tv, NULL) != -1) {
		rnd[0] = (unsigned char)((tv.tv_sec % 10000) * 3 + tv.tv_usec * 7 + (getpid() % 1000) * 13);
		for (n = 1; n < 127 ; n++) {
			if (rnd[n] == 0) { rnd[n] = (unsigned char)((rnd[n - 1] + n) ^ ((getpid() % 1000) * 17)); }
		}
	} else {
		rnd[0] = (unsigned char)((getpid() % 1000) * 19);
		for (n = 1; n < 127 ; n++) {
			if (rnd[n] == 0) { rnd[n] = (unsigned char)((rnd[n - 1] + n) ^ ((getpid() % 1000) * 23)); }
		}
	}
	arc4_stir_pid = getpid();
	arc4_addrandom(as, rnd, sizeof(rnd));
	for (n = 0; n < 256; n++) { (void)arc4_getbyte(as); }
	arc4_count = 1600000;
}


LIB_FUNC void arc4random_stir(void) {
	if (!rs_initialized) { arc4_init(&rs); rs_initialized = 1; }
	arc4_stir(&rs);
}
#define __arc4random_stir()   arc4random_stir()


LIB_FUNC uint8_t __arc4_getbyte(void) {
	if (--arc4_count == 0 || (!rs_initialized)) { arc4random_stir(); }
	return arc4_getbyte(&rs);
}


LIB_FUNC uint32_t arc4_getword(struct arc4_stream* as) {
	uint32_t val = (uint32_t)(arc4_getbyte(as) << 24);
	val |= (uint32_t)(arc4_getbyte(as) << 16);
	val |= (uint32_t)(arc4_getbyte(as) << 8);
	val |= (uint32_t)arc4_getbyte(as);
	return val;
}


LIB_FUNC void arc4random_addrandom(uchar* dat, int datlen) {
	if (!rs_initialized) { arc4random_stir(); }
	arc4_addrandom(&rs, dat, datlen);
}


/** Returns a single random 32-bit value */
LIB_FUNC uint32_t arc4random(void) {
	arc4_count -= 4;
	if (arc4_count <= 0 || (!rs_initialized) || arc4_stir_pid != getpid()) { arc4random_stir(); }
	return arc4_getword(&rs);
}
#define rk_random()   arc4random()


LIB_FUNC char* randname(char* template) {
	register int i;
	struct timespec ts = { 0 };
	clock_gettime(CLOCK_REALTIME, &ts);
	register unsigned long r = (unsigned long)(((unsigned long)(ts.tv_nsec * 65537) ^ (unsigned long)((unsigned long)&ts >> 4)) + (unsigned long)template);
	for (i = 0; i < 6; i++, r >>= 5) { template[i] = (char)('A' + (r & 15) + (r & 16) * 2); }
	return template;
}
#define __randname(template)   randname((template))


#endif  // SYS_RANDOM_H


// MISCELLANEOUS STDLIB FUNCTIONS


LIB_FUNC noreturn COLD void error(const int exit_val, const int errno_val, const char* s) {
	if (s == NULL) { s = ""; }
	const char* separator;
	if (*s == '\0') { separator = ""; }
	else { separator = ": "; }
	char buf[NL_TEXTMAX] = { 0 };
	(void)strerror(errno_val);
	(void)fprintf(stderr, "%s%s%s\n", s, separator, buf);
	_Exit(exit_val);
	UNREACHABLE
}
#define exit_on_error(msg)   error(EXIT_FAILURE, get_errno(), (msg))


/** Creates a pipe, a unidirectional data channel that can be used for interprocess communication */
LIB_FUNC int pipe(int fd[2]) {
#ifdef SYS_pipe
	return (int)syscall1(SYS_pipe, (long)fd);
#else
	return (int)syscall2(SYS_pipe2, fd, 0);
#endif
}


/** Creates a pipe, a unidirectional data channel that can be used for interprocess communication */
LIB_FUNC int pipe2(int fd[2], const int flag) {
	if (!flag) { return pipe(fd); }
	int ret = (int)syscall2(SYS_pipe2, (long)&fd, flag);
	if (PREDICT_UNLIKELY(neq_errno(ENOSYS) && ret == -1)) { return -1; }
	else if (ret != -1) { return ret; }
	ret = pipe(fd);
	if (ret) { return ret; }
	if (flag & O_CLOEXEC) {
		syscall3(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
		syscall3(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
	}
	if (flag & O_NONBLOCK) {
		syscall3(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
		syscall3(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
	}
	return 0;
}


/** Creates a new process by duplicating the calling process */
LIB_FUNC pid_t fork(void) {
	sigset_t set;
	__block_all_sigs(&set);
#ifdef SYS_fork
	const pid_t ret = (pid_t)syscall0(SYS_fork);
#else
	const pid_t ret = (pid_t)syscall2(SYS_clone, SIGCHLD, 0);
#endif
	if (!ret) {
		struct pthread* self = __pthread_self();
		self->tid = (pid_t)syscall0(SYS_gettid);
		self->robust_list.off = 0;
		self->robust_list.pending = 0;
		libc.threads_minus_1 = 0;
	}
	__restore_sigs(&set);
	return ret;
}


/** Create a child process and block parent */
LIB_FUNC pid_t vfork(void) {
#ifdef SYS_fork
	return (pid_t)syscall0(SYS_fork);
#else
	return (pid_t)syscall2(SYS_clone, SIGCHLD, 0);
#endif
}
#define __vfork()   vfork()


/** Open a master pseudo terminal and return its file descriptor */
LIB_FUNC int getpt(void) {
	char align64 buf[sizeof(_PATH_PTY) + 2] = { 0 };
	const char *p, *q;
	char* s = mempcpy(buf, _PATH_PTY, (sizeof(_PATH_PTY) - 1));
	s[2] = '\0';
	register int fd;
	for (p = __libc_ptyname1; *p != '\0'; ++p) {
		s[0] = *p;
		for (q = __libc_ptyname2; *q != '\0'; ++q) {
			s[1] = *q;
			fd = open(buf, O_RDWR);
			if (fd != -1) { return fd; }
			else if (eq_errno(ENOENT)) { return -1; }
		}
	}
	set_errno(ENOENT);
	return -1;
}
#define __getpt()   getpt()
#define _getpt()   getpt()


/** Return the unique identifier of the current host */
LIB_FUNC long gethostid(void) {
	return 0;
}


LIB_FUNC int getdomainname(char* restrict name, const size_t len) {
	struct utsname temp = { { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 } };
	uname(&temp);
	if (!len || strlen(temp.domainname) >= len) { set_errno(EINVAL); return -1; }
	strcpy_no_output(name, temp.domainname);
	return 0;
}


LIB_FUNC int setdomainname(const char* restrict name, const size_t len) {
	return (int)syscall2(SYS_setdomainname, (long)&name, (long)len);
}


/** Return a string naming the current system in the character array utsname */
LIB_FUNC int uname(struct utsname* restrict uts) {
	return (int)syscall1(SYS_uname, (long)&uts);
}


/** Open a pseudoterminal device */
LIB_FUNC int posix_openpt(const int flags) {
	return open("/dev/ptmx", flags);
}


/** Changes the mode and owner of the slave pseudoterminal device corresponding to the master pseudoterminal referred to by fd */
LIB_FUNC int grantpt(const int fd) {
	return ioctl(fd, TIOCGRANTPT, 0);
}


LIB_FUNC int unlockpt(const int fd) {
	int unlock = 0;
	return ioctl(fd, TIOCSPTLCK, &unlock);
}


LIB_FUNC int ptsname_r(const int fd, char* buf, size_t len) {
	int pty, err;
	if (!buf) { len = 0; }
	if ((err = (int)syscall3(SYS_ioctl, fd, TIOCGPTN, (long)&pty))) { return -err; }
	else if (snprintf(buf, len, "/dev/pts/%d", pty) >= (int)len) { return ERANGE; }
	return 0;
}
#define __ptsname_r(fd, buf, len)   ptsname_r((fd), (buf), (len))


LIB_FUNC char* ptsname(const int fd) {
	static char align64 buf[10 + (SIZEOF_INT * 3)] = { 0 };
	register int err = ptsname_r(fd, buf, sizeof(buf));
	if (err) { set_errno(err); return 0; }
	return buf;
}


/** Duplicate FD to FD2, closing the old FD2 and making FD2 be open the same file as FD; Return FD2 or -1 */
LIB_FUNC int dup2(const int fd, const int fd2) {
	if (fd < 0 || fd2 < 0) {
		set_errno(EBADF);
		return -1;
	}
	if (fd == fd2) { return fd2; }
	set_errno(ENOSYS);
	return -1;
}
#define __dup2(fd, fd2)   dup2((fd), (fd2))
#define sys_dup2(fd, fd2)   dup2((fd), (fd2))
#define __sys_dup2(fd, fd2)   dup2((fd), (fd2))


LIB_FUNC int login_tty(const int fd) {
	setsid();
	if (ioctl(fd, TIOCSCTTY, (char*)0)) { return -1; }
	dup2(fd, 0);
	dup2(fd, 1);
	dup2(fd, 2);
	if (fd > 2) { close(fd); }
	return 0;
}


LIB_FUNC int openpty(int* pm, int* ps, char* name, const struct termios* tio, const struct winsize* ws) {
	const int m = open("/dev/ptmx", (int)(O_RDWR | O_NOCTTY));
	if (m < 0) { return -1; }
	int cs, s, n = 0;
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	char buf[20] = { 0 };
	if (ioctl(m, TIOCSPTLCK, &n) || ioctl(m, (int)TIOCGPTN, &n)) { goto goto_openpty_fail; }
	if (!name) { name = buf; }
	snprintf(name, sizeof(buf), "/dev/pts/%d", n);
	if ((s = open(name, (int)(O_RDWR | O_NOCTTY))) < 0) { goto goto_openpty_fail; }
	if (tio) { tcsetattr(s, TCSANOW, tio); }
	if (ws) { ioctl(s, TIOCSWINSZ, ws); }
	*pm = m;
	*ps = s;
	pthread_setcancelstate(cs, 0);
	return 0;
goto_openpty_fail:
	close(m);
	pthread_setcancelstate(cs, 0);
	return -1;
}


LIB_FUNC int forkpty(int* pm, char* name, const struct termios* tio, const struct winsize* ws) {
	int m, s, ec = 0, p[2] = { 0 }, cs;
	if (openpty(&m, &s, name, tio, ws) < 0) { return -1; }
	sigset_t set, oldset;
	sigfillset(&set);
	pthread_sigmask(SIG_BLOCK, &set, &oldset);
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	pid_t pid = -1;
	if (pipe2(p, O_CLOEXEC)) {
		close(s);
		if (pid > 0) { *pm = m; }
		else { close(m); }
		pthread_setcancelstate(cs, 0);
		pthread_sigmask(SIG_SETMASK, &oldset, 0);
		return pid;
	}
	pid = fork();
	if (!pid) {
		close(m);
		close(p[0]);
		const int sverrno = get_errno();
		if (login_tty(s)) { write(p[1], &sverrno, SIZEOF_ERRNO); _exit(127); }
		close(p[1]);
		pthread_setcancelstate(cs, 0);
		pthread_sigmask(SIG_SETMASK, &oldset, 0);
		return 0;
	}
	close(s);
	close(p[1]);
	if (read(p[0], &ec, SIZEOF_INT) > 0) {
		int status = 0;
		waitpid(pid, &status, 0);
		pid = -1;
		set_errno(ec);
	}
	close(p[0]);
	if (pid > 0) { *pm = m; }
	else { close(m); }
	pthread_setcancelstate(cs, 0);
	pthread_sigmask(SIG_SETMASK, &oldset, 0);
	return pid;
}


LIB_FUNC char* getcwd(char* buf, size_t size) {
	char tmp[PATH_MAX] = { 0 };
	if (!buf) {
		buf = tmp;
		size = PATH_MAX;
	} else if (!size) {
		set_errno(EINVAL);
		return 0;
	}
	if (syscall2(SYS_getcwd, (long)buf, (long)size) < 0) { return 0; }
	return (buf == tmp ? strdup(buf) : buf);
}


LIB_FUNC char* get_current_dir_name(void) {
	struct stat a, b;
	const char* res = getenv("PWD");
	if (res && *res && (!stat64(res, &a)) && (!stat64(".", &b)) && (a.st_dev == b.st_dev) && (a.st_ino == b.st_ino)) { return strdup(res); }
	return getcwd(0, 0);
}


/** Checks whether the calling process can access the file pathname */
LIB_FUNC int access(const char* filename, const int amode) {
#ifdef SYS_access
	return (int)syscall2(SYS_access, (long)&filename, amode);
#else
	return (int)syscall4(SYS_faccessat, AT_FDCWD, (long)&filename, amode, 0);
#endif
}


LIB_FUNC void procfdname(char* restrict buf, unsigned int fd) {
	register unsigned int i, j;
	for (i = 0; (buf[i] = "/proc/self/fd/"[i]); i++);
	if (!fd) {
		buf[i] = '0';
		buf[i + 1] = 0;
		return;
	}
	for (j = fd; j; j /= 10, i++);
	buf[i] = 0;
	for (; fd; fd /= 10) { buf[--i] = (char)('0' + (fd % 10)); }
}
#define __procfdname(buf, fd)   procfdname((buf), (fd))


LIB_FUNC char* realpath(const char* restrict filename, char* restrict resolved) {
	if (!filename) { set_errno(EINVAL); return 0; }
	int fd = (int)syscall2(SYS_open, (long)filename, (long)(O_PATH | O_NONBLOCK | O_CLOEXEC));
	if (fd < 0) { return 0; }
	char buf[15 + (3 * SIZEOF_INT)] = { 0 };
	char tmp[PATH_MAX] = { 0 };
	procfdname(buf, (unsigned int)fd);
	ssize_t r = readlink(buf, tmp, (sizeof(tmp) - 1));
	if (r < 0) { syscall1(SYS_close, fd); return 0; }
	tmp[r] = 0;
	struct stat _stat1 = { 0 }, _stat2 = { 0 };
	fstat(fd, &_stat1);
	r = stat64(tmp, &_stat2);
	if (r < 0 || (_stat1.st_dev != _stat2.st_dev) || (_stat1.st_ino != _stat2.st_ino)) {
		if (!r) { set_errno(ELOOP); }
		syscall1(SYS_close, fd);
		return 0;
	}
	syscall1(SYS_close, fd);
	return (resolved ? strcpy(resolved, tmp) : strdup(tmp));
}


/** Return true if we read an affirmative line from standard input; Since this function uses stdin, it is suggested that the caller not use `STDIN_FILENO` directly, and also that the line atexit(close_stdin) be added to `main()` */
LIB_FUNC bool yesno(void) {
	bool answer;
#   if (defined(ENABLE_NLS) && ENABLE_NLS)
	char* response = NULL;
	size_t response_size = 0;
	const ssize_t response_len = getline(&response, &response_size, stdin);
	if (response_len <= 0) { answer = false; }
	else {
		if (response[response_len - 1] == '\n') { response[response_len - 1] = '\0'; }
		answer = (0 < rpmatch(response));
	}
	free(response);
#   else
	register int c = getchar();
	answer = (c == 'y' || c == 'Y');
	while (c != '\n' && c != EOF) { c = getchar(); }
#   endif
	return answer;
}


/** Executes the program pointed to by filename */
LIB_FUNC int execve(const char* path, char* argv[], char* envp[]) {
	return (int)syscall3(SYS_execve, (long)path, (long)argv, (long)envp);
}
#define _execve(path, argv, envp)   execve((path), (argv), (envp))
#define __execve(path, argv, envp)   execve((path), (argv), (envp))


/** Executes a program */
LIB_FUNC int execv(const char* path, char* argv[]) {
	return (int)syscall3(SYS_execve, (long)path, (long)argv, (long)__environ);
}
#define _execv(path, argv)   execv((path), (argv))
#define __execv(path, argv)   execv((path), (argv))


/** Executes a program */
LIB_FUNC int execvpe(const char* file, char* argv[], char* envp[]) {
	const char *p, *z, *path = getenv("PATH");
	size_t l, k;
	register int seen_eacces = 0;
	set_errno(ENOENT);
	if (!*file) { return -1; }
	else if (strchr(file, '/')) { return execve(file, argv, envp); }
	else if (!path) { path = "/usr/local/bin:/bin:/usr/bin"; }
	k = strnlen(file, NAME_MAX + 1);
	if (k > NAME_MAX) { set_errno(ENAMETOOLONG); return -1; }
	l = strnlen(path, PATH_MAX - 1) + 1;
	char b[l + k + 1];
	for (p = path; ; p = z) {
		z = strchr(p, ':');
		if (!z) { z = p + strlen(p); }
		if ((size_t)(z - p) >= l) {
			if (!*z++) { break; }
			continue;
		}
		memcpy_no_output(b, p, (size_t)(z - p));
		b[z - p] = '/';
		memcpy_no_output((b + (z - p) + (z > p)), file, (k + 1));
		execve(b, argv, envp);
		if (eq_errno(EACCES)) { seen_eacces = 1; }
		else if (neq_errno(ENOENT)) { return -1; }
		else if (!*z++) { break; }
	}
	if (seen_eacces) { set_errno(EACCES); }
	return -1;
}
#define _execvpe(file, argv, envp)   execvpe((file), (argv), (envp))
#define __execvpe(file, argv, envp)   execvpe((file), (argv), (envp))


/** Executes a program */
LIB_FUNC int execvp(const char* file, char* argv[]) {
	return __execvpe(file, argv, __environ);
}
#define _execvp(file, argv)   execvp((file), (argv))
#define __execvp(file, argv)   execvp((file), (argv))


/** Executes a program */
LIB_FUNC int execlp(const char* file, char* argv0, ...) {
	register int argc;
	va_list ap;
	va_start(ap, argv0);
	for (argc = 1; va_arg(ap, char*); ++argc);
	va_end(ap);
	char* argv[argc + 1];
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i;
	for (i = 1; i < argc; i++) { argv[i] = va_arg(ap, char*); }
	argv[i] = NULL;
	va_end(ap);
	return execvp(file, argv);
}
#define _execlp(file, argv0, ...)   execlp((file), (argv0), (__VA_ARGS__))
#define __execlp(file, argv0, ...)   execlp((file), (argv0), (__VA_ARGS__))


/** Executes a program */
LIB_FUNC int execle(const char* path, char* argv0, ...) {
	va_list ap;
	va_start(ap, argv0);
	register int argcnt = 1;
	for (; va_arg(ap, char*); ++argcnt);
	va_end(ap);
	char* argv[argcnt + 1];
	char** envp = NULL;
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i = 1;
	for (; i <= argcnt; i++) { argv[i] = va_arg(ap, char*); }
	envp = va_arg(ap, char**);
	va_end(ap);
	return execve(path, argv, envp);
}
#define _execle(path, argv0, ...)   execle((path), (argv0), (__VA_ARGS__))
#define __execle(path, argv0, ...)   execle((path), (argv0), (__VA_ARGS__))


/** Executes a program */
LIB_FUNC int execl(const char* path, char* argv0, ...) {
	register int argc;
	va_list ap;
	va_start(ap, argv0);
	for (argc = 1; va_arg(ap, char*); ++argc);
	va_end(ap);
	char* argv[argc + 1];
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i;
	for (i = 1; i < argc; i++) { argv[i] = va_arg(ap, char*); }
	argv[i] = NULL;
	va_end(ap);
	return execv(path, argv);
}
#define _execl(path, argv0, ...)   execl((path), (argv0), (__VA_ARGS__))
#define __execl(path, argv0, ...)   execl((path), (argv0), (__VA_ARGS__))


/** Execute a shell command */
LIB_FUNC int system(const char* command) {
	if (!command) { return -1; }
	register pid_t pid, cpid;
	const char* argp[4] = {"sh", "-c", command, NULL};
	switch (cpid = vfork()) {
		case -1:
			return -1;
		case 0:
			execv(PATH_BSHELL, UNCONST(argp));
			_Exit(127);
		default: break;
	}
	int pstat = 0;
	do {
		pid = waitpid(cpid, &pstat, 0);
	} while (pid == -1 && eq_errno(EINTR));
	return (pid == -1 ? -1 : pstat);
}


/** Return a malloced string containing the canonical absolute name of the named file; The last file name component need not exist, and may be a symlink to a nonexistent file */
LIB_FUNC char* canonicalize_file_name(const char* name) {
	return realpath(name, NULL);
}


#if (defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE))
#   define mkstemp64   mkstemp
#   define mkostemp64   mkostemp
#   define tmpfile64   tmpfile
#   define fopen64   fopen
#   define freopen64   freopen
#   define fseeko64   fseeko
#   define ftello64   ftello
#   define fgetpos64   fgetpos
#   define fsetpos64   fsetpos
#elif (defined(_BSD_SOURCE))
#   define mkstemps64   mkstemps
#   define mkostemps64   mkostemps
#endif


/* TODO: Add stdlib functions
int getsubopt(char**, char* const*, char**);
char* mkdtemp(char*);
int mkstemp(char*);
void setkey(const char*);
*/


#endif  // STDLIB_H


/* PTRACE DEBUGGER SUPPORT INTERFACE */


#if (!(defined(SYS_PTRACE_H) || defined(_SYS_PTRACE_H) || defined(_SYS_PTRACE_H_)))
#define SYS_PTRACE_H   (1)
#define _SYS_PTRACE_H   (1)
#define _SYS_PTRACE_H_   (1)


/** Flag for `PTRACE_LISTEN` */
#define PTRACE_SEIZE_DEVEL   0x80000000

/** Arguments for `PTRACE_PEEKSIGINFO` */
struct __ptrace_peeksiginfo_args {
	uint64_t off;  //!< From which `siginfo` should start
	uint32_t flags;  //!< Flags for `peeksiginfo`
	int32_t nr;  //!< Number of `siginfos` to take
};

/** Read signals from a shared (process wide) queue */
enum __ptrace_peeksiginfo_flags { PTRACE_PEEKSIGINFO_SHARED = 1 };

/** @enum __ptrace_request
Type of the REQUEST argument to `ptrace` */
/** @enum __ptrace_setoptions
Options set using `PTRACE_SETOPTIONS` */
/** @enum __ptrace_eventcodes
Wait extended result codes for the above trace options */
#ifdef ARCHSPARC
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 11,
#   if IS_WORDSIZE_32
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 12,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 13,
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 14,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 15,
#   endif
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Write several bytes at a time */
	PTRACE_WRITEDATA = 17,
	/** Read several bytes at a time */
	PTRACE_READTEXT = 18,
	/** Write several bytes at a time */
	PTRACE_WRITETEXT = 19,
#   if IS_WORDSIZE_64
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 22,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 23,
#   endif
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
#   if IS_WORDSIZE_64
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 25,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 26,
#   endif
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208,
	PTRACE_PEEKSIGINFO = 0x4209
};
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_EXITKILL = 0x100000,
	PTRACE_O_MASK = 0x1000ff
};
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRACE_EVENT_SECCOMP = 7
};
#elif defined(ARCHITANIUM)
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Execute process until next taken branch */
	PTRACE_SINGLEBLOCK = 12,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 13,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 14,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Get all registers (pt_all_user_regs) in one shot */
	PTRACE_GETREGS = 18,
	/** Set all registers (pt_all_user_regs) in one shot */
	PTRACE_SETREGS = 19,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24
};
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};
#elif defined(ARCHMICROBLAZE)
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process */
	PTRACE_SINGLESTEP = 9,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24
};
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};
#elif defined(ARCHPOWERPC)
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208,
	PTRACE_PEEKSIGINFO = 0x4209
};
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_EXITKILL = 0x100000,
	PTRACE_O_MASK = 0x1000ff
};
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRACE_EVENT_SECCOMP = 7
};
#else
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 12,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 13,
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 14,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 15,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Get all extended floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPXREGS = 18,
	/** Set all extended floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPXREGS = 19,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208
};
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};
#endif


#define syscall_ptrace(request, pid, addr, data)   syscall4(SYS_ptrace, (long)(request), (long)(pid), (long)(addr), (long)(data))


/** Perform process tracing functions. `request` is one of the values above, and determines the action to be taken; For all requests except `PTRACE_TRACEME`, `pid` specifies the process to be traced */
LIB_FUNC long ptrace(const enum __ptrace_request request, ...) {
	va_list ap;
	va_start(ap, request);
	register pid_t pid = va_arg(ap, pid_t);
	void* addr = va_arg(ap, void*);
	void* data = va_arg(ap, void*);
	va_end(ap);
	long ret = 0;
	if (request > 0 && request < 4) { data = &ret; }
	const long res = (long)syscall_ptrace(request, pid, addr, data);
	if (res >= 0 && request > 0 && request < 4) { set_errno(0); return ret; }
	return res;
}


#endif  // SYS_PTRACE_H


/* THREAD-LOCAL DATA HANDLING (<sys/tls.h> & <tls.h>) */


#if (!(defined(TLS_H) || defined(_TLS_H) || defined(SYS_TLS_H_) || defined(_SYS_TLS_H_)))
#define TLS_H   (1)
#define _TLS_H   (1)
#define SYS_TLS_H_   (1)
#define SYS_TLS_H_   (1)
#define _SYS_TLS_H_   (1)
#define KERNEL_TLS_H   (1)
#define _KERNEL_TLS_H   (1)


/** Initial size for TLS inbuf, minimum prefix + linelength guaranteed to be accepted */
#define TLS_MIN_LINELENGTH   2053
/** Usually, the inbuf is enlarged as needed and then kept; if bigger than TLS_PERSIST_LINELENGTH, then shrink to TLS_LARGE_LINELENGTH immediately */
#define TLS_LARGE_LINELENGTH   8192
#define TLS_PERSIST_LINELENGTH   32768
/** Timeout to call non-blocking TLS operations again */
#define TLS_RETRY_EVENT_USEC   20000
/** Reconnect to lost server after n sec (initial value) */
#define TLS_RECONNECT_SEC   10
/** Backoff connection attempts */
#define TLS_RECONNECT_BACKOFF_FACTOR   (15 / 10)
#define TLS_RECONNECT_BACKOFF(x)   (x) = (x) * TLS_RECONNECT_BACKOFF_FACTOR
/** Abandon connection attempts after n seconds */
#define TLS_RECONNECT_GIVEUP   7200
/** Default algorithm for certificate fingerprints */
#define DEFAULT_FINGERPRINT_ALG   "sha-1"
/** Default X.509 certificate files */
#define DEFAULT_X509_CERTFILE   "/etc/openssl/default.crt"
/** Default X.509 key files */
#define DEFAULT_X509_KEYFILE   "/etc/openssl/default.key"
// Options for peer certificate verification
#define X509VERIFY_ALWAYS   0
#define X509VERIFY_IFPRESENT   1
#define X509VERIFY_NONE   2
// Attributes for self-generated keys/certificates
#define TLS_GENCERT_BITS   1024
#define TLS_GENCERT_SERIAL   1
#define TLS_GENCERT_DAYS   1825  // 5 years
// TLS connection states
#define ST_NONE   0
#define ST_TLS_EST   1
#define ST_TCP_EST   2
#define ST_CONNECTING   3
#define ST_ACCEPTING   4
#define ST_READING   5
#define ST_WRITING   6
#define ST_EOF   7
#define ST_CLOSING0   8
#define ST_CLOSING1   9
#define ST_CLOSING2   10
// Return values for TLS_examine_error()
/** No real problem, just ignore */
#define TLS_OK   0
/** Just retry, non-blocking operation not finished yet */
#define TLS_RETRY_READ   1
/** Just retry, non-blocking operation not finished yet */
#define TLS_RETRY_WRITE   2
/** Recoverable error condition, but try again */
#define TLS_TEMP_ERROR   4
/** Non-recoverable error condition, closed TLS and socket */
#define TLS_PERM_ERROR   8
/** Backlog for listen */
#define TLSBACKLOG   4
/** Close TLS connection after multiple 'soft' errors */
#define TLS_MAXERRORCOUNT   4
/** Maximum TLS keys allowed to store; the key is reserved process-wide; Note that tls_allocate() will return B_NO_MEMORY if you try to exceed this limit */
#define TLS_MAX_KEYS   (64)
#define TLS_SIZE   (TLS_MAX_KEYS * SIZEOF_POINTER)
#define SIZEOF_TLS   TLS_SIZE
#define BITS_PER_TLS   (TLS_SIZE * 8)
#define mtx_plain   (0)
#define mtx_recursive   (1)
#define mtx_timed   (2)
#define mtx_valid_mask   (3)
#define thrd_success   0
#define thrd_timeout   1
#define thrd_busy   2
#define thrd_error   3
#define thrd_nomem   4
#define TLS_BASE_ADDRESS_SLOT   (0)
#define TLS_THREAD_ID_SLOT   (1)
#define TLS_ERRNO_SLOT   (2)
#define TLS_ON_EXIT_THREAD_SLOT   (3)
#define TLS_USER_THREAD_SLOT   (4)
#define TLS_DYNAMIC_THREAD_VECTOR   (5)
#define TLS_FIRST_FREE_SLOT   (6)


/** Datatype for the dtv */
typedef union attr_packed dtv {
	size_t counter;
	struct attr_packed _dtv_pointer_s {
		void* val;
		bool is_static;
	} pointer;
} dtv_t;


typedef struct tcbhead_s { dtv_t* dtv; void* private; }   tcbhead_t;


#if (defined(__HAVE_TLS_VARIANT_I) || defined(__HAVE_TLS_VARIANT_II))
#   if (defined(__HAVE_TLS_VARIANT_I) && defined(__HAVE_TLS_VARIANT_II))
#      error   "Only one TLS variant can be supported at a time!"
#   endif
typedef struct tls_tcb {
#   ifdef __HAVE_TLS_VARIANT_I
	void** tcb_dtv;
	void* tcb_pthread;
#   else
	void* tcb_self;
	void** tcb_dtv;
	void* tcb_pthread;
#   endif
} tls_tcb_t;
#endif  // HAVE_TLS_VARIANT


typedef struct tls_module {
	struct tls_module* next;
	void* image;
	size_t len, size, align, offset;
} tls_module_t;


/* TODO: Add TLS functions
struct tls_tcb* _rtld_tls_allocate(void);
void _rtld_tls_free(struct tls_tcb *);
void _rtld_tls_static_setup(void);
char *init_global_TLS_CTX(void);
struct socketEvent *socksetup_tls(const int, const char *, const char *);
int check_peer_cert(int, X509_STORE_CTX *);
int accept_cert(const char* , struct tls_conn_settings *, char *, char *);
int deny_cert(struct tls_conn_settings *, char *, char *);
bool read_certfile(X509 **, const char *);
bool write_x509files(EVP_PKEY *, X509 *, const char *, const char *);
bool mk_x509_cert(X509 **, EVP_PKEY **, int, int, int);
bool x509_cert_add_subjectAltName(X509 *, X509V3_CTX *);
int tls_examine_error(const char *, const SSL *, struct tls_conn_settings *, const int);
bool get_fingerprint(const X509 *, char **, const char *);
bool get_commonname(X509 *, char **);
bool match_hostnames(X509 *, const char *, const char *);
bool match_fingerprint(const X509 *, const char *);
bool match_certfile(const X509 *, const char *);
bool parse_tls_destination(const char *, struct filed *, size_t);
void dispatch_socket_accept(int, short, void *);
void dispatch_tls_accept(int, short, void *);
void dispatch_tls_read(int, short, void *);
void dispatch_tls_send(int, short, void *);
void dispatch_tls_eof(int, short, void *);
void dispatch_SSL_connect(int, short, void *);
void dispatch_SSL_shutdown(int, short, void *);
void dispatch_force_tls_reconnect(int, short, void *);
bool tls_connect(struct tls_conn_settings *);
void tls_reconnect(int, short, void *);
bool tls_send(struct filed *, char *, size_t, struct buf_queue*);
void tls_split_messages(struct TLS_Incoming_Conn *);
void free_tls_conn(struct tls_conn_settings *);
void free_tls_sslptr(struct tls_conn_settings *);
void free_tls_send_msg(struct tls_send_msg *);
*/


#endif  // TLS_H


/* WIDE-CHARACTER & EXTENDED-MULTIBYTE HANDLING (<wchar.h>) */


#if (!(defined(_WCHAR_H) || defined(_WCHAR_H_) || defined(_WCHAR2_H_) || defined(_LIBC_WCHAR_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/wchar.h.html & http://www.cplusplus.com/reference/cwchar/
#define WCHAR_H   (1)
#define _WCHAR_H   (1)
#define _WCHAR_H_   (1)
#define _WCHAR2_H   (1)
#define _WCHAR2_H_   (1)
#define _LIBC_WCHAR_H_   (1)


#define btowc(c)   ((wint_t)((((int)(c)) == EOF) ? WEOF : (wint_t)(c)))


LIB_FUNC size_t wcsnlen(const wchar_t* s, size_t maxlen) {
	const wchar_t* ptr;
	for (ptr = s; maxlen > 0 && *ptr != (wchar_t)0; ptr++, maxlen--);
	return (size_t)(ptr - s);
}


/** Return the length of a wchar_t string */
LIB_FUNC unsigned int strlenW(const wchar_t* restrict wcstr) {
	const wchar_t* s = wcstr;
	while (*s) { ++s; }
	return (unsigned int)(s - wcstr);
}
#define wcstrlen(wcstr)   strlenW((wcstr))
#define _wcstrlen(wcstr)   strlenW((wcstr))
#define strlenw(wcstr)   strlenW((wcstr))
#define wstrlen(wcstr)   strlenW((wcstr))
#define Wstrlen(wcstr)   strlenW((wcstr))


/** Copy a wchar_t string */
LIB_FUNC wchar_t* strcpyW(wchar_t* restrict dst, const wchar_t* restrict src) {
	wchar_t* p = dst;
	while ((*p++ = *src++));
	return dst;
}
#define wccpy(dst, src)   strcpyW((dst), (src))
#define _wccpy(dst, src)   strcpyW((dst), (src))
#define strcpyw(dst, src)   strcpyW((dst), (src))
#define wstrcpy(dst, src)   strcpyW((dst), (src))
#define Wstrcpy(dst, src)   strcpyW((dst), (src))


LIB_FUNC wchar_t* strncpyW(wchar_t* restrict dest, const wchar_t* restrict src, const size_t n) {
	wchar_t* orig = dest;
	for (; dest < orig + n && (*dest = *src); ++src, ++dest);
	for (; dest < orig + n; ++dest) { *dest = 0; }
	return orig;
}
#define wcsncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define _wcsncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define strncpyw(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define wstrncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define Wstrncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))


LIB_FUNC int strcmpW(const wchar_t* restrict str1, const wchar_t* restrict str2) {
	while (*str1 && (*str1 == *str2)) { ++str1; ++str2; }
	return (int)(*str1 - *str2);
}
#define wcscmp(str1, str2)   strcmpW((str1), (str2))
#define _wcscmp(str1, str2)   strcmpW((str1), (str2))
#define strcmpw(str1, str2)   strcmpW((str1), (str2))
#define wstrcmp(str1, str2)   strcmpW((str1), (str2))
#define Wstrcmp(str1, str2)   strcmpW((str1), (str2))


LIB_FUNC int strncmpW(const wchar_t* restrict str1, const wchar_t* restrict str2, const int len) {
	if (len <= 0) { return 0; }
	register int maxlen = len;
	while ((--maxlen > 0) && *str1 && (*str1 == *str2)) { ++str1; ++str2; }
	return (int)(*str1 - *str2);
}
#define wcsncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define _wcsncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define strncmpw(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define wstrncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define Wstrncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))


LIB_FUNC wchar_t* strcatW(wchar_t* restrict dst, const wchar_t* restrict src) {
	return strcpyW(dst + strlenW(dst), src);
}
#define wccat(dst, src)   strcatW((dst), (src))
#define _wccat(dst, src)   strcatW((dst), (src))
#define wcscat(d, str)   strcatW((d), (str))
#define strcatw(dst, src)   strcatW((dst), (src))
#define wstrcat(dst, src)   strcatW((dst), (src))
#define Wstrcat(dst, src)   strcatW((dst), (src))


LIB_FUNC wchar_t* strchrW(const wchar_t* restrict wcstr, const wchar_t ch) {
	do { if (*wcstr == ch) { return (wchar_t*)(ULONG_PTR)wcstr; } } while (*wcstr++);
	return NULL;
}
#define wcschr(wcstr, ch)   strchrW((wcstr), (wchar_t)(ch))
#define _wcschr(wcstr, ch)   strchrW((wcstr), (wchar_t)(ch))
#define strchrw(wcstr, ch)   strchrW((wcstr), (wchar_t)(ch))
#define wstrchr(wcstr, ch)   strchrW((wcstr), (wchar_t)(ch))
#define Wstrchr(wcstr, ch)   strchrW((wcstr), (wchar_t)(ch))


LIB_FUNC wchar_t* strrchrW(const wchar_t* restrict wcstr, const wchar_t ch) {
	wchar_t* ret = NULL;
	do { if (*wcstr == ch) { ret = (wchar_t*)(ULONG_PTR)wcstr; } } while (*wcstr++);
	return ret;
}
#define wcsrchr(wcstr, c)   strrchrW((wcstr), (wchar_t)(c))
#define _wcsrchr(wcstr, c)   strrchrW((wcstr), (wchar_t)(c))
#define strrchrw(wcstr, c)   strrchrW((wcstr), (wchar_t)(c))
#define wstrrchr(wcstr, c)   strrchrW((wcstr), (wchar_t)(c))
#define Wstrrchr(wcstr, c)   strrchrW((wcstr), (wchar_t)(c))


LIB_FUNC wchar_t* strpbrkW(const wchar_t* restrict wcstr, const wchar_t* restrict accept) {
	for (; *wcstr; wcstr++) { if (strchrW(accept, *wcstr)) { return (wchar_t*)(ULONG_PTR)wcstr; } }
	return NULL;
}
#define wcspbrk(wcstr, accept)   strpbrkW((wcstr), (accept))
#define _wcspbrk(wcstr, accept)   strpbrkW((wcstr), (accept))
#define strpbrkw(wcstr, accept)   strpbrkW((wcstr), (accept))
#define wstrpbrk(wcstr, accept)   strpbrkW((wcstr), (accept))
#define Wstrpbrk(wcstr, accept)   strpbrkW((wcstr), (accept))


LIB_FUNC size_t strspnW(const wchar_t* restrict wcstr, const wchar_t* restrict accept) {
	const wchar_t* ptr = wcstr;
	for (; *ptr; ptr++) { if (!(strchrW(accept, *ptr))) { break; } }
	return (size_t)(ptr - wcstr);
}
#define wstrspn(wcstr, accept)   strspnW((wcstr), (accept))
#define Wstrspn(wcstr, accept)   strspnW((wcstr), (accept))
#define strspnw(wcstr, accept)   strspnW((wcstr), (accept))
#define wstrspn(wcstr, accept)   strspnW((wcstr), (accept))
#define Wstrspn(wcstr, accept)   strspnW((wcstr), (accept))


LIB_FUNC size_t strcspnW(const wchar_t* wcstr, const wchar_t* reject) {
	const wchar_t* ptr = wcstr;
	for (; *ptr; ptr++) { if (strchrW(reject, *ptr)) { break; } }
	return (size_t)(ptr - wcstr);
}
#define strcspnw(wcstr, reject)   strcspnW((wcstr), (reject))
#define wstrcspn(wcstr, reject)   strcspnW((wcstr), (reject))
#define Wstrcspn(wcstr, reject)   strcspnW((wcstr), (reject))


LIB_FUNC wchar_t* strlwrW(wchar_t* restrict str) {
	wchar_t* ret = str;
	while ((*str = (wchar_t)tolowerW(*str))) { ++str; }
	return ret;
}
#define wcslwr(str)   strlwrW((str))
#define _wcslwr(str)   strlwrW((str))
#define strlwrw(str)   strlwrW((str))
#define wstrlwr(str)   strlwrW((str))
#define Wstrlwr(str)   strlwrW((str))


LIB_FUNC wchar_t* struprW(wchar_t* restrict str) {
	wchar_t* ret = str;
	while ((*str = (wchar_t)toupperW(*str))) { ++str; }
	return ret;
}
#define struprw(str)   struprW((str))
#define wcsupr(str)   struprW((str))
#define _wcsupr(str)   struprW((str))


LIB_FUNC const wchar_t* memchrW(const wchar_t* restrict ptr, const wchar_t ch, const size_t len) {
	const wchar_t* end = (const wchar_t*)(ptr + len);
	for (; ptr < end; ptr++) { if (*ptr == ch) { return (const wchar_t*)ptr; } }
	return NULL;
}
#define memchrw(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memwchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memWchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define wmemchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define Wmemchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))


LIB_FUNC wchar_t* memrchrW(wchar_t* ptr, const wchar_t ch, const size_t len) {
	wchar_t *end, *ret = NULL;
	for (end = (ptr + len); ptr < end; ptr++) { if (*ptr == ch) { ret = ptr; } }
	return (wchar_t*)ret;
}
#define memrchrw(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memwrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memWrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define wmemrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define Wmemrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))


LIB_FUNC wchar_t* wmemmove(wchar_t* restrict dest, const wchar_t* restrict src, const size_t len) {
	wchar_t* d0 = dest;
	register size_t _len = len;
	if ((size_t)(dest - src) < _len) { while (_len--) { dest[_len] = src[_len]; } }
	else { while (_len--) { *dest++ = *src++; } }
	return d0;
}
#define memmoveW(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define memmove_W(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define memmovew(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define wmemmove(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define Wmemmove(dest, src, len)   wmemmove((dest), (src), (size_t)(len))


LIB_FUNC float wcstof(const wchar_t* restrict nptr, const wchar_t** restrict endptr) {
	return (float)strtof((const char*)(nptr), (const char**)(endptr));
}
#define _wcstof(nptr, endptr)   wcstof((nptr), (endptr))
#define strtofW(nptr, endptr)   wcstof((nptr), (endptr))
#define strtofw(nptr, endptr)   wcstof((nptr), (endptr))
#define wstrtof(nptr, endptr)   wcstof((nptr), (endptr))
#define Wstrtof(nptr, endptr)   wcstof((nptr), (endptr))


LIB_FUNC double wcstod(const wchar_t* restrict nptr, const wchar_t** restrict endptr) {
	return (double)strtod((const char*)(nptr), (const char**)(endptr));
}
#define _wcstod(nptr, endptr)   wcstod((nptr), (endptr))
#define strtodW(nptr, endptr)   wcstod((nptr), (endptr))
#define strtodw(nptr, endptr)   wcstod((nptr), (endptr))
#define wstrtod(nptr, endptr)   wcstod((nptr), (endptr))
#define Wstrtod(nptr, endptr)   wcstod((nptr), (endptr))


LIB_FUNC long wcstol(const wchar_t* restrict nptr, const wchar_t** endptr, const int base) {
	return (long)strtol((const char*)(nptr), (const char**)(endptr), base);
}
#define _wcstol(str, e, b)   wcstol((str), (e), (int)(b))
#define strtolW(str, e, b)   wcstol((str), (e), (int)(b))
#define strtolw(str, e, b)   wcstol((str), (e), (int)(b))
#define wstrtol(str, e, b)   wcstol((str), (e), (int)(b))
#define Wstrtol(str, e, b)   wcstol((str), (e), (int)(b))


LIB_FUNC unsigned long wcstoul(const wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (unsigned long)strtoul((const char*)(nptr), (const char**)(endptr), base);
}
#define _wcstoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define strtoulW(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define strtoulw(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define wstrtoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define Wstrtoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))


/** Like `wcstol` but convert to `intmax_t` */
LIB_FUNC intmax_t wcstoimax(wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (intmax_t)wcstoll(nptr, endptr, base);
}


/** Like `wcstoul` but convert to `uintmax_t` */
LIB_FUNC uintmax_t wcstoumax(wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (uintmax_t)wcstox(nptr, endptr, base, ULLONG_MAX);
}


LIB_FUNC long atolW(const wchar_t* restrict str) {
	return (long)wcstol(str, (const wchar_t**)0, 10);
}
#define atolw(str)   atolW((str))
#define __atolw(str)   atolW((str))
#define __atolW(str)   atolW((str))
#define wtol(str)   atolW((str))
#define _wtol(str)   atolW((str))


LIB_FUNC int atoiW(const wchar_t* restrict str) {
	return (int)wcstol(str, (const wchar_t**)0, 10);
}
#define atoiw(str)   atoiW((str))
#define __atoiw(str)   atoiW((str))
#define __atoiW(str)   atoiW((str))
#define wtoi(str)   atoiW((str))
#define _wtoi(str)   atoiW((str))


LIB_FUNC int wcwidth(const wchar_t wc) {
	if (wc < (wchar_t)0xffU) { return ((((wc + 1) & 0x7f) >= 0x21) ? 1 : (wc ? -1 : 0)); }
	else if ((wc & (wchar_t)0xfffeffffU) < (wchar_t)0xfffe) {
		if ((nonspacing_table[(unsigned int)(nonspacing_table[wc >> 8] * 32) + (unsigned int)((wc & 255) >> 3)] >> (wc & 7)) & 1) { return 0; }
		else if ((wide_table[(unsigned int)(wide_table[wc >> 8] * 32) + (unsigned int)((wc & 255) >> 3)] >> (wc & 7)) & 1) { return 2; }
		return 1;
	}
	if ((wc & (wchar_t)0xfffe) == (wchar_t)0xfffe) { return -1; }
	else if ((wc - (wchar_t)0x20000U) < (wchar_t)0x20000) { return 2; }
	else if (wc == (wchar_t)0xe0001 || ((wc - (wchar_t)0xe0020U) < (wchar_t)0x5f) || ((wc - (wchar_t)0xe0100) < (wchar_t)0xef)) { return 0; }
	return 1;
}


LIB_FUNC int wcswidth(const wchar_t* restrict wcs, const size_t len) {
	register int l = 0, k = 0;
	register size_t n = len;
	for (; n-- && *wcs && (k = (int)wcwidth(*wcs)) >= 0; l += k, ++wcs);
	return ((k < 0) ? k : l);
}


LIB_FUNC const wchar_t* wcswcs(const wchar_t* restrict ws1, const wchar_t* restrict ws2) {
	const char* s1 = (const char*)(ws1);
	const char* s2 = (const char*)(ws2);
	return (const wchar_t*)(strstr(s1, s2));
}


LIB_FUNC int wcsicmp(const wchar_t* restrict cs, const wchar_t* restrict ct) {
	while (towlower(*cs) == towlower(*ct)) {
		if (*cs == 0) { return 0; }
		++cs;
		++ct;
	}
	return (int)(towlower(*cs) - towlower(*ct));
}
#define _wcsicmp(str1, str2)   wcsicmp((str1), (str2))
#define strcmpiW(str1, str2)   wcsicmp((str1), (str2))
#define strcmpiw(str1, str2)   wcsicmp((str1), (str2))
#define wstrcmpi(str1, str2)   wcsicmp((str1), (str2))
#define Wstrcmpi(str1, str2)   wcsicmp((str1), (str2))


LIB_FUNC wchar_t* wcsstr(wchar_t* s, wchar_t* b) {
	wchar_t *x, *y, *c;
	x = (wchar_t*)s;
	while (*x) {
		if (*x == *b) {
			y = x;
			c = (wchar_t*)b;
			while (*y && *c && *y == *c) { ++c; ++y; }
			if (!*c) { return x; }
		}
		++x;
	}
	return NULL;
}
#define strstrW(d, str)   wcsstr((d), (str))
#define _strstrW(d, str)   wcsstr((d), (str))
#define strstrw(d, str)   wcsstr((d), (str))
#define _strstrw(d, str)   wcsstr((d), (str))
#define _wcsstr(d, str)   wcsstr((d), (str))
#define wstrstr(d, str)   wcsstr((d), (str))
#define Wstrstr(d, str)   wcsstr((d), (str))


LIB_FUNC size_t wcsspn(const wchar_t* str, const wchar_t* accept) {
	const wchar_t *s, *t;
	s = str;
	do {
		t = accept;
		while (*t) { if (*t == *s) { break; } ++t; }
		if (!*t) { break; }
		++s;
	} while (*s);
	return (size_t)(s - str);
}
#define _wcsspn(str, accept)   wcsspn((str), (accept))


LIB_FUNC size_t wcscspn(wchar_t* restrict str, wchar_t* restrict reject) {
	wchar_t *s, *t;
	s = (wchar_t*)str;
	while (*s) {
		t = (wchar_t*)reject;
		while (*t) { if (*t == *s) { break; } ++t; }
		if (*t) { break; }
		++s;
	}
	return (size_t)(s - str);
}
#define _wcscspn(d, str)   wcscspn((d), (str))


LIB_FUNC size_t wcsxfrm(wchar_t* restrict dst, const wchar_t* restrict src, const size_t len) {
	register size_t r = 0, _len = len;
	register int c;
	if (_len != 0) {
		while ((c = *src++) != 0) {
			++r;
			if (--_len == 0) { while (*src++ != 0) { ++r; } break; }
			*dst++ = c;
		}
		*dst = 0;
	}
	return r;
}


LIB_FUNC size_t wcrtomb(char* restrict s, wchar_t wc, const UNUSED mbstate_t* restrict st) {
	if (!s) { return 1; }
	else if ((unsigned)wc < 0x80) {
		*s = (char)wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
		if ((!IS_CODEUNIT(wc))) {
			set_errno(EILSEQ);
			return (size_t)-1;
		}
		*s = (char)wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
		*s++ = (char)(0xc0 | (wc >> 6));
		*s = (char)(0x80 | (wc & 0x3f));
		return 2;
	} else if ((unsigned)wc < 0xd800 || (((unsigned)wc - 0xe000) < 0x2000)) {
		*s++ = (char)(0xe0 | (wc >> 12));
		*s++ = (char)(0x80 | ((wc >> 6) & 0x3f));
		*s = (char)(0x80 | (wc & 0x3f));
		return 3;
	} else if (((unsigned)wc - 0x10000) < 0x100000) {
		*s++ = (char)(0xf0 | (wc >> 18));
		*s++ = (char)(0x80 | ((wc >> 12) & 0x3f));
		*s++ = (char)(0x80 | ((wc >> 6) & 0x3f));
		*s = (char)(0x80 | (wc & 0x3f));
		return 4;
	}
	set_errno(EILSEQ);
	return (size_t)-1;
}


LIB_FUNC int wctomb(char* s, wchar_t wchar) {
	static mbstate_t mbs;
	register size_t rval;
	if (s == NULL) {
		memset_no_output(&mbs, 0, SIZEOF_MBSTATE_T);
		return 0;
	} else if ((rval = wcrtomb(s, wchar, &mbs)) == (size_t)-1) { return -1; }
	return ((int)rval);
}


/** Convert the wchar to a uppercase wide ASCII letter */
LIB_FUNC wchar_t towcase(const wchar_t wc, const int lower) {
	if (!iswalpha((wint_t)wc) || ((unsigned)wc - 0x600) <= (0xfff - 0x600) || ((unsigned)wc - 0x2e00) <= (0xa63f - 0x2e00) || ((unsigned)wc - 0xa800) <= (0xfeff - 0xa800)) { return wc; }
	if (lower && (((unsigned)wc - 0x10a0) < 0x2e)) {
		if (wc > 0x10c5 && wc != 0x10c7 && wc != 0x10cd) { return wc; }
		else { return (wc + 0x2d00 - 0x10a0); }
	} else if (!lower && (((unsigned)wc - 0x2d00) < 0x26)) {
		if (wc > 0x2d25 && wc != 0x2d27 && wc != 0x2d2d) { return wc; }
		else { return (wchar_t)(wc + 0x10a0 - 0x2d00); }
	}
	const int lmul = ((lower + lower) - 1);
	const int lmask = (lower - 1);
	register int i;
	for (i = 0; wchar_casemaps[i].len; i++) {
		int base = wchar_casemaps[i].upper + (lmask & wchar_casemaps[i].lower);
		if (((unsigned)wc - (unsigned)base) < wchar_casemaps[i].len) {
			if (wchar_casemaps[i].lower == 1) { return (wchar_t)(wc + lower - ((wc - wchar_casemaps[i].upper) & 1)); }
			return (wc + (lmul * wchar_casemaps[i].lower));
		}
	}
	for (i = 0; wchar_pairs[i][1 - lower]; i++) {
		if (wchar_pairs[i][1 - lower] == wc) { return wchar_pairs[i][lower]; }
	}
	if (((unsigned)wc - (unsigned)(0x10428 - (0x28 * lower))) < 0x28) { return (wc - 0x28 + (0x50 * lower)); }
	return wc;
}
#define _towcase(wc, lower)   towcase((wc), (int)(lower))
#define __towcase(wc, lower)   towcase((wc), (int)(lower))


/** Returns a value of type wctrans_t that corresponds to the character transformation by property */
LIB_FUNC wctrans_t wctrans(const char* restrict property) {
	if (!(strcmp(property, "toupper"))) { return (wctrans_t)1; }
	else if (!(strcmp(property, "tolower"))) { return (wctrans_t)2; }
	return (wctrans_t)0;
}
#define __wctrans(property)   wctrans((property))


/** Returns a value of type wctrans_t that corresponds to the character transformation by property */
LIB_FUNC wctrans_t wctrans_l(const char* restrict property, const UNUSED locale_t l) {
	return wctrans(property);
}
#define __wctrans_l(property, l)   wctrans_l((property), (l))


/** Applies a the transformation specified by `trans` to the wide character `wc` */
LIB_FUNC wint_t towctrans(const wint_t wc, const wctrans_t trans) {
	switch ((int)*trans) {
		case 1: return (wint_t)towupper(wc);
		case 2: return (wint_t)towlower(wc);
		default: return (wint_t)wc;
	}
	UNREACHABLE
}
#define _towctrans(wc, trans)   towctrans((wc), (trans))
#define __towctrans(wc, trans)   towctrans((wc), (trans))


/** Applies a the transformation specified by `trans` to the wide character `wc` */
LIB_FUNC wint_t towctrans_l(const wint_t wc, const wctrans_t trans, const UNUSED locale_t l) {
	return towctrans(wc, trans);
}
#define _towctrans_l(wc, trans, l)   towctrans_l((wc), (trans), (l))
#define __towctrans_l(wc, trans, l)   towctrans_l((wc), (trans), (l))


LIB_FUNC int mbsinit(const mbstate_t* restrict st) {
	return (!st || !*(const unsigned*)st);
}


LIB_FUNC size_t mbrtowc(wchar_t* restrict pwc, const char* s, const size_t len, const UNUSED mbstate_t* ps) {
	if (s == NULL) { s = ""; pwc = NULL; }
	else if (len == 0 && pwc) { *pwc = 0; return 0; }
	if (pwc) { *pwc = *s; }
	return (*s != 0);
}


LIB_FUNC int mbtowc(wchar_t* restrict pwc, const char* s, const size_t n) {
	return (int)mbrtowc(pwc, s, n, NULL);
}


LIB_FUNC size_t mbsrtowcs(wchar_t* dst, const char** src, const size_t len, const UNUSED mbstate_t* ps) {
	const char* s = *src;
	const char* s2 = (const char*)(memchr(s, 0, len));
	register size_t _len = len;
	if (s2 != NULL) { _len = (size_t)(s2 - s) + 1U; }
	if (dst) { dst = (wchar_t*)memcpy((char*)(dst), s, _len ); }
	*src = s + _len;
	return _len;
}


LIB_FUNC size_t mbstowcs(wchar_t* dst, const char* src, const size_t len) {
	return mbsrtowcs(dst, &src, len, NULL);
}


DIAG_PUSH
IGNORE_WFORMAT_NONLITERAL


/** Format time as wide string */
LIB_FUNC size_t wcsftime(wchar_t* wcs, size_t maxsize, const wchar_t* format,  const struct tm* timptr) {
	return strftime((char*)(wcs), maxsize, (const char*)(format), timptr);
}


DIAG_POP


LIB_FUNC size_t wcsrtombs(char* dst, const wchar_t** src, const size_t len, const UNUSED mbstate_t* ps) {
	const char* s = (const char*)(*src);
	register size_t _len = len;
	const char* s2 = (const char*)(memchr(s, 0, _len));
	if (s2 != NULL) { _len = (size_t)((s2 - s) + 1); }
	if (dst != NULL) { dst = (char*)memcpy(dst, s, _len); }
	*src = (const wchar_t*)(s + _len);
	return _len;
}


LIB_FUNC size_t wcstombs(char* dst, const wchar_t* src, const size_t len) {
	return wcsrtombs(dst, &src, len, NULL);
}


LIB_FUNC int wctob(const wint_t wc) {
	char buf[64];
	if (!(MB_CUR_MAX <= sizeof(buf))) { abort(); }
	else if ((wc > (wint_t)0) && wctomb(buf, (wchar_t)wc) == 1) { return (unsigned char) buf[0]; }
	return EOF;
}


LIB_FUNC long double wcstox_l(wchar_t* wcstr, wchar_t** p, const int prec) {
	wchar_t* t = wcstr;
	unsigned char buf[64] = { 0 };
	FILE fp = { 0 };
	fp.flags = 0;
	fp.rpos = fp.rend = 0;
	fp.buf = buf + 4;
	fp.buf_size = (sizeof(buf) - 4);
	fp.lock = -1;
	fp.read = do_read_helper;
	while (iswspace(*t)) { t++; }
	fp.wbuf = (wchar_t*)t;
	shlim(&fp, 0);
	const long double y = __floatscan(&fp, prec, 1);
	if (p) { const size_t cnt = (size_t)shcnt(&fp); *p = (cnt ? t + cnt : (wchar_t*)wcstr); }
	return y;
}


LIB_FUNC unsigned long long wcstox(wchar_t* wcstr, const wchar_t** p, const int base, const unsigned long long lim) {
	wchar_t* t = wcstr;
	unsigned char buf[64] = { 0 };
	FILE fp = { 0 };
	fp.flags = 0;
	fp.rpos = fp.rend = 0;
	fp.buf = buf + 4;
	fp.buf_size = (sizeof(buf) - 4);
	fp.lock = -1;
	fp.read = do_read_helper;
	while (iswspace(*t)) { t++; }
	fp.wbuf = (wchar_t*)t;
	shlim(&fp, 0);
	const unsigned long long y = intscan(&fp, (unsigned int)base, 1, lim);
	if (p) { const size_t cnt = (size_t)shcnt(&fp); *p = (cnt ? t + cnt : (wchar_t*)wcstr); }
	return y;
}


LIB_FUNC long double wcstold(wchar_t* restrict wcstr, wchar_t** restrict p) {
	return (long double)wcstox_l(wcstr, p, 2);
}


LIB_FUNC unsigned long long wcstoull(wchar_t* restrict wcstr, const wchar_t** restrict p, const int base) {
	return (unsigned long long)wcstox(wcstr, p, base, ULLONG_MAX);
}


LIB_FUNC long long wcstoll(wchar_t* restrict wcstr, const wchar_t** restrict p, const int base) {
	return (long long)wcstox(wcstr, p, base, (unsigned long long)LLONG_MIN);
}


LIB_FUNC int mblen(const char* str, const size_t len) {
	return mbtowc(0, str, len);
}


LIB_FUNC size_t mbrlen(const char* restrict str, const size_t len, mbstate_t* restrict _state) {
	static unsigned internal;
	return mbrtowc(0, str, len, _state ? _state : (mbstate_t*)&internal);
}


/** Read wide character from file stream */
LIB_FUNC wint_t getwc(FILE* fp) {
	return (wint_t)((fp)->rpos < (fp)->rend && *(fp)->rpos < 128 ? *(fp)->rpos++ : getc(fp));
}
#define fgetwc(fp)   getwc((fp))


/** Read wide character from STDIN */
LIB_FUNC wint_t getwchar(void) {
	return getwc(stdin);
}
#define getwchar_unlocked()   getwchar()
#define fgetwc_unlocked()   getwchar()


LIB_FUNC wchar_t* fgetws(wchar_t* wcstr, const int num, FILE* fp) {
	return (wchar_t*)(fgets((char*)(wcstr), num, fp));
}


/** Write wide character to stream */
LIB_FUNC wint_t fputwc(const wchar_t wc, FILE* fp) {
	FLOCK(fp);
	register const wint_t ret = (wint_t)fp->write(fp, (const unsigned char*)&wc, SIZEOF_WCHAR_T);
	FUNLOCK(fp);
	if (ret) { return ret; }
	return WEOF;
}
#define putwc(wc, fp)    fputwc((wc), (fp))
#define __fputwc_unlock(wc, fp)    fputwc((wc), (fp))
#define putwchar(wc)   fputwc((wc), (stdout))
#define putwchar_unlocked(wc)   fputwc((wc), (stdout))
#define _IO_putwc_unlocked(wc)   fputwc((wc), (stdout))
#define fputwc_unlocked(wc)   fputwc((wc), (stdout))


LIB_FUNC wint_t fputwc_lite(const wchar_t wc, FILE* fp) {
	return (wint_t)(fputc((char)(wc), fp));
}


/** Writes the wide-string to the specified file */
LIB_FUNC int fputws(const wchar_t* restrict str, FILE* restrict fp) {
	return fputs((const char*)(str), fp );
}
#define putws(str)   fputws((str), stdout)


LIB_FUNC wint_t ungetwc(wint_t wc, FILE* fp) {
	return (wint_t)ungetc((int)(wc), fp);
}


LIB_FUNC size_t wstring_read(FILE* fp, unsigned char* buf, const size_t len) {
	if (!fp->buf) { return 0; }
	const wchar_t* src = (const wchar_t*)&fp->buf;
	const size_t k = wcsrtombs((void*)fp->buf, &src, fp->buf_size, 0);
	if (k == (size_t)-1) { fp->rpos = fp->rend = 0; return 0; }
	fp->rpos = fp->buf;
	fp->rend = fp->buf + k;
	if (!len || !k) { return 0; }
	*buf = *fp->rpos++;
	return 1;
}


LIB_FUNC size_t wstring_read_helper(void* fp, unsigned char* buf, const size_t len) {
	return wstring_read((FILE*)fp, buf, len);
}


LIB_FUNC int in_set(const wchar_t* set, const int c) {
	const wchar_t* p = set;
	if (*p == '-') {
		if (c == '-') { return 1; }
		++p;
	} else if (*p == ']') {
		if (c == ']') { return 1; }
		++p;
	}
	register int j;
	for (; *p && *p != ']'; p++) {
		if (*p == '-' && p[1] && p[1] != ']') {
			for (j = p++[-1]; j < *p; j++) { if (c == j) { return 1; } }
		}
		if (c == *p) { return 1; }
	}
	return 0;
}


DIAG_PUSH
IGNORE_WFORMAT_NONLITERAL


/** Reads data from the stream and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vfwscanf(FILE* restrict fp, const wchar_t* restrict fmt, va_list ap) {
	const wchar_t* p;
	char* s = 0;
	wchar_t* wcs = 0;
	void* dest = NULL;
	off_t pos = 0, cnt;
	const char size_pfx[8][4] = { "hh", "h", "", "l", "L", "ll" };
	char tmp[106] = { 0 };
	const wchar_t* set;
	size_t i, k;
	FLOCK(fp);
	fwide(fp, _O_WIDE);
	int alloc, width, size, c, t, invert, matches = 0;
	for (p = fmt; *p; p++) {
		alloc = 0;
		if (iswspace(*p)) {
			while (iswspace(p[1])) { ++p; }
			while (iswspace((c = (int)getwc(fp)))) { ++pos; }
			ungetwc((wint_t)c, fp);
			continue;
		} else if (*p != '%' || p[1] == '%') {
			p += *p == '%';
			c = (int)getwc(fp);
			if (c != *p) {
				ungetwc((wint_t)c, fp);
				if (c < 0) { goto goto_vfwscanf_general_fail; }
				goto goto_match_fail;
			}
			++pos;
			continue;
		}
		++p;
		if (*p == '*') { dest = 0; p++; }
		else if (iswdigit(*p) && p[1]=='$') { dest = arg_n(ap, (unsigned int)(*p - '0')); p += 2; }
		else { dest = va_arg(ap, void*); }
		for (width = 0; iswdigit(*p); p++) { width = 10 * width + *p - '0'; }
		if (*p == 'm') {
			wcs = 0;
			s = 0;
			alloc = !!dest;
			p++;
		} else { alloc = 0; }
		size = SIZE_def;
		switch (*p++) {
			case 'h':
				if (*p == 'h') { ++p; size = SIZE_hh; }
				else { size = SIZE_h; }
				break;
			case 'l':
				if (*p == 'l') { ++p; size = SIZE_ll; }
				else { size = SIZE_l; }
				break;
			case 'j':
				size = SIZE_ll;
				break;
			case 'z':
			case 't':
				size = SIZE_l;
				break;
			case 'L':
				size = SIZE_L;
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 's':
			case 'c':
			case '[':
			case 'S':
			case 'C':
			case 'p':
			case 'n':
				--p;
				break;
			default: goto goto_vfwscanf_general_fail;
		}
		t = *p;
		if ((t & 0x2f) == 3) { size = SIZE_l; t |= 32; }
		if (t != 'n') {
			if (t != '[' && (t | 32) != 'c') { while (iswspace((c = (int)getwc(fp)))) { ++pos; } }
			else { c = (int)getwc(fp); }
			if (c < 0) { goto goto_vfwscanf_general_fail; }
			ungetwc((wint_t)c, fp);
		}
		register int gotmatch = 0;
		switch (t) {
			case 'n':
				store_int(dest, size, (unsigned long long)pos);
				continue;
			case 's':
			case 'c':
			case '[':
				if (t == 'c') {
					if (width < 1) { width = 1; }
					invert = 1;
					set = L"";
				} else if (t == 's') {
					invert = 1;
					set = (const wchar_t[22]) { ' ', '\t', '\n', '\r', 11, 12, 0x85, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2008, 0x2009, 0x200a, 0x2028, 0x2029, 0x205f, 0x3000, 0 };
				} else {
					if (*++p == '^') { ++p; invert = 1; }
					else { invert = 0; }
					set = p;
					if (*p == ']') { ++p; }
					while (*p != ']') {
						if (!*p) { goto goto_vfwscanf_general_fail; }
						p++;
					}
				}
				s = ((size == SIZE_def) ? dest : 0);
				wcs = ((size == SIZE_l) ? dest : 0);
				if (width < 1) { width = -1; }
				i = 0;
				if (alloc) {
					k = (size_t)((t == 'c') ? width + 1 : 31);
					if (size == SIZE_l) {
						wcs = malloc(k * SIZEOF_WCHAR_T);
						if (!wcs) { goto goto_vfwscanf_general_fail; }
					} else {
						s = malloc(k);
						if (!s) { goto goto_vfwscanf_general_fail; }
					}
				}
				while (width) {
					if ((c = (int)getwc(fp)) < 0) { break; }
					else if (in_set(set, c) == invert) { break; }
					else if (wcs) {
						wcs[i++] = c;
						if (alloc && i == k) {
							k += (k + 1);
							wchar_t* tmp = realloc(wcs, k * SIZEOF_WCHAR_T);
							if (!tmp) { goto goto_vfwscanf_general_fail; }
							wcs = tmp;
						}
					} else if (size != SIZE_l) {
						int l = wctomb(s ? s + i : tmp, c);
						if (l < 0) { goto goto_vfwscanf_general_fail; }
						i += (size_t)l;
						if (alloc && i > k - 4) {
							k += (k + 1);
							char* tmp = realloc(s, k);
							if (!tmp) { goto goto_vfwscanf_general_fail; }
							s = tmp;
						}
					}
					++pos;
					width -= (width > 0);
					gotmatch = 1;
				}
				if (width) {
					ungetwc((wint_t)c, fp);
					if (t == 'c' || (!gotmatch)) { goto goto_match_fail; }
				}
				if (alloc) {
					if (size == SIZE_l) { *(wchar_t**)dest = wcs; }
					else { *(char**)dest = s; }
				}
				if (t != 'c') {
					if (wcs) { wcs[i] = 0; }
					if (s) { s[i] = 0; }
				}
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 'p':
				if (width < 1) { width = 0; }
				snprintf(tmp, sizeof(tmp), "%.*s%.0d%s%c%%lln", 1 + (!dest), "%*", width, size_pfx[size + 2], t);
				cnt = 0;
				if (fscanf(fp, tmp, (dest ? dest : &cnt), &cnt) == -1) { goto goto_vfwscanf_general_fail; }
				else if (!cnt) { goto goto_match_fail; }
				pos += cnt;
				break;
			default: goto goto_vfwscanf_general_fail;
		}
		if (dest) { ++matches; }
	}
	if (0) {
goto_vfwscanf_general_fail:
		if (!matches) { --matches; }
goto_match_fail:
		if (alloc) { free(s); free(wcs); }
	}
	FUNLOCK(fp);
	return matches;
}
#define __isoc99_vfwscanf(fp, fmt, ap)   vfwscanf((fp), (fmt), (ap))
#define isoc99_vfwscanf(fp, fmt, ap)   vfwscanf((fp), (fmt), (ap))


DIAG_POP


/** Reads data from the stream and stores them according to the C wide string format into the locations pointed by the additional arguments */
LIB_FUNC int fwscanf(FILE* restrict fp, const wchar_t* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	const int ret = vfwscanf(fp, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_fwscanf(fp, fmt, ...)   fwscanf((fp), (fmt), (__VA_ARGS__))
#define isoc99_fwscanf(fp, fmt, ...)   fwscanf((fp), (fmt), (__VA_ARGS__))


/** Reads data from ws and stores them according to parameter format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vswscanf(wchar_t* restrict wcstr, const wchar_t* restrict fmt, va_list ap) {
	unsigned char buf[256] = { 0 };
	FILE fp = {
		.buf = buf,
		.buf_size = sizeof(buf),
		.wbuf = wcstr,
		.wbuf_size = strlenw(wcstr),
		.read = wstring_read_helper,
		.lock = -1
	};
	return vfwscanf(&fp, fmt, ap);
}
#define __isoc99_vswscanf(wcstr, fmt, ap)   vswscanf((wcstr), (fmt), (ap))
#define isoc99_vswscanf(wcstr, fmt, ap)   vswscanf((wcstr), (fmt), (ap))


/** Reads data from the wide string `wcstr` and stores them according to parameter format into the locations given by the additional arguments, as if wscanf was used, but reading from `wcstr` instead of the standard input (stdin) */
LIB_FUNC int swscanf(wchar_t* restrict wcstr, const wchar_t* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	const int ret = vswscanf(wcstr, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_swscanf(wcstr, fmt, ...)   swscanf((wcstr), (fmt), (__VA_ARGS__))
#define isoc99_swscanf(wcstr, fmt, ...)   swscanf((wcstr), (fmt), (__VA_ARGS__))


/** Reads data from the standard input (stdin) and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vwscanf(const wchar_t* restrict fmt, va_list ap) {
	return vfwscanf(stdin, fmt, ap);
}
#define __isoc99_vwscanf(fmt, ap)   vwscanf((fmt), (ap))
#define isoc99_vwscanf(fmt, ap)   vwscanf((fmt), (ap))


/** Reads data from stdin and stores them according to the C wide string format into the locations pointed by the additional arguments */
LIB_FUNC int wscanf(const wchar_t* format, ... ) {
	va_list args;
	va_start(args, format);
	const int result = fwscanf(stdout, format, args );
	va_end(args);
	return result;
}
#define __isoc99_wscanf(fmt, ...)   vwscanf((fmt), (__VA_ARGS__))
#define isoc99_wscanf(fmt, ...)   vwscanf((fmt), (__VA_ARGS__))


/** Write some memory regions; Return zero on success, or `EOF` on error */
LIB_FUNC int sfvwrite(FILE* fp, struct __suio* uio) {
	if ((int)uio->uio_resid == 0) { return 0; }
	else if (cantwrite(fp)) {
		set_errno(EBADF);
		return EOF;
	}
	int s, nlknown, nldist;
	size_t w;
	char* nl;
	struct __siov* iov;
	iov = uio->uio_iov;
	char* p = iov->iov_base;
	size_t len = iov->iov_len;
	++iov;
	if (fp->flags & (unsigned int)__SNBF) {  // Unbuffered: Write up to BUFSIZ bytes at a time
		do {
			while (len == 0) {
				p = iov->iov_base;
				len = iov->iov_len;
				iov++;
			}
			w = (size_t)(*fp->write)(fp, (unsigned char*)p, (size_t)MIN(len, (size_t)BUFSIZ));
			if (w <= 0) { goto goto_sfvwrite_err; }
			p += w;
			len -= w;
		} while ((uio->uio_resid -= (int)w) != 0);
	} else if ((fp->flags & (unsigned int)__SLBF) == 0) {  // Fully buffered
		do {
			while (len == 0) {
				p = iov->iov_base;
				len = iov->iov_len;
				iov++;
			}
			if ((fp->flags & (unsigned int)(__SALC | __SSTR)) == (__SALC | __SSTR) && (size_t)fp->wspace < len) {
				const size_t blen = (size_t)(fp->rpos - fp->buf);
				unsigned char* _base;
				size_t _size = fp->buf_size;
				do { _size = (_size << 1) + 1; } while (_size < (size_t)(blen + len));
				_base = realloc(fp->buf, (size_t)(_size + 1));
				if (_base == NULL) { goto goto_sfvwrite_err; }
				fp->wspace += (int)(_size - fp->buf_size);
				fp->buf = _base;
				fp->buf_size = _size;
				fp->rpos = _base + blen;
			}
			w = (size_t)fp->wspace;
			if (fp->flags & (unsigned int)__SSTR) {
				if (len < w) { w = len; }
				COPY(fp, p, w);
				fp->wspace -= (int)w;
				fp->rpos += (int)w;
				w = len;
			} else if (fp->rpos > fp->buf && len > w) {
				COPY(fp, p, w);
				fp->rpos += (int)w;
				if (sflush(fp)) { goto goto_sfvwrite_err; }
			} else if (len >= (w = fp->buf_size)) {
				w = (size_t)(*fp->write)(fp, (unsigned char*)p, w);
				if (w <= 0) { goto goto_sfvwrite_err; }
			} else {
				w = len;
				COPY(fp, p, w);
				fp->wspace -= (int)w;
				fp->rpos += (int)w;
			}
			p += (int)w;
			len -= w;
		} while ((uio->uio_resid -= (int)w) != 0);
	} else {  // Line buffered: like fully buffered, but check for newlines
		nlknown = 0;
		nldist = 0;
		do {
			while (len == 0) {
				nlknown = 0;
				p = iov->iov_base;
				len = iov->iov_len;
				iov++;
			}
			if (!nlknown) {
				nl = memchr_nonconst((void*)p, '\n', len);
				nldist = (int)(nl ? (int)(nl + 1 - p) : (int)(len + 1));
				nlknown = 1;
			}
			s = (int)MIN((int)len, nldist);
			w = (size_t)((size_t)fp->wspace + fp->buf_size);
			if ((fp->rpos > fp->buf) && (s > (int)w)) {
				COPY(fp, p, w);
				fp->rpos += (int)w;
				if (sflush(fp)) { goto goto_sfvwrite_err; }
			} else if (s >= (int)(w = fp->buf_size)) {
				w = (size_t)(*fp->write)(fp, (unsigned char*)p, w);
				if (w <= 0) { goto goto_sfvwrite_err; }
			} else {
				w = (size_t)s;
				COPY(fp, p, w);
				fp->wspace -= (int)w;
				fp->rpos += (int)w;
			}
			if ((nldist -= (int)w) == 0) {
				if (sflush(fp)) { goto goto_sfvwrite_err; }
				nlknown = 0;
			}
			p += (int)w;
			len -= w;
		} while ((uio->uio_resid -= (int)w) != 0);
	}
	return 0;
goto_sfvwrite_err:
	fp->flags |= (unsigned int)__SERR;
	return EOF;
}
#define __sfvwrite(fp, uio)   sfvwrite((fp), (uio))


LIB_FUNC void pop_arg(union printf_arg* arg, const int type, va_list* ap) {
	if ((unsigned)type > PRINTF_MAXSTATE) { return; }
	switch (type) {
		case PRINTF_PTR: arg->p = va_arg(*ap, void*); break;
		case PRINTF_INT: arg->i = (uintmax_t)va_arg(*ap, int); break;
		case PRINTF_UINT: arg->i = (uintmax_t)va_arg(*ap, unsigned int); break;
#   if LONG_GT_INT
		case PRINTF_LONG: arg->i = (uintmax_t)va_arg(*ap, long);
		case PRINTF_ULONG: arg->i = (uintmax_t)va_arg(*ap, unsigned long); break;
#   endif
		case PRINTF_ULLONG: arg->i = (uintmax_t)va_arg(*ap, unsigned long long); break;
		case PRINTF_SHORT: arg->i = (unsigned short)va_arg(*ap, int); break;
		case PRINTF_USHORT: arg->i = (unsigned short)va_arg(*ap, int); break;
		case PRINTF_CHAR: arg->i = (unsigned char)va_arg(*ap, int); break;
		case PRINTF_UCHAR: arg->i = (unsigned char)va_arg(*ap, int); break;
#   ifdef ODD_TYPES
		case PRINTF_LLONG: arg->i = (uintmax_t)va_arg(*ap, long long); break;
		case PRINTF_SIZET: arg->i = (uintmax_t)va_arg(*ap, size_t); break;
		case PRINTF_IMAX: arg->i = (uintmax_t)va_arg(*ap, intmax_t); break;
		case PRINTF_UMAX: arg->i = (uintmax_t)va_arg(*ap, uintmax_t); break;
		case PRINTF_PDIFF: arg->i = (uintmax_t)va_arg(*ap, ptrdiff_t); break;
		case PRINTF_UIPTR: arg->i = (uintptr_t)va_arg(*ap, void*); break;
#   endif
		case PRINTF_DBL: arg->f = va_arg(*ap, double); break;
		case PRINTF_LDBL: arg->f = va_arg(*ap, long double); break;
		default: break;
	}
}


DIAG_PUSH
IGNORE_WFORMAT_NONLITERAL


LIB_FUNC int wprintf_core(FILE* f, const wchar_t* fmt, va_list* ap, union printf_arg* nl_arg, int* nl_type) {
	const wchar_t *a, *z, *s = (const wchar_t*)fmt;
	unsigned int l10n = 0, litpct, _fl, st, ps;
	union printf_arg arg;
	int argpos, cnt = 0, l = 0, i, t, w, p;
	char* bs;
	char charfmt[16] = { 0 };
	wchar_t wc;
	loop_forever {
		if (cnt >= 0) {
			if (l > INT_MAX - cnt) {
				if (!ferror(f)) { set_errno(EOVERFLOW); }
				cnt = -1;
			} else { cnt += l; }
		}
		if (!*s) { break; }
		for (a = s; *s && *s != '%'; s++);
		litpct = (unsigned int)wcsspn(s, L"%") / 2;
		z = s + litpct;
		s += 2 * litpct;
		l = (int)(z - a);
		if (f) { out_wchar(f, a, (size_t)l); }
		else if (l) { continue; }
		if (iswdigit(s[1]) && s[2] == '$') {
			l10n = 1;
			argpos = s[1] - '0';
			s += 3;
		} else { argpos = -1; s++; }
		// Read modifier flags
		for (_fl = 0; ((unsigned)*s - ' ' < 32) && (FLAGMASK & (1U << (*s - ' '))); s++) {
			_fl |= (unsigned int)(1U << (*s - ' '));
		}
		// Read field width
		if (*s == '*') {
			if (iswdigit(s[1]) && s[2] == '$') {
				l10n = 1;
				nl_type[s[1] - '0'] = PRINTF_INT;
				w = (int)nl_arg[s[1] - '0'].i;
				s += 3;
			} else if (!l10n) {
				w = f ? va_arg(*ap, int) : 0;
				s++;
			} else { return -1; }
			if (w < 0) { _fl |= (unsigned int)LEFT_ADJ; w = -w; }
		} else if ((w = getint((const char**)&s)) < 0) { return -1; }
		// Read precision
		if (*s == '.' && s[1] == '*') {
			if (isdigit(s[2]) && s[3] == '$') {
				nl_type[s[2] - '0'] = PRINTF_INT;
				p = (int)nl_arg[s[2] - '0'].i;
				s += 4;
			} else if (!l10n) {
				p = f ? va_arg(*ap, int) : 0;
				s += 2;
			} else { return -1; }
		} else if (*s == '.') {
			s++;
			p = getint((const char**)&s);
		} else { p = -1; }
		// Format specifier state machine
		st = 0;
		do {
			if (OOB(*s)) { return -1; }
			ps = st;
			st = printf_states[st]sub_ascii_a(*s++);
		} while (st - 1 < PRINTF_STOP);
		if (!st) { return -1; }
		// Check validity of argument type (nl/normal)
		if (st == PRINTF_NOARG) {
			if (argpos >= 0) { return -1; }
		} else {
			if (argpos >= 0) { nl_type[argpos] = (int)st; arg = nl_arg[argpos]; }
			else if (f) { pop_arg(&arg, (int)st, ap); }
			else { return 0; }
		}
		if (!f) { continue; }
		t = s[-1];
		if (ps && (t & 15) == 3) { t &= (~32); }
		UNUSED char wprintf_core_null[8] = { '(', 'n', 'u', 'l', 'l', ')', '\0' };
		switch (t) {
			case 'n':
				switch (ps) {
					case PRINTF_BARE: *(int*)arg.p = cnt; break;
					case PRINTF_LPRE: *(long*)arg.p = cnt; break;
					case PRINTF_LLPRE: *(long long*)arg.p = cnt; break;
					case PRINTF_HPRE: *(unsigned short*)arg.p = (unsigned short)cnt; break;
					case PRINTF_HHPRE: *(unsigned char*)arg.p = (unsigned char)cnt; break;
					case PRINTF_ZTPRE: *(size_t*)arg.p = (size_t)cnt; break;
					case PRINTF_JPRE: *(uintmax_t*)arg.p = (uintmax_t)cnt; break;
					default: break;
				}
				continue;
			case 'c':
				fputwc((wchar_t)btowc((int)arg.i), f);
				l = 1;
				continue;
			case 'C':
				fputwc((wchar_t)arg.i, f);
				l = 1;
				continue;
			case 'S':
				a = arg.p;
				z = wmemchr(a, 0, (size_t)p);
				if (z) { p = (int)(z - a); }
				if (w < p) { w = p; }
				if (!(_fl & LEFT_ADJ)) { fprintf(f, "%.*s", w - p, ""); }
				out_wchar(f, a, (size_t)p);
				if ((_fl & LEFT_ADJ)) { fprintf(f, "%.*s", w - p, ""); }
				l = w;
				continue;
			case 'm':
				arg.p = strerror(get_errno());
			case 's':
				if (!arg.p) { arg.p = wprintf_core_null; }
				bs = arg.p;
				if (p < 0) { p = INT_MAX; }
				for (i = l = 0; l < p && (i = mbtowc(&wc, bs, MB_LEN_MAX)) > 0; bs += i, l++);
				if (i < 0) { return -1; }
				p = l;
				if (w < p) { w = p; }
				if (!(_fl & LEFT_ADJ)) { fprintf(f, "%.*s", (w - p), ""); }
				bs = arg.p;
				while (l--) {
					i = mbtowc(&wc, bs, MB_LEN_MAX);
					bs += i;
					fputwc(wc, f);
				}
				if ((_fl & LEFT_ADJ)) { fprintf(f, "%.*s", (w - p), ""); }
				l = w;
				continue;
			default: break;
		}
		snprintf(charfmt, sizeof(charfmt), "%%%s%s%s%s%s*.*%c%c", "#" + !(_fl & ALT_FORM), "+" + !(_fl & MARK_POS), "-" + !(_fl & LEFT_ADJ), " " + !(_fl & PAD_POS), "0" + !(_fl & ZERO_PAD), sizeprefix[(t | 32) - 'a'], t);
		switch (t | 32) {
			case 'a':
			case 'e':
			case 'f':
			case 'g':
				l = fprintf(f, charfmt, w, p, arg.f);
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'p':
				l = fprintf(f, charfmt, w, p, arg.i);
				break;
			default: break;
		}
	}
	if (f) { return cnt; }
	else if (!l10n) { return 0; }
	for (i = 1; i <= NL_ARGMAX && nl_type[i]; i++) { pop_arg((nl_arg + i), nl_type[i], ap); }
	for (; i <= NL_ARGMAX && (!nl_type[i]); i++);
	if (i <= NL_ARGMAX) { return -1; }
	return 1;
}


DIAG_POP


/** Writes the C wide string pointed by `fmt` to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by `ap` instead of additional function arguments */
LIB_FUNC int vfwprintf(FILE* restrict f, const wchar_t* restrict fmt, va_list ap) {
	va_list ap2;
	int nl_type[NL_ARGMAX] = { 0 };
	union printf_arg nl_arg[NL_ARGMAX];
	va_copy(ap2, ap);
	if (wprintf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) { va_end(ap2); return -1; }
	FLOCK(f);
	fwide(f, _O_WIDE);
	const int olderr = (f->flags & (unsigned int)__SERR);
	f->flags &= (unsigned int)(~__SERR);
	int ret = wprintf_core(f, fmt, &ap2, nl_arg, nl_type);
	if (f->flags & (unsigned int)__SERR) { ret = -1; }
	f->flags |= (unsigned int)olderr;
	FUNLOCK(f);
	va_end(ap2);
	return ret;
}
#define __vfwprintf(f, fmt, ap)   vfwprintf((f), (fmt), (ap))


/** Composes a string with the same text that would be printed if `fmt` was used on wprintf, but using the elements in the variable argument list identified by `ap` instead of additional function arguments and storing the resulting content as a C wide string in the buffer pointed by `wcstr` (taking `maxlen` as the maximum buffer capacity to fill, expressed in wide characters) */
LIB_FUNC int vswprintf(wchar_t* restrict wcstr, const size_t maxlen, const wchar_t* restrict fmt, va_list ap) {
	if (maxlen == 0) { set_errno(EINVAL); return -1; }
	FILE fp = { 0 };
	memset_no_output(&fp, 0, SIZEOF_FILE);
	fp.lbf = EOF;
	fp.flags = (unsigned int)(__SWR | __SSTR | __SALC);
	fp.write = &sw_write_helper;
	unsigned char buf[256] = { 0 };
	fp.buf = buf;
	fp.buf_size = sizeof(buf);
	fp.wbuf = wcstr;
	fp.wbuf_size = (maxlen - 1);
	fp.lock = -1;
	if (!maxlen) { return -1; }
	else if (maxlen > INT_MAX) { set_errno(EOVERFLOW); return -1; }
	const int r = vfwprintf(&fp, fmt, ap);
	sw_write(&fp, 0, 0);
	return (int)((size_t)r >= maxlen ? -1 : r);
}
#define _IO_vswprintf(wcstr, maxlen, format, args)   vswprintf((wcstr), (maxlen), (format), (args))
#define _vswprintf(wcstr, maxlen, format, args)   vswprintf((wcstr), (maxlen), (format), (args))
#define __vswprintf(wcstr, maxlen, format, args)   vswprintf((wcstr), (maxlen), (format), (args))
#define vsprintfW(wcstr, maxlen, format, args)   vswprintf((wcstr), (maxlen), (format), (args))


/** Writes the C wide string pointed by `fmt` to the standard output (stdout), replacing any format specifier in the same way as printf does, but using the elements in the variable argument list instead of additional function arguments */
LIB_FUNC int vwprintf(const wchar_t* format, va_list arg) {
	return vfwprintf(stdout, format, arg);
}


/** Writes the C wide string pointed by `format` to the stream; If `format` includes format specifiers (subsequences beginning with %), the additional arguments following `format` are formatted and inserted in the resulting string replacing their respective specifiers */
LIB_FUNC int fwprintf(FILE* stream, const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vfwprintf(stream, format, args);
	va_end(args);
	return result;
}


/** Writes the C wide string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does */
LIB_FUNC int wprintf(const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vwprintf(format, args);
	va_end(args);
	return result;
}


/** Composes a wide string with the same text that would be printed if format was used on wprintf, but instead of being printed, the content is stored as a C wide string in the buffer pointed by `s` */
LIB_FUNC int swprintf(wchar_t* s, const size_t len, const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vswprintf(s, len, format, args);
	va_end(args);
	return result;
}


/* TODO: Add WCHAR functions
size_t mbsnrtowcs(wchar_t* restrict, const char** restrict, size_t, size_t, mbstate_t* restrict);
wchar_t* wcpcpy(wchar_t* restrict, const wchar_t* restrict);
wchar_t* wcpncpy(wchar_t* restrict, const wchar_t* restrict, size_t);
int wcscasecmp(const wchar_t*, const wchar_t*);
int wcscasecmp_l(const wchar_t*, const wchar_t*, locale_t);
int wcscoll(const wchar_t*, const wchar_t*);
int wcscoll_l(const wchar_t*, const wchar_t*, locale_t);
wchar_t* wcsdup(const wchar_t*);
wcslen(const wchar_t*);
int wcsncasecmp(const wchar_t*, const wchar_t*, size_t);
int wcsncasecmp_l(const wchar_t*, const wchar_t*, size_t, locale_t);
wchar_t* wcsncat(wchar_t* restrict, const wchar_t* restrict, size_t);
size_t wcsnrtombs(char* restrict, const wchar_t** restrict, size_t, size_t, mbstate_t* restrict);
wchar_t* wcstok(wchar_t* restrict, const wchar_t* restrict, wchar_t** restrict);
size_t wcsxfrm_l(wchar_t* restrict, const wchar_t* restrict, size_t, locale_t);
wchar_t* wmemset(wchar_t*, wchar_t, size_t);
*/


#endif  // WCHAR_H


/* MULTI-BYTE CHARACTER TYPE (MB-CTYPE) & CODESET CONVERSION FACILITY (<iconv.h>) */


#if (!(defined(MBCTYPE_H) || defined(MBCTYPE_H_) || defined(_MBCTYPE_H) || defined(_MBCTYPE_H_) || defined(_ICONV_H) || defined(_ICONV_H_) || defined(_GCONV_H) || defined(_GCONV_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/iconv.h.html
#define MBCTYPE_H   (1)
#define MBCTYPE_H_   (1)
#define _MBCTYPE_H   (1)
#define _MBCTYPE_H_   (1)
#define ICONV_H   (1)
#define _ICONV_H   (1)
#define _ICONV_H_   (1)
#define GCONV_H   (1)
#define _GCONV_H   (1)
#define _GCONV_H_   (1)
#define _UTF8_H   (1)
#define _UTF8_H_   (1)


#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
#   error   "The character set is not based on ISO-646!"
#endif
#define TOTAL_KEYWORDS   345
#define MIN_WORD_LENGTH   2
#define MAX_WORD_LENGTH   45
#define MIN_HASH_VALUE   17
#define MAX_HASH_VALUE   926
#define UTF7_ENCODE_OPTIONAL_CHARS   1
/** Escape character used for JIS encoding */
#define MB_ESC_CHAR   0x1b
// Functions used to support SHIFT_JIS, EUC-JP, and JIS multibyte encodings
#define _isjis(c)   (((c) >= 0x21) && ((c) <= 0x7e))
#define isjis(c)   _isjis((c))
#define _issjis1(c)   ((((c) >= 0x81) && ((c) <= 0x9f)) || (((c) >= 0xe0) && ((c) <= 0xef)))
#define issjis1(c)   _issjis1((c))
#define _issjis2(c)   ((((c) >= 0x40) && ((c) <= 0x7e)) || (((c) >= 0x80) && ((c) <= 0xfc)))
#define issjis2(c)   _issjis2((c))
#define _iseucjp1(c)   (((c) == 0x8e) || ((c) == 0x8f) || (((c) >= 0xa1) && ((c) <= 0xfe)))
#define iseucjp1(c)   _iseucjp1((c))
#define _iseucjp2(c)   (((c) >= 0xa1) && ((c) <= 0xfe))
#define iseucjp2(c)   _iseucjp2((c))
#define ic_from(x)   (((x)) & UINT16_MAX)
#define ic_to(x)   (((x) >> 16) & UINT16_MAX)
/** Return code if invalid */
#define RET_ILSEQ   -1
/** Return code if only a shift sequence of n bytes was read */
#define RET_TOOFEW(n)   (-2 - (n))
/** Return code if invalid */
#define RET_ILUNI   -1
/** Return code if output buffer is too small */
#define RET_TOOSMALL   -2
#define ISBADF(_h_)   (!(_h_) || (_h_) == (iconv_t)-1)
/** ISO 10646 value used to signal invalid value */
#define __UNKNOWN_10646_CHAR   ((wchar_t)0xfffd)
#define GCONVCACHE_MAGIC   0x20010324
#define GCONV_MODULES_CACHE   GCONV_DIR "/gconv-modules.cache"
#define mbrtowc_utf8   mbrtowc
#define wctomb_utf8   wctomb


enum charset {
	INVALID_CHARSET = 0,
	ISO_8859_1, UTF_8,
	UCS_2, UCS_4,
	UTF_16_BE, UTF_16_LE, UTF_16
};


/** Error codes for gconv functions */
typedef enum GCONV_ERR {
	__GCONV_OK = 0,
	__GCONV_NOCONV, __GCONV_NODB, __GCONV_NOMEM,
	__GCONV_EMPTY_INPUT, __GCONV_FULL_OUTPUT, __GCONV_ILLEGAL_INPUT,
	__GCONV_INCOMPLETE_INPUT, __GCONV_ILLEGAL_DESCRIPTOR, __GCONV_INTERNAL_ERROR
} gconv_err_t;


/** Flags the `__gconv_open` function can set */
typedef enum GCONV_FLAGS {
	__GCONV_IS_LAST = 1,
	__GCONV_IGNORE_ERRORS = 2,
	__GCONV_SWAP = 4,
	__GCONV_TRANSLIT = 8
} gconv_flags_t;


/** CJK character set datatype */
typedef struct Summary16 {
	unsigned short indx;  //!< Index into big table
	unsigned short used_entries;  //!< Bitmask of used entries
} Summary16;


typedef struct attr_packed gconvcache_header {
	uint32_t magic;
	gidx_t string_offset, hash_offset, hash_size, module_offset, otherconv_offset;
} gconvcache_header_t;


typedef struct hash_entry { gidx_t string_offset, module_idx; }   hash_entry_t;


typedef struct module_entry {
	gidx_t canonname_offset, fromdir_offset, fromname_offset;
	gidx_t todir_offset, toname_offset, extra_offset;
} module_entry_t;


typedef struct extra_entry {
	gidx_t module_cnt;
	struct extra_entry_module {
		gidx_t outname_offset, dir_offset, name_offset;
	} module[1];
} extra_entry_t;


typedef struct attr_packed charseq { int length; char* data; }   CharSeq;


typedef struct convtable {
	int term[32];
	union __union_convtable {
		struct convtable* sub;
		struct charseq* out;
	} val[256];
} convtable_t;


typedef struct encoding_alias { int name; unsigned int encoding_index; }   encoding_alias_t;


DIAG_PUSH
IGNORE_WOVERLENGTH_STRINGS
#include "stringpool.h"
DIAG_POP


#include "armscii.h"
#include "atarist.h"
#include "cjk_variants.h"
#include "cns11643_1.h"
#include "cns11643_2.h"
#include "cns11643_3.h"
#include "cns11643_4a.h"
#include "cns11643_4b.h"
#include "cns11643_5.h"
#include "cns11643_6.h"
#include "cns11643_7.h"
#include "cns11643_15.h"
#include "cns11643_inv.h"
#include "nextstep.h"


static const UNUSED unsigned short align64 big5[13973] = {
#include "big5.def"
};


static const UNUSED unsigned short align64 gb18030[23940] = {
#include "gb18030.def"
};


static const UNUSED unsigned short align64 hkscs[] = {
#include "hkscs.def"
};


static const UNUSED unsigned short align64 jis0208[7896] = {
#include "jis0208.def"
};


static const UNUSED unsigned short align64 ksc[8742] = {
#include "ksc.def"
};


static const UNUSED unsigned short align64 legacy_chars[] = {
#include "legacychars.def"
};


/** Converts a value in the range 0..63 to a base64 encoded char */
LIB_FUNC unsigned char base64(const unsigned int i) {
	if (i < 26) { return (unsigned char)(i + 'A'); }
	else if (i < 52) { return (unsigned char)(i - 26 + 'a'); }
	else if (i < 62) { return (unsigned char)(i - 52 + '0'); }
	else if (i == 62) { return (unsigned char)'+'; }
	else if (i == 63) { return (unsigned char)'/'; }
	abort();
}


LIB_FUNC unsigned int utf8_seqlen(const long codepoint) {
	if (codepoint < 0x80) { return 1; }
	else if (codepoint < 0x800) { return 2; }
	else if (codepoint < 0x10000) { return 3; }
	else if (codepoint < 0x200000) { return 4; }
	else if (codepoint < 0x4000000) { return 5; }
	return 6;
}


/** Does not NUL-terminate the buffer */
LIB_FUNC int fill_utf8(long codepoint, char* restrict str) {
	const int nbytes = (int)utf8_seqlen(codepoint);
	register int b = nbytes;
	while (b > 1) {
		--b;
		str[b] = (char)(0x80 | (codepoint & 0x3f));
		codepoint >>= 6;
	}
	switch (nbytes) {
		case 1: str[0] = (char)(codepoint & 0x7f); break;
		case 2: str[0] = (char)(0xc0 | (codepoint & 0x1f)); break;
		case 3: str[0] = (char)(0xe0 | (codepoint & 0xf)); break;
		case 4: str[0] = (char)(0xf0 | (codepoint & 7)); break;
		case 5: str[0] = (char)(0xf8 | (codepoint & 3)); break;
		case 6: str[0] = (char)(0xfc | (codepoint & 1)); break;
		default: break;
	}
	return nbytes;
}


LIB_FUNC unsigned int get_16(const unsigned char* restrict s, int e) {
	e &= 1;
	return (unsigned int)(s[e] << 8 | s[1 - e]);
}


LIB_FUNC void put_16(unsigned char* s, const unsigned int c, int e) {
	e &= 1;
	s[e] = (unsigned char)(c >> 8);
	s[1 - e] = (unsigned char)c;
}


LIB_FUNC unsigned int get_32(const unsigned char* restrict s, int e) {
	e &= 3;
	return (unsigned int)(((unsigned int)(s[e] + 0U) << 24) | (unsigned int)(s[e ^ 1] << 16) | (unsigned int)(s[e ^ 2] << 8) | (unsigned int)s[e ^ 3]);
}


LIB_FUNC void put_32(unsigned char* s, const unsigned int c, int e) {
	e &= 3;
	s[e ^ 0] = (unsigned char)(c >> 24);
	s[e ^ 1] = (unsigned char)(c >> 16);
	s[e ^ 2] = (unsigned char)(c >> 8);
	s[e ^ 3] = (unsigned char)c;
}


LIB_FUNC int fuzzycmp(const unsigned char* restrict a, const unsigned char* restrict b) {
	for (; *a && *b; a++, b++) {
		while (*a && ((*a | 32U) - 'a') > 26 && (unsigned int)(*a - '0') > 10U) { ++a; }
		if ((*a | 32U) != *b) { return 1; }
	}
	return (int)(*a != *b);
}


LIB_FUNC int armscii_8_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	unsigned char c = *s;
	if (c < 0xa0) { *pwc = (ucs4_t)c; return 1; }
	else {
		register unsigned short wc = armscii_8_2uni[c - 0xa0];
		if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 1; }
	}
	return RET_ILSEQ;
}


LIB_FUNC int armscii_8_wctomb(unsigned char* r, ucs4_t wc) {
	register unsigned char c = 0;
	if (wc < 0x28) { *r = (unsigned char)wc; return 1; }
	else if (wc >= 0x28 && wc < 0x30) { c = (unsigned char)armscii_8_page00[wc - 0x28]; }
	else if (wc >= 0x30 && wc < 0xa0) { c = (unsigned char)wc; }
	else if (wc >= 0xa0 && wc < 0xc0) { c = (unsigned char)armscii_8_page00_1[wc - 0xa0]; }
	else if (wc >= 0x530 && wc < 0x590) { c = (unsigned char)armscii_8_page05[wc - 0x530]; }
	else if (wc >= 0x2010 && wc < 0x2028) { c = (unsigned char)armscii_8_page20[wc - 0x2010]; }
	if (c != 0) { *r = c; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int atarist_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	unsigned char c = *s;
	if (c < 0x80) { *pwc = (ucs4_t)c; }
	else { *pwc = (ucs4_t)atarist_2uni[c - 0x80]; }
	return 1;
}


LIB_FUNC int atarist_wctomb(unsigned char* restrict r, const ucs4_t wc) {
	register unsigned char c = 0;
	if (wc < 0x80) { *r = (unsigned char)wc; return 1; }
	else if (wc >= 0xa0 && wc < 0x100) { c = (unsigned char)atarist_page00[wc - 0xa0]; }
	else if (wc >= 0x130 && wc < 0x198) { c = (unsigned char)atarist_page01[wc - 0x130]; }
	else if (wc >= 0x390 && wc < 0x3c8) { c = (unsigned char)atarist_page03[wc - 0x390]; }
	else if (wc >= 0x5d0 && wc < 0x5f0) { c = (unsigned char)atarist_page05[wc - 0x5d0]; }
	else if (wc == 0x2020) { c = 0xbb; }
	else if (wc == 0x207f) { c = 0xfc; }
	else if (wc == 0x2122) { c = 0xbf; }
	else if (wc >= 0x2208 && wc < 0x2268) { c = (unsigned char)atarist_page22[wc - 0x2208]; }
	else if (wc >= 0x2310 && wc < 0x2328) { c = (unsigned char)atarist_page23[wc - 0x2310]; }
	if (c != 0) { *r = c; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int ascii_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	register unsigned char c = *s;
	if (c < 0x80) { *pwc = (ucs4_t)c; return 1; }
	return RET_ILSEQ;
}


LIB_FUNC int ascii_wctomb(unsigned char* r, const ucs4_t wc) {
	if (wc < 0x80) { *r = (unsigned char)wc; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int cns11643_1_mbtowc(ucs4_t* restrict pwc, const unsigned char* s, const int n) {
	register const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x27) || (c1 == 0x42) || (c1 >= 0x44 && c1 <= 0x7d)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				register unsigned short wc = 0xfffd;
				if (i < 3102) {
					if (i < 500) { wc = cns11643_1_2uni_page21[i]; }
					else if (i == 571) { wc = 0x4ea0; }
					else if (i == 578) { wc = 0x51ab; }
					else if (i == 583) { wc = 0x52f9; }
				} else if (i < 3290) {
					if (i < 3136) { wc = (unsigned short)cns11643_1_2uni_page42[i - 3102]; }
				} else if (i < 8691) { wc = (unsigned short)cns11643_1_2uni_page44[i - 3290]; }
				if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_2_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x72)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				unsigned short wc = 0xfffd;
				if (i < 7650) { wc = (unsigned short)cns11643_2_2uni_page21[i]; }
				if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_3_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x62) || (c1 >= 0x64 && c1 <= 0x67)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6298) {
					if (i < 6148) {
						swc = cns11643_3_2uni_page21[i];
						wc = cns11643_3_2uni_upages[swc >> 8] | (swc & 0xff);
					}
				} else {
					if (i < 6590) {
						swc = cns11643_3_2uni_page64[i - 6298];
						wc = cns11643_3_2uni_upages[swc >> 8] | (swc & 0xff);
					}
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_4_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x6e)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 2914) {
					swc = cns11643_4a_2uni_page21[i];
					wc = cns11643_4a_2uni_upages[swc >> 8] | (swc & 0xff);
				} else if (i < 7298) {
					swc = cns11643_4b_2uni_page40[i - 2914];
					wc = cns11643_4b_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_5_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x7c)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 8603) {
					swc = cns11643_5_2uni_page21[i],
					wc = cns11643_5_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_6_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x64)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6388) {
					swc = cns11643_6_2uni_page21[i];
					wc = cns11643_6_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_7_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x66)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6539) {
					swc = cns11643_7_2uni_page21[i];
					wc = cns11643_7_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_15_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x6d)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 7169) {
					swc = cns11643_15_2uni_page21[i];
					wc = cns11643_15_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_inv_wctomb(unsigned char* r, ucs4_t wc, const int n) {
	if (n >= 2) {
		const Summary16* summary = NULL;
		if (wc < 0x100) { summary = &cns11643_inv_uni2indx_page00[(wc >> 4)]; }
		else if (wc >= 0x200 && wc < 0x3d0) { summary = &cns11643_inv_uni2indx_page02[(wc >> 4) - 0x20]; }
		else if (wc >= 0x2000 && wc < 0x22c0)  { summary = &cns11643_inv_uni2indx_page20[(wc >> 4) - 0x200]; }
		else if (wc >= 0x2400 && wc < 0x2650) { summary = &cns11643_inv_uni2indx_page24[(wc >> 4) - 0x240]; }
		else if (wc >= 0x3000 && wc < 0x9fb0) { summary = &cns11643_inv_uni2indx_page30[(wc >> 4) - 0x300]; }
		else if (wc >= 0xfa00 && wc < 0xfa30) { summary = &cns11643_inv_uni2indx_pagefa[(wc >> 4) - 0xfa0]; }
		else if (wc >= 0xfe00 && wc < 0xfff0) { summary = &cns11643_inv_uni2indx_pagefe[(wc >> 4) - 0xfe0]; }
		else if (wc >= 0x20000 && wc < 0x2a6e0) { summary = &cns11643_inv_uni2indx_page200[(wc >> 4) - 0x2000]; }
		else if (wc >= 0x2f800 && wc < 0x2fa20) { summary = &cns11643_inv_uni2indx_page2f8[(wc >> 4) - 0x2f80]; }
		if (summary) {
			register unsigned short used_entries = summary->used_entries;
			register unsigned int i = wc & 0xf;
			if (used_entries & (unsigned short)(1 << i)) {
				used_entries &= (unsigned short)((1 << i) - 1);
				used_entries = (unsigned short)((used_entries & 0x5555) + ((used_entries & 0xaaaa) >> 1));
				used_entries = (unsigned short)((used_entries & 0x3333) + ((used_entries & 0xcccc) >> 2));
				used_entries = (unsigned short)((used_entries & 0xf0f) + ((used_entries & 0xf0f0) >> 4));
				used_entries = (unsigned short)((used_entries & 0xff) + (used_entries >> 8));
				used_entries = (unsigned short)(used_entries + (unsigned short)summary->indx);
				r[0] = (unsigned char)cns11643_inv_2charset[3 * used_entries];
				r[1] = (unsigned char)cns11643_inv_2charset[3 * used_entries + 1];
				r[2] = (unsigned char)cns11643_inv_2charset[3 * used_entries + 2];
				return 3;
			}
		}
		return RET_ILUNI;
	}
	return RET_TOOSMALL;
}
/** Returns the plane number (1,...,7,15) in r[0], the two bytes in r[1], r[2] */
#define cns11643_wctomb(r, wc, n)   cns11643_inv_wctomb((r), (wc), (n))


LIB_FUNC int java_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	unsigned char c = s[0];
	if (c != '\\') {
		*pwc = c;
		return 1;
	} else if (n < 2) { return RET_TOOFEW(0); }
	else if (s[1] != 'u') { *pwc = '\\'; return 1; }
	register int i;
	ucs4_t wc;
	for (i = 2; i < 6; i++) {
		if (n <= i) { return RET_TOOFEW(0); }
		c = s[i];
		if (c >= '0' && c <= '9') { c = (unsigned char)(c - '0'); }
		else if (c >= 'A' && c <= 'Z') { c = (unsigned char)(c - ('A' - 10)); }
		else if (c >= 'a' && c <= 'z') { c = (unsigned char)(c - ('a' - 10)); }
		else { *pwc = '\\'; return 1; }
		wc = 0;
		wc |= (ucs4_t)c << (4 * (5 - i));
	}
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		*pwc = wc;
		return 6;
	} else if (wc >= 0xdc00) { *pwc = '\\'; return 1; }
	else if (n < 7) { return RET_TOOFEW(0); }
	else if (s[6] != '\\') { *pwc = '\\'; return 1; }
	if (n < 8) { return RET_TOOFEW(0); }
	if (s[7] != 'u') { *pwc = '\\'; return 1; }
	ucs4_t wc2;
	for (i = 8; i < 12; i++) {
		if (n <= i) { return RET_TOOFEW(0); }
		c = s[i];
		if (c >= '0' && c <= '9') { c = (unsigned char)(c - '0'); }
		else if (c >= 'A' && c <= 'Z') { c = (unsigned char)(c - ('A' - 10)); }
		else if (c >= 'a' && c <= 'z') { c = (unsigned char)(c - ('a' - 10)); }
		else { *pwc = '\\'; return 1; }
		wc2 = 0;
		wc2 |= (ucs4_t)((ucs4_t)c << (4 * (11 - i)));
	}
	if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { *pwc = '\\'; return 1; }
	*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
	return 12;
}


LIB_FUNC int java_wctomb(unsigned char* r, ucs4_t wc, const int n) {
	if (wc < 0x80) {
		*r = (unsigned char)wc;
		return 1;
	} else if (wc < 0x10000) {
		if (n >= 6) {
			register unsigned int i;
			r[0] = '\\';
			r[1] = 'u';
			i = (unsigned int)((wc >> 12) & 0xf);
			r[2] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)((wc >> 8) & 0xf);
			r[3] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)((wc >> 4) & 0xf);
			r[4] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)(wc & 0xf);
			r[5] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			return 6;
		} else { return RET_TOOSMALL; }
	} else if (wc < 0x110000) {
		if (n >= 12) {
			ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
			ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
			register unsigned int i;
			r[0] = '\\';
			r[1] = 'u';
			i = (wc1 >> 12) & 0xf;
			r[2] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc1 >> 8) & 0xf;
			r[3] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc1 >> 4) & 0xf;
			r[4] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = wc1 & 0xf;
			r[5] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			r[6] = '\\';
			r[7] = 'u';
			i = (wc2 >> 12) & 0xf;
			r[8] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc2 >> 8) & 0xf;
			r[9] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc2 >> 4) & 0xf;
			r[10] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = wc2 & 0xf;
			r[11] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			return 12;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


LIB_FUNC int nextstep_mbtowc(ucs4_t* pwc, const unsigned char* s) {
	unsigned char c = *s;
	if (c < 0x80) {
		*pwc = (ucs4_t)c;
		return 1;
	} else {
		unsigned short wc = nextstep_2uni[c - 0x80];
		if (wc != 0xfffd) {
			*pwc = (ucs4_t)wc;
			return 1;
		}
	}
	return RET_ILSEQ;
}


LIB_FUNC int nextstep_wctomb(unsigned char* r, ucs4_t wc) {
	unsigned char c = 0;
	if (wc < 0x80) {
		*r = (unsigned char)wc;
		return 1;
	} else if (wc >= 0xa0 && wc < 0x100) { c = nextstep_page00[wc - 0xa0]; }
	else if (wc >= 0x130 && wc < 0x198) { c = nextstep_page01[wc - 0x130]; }
	else if (wc >= 0x2c0 && wc < 0x2e0) { c = nextstep_page02[wc - 0x2c0]; }
	else if (wc >= 0x2010 && wc < 0x2048) { c = nextstep_page20[wc - 0x2010]; }
	else if (wc >= 0xfb00 && wc < 0xfb08) { c = nextstep_pagefb[wc - 0xfb00]; }
	if (c != 0) {
		*r = c;
		return 1;
	}
	return RET_ILUNI;
}


/** UTF-16BE (RFC 2781) */
LIB_FUNC int utf16be_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 2) {
		ucs4_t wc = (ucs4_t)((s[0] << 8) + s[1]);
		if (wc >= 0xd800 && wc < 0xdc00) {
			if (n >= 4) {
				ucs4_t wc2 = (ucs4_t)((s[2] << 8) + s[3]);
				if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { return RET_ILSEQ; }
				*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
				return 4;
			}
		} else if (wc >= 0xdc00 && wc < 0xe000) { return RET_ILSEQ; }
		else { *pwc = wc; return 2; }
	}
	return RET_TOOFEW(0);
}


/** UTF-16BE (RFC 2781) */
LIB_FUNC int utf16be_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		if (wc < 0x10000) {
			if (n >= 2) {
				r[0] = (unsigned char)(wc >> 8);
				r[1] = (unsigned char)wc;
				return 2;
			} else { return RET_TOOSMALL; }
		} else if (wc < 0x110000) {
			if (n >= 4) {
				ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
				ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
				r[0] = (unsigned char)(wc1 >> 8);
				r[1] = (unsigned char)wc1;
				r[2] = (unsigned char)(wc2 >> 8);
				r[3] = (unsigned char)wc2;
				return 4;
			} else { return RET_TOOSMALL; }
		}
	}
	return RET_ILUNI;
}


/** UTF-16LE (RFC 2781) */
LIB_FUNC int utf16le_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 2) {
		ucs4_t wc = (ucs4_t)(s[0] + (s[1] << 8));
		if (wc >= 0xd800 && wc < 0xdc00) {
			if (n >= 4) {
				ucs4_t wc2 = (ucs4_t)(s[2] + (s[3] << 8));
				if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { return RET_ILSEQ; }
				*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
				return 4;
			}
		} else if (wc >= 0xdc00 && wc < 0xe000) { return RET_ILSEQ; }
		else { *pwc = wc; return 2; }
	}
	return RET_TOOFEW(0);
}


/** UTF-16LE (RFC 2781) */
LIB_FUNC int utf16le_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		if (wc < 0x10000) {
			if (n >= 2) {
				r[0] = (unsigned char)wc;
				r[1] = (unsigned char)(wc >> 8);
				return 2;
			} else { return RET_TOOSMALL; }
		} else if (wc < 0x110000) {
			if (n >= 4) {
				ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
				ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
				r[0] = (unsigned char)wc1;
				r[1] = (unsigned char)(wc1 >> 8);
				r[2] = (unsigned char)wc2;
				r[3] = (unsigned char)(wc2 >> 8);
				return 4;
			} else { return RET_TOOSMALL; }
		}
	}
	return RET_ILUNI;
}


/** UTF-32BE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32be_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 4) {
		ucs4_t wc = (ucs4_t)((s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3]);
		if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
			*pwc = wc;
			return 4;
		} else { return RET_ILSEQ; }
	}
	return RET_TOOFEW(0);
}


/** UTF-32BE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32be_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
		if (n >= 4) {
			r[0] = 0;
			r[1] = (unsigned char)(wc >> 16);
			r[2] = (unsigned char)(wc >> 8);
			r[3] = (unsigned char)wc;
			return 4;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


/** UTF-32LE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32le_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 4) {
		ucs4_t wc = (ucs4_t)(s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24));
		if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
			*pwc = wc;
			return 4;
		} else { return RET_ILSEQ; }
	}
	return RET_TOOFEW(0);
}


/** UTF-32LE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32le_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
		if (n >= 4) {
			r[0] = (unsigned char)wc;
			r[1] = (unsigned char)(wc >> 8);
			r[2] = (unsigned char)(wc >> 16);
			r[3] = 0;
			return 4;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


/* TODO: Add ICONV functions
size_t  iconv(iconv_t, char** restrict, size_t* restrict, char** restrict, size_t* restrict);
int iconv_close(iconv_t);
iconv_t iconv_open(const char*, const char*);
*/


#endif  // MBCTYPE_H & ICONV_H


/* UNSIGNED/UNICODE CHARACTERS (<uchar.h>) */


#if (!(defined(UCHAR_H) || defined(_UCHAR_H) || defined(_UCHAR_H_) || defined(_LIBC_UCHAR_H_)))  // http://www.cplusplus.com/reference/cuchar/
#define UCHAR_H   (1)
#define _UCHAR_H   (1)
#define _UCHAR_H_   (1)
#define _LIBC_UCHAR_H   (1)
#define _LIBC_UCHAR_H_   (1)


/** Return the length of a UTF-8 string */
LIB_FUNC NONNULL ATTR_PURE size_t utf8len(const char* restrict str) {
	register size_t i = 0;
	while (*str != 0) {
		if (PREDICT_LIKELY((signed char)*str > 0)) { ++i; ++str; }
		else if (PREDICT_UNLIKELY((unsigned char)*str >= (unsigned char)0xf0)) { i += 4; str += 4; }
		else if (((unsigned char)*str >= (unsigned char)0xe0) && ((unsigned char)*str < (unsigned char)0xf0)) { i += 3; str += 3; }
		else if (((unsigned char)*str >= (unsigned char)0xc0) && ((unsigned char)*str < (unsigned char)0xe0)) { i += 2; str += 2; }
		else { return 0; }
	}
	return i;
}


/** Return the length of a UTF-16 string */
LIB_FUNC NONNULL ATTR_PURE size_t utf16len(const char16_t* restrict str) {
	register size_t i = 0;
	while (*str != 0) {
		if (PREDICT_LIKELY((*str <= 0xd7ff) || (*str >= 0xe000))) { ++i; ++str; }
		else if (PREDICT_UNLIKELY((*str > 0xd7ff) && (*str < 0xe000))) { i += 2; str += 2; }
		else { return 0; }
	}
	return i;
}


/** Return the length of a UTF-32 string */
LIB_FUNC NONNULL ATTR_PURE size_t utf32len(const ucs4_t* restrict str) {
	register const ucs4_t* s = str;
	for (; *s; ++s);
	return (size_t)(s - str);
}


/** Convert a UTF-8 character to UTF-32 character */
LIB_FUNC ATTR_CF ucs4_t utf8c2utf32c(const uint32_t utf8char) {
	register ucs4_t tmp = 0;
	if (PREDICT_LIKELY(utf8char > 0)) { return (ucs4_t)utf8char; }
	else if (PREDICT_UNLIKELY(utf8char >= 0xf0)) {
		tmp = ((ucs4_t)(utf8char ^ 0xf0)) << 18;
		tmp &= ((ucs4_t)(utf8char ^ 0x80)) << 12;
		tmp &= (((ucs4_t)(utf8char ^ 0x80)) << 6);
		return (tmp & ((ucs4_t)(utf8char ^ 0x80)));
	} else if ((utf8char >= 0xe0) && (utf8char < 0xf0)) {
		tmp = ((ucs4_t)(utf8char ^ 0xe0)) << 12;
		tmp &= (((ucs4_t)(utf8char ^ 0x80)) << 6);
		return (tmp & ((ucs4_t)(utf8char ^ 0x80)));
	} else if ((utf8char >= 0xc0) && (utf8char < 0xe0)) {
		tmp = ((ucs4_t)(utf8char ^ 0xc0)) << 6;
		return (tmp & ((ucs4_t)(utf8char ^ 0x80)));
	}
	return 0;
}


/** Convert a UTF-8 string to UTF-32 string; Return the number of UTF-32 characters */
LIB_FUNC NONNULL size_t utf8toutf32(const signed char* restrict utf8str, ucs4_t* restrict utf32str) {
	register size_t i = 0;
	register ucs4_t tmp = 0;
	while (*utf8str != 0) {
		if (PREDICT_LIKELY(*utf8str > 0)) { *utf32str++ = (ucs4_t)*utf8str++; ++i; }
		else if (PREDICT_UNLIKELY((unsigned char)*utf8str >= (unsigned char)0xf0)) {
			tmp = ((ucs4_t)(*utf8str++ ^ 0xf0)) << 18;
			tmp &= ((ucs4_t)(*utf8str++ ^ 0x80)) << 12;
			tmp &= (((ucs4_t)(*utf8str++ ^ 0x80)) << 6);
			*utf32str++ = (tmp & ((ucs4_t)(*utf8str++ ^ 0x80)));
			i += 4;
		} else if (((unsigned char)*utf8str >= (unsigned char)0xe0) && ((unsigned char)*utf8str < (unsigned char)0xf0)) {
			tmp = ((ucs4_t)(*utf8str++ ^ 0xe0)) << 12;
			tmp &= (((ucs4_t)(*utf8str++ ^ 0x80)) << 6);
			*utf32str++ = (tmp & ((ucs4_t)(*utf8str++ ^ 0x80)));
			i += 3;
		} else if (((unsigned char)*utf8str >= (unsigned char)0xc0) && ((unsigned char)*utf8str < (unsigned char)0xe0)) {
			tmp = ((ucs4_t)(*utf8str++ ^ 0xc0)) << 6;
			*utf32str++ = (tmp & ((ucs4_t)(*utf8str++ ^ 0x80)));
			i += 2;
		} else { return 0; }
	}
	return i;
}


/** Convert a UTF-32 character to a UTF-8 character */
LIB_FUNC ATTR_CF uint32_t utf32c2utf8c(const ucs4_t codepoint) {
	utf8_t utf8char = { .whole = 0 };
	if (PREDICT_UNLIKELY(codepoint <= 0x7f)) {  // 0xxxxxxx
		return (uint32_t)codepoint;
	} else if (PREDICT_LIKELY(codepoint <= 0x7ff)) {  // 110xxxxx 10xxxxxx
		utf8char.bytes.byte1 = (uint8_t)(0xc0 | (codepoint >> 6));
		utf8char.bytes.byte2 = (uint8_t)(0x80 | (codepoint & 0x3f));
		return utf8char.whole;
	} else if (codepoint <= 0xffff) {  // 1110xxxx 10xxxxxx 10xxxxxx
		utf8char.bytes.byte1 = (uint8_t)(0xe0 | (codepoint >> 12));
		utf8char.bytes.byte2 = (uint8_t)(0x80 | ((codepoint >> 6) & 0x3f));
		utf8char.bytes.byte3 = (uint8_t)(0x80 | (codepoint & 0x3f));
		return utf8char.whole;
	} else if (PREDICT_UNLIKELY(codepoint <= 0x10ffff)) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
		utf8char.bytes.byte1 = (uint8_t)(0xf0 | (codepoint >> 18));
		utf8char.bytes.byte2 = (uint8_t)(0x80 | ((codepoint >> 12) & 0x3f));
		utf8char.bytes.byte3 = (uint8_t)(0x80 | ((codepoint >> 6) & 0x3f));
		utf8char.bytes.byte4 = (uint8_t)(0x80 | (codepoint & 0x3f));
		return utf8char.whole;
	}
	return 0;
}


/** Convert a UTF-32 string to a UTF-8 string; Return the number of UTF-8 characters */
LIB_FUNC NONNULL size_t utf32toutf8(const ucs4_t* restrict codepoints, unsigned char* restrict utf8str) {
	register ucs4_t codepoint = 0;
	register size_t i = 0;
	while (*codepoints != 0) {
		codepoint = *codepoints++;
		if (PREDICT_LIKELY(codepoint <= 0x7f)) {  // 0xxxxxxx
			*utf8str++ = (uint8_t)codepoint;
			++i;
		} else if (PREDICT_LIKELY(codepoint <= 0x7ff)) {  // 110xxxxx 10xxxxxx
			*utf8str++ = (uint8_t)(0xc0 | (codepoint >> 6));
			*utf8str++ = (uint8_t)(0x80 | (codepoint & 0x3f));
			i += 2;
		} else if (codepoint <= 0xffff) {  // 1110xxxx 10xxxxxx 10xxxxxx
			*utf8str++ = (uint8_t)(0xe0 | (codepoint >> 12));
			*utf8str++ = (uint8_t)(0x80 | ((codepoint >> 6) & 0x3f));
			*utf8str++ = (uint8_t)(0x80 | (codepoint & 0x3f));
			i += 3;
		} else if (PREDICT_UNLIKELY(codepoint <= 0x10ffff)) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			*utf8str++ = (uint8_t)(0xf0 | (codepoint >> 18));
			*utf8str++ = (uint8_t)(0x80 | ((codepoint >> 12) & 0x3f));
			*utf8str++ = (uint8_t)(0x80 | ((codepoint >> 6) & 0x3f));
			*utf8str++ = (uint8_t)(0x80 | (codepoint & 0x3f));
			i += 4;
		}
		return 0;
	}
	return i;
}


/** The 32-bit character `c32` is translated to its multibyte equivalent and stored in the array pointed by `pmb`; The function returns the length in bytes of the equivalent multibyte sequence pointed by `pmb` */
LIB_FUNC size_t c32rtomb(char* restrict pmb, char32_t c32, mbstate_t* restrict ps) {
	return wcrtomb(pmb, (wchar_t)c32, ps);
}
#define _c32rtomb(pmb, c32, ps)   c32rtomb((pmb), (c32), (ps))
#define __c32rtomb(pmb, c32, ps)   c32rtomb((pmb), (c32), (ps))


/** The multibyte character pointed by `pmb` is converted to a 16-bit character and stored at the location pointed by `pc16`; The function returns the length in bytes of the multibyte character (up to `len`) */
LIB_FUNC size_t mbrtoc16(char16_t* restrict pc16, const char* restrict pmb, const size_t len, mbstate_t* restrict ps) {
	static unsigned int internal_state;
	if (!ps) { ps = (void*)&internal_state; }
	unsigned* pending = (unsigned*)ps;
	if (!pmb) { return mbrtoc16(0, "", 1, ps); }
	else if ((int)*pending > 0) {
		if (pc16) { *pc16 = (char16_t)*pending; }
		*pending = 0;
		return (size_t)-3;
	}
	wchar_t wc = 0;
	register const size_t ret = mbrtowc(&wc, pmb, len, ps);
	if (ret <= 4) {
		if (wc >= 0x10000) {
			*pending = (unsigned)((wc & 0x3ff) + 0xdc00);
			wc = (0xd7c0 + (wc >> 10));
		}
		if (pc16) { *pc16 = (char16_t)wc; }
	}
	return ret;
}


/** The multibyte character pointed by `pmb` is converted to a 32-bit character and stored at the location pointed by `pc32`; The function returns the length in bytes of the multibyte character (up to `len`) */
LIB_FUNC size_t mbrtoc32(char32_t* restrict pc32, const char* restrict pmb, const size_t len, mbstate_t* restrict ps) {
	static unsigned int internal_state;
	if (!ps) { ps = (void*)&internal_state; }
	if (!pmb) { return mbrtoc32(0, "", 1, ps); }
	wchar_t wc = 0;
	register const size_t ret = mbrtowc(&wc, pmb, len, ps);
	if (ret <= 4 && pc32) { *pc32 = (char32_t)wc; }
	return ret;
}


#endif  // UCHAR_H


/* CONVERSION FROM/TO VISCII (<viscii.h>); RFC1456 */


#if (!(defined(VISCII_H) || defined(_VISCII_H) || defined(_VISCII_H_)))
#define VISCII_H   (1)
#define _VISCII_H   (1)
#define _VISCII_H_   (1)


#define CHARSET_NAME   "VISCII//"
/** All 256 character are defined */
#define HAS_HOLES   0
typedef struct gap { uint16_t start, end; int32_t idx; }   gap_t;


#define FROM_LOOP   from_gap
#define TO_LOOP   to_gap
#define MIN_NEEDED_FROM   1
#define MIN_NEEDED_TO   4
#define ONE_DIRECTION   0
// Define the conversion function from the 8bit charset to UCS4
#define MIN_NEEDED_INPUT   MIN_NEEDED_FROM
#define MIN_NEEDED_OUTPUT   MIN_NEEDED_TO
#define LOOPFCT   FROM_LOOP
#define BODY   do { uint32_t ch = to_ucs4[*inptr]; if (HAS_HOLES && PREDICT_UNLIKELY(ch == L'0') && IS_NONNUL(*inptr)) { STANDARD_FROM_LOOP_ERR_HANDLER(1); } else { put32(outptr, ch); outptr += 4; } ++inptr; } while (0x0)
#define LOOP_NEED_FLAGS
#define ONEBYTE_BODY   do { uint32_t ch = to_ucs4[c]; if (HAS_HOLES && PREDICT_UNLIKELY(ch == L'0') && IS_NONNUL(c)) { return WEOF; } else { return ch; } } while (0x0)


#include "viscii.h"


#endif  // VISCII_H


/* VISUALLY ENCODE CHARACTERS (<vis.h> & <bsd/vis.h>) */


#if (!(defined(VIS_H) || defined(_VIS_H) || defined(_VIS_H_) || defined(_LIBC_VIS_H_) || defined(_BSD_VIS_H_) || defined(_COMPAT_VIS_H_)))
#define VIS_H   (1)
#define _VIS_H   (1)
#define _VIS_H_   (1)
#define _BSD_VIS_H_   (1)
#define _LIBC_VIS_H_   (1)
#define _COMPAT_VIS_H_   (1)


/** Use octal format */
#define VIS_OCTAL   1
/** Use [nrft0..] where appropiate */
#define VIS_CSTYLE   2
/** Also encode space */
#define VIS_SP   4
/** Also encode tab */
#define VIS_TAB   8
/** Also encode newline */
#define VIS_NL   0x10
/** Also encode white-space */
#define VIS_WHITE   (VIS_SP | VIS_TAB | VIS_NL)
/** Only encode "unsafe" characters */
#define VIS_SAFE   0x20
/** Inhibit printing '\' */
#define VIS_NOSLASH   0x40
/** HTTP-style escape % hex hex */
#define VIS_HTTP1808   0x80
/** HTTP-style escape % hex hex */
#define VIS_HTTPSTYLE   0x80
/** Mime-style escape = HEX HEX */
#define VIS_MIMESTYLE   0x100
/** HTTP-style <tt>\&\#num;</tt> or <tt>\&string;</tt> */
#define VIS_HTTP1866   0x200
/** Do not decode '\' */
#define VIS_NOESCAPE   0x400
/** For unvis */
#define _VIS_END   0x800
/** Encode glob(3) magic characters */
#define VIS_GLOB   0x1000
/** Encode shell special characters [not glob] */
#define VIS_SHELL   0x2000
/** Encode magic characters, white-space, and shell special characters */
#define VIS_META   (VIS_WHITE | VIS_GLOB | VIS_SHELL)
/** Encode using the C locale */
#define VIS_NOLOCALE   0x4000
#define VIS_DQ   0x8000
#define VIS_ALL   INT_MAX
// unvis return codes
/** Character valid */
#define UNVIS_VALID   1
/** Character valid, push back passed char */
#define UNVIS_VALIDPUSH   2
/** Valid sequence, no character produced */
#define UNVIS_NOCHAR   3
/** Unrecognized escape sequence */
#define UNVIS_SYNBAD   -1
/** Decoder in unknown state (unrecoverable) */
#define UNVIS_ERROR   -2
/** No more characters (unvis flag) */
#define UNVIS_END   _VIS_END
// Decode driven by state machine
/** Have not seen escape char */
#define S_GROUND   0
/** Start decoding special sequence */
#define S_START   1
/** Metachar started (M) */
#define S_META   2
/** Metachar more, regular char (-) */
#define S_META1   3
/** Control char started (^) */
#define S_CTRL   4
/** Octal digit 2 */
#define S_OCTAL2   5
/** Octal digit 3 */
#define S_OCTAL3   6


/** Test if the character is visible */
#define ISVISIBLE(c, flag)   (((c) != '\0' || (flag & VIS_ALL) == 0) && (((uint32_t)(c) <= UCHAR_MAX && isascii((c)) && (((c) != '*' && (c) != '?' && (c) != '[' && (c) != '#') || (flag & VIS_GLOB) == 0) && isgraph((c))) || ((flag & VIS_SP) == 0 && (c) == ' ') || ((flag & VIS_TAB) == 0 && (c) == 't') || ((flag & VIS_NL) == 0 && (c) == 'n') || ((flag & VIS_SAFE) && ((c) == 'b' || ((int)(c) == 0x303037) || (c) == 'r' || isgraph((c))))))  // '007' = 0x303037
/** Test if the character is visible */
#define isvisible(c, flag)   ISVISIBLE((c), (flag))


/** Decode characters previously encoded by vis */
LIB_FUNC int unvis(char* cp, const char c, int* astate, const int flag) {
	if (flag & UNVIS_END) {
		if (*astate == S_OCTAL2 || *astate == S_OCTAL3) {
			*astate = S_GROUND;
			return (UNVIS_VALID);
		}
		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
	}
	switch (*astate) {
		case S_GROUND:
			*cp = 0;
			if (c == '\\') {
				*astate = S_START;
				return 0;
			}
			*cp = c;
			return UNVIS_VALID;
		case S_START:
			switch (c) {
				case '-':
					*cp = 0;
					*astate = S_GROUND;
					return 0;
				case '\\':
				case '"':
					*cp = c;
					*astate = S_GROUND;
					return UNVIS_VALID;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
					*cp = (char)(c - '0');
					*astate = S_OCTAL2;
					return 0;
				case 'M':
					*cp = (char)0200;
					*astate = S_META;
					return 0;
				case '^':
					*astate = S_CTRL;
					return 0;
				case 'n':
					*cp = '\n';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'r':
					*cp = '\r';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'b':
					*cp = '\b';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'a':
					*cp = '\007';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'v':
					*cp = '\v';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 't':
					*cp = '\t';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'f':
					*cp = '\f';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 's':
					*cp = ' ';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'E':
					*cp = '\033';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case '\n':
					*astate = S_GROUND;
					return UNVIS_NOCHAR;
				case '$':
					*astate = S_GROUND;
					return UNVIS_NOCHAR;
				default:
					return 0;
			}
			*astate = S_GROUND;
			return UNVIS_SYNBAD;
		case S_META:
			if (c == '-') { *astate = S_META1; }
			else if (c == '^') { *astate = S_CTRL; }
			else {
				*astate = S_GROUND;
				return UNVIS_SYNBAD;
			}
			return 0;
		case S_META1:
			*astate = S_GROUND;
			*cp |= c;
			return UNVIS_VALID;
		case S_CTRL:
			if (c == '?') { *cp |= 0177; }
			else { *cp = (char)((char)(*cp) | ((char)(c & 037))); }
			*astate = S_GROUND;
			return UNVIS_VALID;
		case S_OCTAL2:  // Second possible octal digit
			if (isoctal(c)) {
				*cp = (char)((*cp << 3) + (c - '0'));
				*astate = S_OCTAL3;
				return 0;
			}
			*astate = S_GROUND;
			return UNVIS_VALIDPUSH;
		case S_OCTAL3:  // Third possible octal digit
			*astate = S_GROUND;
			if (isoctal(c)) {
				*cp = (char)((*cp << 3) + (c - '0'));
				return UNVIS_VALID;
			}
			return UNVIS_VALIDPUSH;
		default:  // Decoder in unknown state - (probably uninitialized)
			*astate = S_GROUND;
			return UNVIS_SYNBAD;
	}
	UNREACHABLE
}
#define __unvis50(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define __unvis13(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define unvis50(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define unvis13(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))


/** Decode src into dest; Number of chars decoded into dest is returned, -1 on error; dest is null terminated */
LIB_FUNC int strunvis(char* dest, const char* src) {
	char c;
	char* start = dest;
	int vis_state = 0;
	while ((c = *src++)) {
goto_strunvis_again:
		switch (unvis(dest, c, &vis_state, 0)) {
			case UNVIS_VALID:
				++dest;
				break;
			case UNVIS_VALIDPUSH:
				++dest;
				goto goto_strunvis_again;
			case 0:
			case UNVIS_NOCHAR:
				break;
			default:
				*dest = '\0';
				return -1;
		}
	}
	if (unvis(dest, c, &vis_state, UNVIS_END) == UNVIS_VALID) { ++dest; }
	*dest = '\0';
	return (int)(dest - start);
}


LIB_FUNC ssize_t strnunvis(char* dest, const char* src, const size_t sz) {
	char c, p;
	char* start = dest, *end = (dest + sz - 1);
	int vis_state = 0;
	if (sz > 0) { *end = '\0'; }
	while ((c = *src++)) {
goto_strnunvis_again:
		switch (unvis(&p, c, &vis_state, 0)) {
			case UNVIS_VALID:
				if (dest < end) { *dest = p; }
				++dest;
				break;
			case UNVIS_VALIDPUSH:
				if (dest < end) { *dest = p; }
				++dest;
				goto goto_strnunvis_again;
			case 0:
			case UNVIS_NOCHAR:
				break;
			default:
				if (dest <= end) { *dest = '\0'; }
				return -1;
		}
	}
	if (unvis(&p, c, &vis_state, UNVIS_END) == UNVIS_VALID) {
		if (dest < end) { *dest = p; }
		++dest;
	}
	if (dest <= end) { *dest = '\0'; }
	return (ssize_t)(dest - start);
}


/** Visually encode characters */
LIB_FUNC char* vis(char* dest, int c, const int flag, const int nextc) {
	if (isvisible(c, flag)) {
		if ((c == '"' && (flag & VIS_DQ) != 0) || (c == '\\' && (flag & VIS_NOSLASH) == 0)) {
			*dest++ = '\\';
		}
		*dest++ = (char)c;
		*dest = '\0';
		return dest;
	}
	else if (flag & VIS_CSTYLE) {
		switch (c) {
			case '\n':
				*dest++ = '\\';
				*dest++ = 'n';
				*dest = '\0';
				return dest;
			case '\r':
				*dest++ = '\\';
				*dest++ = 'r';
				*dest = '\0';
				return dest;
			case '\b':
				*dest++ = '\\';
				*dest++ = 'b';
				*dest = '\0';
				return dest;
			case '\a':
				*dest++ = '\\';
				*dest++ = 'a';
				*dest = '\0';
				return dest;
			case '\v':
				*dest++ = '\\';
				*dest++ = 'v';
				*dest = '\0';
				return dest;
			case '\t':
				*dest++ = '\\';
				*dest++ = 't';
				*dest = '\0';
				return dest;
			case '\f':
				*dest++ = '\\';
				*dest++ = 'f';
				*dest = '\0';
				return dest;
			case ' ':
				*dest++ = '\\';
				*dest++ = 's';
				*dest = '\0';
				return dest;
			case '\0':
				*dest++ = '\\';
				*dest++ = '0';
				if (isoctal(nextc)) {
					*dest++ = '0';
					*dest++ = '0';
				}
				*dest = '\0';
				return dest;
			default:
				*dest = '\0';
				return dest;
		}
	}
	else if (((c & 0177) == ' ') || (flag & VIS_OCTAL) || ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {
		*dest++ = '\\';
		*dest++ = (char)(((char)c >> 6 & 7) + '0');
		*dest++ = (char)(((char)c >> 3 & 7) + '0');
		*dest++ = (char)(((char)c & 7) + '0');
		*dest = '\0';
		return dest;
	}
	else if ((flag & VIS_NOSLASH) == 0) { *dest++ = '\\'; }
	if (c & 0200) {
		c &= (char)0177;
		*dest++ = 'M';
	}
	if (iscntrl((uchar)c)) {
		*dest++ = '^';
		if (c == 0177) { *dest++ = '?'; }
		else { *dest++ = (char)(c + '@'); }
	} else {
		*dest++ = '-';
		*dest++ = (char)c;
	}
	*dest = '\0';
	return dest;
}


/** Visually encode characters from src into dest */
LIB_FUNC int strvis(char* dest, const char* src, const int flag) {
	char c;
	char* start;
	for (start = dest; (c = *src);) { dest = vis(dest, c, flag, *++src); }
	*dest = '\0';
	return (int)(dest - start);
}


/** Visually encode characters from src into dst; Strnvis will write no more than (siz - 1) bytes (and will NULL terminate); The number of bytes needed to fully encode the string is returned */
LIB_FUNC int strnvis(char* dst, const char* src, const size_t siz, const int flag) {
	char *start, *end;
	char tbuf[5] = { 0 };
	register int c, i = 0;
	for (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {
		if (isvisible(c, flag)) {
			if ((c == '"' && (flag & VIS_DQ) != 0) || (c == '\\' && (flag & VIS_NOSLASH) == 0)) {  // Need space for the extra '\\'
				if (dst + 1 >= end) { i = 2; break; }
				*dst++ = '\\';
			}
			i = 1;
			*dst++ = (char)c;
			++src;
		} else {
			i = (int)(vis(tbuf, c, flag, *++src) - tbuf);
			if (dst + i <= end) { memcpy_no_output(dst, tbuf, (size_t)i); dst += i; }
			else { --src; break; }
		}
	}
	if (siz > 0) { *dst = '\0'; }
	if (dst + i > end) {  // Adjust return value for truncation
		while ((c = *src)) { dst += vis(tbuf, c, flag, *++src) - tbuf; }
	}
	return (int)(dst - start);
}


/** Visually encode characters from src into dst */
LIB_FUNC int stravis(char** outp, const char* src, const int flag) {
	char* buf = reallocarray(NULL, 4, (strlen(src) + 1));
	if (buf == NULL) { return -1; }
	const int len = strvis(buf, src, flag);
	const int sverrno = get_errno();
	*outp = realloc(buf, (size_t)(len + 1));
	if (*outp == NULL) { *outp = buf; set_errno(sverrno); }
	return len;
}


/** Visually encode characters from src into dst; Strvisx encodes exactly len bytes from src into dst; This is useful for encoding a block of data */
LIB_FUNC int strvisx(char* dst, const char* src, const size_t len, const int flag) {
	char c;
	char* start;
	register size_t n = len;
	for (start = dst; n > 1; --n) {
		c = *src;
		dst = vis(dst, c, flag, *++src);
	}
	if (n) { dst = vis(dst, *src, flag, '\0'); }
	*dst = '\0';
	return (int)(dst - start);
}


/* TODO: Add vis.h functions
char *nvis(char *, size_t, int, int, int);
char *svis(char *, int, int, int, const char *);
char *snvis(char *, size_t, int, int, int, const char *);
int strsvis(char *, const char *, int, const char *);
int strsnvis(char *, size_t, const char *, int, const char *);
int strnvisx(char *, size_t, const char *, size_t, int);
int strenvisx(char *, size_t, const char *, size_t, int, int *);
int strsvisx(char *, const char *, size_t, int, const char *);
int strsnvisx(char *, size_t, const char *, size_t, int, const char *);
int strsenvisx(char *, size_t, const char *, size_t , int, const char *, int *);
int strunvisx(char *, const char *, int);
int strnunvisx(char *, size_t, const char *, int);
*/


#endif  // VIS_H


/* TIME (<time.h> & <sys/time.h>) */


#if (!(defined(TIME_H) || defined(_TIME_H) || defined(_TIME_H_) || defined(_SYS_TIME_H) || defined(_SYS_TIME_H_) || defined(_BITS_TIME_H) || defined(_BITS_TIME_H_) || defined(_BIONIC_TIME_H) || defined(_SYS_TIMEX_H) || defined(_SYS_TIMEX_H_)))  // http://www.cplusplus.com/reference/ctime/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html & http://pubs.opengroup.org/onlinepubs/000095399/basedefs/sys/timeb.h.html
#define TIME_H   (1)
#define _TIME_H   (1)
#define _TIME_H_   (1)
#define _SYS_TIME_H   (1)
#define _SYS_TIME_H_   (1)
#define _SYS_TIMEB_H   (1)  // <sys/timeb.h>
#define _SYS_TIMEB_H_   (1)
#define TIME_TYPES_H   (1)
#define TIME_TYPES_H_   (1)
#define _BITS_TIME_H   (1)
#define _BITS_TIME_H_   (1)
#define _BIONIC_TIME_H   (1)
#define _SYS_TIMEX_H   (1)
#define _SYS_TIMEX_H_   (1)
#define _XT_TIME_H   (1)
#define _COMPAT_SYS_TIME_TYPES_H_   (1)


#define TM_ZONE   tm_zone
/** Identifier for the system-wide monotonic clock */
#define CLOCK_MONOTONIC   1
#define CLOCK_PROCESS_CPUTIME_ID   2
#define CLOCK_THREAD_CPUTIME_ID   3
#define CLOCK_MONOTONIC_RAW   4
#define CLOCK_REALTIME_COARSE   5
#define CLOCK_MONOTONIC_COARSE   6
#define CLOCK_BOOTTIME   7
#define CLOCK_REALTIME_ALARM   8
#define CLOCK_BOOTTIME_ALARM   9
#define CLOCK_SGI_CYCLE   10
#define CLOCK_TAI   11
#define ADJ_OFFSET   1
#define ADJ_FREQUENCY   2
#define ADJ_MAXERROR   4
#define ADJ_ESTERROR   8
#define ADJ_STATUS   0x10
#define ADJ_TIMECONST   0x20
#define ADJ_TAI   0x80
#define ADJ_SETOFFSET   0x100
#define ADJ_MICRO   0x1000
#define ADJ_NANO   0x2000
#define ADJ_TICK   0x4000
#define ADJ_OFFSET_SINGLESHOT   0x8001
#define ADJ_OFFSET_SS_READ   0xa001
#define MOD_OFFSET   ADJ_OFFSET
#define MOD_FREQUENCY   ADJ_FREQUENCY
#define MOD_MAXERROR   ADJ_MAXERROR
#define MOD_ESTERROR   ADJ_ESTERROR
#define MOD_STATUS   ADJ_STATUS
#define MOD_TIMECONST   ADJ_TIMECONST
#define MOD_CLKB   ADJ_TICK
#define MOD_CLKA   ADJ_OFFSET_SINGLESHOT
#define MOD_TAI   ADJ_TAI
#define MOD_MICRO   ADJ_MICRO
#define MOD_NANO   ADJ_NANO
#define STA_PLL   1
#define STA_PPSFREQ   2
#define STA_PPSTIME   4
#define STA_FLL   8
#define STA_INS   0x10
#define STA_DEL   0x20
#define STA_UNSYNC  0x40
#define STA_FREQHOLD   0x80
#define STA_PPSSIGNAL   0x100
#define STA_PPSJITTER   0x200
#define STA_PPSWANDER   0x400
#define STA_PPSERROR   0x800
#define STA_CLOCKERR   0x1000
#define STA_NANO   0x2000
#define STA_MODE   0x4000
#define STA_CLK   0x8000
#define STA_RONLY   (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
#define TIME_OK   0
#define TIME_INS   1
#define TIME_DEL   2
#define TIME_OOP   3
#define TIME_WAIT   4
#define TIME_ERROR   5
#define TIME_BAD   TIME_ERROR
#define MAXTC   6
#define XT_TIME_LOCAL_TZ   1
#define XT_TIME_CONTIGUOUS   2
#define XT_TIME_ALL_MONTHDAYS   0xfffffffe
#define XT_TIME_ALL_WEEKDAYS   0xfe
#define XT_TIME_MIN_DAYTIME   0
#define XT_TIME_MAX_DAYTIME   86399
#define XT_TIME_ALL_FLAGS   (XT_TIME_LOCAL_TZ | XT_TIME_CONTIGUOUS)
#ifdef ARCHX86_64
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
/** Extend change to start of growsdown vma (mprotect only) */
#   define PROT_GROWSDOWN   0x1000000
/** Extend change to start of growsup vma (mprotect only) */
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_32BIT   0x40
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define MAP_HUGE_SHIFT   26
#   define MAP_HUGE_MASK   0x3f
/** No further special treatment */
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
/** Lock all currently mapped pages */
#   define MCL_CURRENT   1
/** Lock all additions to address space */
#   define MCL_FUTURE   2
/** Lock all pages that are faulted in */
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
/** Explicity exclude from the core dump, overrides the coredump filter bits */
#   define MADV_DONTDUMP   16
/** Clear the MADV_DONTDUMP flag */
#   define MADV_DODUMP   17
/** Poison a page for testing */
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHX86_32)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
/** Pages can be read */
#   define PROT_READ   1
/** Pages can be written */
#   define PROT_WRITE   2
/** Pages can be executed */
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
/** Share changes */
#   define MAP_SHARED   1
/** Changes are private */
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_32BIT   0x40
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x0100
#   define MAP_DENYWRITE   0x0800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHSUPERH)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_32BIT   0x40
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   4
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHPOWERPC)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_SAO   0x10
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_NORESERVE   0x40
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x80
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   0x2000
#   define MCL_FUTURE   0x4000
#   define MCL_ONFAULT   0x8000
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHMIPS)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x800
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_NORESERVE   0x400
#   define MAP_GROWSDOWN   0x1000
#   define MAP_DENYWRITE   0x2000
#   define MAP_EXECUTABLE   0x4000
#   define MAP_LOCKED   0x8000
#   define MAP_POPULATE   0x10000
#   define MAP_NONBLOCK   0x20000
#   define MAP_STACK   0x40000
#   define MAP_HUGETLB   0x80000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#elif defined(ARCHMICROBLAZE)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHAARCH64)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#elif defined(ARCHAARCH32)
#   define MAP_FAILED   ((void*)-1)
#   define PROT_NONE   0
#   define PROT_READ   1
#   define PROT_WRITE   2
#   define PROT_EXEC   4
#   define PROT_GROWSDOWN   0x1000000
#   define PROT_GROWSUP   0x2000000
#   define MAP_SHARED   1
#   define MAP_PRIVATE   2
#   define MAP_FIXED   0x10
#   define MAP_TYPE   0xf
#   define MAP_FILE   0
#   define MAP_ANON   0x20
#   define MAP_ANONYMOUS   MAP_ANON
#   define MAP_NORESERVE   0x4000
#   define MAP_GROWSDOWN   0x100
#   define MAP_DENYWRITE   0x800
#   define MAP_EXECUTABLE   0x1000
#   define MAP_LOCKED   0x2000
#   define MAP_POPULATE   0x8000
#   define MAP_NONBLOCK   0x10000
#   define MAP_STACK   0x20000
#   define MAP_HUGETLB   0x40000
#   define POSIX_MADV_NORMAL   0
#   define POSIX_MADV_RANDOM   1
#   define POSIX_MADV_SEQUENTIAL   2
#   define POSIX_MADV_WILLNEED   3
#   define POSIX_MADV_DONTNEED   0
#   define MS_ASYNC   1
#   define MS_INVALIDATE   2
#   define MS_SYNC   4
#   define MCL_CURRENT   1
#   define MCL_FUTURE   2
#   define MCL_ONFAULT   4
#   define MADV_NORMAL   0
#   define MADV_RANDOM   1
#   define MADV_SEQUENTIAL   2
#   define MADV_WILLNEED   3
#   define MADV_DONTNEED   4
#   define MADV_REMOVE   9
#   define MADV_DONTFORK   10
#   define MADV_DOFORK   11
#   define MADV_MERGEABLE   12
#   define MADV_UNMERGEABLE   13
#   define MADV_HUGEPAGE   14
#   define MADV_NOHUGEPAGE   15
#   define MADV_DONTDUMP   16
#   define MADV_DODUMP   17
#   define MADV_HWPOISON   100
#   define MADV_SOFT_OFFLINE   101
#endif  // ARCH
#ifndef MAP_FILE
#   define MAP_FILE   0
#endif
#ifndef MAP_FAILED
#   define MAP_FAILED   ((void*)-1)
#endif
/** Flag indicating time is absolute; For functions taking timer objects, this refers to the clock associated with the timer */
#define TIMER_ABSTIME   (1)
#define timerisset(tvp)   ((tvp)->tv_sec || (tvp)->tv_usec)
#define timerclear(tvp)   ((tvp)->tv_sec = (tvp)->tv_usec = 0)
#ifndef timercmp
#   define timercmp(tvp, uvp, cmp)   (((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))
#endif
#ifndef timeradd
#   define timeradd(tvp, uvp, vvp)   do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0x0)
#endif
#ifndef timersub
#   define timersub(tvp, uvp, vvp)   do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0x0)
#endif
#define BAD_MACH_TIMESPEC(t)   ((t)->tv_nsec < 0 || (t)->tv_nsec >= (long)NSEC_PER_SEC)
/** t1 <=> t2, also (t1 - t2) in nsec with max of +- 1 sec */
#define CMP_MACH_TIMESPEC(t1, t2)   ((t1)->tv_sec > (t2)->tv_sec ? (long)(NSEC_PER_SEC) : ((t1)->tv_sec < (t2)->tv_sec ? (long) -NSEC_PER_SEC : (t1)->tv_nsec - (t2)->tv_nsec))
#define ADD_MACH_TIMESPEC(t1, t2)   do { if (((t1)->tv_nsec += (t2)->tv_nsec) >= (long) NSEC_PER_SEC) { (t1)->tv_nsec -= (long) NSEC_PER_SEC; (t1)->tv_sec += 1; } (t1)->tv_sec += (t2)->tv_sec; } while (0x0)
#define SUB_MACH_TIMESPEC(t1, t2)   do { if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0) { (t1)->tv_nsec += (long) NSEC_PER_SEC; (t1)->tv_sec -= 1; } (t1)->tv_sec -= (t2)->tv_sec; } while (0x0)
/** Macro for converting from `struct timeval` to `struct timespec` */
#define TIMEVAL_TO_TIMESPEC(tv, ts)   { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }
/** Macro for converting from `struct timespec` to `struct timeval` */
#define TIMESPEC_TO_TIMEVAL(tv, ts)   { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }
/** Nonzero if YEAR is a leap year (every 4 years, except every 100 that is not divisible by 400) */
#define __isleap(year)   ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
/** Nonzero if YEAR is a leap year (every 4 years, except every 100 that is not divisible by 400) */
#define isleap(year)   __isleap((year))
/** Minimum finite time value; This assumes no padding */
static const UNUSED time_t time_t_min = MINVAL(time_t, TYPE_BIT(time_t));
/** Maximum finite time value; This assumes no padding */
static const UNUSED time_t time_t_max = MAXVAL(time_t, TYPE_BIT(time_t));


/** Structure returned by the `ftime` function; Current time */
typedef struct attr_packed timeb {
	time_t time;  //!< The seconds portion of the current time
	unsigned short millitm;  //!< The milliseconds portion of the current time
	short timezone;  //!< The local timezone in minutes west of Greenwich
	short dstflag;  //!< TRUE if Daylight Savings Time is in effect
} timeb_t;


typedef struct attr_packed xt_time_info {
	uint32_t date_start, date_stop, daytime_start, daytime_stop, monthdays_match;
	uint8_t weekdays_match, flags;
} xt_time_info_t;


#ifndef _BIONIC_STRFTIME_TZ_DECLARED
#   define _BIONIC_STRFTIME_TZ_DECLARED   (1)
typedef struct strftime_locale {
	const char* mon[12];
	const char* month[12];
	const char* standalone_month[12];
	const char* wday[7];
	const char* weekday[7];
	const char* X_fmt;
	const char* x_fmt;
	const char* c_fmt;
	const char* am;
	const char* pm;
	const char* date_fmt;
} strftime_locale_t;
#endif


typedef struct attr_packed timex {
	unsigned modes;
	long offset, freq, maxerror, esterror;
	int status;
	long constant, precision, tolerance;
	struct timeval time;
	long tick, ppsfreq, jitter;
	int shift;
	long stabil, jitcnt, calcnt, errcnt, stbcnt;
	int tai;
	int __padding[11];
} timex_t;


struct bintime {
	time_t sec;
	uint64_t frac;
};


// TIME-RELATED VARIABLES

static UNUSED char* __tzname[2] = { 0 };
static UNUSED int __daylight = 0, getdate_err = 0;
static UNUSED long __timezone = 0, dst_off = 0;
static UNUSED int r0[5] = { 0 }, r1[5] = { 0 };
static UNUSED char std_name[TZNAME_MAX + 1];
static UNUSED char dst_name[TZNAME_MAX + 1];
static UNUSED char __gmt[4] = "GMT";
static UNUSED char old_tz_buf[32] = { 0 };
static UNUSED size_t old_tz_size = sizeof(old_tz_buf), map_size;
static UNUSED char* old_tz = old_tz_buf;
static UNUSED int rule0[5] = { 0 }, rule1[5] = { 0 };
static UNUSED unsigned char *time_index, *abbrevs, *abbrevs_end, *types;
static const UNUSED unsigned char *zi, *trans;


#ifndef _OS_OSBASE_H
#define _OS_OSBASE_H   (1)
#define OS_OSBASE_H   (1)


#ifdef ALLOW_XNU_DATATYPES_H
LIB_FUNC uint64_t* OSAbsoluteTimePtr(AbsoluteTime* abstime) { return ((uint64_t*)abstime); }
#   define __OSAbsoluteTimePtr(abstime)   OSAbsoluteTimePtr((abstime))
#endif
#define AbsoluteTime_to_scalar(x)   (*(uint64_t*)(x))
#define CMP_ABSOLUTETIME(t1, t2)   ((AbsoluteTime_to_scalar(t1) > AbsoluteTime_to_scalar(t2)) ? (int)1 : ((AbsoluteTime_to_scalar(t1) < AbsoluteTime_to_scalar(t2)) ? ((int)-1) : 0))
#define ADD_ABSOLUTETIME(t1, t2)   (AbsoluteTime_to_scalar(t1) += AbsoluteTime_to_scalar(t2))
#define SUB_ABSOLUTETIME(t1, t2)   (AbsoluteTime_to_scalar(t1) -= AbsoluteTime_to_scalar(t2))
#define ADD_ABSOLUTETIME_TICKS(t1, ticks)   (AbsoluteTime_to_scalar(t1) += (int32_t)(ticks))


#endif  // OS_OSBASE_H


#define difftime(t1, t0)   (double)((time_t)(t1) - (time_t)(t0))


LIB_FUNC int is_leap(const int x) {
	register int y = x;
	if (y > (INT_MAX - 1900)) { y -= 2000; }
	y += 1900;
	return (!(y % 4) && ((y % 100) || !(y % 400)));
}


LIB_FUNC int week_num(const struct tm* _tm) {
	register int val = (_tm->tm_yday + 7 - (_tm->tm_wday + 6) % 7) / 7;
	// If 1 Jan is just 1-3 days past Monday, the previous week is also in this year
	if (((_tm->tm_wday + 371) - _tm->tm_yday - 2) % 7 <= 2) { ++val; }
	if (!val) {
		val = 52;
		// If 31 December of prev year a Thursday, or Friday of a leap year, then the prev year has 53 weeks
		register int dec31 = ((_tm->tm_wday + 7) - _tm->tm_yday - 1) % 7;
		if (dec31 == 4 || (dec31 == 5 && is_leap((_tm->tm_year % 400) - 1))) { ++val; }
	} else if (val == 53) {
		// If 1 January is not a Thursday, and not a Wednesday of a leap year, then this year has only 52 weeks
		register int jan1 = (int)((_tm->tm_wday + 371 - _tm->tm_yday) % 7);
		if (jan1 != 4 && (jan1 != 3 || (!is_leap(_tm->tm_year)))) { val = 1; }
	}
	return val;
}


/** Return the number of days in a month */
LIB_FUNC int days_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2: return (28 + _is_leap);
		case 4:
		case 6:
		case 9:
		case 11:
			return 30;
		default: return 31;
	}
	UNREACHABLE
}
#define __days_in_month(_month, _is_leap)   days_in_month((_month), (_is_leap))
#define __month_to_days(_month, _is_leap)   days_in_month((_month), (_is_leap))
#define month_to_days(_month, _is_leap)   days_in_month((_month), (_is_leap))


/** Return the number of hours in a month */
LIB_FUNC int hours_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 696; }
			else { return 672; }
		case 4:
		case 6:
		case 9:
		case 11:
			return 720;
		default: return 744;
	}
	UNREACHABLE
}
#define __hours_in_month(_month, _is_leap)   hours_in_month((_month), (_is_leap))
#define __month_to_hours(_month, _is_leap)   hours_in_month((_month), (_is_leap))
#define month_to_hours(_month, _is_leap)   hours_in_month((_month), (_is_leap))


/** Return the number of minutes in a month */
LIB_FUNC int minutes_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 41760; }
			else { return 40320; }
		case 4:
		case 6:
		case 9:
		case 11: return 43200;
		default: return 44640;
	}
	UNREACHABLE
}
#define __minutes_in_month(_month, _is_leap)   minutes_in_month((_month), (_is_leap))
#define __month_to_minutes(_month, _is_leap)   minutes_in_month((_month), (_is_leap))
#define month_to_minutes(_month, _is_leap)   minutes_in_month((_month), (_is_leap))


/** Return the number of seconds in a month */
LIB_FUNC int secs_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 2505600; }
			else { return 2419200; }
		case 4:
		case 6:
		case 9:
		case 11: return 2592000;
		default: return 2678400;
	}
	UNREACHABLE
}
#define __secs_in_month(_month, _is_leap)   secs_in_month((_month), (_is_leap))
#define __month_to_secs(_month, _is_leap)   secs_in_month((_month), (_is_leap))
#define month_to_secs(_month, _is_leap)   secs_in_month((_month), (_is_leap))


LIB_FUNC int secs_to_tm(long long t, struct tm* _tm) {
	int wday = 0, yday = 0, leap = 0;
	// Reject time_t values whose year would overflow int
	if (t < (INT_MIN * 31622400LL) || t > (INT_MAX * 31622400LL)) { return -1; }
	register const long long secs = t - LEAPOCH;
	register long long days = secs / 86400;
	register int remsecs = (int)(secs % 86400);
	if (remsecs < 0) {
		remsecs += 86400;
		--days;
	}
	wday = (int)((3 + days) % 7);
	if (wday < 0) { wday += 7; }
	register int qc_cycles = (int)(days / DAYS_PER_400Y);
	register int remdays = (int)(days % DAYS_PER_400Y);
	if (remdays < 0) {
		remdays += DAYS_PER_400Y;
		--qc_cycles;
	}
	register int c_cycles = (int)(remdays / DAYS_PER_100Y);
	if (c_cycles == 4) { c_cycles--; }
	remdays -= (c_cycles * DAYS_PER_100Y);
	register int q_cycles = (int)(remdays / DAYS_PER_4Y);
	if (q_cycles == 25) { --q_cycles; }
	remdays -= (q_cycles * DAYS_PER_4Y);
	register int remyears = (int)(remdays / 365);
	if (remyears == 0x4) { --remyears; }
	remdays -= (remyears * 365);
	leap = (!remyears && (q_cycles || !c_cycles));
	yday = remdays + 59 + leap;
	if (yday >= (365 + leap)) { yday -= (365 + leap); }
	long long years = remyears + 4 * q_cycles + 100 * c_cycles + 400LL * qc_cycles;
	int months;
	for (months = 0; days_per_month[months] <= remdays; months++) { remdays -= days_per_month[months]; }
	if (((years + 100) > INT_MAX) || ((years + 100) < INT_MIN)) { return -1; }
	_tm->tm_year = (int)(years + 100);
	_tm->tm_mon = months + 2;
	if (_tm->tm_mon >= 12) { _tm->tm_mon -= 12; _tm->tm_year++; }
	_tm->tm_mday = remdays + 1;
	_tm->tm_wday = wday;
	_tm->tm_yday = yday;
	_tm->tm_hour = remsecs / 3600;
	_tm->tm_min = (remsecs / 60) % 60;
	_tm->tm_sec = remsecs % 60;
	return 0;
}
#define __secs_to_tm(t, _tm)   secs_to_tm((t), (_tm))


LIB_FUNC long long year_to_secs(const long long year, int* _is_leap) {
	if ((year - 2LL) <= 136) {
		int y = (int)year;
		int leaps = (y - 68) >> 2;
		if (!((y - 68) & 3)) {
			leaps--;
			if (_is_leap) { *_is_leap = 1; }
		} else if (_is_leap) { *_is_leap = 0; }
		return 31536000 * (y - 70) + 86400 * leaps;
	}
	int centuries, leaps, rem;
	if (!_is_leap) { _is_leap = &(int) { 0 }; }
	register int cycles = (int)((year - 100) / 400);
	rem = (int)((year - 100) % 400);
	if (rem < 0) { --cycles; rem += 400; }
	if (!rem) {
		*_is_leap = 1;
		centuries = 0;
		leaps = 0;
	} else {
		if (rem >= 200) {
			if (rem >= 300) { centuries = 3; rem -= 300; }
			else { centuries = 2; rem -= 200; }
		} else {
			if (rem >= 100) { centuries = 1; rem -= 100; }
			else { centuries = 0; }
		}
		if (!rem) {
			*_is_leap = 0;
			leaps = 0;
		} else {
			leaps = (int)(rem / 4);
			rem %= 4;
			*_is_leap = (!rem);
		}
	}
	leaps += (97 * cycles + 24 * centuries - *_is_leap);
	return ((year - 100) * 31536000LL + leaps * 86400LL + 946684800 + 86400);
}
#define __year_to_secs(year, _is_leap)   year_to_secs((year), (_is_leap))


LIB_FUNC long long tm_to_secs(const struct tm* _tm) {
	register long long year = _tm->tm_year;
	register int month = _tm->tm_mon;
	if (month >= 12 || month < 0) {
		register int adj = month / 12;
		month %= 12;
		if (month < 0) { adj--; month += 12; }
		year += adj;
	}
	int _is_leap = 0;
	register long long t = __year_to_secs(year, &_is_leap);
	t += __month_to_secs(month, _is_leap);
	t += 86400LL * (_tm->tm_mday - 1);
	t += 3600LL * _tm->tm_hour;
	t += 60LL * _tm->tm_min;
	t += _tm->tm_sec;
	return t;
}
#define __tm_to_secs(_tm)   tm_to_secs((_tm))


LIB_FUNC const char* tm_to_tzname(const struct tm* _tm) {
	const void* p = _tm->__tm_zone;
	LOCK(tmlock);
	do_tzset();
	if (p != __gmt && p != __tzname[0] && p != __tzname[1] && (!zi || (uintptr_t)p - (uintptr_t)abbrevs >= (uintptr_t)(abbrevs_end - abbrevs))) { p = ""; }
	UNLOCK(tmlock);
	return p;
}
#define __tm_to_tzname(_tm)   tm_to_tzname((_tm))


/** Convert a POSIX DST rule plus year to seconds since epoch */
LIB_FUNC long long rule_to_secs(const int* rule, const int year) {
	int is_leap = 0, x = 0, m = 0, n = 0, d = 0;
	register long long t = year_to_secs(year, &is_leap);
	if (rule[0] != 'M') {
		x = rule[1];
		if (rule[0] == 'J' && (x < 60 || !(is_leap))) { x--; }
		t += 86400 * x;
	} else {
		m = rule[1];
		n = rule[2];
		d = rule[3];
		t += month_to_secs((m - 1), is_leap);
		const int wday = (int)((t + 4 * 86400) % (7 * 86400)) / 86400;
		register int days = (int)(d - wday);
		if (days < 0) { days += 7; }
		if (n == 5 && days + 28 >= days_in_month(m, is_leap)) { n = 4; }
		t += 86400 * (days + 7 * (n - 1));
	}
	t += rule[4];
	return t;
}


LIB_FUNC int getoff(const char** p) {
	register int neg = 0;
	if (**p == '-') { ++*p; neg = 1; }
	else if (**p == '+') { ++*p; }
	int off = 3600 * getint(p);
	if (**p == ':') {
		++*p;
		off += 60 * getint(p);
		if (**p == ':') {
			++*p;
			off += getint(p);
		}
	}
	return (neg ? (-off) : off);
}


LIB_FUNC void getrule(const char** p, int rule[5]) {
	int r = rule[0] = **p;
	if (r != 'M') {
		if (r == 'J') { ++*p; }
		else { rule[0] = 0; }
		rule[1] = getint(p);
	} else {
		++*p; rule[1] = getint(p);
		++*p; rule[2] = getint(p);
		++*p; rule[3] = getint(p);
	}
	if (**p == '/') { ++*p; rule[4] = getoff(p); }
	else { rule[4] = 7200; }
}


LIB_FUNC void getname(char* d, const char** p) {
	register int i = 0;
	if (**p == '<') {
		++*p;
		for (i = 0; **p != '>' && i < TZNAME_MAX; i++) { d[i] = (*p)[i]; }
		++*p;
	} else {
		for (i = 0; ((unsigned int)(((*p)[i] | 32) - 'a') < 26U) && i < TZNAME_MAX; i++) { d[i] = (*p)[i]; }
	}
	*p += i;
	d[i] = 0;
}


LIB_FUNC int adjtimex(struct timex* tx) {
	return (int)syscall1(SYS_adjtimex, (long)tx);
}


LIB_FUNC int clock_adjtime(const clockid_t clock_id, struct timex* utx) {
	return (int)syscall2(SYS_clock_adjtime, (long)clock_id, (long)utx);
}


LIB_FUNC int clock_settime(const clockid_t clk, const struct timespec* ts) {
	return (int)syscall2(SYS_clock_settime, clk, (long)ts);
}


LIB_FUNC int settimeofday(const struct timeval* tv, const UNUSED struct timezone_struct* tz) {
	return (int)syscall2(SYS_settimeofday, (long)tv, 0);
}


LIB_FUNC int getitimer(const int which, struct itimerval* old) {
	return (int)syscall2(SYS_getitimer, which, (long)old);
}


LIB_FUNC int setitimer(const int which, const struct itimerval* restrict new, struct itimerval* restrict old) {
	return (int)syscall3(SYS_setitimer, which, (long)new, (long)old);
}


LIB_FUNC int nanosleep(const struct timespec* req, struct timespec* rem) {
	return (int)syscall2(SYS_nanosleep, (long)req, (long)rem);
}
#define _nanosleep(req, rem)   nanosleep((req), (rem))
#define __nanosleep(req, rem)   nanosleep((req), (rem))
#define __libc_nanosleep(req, rem)   nanosleep((req), (rem))
#define libc_nanosleep(req, rem)   nanosleep((req), (rem))


LIB_FUNC int clock_nanosleep(const clockid_t clk, const int flags, const struct timespec* req, struct timespec* rem) {
	return -(int)(syscall4(SYS_clock_nanosleep, (long)clk, flags, (long)req, (long)rem));
}


LIB_FUNC int clock_getres(const clockid_t clk, struct timespec* ts) {
	return (int)syscall2(SYS_clock_getres, (long)clk, (long)ts);
}


LIB_FUNC int timer_getoverrun(const timer_t t) {
	timer_t tmp_t = t;
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		tmp_t = (void*)((uintptr_t)(td->timer_id & INT_MAX));
	}
	return (int)syscall1(SYS_timer_getoverrun, (long)tmp_t);
}


LIB_FUNC int ntp_gettime(struct ntptimeval* ntv) {
	struct timex tntx = { 0 };
	tntx.modes = 0;
	const int result = adjtimex(&tntx);
	ntv->time = tntx.time;
	ntv->maxerror = tntx.maxerror;
	ntv->esterror = tntx.esterror;
	return result;
}


LIB_FUNC int clock_gettime(const clockid_t clk, struct timespec* restrict ts) {
	register const int r = (int)syscall2(SYS_clock_gettime, (long)clk, (long)ts);
	if (r == -ENOSYS) {
		if (clk == CLOCK_REALTIME) {
			syscall2(SYS_gettimeofday, (long)ts, 0);
			ts->tv_nsec = (int)ts->tv_nsec * 1000;
			return 0;
		}
		return -EINVAL;
	}
	return r;
}
#define __clock_gettime(clock_id, tp)   clock_gettime((clock_id), (tp))


LIB_FUNC ATTR_NONNULL(1) int gettimeofday(struct timeval* restrict tv, const UNUSED void* restrict tz) {
	struct timespec align64 ts = { 0 };
	syscall2void(SYS_clock_gettime, (long)CLOCK_REALTIME, (long)&ts);  // clock_gettime(CLOCK_REALTIME, &ts);
	tv->tv_sec = ts.tv_sec;
	tv->tv_usec = (int)ts.tv_nsec / 1000;
	return 0;
}


#ifndef GETTIME
#   define GETTIME(low, high)   do { struct timeval align32 tval = { 0 }; gettimeofday(&tval, NULL); const uint64_t usecs = (uint64_t)tval.tv_usec + (uint64_t)tval.tv_usec * 1000000; low = (uint64_t)(usecs & UINT32_MAX); high = (usecs >> 32); } while (0x0)
#endif


#ifndef START_TIME
/** Macros used to measure the execution time (in microseconds) of the code between `START_TIME()` and `END_TIME()` */
#   define START_TIME()   struct timeval align64 __start_time_clock = { 0 }; gettimeofday(&__start_time_clock, NULL)
#endif


#ifndef END_TIME
/** Macros used to measure the execution time (in microseconds) of the code between `START_TIME()` and `END_TIME()` */
#   define END_TIME()   struct timeval align64 __end_time_clock = { 0 }; gettimeofday(&__end_time_clock, NULL); const uint64_t align64 __elapsed_time = (uint64_t)(((unsigned long long)((1000000UL * (unsigned long)__end_time_clock.tv_sec) + (unsigned long)__end_time_clock.tv_usec)) - ((unsigned long long)((1000000UL * (unsigned long)__start_time_clock.tv_sec) + (unsigned long)__start_time_clock.tv_usec))); puts2("Microseconds elapsed: "); putu64(__elapsed_time)
#endif


LIB_FUNC int clock_getcpuclockid(const pid_t pid, clockid_t* restrict clk) {
	struct timespec align64 ts = { 0 };
	clockid_t _id = (clockid_t)(((unsigned int)((-pid) - 1) * 8U) + 2);
	register int ret = (int)syscall2(SYS_clock_getres, (long)_id, (long)&ts);
	if (ret) { return -ret; }
	*clk = _id;
	return 0;
}


LIB_FUNC int timer_gettime(timer_t t, struct itimerspec* restrict val) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		t = (timer_t)(uintptr_t)(td->timer_id & INT_MAX);
	}
	return (int)syscall2(SYS_timer_gettime, (long)t, (long)val);
}


LIB_FUNC int timer_settime(timer_t t, const int flags, const struct itimerspec* restrict val, struct itimerspec* restrict old) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		t = (void*)(uintptr_t)(td->timer_id & INT_MAX);
	}
	return (int)syscall4(SYS_timer_settime, (long)t, flags, (long)val, (long)old);
}


LIB_FUNC int timer_delete(const timer_t t) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		a_store(&td->timer_id, (int)(td->timer_id | INT_MIN));
		wake((atomic volatile int*)&td->timer_id, 1, 1);
		return 0;
	}
	return (int)syscall1(SYS_timer_delete, (long)t);
}


/** Like `mktime`, but for TP represents Universal Time, not local time */
LIB_FUNC time_t timegm(struct tm* _tm) {
	struct tm new = { 0 };
	long long t = tm_to_secs(_tm);
	if (secs_to_tm(t, &new) < 0) {
		set_errno(EOVERFLOW);
		return -1;
	}
	*_tm = new;
	_tm->tm_isdst = 0;
	_tm->__tm_gmtoff = 0;
	_tm->__tm_zone = __gmt;
	return t;
}


LIB_FUNC void timeval50_to_timeval(const struct timeval50* ts50, struct timeval* ts) {
	ts->tv_sec = ts50->tv_sec; ts->tv_usec = (suseconds_t)ts50->tv_usec;
}


LIB_FUNC void timeval_to_timeval50(const struct timeval* ts, struct timeval50* ts50) {
	ts50->tv_sec = (long)ts->tv_sec; ts50->tv_usec = ts->tv_usec;
}


LIB_FUNC void timespec50_to_timespec(const struct timespec50* ts50, struct timespec* ts) {
	ts->tv_sec = ts50->tv_sec;
	ts->tv_nsec = ts50->tv_nsec;
}


LIB_FUNC void timespec_to_timespec50(const struct timespec* ts, struct timespec50* ts50) {
	ts50->tv_sec = (int32_t)ts->tv_sec;
	ts50->tv_nsec = ts->tv_nsec;
}


LIB_FUNC void itimerval50_to_itimerval(const struct itimerval50* ts50, struct itimerval* ts) {
	timeval50_to_timeval(&ts50->it_interval, &ts->it_interval);
	timeval50_to_timeval(&ts50->it_value, &ts->it_value);
}


LIB_FUNC void itimerval_to_itimerval50(const struct itimerval* ts, struct itimerval50* ts50) {
	timeval_to_timeval50(&ts->it_interval, &ts50->it_interval);
	timeval_to_timeval50(&ts->it_value, &ts50->it_value);
}


LIB_FUNC void itimerspec50_to_itimerspec(const struct itimerspec50* ts50, struct itimerspec* ts) {
	timespec50_to_timespec(&ts50->it_interval, &ts->it_interval);
	timespec50_to_timespec(&ts50->it_value, &ts->it_value);
}


LIB_FUNC void itimerspec_to_itimerspec50(const struct itimerspec* ts, struct itimerspec50* ts50) {
	timespec_to_timespec50(&ts->it_interval, &ts50->it_interval);
	timespec_to_timespec50(&ts->it_value, &ts50->it_value);
}


LIB_FUNC int realtime_gettime(struct timespec* tp) {
	struct timeval tv = { 0 };
	const int retval = gettimeofday(&tv, NULL);
	if (retval == 0) { TIMEVAL_TO_TIMESPEC(&tv, tp); }
	return retval;
}


/** Return processor time */
LIB_FUNC clock_t clock(void) {
	struct timespec ts = { 0 };
	if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts)) { return -1; }
	else if (ts.tv_sec > (LONG_MAX / 1000000) || (ts.tv_nsec / 1000) > (LONG_MAX - (1000000 * ts.tv_sec))) { return -1; }
	return ((ts.tv_sec * 1000000) + (ts.tv_nsec / 1000));
}


/** Return processor time as a float */
LIB_FUNC float clockf(void) {
	struct timespec ts = { 0 };
	if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts)) { return -1.0F; }
	else if (ts.tv_sec > (LONG_MAX / 1000000) || (ts.tv_nsec / 1000) > (LONG_MAX - (1000000 * ts.tv_sec))) { return -1.0F; }
	return (((float)ts.tv_sec * 1000000.0F) + ((float)ts.tv_nsec / 1000.0F));
}


/** Wait for the specified number of seconds (as an integer) */
LIB_FUNC void wait_sec(const int sec) {
	register const clock_t endwait = clock() + sec * CLOCKS_PER_SEC;
	while (clock() < endwait);
}


/** Wait the specified amount of seconds (as a double) */
LIB_FUNC void delay(const double sec) {
	const clock_t start = clock();  // Save first clock tick
	register clock_t current;
	do {
		current = clock();  // Current clock tick
	} while ((double)(current - start) < (sec * CLOCKS_PER_SEC));
}


/** Display a progress indicator that is based on a specified time in seconds to wait */
LIB_FUNC void wait_progress_indicator(const int sec) {
	if (chk_ferr(stdout)) { return; }
	register int progress = 0;
	register size_t len = 0;
	char progress_str[ANSI_SGR_CUR_START_LEN + 5] = ANSI_SGR_CUR_START "000%\0";
	(void)__stdio_write(stdout, (const unsigned char*)ANSI_SGR_CUR_START "0%\0", 3 + ANSI_SGR_CUR_START_LEN);
	register const clock_t endwait = clock() + (clock_t)(sec * CLOCKS_PER_SEC);
	while (clock() < endwait) {
		progress = (int)((float)(clockf() / ((float)endwait)) * 100.0F);
		ltodec(progress, &progress_str[ANSI_SGR_CUR_START_LEN]);
		len = strlen(&progress_str[ANSI_SGR_CUR_START_LEN]) + ANSI_SGR_CUR_START_LEN;
		progress_str[++len] = '%';
		progress_str[++len] = '\0';
		(void)__stdio_write(stdout, (const unsigned char*)progress_str, len);
	}
	puts_no_output(ANSI_SGR_CUR_START "100%");
}


/** Display a progress bar that is based on a specified time in seconds to wait */
LIB_FUNC void wait_progress_bar(const int sec) {
	if (chk_ferr(stdout)) { return; }
	register int progress = 0, hashes = 0;
	register size_t len = 0;
	char progress_str[ANSI_SGR_CUR_START_LEN + 32] = ANSI_SGR_CUR_START "[                         ]000%\0";
	(void)__stdio_write(stdout, (const unsigned char*)ANSI_SGR_CUR_START "[                         ]0%\0", 30 + ANSI_SGR_CUR_START_LEN);
	do_sync();
	register const clock_t endwait = clock() + (clock_t)(sec * CLOCKS_PER_SEC);
	while (clock() < endwait) {
		progress = (int)((float)(clockf() / ((float)endwait)) * 100.0F);
		if (progress < 1) { continue; }
		else if (progress > 100) { break; }
		for (hashes = (int)(progress / 4); (hashes >= 0) && (progress < 100); --hashes) {
			progress_str[ANSI_SGR_CUR_START_LEN + 1 + hashes] = '#';
		}
		itodec(progress, &progress_str[ANSI_SGR_CUR_START_LEN + 27]);
		len = strlen(&progress_str[ANSI_SGR_CUR_START_LEN + 27]) + ANSI_SGR_CUR_START_LEN + 27;
		progress_str[++len] = '%';
		progress_str[++len] = '\0';
		(void)__stdio_write(stdout, (const unsigned char*)progress_str, len);
	}
	puts_no_output(ANSI_SGR_CUR_START "[#########################]100%");
}


/** Return wall-clock time */
LIB_FUNC time_t time(time_t* restrict t) {
	struct timespec ts = { 0 };
	clock_gettime(CLOCK_REALTIME, &ts);
	if (t) { *t = ts.tv_sec; }
	return ts.tv_sec;
}
#define sys_time(x)   time((x))


/** Return date and time */
LIB_FUNC int ftime(struct timeb* tp) {
	struct timespec ts = { 0 };
	clock_gettime(CLOCK_REALTIME, &ts);
	tp->time = ts.tv_sec;
	tp->millitm = (unsigned short)(ts.tv_nsec / 1000000);
	tp->timezone = tp->dstflag = 0;
	return 0;
}


LIB_FUNC const unsigned char* __map_file(const char* restrict pathname, size_t* size) {
	struct stat st = { 0 };
	const unsigned char* map = MAP_FAILED;
	int fd = (int)syscall2(SYS_open, (long)pathname, (O_RDONLY | O_CLOEXEC | O_NONBLOCK));
	if (fd < 0) { return 0; }
	else if (!(syscall2(SYS_fstat, fd, (long)&st))) {
		map = mmap(0, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
		*size = (size_t)st.st_size;
	}
	syscall1(SYS_close, fd);
	return (const unsigned char*)(map == MAP_FAILED ? 0 : map);
}


/** Determine the time zone in effect for a given time in seconds since the epoch; It can be given in local or universal time */
LIB_FUNC void secs_to_zone(long long t, int local, int* isdst, long* offset, long* oppoff, const char** zonename) {
	LOCK(tmlock);
	do_tzset();
	if (zi) {
		size_t alt = 0, i = (size_t)scan_trans(t, local, &alt);
		if (i != (size_t)-1) {
			*isdst = types[6 * i + 4];
			*offset = (int32_t)zi_read32(types + 6 * i);
			*zonename = (const char*)abbrevs + types[6 * i + 5];
			if (oppoff) { *oppoff = (int32_t)zi_read32(types + 6 * alt); }
			UNLOCK(tmlock);
			return;
		}
	}
	if (!(__daylight)) {
		*isdst = 0;
		*offset = -__timezone;
		if (oppoff) { *oppoff = -dst_off; }
		*zonename = __tzname[0];
		UNLOCK(tmlock);
		return;
	}
	long long y = (long long)(t / 31556952 + 70);
	while (year_to_secs(y, 0) > t) { --y; }
	while (year_to_secs((y + 1), 0) < t) { ++y; }
	long long t0 = rule_to_secs(r0, (int)y);
	long long t1 = rule_to_secs(r1, (int)y);
	if (t0 < t1) {
		if (!local) {
			t0 += __timezone;
			t1 += dst_off;
		}
		if (t >= t0 && t < t1) {
			*isdst = 1;
			*offset = -dst_off;
			if (oppoff) { *oppoff = -__timezone; }
			*zonename = __tzname[1];
			UNLOCK(tmlock);
			return;
		}
		*isdst = 0;
		*offset = -__timezone;
		if (oppoff) { *oppoff = -dst_off; }
		*zonename = __tzname[0];
		UNLOCK(tmlock);
		return;
	} else {
		if (!local) {
			t1 += __timezone;
			t0 += dst_off;
		}
		if (t >= t1 && t < t0) {
			*isdst = 0;
			*offset = -__timezone;
			if (oppoff) { *oppoff = -dst_off; }
			*zonename = __tzname[0];
			UNLOCK(tmlock);
			return;
		}
		*isdst = 1;
		*offset = -dst_off;
		if (oppoff) { *oppoff = -__timezone; }
		*zonename = __tzname[1];
		UNLOCK(tmlock);
		return;
	}
	UNREACHABLE
}
#define __secs_to_zone(t, local, isdst, offset, oppoff, zonename)   secs_to_zone((t), (local), (isdst), (offset), (oppoff), (zonename))


LIB_FUNC struct tm* gmtime(const time_t* t) {
	static struct tm _tm = { 0 };
	return gmtime_r(t, &_tm);
}


LIB_FUNC struct tm* gmtime_r(const time_t* restrict t, struct tm* restrict _tm) {
	if (secs_to_tm(*t, _tm) < 0) {
		set_errno(EOVERFLOW);
		return 0;
	}
	_tm->tm_isdst = 0;
	_tm->__tm_gmtoff = 0;
	_tm->__tm_zone = __gmt;
	return _tm;
}
#define __gmtime_r(t, _tm)   gmtime_r((t), (_tm))


LIB_FUNC uint32_t zi_read32(const unsigned char* z) {
	return (uint32_t)((unsigned)z[0] << 24 | (unsigned)z[1] << 16 | (unsigned)z[2] << 8 | (unsigned)z[3]);
}


LIB_FUNC size_t zi_dotprod(const unsigned char* z, const unsigned char* v, size_t n) {
	register size_t y = 0;
	register uint32_t x = 0;
	for (y = 0; n; n--, z += 4, v++) {
		x = zi_read32(z);
		y += (x * (*v));
	}
	return y;
}


LIB_FUNC time_t mktime(struct tm* _tm) {
	struct tm new = { 0 };
	long opp = 0;
	long long t = tm_to_secs(_tm);
	__secs_to_zone(t, 1, &new.tm_isdst, &new.__tm_gmtoff, &opp, &new.__tm_zone);
	if (_tm->tm_isdst>=0 && new.tm_isdst!=_tm->tm_isdst) { t -= (long long)(opp - new.__tm_gmtoff); }
	t -= new.__tm_gmtoff;
	if ((time_t)t != t) { set_errno(EOVERFLOW); return -1; }
	secs_to_zone(t, 0, &new.tm_isdst, &new.__tm_gmtoff, &opp, &new.__tm_zone);
	if (secs_to_tm(t + new.__tm_gmtoff, &new) < 0) { set_errno(EOVERFLOW); return -1; }
	*_tm = new;
	return t;
}


LIB_FUNC void do_tzset(void) {
	char buf[NAME_MAX + 25] = { 0 }, *pathname = buf + 24;
	const char *try = NULL, *s = NULL, *p = NULL;
	const unsigned char* map = 0;
	const char search[64] = "/usr/share/zoneinfo/\0/share/zoneinfo/\0/etc/zoneinfo/\0";
	s = getenv("TZ");
	if (!s) { s = "/etc/localtime"; }
	else if (!*s) { s = __gmt; }
	if (old_tz && (!strcmp(s, old_tz))) { return; }
	else if (zi) { munmap_const((const void*)zi, map_size); }
	register size_t i = strlen(s);
	if (i > PATH_MAX + 1) { s = __gmt, i = 3; }
	if (i >= old_tz_size) {
		old_tz_size *= 2;
		if (i >= old_tz_size) { old_tz_size = i + 1; }
		if (old_tz_size > PATH_MAX + 2) { old_tz_size = PATH_MAX + 2; }
		old_tz = malloc(old_tz_size);
	}
	if (old_tz) { memcpy_no_output(old_tz, s, (i + 1)); }
	// Non-suid can use an absolute tzfile pathname or a relative pathame beginning with "."; in secure mode, only the standard path will be searched
	if (*s == ':' || ((p = strchr(s, '/')) && !(memchr(s, ',', (size_t)(p - s))))) {
		if (*s == ':') { s++; }
		if (*s == '/' || *s == '.') {
			if (!libc.secure || !(strcmp(s, "/etc/localtime"))) {
				map = __map_file(s, &map_size);
			}
		} else {
			size_t l = strlen(s);
			if (l <= NAME_MAX && !(strchr(s, '.'))) {
				memcpy_no_output(pathname, s, (l + 1));
				pathname[l] = 0;
				for (try = search; !(map) && *try; try += l + 1) {
					l = strlen(try);
					memcpy_no_output((pathname - l), try, l);
					map = __map_file((pathname - l), &map_size);
				}
			}
		}
		if (!map) { s = __gmt; }
	}
	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
		munmap_const((const void*)map, map_size);
		map = 0;
		s = __gmt;
	}
	zi = map;
	if (map) {
		int scale = 2;
		if (SIZEOF_TIME_T > 4 && map[4] == '2') {
			size_t skip = zi_dotprod((zi + 20), VEC(1, 1, 8, 5, 6, 1), 6);
			trans = zi + skip + 88;
			++scale;
		} else { trans = zi + 44; }
		types = (unsigned char*)(((uintptr_t)trans + (zi_read32(trans - 12) << scale)) + zi_read32(trans - 12));
		abbrevs = (types + 6 * zi_read32(trans - 8));
		abbrevs_end = (abbrevs + zi_read32(trans - 4));
		if (zi[map_size - 1] == '\n') {
			for (s = (const char*)zi + map_size - 2; *s != '\n'; --s);
			++s;
		} else {
			const unsigned char* p = NULL;
			__tzname[0] = __tzname[1] = 0;
			__daylight = 0;
			__timezone = dst_off = 0;
			for (i = 0; i < 5; i++) { rule0[i] = rule1[i] = 0; }
			for (p = types; p < abbrevs; p += 6) {
				if (!p[4] && !(__tzname[0])) {
					__tzname[0] = (char*)abbrevs + p[5];
					__timezone = -zi_read32(p);
				}
				if (p[4] && !(__tzname[1])) {
					__tzname[1] = (char*)abbrevs + p[5];
					dst_off = -zi_read32(p);
					__daylight = 1;
				}
			}
			if (!__tzname[0]) { __tzname[0] = __tzname[1]; }
			if (!__tzname[0]) { __tzname[0] = (char*)__gmt; }
			if (!__daylight) {
				__tzname[1] = __tzname[0];
				dst_off = __timezone;
			}
			return;
		}
	}
	if (!s) { s = __gmt; }
	getname(std_name, &s);
	__tzname[0] = std_name;
	__timezone = getoff(&s);
	getname(dst_name, &s);
	__tzname[1] = dst_name;
	if (dst_name[0]) {
		__daylight = 1;
		if (*s == '+' || *s == '-' || (unsigned int)(*s - '0') < 10U) { dst_off = getoff(&s); }
		else { dst_off = __timezone - 3600; }
	} else {
		__daylight = 0;
		dst_off = 0;
	}
	if (*s == ',') { s++, getrule(&s, rule0); }
	if (*s == ',') { s++, getrule(&s, rule1); }
}


/** Search zoneinfo rules to find the one that applies to the given time, and determine alternate opposite-DST-status rule that may be needed */
LIB_FUNC size_t scan_trans(long long t, int local, size_t* alt) {
	int scale = (int)(3 - (trans == zi + 44));
	uint64_t x = 0U;
	int off = 0;
	size_t a = 0, n = (size_t)((time_index - trans) >> scale), m;
	if (!n) {
		if (alt) { *alt = 0; }
		return 0;
	}
	while (n > 1) {  // Binary search for 'most-recent rule before t'
		m = (a + n) >> 1;
		x = zi_read32(trans + (m << scale));
		if (scale == 3) { x = (x << 32 | zi_read32(trans + (m << scale) + 4)); }
		else { x = (uint64_t)((int32_t)x); }
		if (local) { off = (int)zi_read32(types + 6 * time_index[m - 1]); }
		if ((int64_t)(t - off) < (int64_t)x) {
			n /= 2;
		} else {
			a = m;
			n -= (n / 2);
		}
	}
	n = (size_t)((time_index - trans) >> scale);
	if (a == (n - 1)) { return (size_t)-1; }
	else if (a == 0) {
		x = zi_read32(trans + (a << scale));
		if (scale == 3) { x = (x << 32 | zi_read32(trans + (a << scale) + 4)); }
		else { x = (uint64_t)((int32_t)x); }
		if (local) { off = (int32_t)zi_read32(types + 6 * time_index[a - 1]); }
		if (t - off < (int64_t)x) {
			for (a = 0; a < (size_t)((abbrevs - types) / 6); a++) {
				if (types[6 * a + 4] != types[4]) { break; }
			}
			if (a == (size_t)((abbrevs - types) / 6)) { a = 0; }
			if (types[6 * a + 4]) {
				*alt = a;
				return 0;
			} else {
				*alt = 0;
				return a;
			}
			UNREACHABLE
		}
	}
	if (alt) {  // Try to find a neighboring opposite-DST-status rule
		if (a && types[6 * time_index[a - 1] + 4] != types[6 * time_index[a] + 4]) { *alt = time_index[a - 1]; }
		else if (a + 1 < n && types[6 * time_index[a + 1] + 4] != types[6 * time_index[a] + 4]) { *alt = time_index[a + 1]; }
		else { *alt = time_index[a]; }
	}
	return time_index[a];
}


LIB_FUNC void tzset(void) {
	LOCK(tmlock);
	do_tzset();
	UNLOCK(tmlock);
}
#define __tzset()   tzset()


LIB_FUNC size_t strftime_l(char* restrict s, size_t n, const char* restrict f, const struct tm* restrict _tm, locale_t loc) {
	size_t l = 0, k = 0;
	char buf[100] = { 0 };
	const char* p = NULL;
	const char* t = NULL;
	int plus = 0;
	unsigned long width = 0U;
	for (l = 0; l < n; f++) {
		if (!(*f)) {
			s[l] = 0;
			return l;
		} else if (*f != '%') {
			s[l++] = *f;
			continue;
		}
		++f;
		if ((plus = (*f == '+'))) { f++; }
		width = strtoul(f, &p, 10);
		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
			if (!width && p != f) { width = 1; }
		} else {
			width = 0;
		}
		f = p;
		if (*f == 'E' || *f == 'O') { f++; }
		t = strftime_fmt_1(&buf, &k, *f, _tm, loc);
		if (!t) { break; }
		if (width) {
			for (; *t == '+' || *t == '-' || (*t == '0' && t[1]); t++, k--);
			width--;
			if (plus && _tm->tm_year >= 8100) { s[l++] = '+'; }
			else if (_tm->tm_year < -1900) { s[l++] = '-'; }
			else { width++; }
			for (; width > k && l < n; width--) { s[l++] = '0'; }
		}
		if (k > n - l) { k = n - l; }
		memcpy_no_output((s + l), t, k);
		l += k;
	}
	if (n) {
		if (l == n) { l = n - 1; }
		s[l] = 0;
	}
	return 0;
}
#define __strftime_l(s, n, f, _tm, loc)   strftime_l((s), (n), (f), (_tm), (loc))


LIB_FUNC size_t strftime(char* restrict s, size_t n, const char* restrict f, const struct tm* restrict _tm) {
	return __strftime_l(s, n, f, _tm, CURRENT_LOCALE);
}


LIB_FUNC const char* strftime_fmt_1(char (*s)[100], size_t* l, int f, const struct tm* _tm, locale_t loc) {
	nl_item item = 0;
	long long val = 0;
	const char* frmt = "-";
	int width = 2;
	switch (f) {
		case 'a':
			if (_tm->tm_wday > 6) { goto goto_strftime_fmt_1_strftime_string; }
			item = ABDAY_1 + _tm->tm_wday;
			goto goto_strftime_fmt_1_nl_strcat;
		case 'A':
			if (_tm->tm_wday > 6) { goto goto_strftime_fmt_1_strftime_string; }
			item = DAY_1 + _tm->tm_wday;
			goto goto_strftime_fmt_1_nl_strcat;
		case 'h':
		case 'b':
			if (_tm->tm_mon > 11) { goto goto_strftime_fmt_1_strftime_string; }
			item = ABMON_1 + _tm->tm_mon;
			goto goto_strftime_fmt_1_nl_strcat;
		case 'B':
			if (_tm->tm_mon > 11) { goto goto_strftime_fmt_1_strftime_string; }
			item = MON_1 + _tm->tm_mon;
			goto goto_strftime_fmt_1_nl_strcat;
		case 'c':
			item = D_T_FMT;
			goto goto_strftime_fmt_1_nl_strftime;
		case 'C':
			val = (1900LL + _tm->tm_year) / 100;
			goto goto_strftime_fmt_1_number;
		case 'd':
			val = _tm->tm_mday;
			goto goto_strftime_fmt_1_number;
		case 'D':
			frmt = "%m/%d/%y";
			goto goto_strftime_fmt_1_recu_strftime;
		case 'e':
			*l = (size_t)snprintf(*s, sizeof(*s), "%2d", _tm->tm_mday);
			return *s;
		case 'F':
			frmt = "%Y-%m-%d";
			goto goto_strftime_fmt_1_recu_strftime;
		case 'g':
		case 'G':
			val = _tm->tm_year + 1900LL;
			if (_tm->tm_yday < 3 && week_num(_tm) != 1) { val--; }
			else if (_tm->tm_yday > 360 && week_num(_tm) == 1) { val++; }
			if (f == 'g') { val %= 100; }
			else { width = 4; }
			goto goto_strftime_fmt_1_number;
		case 'H':
			val = _tm->tm_hour;
			goto goto_strftime_fmt_1_number;
		case 'I':
			val = _tm->tm_hour;
			if (!val) { val = 12; }
			else if (val > 12) { val -= 12; }
			goto goto_strftime_fmt_1_number;
		case 'j':
			val = _tm->tm_yday + 1;
			width = 3;
			goto goto_strftime_fmt_1_number;
		case 'm':
			val = _tm->tm_mon + 1;
			goto goto_strftime_fmt_1_number;
		case 'M':
			val = _tm->tm_min;
			goto goto_strftime_fmt_1_number;
		case 'n':
			*l = 1;
			return "\n";
		case 'p':
			item = (_tm->tm_hour >= 12 ? PM_STR : AM_STR);
			goto goto_strftime_fmt_1_nl_strcat;
		case 'r':
			item = T_FMT_AMPM;
			goto goto_strftime_fmt_1_nl_strftime;
		case 'R':
			frmt = "%H:%M";
			goto goto_strftime_fmt_1_recu_strftime;
		case 's':
			val = (__tm_to_secs(_tm) - _tm->__tm_gmtoff);
			width = 1;
			goto goto_strftime_fmt_1_number;
		case 'S':
			val = _tm->tm_sec;
			goto goto_strftime_fmt_1_number;
		case 't':
			*l = 1;
			return "\t";
		case 'T':
			frmt = "%H:%M:%S";
			goto goto_strftime_fmt_1_recu_strftime;
		case 'u':
			val = (_tm->tm_wday ? _tm->tm_wday : 7);
			width = 1;
			goto goto_strftime_fmt_1_number;
		case 'U':
			val = (_tm->tm_yday + 7 - _tm->tm_wday) / 7;
			goto goto_strftime_fmt_1_number;
		case 'W':
			val = (_tm->tm_yday + 7 - (_tm->tm_wday + 6) % 7) / 7;
			goto goto_strftime_fmt_1_number;
		case 'V':
			val = week_num(_tm);
			goto goto_strftime_fmt_1_number;
		case 'w':
			val = _tm->tm_wday;
			width = 1;
			goto goto_strftime_fmt_1_number;
		case 'x':
			item = D_FMT;
			goto goto_strftime_fmt_1_nl_strftime;
		case 'X':
			item = T_FMT;
			goto goto_strftime_fmt_1_nl_strftime;
		case 'y':
			val = _tm->tm_year % 100;
			goto goto_strftime_fmt_1_number;
		case 'Y':
			val = _tm->tm_year + 1900LL;
			if (val >= 10000) {
				*l = (size_t)snprintf(*s, sizeof(*s), "+%lld", val);
				return *s;
			}
			width = 4;
			goto goto_strftime_fmt_1_number;
		case 'z':
			if (_tm->tm_isdst < 0) {
				*l = 0;
				return "";
			}
			*l = (size_t)snprintf(*s, sizeof(*s), "%+.2d%.2d", (int)((_tm->__tm_gmtoff) / 3600), (int)(abs(_tm->__tm_gmtoff % 3600) / 60));
			return *s;
		case 'Z':
			if (_tm->tm_isdst < 0) {
				*l = 0;
				return "";
			}
			frmt = __tm_to_tzname(_tm);
			goto goto_strftime_fmt_1_strftime_string;
		case '%':
			*l = 1;
			return "%";
		default:
			return 0;
	}
goto_strftime_fmt_1_number:
	*l = (size_t)snprintf(*s, sizeof(*s), "%0*lld", width, val);
	return *s;
goto_strftime_fmt_1_nl_strcat:
	frmt = __nl_langinfo_l(item, loc);
goto_strftime_fmt_1_strftime_string:
	*l = strlen(frmt);
	return frmt;
goto_strftime_fmt_1_nl_strftime:
	frmt = __nl_langinfo_l(item, loc);
goto_strftime_fmt_1_recu_strftime:
	*l = __strftime_l(*s, sizeof(*s), frmt, _tm, loc);
	if (!*l) { return 0; }
	return *s;
}
#define __strftime_fmt_1(s, l, f, _tm, loc)   strftime_fmt_1((s), (l), (f), (_tm), (loc))


LIB_FUNC int stime(const time_t* when) {
	if (when == NULL) { set_errno(EINVAL); return -1; }
	struct timeval tv = { .tv_sec = (time_t)*when, .tv_usec = (suseconds_t)0 };
	return settimeofday(&tv, (struct timezone_struct*)0);
}


LIB_FUNC struct tm* localtime_r(const time_t* restrict t, struct tm* restrict _tm) {
	if (*t < INT_MIN * 31622400LL || *t > INT_MAX * 31622400LL) {
		set_errno(EOVERFLOW);
		return 0;
	}
	__secs_to_zone(*t, 0, &_tm->tm_isdst, &_tm->__tm_gmtoff, 0, &_tm->__tm_zone);
	if (__secs_to_tm((long long)*t + _tm->__tm_gmtoff, _tm) < 0) {
		set_errno(EOVERFLOW);
		return 0;
	}
	return _tm;
}
#define __localtime_r(t, _tm)   localtime_r((t), (_tm))


LIB_FUNC struct tm* localtime(const time_t* t) {
	static struct tm _tm = { 0 };
	return localtime_r(t, &_tm);
}


LIB_FUNC char* __asctime(const struct tm* restrict _tm, char* restrict buf) {
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n", __nl_langinfo(ABDAY_1 + _tm->tm_wday), __nl_langinfo(ABMON_1 + _tm->tm_mon), _tm->tm_mday, _tm->tm_hour, _tm->tm_min, _tm->tm_sec, 1900 + _tm->tm_year) >= 26) { a_crash(); }
	return buf;
}


LIB_FUNC char* asctime_r(const struct tm* restrict _tm, char* restrict buf) {
	return __asctime(_tm, buf);
}


LIB_FUNC char* asctime(const struct tm* _tm) {
	static char buf[26] = { 0 };
	return __asctime(_tm, buf);
}


LIB_FUNC char* ctime_r(const time_t* t, char* buf) {
	struct tm _tm = { 0 };
	localtime_r(t, &_tm);
	return __asctime(&_tm, buf);
}


LIB_FUNC char* ctime(const time_t* t) {
	static char buf[26] = { 0 };
	return __asctime(localtime(t), buf);
}


/** There is no other implemented value than TIME_UTC; all other values are considered erroneous */
LIB_FUNC int timespec_get(struct timespec* ts, const int base) {
	if (base != TIME_UTC) { return 0; }
	register int ret = __clock_gettime(CLOCK_REALTIME, ts);
	return ((ret < 0) ? 0 : base);
}


#define OFFSETOF_TM_YDAY   28
LIB_FUNC const char* strptime(const char* restrict s, const char* f, struct tm* restrict _tm) {
	int i = 0, w = 0, neg = 0, adj = 0, min = 0, range = 0, *dest = NULL, _dummy = 0;
	const char* ex = NULL;
	size_t len = 0;
	int want_century = 0, century = 0;
	while (*f) {
		if (*f != '%') {
			if (isspace(*f)) { for (; *s && isspace(*s); s++); }
			else if (*s != *f) { return 0; }
			else { ++s; }
			++f;
			continue;
		}
		++f;
		if (*f == '+') { ++f; }
		if (isdigit(*f)) { w = (int)strtoul(f, (void*)&f, 10); }
		else { w = -1; }
		adj = 0;
		switch (*f++) {
			case 'a':
			case 'A':
				dest = &_tm->tm_wday;
				min = ABDAY_1;
				range = 7;
				goto goto_strptime_symbolic_range;
			case 'b':
			case 'B':
			case 'h':
				dest = &_tm->tm_mon;
				min = ABMON_1;
				range = 12;
				goto goto_strptime_symbolic_range;
			case 'c':
				s = strptime(s, nl_langinfo(D_T_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'C':
				dest = &century;
				if (w < 0) { w = 2; }
				want_century |= 2;
				goto goto_strptime_numeric_digits;
			case 'd':
			case 'e':
				dest = &_tm->tm_mday;
				min = 1;
				range = 31;
				goto goto_strptime_numeric_range;
			case 'D':
				s = strptime(s, "%m/%d/%y", _tm);
				if (!s) { return 0; }
				break;
			case 'H':
				dest = &_tm->tm_hour;
				min = 0;
				range = 24;
				goto goto_strptime_numeric_range;
			case 'I':
				dest = &_tm->tm_hour;
				min = 1;
				range = 12;
				goto goto_strptime_numeric_range;
			case 'j':
				dest = &_tm->tm_yday;
				min = 1;
				range = 366;
				goto goto_strptime_numeric_range;
			case 'm':
				dest = &_tm->tm_mon;
				min = 1;
				range = 12;
				adj = 1;
				goto goto_strptime_numeric_range;
			case 'M':
				dest = &_tm->tm_min;
				min = 0;
				range = 60;
				goto goto_strptime_numeric_range;
			case 'n':
			case 't':
				for (; *s && isspace(*s); s++);
				break;
			case 'p':
				ex = nl_langinfo(AM_STR);
				len = strlen(ex);
				if (!(strncasecmp(s, ex, len))) {
					_tm->tm_hour %= 12;
					break;
				}
				ex = nl_langinfo(PM_STR);
				len = strlen(ex);
				if (!(strncasecmp(s, ex, len))) {
					_tm->tm_hour %= 12;
					_tm->tm_hour += 12;
					break;
				}
				return 0;
			case 'r':
				s = strptime(s, nl_langinfo(T_FMT_AMPM), _tm);
				if (!s) { return 0; }
				break;
			case 'R':
				s = strptime(s, "%H:%M", _tm);
				if (!s) { return 0; }
				break;
			case 'S':
				dest = &_tm->tm_sec;
				min = 0;
				range = 61;
				goto goto_strptime_numeric_range;
			case 'T':
				s = strptime(s, "%H:%M:%S", _tm);
				if (!s) { return 0; }
				break;
			case 'U':
			case 'W':
				dest = &_dummy;
				min = 0;
				range = 54;
				goto goto_strptime_numeric_range;
			case 'w':
				dest = &_tm->tm_wday;
				min = 0;
				range = 7;
				goto goto_strptime_numeric_range;
			case 'x':
				s = strptime(s, nl_langinfo(D_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'X':
				s = strptime(s, nl_langinfo(T_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'y':
				dest = &_tm->tm_year;
				w = 2;
				want_century |= 1;
				goto goto_strptime_numeric_digits;
			case 'Y':
				dest = &_tm->tm_year;
				if (w < 0) { w = 4; }
				adj = 1900;
				want_century = 0;
				goto goto_strptime_numeric_digits;
			case '%':
				if (*s++ != '%') { return 0; }
				break;
			default:
				return 0;
goto_strptime_numeric_range:
				if (!isdigit(*s)) { return 0; }
				*dest = 0;
				for (i = 1; i <= (min + range) && isdigit(*s); i *= 10) {
					*dest = ((*dest * 10) + (*s++ - '0'));
				}
				if ((*dest - min) >= range) { return 0; }
				*dest -= adj;
				switch ((char*)dest - (char*)_tm) {
					case OFFSETOF_TM_YDAY: break;
					default: goto goto_strptime_update;
				}
				goto goto_strptime_update;
goto_strptime_numeric_digits:
				neg = 0;
				if (*s == '+') { s++; }
				else if (*s == '-') { neg = 1; s++; }
				if (!isdigit(*s)) { return 0; }
				for (*dest = i = 0; i < w && isdigit(*s); i++) { *dest = *dest * 10 + *s++ - '0'; }
				if (neg) { *dest = -*dest; }
				*dest -= adj;
				goto goto_strptime_update;
goto_strptime_symbolic_range:
				for (i = 2 * range - 1; i >= 0; i--) {
					ex = nl_langinfo(min + i);
					len = strlen(ex);
					if (strncasecmp(s, ex, len)) { continue; }
					s += len;
					*dest = i % range;
					break;
				}
				if (i < 0) { return 0; }
				goto goto_strptime_update;
goto_strptime_update:
				;
		}
	}
	if (want_century) {
		if (want_century & 2) { _tm->tm_year += (century * 100 - 1900); }
		else if (_tm->tm_year <= 68) { _tm->tm_year += 100; }
	}
	return (const char*)s;
}


LIB_FUNC struct tm* getdate(const char* s) {
	static struct tm align64 tmbuf = { 0 };
	struct tm* ret = 0;
	const char* datemsk = getenv("DATEMSK");
	char align64 fmt[100] = { 0 };
	const char* p = NULL;
	int cs = 0;
	pthread_setcancelstate(PTHREAD_CANCEL_DEFERRED, &cs);
	if (!datemsk) {
		getdate_err = 1;
		pthread_setcancelstate(cs, 0);
		return ret;
	}
	FILE* f = fopen(datemsk, "rbe");
	if (!f) {
		if (eq_errno(ENOMEM)) { getdate_err = 6; }
		else { getdate_err = 2; }
		goto goto_getdate_out;
	}
	while (fgets(fmt, sizeof(fmt), f)) {
		p = strptime(s, fmt, &tmbuf);
		if (p && !(*p)) {
			ret = &tmbuf;
			goto goto_getdate_out;
		}
	}
	getdate_err = 7;
goto_getdate_out:
	if (f) { fclose(f); }
	pthread_setcancelstate(cs, 0);
	return ret;
}


LIB_FUNC int utimensat(const int fd, const char* path, const struct timespec times[2], const int flags) {
	int r = (int)syscall4(SYS_utimensat, fd, (long)path, (long)times, flags);
#   ifdef SYS_futimesat
	if (neq_errno(ENOSYS) || flags) { return r; }
	struct timeval* tv = 0, tmp[2] = { { 0 }, { 0 } };
	if (times) {
		int i = 0;
		tv = tmp;
		for (; i < 2; i++) {
			if (times[i].tv_nsec >= (long)1000000000ULL) {
				if (times[i].tv_nsec == UTIME_NOW && times[1 - i].tv_nsec == UTIME_NOW) {
					tv = 0;
					break;
				}
				if (times[i].tv_nsec == UTIME_OMIT) {
					set_errno(ENOSYS);
					return -1;
				}
				set_errno(EINVAL);
				return -1;
			}
			tmp[i].tv_sec = times[i].tv_sec;
			tmp[i].tv_usec = times[i].tv_nsec / 1000;
		}
	}
	r = (int)syscall3(SYS_futimesat, fd, (long)path, (long)tv);
	if (neq_errno(ENOSYS) || fd != AT_FDCWD) { return r; }
	r = (int)syscall2(SYS_utimes, (long)path, (long)tv);
#   endif
	return r;
}


LIB_FUNC int lutimes(const char* filename, const struct timeval tv[2]) {
	struct timespec times[2] = { { .tv_sec = tv[0].tv_sec, .tv_nsec = tv[0].tv_usec * 1000 }, { .tv_sec = tv[1].tv_sec, .tv_nsec = tv[1].tv_usec * 1000 } };
	return utimensat(AT_FDCWD, filename, times, AT_SYMLINK_NOFOLLOW);
}


LIB_FUNC int futimens(int fd, const struct timespec times[2]) {
	return utimensat(fd, 0, times, 0);
}


LIB_FUNC int futimes(int fd, const struct timeval tv[2]) {
	if (!tv) { return futimens(fd, 0); }
	struct timespec times[2] = { { .tv_sec = tv[0].tv_sec, .tv_nsec = tv[0].tv_usec * 1000 }, { .tv_sec = tv[1].tv_sec, .tv_nsec = tv[1].tv_usec * 1000 } };
	return futimens(fd, times);
}


LIB_FUNC int futimesat(int dirfd, const char* pathname, const struct timeval times[2]) {
	struct timespec ts[2] = { { 0 }, { 0 } };
	if (times) {
		register int i = 0;
		for (; i < 2; i++) {
			if (times[i].tv_usec >= (long)1000000ULL) {
				set_errno(EINVAL);
				return -1;
			}
			ts[i].tv_sec = times[i].tv_sec;
			ts[i].tv_nsec = times[i].tv_usec * 1000;
		}
	}
	return utimensat(dirfd, pathname, (times ? ts : 0), 0);
}
#define __futimesat(dirfd, pathname, times)   futimesat((dirfd), (pathname), (times))


LIB_FUNC int utimes(const char* path, const struct timeval times[2]) {
	return futimesat(AT_FDCWD, path, times);
}


LIB_FUNC void bintime_addx(struct bintime* bt, uint64_t x) {
	const uint64_t u = bt->frac;
	bt->frac += x;
	if (u > bt->frac) { ++bt->sec; }
}


LIB_FUNC void bintime_add(struct bintime* bt, const struct bintime* bt2) {
	const uint64_t u = bt->frac;
	bt->frac += bt2->frac;
	if (u > bt->frac) { ++bt->sec; }
	bt->sec += bt2->sec;
}


LIB_FUNC void bintime_sub(struct bintime* bt, const struct bintime* bt2) {
	const uint64_t u = bt->frac;
	bt->frac -= bt2->frac;
	if (u < bt->frac) { --bt->sec; }
	bt->sec -= bt2->sec;
}


#define bintimecmp(bta, btb, cmp)   (((bta)->sec == (btb)->sec) ? ((bta)->frac cmp (btb)->frac) : ((bta)->sec cmp (btb)->sec))


LIB_FUNC void bintime2timespec(const struct bintime* bt, struct timespec* ts) {
	ts->tv_sec = bt->sec;
	ts->tv_nsec = (long)(((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}


LIB_FUNC void timespec2bintime(const struct timespec* ts, struct bintime* bt) {
	bt->sec = ts->tv_sec;
	bt->frac = (uint64_t)ts->tv_nsec * (uint64_t)18446744073ULL;
}


LIB_FUNC void bintime2timeval(const struct bintime* bt, struct timeval* tv) {
	tv->tv_sec = bt->sec;
	tv->tv_usec = (suseconds_t)(((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}


LIB_FUNC void timeval2bintime(const struct timeval* tv, struct bintime* bt) {
	bt->sec = tv->tv_sec;
	bt->frac = (uint64_t)tv->tv_usec * (uint64_t)18446744073709ULL;
}


LIB_FUNC struct bintime ms2bintime(const uint64_t ms) {
	const struct bintime bt = { .sec = (time_t)(ms / 1000U), .frac = (uint64_t)((((ms % 1000U) >> 32) / 1000U) >> 32) };
	return bt;
}


LIB_FUNC struct bintime us2bintime(const uint64_t us) {
	const struct bintime bt = { .sec = (time_t)(us / 1000000U), .frac = (uint64_t)((((us % 1000000U) >> 32) / 1000000U) >> 32) };
	return bt;
}


LIB_FUNC struct bintime ns2bintime(const uint64_t ns) {
	const struct bintime bt = { .sec = (time_t)(ns / 1000000000U), .frac = (uint64_t)((((ns % 1000000000U) >> 32) / 1000000000U) >> 32) };
	return bt;
}


#ifdef OSPOSIX
/**
@brief Return the current time in microseconds since the epoch
@return The number of microseconds since the epoch to now
*/
LIB_FUNC unsigned long time_microseconds(void) {
	struct timeval now = { 0 };
	gettimeofday(&now, NULL);
	return (unsigned long)((1000000UL * (unsigned long)now.tv_sec) + (unsigned long)now.tv_usec);
}
#endif


/**
@brief Return the current time in seconds since the epoch
@return The number of seconds since the epoch to now
*/
LIB_FUNC unsigned long time_seconds(void) {
	time_t timer;
	return (unsigned long)time(&timer);
}


/* TODO: Add time functions
// Another name for `mktime`
extern time_t timelocal (struct tm *__tp) __THROW;
// Return the number of days in YEAR
extern const int dysize (int __year) __THROW;
extern int getdate_r (const char* restrict __string, struct tm* restrict __resbufp);
*/


#endif  // TIME_H


/* FILE ACCESS AND MODIFICATION TIMES (<sys/times.h>) */


#if (!(defined(SYS_TIMES_H) || defined(_SYS_TIMES_H) || defined(SYS_TIMES_H_) || defined(_SYS_TIMES_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_times.h.html
#define SYS_TIMES_H   (1)
#define _SYS_TIMES_H   (1)
#define SYS_TIMES_H_   (1)
#define _SYS_TIMES_H_   (1)


typedef struct tms {
	clock_t tms_utime;  //!< User CPU time
	clock_t tms_stime;  //!< System CPU time
	clock_t tms_cutime;  //!< User CPU time of terminated child processes
	clock_t tms_cstime;  //!< System CPU time of terminated child processes
} tms_t;


LIB_FUNC clock_t times(struct tms* _tms) {
	return (clock_t)syscall1(SYS_times, (long)&_tms);
}


#endif  // SYS_TIMES_H


/* ACCESS AND MODIFICATION TIME (<utime.h>) */


#if (!(defined(UTIME_H) || defined(_UTIME_H) || defined(_UTIME_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/utime.h.html
#define UTIME_H   (1)
#define _UTIME_H   (1)
#define _UTIME_H_   (1)


/** Structure describing file times */
typedef struct utimbuf {
	time_t actime;  //!< Access time
	time_t modtime;  //!< Modification time
} utimbuf_t;


/** Set the access and modification times of FILE to those given in *FILE_TIMES; If FILE_TIMES is NULL, set them to the current time */
LIB_FUNC int utime(const char* restrict path, const struct utimbuf* restrict times) {
	return utimensat(AT_FDCWD, path, times ? ((struct timespec [2]) { { .tv_sec = times->actime }, { .tv_sec = times->modtime } }) : 0, 0);
}


/** Change a file's modification time to now */
LIB_FUNC int touch_file(const char* restrict fname) {
	if (utime(fname, NULL) != 0) { return -1; }
	return 0;
}


#endif  // UTIME_H


/* UTILITIES FOR READING/WRITING FSTAB & MTAB (<mntent.h>) */


#if (!(defined(MNTENT_H) || defined(_MNTENT_H) || defined(_MNTENT_H_)))
#define MNTENT_H   (1)
#define _MNTENT_H   (1)
#define _MNTENT_H_   (1)


/** File listing canonical interesting mount points */
#define MNTTAB   _PATH_MNTTAB
/** File listing currently active mount points */
#define MOUNTED   _PATH_MOUNTED
// General filesystem types
/** Ignore this entry */
#define MNTTYPE_IGNORE   "ignore"
/** Network file system */
#define MNTTYPE_NFS   "nfs"
/** Swap device */
#define MNTTYPE_SWAP   "swap"
// Generic mount options
/** Use all default options */
#define MNTOPT_DEFAULTS   "defaults"
/** Read only */
#define MNTOPT_RO   "ro"
/** Read/write */
#define MNTOPT_RW   "rw"
/** Set uid allowed */
#define MNTOPT_SUID   "suid"
/** No set uid allowed */
#define MNTOPT_NOSUID   "nosuid"
/** Do not auto mount */
#define MNTOPT_NOAUTO   "noauto"


/** Structure describing a mount table entry */
struct mntent {
	char* mnt_fsname;  //!< Device or server for filesystem
	char* mnt_dir;  //!< Directory mounted on
	char* mnt_type;  //!< Type of filesystem: UFS, NFS, etc.
	char* mnt_opts;  //!< Comma-separated options for fs
	int mnt_freq;  //!< Dump frequency (in days)
	int mnt_passno;  //!< Pass number for `fsck`
};


static UNUSED char* getmntent_buffer[4096] = { 0 };
#define getmntent_allocate()   getmntent_buffer = { 0 }


/** Since the values in a line are separated by spaces, a name cannot contain a space; Therefore some programs encode spaces in names by the strings "\040"; We undo the encoding when reading an entry; The decoding happens in place */
LIB_FUNC char* decode_name(char* buf) {
	char* rp = buf;
	char* wp = buf;
	do {
		if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0') {
			*wp++ = ' ';
			rp += 3;
		} else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1') {
			*wp++ = '\t';  // \011 is a TAB
			rp += 3;
		} else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2') {
			*wp++ = '\n';  // \012 is a NEWLINE
			rp += 3;
		} else if (rp[0] == '\\' && rp[1] == '\\') {
			*wp++ = '\\';  // Escape \\ to represent all characters
			rp += 1;
		} else if (rp[0] == '\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4') {
			*wp++ = '\\';  // \134 is also \\ .
			rp += 3;
		} else { *wp++ = *rp; }
	} while (*rp++ != '\0');
	return buf;
}


/** We have to use an encoding for names if they contain spaces or tabs; To be able to represent all characters we also have to escape the backslash itself */
#define encode_name(name)   do { \
	const char* rp = name; \
	while (*rp != '\0') { \
		if (*rp == ' ' || *rp == '\t' || *rp == '\n' || *rp == '\\') { break; } \
		else { ++rp; } \
	} \
	if (*rp != '\0') { \
		char* wp = NULL; \
		rp = name; \
		name = wp = (char*)alloca((strlen(name) * 4) + 1); \
		do { \
			if (*rp == ' ') { \
				*wp++ = '\\'; \
				*wp++ = '0'; \
				*wp++ = '4'; \
				*wp++ = '0'; \
			} else if (*rp == '\t') { \
				*wp++ = '\\'; \
				*wp++ = '0'; \
				*wp++ = '1'; \
				*wp++ = '1'; \
			} else if (*rp == '\n') { \
				*wp++ = '\\'; \
				*wp++ = '0'; \
				*wp++ = '1'; \
				*wp++ = '2'; \
			} else if (*rp == '\\') { \
				*wp++ = '\\'; \
				*wp++ = '\\'; \
			} else { *wp++ = *rp; } \
		} while (*rp++ != '\0'); \
	} \
} while (0x0)


LIB_FUNC int fsetlocking(FILE* restrict fp, const int type) {
	const int result = ((fp->flags & _IO_USER_LOCK) ? FSETLOCKING_BYCALLER : FSETLOCKING_INTERNAL);
	if (type != FSETLOCKING_QUERY) {
		fp->flags &= (unsigned int)(~(_IO_USER_LOCK));
		if (type == FSETLOCKING_BYCALLER) { fp->flags |= _IO_USER_LOCK; }
	}
	return result;
}


/** Read one mount table entry from STREAM; Returns a pointer to storage reused on the next call, or null for EOF or error (use feof/ferror to check) */
LIB_FUNC struct mntent* getmntent_r(FILE* stream, struct mntent* mp, char* restrict buffer, const int bufsiz) {
	char* cp = NULL;
	char* head = NULL;
	FLOCK(stream);
	do {
		char* end_ptr = NULL;
		if (fgets_unlocked(buffer, bufsiz, stream) == NULL) {
			FUNLOCK(stream);
			return NULL;
		}
		end_ptr = strchr_nc(buffer, '\n');
		if (end_ptr != NULL) {  // Chop newline
			while (end_ptr != buffer && (end_ptr[-1] == ' ' || end_ptr[-1] == '\t')) {
				end_ptr--;
			}
			*end_ptr = '\0';
		} else {
			char align64 tmp[1024] = { 0 };
			while (fgets_unlocked(tmp, 1024, stream) != NULL) {
				if (strchr(tmp, '\n') != NULL) { break; }
			}
		}
		head = buffer + strspn(buffer, " \t");  // Skip empty lines and comments
	} while (head[0] == '\0' || head[0] == '#');
	cp = strsep(&head, " \t");
	mp->mnt_fsname = ((cp != NULL) ? decode_name(cp) : UNCONST(empty));
	if (head) { head += strspn(head, " \t"); }
	cp = strsep(&head, " \t");
	mp->mnt_dir = ((cp != NULL) ? decode_name(cp) : UNCONST(empty));
	if (head) { head += strspn(head, " \t"); }
	cp = strsep(&head, " \t");
	mp->mnt_type = ((cp != NULL) ? decode_name(cp) : UNCONST(empty));
	if (head) { head += strspn(head, " \t"); }
	cp = strsep(&head, " \t");
	mp->mnt_opts = ((cp != NULL) ? decode_name(cp) : UNCONST(empty));
	switch (head ? sscanf(head, " %d %d ", &mp->mnt_freq, &mp->mnt_passno) : 0) {
		case 0:
			mp->mnt_freq = 0; attr_fallthrough
		case 1:
			mp->mnt_passno = 0; attr_fallthrough
		default:
			break;
	}
	FUNLOCK(stream);
	return mp;
}
#define __getmntent_r(stream, mp, buffer, bufsiz)   getmntent_r((stream), (mp), (buffer), (bufsiz))


LIB_FUNC struct mntent* getmntent(FILE* stream) {
	static struct mntent m = { NULL, NULL, NULL, NULL, 0, 0 };
	if (*getmntent_buffer == NULL) { return NULL; }
	char* getmntent_buffer_p = (char*)&getmntent_buffer;
	return getmntent_r(stream, &m, getmntent_buffer_p, 4096);
}


/** Prepare to begin reading and/or writing mount table entries from the beginning of FILE; MODE is as for `fopen` */
LIB_FUNC FILE* setmntent(const char* file, const char* mode) {
	register const size_t modelen = strlen(mode);
	char newmode[modelen + 3];
	memcpy_no_output(mempcpy(newmode, mode, modelen), "ce", 3);
	FILE* result = fopen(file, newmode);
	if (result != NULL) { fsetlocking(result, FSETLOCKING_BYCALLER); }
	return result;
}
#define __setmntent(file, mode)   setmntent((file), (mode))


/** Close a stream opened with `setmntent` */
LIB_FUNC int endmntent(FILE* stream) {
	if (stream) { fclose(stream); }
	return 1;
}
#define __endmntent(stream)   endmntent((stream))


/** Write the mount table entry described by MNT to STREAM; Return zero on success, nonzero on failure */
LIB_FUNC int addmntent(FILE* stream, const struct mntent* mnt) {
	struct mntent mntcopy = *mnt;
	if (fseek(stream, 0, SEEK_END)) { return 1; }
	// Encode spaces and tabs in the names
	encode_name(mntcopy.mnt_fsname);
	encode_name(mntcopy.mnt_dir);
	encode_name(mntcopy.mnt_type);
	encode_name(mntcopy.mnt_opts);
	return (int)(fprintf(stream, "%s %s %s %s %d %d\n", mntcopy.mnt_fsname, mntcopy.mnt_dir, mntcopy.mnt_type, mntcopy.mnt_opts, mntcopy.mnt_freq, mntcopy.mnt_passno) < 0 || fflush(stream) != 0);
}
#define __addmntent(stream, mnt)   addmntent((stream), (mnt))


/** Search MNT->mnt_opts for an option matching OPT; Returns the address of the substring, or NULL if none found */
LIB_FUNC char* hasmntopt(const struct mntent* mnt, const char* opt) {
	const UNUSED size_t optlen = strlen(opt);
	char* rest = mnt->mnt_opts;
	char* p = NULL;
	while ((p = strstr_nc(rest, opt)) != NULL) {
		if ((p == rest || p[-1] == ',') && (p[optlen] == '\0' || p[optlen] == '=' || p[optlen] == ',')) { return p; }
		rest = strchr_nc(p, ',');
		if (rest == NULL) { break; }
		++rest;
	}
	return NULL;
}
#define __hasmntopt(mnt, opt)   hasmntopt((mnt), (opt))


#endif  // MNTENT_H


/* STATFS & STATVFS (<sys/statfs.h> & <sys/statvfs.h>) */


#if (!(defined(SYS_STATVFS_H) || defined(SYS_STATVFS_H_) || defined(_SYS_STATVFS_H_) || defined(_SYS_STATFS_H) || defined(_SYS_STATFS_H_)))
#define SYS_STATVFS_H   (1)
#define SYS_STATVFS_H_   (1)
#define _SYS_STATVFS_H_   (1)
#define _SYS_STATFS_H   (1)
#define _SYS_STATFS_H_   (1)


/** Special internal-only bit value */
#define ST_VALID   0x20

#if (IS_WORDSIZE_32 && ((!defined(SYSCALL_WORDSIZE)) || SYSCALL_WORDSIZE == 32))
#   define _STATVFSBUF_F_UNUSED
#endif

/** Structure and datatype used as a statvfs/fstatvfs function parameter */
typedef struct statvfs {
	unsigned long f_bsize;  //!< File system block size
	unsigned long f_frsize;  //!< Fundamental file system block size
#   ifndef USE_FILE_OFFSET64
	fsblkcnt_t f_blocks;  //!< Blocks on FS in units of f_frsize
	fsblkcnt_t f_bfree;  //!< Free blocks
	fsblkcnt_t f_bavail;  //!< Blocks available to non-root
	fsfilcnt_t f_files;  //!< Total inodes
	fsfilcnt_t f_ffree;  //!< Free inodes
	fsfilcnt_t f_favail;  //!< Free inodes for non-root
#   else
	fsblkcnt64_t f_blocks, f_bfree, f_bavail;
	fsfilcnt64_t f_files, f_ffree, f_favail;
#   endif
	unsigned long f_fsid;  //!< Filesystem ID
#   ifdef _STATVFSBUF_F_UNUSED
	int __f_unused;
#   endif
	unsigned long f_flag;  //!< Bit mask of values
	unsigned long f_namemax;  //!< Max file name length
	int __f_spare[6];
} statvfs_t;

#if SUPPORTS_LARGEFILE64
typedef struct statvfs64 {
	unsigned long f_bsize, f_frsize;
	fsblkcnt64_t f_blocks, f_bfree, f_bavail;
	fsfilcnt64_t f_files, f_ffree, f_favail;
	unsigned long f_fsid;
#   ifdef _STATVFSBUF_F_UNUSED
	int __f_unused;
#   endif
	unsigned long f_flag, f_namemax;
	int __f_spare[6];
} statvfs64_t;
#endif


// Defined bits for `f_flag` field value
/** Read-only file system */
#define ST_RDONLY   1
/** Does not honor setuid/setgid */
#define ST_NOSUID   2
/** Disallow access to device special files */
#define ST_NODEV   4
/** Disallow program execution */
#define ST_NOEXEC   8
/** Writes are synced at once */
#define ST_SYNCHRONOUS   16
/** Allow mandatory locks on an FS */
#define ST_MANDLOCK   64
/** Write on file/directory/symlink */
#define ST_WRITE   128
/** Append-only file */
#define ST_APPEND   256
/** Immutable file */
#define ST_IMMUTABLE   512
/** Do not update access times */
#define ST_NOATIME   1024
/** Do not update directory access times */
#define ST_NODIRATIME   2048
/** Update atime relative to mtime/ctime */
#define ST_RELATIME   4096


LIB_FUNC int __statvfs_getflags(const char* restrict name, const int fstype, const int fd) {
	struct stat64 align64 st = { 0 };
	if ((fd < 0 ? stat64(name, &st) : fstat64(fd, &st)) < 0) { return 0; }
	const char* fsname = NULL;
	const char* fsname2 = NULL;
	const char* fsname3 = NULL;
	switch (fstype) {
		case EXT2_SUPER_MAGIC:
			fsname = "ext4";
			fsname2 = "ext3";
			fsname3 = "ext2";
			break;
		case DEVPTS_SUPER_MAGIC:
			fsname = "devpts";
			break;
		case SHMFS_SUPER_MAGIC:
			fsname = "tmpfs";
			break;
		case PROC_SUPER_MAGIC:
			fsname = "proc";
			break;
		case USBDEVFS_SUPER_MAGIC:
			fsname = "usbdevfs";
			break;
		case AUTOFS_SUPER_MAGIC:
			fsname = "autofs";
			break;
		case NFS_SUPER_MAGIC:
			fsname = "nfs";
			break;
		case SYSFS_MAGIC:
			fsname = "sysfs";
			break;
		case REISERFS_SUPER_MAGIC:
			fsname = "reiserfs";
			break;
		case XFS_SUPER_MAGIC:
			fsname = "xfs";
			break;
		case JFS_SUPER_MAGIC:
			fsname = "jfs";
			break;
		case (int)HPFS_SUPER_MAGIC:
			fsname = "hpfs";
			break;
		case DEVFS_SUPER_MAGIC:
			fsname = "devfs";
			break;
		case ISOFS_SUPER_MAGIC:
			fsname = "iso9660";
			break;
		case MSDOS_SUPER_MAGIC:
			fsname = "msdos";
			break;
		case NTFS_SUPER_MAGIC:
			fsname = "ntfs";
			break;
		case (int)LOGFS_MAGIC_U32:
			fsname = "logfs";
			break;
		case (int)BTRFS_SUPER_MAGIC:
			fsname = "btrfs";
			break;
		case CGROUP_SUPER_MAGIC:
			fsname = "cgroup";
			break;
		case LUSTRE_SUPER_MAGIC:
			fsname = "lustre";
			break;
		case (int)F2FS_SUPER_MAGIC:
			fsname = "f2fs";
			break;
		case (int)EFIVARFS_MAGIC:
			fsname = "efivarfs";
			break;
		default: return 0;
	}
	FILE* mtab = __setmntent("/proc/mounts", "r");
	if (mtab == NULL) { mtab = __setmntent(_PATH_MOUNTED, "r"); }
	int result = 0;
	if (mtab != NULL) {
		bool success = false;
		struct mntent align64 mntbuf = { 0 };
		char align64 tmpbuf[1024] = { 0 };
		(void)fsetlocking(mtab, FSETLOCKING_BYCALLER);
goto___statvfs_getflags_again:
		while (__getmntent_r(mtab, &mntbuf, tmpbuf, 1024)) {
			if (name != NULL && strcmp(name, mntbuf.mnt_dir) != 0) { continue; }
			else if (fsname != NULL && strcmp(fsname, mntbuf.mnt_type) != 0 && (fsname2 == NULL || strcmp(fsname2, mntbuf.mnt_type) != 0) && (fsname3 == NULL || strcmp(fsname3, mntbuf.mnt_type) != 0)) { continue; }
			struct stat64 align64 fsst = { 0 };
			if (stat64(mntbuf.mnt_dir, &fsst) >= 0 && st.st_dev == fsst.st_dev) {
				char* cp = mntbuf.mnt_opts;
				char* opt;
				while ((opt = strsep(&cp, ",")) != NULL)
				if (strncmp(opt, "ro", 2) == 0) { result |= ST_RDONLY; }
				else if (strncmp(opt, "nosuid", 6) == 0) { result |= ST_NOSUID; }
				else if (strncmp(opt, "noexec", 6) == 0) { result |= ST_NOEXEC; }
				else if (strncmp(opt, "nodev", 5) == 0) { result |= ST_NODEV; }
				else if (strncmp(opt, "sync", 4) == 0) { result |= ST_SYNCHRONOUS; }
				else if (strncmp(opt, "mand", 4) == 0) { result |= ST_MANDLOCK; }
				else if (strncmp(opt, "noatime", 7) == 0) { result |= ST_NOATIME; }
				else if (strncmp(opt, "nodiratime", 10) == 0) { result |= ST_NODIRATIME; }
				else if (strncmp(opt, "relatime", 8) == 0) { result |= ST_RELATIME; }
				success = true;
				break;
			}
		}
		if (!success && (name != NULL || fsname != NULL)) {
			if (name != NULL) { name = NULL; }
			else {
				fsname = fsname2 = fsname3 = NULL;
			}
			rewind(mtab);
			goto goto___statvfs_getflags_again;
		}
		__endmntent(mtab);
	}
	return result;
}


LIB_FUNC void __internal_statvfs(const char* restrict name, struct statvfs* restrict buf, struct statfs* restrict fsbuf, const int fd) {
	buf->f_bsize = (unsigned long)fsbuf->f_bsize;
	buf->f_frsize = (unsigned long)(fsbuf->f_frsize ? fsbuf->f_frsize : fsbuf->f_bsize);
	buf->f_blocks = fsbuf->f_blocks;
	buf->f_bfree = fsbuf->f_bfree;
	buf->f_bavail = fsbuf->f_bavail;
	buf->f_files = fsbuf->f_files;
	buf->f_ffree = fsbuf->f_ffree;
	if (sizeof(buf->f_fsid) == sizeof(fsbuf->f_fsid)) {
		buf->f_fsid = (unsigned long)(((unsigned long)fsbuf->f_fsid.__val[0] & (unsigned long)((1UL << (8 * sizeof(fsbuf->f_fsid.__val[0]))) - 1)) | ((unsigned long)fsbuf->f_fsid.__val[1] << (8 * (sizeof(buf->f_fsid) - sizeof(fsbuf->f_fsid.__val[0])))));
	} else { buf->f_fsid = (unsigned long)fsbuf->f_fsid.__val[0]; }
#   ifdef _STATVFSBUF_F_UNUSED
	buf->__f_unused = 0;
#   endif
	buf->f_namemax = (unsigned long)fsbuf->f_namelen;
	memset_no_output(buf->__f_spare, '\0', sizeof(buf->__f_spare));
	buf->f_favail = buf->f_ffree;
#   ifndef __ASSUME_STATFS_F_FLAGS
	if ((fsbuf->f_flags & ST_VALID) == 0) {
		buf->f_flag = (unsigned long)__statvfs_getflags(name, (int)fsbuf->f_type, fd);
	} else { buf->f_flag = (unsigned long)(fsbuf->f_flags ^ ST_VALID); }
	return;
#   endif
	buf->f_flag = (unsigned long)(fsbuf->f_flags ^ ST_VALID);
}


/** Return information about the filesystem on which FILE resides */
LIB_FUNC NONNULL int __statfs(const char* restrict file, struct statfs* restrict buf) {
	return (int)syscall2(SYS_statfs, (long)file, (long)buf);
}
#define statfs(file, buf)   __statfs((file), (buf))


/** Return information about the filesystem on which FD resides */
LIB_FUNC int __fstatfs(const int fd, struct statfs* restrict buf) {
	return (int)syscall2(SYS_fstatfs, fd, (long)buf);
}
#define fstatfs(fd, buf)   __fstatfs((fd), (buf))


LIB_FUNC int fstatvfs(const int fd, struct statvfs* restrict buf) {
	struct statfs align64 fsbuf = { 0 };
	if (__fstatfs(fd, &fsbuf) < 0) { return -1; }
	__internal_statvfs(NULL, buf, &fsbuf, fd);
	return 0;
}
#define __fstatvfs(fd, buf)   fstatvfs((fd), (buf))
#define __fstatvfs64(fd, buf)   fstatvfs((fd), (buf))
#define fstatvfs64(fd, buf)   fstatvfs((fd), (buf))


LIB_FUNC NONNULL int statvfs(const char* restrict file, struct statvfs* restrict buf) {
	struct statfs align64 fsbuf = { 0 };
	const int sverrno = get_errno();
	set_errno(__statfs(file, &fsbuf));
	if (is_errno_neg()) { return -1; }
	else { set_errno(sverrno); }
	__internal_statvfs(file, buf, &fsbuf, -1);
	return 0;
}
#define __statvfs(file, buf)   statvfs((file), (buf))
#define __statvfs64(file, buf)   statvfs((file), (buf))
#define statvfs64(file, buf)   statvfs((file), (buf))


#endif  // SYS_STATVFS_H


/* DIRECTORY OPERATIONS (<sys/dir.h> & <dirent.h>) */


#if (!(defined(DIRENT_H) || defined(_DIRENT_H) || defined(_DIRENT_H_) || defined(_SYS_DIR_H) || defined(_SYS_DIR_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/dirent.h.html
#define DIRENT_H   (1)
#define _DIRENT_H   (1)
#define _DIRENT_H_   (1)
#define SYS_DIR_H   (1)
#define _SYS_DIR_H   (1)
#define _SYS_DIR_H_   (1)


#define _DIRENT_HAVE_D_RECLEN
#define _DIRENT_HAVE_D_OFF
#define _DIRENT_HAVE_D_TYPE

typedef struct attr_packed dirent {
#   ifndef USE_FILE_OFFSET64
	ino_t d_ino;
	off_t d_off;
#   else
	ino64_t d_ino;
	off64_t d_off;
#   endif
	unsigned short d_reclen;
	unsigned char d_type;
	char d_name[256];
} dirent_t;

#if SUPPORTS_LARGEFILE64
typedef struct dirent64 {
	ino64_t d_ino;
	off64_t d_off;
	unsigned short d_reclen;
	unsigned char d_type;
	char d_name[256];
} dirent64_t;
#endif
/** Backwards compatibility */
#define d_fileno   d_ino

#ifdef _DIRENT_HAVE_D_NAMLEN
/** Returns the length of DP->d_name, not including its terminating null character */
#   define _D_EXACT_NAMLEN(d)   ((d)->d_namlen)
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#   define _D_ALLOC_NAMLEN(d)   (_D_EXACT_NAMLEN(d) + 1)
#else
/** Returns the length of DP->d_name, not including its terminating null character */
#   define _D_EXACT_NAMLEN(d)   (strlen((d)->d_name))
#   ifdef _DIRENT_HAVE_D_RECLEN
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#      define _D_ALLOC_NAMLEN(d)   (((char*)(d) + (d)->d_reclen) - (&(d)->d_name[0]))
#   else
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#      define _D_ALLOC_NAMLEN(d)   ((sizeof(d)->d_name > 1) ? sizeof(d)->d_name : (_D_EXACT_NAMLEN(d) + 1))
#   endif
#endif
#define _GENERIC_DIRSIZ(dp)   (((unsigned long)&((struct dirent*)0)->d_name + (dp)->d_namlen + 4) & (~3))


/** Filetype values used in the dirent datatypes' `d_type` field */
enum DIRENT_FILETYPES {
	DT_UNKNOWN = 0,
	DT_FIFO = 1,
	DT_CHR = 2,
	DT_DIR = 4,
	DT_BLK = 6,
	DT_REG = 8,
	DT_LNK = 10,
	DT_SOCK = 12,
	DT_WHT = 14
};
/** Convert from stat structure types to directory types */
#define IFTODT(mode)   (((mode) & 0170000) >> 12)
/** Convert from directory types to stat structure types */
#define DTTOIF(dirtype)   ((dirtype) << 12)


LIB_FUNC int alphasort(const struct dirent** restrict a, const struct dirent** restrict b) {
	return strcmp((*a)->d_name, (*b)->d_name);
}


// TODO: Add scandir()


#endif  // DIRENT_H


/* MOUNT FILESYSTEMS (<mount.h>) */


#if (!(defined(SYS_MOUNT_H) || defined(_SYS_MOUNT_H) || defined(_SYS_MOUNT_H_)))
#define SYS_MOUNT_H   (1)
#define _SYS_MOUNT_H   (1)
#define _SYS_MOUNT_H_   (1)


#define BLKROSET   _IO(0x12, 93)
#define BLKROGET   _IO(0x12, 94)
#define BLKRRPART   _IO(0x12, 95)
#define BLKGETSIZE   _IO(0x12, 96)
#define BLKFLSBUF   _IO(0x12, 97)
#define BLKRASET   _IO(0x12, 98)
#define BLKRAGET   _IO(0x12, 99)
#define BLKFRASET   _IO(0x12, 100)
#define BLKFRAGET   _IO(0x12, 101)
#define BLKSECTSET   _IO(0x12, 102)
#define BLKSECTGET   _IO(0x12, 103)
#define BLKSSZGET   _IO(0x12, 104)
#define BLKBSZGET   _IOR(0x12, 112, size_t)
#define BLKBSZSET   _IOW(0x12, 113, size_t)
#define BLKGETSIZE64   _IOR(0x12, 114, size_t)
#define MS_RDONLY   1
#define MS_NOSUID   2
#define MS_NODEV   4
#define MS_NOEXEC   8
#define MS_SYNCHRONOUS   16
#define MS_REMOUNT   32
#define MS_MANDLOCK   64
#define MS_DIRSYNC   128
#define MS_NOATIME   1024
#define MS_NODIRATIME   2048
#define MS_BIND   4096
#define MS_MOVE   8192
#define MS_REC   16384
#define MS_SILENT   32768
#define MS_POSIXACL   0x10000
#define MS_UNBINDABLE   0x20000
#define MS_PRIVATE   0x40000
#define MS_SLAVE   0x80000
#define MS_SHARED   0x100000
#define MS_RELATIME   0x200000
#define MS_KERNMOUNT   0x400000
#define MS_I_VERSION   0x800000
#define MS_STRICTATIME   0x1000000
#define MS_LAZYTIME   0x2000000
#define MS_NOSEC   0x10000000
#define MS_BORN   0x20000000
#define MS_ACTIVE   0x40000000
#define MS_NOUSER   0x80000000
#define MS_RMT_MASK   (MS_RDONLY | MS_SYNCHRONOUS | MS_MANDLOCK | MS_I_VERSION | MS_LAZYTIME)
#define MS_MGC_VAL   0xc0ed0000
#define MS_MGC_MSK   0xffff0000
#define MNT_FORCE   1
#define MNT_DETACH   2
#define MNT_EXPIRE   4
#define UMOUNT_NOFOLLOW   8


LIB_FUNC int mount(const char* restrict special, const char* restrict dir, const char* restrict fstype, const unsigned long flags, const void* data) {
	return (int)syscall5(SYS_mount, (long)&special, (long)&dir, (long)&fstype, (long)flags, (long)&data);
}


LIB_FUNC int umount(const char* restrict special) {
	return (int)syscall2(SYS_umount2, (long)&special, 0);
}


LIB_FUNC int umount2(const char* restrict special, const int flags) {
	return (int)syscall2(SYS_umount2, (long)&special, flags);
}


#endif  // SYS_MOUNT_H


/* MEMORY MANAGEMENT (<sys/mman.h>) */


#if (!(defined(_SYS_MMAN_H) || defined(_SYS_MMAN_H_) || defined(_MALLOC_H) || defined(_MALLOC_H_) || defined(XALLOC_OVERSIZED_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_mman.h.html
#define SYS_MMAN_H   (1)
#define _SYS_MMAN_H   (1)
#define _SYS_MMAN_H_   (1)
#define MALLOC_H   (1)
#define _MALLOC_H   (1)
#define _MALLOC_H_   (1)
#define _MM_MALLOC_H_INCLUDED   (1)
#define _LIBC_SYS_MMAN_H_   (1)
#define _PAGEALIGN_ALLOC_H   (1)
#define _PAGEALIGN_ALLOC_H_   (1)
#define XALLOC_OVERSIZED_H   (1)  // <xalloc-oversized.h>
#define XALLOC_OVERSIZED_H_   (1)
#define _XALLOC_OVERSIZED_H_   (1)


#define MREMAP_MAYMOVE   (1)
#define MREMAP_FIXED   (2)
#define MLOCK_ONFAULT   (1)
#define MMAP_OFF_MASK   (((long long)(-0x2000ULL) << (BITS_PER_LONG - 1)) | (SYSCALL_MMAP2_UNIT - 1))
#define __MALLOC_P(args)   args __THROW
/** This macro will be used for functions which might use C++ callback functions */
#define __MALLOC_PMT(args)   args
/** Return the number of bytes that need to be added to X to make it aligned to an ALIGN boundary; ALIGN must be a power of 2 */
#define M_ALIGN(x, align)   (-(size_t)(x) & ((align) - 1))
/** Return the number of bytes that need to be subtracted from X to make it aligned to an ALIGN boundary; ALIGN must be a power of 2 */
#define M_ALIGN_SUB(x, align)   ((size_t)(x) & ((align) - 1))
/** real_size is the size we actually have to allocate, allowing for overhead and alignment */
#define REAL_SIZE(sz)   ((sz) < sizeof(struct freelist_entry) - SIZEOF_SIZE_T ? sizeof(struct freelist_entry) : ((sz) + SIZEOF_SIZE_T + M_ALIGN((sz), SIZEOF_SIZE_T)))
#ifdef ARCHXSTORMY  // MALLOC_LIMIT
register void* stack_pointer asm ("r15;");
#   define MALLOC_LIMIT    stack_pointer
#else
#   define MALLOC_LIMIT   __builtin_frame_address(0)
#endif  // MALLOC_LIMIT
#ifndef MALLOC_ALIGNMENT
/** MALLOC_ALIGNMENT is the minimum alignment for malloced chunks; It must be a power of two at least 2*(sizeof(size_t)) */
#   define MALLOC_ALIGNMENT   (2 * SIZEOF_SIZE_T)
#endif
/** The corresponding bit mask value */
#define MALLOC_ALIGN_MASK   (MALLOC_ALIGNMENT - 1)
#ifndef DEFAULT_TRIM_THRESHOLD
/** Maximum amount of unused top-most memory to keep before releasing via malloc_trim in free() */
#   define DEFAULT_TRIM_THRESHOLD   (131072)
#endif
#ifndef DEFAULT_TOP_PAD
/** Amount of extra `padding` space to allocate or retain whenever sbrk is called */
#   define DEFAULT_TOP_PAD   (0)
#endif
#ifndef DEFAULT_MMAP_THRESHOLD
/** Request size threshold for using mmap() to service a request; Requests of at least this size that cannot be allocated using already-existing space will be serviced via mmap */
#   define DEFAULT_MMAP_THRESHOLD   (131072)
#endif
#ifndef DEFAULT_MMAP_MAX
#   ifdef HAVE_MMAP
/** Maximum number of requests to simultaneously service using mmap */
#      define DEFAULT_MMAP_MAX   (1024)
#   else
/** Maximum number of requests to simultaneously service using mmap */
#      define DEFAULT_MMAP_MAX   (0)
#   endif
#endif
/** Conversion from malloc headers to user pointers, and back */
#define chunk2mem(p)   ((void*)((char*)(p) + (2 * SIZEOF_SIZE_T)))
#define mem2chunk(mem)   ((mchunkptr)((char*)(mem) - (2 * SIZEOF_SIZE_T)))
/** The smallest possible chunk */
#define MIN_CHUNK_SIZE   (sizeof(struct malloc_chunk))
/** The smallest size we can malloc is an aligned minimal chunk */
#define MINSIZE   ((unsigned long)((unsigned long)(MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) & (unsigned long)(~MALLOC_ALIGN_MASK)))
/** Check if m has acceptable alignment */
#define aligned_OK(m)   (((unsigned long)((m)) & (MALLOC_ALIGN_MASK)) == 0)
/** Check if a request is so large that it would wrap around zero when padded and aligned; The bound is made low enough so that adding MINSIZE will also not wrap around zero */
#define REQUEST_OUT_OF_RANGE(req)   ((unsigned long)(req) >= (unsigned long)((-2) * MINSIZE))
/** Pad request bytes into a usable size -- internal version */
#define request2size(req)   ((((req) + SIZEOF_SIZE_T + MALLOC_ALIGN_MASK) < MINSIZE) ? MINSIZE : (((req) + SIZEOF_SIZE_T + MALLOC_ALIGN_MASK) & (~MALLOC_ALIGN_MASK)))
#define checked_request2size(req, sz)   if (REQUEST_OUT_OF_RANGE(req)) { set_errno(ENOMEM); return 0; } (sz) = request2size(req);
/** Size field is ORed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE   1
/** Extract in-use bit of previous chunk */
#define prev_inuse(p)   ((p)->size & PREV_INUSE)
/** size field is ORed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED   2
/** Check for mmapped chunk */
#define chunk_is_mmapped(p)   ((p)->size & IS_MMAPPED)
/** Bits to mask off when extracting size */
#define SIZE_BITS   (PREV_INUSE | IS_MMAPPED)
/** Get size, ignoring use bits */
#define chunksize(p)   ((p)->size & (~(SIZE_BITS)))
/** Ptr to next physical malloc_chunk */
#define next_chunk(p)   ((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))
/** Ptr to previous physical malloc_chunk */
#define prev_chunk(p)   ((mchunkptr)(((char*)(p)) - ((p)->prev_size)))
/** Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)   ((mchunkptr)(((char*)(p)) + (s)))
/** Extract p's inuse bit */
#define inuse(p)   ((((mchunkptr)(((char*)(p))+((p)->size & (~PREV_INUSE))))->size) & PREV_INUSE)
/** Set chunk as being inuse without otherwise disturbing */
#define set_inuse(p)   (((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))->size |= PREV_INUSE)
/** Clear chunk as being inuse without otherwise disturbing */
#define clear_inuse(p)   (((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))->size &= (~(PREV_INUSE)))
/** Check inuse bits in known places */
#define inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)
/** Set inuse bits in known places */
#define set_inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)
/** Clear inuse bits in known places */
#define clear_inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size &= (~(PREV_INUSE)))
/** Set size at head, without disturbing its use bit */
#define set_head_size(p, s)   ((p)->size = (((p)->size & PREV_INUSE) | (s)))
/** Set size/use field */
#define set_head(p, s)   ((p)->size = (s))
/** Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)   (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))
#define SQRT_SIZE_MAX   ((size_t)1 << ((SIZEOF_SIZE_T * CHAR_BIT) >> 1))
#define MUL_NO_OVERFLOW   ((size_t)1 << (SIZEOF_SIZE_T * 4))
#define BLOCK_START(b)   ((void*)((uintptr_t)((void*)(b)) - (uintptr_t)SIZEOF_ALLOC_T))
#define BLOCK_RET(b)   ((void*)((uintptr_t)((void*)(b)) + (uintptr_t)SIZEOF_ALLOC_T))
/** Return 1 if an array of N objects, each of size S, cannot exist due to size arithmetic overflow; S must be positive and N must be nonnegative */
#define xalloc_oversized(n, s)   ((size_t)(((SIZEOF_PTRDIFF_T <= SIZEOF_SIZE_T) ? -1 : -2)) / (s) < (n))


// FREE FUNCTIONS


LIB_FUNC void _alloc_libc_free(void* ptr) {
	if (ptr) { munmap(BLOCK_START(ptr), ((size_t)((alloc_t*)BLOCK_START(ptr))->size)); }
}


LIB_FUNC void free(void* ptr) {
	if (PREDICT_UNLIKELY(ptr == NULL)) { return; }
	ptr = (void*)((uintptr_t)ptr - (uintptr_t)SIZEOF_SIZE_T);
	munmap(ptr, (*(size_t*)ptr + SIZEOF_SIZE_T));
}
#define __libc_free(ptr)   free((ptr))
#define _libc_free(ptr)   free((ptr))
#define libc_free(ptr)   free((ptr))
#define rk_xfree(addr)   free((addr))
#define mm_free(ptr)   free(((void*)(ptr)))
#define _mm_free(ptr)   free(((void*)(ptr)))
#define mem_free(ptr, bsize)   free(((void*)(ptr)))
#define free_r(ptr, addr)   free((addr))
#define _free_r(ptr, addr)   free((addr))
#define ckfree(addr)   free((void*)(addr))
#define xfree(x)   do { if ((x) != NULL) { free((void*)(x)); (x) = NULL; } } while (0x0)
#define FREEPTR(x)   xfree((x))
#define FREE_AND_CLEAR(x)   xfree((x))
#define MEMSET_FREE_AND_CLEAR(x)   do { if ((x)) { memset((x), 0, strlen(x)); free((x)); (x) = NULL; } } while (0x0)


/** Clear memory block */
LIB_FUNC void _cfree(void* p, const UNUSED size_t num, const UNUSED size_t size) {
	free(p);
}
#define cfree(ptr)   free(((void*)(ptr)))
#define cfree_r(ptr, mem)   cfree((mem))
#define _cfree_r(ptr, mem)   cfree((mem))


LIB_FUNC void cpuset_free(cpu_set_t* set) {
	free(set);
}
#define __cpuset_free(set)   cpuset_free((set))


LIB_FUNC void freelocale(locale_t _locale) {
	_DIAGASSERT(_locale != LC_GLOBAL_LOCALE);
	_DIAGASSERT(_locale != LC_C_LOCALE);
	_DIAGASSERT(_locale != (locale_t)NULL);
	free(_locale);
}
#define _freelocale(l)   freelocale((l))


LIB_FUNC int munmap(void* start, const size_t len) {
	return (int)syscall2(SYS_munmap, (long)start, (long)len);
}
#define __munmap(start, len)   munmap((start), (len))
#define free_mem(start, len)   munmap((start), (len))


LIB_FUNC int munmap_const(const void* start, const size_t len) {
	return (int)syscall2(SYS_munmap, (long)start, (long)len);
}


// MEMORY ALLOCATION FUNCTIONS


LIB_FUNC NOLIBCALL uintptr_t __brk(const uintptr_t newbrk) {
	return (uintptr_t)syscall1(SYS_brk, (long)newbrk);
}
#define brk(newbrk)   __brk((newbrk))
#define _brk(newbrk)   __brk((newbrk))


/** This function returns true if the interval [old, new] intersects the `len`-sized interval below &libc.auxv (interpreted as the main-thread stack) or below &b (the current stack); It is used to defend against buggy brk implementations that can cross the stack */
LIB_FUNC ATTR_CF int traverses_stack_p(const uintptr_t old, const uintptr_t new) {
	uintptr_t b = (uintptr_t)libc.auxv;
	register uintptr_t a = (b > (uintptr_t)0x800000 ? (b - (uintptr_t)0x800000) : 0);
	if ((new > a) && (old < b)) { return 1; }
	b = (uintptr_t)&b;
	a = (b > (uintptr_t)0x800000 ? (b - (uintptr_t)0x800000) : 0);
	if (new > a && old < b) { return 1; }
	return 0;
}


#ifdef OSOPENBSD
/** Provides 64-bit offset padding */
LIB_FUNC void* mquery(void* addr, const size_t len, const int prot, const int flags, const int fd, const off_t offset) {
	 return (void*)(syscall7(SYS_mquery, addr, len, prot, flags, fd, 0, offset));
}
#   define MQUERY(a, sz)   mquery((a), (size_t)(sz), (PROT_READ | PROT_WRITE), (MAP_ANON | MAP_PRIVATE | MAP_FIXED), -1, (off_t)0)
#endif


LIB_FUNC NOLIBCALL void* mmap(void* restrict start, const size_t len, const int prot, const int flags, const int fd, const off_t off) {
	if (off & (off_t)(((-0x2000UL) << (BITS_PER_LONG - 1)) | (SYSCALL_MMAP2_UNIT - 1))) {
		set_errno(EINVAL);
		return MAP_FAILED;
	} else if (PREDICT_UNLIKELY(len >= PTRDIFF_MAX)) {
		set_errno(ENOMEM);
		return MAP_FAILED;
	} else if (PREDICT_UNLIKELY(flags & MAP_FIXED)) { LOCK(memlock); }
#   ifdef SYS_mmap2
	const long mmap_ptr = (long)syscall6(SYS_mmap2, (long)start, (long)len, prot, flags, fd, (off_t)(off / SYSCALL_MMAP2_UNIT));
#   else
	const long mmap_ptr = (long)syscall6(SYS_mmap, (long)start, (long)len, prot, flags, fd, off);
#   endif
	UNLOCK(memlock);
	return (void*)mmap_ptr;
}
#define mmap64(start, len, prot, flags, fd, off)   mmap((start), (len), (prot), (flags), (fd), (off))
#define __mmap(start, len, prot, flags, fd, off)   mmap((start), (len), (prot), (flags), (fd), (off))
#define MMAPA(a, sz)   mmap((a), (size_t)(sz), (PROT_READ | PROT_WRITE), (MAP_ANON | MAP_PRIVATE), -1, (off_t)0)
#define HAVE_MMAP   (1)


/** Expand the heap in-place if brk can be used, or otherwise via mmap, using an exponential lower bound on growth by mmap to make fragmentation asymptotically irrelevant */
LIB_FUNC NOLIBCALL void* expand_heap(size_t* restrict pn) {
	size_t n = *pn;
	if (n > ((SIZE_MAX >> 1) - PAGE_SIZE)) {
		set_errno(ENOMEM);
		return 0;
	}
	static uintptr_t brk = 0;
	static unsigned int mmap_step = 0;
	n += (-n & (PAGE_SIZE - 1));
	if (!brk) {
		brk = (uintptr_t)syscall1(SYS_brk, 0);
		brk += ((-brk) & (PAGE_SIZE - 1));
	}
	if (n < (SIZE_MAX - brk) && (!traverses_stack_p(brk, (brk + n))) && ((uintptr_t)syscall1(SYS_brk, (long)(brk + n)) == (brk + n))) {
		*pn = n;
		brk += (uintptr_t)n;
		return (void*)(brk - n);
	}
	const size_t min = (size_t)(PAGE_SIZE << (mmap_step >> 1));
	if (n < min) { n = min; }
	void* area = mmap(0, n, (PROT_READ | PROT_WRITE), (MAP_PRIVATE | MAP_ANONYMOUS), -1, 0);
	if (area == MAP_FAILED) { return 0; }
	*pn = n;
	++mmap_step;
	return area;
}
#define __expand_heap(pn)   expand_heap((pn))


LIB_FUNC int mprotect(const void* restrict addr, const size_t len, const int prot) {
	const size_t start = (size_t)addr & (size_t)(-PAGE_SIZE);
	const size_t end = (size_t)((const char*)addr + len + PAGE_SIZE - 1) & (size_t)(-PAGE_SIZE);
	return (int)syscall3(SYS_mprotect, (long)start, (long)(end - start), (long)prot);
}
#define __mprotect(addr, len, prot)   mprotect((addr), (len), (prot))


LIB_FUNC int msync(void* restrict start, const size_t len, const int flags) {
	return (int)syscall3(SYS_msync, (long)start, (long)len, flags);
}


LIB_FUNC int posix_madvise(void* restrict addr, const size_t len, const int advice) {
	if (advice == MADV_DONTNEED) { return 0; }
	return (int)(-(syscall3(SYS_madvise, (long)addr, (long)len, advice)));
}
#define HAVE_POSIX_MADVISE   (1)


LIB_FUNC int mlock(const void* restrict addr, const size_t len) {
	return (int)syscall2(SYS_mlock, (long)addr, (long)len);
}


LIB_FUNC int munlock(const void* restrict addr, const size_t len) {
	return (int)syscall2(SYS_munlock, (long)addr, (long)len);
}


LIB_FUNC int mlockall(const int flags) {
	return (int)syscall1(SYS_mlockall, flags);
}


LIB_FUNC int munlockall(void) {
	return (int)syscall0(SYS_munlockall);
}


LIB_FUNC void* mremap(void* old_addr, const size_t old_len, const size_t new_len, const int flags, ...) {
	va_list ap;
	void* new_addr = 0;
	if (new_len >= PTRDIFF_MAX) {
		set_errno(ENOMEM);
		return MAP_FAILED;
	} else if (flags & MREMAP_FIXED) {
		va_start(ap, flags);
		new_addr = va_arg(ap, void*);
		va_end(ap);
	}
	return (void*)((uintptr_t)syscall5(SYS_mremap, (long)old_addr, (long)old_len, (long)new_len, flags, (long)new_addr));
}
#define __mremap(old_addr, old_len, new_len, flags, ...)   mremap((old_addr), (old_len), (new_len), (flags), (__VA_ARGS__))


LIB_FUNC int remap_file_pages(const void* restrict addr, const size_t size, const int prot, const size_t pgoff, const int flags) {
	return (int)syscall5(SYS_remap_file_pages, (long)addr, (long)size, (long)prot, (long)pgoff, (long)flags);
}


LIB_FUNC int madvise(const void* restrict addr, const size_t len, const int advice) {
	return (int)syscall3(SYS_madvise, (long)addr, (long)len, advice);
}
#define __madvise(addr, len, advice)   madvise((addr), (len), (advice))


LIB_FUNC int mincore(const void* restrict addr, const size_t len, unsigned char* vec) {
	return (int)syscall3(SYS_mincore, (long)addr, (long)len, (long)vec);
}


LIB_FUNC size_t malloc_usable_size(const void* p) {
	return (p ? ((((const struct chunk*)((const char*)(p) - (2 * SIZEOF_SIZE_T)))->csize & (size_t)(-2)) - (2 * SIZEOF_SIZE_T)) : 0);
}


LIB_FUNC char* shm_mapname(const char* restrict name, char* restrict buf) {
	const char* p;
	while (*name == '/') { name++; }
	if (*(p = strchrnul(name, '/')) || p == name || (p - name <= 2 && name[0] == '.' && p[-1] == '.')) {
		set_errno(EINVAL);
		return 0;
	} else if ((p - name) > NAME_MAX) {
		set_errno(ENAMETOOLONG);
		return 0;
	}
	memcpy_no_output(buf, "/dev/shm/", 9);
	memcpy_no_output((buf + 9), name, (size_t)(p - name + 1));
	return buf;
}
#define __shm_mapname(name, buf)   shm_mapname((name), (buf))


LIB_FUNC int shm_open(const char* restrict name, const int flag, const mode_t mode) {
	char align64 buf[NAME_MAX + 10] = { 0 };
	if (!(name = shm_mapname(name, buf))) { return -1; }
	int cs;
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	register int fd = open(name, (flag | O_NOFOLLOW | O_CLOEXEC | O_NONBLOCK), mode);
	pthread_setcancelstate(cs, 0);
	return fd;
}


LIB_FUNC int shm_unlink(const char* restrict name) {
	char buf[NAME_MAX + 10] = { 0 };
	if (!(name = shm_mapname(name, buf))) { return -1; }
	return unlink(name);
}


LIB_FUNC void* memalign(const size_t align, const size_t sz) {
	unsigned char* mem = NULL;
	if ((align & -align) != align) {
		set_errno(EINVAL);
		return NULL;
	} else if (sz > (SIZE_MAX - align)) {
		set_errno(ENOMEM);
		return NULL;
	} else if (align <= (4 * SIZEOF_SIZE_T)) {
		if (!(mem = malloc(sz))) { return NULL; }
		return mem;
	} else if (!(mem = malloc(sz + align - 1))) { return NULL; }
	unsigned char* new = (void*)(((size_t)mem + align - 1) & (size_t)(-align));
	if (new == mem) { return mem; }
	register const size_t _header = ((size_t*)mem)[-1];
	if (!(_header & 7)) {
		((size_t*)new)[-2] = ((size_t*)mem)[-2] + (unsigned long)(new - mem);
		((size_t*)new)[-1] = ((size_t*)mem)[-1] - (unsigned long)(new - mem);
		return new;
	}
	unsigned char* end = mem + (_header & (size_t)(-8));
	register const size_t footer = ((size_t*)end)[-2];
	((size_t*)mem)[-1] = ((_header & 7) | (unsigned long)(new - mem));
	((size_t*)new)[-2] = ((footer & 7) | (unsigned long)(new - mem));
	((size_t*)new)[-1] = ((_header & 7) | (unsigned long)(end - new));
	((size_t*)end)[-2] = ((footer & 7) | (unsigned long)(end - new));
	free(mem);
	mem = NULL;
	return new;
}
#define __memalign(align, sz)   memalign((align), (sz))
#define _memalign(align, sz)   memalign((align), (sz))
#define HAVE_MEMALIGN   (1)


LIB_FUNC int posix_memalign(void** res, const size_t align, const size_t len) {
	if (align < SIZEOF_VOID_PTR) { return EINVAL; }
	void* mem = (void*)memalign(align, len);
	if (PREDICT_UNLIKELY(!mem)) { return EAGAIN; }
	*res = mem;
	return 0;
}
#define HAVE_POSIX_MEMALIGN   (1)


LIB_FUNC void* aligned_alloc(const size_t align, const size_t data_size) {
	return memalign(align, data_size);
}


LIB_FUNC void* pvalloc(const size_t data_size) {
	return memalign(128, (data_size - ((size_t)(data_size) & 127)));
}
#define _palloc(data_size)   palloc((data_size))
#define HAVE_PVALLOC   (1)


LIB_FUNC void* valloc(const size_t data_size) {
	return (void*)memalign(128, data_size);
}
#define _valloc(data_size)   valloc((data_size))
#define HAVE_VALLOC   (1)


LIB_FUNC NOLIBCALL void* malloc(const size_t len) {
	register size_t n = len;
	static char *cur = NULL, *end = NULL;
	register size_t align = 1;
	if (!n) { ++n; }
	while (align < n && align < 16) { align += align; }
	LOCK(memlock);
	register size_t pad = -(uintptr_t)cur & (align - 1);
	if (n <= ((SIZE_MAX >> 1) + align)) { n += pad; }
	if (n > (size_t)(end - cur)) {
		size_t m = n;
		char* new = expand_heap(&m);
		if (!new) {
			UNLOCK(memlock);
			return 0;
		} else if (new != end) {
			cur = new;
			n -= pad;
			pad = 0;
		}
		end = new + m;
	}
	void* p = cur + pad;
	cur += n;
	UNLOCK(memlock);
	return p;
}
#define __simple_malloc(n)   malloc((n))
#define __malloc0(n)   malloc((n))
#define malloc0(n)   malloc((n))
#define __malloc(n)   malloc((n))


LIB_FUNC void* zalloc(const size_t size) {
	void* ptr = malloc(size);
	if (ptr) { memset_no_output(ptr, 0, size); }
	return ptr;
}


/** Like malloc, but returns an error when out of space */
LIB_FUNC void* ckmalloc(const size_t nbytes) {
	void* p = malloc(nbytes);
	if (p == NULL) { exit_on_error("Out of space"); }
	return p;
}


struct stack_block {
	struct stack_block* prev;
	char space[MINSIZE];
};


struct attr_packed stackmark {
	struct stack_block* stackp;
	char* stacknxt;
	int stacknleft;
	struct stackmark* marknext;
};


UNUSED struct stack_block stackbase;
UNUSED struct stack_block* stackp = &stackbase;
UNUSED struct stackmark* markp;
UNUSED char* stacknxt = stackbase.space;
UNUSED int stacknleft = (int)MINSIZE;
UNUSED int sstrnleft = 0;
UNUSED int herefd = -1;
#define stackblock()   stacknxt
#define stackblocksize()   stacknleft
/** Most machines require the value returned from malloc to be aligned in some way; The following macro will get this right on many machines */
#define SHELL_SIZE   (SIZEOF_DOUBLE - 1)
#define SHELL_ALIGN(nbytes)   (((nbytes) + SHELL_SIZE) & (~SHELL_SIZE))


LIB_FUNC void* stalloc(int nbytes) {
	char* p = NULL;
	nbytes = SHELL_ALIGN(nbytes);
	if (nbytes > stacknleft) {
		int blocksize;
		struct stack_block* sp;
		blocksize = nbytes;
		if (blocksize < (int)MINSIZE) { blocksize = (int)MINSIZE; }
		sp = ckmalloc((size_t)(sizeof(struct stack_block) - (unsigned long)MINSIZE + (unsigned long)blocksize));
		sp->prev = stackp;
		stacknxt = sp->space;
		stacknleft = blocksize;
		stackp = sp;
	}
	p = stacknxt;
	stacknxt += nbytes;
	stacknleft -= nbytes;
	return p;
}
#define grabstackstr(p)   stalloc(stackblocksize() - sstrnleft)


LIB_FUNC void stunalloc(void* p) {
	if (p == NULL) { abort(); }
	stacknleft += ((int)(stacknxt - (char*)p));
	stacknxt = p;
}


LIB_FUNC void setstackmark(struct stackmark* mark) {
	mark->stackp = stackp;
	mark->stacknxt = stacknxt;
	mark->stacknleft = stacknleft;
	mark->marknext = markp;
	markp = mark;
}


LIB_FUNC void popstackmark(struct stackmark* mark) {
	struct stack_block* sp = NULL;
	markp = mark->marknext;
	while (stackp != mark->stackp) {
		sp = stackp;
		stackp = sp->prev;
		ckfree(sp);
	}
	stacknxt = mark->stacknxt;
	stacknleft = mark->stacknleft;
}


/** Make a copy of a string in safe storage */
LIB_FUNC char* savestr(const char *s) {
	char* p = ckmalloc((strlen(s) + 1));
	scopy_no_output(s, p);
	return p;
}


LIB_FUNC char* strdup(const char* s) {
	register const size_t l = strlen(s);
	char* d = malloc((size_t)(l + 1));
	if (!d) { return NULL; }
	return (char*)memcpy((void*)d, (const void*)s, (size_t)(l + 1));
}
#define __strdup(s)   strdup((s))


/** Return a malloc copy of at most the specified number of bytes of a string */
LIB_FUNC char* strndup(const char* s, const size_t n) {
	register const size_t len = strnlen(s, n);
	char* new = (char*)malloc(len + 1);
	if (new == NULL) { return NULL; }
	new[len] = '\0';
	return (char*)memcpy(new, s, len);
}
#define __strndup(s, l)   strndup((s), (l))


LIB_FUNC char* sstrdup(const char* p) {
	register const size_t len = strlen(p) + 1;
	return memcpy(stalloc((int)len), p, len);
}
#define __sstrdup(ptr)   sstrdup((ptr))


LIB_FUNC void* calloc(const size_t num_members, const size_t elem_size) {
	register const size_t sz = (num_members * elem_size);
	void* result = NULL;
	result = malloc(sz);
	if (PREDICT_LIKELY(result != NULL)) { memset_no_output(result, 0, sz); }
	return result;
}
#define mem_alloc(bsize)   calloc((size_t)1, (bsize))


LIB_FUNC void* mm_malloc(const size_t data_size, register size_t alignment) {
	if (alignment == 1) { return calloc((size_t)1, data_size); }
	else if (alignment == 2 || (SIZEOF_VOID_PTR == 8 && alignment == 4)) { alignment = SIZEOF_VOID_PTR; }
	void* ptr = NULL;
	if (posix_memalign(&ptr, alignment, data_size) == 0) { return ptr; }
	else { return NULL; }
}
#define _mm_malloc(data_size, alignment)   mm_malloc((data_size), (alignment))


LIB_FUNC char* icatalloc(char* const old, const char* const new) {
	char* result = NULL;
	register int oldsize = 0;
	const int newsize = (int)((new == NULL) ? 0 : strlen(new));
	if (old == NULL) { oldsize = 0; }
	else if (newsize == 0) { return old; }
	else { oldsize = (int)strlen(old); }
	if ((result = realloc(old, (size_t)(oldsize + newsize + 1))) != NULL) { if (new != NULL) { (void) strcpy((result + oldsize), new); } }
	return result;
}


LIB_FUNC char* icpyalloc(const char* const _string) {
	return icatalloc(NULL, _string);
}


/** Allocate an N-byte block of memory from the heap; If N is zero, allocate a 1-byte block */
LIB_FUNC void* rpl_malloc(const size_t n) {
	if (n == 0) { return (void*)malloc(1); }
	return (void*)malloc(n);
}


/** Copy a UTF-8 string */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(2) uint8_t* u8_cpy_alloc(const uint8_t* s, size_t n) {
	uint8_t* dest = NULL;
	dest = (uint8_t*)malloc((size_t)(n > 0 ? n : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n);
		uint8_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


/** Copy a UTF-16 string */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(2) uint16_t* u16_cpy_alloc(const uint16_t* s, size_t n) {
	uint16_t* dest = NULL;
	dest = (uint16_t*)malloc((size_t)(n > 0 ? n * 2 : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n * 2);
		uint16_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


/** Copy a UTF-32 string */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(2) uint32_t* u32_cpy_alloc(const uint32_t* s, size_t n) {
	uint32_t* dest = NULL;
	dest = (uint32_t*)malloc((size_t)(n > 0 ? n * 4 : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n * 4);
		uint32_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


// REALLOC

LIB_FUNC void* realloc(void* ptr, const size_t len) {
	void* newmem = NULL;
	newmem = malloc(len);
	if (newmem) { memcpy_no_output(newmem, ptr, len); }
	free(ptr);
	ptr = NULL;
	return newmem;
}
#define HAVE_REALLOC_POSIX   1
#define NEED_REALLOC_GNU   0
#define SYSTEM_MALLOC_GLIBC_COMPATIBLE   0
#undef GNULIB_REALLOC_GNU


/** Like realloc, but returns an error when out of space */
LIB_FUNC void* ckrealloc(void* p, const int nbytes) {
	p = realloc(p, (size_t)nbytes);
	if (p == NULL) { error(EXIT_FAILURE, get_errno(), "Out of space"); }
	return p;
}


LIB_FUNC void* rk_realloc(void* ptr, const size_t size) {
	if (ptr == NULL) { return (void*)malloc(size); }
	return (void*)realloc(ptr, size);
}


/** Like realloc but never fails */
LIB_FUNC void* erealloc(void* ptr, const size_t sz) {
	void* tmp = realloc(ptr, sz);
	if (tmp == NULL && sz != 0) { errx(1, "realloc %lu failed", (unsigned long)sz); }
	return tmp;
}


LIB_FUNC void* reallocarray(void* optr, const size_t nmemb, const size_t size) {
	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) && nmemb > 0 && (SIZE_MAX / nmemb) < size) { set_errno(ENOMEM); return NULL; }
	return realloc(optr, (size * nmemb));
}


LIB_FUNC void* reallocf(void* ptr, const size_t size) {
	void* nptr = NULL;
	nptr = realloc(ptr, size);
	if (!nptr && ptr && size != 0) { free(ptr); }
	return nptr;
}


LIB_FUNC int reallocarr(void* ptr, const size_t number, const size_t size) {
	void *optr = NULL, *nptr = NULL;
	const int sverrno = get_errno();
	memcpy_no_output(&optr, ptr, sizeof(ptr));
	if (number == 0 || size == 0) {
		free(optr);
		nptr = NULL;
		memcpy_no_output(ptr, &nptr, sizeof(ptr));
		set_errno(sverrno);
		return 0;
	}
	if (PREDICT_UNLIKELY((number | size) >= SQRT_SIZE_MAX && number > (SIZE_MAX / size))) {
		set_errno(sverrno);
		return EOVERFLOW;
	}
	nptr = realloc(optr, (number * size));
	register int result;
	if (PREDICT_UNLIKELY(nptr == NULL)) { result = get_errno(); }
	else { result = 0; memcpy_no_output(ptr, &nptr, sizeof(ptr)); }
	set_errno(sverrno);
	return result;
}


/** Change the size of an allocated block of memory P to N bytes, with error checking; If N is zero, change it to 1; If P is NULL, use malloc */
LIB_FUNC void* rpl_realloc(void* p, const size_t len) {
	void* result = NULL;
	if (p == NULL) { result = malloc(len); }
	else { result = realloc(p, len); }
	return result;
}


/* MEMORY ALLOCATION WITH EXPENSIVE EMPTY ALLOCATIONS (<eealloc.h>) */


#if (!(defined(EEALLOC_H) || defined(_EEALLOC_H) || defined(_EEALLOC_H_)))
#define EEALLOC_H   (1)
#define _EEALLOC_H   (1)
#define _EEALLOC_H_   (1)


LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* eemalloc(const size_t n) {
	if (n == 0) { return malloc(1); }  // If n is zero, allocate a 1-byte block
	return malloc(n);
}


LIB_FUNC ATTR_ALLOC_SIZE(2) void* eerealloc(void* p, const size_t n) {
	if (n == 0) { return realloc(p, 1); }  // If n is zero, allocate or keep a 1-byte block
	return realloc(p, n);
}


LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* eenmalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	return eemalloc((size_t)(n * s));
}


/* TODO: Create eealloc variants
eezalloc (size_t n) - like eemalloc followed by memset 0
eecalloc (size_t n, size_t s) - like eemalloc (n * s) followed by memset 0
eenrealloc (void *p, size_t n, size_t s) - like eerealloc (p, n * s)
emalloc
ecalloc
estrdup
*/


#endif  // EEALLOC_H


/* SAFE AUTOMATIC MEMORY ALLOCATION (<alloca.h> & <malloca.h>) */


#if (!(defined(_ALLOCA_H) || defined(_ALLOCA_H_) || defined(_MALLOCA_H) || defined(_MALLOCA_H_)))
#define ALLOCA_H   (1)
#define _ALLOCA_H   (1)
#define _ALLOCA_H_   (1)
#define MALLOCA_H   (1)
#define _MALLOCA_H   (1)
#define _MALLOCA_H_   (1)
#define _GL_ALLOCATOR_H   (1)
#define _GL_USE_STDLIB_ALLOC   (1)


/** An object describing a memory allocator family */
typedef struct allocator {
	void* (*allocate)(size_t);
	void* (*reallocate)(void*, size_t);
	void (*free)(void*);
	void (*die)(size_t);
} allocator_t;


#define MAGIC_NUMBER   0x1415fb4a
#define MAGIC_SIZE   SIZEOF_INT
/** Make the hash table large, so that during lookups the probability of empty hash buckets is high */
#define HASH_TABLE_SIZE   257
#define __MAX_ALLOCA_CUTOFF   65536
#define MAX_ALLOCA_CUTOFF   __MAX_ALLOCA_CUTOFF
static UNUSED void* mmalloca_results[HASH_TABLE_SIZE];
/** This is how the header info would look like without any alignment considerations */
struct attr_packed preliminary_header { void* next; int magic; };
#define SIZEOF_PRELIMINARY_HEADER   (SIZEOF_INT + SIZEOF_POINTER)
/** The header's size must be a multiple of sa_alignment_max */
#define HEADER_SIZE   (((SIZEOF_PRELIMINARY_HEADER + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)
union header {
	void* next;
	char* deep;
	struct magic_header {
		char room[HEADER_SIZE - MAGIC_SIZE];
		int word;
	} magic;
};
UNUSED union header* last_alloca_header = NULL;


/** safe_alloca(N) is equivalent to alloca(N) when it is safe to call alloca(N); otherwise it returns NULL; It either returns N bytes of memory allocated on the stack, that lasts until the function returns, or NULL; The use of safe_alloca should be avoided inside arguments of function calls and in inline functions */
#if HAVE_ALLOCA  // safe_alloca & malloca
/** The OS usually guarantees only one guard page at the bottom of the stack, and a page size can be as small as 4096 bytes */
#   define safe_alloca(N)   ((N) < 4032 ? (alloca(N)) : NULL)
/** malloca(N) is a safe variant of alloca(N); It allocates N bytes of memory allocated on the stack, that must be freed using freea() before the function returns; Upon failure, it returns NULL */
#   define malloca(N)   ((N) < 4032 - sa_increment ? (void*)((char*)alloca((N) + sa_increment) + sa_increment) : mmalloca(N))
#else
#   define safe_alloca(N)   ((void)(N), NULL)
#   define malloca(N)   mmalloca(N)
#endif
/** nmalloca(N,S) is an overflow-safe variant of malloca(N * S); It allocates an array of N objects, each with S bytes of memory, on the stack; S must be positive and N must be nonnegative; The array must be freed using freea() before the function returns */
#define nmalloca(n, s)   ((n) > (size_t)(SIZEOF_PTRDIFF_T <= SIZEOF_SIZE_T ? -1 : -2) / (s) ? NULL : malloca((n) * (s)))


/** An allocator using the stdlib functions and a null DIE function */
static const UNUSED struct allocator stdlib_allocator = { malloc, realloc, free, NULL };


LIB_FUNC int find_stack_direction(int* addr, const int depth) {
	int _dummy = 0;
	if (!addr) { addr = &_dummy; }
	*addr = (addr < &_dummy ? 1 : ((addr == &_dummy) ? 0 : -1));
	return (int)((depth ? find_stack_direction(addr, (depth - 1)) : 0) + _dummy);
}


/** Allocate automatically reclaimed memory */
LIB_FUNC void* alloca(const size_t size) {
	auto char probe = 0;
	register char* depth = ADDRESS_FUNCTION(probe);
#   if IS_STACK_DIRECTION_UKNOWN
	if (STACK_DIR == 0) { STACK_DIR = find_stack_direction(NULL, ((size & 1) + 20)); }
#   endif
	// Reclaim garbage
	register union header* hp = last_alloca_header;
	for (; hp != NULL;) {
		if ((STACK_DIR > 0 && hp->deep > depth) || (STACK_DIR < 0 && hp->deep < depth)) {
			register union header* np = hp->next;
			free(hp);
			hp = np;
		} else { break; }
	}
	last_alloca_header = hp;
	if (size == 0) { return NULL; }  // No allocation required
	// Allocate combined header + user data storage
	union header* new = NULL;
	const size_t combined_size = (sizeof(union header) + size);
	if (combined_size < sizeof(union header)) { memory_full(); }
	new = malloc(combined_size);
	if (!new) { memory_full(); }
	new->next = last_alloca_header;
	new->deep = depth;
	last_alloca_header = new;
	return (void*)(new + 1);
}
#define strdupa(x)   strcpy(alloca(strlen((x)) + 1), (x))


LIB_FUNC void* mmalloca(const size_t len) {
	register size_t nplus = (size_t)(len + HEADER_SIZE);
	if (nplus >= len) {
		void* p = malloc(nplus);
		if (p != NULL) {
			union header* h = p;
			p = h + 1;
			// Put a magic number into the indicator word
			h->magic.word = MAGIC_NUMBER;
			// Enter p into the hash table
			const size_t _slot = (size_t)((uintptr_t)p % HASH_TABLE_SIZE);
			h->next = mmalloca_results[_slot];
			mmalloca_results[_slot] = p;
			return p;
		}
	}
	return NULL;  // Out of memory
}


/** Free a block of memory allocated through malloca() */
LIB_FUNC void freea(void* p) {
	if ((p != NULL) && (((int*) p)[-1] == MAGIC_NUMBER)) {
		const size_t _slot = (size_t)((uintptr_t)p % HASH_TABLE_SIZE);
		void** chain = &mmalloca_results[_slot];
		for (; *chain != NULL;) {
			union header* h = p;
			if (*chain == p) {
				union header* p_begin = h - 1;
				*chain = p_begin->next;
				free(p_begin);
				return;
			}
			h = *chain;
			chain = &h[-1].next;
		} UNREACHABLE
	} else { return; }
}


#endif  // ALLOCA_H


/* MALLOC WITH OUT-OF-MEMORY CHECKING (<xmalloc.h>, <xmalloca.h>, & <xalloc.h>) */


#if (!(defined(_XMALLOC_H) || defined(_XMALLOC_H_) || defined(XALLOC_H) || defined(XALLOC_H_)))
#define XMALLOC_H   (1)
#define _XMALLOC_H   (1)
#define _XMALLOC_H_   (1)
#define XALLOC_H   (1)
#define XALLOC_H_   (1)
#define _XALLOC_H_   (1)
#define XMALLOCA_H   (1)
#define _XMALLOCA_H   (1)
#define _XMALLOCA_H_   (1)


/** Allocate an object of type T dynamically, with error checking */
#define XMALLOC(t)   ((t*)xmalloc(sizeof(t)))
/** Allocate memory for N elements of type T, with error checking */
#define XNMALLOC(n, t)   ((t*)(sizeof(t) == 1 ? xmalloc(n) : xnmalloc(n, sizeof(t))))
/** Allocate an object of type T dynamically, with error checking, and zero it */
#define XZALLOC(t)   ((t*)xzalloc(sizeof(t)))
/** Allocate memory for N elements of type T, with error checking, and zero it */
#define XCALLOC(n, t)   ((t*)(sizeof(t) == 1 ? xzalloc(n) : xcalloc(n, sizeof(t))))
/** xmalloca(N) is a checking safe variant of alloca(N); It allocates N bytes of memory allocated on the stack, that must be freed using freea() before the function returns; Upon failure, it exits with an error message */
#define xmalloca(N)   ((N) < (4032 - sa_increment) ? (void*)((char*)alloca((N) + sa_increment) + sa_increment) : xmmalloca(N))
/** xnmalloca(N,S) is an overflow-safe variant of xmalloca(N * S); It allocates an array of N objects, each with S bytes of memory, on the stack; S must be positive and N must be nonnegative; The array must be freed using freea() before the function returns; Upon failure, it exits with an error message */
#define xnmalloca(n, s)   xmalloca(xalloc_oversized((n), (s)) ? (size_t)-1 : (n) * (s))


LIB_FUNC void* fixup_null_alloc(const size_t n) {
	void* p = NULL;
	if (n == 0) { p = malloc((size_t)1); }
	if (p == 0) { error(EXIT_FAILURE, 0, "memory exhausted"); }
	return p;
}


LIB_FUNC noreturn COLD void xalloc_die(void) {
	error(exit_failure, 0, "Memory exhausted");
	fflush(NULL);  // Flush all streams
	ABORT;
}


/** Allocate zeroed memory for N elements of S bytes, with error checking; S must be nonzero */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* xcalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	void* p = NULL;
	if (xalloc_oversized(n, s) || (!(p = calloc(n, s)) && n != 0)) { xalloc_die(); }
	if (p == 0) { p = fixup_null_alloc(n); }
	return p;
}


/** Allocate N bytes of memory dynamically, with error checking */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* xmalloc(const size_t n) {
	if (n == 0) { return NULL; }
	void* p = malloc(n);
	if (!p && n != 0) { xalloc_die(); }
	return p;
}


/** Change the size of an allocated block of memory P to N bytes, with error checking; If P is NULL, run xmalloc */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(2) void* xrealloc(void* p, const size_t n) {
	if (p == 0) { return xmalloc(n); }
	else if (!n && p) { free(p); return NULL; }
	p = realloc(p, n);
	if (!p && n) { xalloc_die(); }
	return p;
}


LIB_FUNC void* xmmalloca(const size_t n) {
	if (n == 0) { return NULL; }
	void* p = mmalloca(n);
	if (p == NULL) { xalloc_die(); }
	return p;
}


/** Clone an object P of size S, with error checking; There is no need for xnmemdup(P, N, S), since xmemdup(P, N * S) works without any need for an arithmetic overflow check */
LIB_FUNC ATTR_ALLOC_SIZE(2) void* xmemdup(void const* p, const size_t s) {
	if (s == 0) { return NULL; }
	return memcpy(xmalloc(s), p, s);
}


/** Return a newly allocated copy of STRING */
LIB_FUNC ATTR_MALLOC char* xstrdup(const char* _string) {
	return xmemdup(_string, strlen(_string) + 1);
}


/** Allocate an array of N objects, each with S bytes of memory, dynamically, with error checking; S must be nonzero */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* xnmalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	else if (xalloc_oversized(n, s)) { xalloc_die(); }
	return xmalloc(n * s);
}


/** Change the size of an allocated block of memory P to an array of N objects each of S bytes, with error checking; S must be nonzero */
LIB_FUNC ATTR_ALLOC_SIZE(2) void* xnrealloc(void* p, const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	else if (xalloc_oversized(n, s)) { xalloc_die(); }
	return xrealloc(p, (n * s));
}


/** If P is null, allocate a block of at least *PN such objects; otherwise, reallocate P so that it contains more than *PN objects each of S bytes; S must be nonzero; Set *PN to the new number of objects, and return the pointer to the new block; *PN is never set to zero, and the returned pointer is never null */
LIB_FUNC void* x2nrealloc(void* p, size_t* pn, const size_t s) {
	size_t n = *pn;
	if (!p) {
		if (!n) {
			enum { DEFAULT_MXFAST = ((64 * SIZEOF_SIZE_T) >> 2) };
			n = DEFAULT_MXFAST / s;
			n += !n;
		}
	} else {
		if ((((size_t)-1) / 3 * 2 / s) <= n) { xalloc_die(); }
		n += ((n >> 1) + 1);
	}
	*pn = n;
	return xrealloc(p, (n * s));
}


/** Return a pointer to a new buffer of N bytes; This is like xmalloc, except it returns char * */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) char* xcharalloc(const size_t n) {
	if (n == 0) { return NULL; }
	return XNMALLOC(n, char);
}


/** If P is null, allocate a block of at least *PN bytes; otherwise, reallocate P so that it contains more than *PN bytes; *PN must be nonzero unless P is null; Set *PN to the new block's size, and return the pointer to the new block; *PN is never set to zero, and the returned pointer is never null */
LIB_FUNC void* x2realloc(void* p, size_t* pn) {
	return x2nrealloc(p, pn, 1);
}


/** Allocate S bytes of zeroed memory dynamically, with error checking; There is no need for xnzalloc (N, S), since it would be equivalent to xcalloc (N, S) */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* xzalloc(const size_t s) {
	if (s == 0) { return NULL; }
	return memset(xmalloc(s), 0, s);
}


// Scalar allocators
#define XALLOCA(T)   ((T*)alloca(sizeof(T)))
#define XNEW(T)   ((T*)xmalloc(sizeof(T)))
#define XCNEW(T)   ((T*)xcalloc(1, sizeof(T)))
#define XDUP(T, P)   ((T*)xmemdup((P), sizeof(T), sizeof(T)))
#define XDELETE(P)   free((void*)(P))
// Array allocators
#define XALLOCAVEC(T, N)   ((T*)alloca((sizeof(T) * (N))))
#define XNEWVEC(T, N)   ((T*)xmalloc((sizeof(T) * (N))))
#define XCNEWVEC(T, N)   ((T*)xcalloc((N), sizeof(T)))
#define XDUPVEC(T, P, N)   ((T*)xmemdup((P), (sizeof(T) * (N)), (sizeof(T) * (N))))
#define XRESIZEVEC(T, P, N)   ((T*)xrealloc((void*)(P), (sizeof(T) * (N))))
#define XDELETEVEC(P)   free((void*)(P))
// Allocators for variable-sized structures and raw buffers
#define XALLOCAVAR(T, S)   ((T*)alloca((S)))
#define XNEWVAR(T, S)   ((T*)xmalloc((S)))
#define XCNEWVAR(T, S)   ((T*)xcalloc(1, (S)))
#define XDUPVAR(T, P, S1, S2)   ((T*)xmemdup((P), (S1), (S2)))
#define XRESIZEVAR(T, P, S)   ((T*)xrealloc((P), (S)))
// Type-safe obstack allocator
#define XOBNEW(O, T)   ((T*)obstack_alloc((O), sizeof(T)))
#define XOBNEWVEC(O, T, N)   ((T*)obstack_alloc((O), (sizeof(T) * (N))))
#define XOBNEWVAR(O, T, S)   ((T*)obstack_alloc((O), (S)))
#define XOBFINISH(O, T)   ((T)obstack_finish((O)))


#endif  // XMALLOC_H


// MEMORY ALLOCATION ALIGNED TO SYSTEM PAGE BOUNDARIES (<pagealign_alloc.h>)


/** The list of currently allocated memory regions */
static UNUSED memnode_t* memnode_table = NULL;


LIB_FUNC void new_memnode(void* aligned_ptr, const info_t info) {
	memnode_t* new_node = XMALLOC(memnode_t);
	new_node->aligned_ptr = aligned_ptr;
	new_node->info = info;
	new_node->next = memnode_table;
	memnode_table = new_node;
}


/** Dispose of the memnode containing a map for the ALIGNED_PTR in question and return the content of the node's INFO field */
LIB_FUNC info_t get_memnode(void* aligned_ptr) {
	memnode_t* c = NULL;
	memnode_t** p_next = &memnode_table;
	for (c = *p_next; c != NULL; p_next = &c->next, c = c->next) {
		if (c->aligned_ptr == aligned_ptr) { break; }
	}
	if (c == NULL) { abort(); }  // Attempt to free untracked memory; A wrong pointer was passed to pagealign_free()
	// Remove this entry from the list, save the return value, and free it
	*p_next = c->next;
	const info_t ret = c->info;
	free(c);
	return ret;
}


/** Allocate a block of memory of SIZE bytes, aligned on a system page boundary; If SIZE is not a multiple of the system page size, it will be rounded up to the next multiple; Return a pointer to the start of the memory block; Upon allocation failure, return NULL and set errno */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* pagealign_alloc(const size_t size) {
	void* ret = mmap(NULL, size, (PROT_READ | PROT_WRITE), (MAP_ANONYMOUS | MAP_PRIVATE), -1, 0);
	if (ret == MAP_FAILED) { return NULL; }
	new_memnode(ret, size);
	return ret;
}


/** Like pagealign_alloc, except it exits the program if the allocation fails */
LIB_FUNC ATTR_MALLOC ATTR_ALLOC_SIZE(1) void* pagealign_xalloc(const size_t size) {
	void* ret = pagealign_alloc(size);
	if (ret == NULL) { xalloc_die(); }
	return ret;
}


/** Free a memory block; PTR must be a non-NULL pointer returned by pagealign_alloc or pagealign_xalloc */
LIB_FUNC void pagealign_free(void* aligned_ptr) {
#   if HAVE_MMAP
	if (munmap(aligned_ptr, get_memnode(aligned_ptr)) < 0) { error(EXIT_FAILURE, get_errno(), "Failed to unmap memory"); }
#   elif HAVE_POSIX_MEMALIGN
	free(aligned_ptr);
#   else
	free(get_memnode(aligned_ptr));
#   endif
}


/* TODO: Add sys/mman.h functions
int posix_mem_offset(const void* restrict, size_t, off_t* restrict, size_t* restrict, int* restrict);
int posix_typed_mem_get_info(int, struct posix_typed_mem_info *);
int posix_typed_mem_open(const char*, int, int);
*/


#endif  // SYS_MMAN_H


/* STRINGLIST (<bsd/stringlist.h>) */


#if (!(defined(STRINGLIST_H) || defined(_STRINGLIST_H) || defined(_STRINGLIST_H_)))
#define STRINGLIST_H   (1)
#define _STRINGLIST_H   (1)
#define _STRINGLIST_H_   (1)


#define _SL_CHUNKSIZE   20


/** Simple string list */
typedef struct _stringlist {
	char** sl_str;
	size_t sl_max, sl_cur;
} StringList;


/** Initialize a string list */
LIB_FUNC StringList* sl_init(void) {
	StringList* sl = NULL;
	sl = malloc(sizeof(StringList));
	if (sl == NULL) { err(1, "Invalid/NULL stringlist"); }
	sl->sl_cur = 0;
	sl->sl_max = _SL_CHUNKSIZE;
	sl->sl_str = malloc(sl->sl_max * SIZEOF_POINTER);
	if (sl->sl_str == NULL) { err(1, "Invalid/NULL stringlist"); }
	return sl;
}


/** Add an item to the string list */
LIB_FUNC int sl_add(StringList* sl, char* name) {
	if (sl->sl_cur == sl->sl_max - 1) {
		char** _string = NULL;
		sl->sl_max += _SL_CHUNKSIZE;
		_string = realloc(sl->sl_str, (size_t)(sl->sl_max * SIZEOF_POINTER));
		if (_string == NULL) { return -1; }
		sl->sl_str = _string;
	}
	sl->sl_str[sl->sl_cur++] = name;
	return 0;
}


/** Free a stringlist */
LIB_FUNC void sl_free(StringList* sl, const int all) {
	if (sl == NULL) { return; }
	else if (sl->sl_str) {
		register size_t i = 0;
		if (all) { for (; i < sl->sl_cur; i++) { free(sl->sl_str[i]); } }
		free(sl->sl_str);
	}
	free(sl);
}


/** Find a name in the string list */
LIB_FUNC char* sl_find(StringList* sl, char* restrict name) {
	register size_t i = 0;
	for (; i < sl->sl_cur; i++) {
		if (strcmp(sl->sl_str[i], name) == 0) { return sl->sl_str[i]; }
	}
	return NULL;
}


#endif  // STRINGLIST_H


/* GETOPT (<getopt.h>) */


#if (!(defined(GETOPT_H) || defined(_GETOPT_H) || defined(_GETOPT_H_) || defined(_GETOPT)))
#define GETOPT_H   (1)
#define _GETOPT_H   (1)
#define _GETOPT_H_   (1)
#define _GETOPT   (1)
#define _OPTRESET   (1)


#define no_argument   (0)
#define required_argument   (1)
#define optional_argument   (2)
#define BADCH   (int)'?'
#define BADARG   (int)':'
#define EMSG   (char*)NULL


typedef struct attr_packed option {
	const char* name;  //!< Name of long option
	int has_arg;
	int* flag;  //!< If not `NULL`, set `*flag` to `val` when option found
	int val;  //!< If flag not `NULL`, new value for `*flag`; else return value
} option_t;


// getopt variables
/** Callers store zero here to inhibit the error message `getopt` prints for unrecognized options */
static UNUSED int opterr = 1;
/** Index into parent argv vector; On entry to `getopt`, zero means this is the first call */
static UNUSED int optind = 1;
/** Character checked for validity; Set to an option character which was unrecognized */
extern UNUSED int optopt;
/** Reset getopt */
extern UNUSED int optreset;
/** Argument associated with getopt option; For communication from `getopt` to the caller */
extern UNUSED char* optarg;


/** Parse argc/argv argument vector */
static int getopt(const int nargc, char* const nargv[], const char* ostr) {
	static char* getopt_place = EMSG;  // option letter processing
	char* oli = NULL;  // option letter list index
	if (optreset || *getopt_place == 0) {  // update scanning pointer
		optreset = 0;
		getopt_place = nargv[optind];
		if (optind >= nargc || *getopt_place++ != '-') {  // Argument is absent or is not an option
			getopt_place = EMSG;
			return -1;
		}
		optopt = *getopt_place++;
		if (optopt == '-' && *getopt_place == 0) {  // "--" => end of options
			++optind;
			getopt_place = EMSG;
			return -1;
		} else if (PREDICT_UNLIKELY(optopt == 0)) {  // Solitary '-'
			getopt_place = EMSG;
			if (strchr(ostr, '-') == (char*)NULL) { return -1; }
			optopt = '-';
		}
	} else { optopt = *getopt_place++; }  // See if option letter is one the caller wanted...
	if (optopt == ':' || (oli = strchr2(ostr, optopt)) == (char*)NULL) {
		if (*getopt_place == 0) { ++optind; }
		if (opterr && *ostr != ':') { (void)fprintf(stderr, "Illegal option -- %c\n", optopt); }
		return BADCH;
	}
	// Does this option need an argument?
	if (oli[1] != ':') {  // Does not need argument
		optarg = (char*)NULL;
		if (*getopt_place == 0) { ++optind; }
	} else {  // Option-argument is either the rest of this argument or the entire next argument */
		if (*getopt_place) { optarg = getopt_place; }
		else if (nargc > ++optind) { optarg = nargv[optind]; }
		else {  // Option-argument absent
#         ifdef __DARWIN_UNIX03
			++optind;  // Put optind past the last argument
			optarg = (char*)NULL;
#         endif  // __DARWIN_UNIX03
			getopt_place = EMSG;
			if (*ostr == ':') { return BADARG; }
			else if (PREDICT_LIKELY(opterr)) { (void)fprintf(stderr, "Option requires an argument -- %c\n", optopt); }
			return BADCH;
		}
		getopt_place = EMSG;
		++optind;
	}
	return optopt;  // Return option letter
}


/** Parse argc/argv argument vector with long options */
static int __getopt_long(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx, int longonly) {
	if (optind >= argc || !argv[optind] || argv[optind][0] != '-') { return -1; }
	else if (PREDICT_LIKELY((longonly && argv[optind][1]) || ((argv[optind][1] == '-') && argv[optind][2]))) {
		register int i = 0;
		for (; longopts[i].name; i++) {
			const char* name = longopts[i].name;
			char* opt = (argv[optind] + 2);
			while (*name && *name++ == *opt++);
			if (*name || (*opt && *opt != '=')) { continue; }
			else if (*opt == '=') {
				if (!longopts[i].has_arg) { continue; }
				optarg = opt + 1;
			} else {
				if (longopts[i].has_arg == required_argument) {
					if (!(optarg = argv[++optind])) { return ':'; }
				} else { optarg = (char*)NULL; }
			}
			optind++;
			if (idx) { *idx = i; }
			if (longopts[i].flag) {
				*longopts[i].flag = longopts[i].val;
				return 0;
			}
			return longopts[i].val;
		}
		if (argv[optind][1] == '-') { optind++; return '?'; }
	}
	return getopt(argc, argv, optstring);
}


/** Parse argc/argv argument vector with long options */
LIB_FUNC int getopt_long(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx) {
	return __getopt_long(argc, argv, optstring, longopts, idx, 0);
}


/** Parse argc/argv argument vector with long options */
LIB_FUNC int getopt_long_only(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx) {
	return __getopt_long(argc, argv, optstring, longopts, idx, 1);
}


#endif  // GETOPT_H
