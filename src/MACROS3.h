// -*- coding: utf-8 -*-
// vim:fileencoding=utf-8
/**
@file MACROS3.h
@author Devyn Collier Johnson <DevynCJohnson@Gmail.com>
@copyright LGPLv3

@brief Standard Macros Header with AT&T-style Assembly
@version 2017.07.15

@section DESCRIPTION
This file defines various datatypes, macros functions, and names used in MACROS.h.
Substitutes for most standard C libraries are also provided.
 - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/contents.html

@section LICENSE
GNU Lesser General Public License v3
Copyright (c) Devyn Collier Johnson, All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library.
*/


/* SIGNAL STACK (<bits/sigstack.h>) */


#if (!(defined(SIGSTACK_H) || defined(_SIGSTACK_H) || defined(_SIGSTACK_H_)))
#define SIGSTACK_H   (1)
#define _SIGSTACK_H   (1)
#define _SIGSTACK_H_   (1)


// Possible values for `ss_flags`
#define SS_ONSTACK   1
#define SS_DISABLE   2


#ifdef ALPHA


/** Minimum stack size for a signal handler */
#define MINSIGSTKSZ   4096
/** System default stack size */
#define SIGSTKSZ   16384

/** Structure describing a signal stack */
typedef struct attr_packed sigstack {
	void* ss_sp;  // Signal stack pointer
	int ss_onstack;  // Nonzero if executing on this stack
} sigstack_t;

/** Preferred signal stack interface */
typedef struct attr_packed sigaltstack {
	void* ss_sp;
	int ss_flags;
	size_t ss_size;
} stack_t;


#elif defined(MIPS)


/** Minimum stack size for a signal handler */
#define MINSIGSTKSZ   2048
/** System default stack size */
#define SIGSTKSZ   8192

/** Structure describing a signal stack */
typedef struct attr_packed sigstack {
	void* ss_sp;  // Signal stack pointer
	int ss_onstack;  // Nonzero if executing on this stack
} sigstack_t;

/** Preferred signal stack interface */
typedef struct attr_packed sigaltstack {
	void* ss_sp;
	size_t ss_size;
	int ss_flags;
} stack_t;


#elif defined(ITANIUM)


/** Minimum stack size for a signal handler */
#define MINSIGSTKSZ   131027
/** System default stack size */
#define SIGSTKSZ   262144

/** Structure describing a signal stack */
typedef struct attr_packed sigstack {
	void* ss_sp;  // Signal stack pointer
	int ss_onstack;  // Nonzero if executing on this stack
} sigstack_t;

/** Preferred signal stack interface */
typedef struct attr_packed sigaltstack {
	void* ss_sp;
	int ss_flags;
	size_t ss_size;
} stack_t;


#elif defined(SPARC)


/** Minimum stack size for a signal handler */
#define MINSIGSTKSZ   4096
/** System default stack size */
#define SIGSTKSZ   16384

/** Structure describing a signal stack */
typedef struct attr_packed sigstack {
	void* ss_sp;  // Signal stack pointer
	int ss_onstack;  // Nonzero if executing on this stack
} sigstack_t;

/** Preferred signal stack interface */
typedef struct attr_packed sigaltstack {
	void* ss_sp;
	int ss_flags;
	size_t ss_size;
} stack_t;


#else


/** Minimum stack size for a signal handler */
#define MINSIGSTKSZ   2048
/** System default stack size */
#define SIGSTKSZ   8192

/** Structure describing a signal stack */
typedef struct attr_packed sigstack {
	void* ss_sp;  // Signal stack pointer
	int ss_onstack;  // Nonzero if executing on this stack
} sigstack_t;

/** Preferred signal stack interface */
typedef struct attr_packed sigaltstack {
	void* ss_sp;
	int ss_flags;
	size_t ss_size;
} stack_t;


#endif  // ARCH


#endif  // SIGSTACK_H


/* MACHINE DEPENDENT CONSTANTS (<param.h>) */


#if (!(defined(_BSD_MACHINE_PARAM_H_) || defined(_BSD_MACHINE_VMPARAM_H_) || defined(_PARAM_H_)))
#define BSD_MACHINE_PARAM_H_   (1)
#define _BSD_MACHINE_PARAM_H_   (1)
#define BSD_MACHINE_VMPARAM_H_   (1)
#define _BSD_MACHINE_VMPARAM_H_   (1)
#define PARAM_H_   (1)
#define _PARAM_H_   (1)


#if ((defined(I386) || defined(X86) || defined(X86_64)) && (!(defined(_I386_PARAM_H_) || defined(_BSD_I386_VMPARAM_H_))))
#define _I386_PARAM_H_   (1)
#define I386_PARAM_H_   (1)
#define _BSD_I386_VMPARAM_H_   (1)
#define BSD_I386_VMPARAM_H_   (1)


/** Byte offset into page */
#define PGOFSET   4095
/** LOG2(NBPG) */
#define PGSHIFT   12
/** log2(DEV_BSIZE) */
#define DEV_BSHIFT   9
#define BLKDEV_IOSIZE   2048
/** Max raw I/O transfer size */
#define MAXPHYS   131072
#define CLSIZELOG2   0
#define RLIM_INFINITY   (~0ULL)
#define RLIM64_INFINITY   (~0ULL)
// Virtual memory related constants (in bytes)
#ifndef DFLDSIZ
/** Initial data size limit */
#   define DFLDSIZ   (RLIM_INFINITY)
#endif
#ifndef MAXDSIZ
/** Max data size */
#   define MAXDSIZ   (RLIM_INFINITY)
#endif
#ifndef DFLSSIZ
/** Initial stack size limit */
#   define DFLSSIZ   (8388608)
#endif
#ifndef MAXSSIZ
/** Max stack size */
#   define MAXSSIZ   (67108864)
#endif
#ifndef DFLCSIZ
/** Initial core size limit */
#   define DFLCSIZ   (0)
#endif
#ifndef MAXCSIZ
/** Max core size */
#   define MAXCSIZ   (RLIM_INFINITY)
#endif
#define VM_USRSTACK32   ((vm_offset_t)0xC0000000)
#define VM_USRSTACK64   ((user_addr_t)0x7FFF5FC00000ULL)
#define USRSTACK   VM_USRSTACK32
#define USRSTACK64   VM_USRSTACK64


// Constants related to network buffer management
#define MSIZESHIFT   8
#define MSIZE   (1 << MSIZESHIFT)
#define MCLSHIFT   11
/** Size of an mbuf cluster */
#define MCLBYTES   (1 << MCLSHIFT)
#define MBIGCLSHIFT   12
/** Size of a big cluster */
#define MBIGCLBYTES   (1 << MBIGCLSHIFT)
#define M16KCLSHIFT   14
/** Size of a jumbo cluster */
#define M16KCLBYTES   (1 << M16KCLSHIFT)
#define MCLOFSET   (MCLBYTES - 1)
#ifndef NMBCLUSTERS
/** cl map size: 1MB */
#   define   NMBCLUSTERS   ((1048576) / MCLBYTES)
#endif


/** Core clicks (NeXT_page_size bytes) to segments */
#define ctos(x)   (x)
/** Segments to Core clicks (NeXT_page_size bytes) */
#define stoc(x)   (x)
/** Core clicks (4096 bytes) to disk blocks */
#define ctod(x)   ((x) << (PGSHIFT - DEV_BSHIFT))
/** Disk blocks to Core clicks (4096 bytes) */
#define dtoc(x)   ((x) >> (PGSHIFT - DEV_BSHIFT))
/** Disk blocks to Core clicks (4096 bytes) */
#define dtob(x)   ((x) << DEV_BSHIFT)
/** Clicks to bytes */
#define ctob(x)   ((x) << PGSHIFT)
/** Bytes to clicks */
#define btoc(x)   (((unsigned)(x) + (NBPG - 1)) >> PGSHIFT)
#ifdef __APPLE__
#   define btodb(bytes, devBlockSize)   ((unsigned)(bytes) / (devBlockSize))
#   define dbtob(db, devBlockSize)   ((unsigned)(db) * (devBlockSize))
#else
#   define btodb(bytes)   ((unsigned)(bytes) >> DEV_BSHIFT)
#   define dbtob(db)   ((unsigned)(db) << DEV_BSHIFT)
#endif
/** Map a `block device block` to a file system block */
#define bdbtofsb(bn)   ((bn) / (BLKDEV_IOSIZE / DEV_BSIZE))

/** Macros to decode (and encode) processor status word */
#define STATUS_WORD(rpl, ipl)   (((ipl) << 8) | (rpl))
#define USERMODE(x)   (((x) & 3) == 3)
#define BASEPRI(x)   (((x) & 0xff00) == 0)
#define DELAY(n)   register int DELAY_N = (n); while (--DELAY_N > 0)


#endif  // I386_PARAM_H


#endif  // PARAM_H


/* ARM EABI AND C6X UNWINDERS (<unwind-arm-common.h>) */


#if ((defined(ARM) || defined(ARM64)) && (!defined(UNWIND_ARM_COMMON_H)))
#define UNWIND_ARM_COMMON_H   (1)
#define _UNWIND_ARM_COMMON_H   (1)
#define _UNWIND_ARM_COMMON_H_   (1)


#define __ARM_EABI_UNWINDER__   1
#define _UA_SEARCH_PHASE   1
#define _UA_CLEANUP_PHASE   2
#define _UA_HANDLER_FRAME   4
#define _UA_FORCE_UNWIND   8
#define _UA_END_OF_STACK   16
#define _URC_NO_REASON   _URC_OK
typedef unsigned int __attribute__((__mode__(__word__)))   _Unwind_Word;
typedef signed int __attribute__((__mode__(__word__)))   _Unwind_Sword;
typedef unsigned int __attribute__((__mode__(__pointer__)))   _Unwind_Ptr;
typedef unsigned int __attribute__((__mode__(__pointer__)))   _Unwind_Internal_Ptr;
typedef _Unwind_Word   _uw;
typedef _uw   _Unwind_EHT_Header;
typedef unsigned int __attribute__((__mode__(__DI__)))   _uw64;
typedef unsigned int __attribute__((__mode__(__HI__)))   _uw16;
typedef unsigned int __attribute__((__mode__(__QI__)))   _uw8;
typedef int   _Unwind_Action;
typedef long   _sleb128_t;
typedef unsigned long   _uleb128_t;
typedef char   _Unwind_Exception_Class[8];
typedef enum Unwind_Reason_Code {
	_URC_OK = 0,
	_URC_FOREIGN_EXCEPTION_CAUGHT = 1,
	_URC_END_OF_STACK = 5,
	_URC_HANDLER_FOUND = 6,
	_URC_INSTALL_CONTEXT = 7,
	_URC_CONTINUE_UNWIND = 8,
	_URC_FAILURE = 9
} _Unwind_Reason_Code;
typedef enum _Unwind_State {
	_US_VIRTUAL_UNWIND_FRAME = 0,
	_US_UNWIND_FRAME_STARTING = 1,
	_US_UNWIND_FRAME_RESUME = 2,
	_US_ACTION_MASK = 3,
	_US_FORCE_UNWIND = 8,
	_US_END_OF_STACK = 16
} _Unwind_State;
/** Virtual Register Set*/
typedef enum _Unwind_VRS_RegClass {
	_UVRSC_CORE = 0,  // Integer register
	_UVRSC_VFP = 1,  // vfp
	_UVRSC_FPA = 2,  // fpa
	_UVRSC_WMMXD = 3,  // Intel WMMX data register
	_UVRSC_WMMXC = 4  // Intel WMMX control register
} _Unwind_VRS_RegClass;
typedef enum _Unwind_VRS_DataRepresentation {
	_UVRSD_UINT32 = 0,
	_UVRSD_VFPX = 1,
	_UVRSD_FPAX = 2,
	_UVRSD_UINT64 = 3,
	_UVRSD_FLOAT = 4,
	_UVRSD_DOUBLE = 5
} _Unwind_VRS_DataRepresentation;
typedef enum _Unwind_VRS_Result {
	_UVRSR_OK = 0,
	_UVRSR_NOT_IMPLEMENTED = 1,
	_UVRSR_FAILED = 2
} _Unwind_VRS_Result;


typedef struct _Unwind_Control_Block {
	char exception_class[8];
	void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block*);
	struct unwinder_cache_s {  // Unwinder cache; private fields for the unwinder's use
		_uw reserved1;  // Forced unwind stop fn, 0 if not forced
		_uw reserved2;  // Personality routine address
		_uw reserved3;  // Saved callsite address
		_uw reserved4;  // Forced unwind stop arg
		_uw reserved5;
	} unwinder_cache;
	struct barrier_cache_s {  // Propagation barrier cache (valid after phase 1)
		_uw sp; _uw bitpattern[5];
	} barrier_cache;
	struct cleanup_cache_s { _uw bitpattern[4]; } cleanup_cache;  // Cleanup cache (preserved over cleanup)
	struct pr_cache_s {  // Pr cache (for pr's benefit)
		_uw fnstart;  // Function start address
		_Unwind_EHT_Header* ehtp;  // Pointer to EHT entry header word
		_uw additional;  // Additional data
		_uw reserved1;
	} pr_cache;
	long long padding:0;  // Force alignment to 8-byte boundary
} _Unwind_Control_Block;
#define _Unwind_Exception   _Unwind_Control_Block


/** Frame unwinding state */
typedef struct __gnu_unwind_state {
	_uw data;  // The current word (bytes packed msb first)
	_uw* next;  // Pointer to the next word of data
	_uw8 bytes_left;  // The number of bytes left in this word
	_uw8 words_left;  // The number of words pointed to by ptr
} __gnu_unwind_state;


#endif  // UNWIND_ARM_COMMON_H


/* AVR ARCHITECTURE AND DEVICE INFORMATION DATATYPES (<avr-arch.h>) */


#if (defined(AVR) && SUPPORTS_STDFIX && (!defined(AVR_ARCH_H)))
#define AVR_ARCH_H   (1)
#define _AVR_ARCH_H   (1)
#define _AVR_ARCH_H_   (1)


#define AVR_MMCU_DEFAULT   "avr2"


/** Indices for the avr_arch_types[] table */
typedef enum avr_arch_id {
	ARCH_UNKNOWN, ARCH_AVR1,
	ARCH_AVR2, ARCH_AVR25,
	ARCH_AVR3, ARCH_AVR31,
	ARCH_AVR35, ARCH_AVR4,
	ARCH_AVR5, ARCH_AVR51,
	ARCH_AVR6, ARCH_AVRTINY,
	ARCH_AVRXMEGA2, ARCH_AVRXMEGA4,
	ARCH_AVRXMEGA5, ARCH_AVRXMEGA6, ARCH_AVRXMEGA7
} avr_arch_id_t;


/** Architecture-specific properties */
typedef struct avr_arch {
	int asm_only;
	// Core have 'MUL*' instructions
	int have_mul;
	// Core have 'CALL' and 'JMP' instructions
	int have_jmp_call;
	// Core have 'MOVW' and 'LPM Rx,Z' instructions
	int have_movw_lpmx;
	// Core have 'ELPM' instructions
	int have_elpm;
	// Core have 'ELPM Rx,Z' instructions
	int have_elpmx;
	// Core have 'EICALL' and 'EIJMP' instructions
	int have_eijmp_eicall;
	// This is an XMEGA core
	int xmega_p;
	// This core has the RAMPD special function register and thus also the RAMPX, RAMPY, and RAMPZ registers
	int have_rampd;
	// This is a TINY core
	int tiny_p;
	// Default start of data section address for architecture
	int default_data_section_start;
	// Offset between SFR address and RAM address: SFR-address = RAM-address - sfr_offset
	int sfr_offset;
	// Architecture id to built-in define __AVR_ARCH__ (NULL -> no macro)
	const char* const macro;
	// Architecture name
	const char* const name;
} avr_arch_t;


/** Device-specific properties */
typedef struct avr_mcu {
	// Device name
	const char* const name;
	// Index in avr_arch_types[]
	enum avr_arch_id arch_id;
	// Device specific feature
	int dev_attribute;
	// Must lie outside user's namespace; NULL == no macro
	const char* const macro;
	// Start of data section
	int data_section_start;
	// Start of text section
	int text_section_start;
	// Number of 64k segments in the flash
	int n_flash;
} avr_mcu_t;


/** AVR device specific features */
enum avr_device_specific_features {
	AVR_ISA_NONE,
	AVR_ISA_RMW = 1,  // Device has RMW instructions
	AVR_SHORT_SP = 2,  // Stack Pointer has 8 bits width
	AVR_ERRATA_SKIP = 4  // Device has a core erratum
};


/** Map architecture to its texinfo string */
typedef struct avr_arch_info {
	enum avr_arch_id arch_id;  // Architecture ID
	const char* texinfo;  // Textinfo source to describe the archtiecture
} avr_arch_info_t;


/** Preprocessor macros to define depending on MCU type */
static const UNUSED avr_arch_t avr_arch_types[];
static const UNUSED avr_arch_t* avr_arch;
static const UNUSED avr_mcu_t avr_mcu_types[];


#endif  // AVR_ARCH_H


/* VMX ARCHITECTURE RELATED DEFINITIONS (<vmx.h>) */


#if ((!(defined(VMX_H) || defined(_VMX_H) || defined(_VMX_H_))) && defined(ARCH_VMX))
#define VMX_H   (1)
#define _VMX_H   (1)
#define _VMX_H_   (1)


// Definitions of Primary Processor-Based VM-Execution Controls
#define CPU_BASED_VIRTUAL_INTR_PENDING   4
#define CPU_BASED_USE_TSC_OFFSETING   8
#define CPU_BASED_HLT_EXITING   0x80
#define CPU_BASED_INVLPG_EXITING   0x200
#define CPU_BASED_MWAIT_EXITING   0x400
#define CPU_BASED_RDPMC_EXITING   0x800
#define CPU_BASED_RDTSC_EXITING   0x1000
#define CPU_BASED_CR3_LOAD_EXITING   0x8000
#define CPU_BASED_CR3_STORE_EXITING   0x10000
#define CPU_BASED_CR8_LOAD_EXITING   0x80000
#define CPU_BASED_CR8_STORE_EXITING   0x100000
#define CPU_BASED_TPR_SHADOW   0x200000
#define CPU_BASED_VIRTUAL_NMI_PENDING   0x400000
#define CPU_BASED_MOV_DR_EXITING   0x800000
#define CPU_BASED_UNCOND_IO_EXITING   0x1000000
#define CPU_BASED_USE_IO_BITMAPS   0x2000000
#define CPU_BASED_USE_MSR_BITMAPS   0x10000000
#define CPU_BASED_MONITOR_EXITING   0x20000000
#define CPU_BASED_PAUSE_EXITING   0x40000000
#define CPU_BASED_ACTIVATE_SECONDARY_CONTROLS   0x80000000
#define CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR   0x401e172
// Definitions of Secondary Processor-Based VM-Execution Controls
#define SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES   1
#define SECONDARY_EXEC_ENABLE_EPT   2
#define SECONDARY_EXEC_RDTSCP   8
#define SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE   0x10
#define SECONDARY_EXEC_ENABLE_VPID   0x20
#define SECONDARY_EXEC_WBINVD_EXITING   0x40
#define SECONDARY_EXEC_UNRESTRICTED_GUEST   0x80
#define SECONDARY_EXEC_APIC_REGISTER_VIRT   0x100
#define SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY   0x200
#define SECONDARY_EXEC_PAUSE_LOOP_EXITING   0x400
#define SECONDARY_EXEC_ENABLE_INVPCID   0x1000
#define SECONDARY_EXEC_SHADOW_VMCS   0x4000
#define SECONDARY_EXEC_ENABLE_PML   0x20000
#define SECONDARY_EXEC_XSAVES   0x100000
#define PIN_BASED_EXT_INTR_MASK   1
#define PIN_BASED_NMI_EXITING   8
#define PIN_BASED_VIRTUAL_NMIS   0x20
#define PIN_BASED_VMX_PREEMPTION_TIMER   0x40
#define PIN_BASED_POSTED_INTR   0x80
#define PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR   0x16
#define VM_EXIT_SAVE_DEBUG_CONTROLS   4
#define VM_EXIT_HOST_ADDR_SPACE_SIZE   0x200
#define VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL   0x1000
#define VM_EXIT_ACK_INTR_ON_EXIT   0x8000
#define VM_EXIT_SAVE_IA32_PAT   0x40000
#define VM_EXIT_LOAD_IA32_PAT   0x80000
#define VM_EXIT_SAVE_IA32_EFER   0x100000
#define VM_EXIT_LOAD_IA32_EFER   0x200000
#define VM_EXIT_SAVE_VMX_PREEMPTION_TIMER   0x400000
#define VM_EXIT_CLEAR_BNDCFGS   0x800000
#define VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR   0x36dff
#define VM_ENTRY_LOAD_DEBUG_CONTROLS   0x4
#define VM_ENTRY_IA32E_MODE   0x200
#define VM_ENTRY_SMM   0x400
#define VM_ENTRY_DEACT_DUAL_MONITOR   0x800
#define VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL   0x2000
#define VM_ENTRY_LOAD_IA32_PAT   0x4000
#define VM_ENTRY_LOAD_IA32_EFER   0x8000
#define VM_ENTRY_LOAD_BNDCFGS   0x10000
#define VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR   0x11ff
#define VMX_MISC_PREEMPTION_TIMER_RATE_MASK   0x1f
#define VMX_MISC_SAVE_EFER_LMA   0x20
#define VMX_MISC_ACTIVITY_HLT   0x40


/** VMCS Encodings */
enum vmcs_field {
	VIRTUAL_PROCESSOR_ID = 0,
	POSTED_INTR_NV = 2,
	GUEST_ES_SELECTOR = 0x800,
	GUEST_CS_SELECTOR = 0x802,
	GUEST_SS_SELECTOR = 0x804,
	GUEST_DS_SELECTOR = 0x806,
	GUEST_FS_SELECTOR = 0x808,
	GUEST_GS_SELECTOR = 0x80a,
	GUEST_LDTR_SELECTOR = 0x80c,
	GUEST_TR_SELECTOR = 0x80e,
	GUEST_INTR_STATUS = 0x810,
	GUEST_PML_INDEX = 0x812,
	HOST_ES_SELECTOR = 0xc00,
	HOST_CS_SELECTOR = 0xc02,
	HOST_SS_SELECTOR = 0xc04,
	HOST_DS_SELECTOR = 0xc06,
	HOST_FS_SELECTOR = 0xc08,
	HOST_GS_SELECTOR = 0xc0a,
	HOST_TR_SELECTOR = 0xc0c,
	IO_BITMAP_A = 0x2000,
	IO_BITMAP_A_HIGH = 0x2001,
	IO_BITMAP_B = 0x2002,
	IO_BITMAP_B_HIGH = 0x2003,
	MSR_BITMAP = 0x2004,
	MSR_BITMAP_HIGH = 0x2005,
	VM_EXIT_MSR_STORE_ADDR = 0x2006,
	VM_EXIT_MSR_STORE_ADDR_HIGH = 0x2007,
	VM_EXIT_MSR_LOAD_ADDR = 0x2008,
	VM_EXIT_MSR_LOAD_ADDR_HIGH = 0x2009,
	VM_ENTRY_MSR_LOAD_ADDR = 0x200a,
	VM_ENTRY_MSR_LOAD_ADDR_HIGH = 0x200b,
	PML_ADDRESS = 0x200e,
	PML_ADDRESS_HIGH = 0x200f,
	TSC_OFFSET = 0x2010,
	TSC_OFFSET_HIGH = 0x2011,
	VIRTUAL_APIC_PAGE_ADDR = 0x2012,
	VIRTUAL_APIC_PAGE_ADDR_HIGH = 0x2013,
	APIC_ACCESS_ADDR = 0x2014,
	APIC_ACCESS_ADDR_HIGH = 0x2015,
	POSTED_INTR_DESC_ADDR = 0x2016,
	POSTED_INTR_DESC_ADDR_HIGH = 0x2017,
	EPT_POINTER = 0x201a,
	EPT_POINTER_HIGH = 0x201b,
	EOI_EXIT_BITMAP0 = 0x201c,
	EOI_EXIT_BITMAP0_HIGH = 0x201d,
	EOI_EXIT_BITMAP1 = 0x201e,
	EOI_EXIT_BITMAP1_HIGH = 0x201f,
	EOI_EXIT_BITMAP2 = 0x2020,
	EOI_EXIT_BITMAP2_HIGH = 0x2021,
	EOI_EXIT_BITMAP3 = 0x2022,
	EOI_EXIT_BITMAP3_HIGH = 0x2023,
	VMREAD_BITMAP = 0x2026,
	VMWRITE_BITMAP = 0x2028,
	XSS_EXIT_BITMAP = 0x202C,
	XSS_EXIT_BITMAP_HIGH = 0x202D,
	GUEST_PHYSICAL_ADDRESS = 0x2400,
	GUEST_PHYSICAL_ADDRESS_HIGH = 0x2401,
	VMCS_LINK_POINTER = 0x2800,
	VMCS_LINK_POINTER_HIGH = 0x2801,
	GUEST_IA32_DEBUGCTL = 0x2802,
	GUEST_IA32_DEBUGCTL_HIGH = 0x2803,
	GUEST_IA32_PAT = 0x2804,
	GUEST_IA32_PAT_HIGH = 0x2805,
	GUEST_IA32_EFER = 0x2806,
	GUEST_IA32_EFER_HIGH = 0x2807,
	GUEST_IA32_PERF_GLOBAL_CTRL	= 0x2808,
	GUEST_IA32_PERF_GLOBAL_CTRL_HIGH= 0x2809,
	GUEST_PDPTR0 = 0x280a,
	GUEST_PDPTR0_HIGH = 0x280b,
	GUEST_PDPTR1 = 0x280c,
	GUEST_PDPTR1_HIGH = 0x280d,
	GUEST_PDPTR2 = 0x280e,
	GUEST_PDPTR2_HIGH = 0x280f,
	GUEST_PDPTR3 = 0x2810,
	GUEST_PDPTR3_HIGH = 0x2811,
	GUEST_BNDCFGS = 0x2812,
	GUEST_BNDCFGS_HIGH = 0x2813,
	HOST_IA32_PAT = 0x2c00,
	HOST_IA32_PAT_HIGH = 0x2c01,
	HOST_IA32_EFER = 0x2c02,
	HOST_IA32_EFER_HIGH = 0x2c03,
	HOST_IA32_PERF_GLOBAL_CTRL	= 0x2c04,
	HOST_IA32_PERF_GLOBAL_CTRL_HIGH	= 0x2c05,
	PIN_BASED_VM_EXEC_CONTROL = 0x4000,
	CPU_BASED_VM_EXEC_CONTROL = 0x4002,
	EXCEPTION_BITMAP = 0x4004,
	PAGE_FAULT_ERROR_CODE_MASK = 0x4006,
	PAGE_FAULT_ERROR_CODE_MATCH = 0x4008,
	CR3_TARGET_COUNT = 0x400a,
	VM_EXIT_CONTROLS = 0x400c,
	VM_EXIT_MSR_STORE_COUNT = 0x400e,
	VM_EXIT_MSR_LOAD_COUNT = 0x4010,
	VM_ENTRY_CONTROLS = 0x4012,
	VM_ENTRY_MSR_LOAD_COUNT = 0x4014,
	VM_ENTRY_INTR_INFO_FIELD = 0x4016,
	VM_ENTRY_EXCEPTION_ERROR_CODE = 0x4018,
	VM_ENTRY_INSTRUCTION_LEN = 0x401a,
	TPR_THRESHOLD = 0x401c,
	SECONDARY_VM_EXEC_CONTROL = 0x401e,
	PLE_GAP = 0x4020,
	PLE_WINDOW = 0x4022,
	VM_INSTRUCTION_ERROR = 0x4400,
	VM_EXIT_REASON = 0x4402,
	VM_EXIT_INTR_INFO = 0x4404,
	VM_EXIT_INTR_ERROR_CODE = 0x4406,
	IDT_VECTORING_INFO_FIELD = 0x4408,
	IDT_VECTORING_ERROR_CODE = 0x440a,
	VM_EXIT_INSTRUCTION_LEN = 0x440c,
	VMX_INSTRUCTION_INFO = 0x440e,
	GUEST_ES_LIMIT = 0x4800,
	GUEST_CS_LIMIT = 0x4802,
	GUEST_SS_LIMIT = 0x4804,
	GUEST_DS_LIMIT = 0x4806,
	GUEST_FS_LIMIT = 0x4808,
	GUEST_GS_LIMIT = 0x480a,
	GUEST_LDTR_LIMIT = 0x480c,
	GUEST_TR_LIMIT = 0x480e,
	GUEST_GDTR_LIMIT = 0x4810,
	GUEST_IDTR_LIMIT = 0x4812,
	GUEST_ES_AR_BYTES = 0x4814,
	GUEST_CS_AR_BYTES = 0x4816,
	GUEST_SS_AR_BYTES = 0x4818,
	GUEST_DS_AR_BYTES = 0x481a,
	GUEST_FS_AR_BYTES = 0x481c,
	GUEST_GS_AR_BYTES = 0x481e,
	GUEST_LDTR_AR_BYTES = 0x4820,
	GUEST_TR_AR_BYTES = 0x4822,
	GUEST_INTERRUPTIBILITY_INFO = 0x4824,
	GUEST_ACTIVITY_STATE = 0x4826,
	GUEST_SYSENTER_CS = 0x482A,
	VMX_PREEMPTION_TIMER_VALUE = 0x482E,
	HOST_IA32_SYSENTER_CS = 0x4c00,
	CR0_GUEST_HOST_MASK = 0x6000,
	CR4_GUEST_HOST_MASK = 0x6002,
	CR0_READ_SHADOW = 0x6004,
	CR4_READ_SHADOW = 0x6006,
	CR3_TARGET_VALUE0 = 0x6008,
	CR3_TARGET_VALUE1 = 0x600a,
	CR3_TARGET_VALUE2 = 0x600c,
	CR3_TARGET_VALUE3 = 0x600e,
	EXIT_QUALIFICATION = 0x6400,
	GUEST_LINEAR_ADDRESS = 0x640a,
	GUEST_CR0 = 0x6800,
	GUEST_CR3 = 0x6802,
	GUEST_CR4 = 0x6804,
	GUEST_ES_BASE = 0x6806,
	GUEST_CS_BASE = 0x6808,
	GUEST_SS_BASE = 0x680a,
	GUEST_DS_BASE = 0x680c,
	GUEST_FS_BASE = 0x680e,
	GUEST_GS_BASE = 0x6810,
	GUEST_LDTR_BASE = 0x6812,
	GUEST_TR_BASE = 0x6814,
	GUEST_GDTR_BASE = 0x6816,
	GUEST_IDTR_BASE = 0x6818,
	GUEST_DR7 = 0x681a,
	GUEST_RSP = 0x681c,
	GUEST_RIP = 0x681e,
	GUEST_RFLAGS = 0x6820,
	GUEST_PENDING_DBG_EXCEPTIONS = 0x6822,
	GUEST_SYSENTER_ESP = 0x6824,
	GUEST_SYSENTER_EIP = 0x6826,
	HOST_CR0 = 0x6c00,
	HOST_CR3 = 0x6c02,
	HOST_CR4 = 0x6c04,
	HOST_FS_BASE = 0x6c06,
	HOST_GS_BASE = 0x6c08,
	HOST_TR_BASE = 0x6c0a,
	HOST_GDTR_BASE = 0x6c0c,
	HOST_IDTR_BASE = 0x6c0e,
	HOST_IA32_SYSENTER_ESP = 0x6c10,
	HOST_IA32_SYSENTER_EIP = 0x6c12,
	HOST_RSP = 0x6c14,
	HOST_RIP = 0x6c16
};


// Interruption-information format
#define INTR_INFO_VECTOR_MASK   0xff
#define INTR_INFO_INTR_TYPE_MASK   0x700
#define INTR_INFO_DELIVER_CODE_MASK   0x800
#define INTR_INFO_UNBLOCK_NMI   0x1000
#define INTR_INFO_VALID_MASK   0x80000000
#define INTR_INFO_RESVD_BITS_MASK   0x7ffff000
#define VECTORING_INFO_VECTOR_MASK   INTR_INFO_VECTOR_MASK
#define VECTORING_INFO_TYPE_MASK   INTR_INFO_INTR_TYPE_MASK
#define VECTORING_INFO_DELIVER_CODE_MASK   INTR_INFO_DELIVER_CODE_MASK
#define VECTORING_INFO_VALID_MASK   INTR_INFO_VALID_MASK
/** External interrupt */
#define INTR_TYPE_EXT_INTR   (0)
#define INTR_TYPE_NMI_INTR   (0x200)
/** Processor exception */
#define INTR_TYPE_HARD_EXCEPTION   (0x300)
/** Software interrupt */
#define INTR_TYPE_SOFT_INTR   (0x400)
/** Software exception */
#define INTR_TYPE_SOFT_EXCEPTION   (0x600)

// GUEST_INTERRUPTIBILITY_INFO flags
#define GUEST_INTR_STATE_STI   (1)
#define GUEST_INTR_STATE_MOV_SS   (2)
#define GUEST_INTR_STATE_SMI   (4)
#define GUEST_INTR_STATE_NMI   (8)

// GUEST_ACTIVITY_STATE flags
#define GUEST_ACTIVITY_ACTIVE   (0)
#define GUEST_ACTIVITY_HLT   (1)
#define GUEST_ACTIVITY_SHUTDOWN   (2)
#define GUEST_ACTIVITY_WAIT_SIPI   (3)

// Exit Qualifications for MOV for Debug Register Access
#define DEBUG_REG_ACCESS_NUM    (7)
#define DEBUG_REG_ACCESS_TYPE   (0x10)
#define TYPE_MOV_TO_DR   (0)
#define TYPE_MOV_FROM_DR   (0x10)
#define DEBUG_REG_ACCESS_REG(eq)   (((eq) >> 8) & 0xf)

// Exit Qualifications for APIC-Access
#define APIC_ACCESS_OFFSET   (0xfff)
#define APIC_ACCESS_TYPE   (0xf000)
#define TYPE_LINEAR_APIC_INST_READ   (0)
#define TYPE_LINEAR_APIC_INST_WRITE   (0x1000)
#define TYPE_LINEAR_APIC_INST_FETCH   (0x2000)
#define TYPE_LINEAR_APIC_EVENT   (0x3000)
#define TYPE_PHYSICAL_APIC_EVENT   (0xa000)
#define TYPE_PHYSICAL_APIC_INST   (0xf000)

// Exit Qualifications for MOV for Control Register Access
#define CONTROL_REG_ACCESS_NUM   (7)
#define CONTROL_REG_ACCESS_TYPE   (0x30)
#define CONTROL_REG_ACCESS_REG   (0xf00)
#define LMSW_SOURCE_DATA_SHIFT   (16)
#define LMSW_SOURCE_DATA   (0xFFFF << LMSW_SOURCE_DATA_SHIFT)
#define REG_EAX   (0)
#define REG_ECX   (0x100)
#define REG_EDX   (0x200)
#define REG_EBX   (0x300)
#define REG_ESP   (0x400)
#define REG_EBP   (0x500)
#define REG_ESI   (0x600)
#define REG_EDI   (0x700)
#define REG_R8   (0x800)
#define REG_R9   (0x900)
#define REG_R10   (0xa00)
#define REG_R11   (0xb00)
#define REG_R12   (0xc00)
#define REG_R13   (0xd00)
#define REG_R14   (0xe00)
#define REG_R15   (0xf00)

// Segment AR
#define SEGMENT_AR_L_MASK   (0x2000)
#define AR_TYPE_ACCESSES_MASK   (1)
#define AR_TYPE_READABLE_MASK   (2)
#define AR_TYPE_WRITEABLE_MASK   (4)
#define AR_TYPE_CODE_MASK   (8)
#define AR_TYPE_MASK   (0xf)
#define AR_TYPE_BUSY_64_TSS   (11)
#define AR_TYPE_BUSY_32_TSS   (11)
#define AR_TYPE_BUSY_16_TSS   (3)
#define AR_TYPE_LDT   (2)
#define AR_UNUSABLE_MASK   (0x10000)
#define AR_S_MASK   (0x10)
#define AR_P_MASK   (0x80)
#define AR_L_MASK   (0x2000)
#define AR_DB_MASK   (0x4000)
#define AR_G_MASK   (0x8000)
#define AR_DPL_SHIFT   (5)
#define AR_DPL(ar)   (((ar) >> AR_DPL_SHIFT) & 3)
#define AR_RESERVD_MASK   0xfffe0f00
#define TSS_PRIVATE_MEMSLOT   (KVM_USER_MEM_SLOTS)
#define APIC_ACCESS_PAGE_PRIVATE_MEMSLOT   (KVM_USER_MEM_SLOTS + 1)
#define IDENTITY_PAGETABLE_PRIVATE_MEMSLOT   (KVM_USER_MEM_SLOTS + 2)
#define VMX_NR_VPIDS   (0x10000)
#define VMX_VPID_EXTENT_SINGLE_CONTEXT   (1)
#define VMX_VPID_EXTENT_ALL_CONTEXT   (2)
#define VMX_EPT_EXTENT_INDIVIDUAL_ADDR   (0)
#define VMX_EPT_EXTENT_CONTEXT   (1)
#define VMX_EPT_EXTENT_GLOBAL   (2)
#define VMX_EPT_EXTENT_SHIFT   (24)
#define VMX_EPT_EXECUTE_ONLY_BIT   (1ULL)
#define VMX_EPT_PAGE_WALK_4_BIT   (0x40ULL)
#define VMX_EPTP_UC_BIT   (0x100ULL)
#define VMX_EPTP_WB_BIT   (0x4000ULL)
#define VMX_EPT_2MB_PAGE_BIT   (0x10000ULL)
#define VMX_EPT_1GB_PAGE_BIT   (0x20000ULL)
#define VMX_EPT_INVEPT_BIT   (0x100000ULL)
#define VMX_EPT_AD_BIT   (0x200000)
#define VMX_EPT_EXTENT_CONTEXT_BIT   (0x2000000ULL)
#define VMX_EPT_EXTENT_GLOBAL_BIT   (0x4000000)
#define VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT   (0x200ULL)
#define VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT   (0x400ULL)
#define VMX_EPT_DEFAULT_GAW   (3)
#define VMX_EPT_MAX_GAW   (4)
#define VMX_EPT_MT_EPTE_SHIFT   (3)
#define VMX_EPT_GAW_EPTP_SHIFT   (3)
#define VMX_EPT_AD_ENABLE_BIT   (0x40ULL)
#define VMX_EPT_DEFAULT_MT   (6ULL)
#define VMX_EPT_READABLE_MASK   (1ULL)
#define VMX_EPT_WRITABLE_MASK   (2ULL)
#define VMX_EPT_EXECUTABLE_MASK   (4ULL)
#define VMX_EPT_IPAT_BIT   (0x40ULL)
#define VMX_EPT_ACCESS_BIT   (0x100ULL)
#define VMX_EPT_DIRTY_BIT   (0x200ULL)
#define VMX_EPT_IDENTITY_PAGETABLE_ADDR   (0xfffbc000UL)
#define ASM_VMX_VMCLEAR_RAX   ".byte 0x66, 0x0f, 0xc7, 0x30"
#define ASM_VMX_VMLAUNCH   ".byte 0x0f, 0x01, 0xc2"
#define ASM_VMX_VMRESUME   ".byte 0x0f, 0x01, 0xc3"
#define ASM_VMX_VMPTRLD_RAX   ".byte 0x0f, 0xc7, 0x30"
#define ASM_VMX_VMREAD_RDX_RAX   ".byte 0x0f, 0x78, 0xd0"
#define ASM_VMX_VMWRITE_RAX_RDX   ".byte 0x0f, 0x79, 0xd0"
#define ASM_VMX_VMWRITE_RSP_RDX   ".byte 0x0f, 0x79, 0xd4"
#define ASM_VMX_VMXOFF   ".byte 0x0f, 0x01, 0xc4"
#define ASM_VMX_VMXON_RAX   ".byte 0xf3, 0x0f, 0xc7, 0x30"
#define ASM_VMX_INVEPT   ".byte 0x66, 0x0f, 0x38, 0x80, 0x08"
#define ASM_VMX_INVVPID   ".byte 0x66, 0x0f, 0x38, 0x81, 0x08"


typedef struct align16 vmx_msr_entry {
	uint32_t index, reserved;
	uint64_t value;
} vmx_msr_entry_t;


// Exit Qualifications for entry failure during or after loading guest state
#define ENTRY_FAIL_DEFAULT   (0)
#define ENTRY_FAIL_PDPTE   (2)
#define ENTRY_FAIL_NMI   (3)
#define ENTRY_FAIL_VMCS_LINK_PTR   (4)


/** VM-instruction error numbers */
enum vm_instruction_error_number {
	VMXERR_VMCALL_IN_VMX_ROOT_OPERATION = 1,
	VMXERR_VMCLEAR_INVALID_ADDRESS = 2,
	VMXERR_VMCLEAR_VMXON_POINTER = 3,
	VMXERR_VMLAUNCH_NONCLEAR_VMCS = 4,
	VMXERR_VMRESUME_NONLAUNCHED_VMCS = 5,
	VMXERR_VMRESUME_AFTER_VMXOFF = 6,
	VMXERR_ENTRY_INVALID_CONTROL_FIELD = 7,
	VMXERR_ENTRY_INVALID_HOST_STATE_FIELD = 8,
	VMXERR_VMPTRLD_INVALID_ADDRESS = 9,
	VMXERR_VMPTRLD_VMXON_POINTER = 10,
	VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID = 11,
	VMXERR_UNSUPPORTED_VMCS_COMPONENT = 12,
	VMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT = 13,
	VMXERR_VMXON_IN_VMX_ROOT_OPERATION = 15,
	VMXERR_ENTRY_INVALID_EXECUTIVE_VMCS_POINTER = 16,
	VMXERR_ENTRY_NONLAUNCHED_EXECUTIVE_VMCS = 17,
	VMXERR_ENTRY_EXECUTIVE_VMCS_POINTER_NOT_VMXON_POINTER = 18,
	VMXERR_VMCALL_NONCLEAR_VMCS = 19,
	VMXERR_VMCALL_INVALID_VM_EXIT_CONTROL_FIELDS = 20,
	VMXERR_VMCALL_INCORRECT_MSEG_REVISION_ID = 22,
	VMXERR_VMXOFF_UNDER_DUAL_MONITOR_TREATMENT_OF_SMIS_AND_SMM = 23,
	VMXERR_VMCALL_INVALID_SMM_MONITOR_FEATURES = 24,
	VMXERR_ENTRY_INVALID_VM_EXECUTION_CONTROL_FIELDS_IN_EXECUTIVE_VMCS = 25,
	VMXERR_ENTRY_EVENTS_BLOCKED_BY_MOV_SS = 26,
	VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID = 28
};


#endif  // VMX_H


/* LOW-LEVEL IO (<io.h>) */


#if (!(defined(_IO_H) || defined(_IO_H_) || defined(_SYS_IO_H) || defined(_SYS_IO_H_)))
#define IO_H   (1)
#define _IO_H   (1)
#define _IO_H_   (1)
#define SYS_IO_H   (1)
#define _SYS_IO_H   (1)
#define _SYS_IO_H_   (1)


#define AGP_PAGE_SHIFT   12
#define PAGE_CACHE_SHIFT   PAGE_SHIFT
#define IOREMAP_MAX_ORDER   (7 + PAGE_SHIFT)
#define NMBPGSHIFT   (PAGE_SHIFT - MSIZESHIFT)
#define NCLPGSHIFT   (PAGE_SHIFT - MCLSHIFT)
#define NBCLPGSHIFT   (PAGE_SHIFT - MBIGCLSHIFT)
#define NSLABSPMB   ((1 << MBSHIFT) >> PAGE_SHIFT)
#define NSLABSP16KB   (M16KCLBYTES >> PAGE_SHIFT)


#define __phys_to_pfn(paddr)   ((paddr) >> PAGE_SHIFT)
#define phys_to_pfn(paddr)   ((paddr) >> PAGE_SHIFT)
#define __pfn_to_phys(pfn)   ((pfn) << PAGE_SHIFT)
#define pfn_to_phys(pfn)   ((pfn) << PAGE_SHIFT)
#define pages_to_mb(x)   ((x) >> (20 - PAGE_SHIFT))


typedef struct attr_packed pgp_memory_t {
	uint8_t* buf;
	size_t length, allocated;
	unsigned int mmapped;
} pgp_memory_t;


#if (defined(X86) || defined(X86_64) || defined(I386))


LIB_FUNC unsigned char inb(unsigned short port) {
	unsigned char _v;
	asm volatile ("inb %w1, %0;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC unsigned char inb_p(unsigned short port) {
	unsigned char _v;
	asm volatile ("inb %w1, %0;" "outb %%al, $0x80;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC unsigned short inw(unsigned short port) {
	unsigned short _v;
	asm volatile ("inw %w1, %0;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC unsigned short inw_p(unsigned short port) {
	unsigned short _v;
	asm volatile ("inw %w1, %0;" "outb %%al, $0x80;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC unsigned int inl(unsigned short port) {
	unsigned int _v;
	asm volatile ("inl %w1, %0;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC unsigned int inl_p(unsigned short port) {
	unsigned int _v;
	asm volatile ("inl %w1, %0;" "outb %%al, $0x80;" : "=a"(_v) : "Nd"(port));
	return _v;
}


LIB_FUNC void outb(unsigned char value, unsigned short port) {
	asm volatile ("outb %b0, %w1;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void outb_p(unsigned char value, unsigned short port) {
	asm volatile ("outb %b0, %w1;" "outb %%al, $0x80;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void outw(unsigned short value, unsigned short port) {
	asm volatile ("outw %w0, %w1;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void outw_p(unsigned short value, unsigned short port) {
	asm volatile ("outw %w0, %w1;" "outb %%al, $0x80;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void outl(unsigned int value, unsigned short port) {
	asm volatile ("outl %0, %w1;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void outl_p(unsigned int value, unsigned short port) {
	asm volatile ("outl %0, %w1;" "outb %%al, $0x80;" : : "a"(value), "Nd"(port));
}


LIB_FUNC void insb(unsigned short port, void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "insb;" : "=D"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


LIB_FUNC void insw(unsigned short port, void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "insw;" : "=D"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


LIB_FUNC void insl(unsigned short port, void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "insl;" : "=D"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


LIB_FUNC void outsb(unsigned short port, const void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "outsb;" : "=S"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


LIB_FUNC void outsw(unsigned short port, const void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "outsw;" : "=S"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


LIB_FUNC void outsl(unsigned short port, const void* addr, unsigned long count) {
	asm volatile ("cld;" "rep;" "outsl;" : "=S"(addr), "=c"(count) : "d"(port), "0"(addr), "1"(count));
}


#endif  // ARCH


#define readb(x)   (*(volatile unsigned char*)(x))
#define readw(x)   (*(volatile unsigned short*)(x))
#define read32(x)   (*(volatile uint32_t*)(x))
#define read64(x)   (*(volatile uint64_t*)(x))
#define cy_readb(port)   readb(port)
#define writeb(b, p)   (*(volatile unsigned char*)(p) = (b))
#define bus_writeb(b, v, a)   writeb((v), (a))
#define writew(w, p)   (*(volatile unsigned short*)(p) = (w))
#define write32(w, p)   (*(volatile uint32_t*)(p) = (w))
#define write64(w, p)   (*(volatile uint64_t*)(p) = (w))


LIB_FUNC uint8_t sw_readb(volatile void* addr) {
	return *(volatile uint8_t*)addr;
}


LIB_FUNC void sw_writeb(uint8_t data, volatile void* addr) {
	*(volatile uint8_t*)addr = data;
}


LIB_FUNC uint16_t sw_readw(volatile void* addr) {
	return *(volatile uint16_t*)addr;
}


LIB_FUNC void sw_writew(uint16_t data, volatile void* addr) {
	*(volatile uint16_t*)addr = data;
}


LIB_FUNC uint32_t sw_readl(volatile void* addr) {
	return *(volatile uint32_t*)addr;
}


LIB_FUNC void sw_writel(uint32_t data, volatile void* addr) {
	*(volatile uint32_t*)addr = data;
}


#endif  // SYS_IO_H


/* PHYSICAL MEMORY LAYOUT (<memory.h>) */


#if (!(defined(_MEMORY_H) || defined(_MEMORY_H_) || defined(_S_I_MEMORY_H)))
#define _MEMORY_H   (1)
#define _MEMORY_H_   (1)
#define _S_I_MEMORY_H   (1)


#define TOTAL_PAGES   (MAX_ADDRESS / PAGE_SIZE)
#define MIOCRAMSIZE   _IOW('m', 3, uint32_t)


#if (defined(ARM) && (!(defined(__ASM_ARCH_MEMORY_H) || defined(_ARM_MEMORY_H))))
#define _ARM_MEMORY_H  (1)
#define __ASM_ARCH_MEMORY_H  (1)


#define PHYS_MEM_BEGIN   (0x80000000)
#define PHYS_MEM_END   (0xbfffffff)


#endif  // ARM_MEMORY_H


#if (defined(OSDOS) && (!(defined(_DOS_MEMORY_H) || defined(_DOS_MEMORY_H_))))
#define _DOS_MEMORY_H   (1)
#define _DOS_MEMORY_H_   (1)


#define DOS_ALLOC_HIGH   (0x40)
#define DOS_ALLOC_HIGH_LOW   (0x80)

enum DOS_ALLOC_STRATEGY {
	DOS_ALLOC_FIRST_FIT, DOS_ALLOC_BEST_FIT, DOS_ALLOC_LAST_FIT
};


#endif  // DOS_MEMORY_H


#if (defined(OSLINUX) && (!(defined(_LINUX_MEMORY_H) || defined(_LINUX_MEMORY_H_))))
#define _LINUX_MEMORY_H   (1)
#define _LINUX_MEMORY_H_   (1)


typedef struct erase_info_t { unsigned long Offset, Size; }   erase_info_t;

#define MEMGETINFO   _IOR('M', 1, region_info_t)
#define MEMERASE   _IOW('M', 2, erase_info_t)


#endif  // LINUX_MEMORY_H


#endif  // MEMORY_H


/* LOW-LEVEL I/O HARDWARE DRIVERS; TR18015 & TR18037 (<iohw.h>, <iodriv_hw.h>, & <hardware.h>) */


#if (!(defined(IOHW_H) || defined(IOHW_H_) || defined(IODRIV_HW_H) || defined(IODRIV_HW_H_)))  // http://www.qnx.com/developers/docs/6.5.0_sp1/topic/com.qnx.doc.dinkum_en_cpp/iohw.html & http://developer.blackberry.com/playbook/native/reference/com.qnx.doc.dinkum/topic/c99/iohw.html & http://www.qnx.com/developers/docs/6.5.0_sp1/topic/com.qnx.doc.dinkum_en_cpp/hardware.html
#define IOHW_H   (1)
#define IOHW_H_   (1)
#define IODRIV_HW_H   (1)
#define IODRIV_HW_H_   (1)
#define __ASM_GENERIC_IRQ_H   (1)
#define _ASM_GENERIC_IRQ_H   (1)
#define _ASM_GENERIC_IRQ_H_   (1)


#if (defined(I386) || defined(X86) || defined(X86_64))
// PCI BIOS function numbering for conventional PCI BIOS systems
#   define PCIBIOS_PCI_FUNCTION_ID   0xb1XX
#   define PCIBIOS_PCI_BIOS_PRESENT   0xb101
#   define PCIBIOS_FIND_PCI_DEVICE   0xb102
#   define PCIBIOS_FIND_PCI_CLASS_CODE   0xb103
#   define PCIBIOS_GENERATE_SPECIAL_CYCLE   0xb106
#   define PCIBIOS_READ_CONFIG_BYTE   0xb108
#   define PCIBIOS_READ_CONFIG_WORD   0xb109
#   define PCIBIOS_READ_CONFIG_DWORD   0xb10a
#   define PCIBIOS_WRITE_CONFIG_BYTE   0xb10b
#   define PCIBIOS_WRITE_CONFIG_WORD   0xb10c
#   define PCIBIOS_WRITE_CONFIG_DWORD   0xb10d
#   define PCIBIOS_GET_ROUTING_OPTIONS   0xb10e
#   define PCIBIOS_SET_PCI_HW_INT   0xb10f
#endif


/** Expand arguments and paste */
#define _IOHW_CAT(x, y)   x##_##y


#ifndef NR_IRQS
/** Upper bound of how many interrupts can be handled in the platform */
#   define NR_IRQS   64
#endif


LIB_FUNC int irq_canonicalize(const int irq) {
	return irq;
}


/* TODO: Add iohw.h Functions
typedef itype   ioindex_t;
typedef itype   ioreg;
#define iordbuf(dev, idx)   _IOHW_CAT((dev), (brd))(idx)
unsigned int iord(ioreg dev);
unsigned long iordl(ioreg dev);
unsigned int iordbuf(ioreg dev, ioindex_t idx);
unsigned long iordbufl(ioreg dev, ioindex_t idx);
void iowr(ioreg dev, unsigned int val);
void iowrl(ioreg dev, unsigned int val);
void iowrbuf(ioreg dev, ioindex_t idx, unsigned int val);
void iowrbufl(ioreg dev, ioindex_t idx, unsigned int val);
void ioor(ioreg dev, unsigned int val);
void ioorl(ioreg dev, unsigned int val);
void ioorbuf(ioreg dev, ioindex_t idx, unsigned int val);
void ioorbufl(ioreg dev, ioindex_t idx, unsigned int val);
void ioand(ioreg dev, unsigned int val);
void ioandl(ioreg dev, unsigned int val);
void ioandbuf(ioreg dev, ioindex_t idx, unsigned int val);
void ioandbufl(ioreg dev, ioindex_t idx, unsigned int val);
void ioxor(ioreg dev, unsigned int val);
void ioxorl(ioreg dev, unsigned int val);
void ioxorbuf(ioreg dev, ioindex_t idx, unsigned int val);
void ioxorbufl(ioreg dev, ioindex_t idx, unsigned int val);
void iogroup_acquire(int group);
void iogroup_release(int group);
void iogroup_map(int group, int direct);
*/


#endif  // IOHW_H


/* FRAMEBUFFER (<fb.h>) */


#if (!(defined(_LINUX_FB_H) || defined(_LINUX_FB_H_)))
#define _LINUX_FB_H   (1)


#define FB_MAX   32
#define FBIOGET_VSCREENINFO   0x4600
#define FBIOPUT_VSCREENINFO   0x4601
#define FBIOGET_FSCREENINFO   0x4602
#define FBIOGETCMAP   0x4604
#define FBIOPUTCMAP   0x4605
#define FBIOPAN_DISPLAY   0x4606
#define FBIOGET_MONITORSPEC   0x460C
#define FBIOPUT_MONITORSPEC   0x460D
#define FBIOSWITCH_MONIBIT   0x460E
#define FBIOGET_CON2FBMAP   0x460F
#define FBIOPUT_CON2FBMAP   0x4610
#define FBIOBLANK   0x4611
#define FBIO_ALLOC   0x4613
#define FBIO_FREE   0x4614
#define FBIOGET_GLYPH   0x4615
#define FBIOGET_HWCINFO   0x4616
#define FBIOPUT_MODEINFO   0x4617
#define FBIOGET_DISPINFO   0x4618
#define FBIO_WAITFORVSYNC   _IOW('F', 0x20, uint32_t)
/** Packed Pixels */
#define FB_TYPE_PACKED_PIXELS   0
/** Non interleaved planes */
#define FB_TYPE_PLANES   1
/** Interleaved planes */
#define FB_TYPE_INTERLEAVED_PLANES   2
/** Text/attributes */
#define FB_TYPE_TEXT   3
/** EGA/VGA planes */
#define FB_TYPE_VGA_PLANES   4
/** Type identified by a V4L2 FOURCC */
#define FB_TYPE_FOURCC   5
/** Monochrome text */
#define FB_AUX_TEXT_MDA   0
/** CGA/EGA/VGA Color text */
#define FB_AUX_TEXT_CGA   1
/** S3 MMIO fasttext */
#define FB_AUX_TEXT_S3_MMIO   2
/** MGA Millenium I: text, attr, 14 reserved bytes */
#define FB_AUX_TEXT_MGA_STEP16   3
/** Other MGAs: text, attr, 6 reserved bytes */
#define FB_AUX_TEXT_MGA_STEP8   4
/** 8-15: SVGA tileblit compatible modes */
#define FB_AUX_TEXT_SVGA_GROUP   8
/** lower three bits says step */
#define FB_AUX_TEXT_SVGA_MASK   7
/** SVGA text mode: text, attr */
#define FB_AUX_TEXT_SVGA_STEP2   8
/** SVGA text mode: text, attr, 2 reserved bytes */
#define FB_AUX_TEXT_SVGA_STEP4   9
/** SVGA text mode: text, attr, 6 reserved bytes */
#define FB_AUX_TEXT_SVGA_STEP8   10
/** SVGA text mode: text, attr, 14 reserved bytes */
#define FB_AUX_TEXT_SVGA_STEP16   11
/** reserved up to 15 */
#define FB_AUX_TEXT_SVGA_LAST   15
/** 16 color planes (EGA/VGA) */
#define FB_AUX_VGA_PLANES_VGA4   0
/** CFB4 in planes (VGA) */
#define FB_AUX_VGA_PLANES_CFB4   1
/** CFB8 in planes (VGA) */
#define FB_AUX_VGA_PLANES_CFB8   2
/** Monochrome 1 = Black 0 = White */
#define FB_VISUAL_MONO01   0
/** Monochrome 1 = White 0 = Black */
#define FB_VISUAL_MONO10   1
/** True color */
#define FB_VISUAL_TRUECOLOR   2
/** Pseudo color (like atari) */
#define FB_VISUAL_PSEUDOCOLOR   3
/** Direct color */
#define FB_VISUAL_DIRECTCOLOR   4
/** Pseudo color readonly */
#define FB_VISUAL_STATIC_PSEUDOCOLOR   5
/** Visual identified by a V4L2 FOURCC */
#define FB_VISUAL_FOURCC   6
/** no hardware accelerator */
#define FB_ACCEL_NONE   0
/** Atari Blitter */
#define FB_ACCEL_ATARIBLITT   1
/** Amiga Blitter */
#define FB_ACCEL_AMIGABLITT   2
/** Cybervision64 (S3 Trio64) */
#define FB_ACCEL_S3_TRIO64   3
/** RetinaZ3 (NCR 77C32BLT) */
#define FB_ACCEL_NCR_77C32BLT   4
/** Cybervision64/3D (S3 ViRGE) */
#define FB_ACCEL_S3_VIRGE   5
/** ATI Mach 64GX family */
#define FB_ACCEL_ATI_MACH64GX   6
/** DEC 21030 TGA */
#define FB_ACCEL_DEC_TGA   7
/** ATI Mach 64CT family */
#define FB_ACCEL_ATI_MACH64CT   8
/** ATI Mach 64CT family VT class */
#define FB_ACCEL_ATI_MACH64VT   9
/** ATI Mach 64CT family GT class */
#define FB_ACCEL_ATI_MACH64GT   10
/** Sun Creator/Creator3D */
#define FB_ACCEL_SUN_CREATOR   11
/** Sun cg6 */
#define FB_ACCEL_SUN_CGSIX   12
/** Sun leo/zx */
#define FB_ACCEL_SUN_LEO   13
/** IMS Twin Turbo */
#define FB_ACCEL_IMS_TWINTURBO   14
/** 3Dlabs Permedia 2 */
#define FB_ACCEL_3DLABS_PERMEDIA2   15
/** Matrox MGA2064W (Millenium) */
#define FB_ACCEL_MATROX_MGA2064W   16
/** Matrox MGA1064SG (Mystique) */
#define FB_ACCEL_MATROX_MGA1064SG   17
/** Matrox MGA2164W (Millenium II) */
#define FB_ACCEL_MATROX_MGA2164W   18
/** Matrox MGA2164W (Millenium II) */
#define FB_ACCEL_MATROX_MGA2164W_AGP   19
/** Matrox G100 (Productiva G100) */
#define FB_ACCEL_MATROX_MGAG100   20
/** Matrox G200 (Myst, Mill, ...) */
#define FB_ACCEL_MATROX_MGAG200   21
/** Sun cgfourteen */
#define FB_ACCEL_SUN_CG14   22
/** Sun bwtwo */
#define FB_ACCEL_SUN_BWTWO   23
/** Sun cgthree */
#define FB_ACCEL_SUN_CGTHREE   24
/** Sun tcx */
#define FB_ACCEL_SUN_TCX   25
/** Matrox G400 */
#define FB_ACCEL_MATROX_MGAG400   26
/** nVidia RIVA 128 */
#define FB_ACCEL_NV3   27
/** nVidia RIVA TNT */
#define FB_ACCEL_NV4   28
/** nVidia RIVA TNT2 */
#define FB_ACCEL_NV5   29
/** C&T 6555x */
#define FB_ACCEL_CT_6555x   30
/** 3Dfx Banshee */
#define FB_ACCEL_3DFX_BANSHEE   31
/** ATI Rage128 family */
#define FB_ACCEL_ATI_RAGE128   32
/** CyberPro 2000 */
#define FB_ACCEL_IGS_CYBER2000   33
/** CyberPro 2010 */
#define FB_ACCEL_IGS_CYBER2010   34
/** CyberPro 5000 */
#define FB_ACCEL_IGS_CYBER5000   35
/** SiS 300/630/540 */
#define FB_ACCEL_SIS_GLAMOUR   36
/** 3Dlabs Permedia 3 */
#define FB_ACCEL_3DLABS_PERMEDIA3   37
/** ATI Radeon family */
#define FB_ACCEL_ATI_RADEON   38
/** Intel 810/815 */
#define FB_ACCEL_I810   39
/** SiS 315, 650, 740 */
#define FB_ACCEL_SIS_GLAMOUR_2   40
/** SiS 330 ("Xabre") */
#define FB_ACCEL_SIS_XABRE   41
/** Intel 830M/845G/85x/865G */
#define FB_ACCEL_I830   42
/** nVidia Arch 10 */
#define FB_ACCEL_NV_10   43
/** nVidia Arch 20 */
#define FB_ACCEL_NV_20   44
/** nVidia Arch 30 */
#define FB_ACCEL_NV_30   45
/** nVidia Arch 40 */
#define FB_ACCEL_NV_40   46
/** XGI Volari V3XT, V5, V8 */
#define FB_ACCEL_XGI_VOLARI_V   47
/** XGI Volari Z7 */
#define FB_ACCEL_XGI_VOLARI_Z   48
/** TI OMAP16xx */
#define FB_ACCEL_OMAP1610   49
/** Trident TGUI */
#define FB_ACCEL_TRIDENT_TGUI   50
/** Trident 3DImage */
#define FB_ACCEL_TRIDENT_3DIMAGE   51
/** Trident Blade3D */
#define FB_ACCEL_TRIDENT_BLADE3D   52
/** Trident BladeXP */
#define FB_ACCEL_TRIDENT_BLADEXP   53
/** Cirrus Logic 543x/544x/5480 */
#define FB_ACCEL_CIRRUS_ALPINE   53
/** NeoMagic NM2070 */
#define FB_ACCEL_NEOMAGIC_NM2070   90
/** NeoMagic NM2090 */
#define FB_ACCEL_NEOMAGIC_NM2090   91
/** NeoMagic NM2093 */
#define FB_ACCEL_NEOMAGIC_NM2093   92
/** NeoMagic NM2097 */
#define FB_ACCEL_NEOMAGIC_NM2097   93
/** NeoMagic NM2160 */
#define FB_ACCEL_NEOMAGIC_NM2160   94
/** NeoMagic NM2200 */
#define FB_ACCEL_NEOMAGIC_NM2200   95
/** NeoMagic NM2230 */
#define FB_ACCEL_NEOMAGIC_NM2230   96
/** NeoMagic NM2360 */
#define FB_ACCEL_NEOMAGIC_NM2360   97
/** NeoMagic NM2380 */
#define FB_ACCEL_NEOMAGIC_NM2380   98
/** PXA3xx */
#define FB_ACCEL_PXA3XX   99
/** S3 Savage4 */
#define FB_ACCEL_SAVAGE4   0x80
/** S3 Savage3D */
#define FB_ACCEL_SAVAGE3D   0x81
/** S3 Savage3D-MV */
#define FB_ACCEL_SAVAGE3D_MV   0x82
/** S3 Savage2000 */
#define FB_ACCEL_SAVAGE2000   0x83
/** S3 Savage/MX-MV */
#define FB_ACCEL_SAVAGE_MX_MV   0x84
/** S3 Savage/MX */
#define FB_ACCEL_SAVAGE_MX   0x85
/** S3 Savage/IX-MV */
#define FB_ACCEL_SAVAGE_IX_MV   0x86
/** S3 Savage/IX */
#define FB_ACCEL_SAVAGE_IX   0x87
/** S3 ProSavage PM133 */
#define FB_ACCEL_PROSAVAGE_PM   0x88
/** S3 ProSavage KM133 */
#define FB_ACCEL_PROSAVAGE_KM   0x89
/** S3 Twister */
#define FB_ACCEL_S3TWISTER_P   0x8a
/** S3 TwisterK */
#define FB_ACCEL_S3TWISTER_K   0x8b
/** S3 Supersavage */
#define FB_ACCEL_SUPERSAVAGE   0x8c
/** S3 ProSavage DDR */
#define FB_ACCEL_PROSAVAGE_DDR   0x8d
/** S3 ProSavage DDR-K */
#define FB_ACCEL_PROSAVAGE_DDRK   0x8e
/** PKUnity-v3 Unigfx */
#define FB_ACCEL_PUV3_UNIGFX   0xa0
/** Device supports FOURCC-based formats */
#define FB_CAP_FOURCC   1


/** Hold-And-Modify (HAM) */
#define FB_NONSTD_HAM   (1)
/** Order of pixels in each byte is reversed */
#define FB_NONSTD_REV_PIX_IN_B   (2)
/** Set values immediately (or vbl)*/
#define FB_ACTIVATE_NOW   (0)
/** Activate on next open */
#define FB_ACTIVATE_NXTOPEN   (1)
/** Do not set, round up impossible */
#define FB_ACTIVATE_TEST   (2)
#define FB_ACTIVATE_MASK   (15)
/** Activate values on next vbl */
#define FB_ACTIVATE_VBL   (16)
/** Change colormap on vbl */
#define FB_CHANGE_CMAP_VBL   (32)
/** Change all VCs on this fb */
#define FB_ACTIVATE_ALL   (64)
/** Force apply even when no change*/
#define FB_ACTIVATE_FORCE   (128)
/** Invalidate videomode */
#define FB_ACTIVATE_INV_MODE  (256)
#define FB_ACCELF_TEXT   (1)
/** Horizontal sync high active */
#define FB_SYNC_HOR_HIGH_ACT   (1)
/** Vertical sync high active */
#define FB_SYNC_VERT_HIGH_ACT   (2)
/** External sync */
#define FB_SYNC_EXT   (4)
/** Composite sync high active */
#define FB_SYNC_COMP_HIGH_ACT   (8)
/** Broadcast video timings */
#define FB_SYNC_BROADCAST   (16)
/** Sync on green */
#define FB_SYNC_ON_GREEN   (32)
/** Non-interlaced */
#define FB_VMODE_NONINTERLACED   (0)
/** Interlaced */
#define FB_VMODE_INTERLACED   (1)
/** Double scan */
#define FB_VMODE_DOUBLE   (2)
/** Interlaced: top line first */
#define FB_VMODE_ODD_FLD_FIRST   (4)
#define FB_VMODE_MASK   (255)
/** ywrap instead of panning */
#define FB_VMODE_YWRAP   (256)
/** Smooth xpan possible (internally used) */
#define FB_VMODE_SMOOTH_XPAN   (512)
/** Do not update x/yoffset */
#define FB_VMODE_CONUPDATE   (512)
// Display rotation support
#define FB_ROTATE_UR   0
#define FB_ROTATE_CW   1
#define FB_ROTATE_UD   2
#define FB_ROTATE_CCW   3
#define PICOS2KHZ(a)   (1000000000UL / (a))
#define KHZ2PICOS(a)   (1000000000UL / (a))
// VESA Blanking Levels
#define VESA_NO_BLANKING   0
/** screen: unblanked, hsync: on, vsync: on */
#define FB_BLANK_UNBLANK   0
/** screen: blanked, hsync: on, vsync: on */
#define FB_BLANK_NORMAL   1
#define VESA_VSYNC_SUSPEND   1
/** screen: blanked, hsync: on, vsync: off */
#define FB_BLANK_VSYNC_SUSPEND   2
#define VESA_HSYNC_SUSPEND   2
/** screen: blanked, hsync: off, vsync: on */
#define FB_BLANK_HSYNC_SUSPEND   3
#define VESA_POWERDOWN   3
/** screen: blanked, hsync: off, vsync: off */
#define FB_BLANK_POWERDOWN   4
/** Currently in a vertical blank */
#define FB_VBLANK_VBLANKING   1
/** Currently in a horizontal blank */
#define FB_VBLANK_HBLANKING   2
/** Vertical blanks can be detected */
#define FB_VBLANK_HAVE_VBLANK   4
/** Horizontal blanks can be detected */
#define FB_VBLANK_HAVE_HBLANK   8
/** Global retrace counter is available */
#define FB_VBLANK_HAVE_COUNT   0x10
/** The vcount field is valid */
#define FB_VBLANK_HAVE_VCOUNT   0x20
/** The hcount field is valid */
#define FB_VBLANK_HAVE_HCOUNT   0x40
/** Currently in a vsync */
#define FB_VBLANK_VSYNCING   0x80
/** Verical syncs can be detected */
#define FB_VBLANK_HAVE_VSYNC   0x100
// Internal HW accel
#define ROP_COPY   0
#define ROP_XOR   1
// Hardware cursor control
#define FB_CUR_SETIMAGE   1
#define FB_CUR_SETPOS   2
#define FB_CUR_SETHOT   4
#define FB_CUR_SETCMAP   8
#define FB_CUR_SETSHAPE   0x10
#define FB_CUR_SETSIZE   0x20
#define FB_CUR_SETALL   0xFF
// Settings for the generic backlight code
#define FB_BACKLIGHT_LEVELS   128
#define FB_BACKLIGHT_MAX   0xFF


typedef struct attr_packed fb_fix_screeninfo {
	char id[16];
	unsigned long smem_start;
	uint32_t smem_len, type;
	uint32_t type_aux;  // Interleave for interleaved Planes
	uint32_t visual;
	uint16_t xpanstep, ypanstep;  // Zero if no hardware panning
	uint16_t ywrapstep;  // Zero if no hardware ywrap
	uint32_t line_length;  // Length of a line in bytes
	unsigned long mmio_start;  // Start of Memory Mapped I/O
	uint32_t mmio_len;  // Length of Memory Mapped I/O
	uint32_t accel;  // Indicate to driver the specific chip/card
	uint16_t capabilities;
	uint16_t reserved[2];
} fb_fix_screeninfo_t;


typedef struct fb_bitfield { uint32_t offset, length, msb_right; }   fb_bitfield_t;


struct fb_var_screeninfo {
	uint32_t xres, yres, xres_virtual, yres_virtual;
	uint32_t xoffset, yoffset;
	uint32_t bits_per_pixel;
	uint32_t grayscale;  // 0 = color, 1 = grayscale, >1 = FOURCC
	struct fb_bitfield red, green, blue, transp;
	uint32_t nonstd, activate;
	uint32_t height, width;
	uint32_t accel_flags, pixclock;
	uint32_t left_margin, right_margin, upper_margin, lower_margin;
	uint32_t hsync_len, vsync_len;
	uint32_t sync, vmode;
	uint32_t rotate;  // Rotation angle; counter-clockwise
	uint32_t colorspace;  // Colorspace for FOURCC-based modes
	uint32_t reserved[4];
};


typedef struct fb_cmap {
	uint32_t start, len;
	uint16_t *red, *green, *blue, *transp;
} fb_cmap_t;


typedef struct fb_con2fbmap { uint32_t console, framebuffer; }   fb_con2fbmap_t;


typedef struct fb_vblank {
	uint32_t flags, count, vcount, hcount, reserved[4];
} fb_vblank_t;


typedef struct fb_copyarea {
	uint32_t dx, dy, width, height, sx, sy;
} fb_copyarea_t;


typedef struct fb_fillrect {
	uint32_t dx, dy, width, height, color, rop;
} fb_fillrect_t;


typedef struct attr_packed fb_image {
	uint32_t dx, dy;  // Where to place image
	uint32_t width, height;
	uint32_t fg_color;  // Only used when a mono bitmap
	uint32_t bg_color;
	uint8_t depth;  // Depth of the image
	const char* data;  // Pointer to image data
	struct fb_cmap cmap;  // color map info
} fb_image_t;


typedef struct fbcurpos { uint16_t x, y; }   fbcurpos_t;


typedef struct attr_packed fb_cursor {
	uint16_t set;  // What to set
	uint16_t enable;  // Cursor on/off
	uint16_t rop;  // Bitop operation
	const char* mask;  // Cursor mask bits
	struct fbcurpos hot;  // Cursor hot spot
	struct fb_image image;  // Cursor image
} fb_cursor_t;


#define FBIO_CURSOR   _IOWR('F', 8, struct fb_cursor)
#define FBIOGET_VBLANK   _IOR('F', 0x12, struct fb_vblank)


#endif  // LINUX_FB_H


/* VGA CHIPSET INTERACTION (<video/vga.h>) */


#if (!(defined(_ASM_GENERIC_VGA_H) || defined(__ASM_GENERIC_VGA_H) || defined(_ASM_GENERIC_VGA_H_) || defined(__ASM_GENERIC_VGA_H_)))
#define _ASM_GENERIC_VGA_H   (1)
#define __ASM_GENERIC_VGA_H   (1)
#define _ASM_GENERIC_VGA_H_   (1)
#define __ASM_GENERIC_VGA_H_   (1)
#define __linux_video_vga_h__   (1)


// VGA data register ports
/** CRT Controller Data Register - color emulation */
#define VGA_CRT_DC   0x3D5
/** CRT Controller Data Register - mono emulation */
#define VGA_CRT_DM   0x3B5
/** Attribute Controller Data Read Register */
#define VGA_ATT_R   0x3C1
/** Attribute Controller Data Write Register */
#define VGA_ATT_W   0x3C0
/** Graphics Controller Data Register */
#define VGA_GFX_D   0x3CF
/** Sequencer Data Register */
#define VGA_SEQ_D   0x3C5
/** Misc Output Read Register */
#define VGA_MIS_R   0x3CC
/** Misc Output Write Register */
#define VGA_MIS_W   0x3C2
/** Feature Control Read Register */
#define VGA_FTC_R   0x3CA
/** Input Status Register 1 - color emulation */
#define VGA_IS1_RC   0x3DA
/** Input Status Register 1 - mono emulation */
#define VGA_IS1_RM   0x3BA
/** PEL Data Register */
#define VGA_PEL_D   0x3C9
/** PEL mask register */
#define VGA_PEL_MSK   0x3C6
// EGA-specific registers
/** Graphics enable processor 0 */
#define EGA_GFX_E0   0x3CC
/** Graphics enable processor 1 */
#define EGA_GFX_E1   0x3CA
// VGA index register ports
/** CRT Controller Index - color emulation */
#define VGA_CRT_IC   0x3D4
/** CRT Controller Index - mono emulation */
#define VGA_CRT_IM   0x3B4
/** Attribute Controller Index & Data Write Register */
#define VGA_ATT_IW   0x3C0
/** Graphics Controller Index */
#define VGA_GFX_I   0x3CE
/** Sequencer Index */
#define VGA_SEQ_I   0x3C4
/** PEL Write Index */
#define VGA_PEL_IW   0x3C8
/** PEL Read Index */
#define VGA_PEL_IR   0x3C7
// Standard VGA indexes max counts
/** Number of CRT Controller Registers */
#define VGA_CRT_C   0x19
/** Number of Attribute Controller Registers */
#define VGA_ATT_C   0x15
/** Number of Graphics Controller Registers */
#define VGA_GFX_C   9
/** Number of Sequencer Registers */
#define VGA_SEQ_C   5
/** Number of Misc Output Register */
#define VGA_MIS_C   1
// VGA misc register bit masks
#define VGA_MIS_COLOR   1
#define VGA_MIS_ENB_MEM_ACCESS   2
#define VGA_MIS_DCLK_28322_720   4
#define VGA_MIS_ENB_PLL_LOAD   0xc
#define VGA_MIS_SEL_HIGH_PAGE   0x20
// VGA CRT controller register indices
#define VGA_CRTC_H_TOTAL   0
#define VGA_CRTC_H_DISP   1
#define VGA_CRTC_H_BLANK_START   2
#define VGA_CRTC_H_BLANK_END   3
#define VGA_CRTC_H_SYNC_START   4
#define VGA_CRTC_H_SYNC_END   5
#define VGA_CRTC_V_TOTAL   6
#define VGA_CRTC_OVERFLOW   7
#define VGA_CRTC_PRESET_ROW   8
#define VGA_CRTC_MAX_SCAN   9
#define VGA_CRTC_CURSOR_START   0xA
#define VGA_CRTC_CURSOR_END   0xB
#define VGA_CRTC_START_HI   0xC
#define VGA_CRTC_START_LO   0xD
#define VGA_CRTC_CURSOR_HI   0xE
#define VGA_CRTC_CURSOR_LO   0xF
#define VGA_CRTC_V_SYNC_START   0x10
#define VGA_CRTC_V_SYNC_END   0x11
#define VGA_CRTC_V_DISP_END   0x12
#define VGA_CRTC_OFFSET   0x13
#define VGA_CRTC_UNDERLINE   0x14
#define VGA_CRTC_V_BLANK_START   0x15
#define VGA_CRTC_V_BLANK_END   0x16
#define VGA_CRTC_MODE   0x17
#define VGA_CRTC_LINE_COMPARE   0x18
#define VGA_CRTC_REGS   VGA_CRT_C
// VGA CRT controller bit masks
/** Lock writes to CR0 - CR7 */
#define VGA_CR11_LOCK_CR0_CR7   0x80
#define VGA_CR17_H_V_SIGNALS_ENABLED   0x80
// VGA attribute controller register indices
#define VGA_ATC_PALETTE0   0
#define VGA_ATC_PALETTE1   1
#define VGA_ATC_PALETTE2   2
#define VGA_ATC_PALETTE3   3
#define VGA_ATC_PALETTE4   4
#define VGA_ATC_PALETTE5   5
#define VGA_ATC_PALETTE6   6
#define VGA_ATC_PALETTE7   7
#define VGA_ATC_PALETTE8   8
#define VGA_ATC_PALETTE9   9
#define VGA_ATC_PALETTEA   0xA
#define VGA_ATC_PALETTEB   0xB
#define VGA_ATC_PALETTEC   0xC
#define VGA_ATC_PALETTED   0xD
#define VGA_ATC_PALETTEE   0xE
#define VGA_ATC_PALETTEF   0xF
#define VGA_ATC_MODE   0x10
#define VGA_ATC_OVERSCAN   0x11
#define VGA_ATC_PLANE_ENABLE   0x12
#define VGA_ATC_PEL   0x13
#define VGA_ATC_COLOR_PAGE   0x14
#define VGA_AR_ENABLE_DISPLAY   0x20
// VGA sequencer register indices
#define VGA_SEQ_RESET   0
#define VGA_SEQ_CLOCK_MODE   1
#define VGA_SEQ_PLANE_WRITE   2
#define VGA_SEQ_CHARACTER_MAP   3
#define VGA_SEQ_MEMORY_MODE   4
// VGA sequencer register bit masks
/** Bit 0: character clocks 8 dots wide are generated */
#define VGA_SR01_CHAR_CLK_8DOTS   1
/** Bit 5: Screen is off */
#define VGA_SR01_SCREEN_OFF   0x20
/** Bits 3-0: enable access to all planes */
#define VGA_SR02_ALL_PLANES   0xF
/** Bit 1: allows complete mem access to 256K */
#define VGA_SR04_EXT_MEM   2
/** Bit 2: directs system to use a sequential addressing mode */
#define VGA_SR04_SEQ_MODE   4
/** Bit 3: selects modulo 4 addressing for CPU access to display memory */
#define VGA_SR04_CHN_4M   8
// VGA graphics controller register indices
#define VGA_GFX_SR_VALUE   0
#define VGA_GFX_SR_ENABLE   1
#define VGA_GFX_COMPARE_VALUE   2
#define VGA_GFX_DATA_ROTATE   3
#define VGA_GFX_PLANE_READ   4
#define VGA_GFX_MODE   5
#define VGA_GFX_MISC   6
#define VGA_GFX_COMPARE_MASK   7
#define VGA_GFX_BIT_MASK   8
/** VGA graphics controller bit mask */
#define VGA_GR06_GRAPHICS_MODE   1
/** Macro for composing an 8-bit VGA register index and value into a single 16-bit quantity */
#define VGA_OUT16VAL(v, r)   (((v) << 8) | (r))
#if LITTLE_ENDIAN
/** Decide whether we should enable the faster 16-bit VGA register writes */
#   define VGA_OUTW_WRITE   (1)
#endif
// VGA State Save and Restore
/** Save/restore plane 2 fonts */
#define VGA_SAVE_FONT0   1
/** Save/restore plane 3 fonts */
#define VGA_SAVE_FONT1   2
/** Save/restore plane 0/1 fonts */
#define VGA_SAVE_TEXT   4
/** Save/restore all fonts */
#define VGA_SAVE_FONTS   7
/** Save/restore video mode */
#define VGA_SAVE_MODE   8
/** Save/restore color map/DAC */
#define VGA_SAVE_CMAP   16


typedef struct attr_packed vgastate {
	void __iomem* vgabase;  // mmio base, if supported
	unsigned long membase;  // VGA window base, 0 for default - 0xA000
	uint32_t memsize;  // VGA window size, 0 for default 64K
	uint32_t flags;  // what state[s] to save (see VGA_SAVE_*)
	uint32_t depth;  // current fb depth, not important
	uint32_t num_attr;  // number of att registers, 0 for default
	uint32_t num_crtc;  // number of crt registers, 0 for default
	uint32_t num_gfx;  // number of gfx registers, 0 for default
	uint32_t num_seq;  // number of seq registers, 0 for default
	void* vidstate;
} vgastate_t;


#define vga_readb(x)   (*(x))
#define vga_writeb(x, y)   (*(y) = (x))


/** Generic VGA port read */
LIB_FUNC unsigned char vga_io_r(unsigned short port) {
	return (unsigned char)inb_p(port);
}


/** Generic VGA port write */
LIB_FUNC void vga_io_w(unsigned short port, unsigned char val) {
	outb_p(val, port);
}


LIB_FUNC void vga_io_w_fast(unsigned short port, unsigned char reg, unsigned char val) {
	outw((unsigned short)VGA_OUT16VAL(val, reg), port);
}


LIB_FUNC unsigned char vga_mm_r(void __iomem* regbase, const unsigned short port) {
	return readb((&regbase + port));
}


LIB_FUNC void vga_mm_w(void __iomem* regbase, unsigned short port, unsigned char val) {
	writeb(val, (&regbase + port));
}


LIB_FUNC void vga_mm_w_fast(void __iomem* regbase, unsigned short port, unsigned char reg, unsigned char val) {
	writew((unsigned short)VGA_OUT16VAL(val, reg), (volatile unsigned short*)(&regbase + port));
}


LIB_FUNC unsigned char vga_r(void __iomem* regbase, unsigned short port) {
	if (regbase) { return vga_mm_r(regbase, port); }
	return vga_io_r(port);
}


LIB_FUNC void vga_w(void __iomem* regbase, unsigned short port, unsigned char val) {
	if (regbase) { vga_mm_w(regbase, port, val); }
	else { vga_io_w(port, val); }
	UNREACHABLE
}


LIB_FUNC void vga_w_fast(void __iomem* regbase, unsigned short port, unsigned char reg, unsigned char val) {
	if (regbase) { vga_mm_w_fast(regbase, port, reg, val); }
	else { vga_io_w_fast(port, reg, val); }
	UNREACHABLE
}


/** VGA CRTC register read */
LIB_FUNC unsigned char vga_rcrt(void __iomem* regbase, unsigned char reg) {
	vga_w(regbase, VGA_CRT_IC, reg);
	return vga_r(regbase, VGA_CRT_DC);
}


/** VGA CRTC register write */
LIB_FUNC void vga_wcrt(void __iomem* regbase, unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_w_fast(regbase, VGA_CRT_IC, reg, val);
#   else
	vga_w(regbase, VGA_CRT_IC, reg);
	vga_w(regbase, VGA_CRT_DC, val);
#   endif
}


LIB_FUNC unsigned char vga_io_rcrt(unsigned char reg) {
	vga_io_w(VGA_CRT_IC, reg);
	return vga_io_r(VGA_CRT_DC);
}


LIB_FUNC void vga_io_wcrt(unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_io_w_fast(VGA_CRT_IC, reg, val);
#   else
	vga_io_w(VGA_CRT_IC, reg);
	vga_io_w(VGA_CRT_DC, val);
#   endif
}


LIB_FUNC unsigned char vga_mm_rcrt(void __iomem* regbase, unsigned char reg) {
	vga_mm_w(regbase, VGA_CRT_IC, reg);
	return vga_mm_r(regbase, VGA_CRT_DC);
}


LIB_FUNC void vga_mm_wcrt(void __iomem* regbase, unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_mm_w_fast(regbase, VGA_CRT_IC, reg, val);
#   else
	vga_mm_w(regbase, VGA_CRT_IC, reg);
	vga_mm_w(regbase, VGA_CRT_DC, val);
#   endif
}


/** VGA sequencer register read */
LIB_FUNC unsigned char vga_rseq(void __iomem* regbase, unsigned char reg) {
	vga_w(regbase, VGA_SEQ_I, reg);
	return vga_r(regbase, VGA_SEQ_D);
}


/** VGA sequencer register write */
LIB_FUNC void vga_wseq(void __iomem* regbase, unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_w_fast(regbase, VGA_SEQ_I, reg, val);
#   else
	vga_w(regbase, VGA_SEQ_I, reg);
	vga_w(regbase, VGA_SEQ_D, val);
#   endif
}


LIB_FUNC unsigned char vga_io_rseq(unsigned char reg) {
	vga_io_w(VGA_SEQ_I, reg);
	return vga_io_r(VGA_SEQ_D);
}


LIB_FUNC void vga_io_wseq(unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_io_w_fast(VGA_SEQ_I, reg, val);
#   else
	vga_io_w(VGA_SEQ_I, reg);
	vga_io_w(VGA_SEQ_D, val);
#   endif
}


LIB_FUNC unsigned char vga_mm_rseq(void __iomem* regbase, unsigned char reg) {
	vga_mm_w(regbase, VGA_SEQ_I, reg);
	return vga_mm_r(regbase, VGA_SEQ_D);
}


LIB_FUNC void vga_mm_wseq(void __iomem* regbase, unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_mm_w_fast(regbase, VGA_SEQ_I, reg, val);
#   else
	vga_mm_w(regbase, VGA_SEQ_I, reg);
	vga_mm_w(regbase, VGA_SEQ_D, val);
#   endif
}


/** VGA graphics controller register read */
LIB_FUNC unsigned char vga_rgfx(void __iomem* regbase, unsigned char reg) {
	vga_w(regbase, VGA_GFX_I, reg);
	return vga_r(regbase, VGA_GFX_D);
}


/** VGA graphics controller register write */
LIB_FUNC void vga_wgfx(void __iomem* regbase, unsigned char reg, unsigned char val) {
#   ifdef VGA_OUTW_WRITE
	vga_w_fast(regbase, VGA_GFX_I, reg, val);
#   else
	vga_w(regbase, VGA_GFX_I, reg);
	vga_w(regbase, VGA_GFX_D, val);
#   endif
}


LIB_FUNC unsigned char vga_io_rgfx(unsigned char reg) {
	vga_io_w(VGA_GFX_I, reg);
	return vga_io_r(VGA_GFX_D);
}


LIB_FUNC void vga_io_wgfx(unsigned char reg, unsigned char val) {
#ifdef VGA_OUTW_WRITE
	vga_io_w_fast(VGA_GFX_I, reg, val);
#else
	vga_io_w(VGA_GFX_I, reg);
	vga_io_w(VGA_GFX_D, val);
#endif
}


LIB_FUNC unsigned char vga_mm_rgfx(void __iomem* regbase, unsigned char reg) {
	vga_mm_w(regbase, VGA_GFX_I, reg);
	return vga_mm_r(regbase, VGA_GFX_D);
}


LIB_FUNC void vga_mm_wgfx(void __iomem* regbase, unsigned char reg, unsigned char val) {
#ifdef VGA_OUTW_WRITE
	vga_mm_w_fast(regbase, VGA_GFX_I, reg, val);
#else
	vga_mm_w(regbase, VGA_GFX_I, reg);
	vga_mm_w(regbase, VGA_GFX_D, val);
#endif
}


/** VGA attribute controller register read */
LIB_FUNC unsigned char vga_rattr(void __iomem* regbase, unsigned char reg) {
	vga_w(regbase, VGA_ATT_IW, reg);
	return vga_r(regbase, VGA_ATT_R);
}


/** VGA attribute controller register write */
LIB_FUNC void vga_wattr(void __iomem* regbase, unsigned char reg, unsigned char val) {
	vga_w(regbase, VGA_ATT_IW, reg);
	vga_w(regbase, VGA_ATT_W, val);
}


LIB_FUNC unsigned char vga_io_rattr(unsigned char reg) {
	vga_io_w(VGA_ATT_IW, reg);
	return vga_io_r(VGA_ATT_R);
}


LIB_FUNC void vga_io_wattr(unsigned char reg, unsigned char val) {
	vga_io_w(VGA_ATT_IW, reg);
	vga_io_w(VGA_ATT_W, val);
}


LIB_FUNC unsigned char vga_mm_rattr(void __iomem* regbase, unsigned char reg) {
	vga_mm_w(regbase, VGA_ATT_IW, reg);
	return vga_mm_r(regbase, VGA_ATT_R);
}


LIB_FUNC void vga_mm_wattr(void __iomem* regbase, unsigned char reg, unsigned char val) {
	vga_mm_w(regbase, VGA_ATT_IW, reg);
	vga_mm_w(regbase, VGA_ATT_W, val);
}


#endif  // ASM_GENERIC_VGA_H


/* VGA (<vgaarb.h>) */


#if (!(defined(LINUX_VGA_H) || defined(_LINUX_VGA_H)))
#define LINUX_VGA_H   (1)
#define _LINUX_VGA_H   (1)


// Legacy VGA regions
#define VGA_RSRC_NONE   0
#define VGA_RSRC_LEGACY_IO   1
#define VGA_RSRC_LEGACY_MEM   2
#define VGA_RSRC_LEGACY_MASK   (VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM)
// Non-legacy access
#define VGA_RSRC_NORMAL_IO   4
#define VGA_RSRC_NORMAL_MEM   8
#define VGA_DEFAULT_DEVICE   (NULL)


#endif  // LINUX_VGA_H


/* SUPPORT FOR LAPTOP WITH DUAL GPU (<vga_switcheroo.h>) */


#if (!(defined(LINUX_VGA_SWITCHEROO_H_) || defined(_LINUX_VGA_SWITCHEROO_H_)))
#define _LINUX_VGA_SWITCHEROO_H_   (1)
#define LINUX_VGA_SWITCHEROO_H_   (1)


enum vga_switcheroo_state {
	VGA_SWITCHEROO_OFF, VGA_SWITCHEROO_ON,
	VGA_SWITCHEROO_INIT, VGA_SWITCHEROO_NOT_FOUND
};


enum vga_switcheroo_client_id {
	VGA_SWITCHEROO_IGD, VGA_SWITCHEROO_DIS, VGA_SWITCHEROO_MAX_CLIENTS
};


#endif  // LINUX_VGA_SWITCHEROO_H


/* SVGA CHIPSET INTERACTION (<video/svga.h>) */


#if (!(defined(_LINUX_SVGA_H) || defined(_LINUX_SVGA_H_) || defined(_SVGA_H) || defined(_SVGA_H_)))
#define _SVGA_H   (1)
#define _SVGA_H_   (1)
#define _LINUX_SVGA_H   (1)
#define _LINUX_SVGA_H_   (1)


/** Terminator for register set */
#define VGA_REGSET_END_VAL   0xFF
#define VGA_REGSET_END   { VGA_REGSET_END_VAL, 0, 0 }
#define SVGA_FORMAT_END_VAL   0xFFFF
#define SVGA_FORMAT_END   { SVGA_FORMAT_END_VAL, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, 0, 0, 0, 0, 0, 0 }


typedef struct vga_regset { uint8_t regnum, lowbit, highbit; }   vga_regset_t;


typedef struct svga_fb_format {
	// Var part
	uint32_t bits_per_pixel;
	struct fb_bitfield red, green, blue, transp;
	uint32_t nonstd;
	// Fix part
	uint32_t type, type_aux, visual, xpanstep, xresstep;
} svga_fb_format_t;


typedef struct svga_timing_regs {
	const struct vga_regset* h_total_regs;
	const struct vga_regset* h_display_regs;
	const struct vga_regset* h_blank_start_regs;
	const struct vga_regset* h_blank_end_regs;
	const struct vga_regset* h_sync_start_regs;
	const struct vga_regset* h_sync_end_regs;
	const struct vga_regset* v_total_regs;
	const struct vga_regset* v_display_regs;
	const struct vga_regset* v_blank_start_regs;
	const struct vga_regset* v_blank_end_regs;
	const struct vga_regset* v_sync_start_regs;
	const struct vga_regset* v_sync_end_regs;
} svga_timing_regs_t;


typedef struct svga_pll {
	uint16_t m_min, m_max, n_min, n_max, r_min, r_max;  // r_max < 32
	uint32_t f_vco_min, f_vco_max, f_base;
} svga_pll_t;


/** Write a value to the attribute register */
LIB_FUNC void svga_wattr(void __iomem* regbase, uint8_t index, uint8_t data) {
	vga_r(regbase, VGA_IS1_RC);
	vga_w(regbase, VGA_ATT_IW, index);
	vga_w(regbase, VGA_ATT_W, data);
}


/** Write a value to a sequence register with a mask */
LIB_FUNC void svga_wseq_mask(void __iomem* regbase, uint8_t index, uint8_t data, uint8_t mask) {
	vga_wseq(regbase, (unsigned char)index, (unsigned char)((data & mask) | (vga_rseq(regbase, index) & (~mask))));
}


/** Write a value to a CRT register with a mask */
LIB_FUNC void svga_wcrt_mask(void __iomem* regbase, uint8_t index, uint8_t data, uint8_t mask) {
	vga_wcrt(regbase, (unsigned char)index, (unsigned char)((data & mask) | (vga_rcrt(regbase, index) & (~mask))));
}


/* TO DO: Add SVGA functions

LIB_FUNC int svga_primary_device(struct pci_dev* dev) {
	uint16_t flags;
	pci_read_config_word(dev, PCI_COMMAND, &flags);
	return (int)(flags & PCI_COMMAND_IO);
}

void svga_wcrt_multi(void __iomem *regbase, const struct vga_regset *regset, uint32_t value);
void svga_wseq_multi(void __iomem *regbase, const struct vga_regset *regset, uint32_t value);
void svga_set_default_gfx_regs(void __iomem *regbase);
void svga_set_default_atc_regs(void __iomem *regbase);
void svga_set_default_seq_regs(void __iomem *regbase);
void svga_set_default_crt_regs(void __iomem *regbase);
void svga_set_textmode_vga_regs(void __iomem *regbase);
void svga_settile(struct fb_info *info, struct fb_tilemap *map);
void svga_tilecopy(struct fb_info *info, struct fb_tilearea *area);
void svga_tilefill(struct fb_info *info, struct fb_tilerect *rect);
void svga_tileblit(struct fb_info *info, struct fb_tileblit *blit);
void svga_tilecursor(void __iomem *regbase, struct fb_info *info, struct fb_tilecursor *cursor);
int svga_get_tilemax(struct fb_info *info);
void svga_get_caps(struct fb_info *info, struct fb_blit_caps *caps, struct fb_var_screeninfo *var);
int svga_compute_pll(const struct svga_pll *pll, uint32_t f_wanted, uint16_t *m, uint16_t *n, uint16_t *r, int node);
int svga_check_timings(const struct svga_timing_regs *tm, struct fb_var_screeninfo *var, int node);
void svga_set_timings(void __iomem *regbase, const struct svga_timing_regs *tm, struct fb_var_screeninfo *var, uint32_t hmul, uint32_t hdiv, uint32_t vmul, uint32_t vdiv, uint32_t hborder, int node);
int svga_match_format(const struct svga_fb_format *frm, struct fb_var_screeninfo *var, struct fb_fix_screeninfo *fix);
*/


#endif  // SVGA_H


/* LIBMAD: MPEG AUDIO DECODER LIBRARY (<fixed.h>) */


#if (!(defined(LIBMAD_FIXED_H) || defined(_LIBMAD_FIXED_H_)))
#define LIBMAD_FIXED_H   (1)
#define _LIBMAD_FIXED_H_   (1)


typedef int32_t   mad_fixed_t;  // Must be 32 bits
typedef int32_t   mad_fixed64hi_t;  // Must be 32 bits
typedef uint32_t   mad_fixed64lo_t;  // Must be 32 bits
typedef volatile signed long   mad_fixed64_t;
#ifdef FPM_FLOAT
typedef double   mad_sample_t;
#else
typedef mad_fixed_t   mad_sample_t;
#endif


#define MAD_F_FRACBITS   (28)
#define MAD_F(x)   ((mad_fixed_t)(x))
#define MAD_F_MIN   ((mad_fixed_t)-0x80000000L)
#define MAD_F_MAX   ((mad_fixed_t)0x7fffffffL)
#define MAD_F_ONE   MAD_F(0x10000000)
#define mad_f_tofixed(x)   ((mad_fixed_t)((x) * (double)(1L << MAD_F_FRACBITS) + 0.5))
#define mad_f_todouble(x)   ((double)((x) / (double)(1L << MAD_F_FRACBITS)))
#define mad_f_intpart(x)   ((x) >> MAD_F_FRACBITS)
#define mad_f_fracpart(x)   ((x) & ((1L << MAD_F_FRACBITS) - 1))
#define mad_f_fromint(x)   ((x) << MAD_F_FRACBITS)
#define mad_f_add(x, y)   ((x) + (y))
#define mad_f_sub(x, y)   ((x) - (y))


#ifdef FPM_FLOAT
#   error   "FPM_FLOAT not yet supported!"
#   undef MAD_F
#   define MAD_F(x)   mad_f_todouble(x)
#   define mad_f_mul(x, y)   ((x) * (y))
#   define mad_f_scale64
#   undef ASO_ZEROCHECK
#elif defined(FPM_64BIT)
#   if defined(OPT_ACCURACY)
#      define mad_f_mul(x, y)   ((mad_fixed_t)((((mad_fixed64_t)(x) * (y)) + (1L << (MAD_F_SCALEBITS - 1))) >> MAD_F_SCALEBITS))
#   else
#      define mad_f_mul(x, y)   ((mad_fixed_t)(((mad_fixed64_t)(x) * (y)) >> MAD_F_SCALEBITS))
#   endif
#   define MAD_F_SCALEBITS   MAD_F_FRACBITS
#elif defined(FPM_INTEL)
#   ifdef MICROSOFT_VISUAL
#      pragma warning(push)
#      pragma warning(disable: 4035)  // No return value
LIB_FUNC mad_fixed_t mad_f_mul_inline(mad_fixed_t x, mad_fixed_t y) {
	enum { fracbits = MAD_F_FRACBITS };
	asm ("mov eax, x;" "imul y;" "shrd eax, edx, fracbits;")
}
#      pragma warning(pop)
#      define mad_f_mul   mad_f_mul_inline
#      define mad_f_scale64
#   else
#      define MAD_F_MLX(hi, lo, x, y)   asm ("imull %3;" : "=a"(lo), "=d"(hi) : "%a"(x), "rm"(y) : "cc")
#      ifdef OPT_ACCURACY
#         define MAD_F_MLA(hi, lo, x, y)  do { mad_fixed64hi_t __hi; mad_fixed64lo_t __lo; MAD_F_MLX(__hi, __lo, (x), (y)); asm ("addl %2, %0;" "adcl %3, %1;" : "=rm"(lo), "=rm"(hi) : "r"(__lo), "r"(__hi), "0"(lo), "1"(hi) : "cc"); } while (0x0)
#         define mad_f_scale64(hi, lo)   do { mad_fixed64hi_t __hi_; mad_fixed64lo_t __lo_; mad_fixed_t __result; asm ("addl %4, %2;" "adcl %5, %3;" : "=rm"(__lo_), "=rm"(__hi_) : "0"(lo), "1"(hi), "ir"((1L << (MAD_F_SCALEBITS - 1))), "ir"(0) : "cc"); asm ("shrdl %3, %2, %1;" : "=rm"(__result) : "0"(__lo_), "r"(__hi_), "I"(MAD_F_SCALEBITS) : "cc"); __result; } while (0x0)
#      elif defined(OPT_INTEL)
#         define mad_f_scale64(hi, lo)   do { mad_fixed_t __result; asm ("shrl %3,%1;" "shll %4, %2;" "orl %2, %1;" : "=rm"(__result) : "0"(lo), "r"(hi), "I"(MAD_F_SCALEBITS), "I"((32 - MAD_F_SCALEBITS)) : "cc"); __result; } while (0x0)
#      else
#         define mad_f_scale64(hi, lo)   do { mad_fixed_t __result; asm ("shrdl %3, %2, %1;" : "=rm"(__result) : "0"(lo), "r"(hi), "I"(MAD_F_SCALEBITS) : "cc"); __result; } while (0x0)
#      endif
#   define MAD_F_SCALEBITS   MAD_F_FRACBITS
#endif
#elif defined(FPM_ARM)
#   define mad_f_mul(x, y)   do { mad_fixed64hi_t __hi; mad_fixed64lo_t __lo; mad_fixed_t __result; asm ("smull %0, %1, %3, %4;" "movs %0, %0;" "lsr %5;" "adc %2, %0, %1;" "lsl %6;" : "=&r"(__lo), "=&r"(__hi), "=r"(__result) : "%r"(x), "r"(y), "M"(MAD_F_SCALEBITS), "M"(32 - MAD_F_SCALEBITS) : "cc"); __result; } while (0x0)
#   define MAD_F_MLX(hi, lo, x, y)   asm ("smull %0, %1, %2, %3;" : "=&r"(lo), "=&r"(hi) : "%r"(x), "r"(y))
#   define MAD_F_MLA(hi, lo, x, y)   asm ("smlal %0, %1, %2, %3;" : "+r"(lo), "+r"(hi) : "%r"(x), "r"(y))
#   define MAD_F_MLN(hi, lo)   asm ("rsbs %0, %2, #0;" "rsc %1, %3, #0;" : "=r"(lo), "=r"(hi) : "0"(lo), "1"(hi) : "cc")
#   define mad_f_scale64(hi, lo)   do { mad_fixed_t __result; asm ("movs %0, %1, lsr %3;" "adc %0, %0, %2;" "lsl %4;" : "=&r"(__result) : "r"(lo), "r"(hi), "M"(MAD_F_SCALEBITS), "M"((32 - MAD_F_SCALEBITS)) : "cc"); __result; } while (0x0)
#   define MAD_F_SCALEBITS   MAD_F_FRACBITS
#elif defined(FPM_MIPS)
#   define MAD_F_MLX(hi, lo, x, y)   asm ("mult %2, %3;" : "=l"(lo), "=h"(hi) : "%r"(x), "r"(y))
#   ifdef HAVE_MADD_ASM
#      define MAD_F_MLA(hi, lo, x, y)   asm ("madd %2, %3;" : "+l"(lo), "+h"(hi) : "%r"(x), "r"(y))
#   elif defined(HAVE_MADD16_ASM)
#      define MAD_F_ML0(hi, lo, x, y)   asm ("mult %2, %3;" : "=l"(lo), "=h"(hi) : "%r"(((x) >> 12)), "r"((y) >> 16))
#      define MAD_F_MLA(hi, lo, x, y)   asm ("madd16 %2, %3;" : "+l"(lo), "+h"(hi) : "%r"(((x) >> 12)), "r"((y) >> 16))
#      define MAD_F_MLZ(hi, lo)   ((mad_fixed_t)(lo))
#   endif
#   ifdef OPT_SPEED
#      define mad_f_scale64(hi, lo)   ((mad_fixed_t)((hi) << (32 - MAD_F_SCALEBITS)))
#      define MAD_F_SCALEBITS   MAD_F_FRACBITS
#   endif
#elif defined(FPM_SPARC)
#   define MAD_F_MLX(hi, lo, x, y)   asm ("smul %2, %3, %0;" "rd %%y, %1" : "=r"(lo), "=r"(hi) : "%r"(x), "rI"(y))
#elif defined(FPM_PPC)
#   define MAD_F_MLX(hi, lo, x, y)   do { asm ("mullw %0, %1, %2;" : "=r"(lo) : "%r"(x), "r"(y)); asm ("mulhw %0, %1, %2;" : "=r"(hi) : "%r"(x), "r"(y)); } while (0x0)
#   ifdef OPT_ACCURACY
#      define MAD_F_MLA(hi, lo, x, y)   do { mad_fixed64hi_t __hi; mad_fixed64lo_t __lo; MAD_F_MLX(__hi, __lo, (x), (y)); asm ("addc %0, %2, %3;" "adde %1, %4, %5;" : "=r"(lo), "=r"(hi) : "%r"(lo), "r"(__lo), "%r"(hi), "r"(__hi) : "xer"); } while (0x0)
#   endif
#   ifdef OPT_ACCURACY
#      define mad_f_scale64(hi, lo)   do { mad_fixed_t __result, __round; asm ("rotrwi %0, %1, %2;" : "=r"(__result) : "r"(lo), "i"(MAD_F_SCALEBITS)); asm ("extrwi %0, %1, 1, 0;" : "=r"(__round) : "r"(__result)); asm ("insrwi %0, %1, %2, 0;" : "+r"(__result) : "r"(hi), "i"(MAD_F_SCALEBITS)); asm ("add %0, %1, %2;" : "=r"(__result) : "%r"(__result), "r"(__round)); __result; } while (0x0)
#   else
#      define mad_f_scale64(hi, lo)   do { mad_fixed_t __result; asm ("rotrwi %0, %1, %2;" : "=r"(__result) : "r"(lo), "i"(MAD_F_SCALEBITS)); asm ("insrwi %0, %1, %2, 0;" : "+r"(__result) : "r"(hi), "i"(MAD_F_SCALEBITS)); __result; } while (0x0)
#   endif
#   define MAD_F_SCALEBITS   MAD_F_FRACBITS
#else  // FPM_DEFAULT
#   ifdef OPT_SPEED
#      define mad_f_mul(x, y)   (((x) >> 12) * ((y) >> 16))
#   else
#      define mad_f_mul(x, y)   ((((x) + (1L << 11)) >> 12) * (((y) + (1L << 15)) >> 16))
#   endif
#endif


#ifndef mad_f_scale64
#   ifdef OPT_ACCURACY
#      define mad_f_scale64(hi, lo)   ((((mad_fixed_t)(((hi) << (32 - (MAD_F_SCALEBITS - 1))) | ((lo) >> (MAD_F_SCALEBITS - 1)))) + 1) >> 1)
#   else
#      define mad_f_scale64(hi, lo)   ((mad_fixed_t)(((hi) << (32 - MAD_F_SCALEBITS)) | ((lo) >> MAD_F_SCALEBITS)))
#   endif
#   define MAD_F_SCALEBITS   MAD_F_FRACBITS
#endif
#ifndef mad_f_mul
#   define mad_f_mul(x, y)   do { register mad_fixed64hi_t __hi; register mad_fixed64lo_t __lo; MAD_F_MLX(__hi, __lo, (x), (y)); mad_f_scale64(__hi, __lo); } while (0x0)
#endif
#ifndef MAD_F_MLA
#   define MAD_F_ML0(hi, lo, x, y)   ((lo) = mad_f_mul((x), (y)))
#   define MAD_F_MLA(hi, lo, x, y)   ((lo) += mad_f_mul((x), (y)))
#   define MAD_F_MLN(hi, lo)   ((lo) = -(lo))
#   define MAD_F_MLZ(hi, lo)   ((void)(hi), (mad_fixed_t)(lo))
#endif
#ifndef MAD_F_ML0
#   define MAD_F_ML0(hi, lo, x, y)   MAD_F_MLX((hi), (lo), (x), (y))
#endif
#ifndef MAD_F_MLN
#   define MAD_F_MLN(hi, lo)   ((hi) = (((lo) = (-(lo))) ? (~(hi)) : (-(hi))))
#endif
#ifndef MAD_F_MLZ
#   define MAD_F_MLZ(hi, lo)   mad_f_scale64((hi), (lo))
#endif


/** Return absolute value of a fixed-point number */
LIB_FUNC mad_fixed_t mad_f_abs(const mad_fixed_t x) {
	return ((x < 0) ? (-x) : x);
}


/** Perform division using fixed-point math */
LIB_FUNC mad_fixed_t mad_f_div(register mad_fixed_t x, register mad_fixed_t y) {
	mad_fixed_t q, r;
	q = mad_f_abs((x / y));
	if (x < 0) {
		x = -x;
		y = -y;
	}
	r = x % y;
	if (y < 0) {
		x = -x;
		y = -y;
	}
	if (q > mad_f_intpart(MAD_F_MAX) && !(q == (-mad_f_intpart(MAD_F_MIN)) && r == 0 && (x < 0) != (y < 0))) { return 0; }
	register unsigned int bits = MAD_F_FRACBITS;
	for (; bits && r; --bits) {
		q <<= 1;
		r <<= 1;
		if (r >= y) { r -= y; ++q; }
	}
	if ((2 * r) >= y) { ++q; }
	if ((x < 0) != (y < 0)) { q = -q; }
	return q << bits;
}


#endif  // LIBMAD_FIXED_H


/* INDUSTRIAL I/O DATATYPES (LINUX KERNEL) */


#if (!(defined(IIO_TYPES_H) || defined(IIO_TYPES_H_) || defined(_IIO_TYPES_H) || defined(_IIO_TYPES_H_)))
#define IIO_TYPES_H   (1)
#define IIO_TYPES_H_   (1)
#define _IIO_TYPES_H   (1)
#define _IIO_TYPES_H_   (1)


typedef enum iio_chan_type {
	IIO_VOLTAGE,
	IIO_CURRENT,
	IIO_POWER,
	IIO_ACCEL,
	IIO_ANGL_VEL,
	IIO_MAGN,
	IIO_LIGHT,
	IIO_INTENSITY,
	IIO_PROXIMITY,
	IIO_TEMP,
	IIO_INCLI,
	IIO_ROT,
	IIO_ANGL,
	IIO_TIMESTAMP,
	IIO_CAPACITANCE,
	IIO_ALTVOLTAGE,
	IIO_CCT,
	IIO_PRESSURE,
	IIO_HUMIDITYRELATIVE,
	IIO_ACTIVITY,
	IIO_STEPS,
	IIO_ENERGY,
	IIO_DISTANCE,
	IIO_VELOCITY,
	IIO_CONCENTRATION,
	IIO_RESISTANCE
} iio_chan_t;


typedef enum iio_modifier {
	IIO_NO_MOD,
	IIO_MOD_X,
	IIO_MOD_Y,
	IIO_MOD_Z,
	IIO_MOD_X_AND_Y,
	IIO_MOD_X_AND_Z,
	IIO_MOD_Y_AND_Z,
	IIO_MOD_X_AND_Y_AND_Z,
	IIO_MOD_X_OR_Y,
	IIO_MOD_X_OR_Z,
	IIO_MOD_Y_OR_Z,
	IIO_MOD_X_OR_Y_OR_Z,
	IIO_MOD_LIGHT_BOTH,
	IIO_MOD_LIGHT_IR,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y,
	IIO_MOD_SUM_SQUARED_X_Y_Z,
	IIO_MOD_LIGHT_CLEAR,
	IIO_MOD_LIGHT_RED,
	IIO_MOD_LIGHT_GREEN,
	IIO_MOD_LIGHT_BLUE,
	IIO_MOD_QUATERNION,
	IIO_MOD_TEMP_AMBIENT,
	IIO_MOD_TEMP_OBJECT,
	IIO_MOD_NORTH_MAGN,
	IIO_MOD_NORTH_TRUE,
	IIO_MOD_NORTH_MAGN_TILT_COMP,
	IIO_MOD_NORTH_TRUE_TILT_COMP,
	IIO_MOD_RUNNING,
	IIO_MOD_JOGGING,
	IIO_MOD_WALKING,
	IIO_MOD_STILL,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z,
	IIO_MOD_I,
	IIO_MOD_Q,
	IIO_MOD_CO2,
	IIO_MOD_VOC
} iio_modifier_t;


typedef enum iio_event_type {
	IIO_EV_TYPE_THRESH,
	IIO_EV_TYPE_MAG,
	IIO_EV_TYPE_ROC,
	IIO_EV_TYPE_THRESH_ADAPTIVE,
	IIO_EV_TYPE_MAG_ADAPTIVE,
	IIO_EV_TYPE_CHANGE
} iio_event_t;


typedef enum iio_event_direction {
	IIO_EV_DIR_EITHER,
	IIO_EV_DIR_RISING,
	IIO_EV_DIR_FALLING,
	IIO_EV_DIR_NONE
} iio_event_direction_t;


#endif  // IIO_TYPES_H


/* GNU/HURD DATATYPES (<hurd_types.h>) */


#if (!(defined(HURD_TYPES_H) || defined(HURD_TYPES_H_) || defined(_HURD_TYPES_H) || defined(_HURD_TYPES_H_)))
#define HURD_TYPES_H   (1)
#define HURD_TYPES_H_   (1)
#define _HURD_TYPES_H   (1)
#define _HURD_TYPES_H_   (1)


#if (defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS == 64))
typedef struct stat   io_statbuf_t;
typedef struct statfs   fsys_statfsbuf_t;
#else
typedef struct stat64   io_statbuf_t;
typedef struct statfs64   fsys_statfsbuf_t;
#endif
/** Values for retry field in fs.defs:dir_lookup call: */
typedef enum retry_type {
	FS_RETRY_NORMAL = 1,  // Retry normally if retry_name is not null
	FS_RETRY_REAUTH = 2,  // Retry after reauthenticating retry port
	FS_RETRY_MAGICAL = 3  // Retry string is magical
} retry_type;
#define retry_t   retry_type
/** Types for fs_notify.defs:dir_changed call: */
typedef enum dir_changed_type {
	DIR_CHANGED_NULL,  // Always sent first for sync
	DIR_CHANGED_NEW,  // Specified name has been added
	DIR_CHANGED_UNLINK,  // Specified name has been removed
	DIR_CHANGED_RENUMBER  // Name has been the target of rename
} dir_changed_type;
#define dir_changed_type_t   dir_changed_type
/** Types for fs_notify.defs:file_changed call: */
typedef enum file_changed_type {
	FILE_CHANGED_NULL,  // Always sent first for sync
	FILE_CHANGED_WRITE,  // File data has been written
	FILE_CHANGED_EXTEND,  // File has grown
	FILE_CHANGED_TRUNCATE,  // File has been truncated
	FILE_CHANGED_META  // Stat information has changed, and none of the previous three apply; Not sent for changes in node times
} file_changed_type;
#define file_changed_type_t   file_changed_type
/** Types of ports the terminal driver can run on top of; Used in term.defs:term_get_bottom_type */
typedef enum term_bottom_type {
	TERM_ON_MACHDEV, TERM_ON_HURDIO, TERM_ON_MASTERPTY
} term_bottom_t;
/** Standard port assignments for file_exec and exec_* */
enum INIT_PORT_EXEC {
	INIT_PORT_CWDIR,
	INIT_PORT_CRDIR,
	INIT_PORT_AUTH,
	INIT_PORT_PROC,
	INIT_PORT_CTTYID,
	INIT_PORT_BOOTSTRAP,
	INIT_PORT_MAX
};
/** Standard ints for file_exec and exec_* */
enum INIT_EXEC {
	INIT_UMASK,
	INIT_SIGMASK,
	INIT_SIGIGN,
	INIT_SIGPENDING,
	INIT_TRACEMASK,
	INIT_INT_MAX
};
/** Types of storage, as returned by file_get_storage_info
	- STORAGE_DEVICE is a mach device_t (for random access devices)
	- STORAGE_HURD_FILE is a hurd file_t (as if a file were mapped)
	- STORAGE_TASK is a task_t (the storage is in the vm of the task)
	- STORAGE_MEMORY is a memory object port
	- STORAGE_ZERO is a fixed-size constant source of zeros
	- STORAGE_INTERLEAVE is a set of other storage types interleaved at a fixed interval
	- STORAGE_CONCAT is a set of other storage types concatenated end-to-end
	- STORAGE_LAYER is a set of storage types, representing the same address range; all will be written too, and will be read in turn until one succeeds
	- STORAGE_REMAP is a layer on top of another store that remaps its blocks
	- STORAGE_COPY is a memory snapshot of another store
	- STORAGE_NETWORK means that the file is stored elsewhere on the network; all the remaining fields contan type-specific information.
	- STORAGE_OTHER means none of these apply; and should be used when no meaningful answer can be given
*/
typedef enum file_storage_class {
	STORAGE_OTHER,
	STORAGE_DEVICE,
	STORAGE_HURD_FILE,
	STORAGE_NETWORK,
	STORAGE_MEMORY,
	STORAGE_TASK,
	STORAGE_ZERO,
	STORAGE_CONCAT,
	STORAGE_INTERLEAVE,
	STORAGE_LAYER,
	STORAGE_REMAP,
	STORAGE_COPY
} file_storage_class_t;


#endif  // HURD_TYPES_H


/* MYO PROGRAMMING API DATATYPES (<myotypes.h>) */


#if (!(defined(MYO_TYPES_H) || defined(_MYO_TYPES_H) || defined(_MYO_TYPES_H_)))
#define MYO_TYPES_H   (1)
#define _MYO_TYPES_H   (1)
#define _MYO_TYPES_H_   (1)


// Properties of MYO arenas
#define MYO_CONSISTENCY_MODE   3
#define MYO_RELEASE_CONSISTENCY   1
#define MYO_STRONG_RELEASE_CONSISTENCY   2
#define MYO_STRONG_CONSISTENCY   3
#define MYO_UPDATE_ON_DEMAND   8
#define MYO_UPDATE_ON_ACQUIRE   0x10
#define MYO_RECORD_DIRTY   0x20
#define MYO_NOT_RECORD_DIRTY   0x40
#define MYO_ONE_VERSION   0x80
#define MYO_MULTI_VERSIONS   0x100
#define MYO_CONSISTENCY   0x200
#define MYO_NO_CONSISTENCY   0x400
#define MYO_HOST_TO_DEVICE   0x800
#define MYO_DEVICE_TO_HOST   0x1000
#define MYO_HYBRID_UPDATE   0x2000
typedef enum MyoError_enum {
	MYO_SUCCESS = 0,  // Success
	MYO_ERROR,  // Error
	MYO_INVALID_ENV,  // Invalid Env
	MYO_INVALID_ARGUMENT,  // Invalid Argument
	MYO_NOT_INITIALIZED,  // Not Initialized
	MYO_ALREADY_FINALIZED,  // Already Finalized
	MYO_BUF_ERROR,  // Buffer Error
	MYO_OUT_OF_RANGE,  // Out of Range
	MYO_OUT_OF_MEMORY,  // Out of Memory
	MYO_ALREADY_EXISTS,  // Already Exists
	MYO_EOF  // EOF
} MyoError;
/** Arena Ownership */
typedef enum MyoOwnership {
	MYO_ARENA_MINE = 1,  // Arena MINE Ownership
	MYO_ARENA_OURS  //  Arena OURS Ownership
} MyoOwnershipType;
typedef unsigned int   MyoArena;
typedef void*   MyoMutex;
typedef void*   MyoSem;
typedef void*   MyoBarrier;


#endif  // MYO_TYPES_H


/* AUBIO DATATYPES */


#if (!(defined(_AUBIO__TYPES_H) || defined(_AUBIO__TYPES_H_) || defined(_AUBIO_TYPES_H)))
#define _AUBIO__TYPES_H   (1)
#define _AUBIO__TYPES_H_   (1)
#define _AUBIO_TYPES_H   (1)


#ifndef HAVE_AUBIO_DOUBLE
/** Defined to 1 if aubio is compiled in double precision */
#   define HAVE_AUBIO_DOUBLE   0
#endif
#ifndef HAVE_AUBIO_DOUBLE
/** Short sample format (32 or 64 bits) */
typedef float   smpl_t;
/** Print format for sample in single precision */
#   define AUBIO_SMPL_FMT   "%f"
#else
/** Short sample format (32 or 64 bits) */
typedef double   smpl_t;
/** Print format for double in single precision */
#   define AUBIO_SMPL_FMT   "%lf"
#endif
#ifndef HAVE_AUBIO_DOUBLE
/** Long sample format (64 bits or more) */
typedef double   lsmp_t;
/** Print format for sample in double precision */
#   define AUBIO_LSMP_FMT   "%lf"
#else
/** Long sample format (64 bits or more) */
typedef long double  lsmp_t;
/** Print format for double in double precision */
#   define AUBIO_LSMP_FMT   "%Lf"
#endif


#endif  // AUBIO_TYPES_H


/* MINIX VBOX */


#if ((!(defined(MINIX_VBOXTYPE_H) || defined(_MINIX_VBOXTYPE_H) || defined(_MINIX_VBOXTYPE_H_))) && defined(OSMINIX))
#define MINIX_VBOXTYPE_H   (1)
#define _MINIX_VBOXTYPE_H   (1)
#define _MINIX_VBOXTYPE_H_   (1)


// This header declares the type definitions shared between VBOX driver, the interface in libsys, and any caller of those interface functions

/** Call parameter type */
typedef enum vbox_type {
	VBOX_TYPE_INVALID,  // Invalid type
	VBOX_TYPE_U32,  // 32-bit value
	VBOX_TYPE_U64,  // 64-bit value
	VBOX_TYPE_PTR  // Pointer to granted memory area
} vbox_type_t;

// Call parameter transfer direction
/** From host to guest */
#define VBOX_DIR_IN   1
/** From guest to host */
#define VBOX_DIR_OUT   2
#define VBOX_DIR_INOUT   (VBOX_DIR_IN | VBOX_DIR_OUT)

/** Call parameter */
typedef struct attr_packed vbox_param {
	vbox_type_t type;
	union _vbox_data {
		uint32_t data_u32;
		uint64_t data_u64;
		struct attr_packed vbox_param_ptr {
			cp_grant_id_t grant;
			size_t off, size;
			unsigned int dir;
		} ptr;
	} _vbox_data;
} vbox_param_t;


#endif  // MINIX_VBOXTYPE_H


/* MINIX CONSTANTS */


#if ((!(defined(MINIX_CONST_H) || defined(_MINIX_CONST_H) || defined(_MINIX_CONST_H_))) && defined(OSMINIX))
#define MINIX_CONST_H   (1)
#define _MINIX_CONST_H   (1)
#define _MINIX_CONST_H_   (1)


/** uid_t of superuser */
#define SUPER_USER   ((uid_t)0)
/** super_user's uid_t */
#define SU_UID   SUPER_USER
/** uid_t for processes PM and INIT (on Minix and perhaps other systems) */
#define SYS_UID   ((uid_t)0)
/** gid_t for processes PM and INIT (on Minix and perhaps other systems) */
#define SYS_GID   ((gid_t)0)
#define GETDENTS_BUFSIZ   1024
/** Max # of entries in a SYS_VSAFECOPY request */
#define SCPVEC_NR   64
/** Max # of entries in a SYS_VUMAP request */
#define MAPVEC_NR   64
/** Maximum number of entries in an iorequest */
#define NR_IOREQS   64
/** SYS_VUMAP: read access */
#define VUA_READ   1
/** SYS_VUMAP: write access */
#define VUA_WRITE   2
// MEMORY RELATED CONSTANTS
/** Bit mask to get segment type */
#define SEGMENT_TYPE   0xFF00
/** Bit mask to get segment index */
#define SEGMENT_INDEX   0xFF
/** Flag indicating entire physical memory */
#define PHYS_SEG   0x400
/** Same as LOCAL_SEG, but with vm lookup */
#define LOCAL_VM_SEG   0x1000
#define MEM_GRANT   3
#define VIR_ADDR   1
#define VM_D   (LOCAL_VM_SEG | VIR_ADDR)
#define VM_GRANT   (LOCAL_VM_SEG | MEM_GRANT)
// LABELS USED TO DISABLE CODE SECTIONS
/** Unused code in normal configuration */
#define DEAD_CODE   0
/** New code to be activated + tested later */
#define FUTURE_CODE   0
/** Active code to be removed later */
#define TEMP_CODE   1
/** Scattered I/O */
#define HAVE_SCATTERED_IO   1
// MEMORY IS ALLOCATED IN CLICKS
/** Unit in which memory is allocated */
#define CLICK_SIZE   4096
/** log2 of CLICK_SIZE */
#define CLICK_SHIFT   12
// CLICK ALIGNMENT MACROS
#define CLICK_FLOOR(n)   (((vir_bytes)(n) / CLICK_SIZE) * CLICK_SIZE)
#define CLICK_CEIL(n)   CLICK_FLOOR((vir_bytes)(n) + CLICK_SIZE - 1)
#define CLICK2ABS(v)   ((v) << CLICK_SHIFT)
#define ABS2CLICK(a)   ((a) >> CLICK_SHIFT)
/** Sizes of memory tables */
#define NR_MEMS   16
// FLAG BITS FOR I_MODE IN THE INODE
/** Field gives inode type */
#define I_TYPE   0170000
/** Unix domain socket */
#define I_UNIX_SOCKET   0140000
/** File is a symbolic link */
#define I_SYMBOLIC_LINK   0120000
/** Regular file, not dir or special */
#define I_REGULAR   0100000
/** Block special file */
#define I_BLOCK_SPECIAL   060000
/** File is a directory */
#define I_DIRECTORY   040000
/** Character special file */
#define I_CHAR_SPECIAL   020000
/** Named pipe (FIFO) */
#define I_NAMED_PIPE   010000
/** Set effective uid_t on exec */
#define I_SET_UID_BIT   04000
/** Set effective gid_t on exec */
#define I_SET_GID_BIT   02000
/** Sticky bit */
#define I_SET_STCKY_BIT   01000
/** All bits for user, group and others */
#define ALL_MODES   07777
/** Mode bits for RWX only */
#define RWX_MODES   0777
/** Rwx protection bit */
#define R_BIT   4
/** rWx protection bit */
#define W_BIT   2
/** rwX protection bit */
#define X_BIT   1
/** Free inode */
#define I_NOT_ALLOC   0
// LIMITS
/** Largest inode number */
#define MAX_INODE_NR   ((ino_t)037777777777)
/** Largest legal file offset */
#define MAX_FILE_POS   ((off_t)0x7FFFFFFF)
/** Largest legal file offset */
#define UMAX_FILE_POS   ((unsigned)0x7FFFFFFF)
/** Max symbolic link recursion */
#define MAX_SYM_LOOPS   8
/** Absence of a block number */
#define NO_BLOCK   ((block_t)0)
/** Absence of a dir entry */
#define NO_ENTRY   ((ino_t)0)
/** Absence of a zone number */
#define NO_ZONE   ((zone_t)0)
/** Absence of incoming links */
#define NO_LINK   ((nlink_t)0)
#ifndef NO_DEV
/** Absence of a device numb */
#   define NO_DEV   ((dev_t)0)
#endif
/** Invalid UID value */
#define INVAL_UID   ((uid_t)-1)
/** Invalid GID value */
#define INVAL_GID   ((gid_t)-1)
#define SERVARNAME   "cttyline"
#define ARCHVARNAME   "arch"
#define BOARDVARNAME   "board"
#define SERBAUDVARNAME   "cttybaud"
// BITS FOR S_FLAGS IN THE PRIVILEGE STRUCTURE
/** Kernel tasks are not preemptible */
#define PREEMPTIBLE   2
/** Some processes are not billable */
#define BILLABLE   4
/** Privilege id assigned dynamically */
#define DYN_PRIV_ID   8
/** System processes have own priv structure */
#define SYS_PROC   0x10
/** Check if I/O request is allowed */
#define CHECK_IO_PORT   0x20
/** Check if IRQ can be used */
#define CHECK_IRQ   0x40
/** Check if (VM) mem map request is allowed */
#define CHECK_MEM   0x80
/** Root-system process instance */
#define ROOT_SYS_PROC   0x100
/** VM system process instance */
#define VM_SYS_PROC   0x200
/** live updated sys proc instance */
#define LU_SYS_PROC   0x400
/** Restarted sys proc instance */
#define RST_SYS_PROC   0x800
// VALUES FOR THE "VERBOSE" BOOT MONITOR VARIABLE
#define VERBOSEBOOT_QUIET   0
#define VERBOSEBOOT_BASIC   1
#define VERBOSEBOOT_EXTRA   2
#define VERBOSEBOOT_MAX   3
#define VERBOSEBOOTVARNAME   "verbose"
/** Magic value to put in struct proc entries for sanity checks */
#define PMAGIC   0xC0FFEE1
// MINIX_KERNFLAGS flags
/** SYSENTER available and supported */
#define MKF_I386_INTEL_SYSENTER   (1L)
/** SYSCALL available and supported */
#define MKF_I386_AMD_SYSCALL   (2L)


#endif  // MINIX_CONST_H


/* SPECIAL MACROS */


#ifndef _SPECIAL_MACROS_H_
#define _SPECIAL_MACROS_H_   (1)


#if SUPPORTS_FLOAT16
#   define _IS_SCALAR_FLOAT16_T_   float16_t: 1,
#   define _TYPENAME_FLOAT16_T_   float16_t: "float16_t",
#else
#   define _IS_SCALAR_FLOAT16_T_
#   define _TYPENAME_FLOAT16_T_
#endif
#if SUPPORTS_LONG_DOUBLE
#   define _IS_SCALAR_LONG_DOUBLE_   long double: 1,
#   define _TYPENAME_LONG_DOUBLE_   long double: "long double",
#else
#   define _IS_SCALAR_LONG_DOUBLE_
#   define _TYPENAME_LONG_DOUBLE_
#endif
#if SUPPORTS_FLOAT128
#   define _IS_SCALAR_FLOAT128_   float128: 1,
#   define _TYPENAME_FLOAT128_   float128: "float128",
#else
#   define _IS_SCALAR_FLOAT128_
#   define _TYPENAME_FLOAT128_
#endif
#if SUPPORTS_DECIMAL_FLOATS
#   define _IS_SCALAR_DECIMAL_FLOAT_   decimal32: 1, decimal64: 1,
#   define _TYPENAME_DECIMAL_FLOAT_   decimal32: "decimal32", decimal64: "decimal64",
#else
#   define _IS_SCALAR_DECIMAL_FLOAT_
#   define _TYPENAME_DECIMAL_FLOAT_
#endif
#if SUPPORTS_DECIMAL128
#   define _IS_SCALAR_DECIMAL128_   decimal128: 1,
#   define _TYPENAME_DECIMAL128_   decimal128: "decimal128",
#else
#   define _IS_SCALAR_DECIMAL128_
#   define _TYPENAME_DECIMAL128_
#endif
#if SUPPORTS_COMPLEX
#   define _IS_SCALAR_COMPLEX_   float complex: 1, double complex: 1,
#   define _TYPENAME_COMPLEX_   float complex: "float complex", double complex: "double complex",
#else
#   define _IS_SCALAR_COMPLEX_
#   define _TYPENAME_COMPLEX_
#endif
#if (SUPPORTS_LONG_DOUBLE && SUPPORTS_COMPLEX)
#   define _IS_SCALAR_LONG_DOUBLE_COMPLEX_   long double complex: 1,
#   define _TYPENAME_LONG_DOUBLE_COMPLEX_   long double complex: "long double complex",
#else
#   define _IS_SCALAR_LONG_DOUBLE_COMPLEX_
#   define _TYPENAME_LONG_DOUBLE_COMPLEX_
#endif
#if SUPPORTS_STDFIX
#   define _IS_SCALAR_STDFIX_   _Fract: 1, _Sat _Fract: 1, _Accum: 1, _Sat _Accum: 1,
#   define _TYPENAME_STDFIX_   _Fract: "_Fract", _Sat _Fract: "_Sat _Fract", _Accum: "_Accum", _Sat _Accum: "_Sat _Accum",
#else
#   define _IS_SCALAR_STDFIX_
#   define _TYPENAME_STDFIX_
#endif


#ifndef is_scalar
#   define is_scalar(type)   _Generic ((type), \
	_Bool: 1, \
	const char: 1, \
	volatile char: 1, \
	char: 1, \
	signed char: 1, \
	unsigned char: 1, \
	short: 1, \
	int: 1, \
	long: 1, \
	long long: 1, \
	_IS_SCALAR_FLOAT16_T_ \
	float: 1, \
	double: 1, \
	_IS_SCALAR_LONG_DOUBLE_ \
	_IS_SCALAR_FLOAT128_ \
	_IS_SCALAR_DECIMAL_FLOAT_ \
	_IS_SCALAR_DECIMAL128_ \
	_IS_SCALAR_COMPLEX_ \
	_IS_SCALAR_LONG_DOUBLE_COMPLEX_ \
	_IS_SCALAR_STDFIX_ \
	default: 0 \
)
#endif


#ifndef typename
/** Return the datatype of the given variable */
#   define typename(type)   _Generic ((type), \
	_Bool: "_Bool", \
	unsigned char: "unsigned char", \
	char: "char", \
	signed char: "signed char", \
	short: "short", \
	unsigned short: "unsigned short", \
	int: "int", \
	unsigned int: "unsigned int", \
	long: "long", \
	unsigned long: "unsigned long", \
	long long: "long long", \
	unsigned long long: "unsigned long long", \
	_TYPENAME_FLOAT16_T_ \
	float: "float", \
	double: "double", \
	_TYPENAME_LONG_DOUBLE_ \
	_TYPENAME_FLOAT128_ \
	_TYPENAME_DECIMAL_FLOAT_ \
	_TYPENAME_DECIMAL128_ \
	_TYPENAME_COMPLEX_ \
	_TYPENAME_LONG_DOUBLE_COMPLEX_ \
	_TYPENAME_STDFIX_ \
	char*: "pointer to char", \
	unsigned char*: "pointer to unsigned char", \
	signed char*: "pointer to signed char", \
	int*: "pointer to int", \
	unsigned int*: "pointer to unsigned int", \
	void*: "pointer to void", \
	void: "void", \
	default: "other" \
)
#endif  // typename(type)


/** Return the datatype of the given variable */
#define get_type(type)   typename((type))


/** This code is needed for the optimized mapping functions */
#define __tobody(c, f, a, args)   __extension__ ({ int __res; if (sizeof(c) > 1) { if (__builtin_constant_p(c)) { int __c = (c); __res = ((__c < (-128) || __c > 255) ? __c : (a)[__c]); } else { __res = f args; } } else { __res = (a)[(int)(c)]; } __res; })


#define DO_ALIGN(x, y)   (((size_t)(x) + ((y) - 1)) & (~((y) - 1)))
#define CONSTANT_STRLEN(x)   (sizeof(x) - sizeof(""))


#if IS_NOT_ASSEMBLER
#   define __BIT(__n)   (((uintmax_t)(__n) >= NBBY * SIZEOF_UINTMAX_T) ? 0 : ((uintmax_t)1 << (uintmax_t)((__n) & (NBBY * SIZEOF_UINTMAX_T - 1))))
#   define __BITS(__m, __n)   ((__BIT(MAX((__m), (__n)) + 1) - 1) ^ (__BIT(MIN((__m), (__n))) - 1))
#endif
#define __type_fit_u(t, a)   ((!__negative_p(a)) && (uintmax_t)((a) + __zeroull()) <= (uintmax_t)__type_max_u(t))
#define __type_fit_s(t, a)   (__negative_p(a) ? ((intmax_t)((a) + __zeroll()) >= (intmax_t)__type_min_s(t)) : ((intmax_t)((a) + __zeroll()) >= (intmax_t)0 && (intmax_t)((a) + __zeroll()) <= (intmax_t)__type_max_s(t)))
/** Return true if value 'a' fits in type 't' */
#define __type_fit(t, a)   (__type_is_signed(t) ? __type_fit_s(t, a) : __type_fit_u(t, a))


/** Macro to make it easier to loop over several blocks */
#define FOR_BLOCKS(length, dst, src, blocksize)   assert(!((length) % (blocksize))); for (; (length); ((length) -= (blocksize), (dst) += (blocksize), (src) += (blocksize)))


// DATATYPE TESTS

#define IS_CHAR(x)   _Generic ((x), const char: 1, const unsigned char: 1, char: 1, unsigned char: 1, const char*: 1, const unsigned char*: 1, char*: 1, unsigned char*: 1, default: 0)
#define IS_SHORT(x)   _Generic ((x), const short: 1, const unsigned short: 1, short: 1, unsigned short: 1, default: 0)
#define IS_INT(x)   _Generic ((x), const int: 1, const unsigned int: 1, int: 1, unsigned int: 1, default: 0)
#define IS_LONG(x)   _Generic ((x), const long: 1, const unsigned long: 1, long: 1, unsigned long: 1, default: 0)
#define IS_LONG_LONG(x)   _Generic ((x), const long long: 1, const unsigned long long: 1, long long: 1, unsigned long long: 1, default: 0)
#define IS_FLT(x)   _Generic ((x), const float: 1, float: 1, default: 0)
#define IS_DBL(x)   _Generic ((x), const double: 1, double: 1, default: 0)
#define IS_LDBL(x)   _Generic ((x), const long double: 1, long double: 1, default: 0)
#define IS_FLTCX(x)   _Generic ((x), const float complex: 1, float complex: 1, default: 0)
#define IS_DBLCX(x)   _Generic ((x), const double complex: 1, double complex: 1, default: 0)
#define IS_LDBLCX(x)   _Generic ((x), const long double complex: 1, long double complex: 1, default: 0)
#define IS_REAL(x)   (IS_FLT(x) || IS_DBL(x) || IS_LDBL(x))
#define IS_CX(x)   (IS_FLTCX(x) || IS_DBLCX(x) || IS_LDBLCX(x))
#define IS_CMPLX(x)   IS_CX((x))
#define IS_FP(x)   (IS_REAL(x) || IS_CMPLX(x))


#endif


/* PATHS (<paths.h>) */


#if (!(defined(_PATHS_H) || defined(_PATHS_H_) || defined(_SYS_PATHS_H_) || defined(_SYS_PATHS_H)))  // https://docs.oracle.com/cd/E36784_01/html/E36873/paths.h-3head.html
#define PATHS_H   (1)
#define _PATHS_H   (1)
#define _PATHS_H_   (1)
#define SYS_PATHS_H   (1)
#define _SYS_PATHS_H   (1)
#define _SYS_PATHS_H_   (1)


/** The default search path for locating catalogs */
#define DEF_NLSPATH   "/usr/share/catalogs"
#define ETHER_FILE_NAME   "/etc/ethers"
#define FREEBSD_DYNAMIC_LINKER32   "/libexec/ld-elf32.so.1"
#define FREEBSD_DYNAMIC_LINKER64   "/libexec/ld-elf.so.1"
#define _PATH_BSHELL   "/bin/sh"
#define PATH_BSHELL   _PATH_BSHELL
#define _PATH_CONSOLE   "/dev/console"
#define _PATH_CSHELL   "/bin/csh"
#define PATH_CSHELL   _PATH_CSHELL
#define _PATH_DATANAME   "data"
#define _PATH_DEFPATH   "/usr/local/bin:/bin:/usr/bin"
#define _PATH_DEV   "/dev/"
#define _PATH_DEVDB   "/var/run/dev.db"
/** Path to dev-null */
#define _PATH_DEVNULL   "/dev/null"
/** Path to dev-null */
#define PATH_DEVNULL   _PATH_DEVNULL
#define _PATH_DRUM   "/dev/drum"
#define _PATH_ELF_HINTS   "/var/run/ld-elf.so.hints"
#ifndef _PATH_ETHERS
#   define _PATH_ETHERS   "/etc/ethers"
#endif
/** Provides support for system wide forks */
#define _PATH_FORKSPECIFIER    "/..namedfork/"
#define _PATH_KLOG   "/proc/kmsg"
#define _PATH_KMEM   "/dev/kmem"
#define _PATH_LASTLOG   "/var/log/lastlog"
#define _PATH_MAILDIR   "/var/mail"
#define _PATH_MAN   "/usr/share/man"
#define _PATH_MEM   "/dev/mem"
#define _PATH_MNTTAB    "/etc/fstab"
#define _PATH_MOUNTED   "/etc/mtab"
#define _PATH_NOLOGIN   "/etc/nologin"
#ifndef _PATH_NS_CONF
#   define _PATH_NS_CONF   "/etc/nsswitch.conf"
#endif
#define _PATH_PRESERVE   "/var/lib"
#define _PATH_PTMDEV   "/dev/ptm"
/** Prefix for master pseudo terminal nodes */
#define _PATH_PTY   "/dev/pty"
#define _PATH_RSRCNAME   "rsrc"
#define _PATH_RSRCFORKSPEC   "/..namedfork/rsrc"
#define _PATH_RWHODIR   "/var/spool/rwho"
#define _PATH_SENDMAIL  "/usr/sbin/sendmail"
#define _PATH_SHADOW   "/etc/shadow"
#define _PATH_SHELL   "/bin/sh"
#define _PATH_SHELLS   "/etc/shells"
#define _PATH_STDPATH   "/bin:/usr/bin:/sbin:/usr/sbin"
#define _PATH_TTY   "/dev/tty"
#define _PATH_UNIX   "/boot/vmlinux"
#define _PATH_UTMP   "/dev/null/utmp"
#define _PATH_VI   "/usr/bin/vi"
#define _PATH_WTMP   "/dev/null/wtmp"
#define _PATH_TMP   "/tmp/"
#define _PATH_VARDB   "/var/lib/misc/"
#define _PATH_VARRUN   "/var/run/"
#define _PATH_VARTMP   "/var/tmp/"
#ifndef P_tmpdir
#   define P_tmpdir   _PATH_TMP
#endif


#endif  // PATHS_H


/* ERRNO: SYSTEM ERROR NUMBERS (<errno.h>) */


#if (!(defined(ERRNO_H) || defined(_ERRNO_H) || defined(_ERRNO_H_)))  // http://www.cplusplus.com/reference/cerrno/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
#define ERRNO_H   (1)
#define _ERRNO_H   (1)
#define _ERRNO_H_   (1)


/** Struct for table of error messages */
typedef struct attr_packed errname {
	short errcode;  // Error number
	short action;  // Operation which encountered the error
	const char* msg;  // Text describing the error
} errname_t;


/** In SVID error handling, `matherr` is called with this description of the exceptional condition */
typedef struct exception {
	int err, type;
	const char* name;
	double arg1, arg2, retval;
} exception_t;


static const UNUSED char* const h_errlist[8] = {
	"Resolver Error 0 (no error)",
	"Unknown host",  // 1 HOST_NOT_FOUND
	"Host name lookup failure",  // 2 TRY_AGAIN
	"Unknown server error",  // 3 NO_RECOVERY
	"No address associated with name",  // 4 NO_ADDRESS
	"\0"
};
static const UNUSED char error_msg[16] = "Resolver error";
static const UNUSED char colon_space[4] = ": \0";
#define h_nerr   (int)(sizeof(h_errlist) / sizeof(h_errlist[0]))


#ifdef ALPHA  // ERROR NUMBERS

/** Operation not permitted */
#define EPERM   (1)
/** No such file or directory */
#define ENOENT   (2)
/** No such process */
#define ESRCH   (3)
/** Interrupted system call */
#define EINTR   (4)
/** I/O error */
#define EIO   (5)
/** No such device or address */
#define ENXIO   (6)
/** Arg list too long */
#define E2BIG   (7)
/** Exec format error */
#define ENOEXEC   (8)
/** Bad file number */
#define EBADF   (9)
/** No child processes */
#define ECHILD   (10)
/** Resource deadlock would occur */
#define EDEADLK   (11)
/** Out of memory */
#define ENOMEM   (12)
/** Permission denied */
#define EACCES   (13)
/** Bad address */
#define EFAULT   (14)
/** Block device required */
#define ENOTBLK   (15)
/** Device or resource busy */
#define EBUSY   (16)
/** File exists */
#define EEXIST   (17)
/** Cross-device link */
#define EXDEV   (18)
/** No such device */
#define ENODEV   (19)
/** Not a directory */
#define ENOTDIR   (20)
/** Is a directory */
#define EISDIR   (21)
/** Invalid argument */
#define EINVAL   (22)
/** File table overflow */
#define ENFILE   (23)
/** Too many open files */
#define EMFILE   (24)
/** Not a typewriter */
#define ENOTTY   (25)
/** Text file busy */
#define ETXTBSY   (26)
/** File too large */
#define EFBIG   (27)
/** No space left on device */
#define ENOSPC   (28)
/** Illegal seek */
#define ESPIPE   (29)
/** Read-only file system */
#define EROFS   (30)
/** Too many links */
#define EMLINK   (31)
/** Broken pipe */
#define EPIPE   (32)
/** Math argument out of domain of func */
#define EDOM   (33)
/** Math result not representable */
#define ERANGE   (34)
/** Try again */
#define EAGAIN   (35)
/** Operation would block */
#define EWOULDBLOCK   (EAGAIN)
/** Operation now in progress */
#define EINPROGRESS   (36)
/** Operation already in progress */
#define EALREADY   (37)
/** Socket operation on non-socket */
#define ENOTSOCK   (38)
/** Destination address required */
#define EDESTADDRREQ   (39)
/** Message too long */
#define EMSGSIZE   (40)
/** Protocol wrong type for socket */
#define EPROTOTYPE   (41)
/** Protocol not available */
#define ENOPROTOOPT   (42)
/** Protocol not supported */
#define EPROTONOSUPPORT   (43)
/** Socket type not supported */
#define ESOCKTNOSUPPORT   (44)
/** Operation not supported on transport endpoint */
#define EOPNOTSUPP   (45)
/** Operation not supported on transport endpoint */
#define ENOTSUP   (EOPNOTSUPP)
/** Protocol family not supported */
#define EPFNOSUPPORT   (46)
/** Address family not supported by protocol */
#define EAFNOSUPPORT   (47)
/** Address already in use */
#define EADDRINUSE   (48)
/** Cannot assign requested address */
#define EADDRNOTAVAIL   (49)
/** Network is down */
#define ENETDOWN   (50)
/** Network is unreachable */
#define ENETUNREACH   (51)
/** Network dropped connection because of reset */
#define ENETRESET   (52)
/** Software caused connection abort */
#define ECONNABORTED   (53)
/** Connection reset by peer */
#define ECONNRESET   (54)
/** No buffer space available */
#define ENOBUFS   (55)
/** Transport endpoint is already connected */
#define EISCONN   (56)
/** Transport endpoint is not connected */
#define ENOTCONN   (57)
/** Cannot send after transport endpoint shutdown */
#define ESHUTDOWN   (58)
/** Too many references: cannot splice */
#define ETOOMANYREFS   (59)
/** Connection timed out */
#define ETIMEDOUT   (60)
/** Connection refused */
#define ECONNREFUSED   (61)
/** Too many symbolic links encountered */
#define ELOOP   (62)
/** File name too long */
#define ENAMETOOLONG   (63)
/** Host is down */
#define EHOSTDOWN   (64)
/** No route to host */
#define EHOSTUNREACH   (65)
/** Directory not empty */
#define ENOTEMPTY   (66)
/** Too many users */
#define EUSERS   (68)
/** Quota exceeded */
#define EDQUOT   (69)
/** Stale NFS file handle */
#define ESTALE   (70)
/** Object is remote */
#define EREMOTE   (71)
/** No record locks available */
#define ENOLCK   (77)
/** Function not implemented */
#define ENOSYS   (78)
/** No message of desired type */
#define ENOMSG   (80)
/** Identifier removed */
#define EIDRM   (81)
/** Out of streams resources */
#define ENOSR   (82)
/** Timer expired */
#define ETIME   (83)
/** Not a data message */
#define EBADMSG   (84)
/** Protocol error */
#define EPROTO   (85)
/** No data available */
#define ENODATA   (86)
/** Device not a stream */
#define ENOSTR   (87)
/** Package not installed */
#define ENOPKG   (92)
/** Illegal byte sequence */
#define EILSEQ   (116)
/** Channel number out of range */
#define ECHRNG   (88)
/** Level 2 not synchronized */
#define EL2NSYNC   (89)
/** Level 3 halted */
#define EL3HLT   (90)
/** Level 3 reset */
#define EL3RST   (91)
/** Link number out of range */
#define ELNRNG   (93)
/** Protocol driver not attached */
#define EUNATCH   (94)
/** No CSI structure available */
#define ENOCSI   (95)
/** Level 2 halted */
#define EL2HLT   (96)
/** Invalid exchange */
#define EBADE   (97)
/** Invalid request descriptor */
#define EBADR   (98)
/** Exchange full */
#define EXFULL   (99)
/** No anode */
#define ENOANO   (100)
/** Invalid request code */
#define EBADRQC   (101)
/** Invalid slot */
#define EBADSLT   (102)
#define EDEADLOCK   (EDEADLK)
/** Bad font file format */
#define EBFONT   (104)
/** Machine is not on the network */
#define ENONET   (105)
/** Link has been severed */
#define ENOLINK   (106)
/** Advertise error */
#define EADV   (107)
/** Srmount error */
#define ESRMNT   (108)
/** Communication error on send */
#define ECOMM   (109)
/** Multihop attempted */
#define EMULTIHOP   (110)
/** RFS specific error */
#define EDOTDOT   (111)
/** Value too large for defined datatype */
#define EOVERFLOW   (112)
/** Name not unique on network */
#define ENOTUNIQ   (113)
/** File descriptor in bad state */
#define EBADFD   (114)
/** Remote address changed */
#define EREMCHG   (115)
/** Structure needs cleaning */
#define EUCLEAN   (117)
/** Not a XENIX named type file */
#define ENOTNAM   (118)
/** No XENIX semaphores available */
#define ENAVAIL   (119)
/** Is a named type file */
#define EISNAM   (120)
/** Remote I/O error */
#define EREMOTEIO   (121)
/** Can not access a needed shared library */
#define ELIBACC   (122)
/** Accessing a corrupted shared library */
#define ELIBBAD   (123)
/** .lib section in a.out corrupted */
#define ELIBSCN   (124)
/** Attempting to link in too many shared libraries */
#define ELIBMAX   (125)
/** Cannot exec a shared library directly */
#define ELIBEXEC   (126)
/** Interrupted system call should be restarted */
#define ERESTART   (127)
/** Streams pipe error */
#define ESTRPIPE   (128)
/** No medium found */
#define ENOMEDIUM   (129)
/** Wrong medium type */
#define EMEDIUMTYPE   (130)
/** Operation Cancelled */
#define ECANCELED   (131)
/** Required key not available */
#define ENOKEY   (132)
/** Key has expired */
#define EKEYEXPIRED   (133)
/** Key has been revoked */
#define EKEYREVOKED   (134)
/** Key was rejected by service */
#define EKEYREJECTED   (135)
#define __SYS_NERR   ((EKEYREJECTED) + 1)

#elif defined(HPPA)

/** Operation not permitted */
#define EPERM   (1)
/** No such file or directory */
#define ENOENT   (2)
/** No such process */
#define ESRCH   (3)
/** Interrupted system call */
#define EINTR   (4)
/** I/O error */
#define EIO   (5)
/** No such device or address */
#define ENXIO   (6)
/** Argument list too long */
#define E2BIG   (7)
/** Exec format error */
#define ENOEXEC   (8)
/** Bad file number */
#define EBADF   (9)
/** No child processes */
#define ECHILD   (10)
/** Try again */
#define EAGAIN   (11)
/** Out of memory */
#define ENOMEM   (12)
/** Permission denied */
#define EACCES   (13)
/** Bad address */
#define EFAULT   (14)
/** Block device required */
#define ENOTBLK   (15)
/** Device or resource busy */
#define EBUSY   (16)
/** File exists */
#define EEXIST   (17)
/** Cross-device link */
#define EXDEV   (18)
/** No such device */
#define ENODEV   (19)
/** Not a directory */
#define ENOTDIR   (20)
/** Is a directory */
#define EISDIR   (21)
/** Invalid argument */
#define EINVAL   (22)
/** File table overflow */
#define ENFILE   (23)
/** Too many open files */
#define EMFILE   (24)
/** Not a typewriter */
#define ENOTTY   (25)
/** Text file busy */
#define ETXTBSY   (26)
/** File too large */
#define EFBIG   (27)
/** No space left on device */
#define ENOSPC   (28)
/** Illegal seek */
#define ESPIPE   (29)
/** Read-only file system */
#define EROFS   (30)
/** Too many links */
#define EMLINK   (31)
/** Broken pipe */
#define EPIPE   (32)
/** Math argument out of domain of func */
#define EDOM   (33)
/** Math result not representable */
#define ERANGE   (34)
/** No message of desired type */
#define ENOMSG   (35)
/** Identifier removed */
#define EIDRM   (36)
/** Channel number out of range */
#define ECHRNG   (37)
/** Level 2 not synchronized */
#define EL2NSYNC   (38)
/** Level 3 halted */
#define EL3HLT   (39)
/** Level 3 reset */
#define EL3RST   (40)
/** Link number out of range */
#define ELNRNG   (41)
/** Protocol driver not attached */
#define EUNATCH   (42)
/** No CSI structure available */
#define ENOCSI   (43)
/** Level 2 halted */
#define EL2HLT   (44)
/** Resource deadlock would occur */
#define EDEADLK   (45)
#define EDEADLOCK   (EDEADLK)
/** No record locks available */
#define ENOLCK   (46)
/** Illegal byte sequence */
#define EILSEQ   (47)
/** Machine is not on the network */
#define ENONET   (50)
/** No data available */
#define ENODATA   (51)
/** Timer expired */
#define ETIME   (52)
/** Out of streams resources */
#define ENOSR   (53)
/** Device not a stream */
#define ENOSTR   (54)
/** Package not installed */
#define ENOPKG   (55)
/** Link has been severed */
#define ENOLINK   (57)
/** Advertise error */
#define EADV   (58)
/** Srmount error */
#define ESRMNT   (59)
/** Communication error on send */
#define ECOMM   (60)
/** Protocol error */
#define EPROTO   (61)
/** Multihop attempted */
#define EMULTIHOP   (64)
/** RFS specific error */
#define EDOTDOT   (66)
/** Not a data message */
#define EBADMSG   (67)
/** Too many users */
#define EUSERS   (68)
/** Quota exceeded */
#define EDQUOT   (69)
/** Stale NFS file handle */
#define ESTALE   (70)
/** Object is remote */
#define EREMOTE   (71)
/** Value too large for defined datatype */
#define EOVERFLOW   (72)
// These errnos are defined by Linux but not HPUX
/** Invalid exchange */
#define EBADE   (160)
/** Invalid request descriptor */
#define EBADR   (161)
/** Exchange full */
#define EXFULL   (162)
/** No anode */
#define ENOANO   (163)
/** Invalid request code */
#define EBADRQC   (164)
/** Invalid slot */
#define EBADSLT   (165)
/** Bad font file format */
#define EBFONT   (166)
/** Name not unique on network */
#define ENOTUNIQ   (167)
/** File descriptor in bad state */
#define EBADFD   (168)
/** Remote address changed */
#define EREMCHG   (169)
/** Can not access a needed shared library */
#define ELIBACC   (170)
/** Accessing a corrupted shared library */
#define ELIBBAD   (171)
/** .lib section in a.out corrupted */
#define ELIBSCN   (172)
/** Attempting to link in too many shared libraries */
#define ELIBMAX   (173)
/** Cannot exec a shared library directly */
#define ELIBEXEC   (174)
/** Interrupted system call should be restarted */
#define ERESTART   (175)
/** Streams pipe error */
#define ESTRPIPE   (176)
/** Structure needs cleaning */
#define EUCLEAN   (177)
/** Not a XENIX named type file */
#define ENOTNAM   (178)
/** No XENIX semaphores available */
#define ENAVAIL   (179)
/** Is a named type file */
#define EISNAM   (180)
/** Remote I/O error */
#define EREMOTEIO   (181)
/** No medium found */
#define ENOMEDIUM   (182)
/** Wrong medium type */
#define EMEDIUMTYPE   (183)
/** Required key not available */
#define ENOKEY   (184)
/** Key has expired */
#define EKEYEXPIRED   (185)
/** Key has been revoked */
#define EKEYREVOKED   (186)
/** Key was rejected by service */
#define EKEYREJECTED   (187)
// HPUX
/** symbol does not exist in executable */
#define ENOSYM   (215)
/** Socket operation on non-socket */
#define ENOTSOCK   (216)
/** Destination address required */
#define EDESTADDRREQ   (217)
/** Message too long */
#define EMSGSIZE   (218)
/** Protocol wrong type for socket */
#define EPROTOTYPE   (219)
/** Protocol not available */
#define ENOPROTOOPT   (220)
/** Protocol not supported */
#define EPROTONOSUPPORT   (221)
/** Socket type not supported */
#define ESOCKTNOSUPPORT   (222)
/** Operation not supported on transport endpoint */
#define EOPNOTSUPP   (223)
/** Protocol family not supported */
#define EPFNOSUPPORT   (224)
/** Address family not supported by protocol */
#define EAFNOSUPPORT   (225)
/** Address already in use */
#define EADDRINUSE   (226)
/** Cannot assign requested address */
#define EADDRNOTAVAIL   (227)
/** Network is down */
#define ENETDOWN   (228)
/** Network is unreachable */
#define ENETUNREACH   (229)
/** Network dropped connection because of reset */
#define ENETRESET   (230)
/** Software caused connection abort */
#define ECONNABORTED   (231)
/** Connection reset by peer */
#define ECONNRESET   (232)
/** No buffer space available */
#define ENOBUFS   (233)
/** Transport endpoint is already connected */
#define EISCONN   (234)
/** Transport endpoint is not connected */
#define ENOTCONN   (235)
/** Cannot send after transport endpoint shutdown */
#define ESHUTDOWN   (236)
/** Too many references: cannot splice */
#define ETOOMANYREFS   (237)
/** for HP's NFS apparently */
#define EREFUSED   (ECONNREFUSED)
/** Connection timed out */
#define ETIMEDOUT   (238)
/** Connection refused */
#define ECONNREFUSED   (239)
/** Remote peer released connection */
#define EREMOTERELEASE   (240)
/** Host is down */
#define EHOSTDOWN   (241)
/** No route to host */
#define EHOSTUNREACH   (242)
/** Operation already in progress */
#define EALREADY   (244)
/** Operation now in progress */
#define EINPROGRESS   (245)
/** Operation would block (Linux returns EAGAIN) */
#define EWOULDBLOCK   (246)
/** Directory not empty */
#define ENOTEMPTY   (247)
/** File name too long */
#define ENAMETOOLONG   (248)
/** Too many symbolic links encountered */
#define ELOOP   (249)
/** Function not implemented */
#define ENOSYS   (251)
/** Function not implemented (POSIX.4 / HPUX) */
#define ENOTSUP   (252)
/** aio request was canceled before complete (POSIX.4 / HPUX) */
#define ECANCELLED   (253)
#define __SYS_NERR   (((ECANCELLED) + 1)

#elif defined(MIPS)

/** Operation not permitted */
#define EPERM   (1)
/** No such file or directory */
#define ENOENT   (2)
/** No such process */
#define ESRCH   (3)
/** Interrupted system call */
#define EINTR   (4)
/** I/O error */
#define EIO   (5)
/** No such device or address */
#define ENXIO   (6)
/** Arg list too long */
#define E2BIG   (7)
/** Exec format error */
#define ENOEXEC   (8)
/** Bad file number */
#define EBADF   (9)
/** No child processes */
#define ECHILD   (10)
/** Try again */
#define EAGAIN   (11)
/** Out of memory */
#define ENOMEM   (12)
/** Permission denied */
#define EACCES   (13)
/** Bad address */
#define EFAULT   (14)
/** Block device required */
#define ENOTBLK   (15)
/** Device or resource busy */
#define EBUSY   (16)
/** File exists */
#define EEXIST   (17)
/** Cross-device link */
#define EXDEV   (18)
/** No such device */
#define ENODEV   (19)
/** Not a directory */
#define ENOTDIR   (20)
/** Is a directory */
#define EISDIR   (21)
/** Invalid argument */
#define EINVAL   (22)
/** File table overflow */
#define ENFILE   (23)
/** Too many open files */
#define EMFILE   (24)
/** Not a typewriter */
#define ENOTTY   (25)
/** Text file busy */
#define ETXTBSY   (26)
/** File too large */
#define EFBIG   (27)
/** No space left on device */
#define ENOSPC   (28)
/** Illegal seek */
#define ESPIPE   (29)
/** Read-only file system */
#define EROFS   (30)
/** Too many links */
#define EMLINK   (31)
/** Broken pipe */
#define EPIPE   (32)
/** Math argument out of domain of func */
#define EDOM   (33)
/** Math result not representable */
#define ERANGE   (34)
/** No message of desired type */
#define ENOMSG   (35)
/** Identifier removed */
#define EIDRM   (36)
/** Channel number out of range */
#define ECHRNG   (37)
/** Level 2 not synchronized */
#define EL2NSYNC   (38)
/** Level 3 halted */
#define EL3HLT   (39)
/** Level 3 reset */
#define EL3RST   (40)
/** Link number out of range */
#define ELNRNG   (41)
/** Protocol driver not attached */
#define EUNATCH   (42)
/** No CSI structure available */
#define ENOCSI   (43)
/** Level 2 halted */
#define EL2HLT   (44)
/** Resource deadlock would occur */
#define EDEADLK   (45)
/** No record locks available */
#define ENOLCK   (46)
/** Invalid exchange */
#define EBADE   (50)
/** Invalid request descriptor */
#define EBADR   (51)
/** Exchange full */
#define EXFULL   (52)
/** No anode */
#define ENOANO   (53)
/** Invalid request code */
#define EBADRQC   (54)
/** Invalid slot */
#define EBADSLT   (55)
/** File locking deadlock error */
#define EDEADLOCK   (56)
/** Bad font file format */
#define EBFONT   (59)
/** Device not a stream */
#define ENOSTR   (60)
/** No data available */
#define ENODATA   (61)
/** Timer expired */
#define ETIME   (62)
/** Out of streams resources */
#define ENOSR   (63)
/** Machine is not on the network */
#define ENONET   (64)
/** Package not installed */
#define ENOPKG   (65)
/** Object is remote */
#define EREMOTE   (66)
/** Link has been severed */
#define ENOLINK   (67)
/** Advertise error */
#define EADV   (68)
/** Srmount error */
#define ESRMNT   (69)
/** Communication error on send */
#define ECOMM   (70)
/** Protocol error */
#define EPROTO   (71)
/** RFS specific error */
#define EDOTDOT   (73)
/** Multihop attempted */
#define EMULTIHOP   (74)
/** Not a data message */
#define EBADMSG   (77)
/** File name too long */
#define ENAMETOOLONG   (78)
/** Value too large for defined datatype */
#define EOVERFLOW   (79)
/** Name not unique on network */
#define ENOTUNIQ   (80)
/** File descriptor in bad state */
#define EBADFD   (81)
/** Remote address changed */
#define EREMCHG   (82)
/** Can not access a needed shared library */
#define ELIBACC   (83)
/** Accessing a corrupted shared library */
#define ELIBBAD   (84)
/** .lib section in a.out corrupted */
#define ELIBSCN   (85)
/** Attempting to link in too many shared libraries */
#define ELIBMAX   (86)
/** Cannot exec a shared library directly */
#define ELIBEXEC   (87)
/** Illegal byte sequence */
#define EILSEQ   (88)
/** Function not implemented */
#define ENOSYS   (89)
/** Too many symbolic links encountered */
#define ELOOP   (90)
/** Interrupted system call should be restarted */
#define ERESTART   (91)
/** Streams pipe error */
#define ESTRPIPE   (92)
/** Directory not empty */
#define ENOTEMPTY   (93)
/** Too many users */
#define EUSERS   (94)
/** Socket operation on non-socket */
#define ENOTSOCK   (95)
/** Destination address required */
#define EDESTADDRREQ   (96)
/** Message too long */
#define EMSGSIZE   (97)
/** Protocol wrong type for socket */
#define EPROTOTYPE   (98)
/** Protocol not available */
#define ENOPROTOOPT   (99)
/** Protocol not supported */
#define EPROTONOSUPPORT   (120)
/** Socket type not supported */
#define ESOCKTNOSUPPORT   (121)
/** Operation not supported on transport endpoint */
#define EOPNOTSUPP   (122)
/** Operation not supported on transport endpoint */
#define ENOTSUP   (EOPNOTSUPP)
/** Protocol family not supported */
#define EPFNOSUPPORT   (123)
/** Address family not supported by protocol */
#define EAFNOSUPPORT   (124)
/** Address already in use */
#define EADDRINUSE   (125)
/** Cannot assign requested address */
#define EADDRNOTAVAIL   (126)
/** Network is down */
#define ENETDOWN   (127)
/** Network is unreachable */
#define ENETUNREACH   (128)
/** Network dropped connection because of reset */
#define ENETRESET   (129)
/** Software caused connection abort */
#define ECONNABORTED   (130)
/** Connection reset by peer */
#define ECONNRESET   (131)
/** No buffer space available */
#define ENOBUFS   (132)
/** Transport endpoint is already connected */
#define EISCONN   (133)
/** Transport endpoint is not connected */
#define ENOTCONN   (134)
/** Structure needs cleaning */
#define EUCLEAN   (135)
/** Not a XENIX named type file */
#define ENOTNAM   (137)
/** No XENIX semaphores available */
#define ENAVAIL   (138)
/** Is a named type file */
#define EISNAM   (139)
/** Remote I/O error */
#define EREMOTEIO   (140)
/** Reserved */
#define EINIT   (141)
/** Error 142 */
#define EREMDEV   (142)
/** Cannot send after transport endpoint shutdown */
#define ESHUTDOWN   (143)
/** Too many references: cannot splice */
#define ETOOMANYREFS   (144)
/** Connection timed out */
#define ETIMEDOUT   (145)
/** Connection refused */
#define ECONNREFUSED   (146)
/** Host is down */
#define EHOSTDOWN   (147)
/** No route to host */
#define EHOSTUNREACH   (148)
/** Operation would block */
#define EWOULDBLOCK   (EAGAIN)
/** Operation already in progress */
#define EALREADY   (149)
/** Operation now in progress */
#define EINPROGRESS   (150)
/** Stale NFS file handle */
#define ESTALE   (151)
/** AIO operation canceled */
#define ECANCELED   (158)
/** No medium found */
#define ENOMEDIUM   (159)
/** Wrong medium type */
#define EMEDIUMTYPE   (160)
/** Required key not available */
#define ENOKEY   (161)
/** Key has expired */
#define EKEYEXPIRED   (162)
/** Key has been revoked */
#define EKEYREVOKED   (163)
/** Key was rejected by service */
#define EKEYREJECTED   (164)
/** Quota exceeded */
#define EDQUOT   (1133)
#define __SYS_NERR   ((EKEYREJECTED) + 1)

#elif defined(SPARC)

/** Operation not permitted */
#define EPERM   (1)
/** No such file or directory */
#define ENOENT   (2)
/** No such process */
#define ESRCH   (3)
/** Interrupted system call */
#define EINTR   (4)
/** I/O error */
#define EIO   (5)
/** No such device or address */
#define ENXIO   (6)
/** Arg list too long */
#define E2BIG   (7)
/** Exec format error */
#define ENOEXEC   (8)
/** Bad file number */
#define EBADF   (9)
/** No child processes */
#define ECHILD   (10)
/** Try again */
#define EAGAIN   (11)
/** Out of memory */
#define ENOMEM   (12)
/** Permission denied */
#define EACCES   (13)
/** Bad address */
#define EFAULT   (14)
/** Block device required */
#define ENOTBLK   (15)
/** Device or resource busy */
#define EBUSY   (16)
/** File exists */
#define EEXIST   (17)
/** Cross-device link */
#define EXDEV   (18)
/** No such device */
#define ENODEV   (19)
/** Not a directory */
#define ENOTDIR   (20)
/** Is a directory */
#define EISDIR   (21)
/** Invalid argument */
#define EINVAL   (22)
/** File table overflow */
#define ENFILE   (23)
/** Too many open files */
#define EMFILE   (24)
/** Not a typewriter */
#define ENOTTY   (25)
/** Text file busy */
#define ETXTBSY   (26)
/** File too large */
#define EFBIG   (27)
/** No space left on device */
#define ENOSPC   (28)
/** Illegal seek */
#define ESPIPE   (29)
/** Read-only file system */
#define EROFS   (30)
/** Too many links */
#define EMLINK   (31)
/** Broken pipe */
#define EPIPE   (32)
/** Math argument out of domain of func */
#define EDOM   (33)
/** Math result not representable */
#define ERANGE   (34)
/** Operation would block */
#define EWOULDBLOCK   (EAGAIN)
/** Operation now in progress */
#define EINPROGRESS   (36)
/** Operation already in progress */
#define EALREADY   (37)
/** Socket operation on non-socket */
#define ENOTSOCK   (38)
/** Destination address required */
#define EDESTADDRREQ   (39)
/** Message too long */
#define EMSGSIZE   (40)
/** Protocol wrong type for socket */
#define EPROTOTYPE   (41)
/** Protocol not available */
#define ENOPROTOOPT   (42)
/** Protocol not supported */
#define EPROTONOSUPPORT   (43)
/** Socket type not supported */
#define ESOCKTNOSUPPORT   (44)
/** Op not supported on transport endpoint */
#define EOPNOTSUPP   (45)
/** Operation not supported on transport endpoint */
#define ENOTSUP   (EOPNOTSUPP)
/** Protocol family not supported */
#define EPFNOSUPPORT   (46)
/** Address family not supported by protocol */
#define EAFNOSUPPORT   (47)
/** Address already in use */
#define EADDRINUSE   (48)
/** Cannot assign requested address */
#define EADDRNOTAVAIL   (49)
/** Network is down */
#define ENETDOWN   (50)
/** Network is unreachable */
#define ENETUNREACH   (51)
/** Net dropped connection because of reset */
#define ENETRESET   (52)
/** Software caused connection abort */
#define ECONNABORTED   (53)
/** Connection reset by peer */
#define ECONNRESET   (54)
/** No buffer space available */
#define ENOBUFS   (55)
/** Transport endpoint is already connected */
#define EISCONN   (56)
/** Transport endpoint is not connected */
#define ENOTCONN   (57)
/** No send after transport endpoint shutdown */
#define ESHUTDOWN   (58)
/** Too many references: cannot splice */
#define ETOOMANYREFS   (59)
/** Connection timed out */
#define ETIMEDOUT   (60)
/** Connection refused */
#define ECONNREFUSED   (61)
/** Too many symbolic links encountered */
#define ELOOP   (62)
/** File name too long */
#define ENAMETOOLONG   (63)
/** Host is down */
#define EHOSTDOWN   (64)
/** No route to host */
#define EHOSTUNREACH   (65)
/** Directory not empty */
#define ENOTEMPTY   (66)
/** SUNOS: Too many processes */
#define EPROCLIM   (67)
/** Too many users */
#define EUSERS   (68)
/** Quota exceeded */
#define EDQUOT   (69)
/** Stale NFS file handle */
#define ESTALE   (70)
/** Object is remote */
#define EREMOTE   (71)
/** Device not a stream */
#define ENOSTR   (72)
/** Timer expired */
#define ETIME   (73)
/** Out of streams resources */
#define ENOSR   (74)
/** No message of desired type */
#define ENOMSG   (75)
/** Not a data message */
#define EBADMSG   (76)
/** Identifier removed */
#define EIDRM   (77)
/** Resource deadlock would occur */
#define EDEADLK   (78)
/** No record locks available */
#define ENOLCK   (79)
/** Machine is not on the network */
#define ENONET   (80)
/** SunOS: Too many lvls of remote in path */
#define ERREMOTE   (81)
/** Link has been severed */
#define ENOLINK   (82)
/** Advertise error */
#define EADV   (83)
/** Srmount error */
#define ESRMNT   (84)
/** Communication error on send */
#define ECOMM   (85)
/** Protocol error */
#define EPROTO   (86)
/** Multihop attempted */
#define EMULTIHOP   (87)
/** RFS specific error */
#define EDOTDOT   (88)
/** Remote address changed */
#define EREMCHG   (89)
/** Function not implemented */
#define ENOSYS   (90)
/** Streams pipe error */
#define ESTRPIPE   (91)
/** Value too large for defined datatype */
#define EOVERFLOW   (92)
/** File descriptor in bad state */
#define EBADFD   (93)
/** Channel number out of range */
#define ECHRNG   (94)
/** Level 2 not synchronized */
#define EL2NSYNC   (95)
/** Level 3 halted */
#define EL3HLT   (96)
/** Level 3 reset */
#define EL3RST   (97)
/** Link number out of range */
#define ELNRNG   (98)
/** Protocol driver not attached */
#define EUNATCH   (99)
/** No CSI structure available */
#define ENOCSI   (100)
/** Level 2 halted */
#define EL2HLT   (101)
/** Invalid exchange */
#define EBADE   (102)
/** Invalid request descriptor */
#define EBADR   (103)
/** Exchange full */
#define EXFULL   (104)
/** No anode */
#define ENOANO   (105)
/** Invalid request code */
#define EBADRQC   (106)
/** Invalid slot */
#define EBADSLT   (107)
/** File locking deadlock error */
#define EDEADLOCK   (108)
/** Bad font file format */
#define EBFONT   (109)
/** Cannot exec a shared library directly */
#define ELIBEXEC   (110)
/** No data available */
#define ENODATA   (111)
/** Accessing a corrupted shared library */
#define ELIBBAD   (112)
/** Package not installed */
#define ENOPKG   (113)
/** Can not access a needed shared library */
#define ELIBACC   (114)
/** Name not unique on network */
#define ENOTUNIQ   (115)
/** Interrupted syscall should be restarted */
#define ERESTART   (116)
/** Structure needs cleaning */
#define EUCLEAN   (117)
/** Not a XENIX named type file */
#define ENOTNAM   (118)
/** No XENIX semaphores available */
#define ENAVAIL   (119)
/** Is a named type file */
#define EISNAM   (120)
/** Remote I/O error */
#define EREMOTEIO   (121)
/** Illegal byte sequence */
#define EILSEQ   (122)
/** Atmpt to link in too many shared libs */
#define ELIBMAX   (123)
/** .lib section in a.out corrupted */
#define ELIBSCN   (124)
/** No medium found */
#define ENOMEDIUM   (125)
/** Wrong medium type */
#define EMEDIUMTYPE   (126)
/** Operation Cancelled */
#define ECANCELED   (127)
/** Required key not available */
#define ENOKEY   (128)
/** Key has expired */
#define EKEYEXPIRED   (129)
/** Key has been revoked */
#define EKEYREVOKED   (130)
/** Key was rejected by service */
#define EKEYREJECTED   (131)
#define __SYS_NERR   ((EKEYREJECTED) + 1)

#else  // i386, ARM, PowerPC, x86-64, ia64

/** Operation not permitted */
#define EPERM   (1)
/** No such file or directory */
#define ENOENT   (2)
/** No such process */
#define ESRCH   (3)
/** Interrupted system call */
#define EINTR   (4)
/** I/O error */
#define EIO   (5)
/** No such device or address */
#define ENXIO   (6)
/** Arg list too long */
#define E2BIG   (7)
/** Exec format error */
#define ENOEXEC   (8)
/** Bad file number */
#define EBADF   (9)
/** No child processes */
#define ECHILD   (10)
/** Try again */
#define EAGAIN   (11)
/** Out of memory */
#define ENOMEM   (12)
/** Permission denied */
#define EACCES   (13)
/** Bad address */
#define EFAULT   (14)
/** Block device required */
#define ENOTBLK   (15)
/** Device or resource busy */
#define EBUSY   (16)
/** File exists */
#define EEXIST   (17)
/** Cross-device link */
#define EXDEV   (18)
/** No such device */
#define ENODEV   (19)
/** Not a directory */
#define ENOTDIR   (20)
/** Is a directory */
#define EISDIR   (21)
/** Invalid argument */
#define EINVAL   (22)
/** File table overflow */
#define ENFILE   (23)
/** Too many open files */
#define EMFILE   (24)
/** Not a typewriter */
#define ENOTTY   (25)
/** Text file busy */
#define ETXTBSY   (26)
/** File too large */
#define EFBIG   (27)
/** No space left on device */
#define ENOSPC   (28)
/** Illegal seek */
#define ESPIPE   (29)
/** Read-only file system */
#define EROFS   (30)
/** Too many links */
#define EMLINK   (31)
/** Broken pipe */
#define EPIPE   (32)
/** Math argument out of domain of func */
#define EDOM   (33)
/** Math result not representable */
#define ERANGE   (34)
/** Resource deadlock would occur */
#define EDEADLK   (35)
/** File name too long */
#define ENAMETOOLONG   (36)
/** No record locks available */
#define ENOLCK   (37)
/** Function not implemented */
#define ENOSYS   (38)
/** Directory not empty */
#define ENOTEMPTY   (39)
/** Too many symbolic links encountered */
#define ELOOP   (40)
/** Operation would block */
#define EWOULDBLOCK   (EAGAIN)
/** No message of desired type */
#define ENOMSG   (42)
/** Identifier removed */
#define EIDRM   (43)
/** Channel number out of range */
#define ECHRNG   (44)
/** Level 2 not synchronized */
#define EL2NSYNC   (45)
/** Level 3 halted */
#define EL3HLT   (46)
/** Level 3 reset */
#define EL3RST   (47)
/** Link number out of range */
#define ELNRNG   (48)
/** Protocol driver not attached */
#define EUNATCH   (49)
/** No CSI structure available */
#define ENOCSI   (50)
/** Level 2 halted */
#define EL2HLT   (51)
/** Invalid exchange */
#define EBADE   (52)
/** Invalid request descriptor */
#define EBADR   (53)
/** Exchange full */
#define EXFULL   (54)
/** No anode */
#define ENOANO   (55)
/** Invalid request code */
#define EBADRQC   (56)
/** Invalid slot */
#define EBADSLT   (57)
#define EDEADLOCK   (EDEADLK)
/** Bad font file format */
#define EBFONT   (59)
/** Device not a stream */
#define ENOSTR   (60)
/** No data available */
#define ENODATA   (61)
/** Timer expired */
#define ETIME   (62)
/** Out of streams resources */
#define ENOSR   (63)
/** Machine is not on the network */
#define ENONET   (64)
/** Package not installed */
#define ENOPKG   (65)
/** Object is remote */
#define EREMOTE   (66)
/** Link has been severed */
#define ENOLINK   (67)
/** Advertise error */
#define EADV   (68)
/** Srmount error */
#define ESRMNT   (69)
/** Communication error on send */
#define ECOMM   (70)
/** Protocol error */
#define EPROTO   (71)
/** Multihop attempted */
#define EMULTIHOP   (72)
/** RFS specific error */
#define EDOTDOT   (73)
/** Not a data message */
#define EBADMSG   (74)
/** Value too large for defined datatype */
#define EOVERFLOW   (75)
/** Name not unique on network */
#define ENOTUNIQ   (76)
/** File descriptor in bad state */
#define EBADFD   (77)
/** Remote address changed */
#define EREMCHG   (78)
/** Can not access a needed shared library */
#define ELIBACC   (79)
/** Accessing a corrupted shared library */
#define ELIBBAD   (80)
/** .lib section in a.out corrupted */
#define ELIBSCN   (81)
/** Attempting to link in too many shared libraries */
#define ELIBMAX   (82)
/** Cannot exec a shared library directly */
#define ELIBEXEC   (83)
/** Illegal byte sequence */
#define EILSEQ   (84)
/** Interrupted system call should be restarted */
#define ERESTART   (85)
/** Streams pipe error */
#define ESTRPIPE   (86)
/** Too many users */
#define EUSERS   (87)
/** Socket operation on non-socket */
#define ENOTSOCK   (88)
/** Destination address required */
#define EDESTADDRREQ   (89)
/** Message too long */
#define EMSGSIZE   (90)
/** Protocol wrong type for socket */
#define EPROTOTYPE   (91)
/** Protocol not available */
#define ENOPROTOOPT   (92)
/** Protocol not supported */
#define EPROTONOSUPPORT   (93)
/** Socket type not supported */
#define ESOCKTNOSUPPORT   (94)
/** Operation not supported on transport endpoint */
#define EOPNOTSUPP   (95)
/** Operation not supported on transport endpoint */
#define ENOTSUP   (EOPNOTSUPP)
/** Protocol family not supported */
#define EPFNOSUPPORT   (96)
/** Address family not supported by protocol */
#define EAFNOSUPPORT   (97)
/** Address already in use */
#define EADDRINUSE   (98)
/** Cannot assign requested address */
#define EADDRNOTAVAIL   (99)
/** Network is down */
#define ENETDOWN   (100)
/** Network is unreachable */
#define ENETUNREACH   (101)
/** Network dropped connection because of reset */
#define ENETRESET   (102)
/** Software caused connection abort */
#define ECONNABORTED   (103)
/** Connection reset by peer */
#define ECONNRESET   (104)
/** No buffer space available */
#define ENOBUFS   (105)
/** Transport endpoint is already connected */
#define EISCONN   (106)
/** Transport endpoint is not connected */
#define ENOTCONN   (107)
/** Cannot send after transport endpoint shutdown */
#define ESHUTDOWN   (108)
/** Too many references: cannot splice */
#define ETOOMANYREFS   (109)
/** Connection timed out */
#define ETIMEDOUT   (110)
/** Connection refused */
#define ECONNREFUSED   (111)
/** Host is down */
#define EHOSTDOWN   (112)
/** No route to host */
#define EHOSTUNREACH   (113)
/** Operation already in progress */
#define EALREADY   (114)
/** Operation now in progress */
#define EINPROGRESS   (115)
/** Stale NFS file handle */
#define ESTALE   (116)
/** Structure needs cleaning */
#define EUCLEAN   (117)
/** Not a XENIX named type file */
#define ENOTNAM   (118)
/** No XENIX semaphores available */
#define ENAVAIL   (119)
/** Is a named type file */
#define EISNAM   (120)
/** Remote I/O error */
#define EREMOTEIO   (121)
/** Quota exceeded */
#define EDQUOT   (122)
/** No medium found */
#define ENOMEDIUM   (123)
/** Wrong medium type */
#define EMEDIUMTYPE   (124)
/** Operation Canceled */
#define ECANCELED   (125)
/** Required key not available */
#define ENOKEY   (126)
/** Key has expired */
#define EKEYEXPIRED   (127)
/** Key has been revoked */
#define EKEYREVOKED   (128)
/** Key was rejected by service */
#define EKEYREJECTED   (129)
#define __SYS_NERR   ((EKEYREJECTED) + 1)

#endif  // ERROR NUMBERS


#ifndef EFTYPE
#   ifdef OSPOSIX
/** POSIX 1003.1 bad file format errno */
#      define EFTYPE   EIO
#   else
/** POSIX 1003.1 bad file format errno */
#      define EFTYPE   EINVAL
#   endif
#endif


// Types of operations (passed to the errmsg routine)
/** Opening a file */
#define E_OPEN   1
/** Creating a file */
#define E_CREAT   2
/** Executing a program */
#define E_EXEC   4
// Exceptions
/** SIGINT received */
#define EXINT   0
/** Generic error */
#define EXERROR   1
/** Execute a shell procedure */
#define EXSHELLPROC   2
/** Command execution failed */
#define EXEXEC   3

#ifndef __BIONIC_ERRDEF
#   define __BIONIC_ERRDEF(x, y, z)   { (x), (y), (z) },
#endif

// File system extended attribute errors
/** Attribute not found */
#define ENOATTR   (_SIGN 93)
// Realtime, XSI STREAMS option errors
/** Must equal largest errno */
#define ELAST   (_SIGN 96)
#if (defined(_KERNEL) || defined(_KMEMUSER))
// Pseudo-errors returned inside kernel to modify return to process
/** Do not modify regs, just return */
#   define EJUSTRETURN   (-2)
/** Restart syscall */
#   define ERESTART   (-3)
/** ioctl not handled by this layer */
#   define EPASSTHROUGH   (-4)
/** Dup given fd */
#   define EDUPFD   (-5)
/** Move given fd */
#   define EMOVEFD   (-6)
#endif
// Special stand error codes
/** Bad adaptor */
#define EADAPT   (ELAST + 1)
/** Bad controller */
#define ECTLR   (ELAST + 2)
/** Bad drive */
#define EUNIT   (ELAST + 3)
/** Bad partition */
#define EPART   (ELAST + 4)
/** Cannot read disk label */
#define ERDLAB   (ELAST + 5)
/** Unlabeled disk */
#define EUNLAB   (ELAST + 6)
/** Relative seek not supported */
#define EOFFSET   (ELAST + 7)
/** Undefined driver command */
#define ECMD   (ELAST + 8)
/** Bad sector error */
#define EBSE   (ELAST + 9)
/** Write check error */
#define EWCK   (ELAST + 10)
/** Uncorrectable ecc error */
#define EECC   (ELAST + 11)
/** Hard error */
#define EHER   (ELAST + 12)
#define ESALAST   (ELAST + 12)


/** Table of error messages */
static const UNUSED struct errname errormsg[] = {
	{ EINTR, (E_OPEN | E_CREAT | E_EXEC), "Interrupted" },
	{ EACCES, (E_OPEN | E_CREAT | E_EXEC), "Permission denied" },
	{ EIO, (E_OPEN | E_CREAT | E_EXEC), "I/O error" },
	{ EEXIST, (E_OPEN | E_CREAT | E_EXEC), "File exists" },
	{ ENOENT, E_OPEN, "No such file" },
	{ ENOENT, E_CREAT,"Directory nonexistent" },
	{ ENOENT, E_EXEC, "Not found" },
	{ ENOTDIR, E_OPEN, "No such file" },
	{ ENOTDIR, E_CREAT,"Directory nonexistent" },
	{ ENOTDIR, E_EXEC, "Not found" },
	{ EISDIR, (E_OPEN | E_CREAT | E_EXEC), "is a directory" },
#   ifdef EMFILE
	{ EMFILE, (E_OPEN | E_CREAT | E_EXEC), "Too many open files" },
#   endif
	{ ENFILE, (E_OPEN | E_CREAT | E_EXEC), "File table overflow" },
	{ ENOSPC, (E_OPEN | E_CREAT | E_EXEC), "File system full" },
#   ifdef EDQUOT
	{ EDQUOT, (E_OPEN | E_CREAT | E_EXEC), "Disk quota exceeded" },
#   endif
#   ifdef ENOSR
	{ ENOSR, (E_OPEN | E_CREAT | E_EXEC), "No streams resources" },
#   endif
	{ ENXIO, (E_OPEN | E_CREAT | E_EXEC), "No such device or address" },
	{ EROFS, (E_OPEN | E_CREAT | E_EXEC), "Read-only file system" },
	{ ETXTBSY, (E_OPEN | E_CREAT | E_EXEC), "Text busy" },
#   ifdef EAGAIN
	{ EAGAIN, E_EXEC, "Not enough memory" },
#   endif
	{ ENOMEM, (E_OPEN | E_CREAT | E_EXEC), "Not enough memory" },
#   ifdef ENOLINK
	{ ENOLINK, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef EMULTIHOP
	{ EMULTIHOP, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ECOMM
	{ ECOMM, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ESTALE
	{ ESTALE, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ETIMEDOUT
	{ ETIMEDOUT, (E_OPEN | E_CREAT | E_EXEC), "Remote access failed" },
#   endif
#   ifdef ELOOP
	{ ELOOP, (E_OPEN | E_CREAT | E_EXEC), "Symbolic link loop" },
#   endif
#   ifdef ENAMETOOLONG
	{ ENAMETOOLONG, 7, "File name too long" },
#   endif
	{ E2BIG, E_EXEC, "Argument list too long" },
#   ifdef ELIBACC
	{ ELIBACC, E_EXEC, "Shared library missing" },
#   endif
	{ 0, 0, NULL },
};


static const UNUSED struct attr_packed mi {
	int errno;
	const char* msg;
} errlist[] = {
	{ EADAPT, "Bad adaptor number" },
	{ ECTLR, "Bad controller number" },
	{ EUNIT, "Bad drive number" },
	{ EPART, "Bad partition" },
	{ ERDLAB, "Cannot read disk label" },
	{ EUNLAB, "Unlabeled" },
	{ ENXIO, "Device not configured" },
	{ EPERM, "Operation not permitted" },
	{ ENOENT, "No such file or directory" },
	{ ESTALE, "Stale NFS file handle" },
	{ EFTYPE, "Inappropriate file type or format" },
	{ ENOEXEC, "Exec format error" },
	{ EIO, "Input/output error" },
	{ EINVAL, "Invalid argument" },
	{ ENOTDIR, "Not a directory" },
	{ EOFFSET, "Invalid file offset" },
	{ EACCES, "Permission denied" },
	{ 0, 0 },
};


#ifndef __error_t_defined
/** Datatype for the `errno` variable; The Hurd <bits/errno.h> defines `error_t` as an enumerated type so that printing `error_t` values in the debugger shows the names */
typedef int   error_t;
/** Darwin alternative to error_t */
#   define errno_t   error_t
#   define __error_t_defined   (1)
#endif
#define SIZEOF_ERROR_T   SIZEOF_INT
typedef unsigned long   error_status_t;
#define SIZEOF_ERROR_STATUS_T   SIZEOF_LONG


#ifndef errno
/** Declare the `errno` variable for errors; In GNU, it is a per-thread variable */
Thread_local UNUSED int errno;
Thread_local UNUSED int exception;
/** Error for EXEXEC */
Thread_local UNUSED int exerrno;
#endif
#ifndef _errno
#   define _errno   errno
#endif
#ifndef __errno
#   define __errno   errno
#endif
#ifndef __h_errno
#   define __h_errno   errno
#endif
#ifndef __libc_h_errno
#   define __libc_h_errno   errno
#endif
#ifndef h_errno
#   define h_errno   errno
#endif
#ifndef SIZEOF_ERRNO
#   define SIZEOF_ERRNO   SIZEOF_INT
#endif


/** When threaded, h_errno may be a per-thread variable; This gives the address of errno */
#define __errno_location()   ((int*)&errno)
/** When threaded, h_errno may be a per-thread variable; This gives the address of errno */
#define errno_location()   ((int*)&errno)
/** When threaded, h_errno may be a per-thread variable; This gives the address of __h_errno */
#define __h_errno_location()   ((int*)&__h_errno)
/** When threaded, h_errno may be a per-thread variable; This gives the address of __h_errno */
#define h_errno_location()   ((int*)&__h_errno)
#define fssh_errno   ((int*)&__h_errno)
#define _fssh_errnop()   ((int*)&__h_errno)


#ifndef __set_errno
/** Set the value of the `errno` variable */
#   define __set_errno(val)   (errno = (val))
#endif
#ifndef set_errno
/** Set the value of the `errno` variable */
#   define set_errno(val)   (errno = (val))
#endif
#ifndef _set_errno
/** Set the value of the `errno` variable */
#   define _set_errno(val)   (errno = (val))
#endif
#ifndef fssh_set_errno
/** Set the value of the `errno` variable */
#   define fssh_set_errno(val)   (errno = (val))
#endif
#define RETURN_AND_SET_ERRNO(err)   if (err < 0) { __set_errno(err); return -1; } return err;
#define fssh_get_errno()   (int)(errno)


#ifdef _BSD_SOURCE
/** Use strerror() instead */
static const UNUSED char* const sys_errlist[];
static UNUSED int sys_nerr;
#endif
#ifdef argv
static UNUSED char* program_invocation_name = argv[0];
static UNUSED char* program_invocation_short_name = argv[0];
#elif defined(_GNU_SOURCE)
static UNUSED char* program_invocation_name = 0;
#   define __progname_full   program_invocation_name
static UNUSED char* program_invocation_short_name = 0;
#   define __progname   program_invocation_short_name
#endif


/** Signal that an error occurred */
#define ERROR_RETURN   do { __set_errno(EINVAL); return NULL; } while (0x0)
#define __fp_range_check(fp_y, fp_x)   if (__FPMAX_ZERO_OR_INF_CHECK((fpmax_t)(fp_y)) && ((fpmax_t)(fp_y) != 0) && (!(__FPMAX_ZERO_OR_INF_CHECK((fpmax_t)(fp_x))))) /* y is 0 or +/- infinity; y is not 0 (could have x>0, y==0 if underflow); or x is not 0 or +/- infinity */ { __set_errno(ERANGE); /* x is not in y's range */ }


// ERRNO FUNCTIONS


/** Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno` set to EINTR */
#define TEMP_FAILURE_RETRY(expression)   __extension__ ({ long __result; do { __result = (long)(expression); } while (__result == (-1L) && errno == EINTR); __result; })


/** Return the string associated with a given "host" errno value */
LIB_FUNC const char* hstrerror(const int err) {
	if (err < 0) { return (const char*)("Resolver internal error"); }
	else if (err < h_nerr) { return (const char*)(h_errlist[err]); }
	return (const char*)("Unknown resolver error");
}
#define fssh_to_host_error(err)   (int)hstrerror((err))


LIB_FUNC char* strerror(const int err) {
	const struct mi* mi;
	for (mi = errlist; mi->msg; mi++) {
		if (mi->errno == err) { return __UNCONST(mi->msg); }
	}
	static char ebuf[36] = { 0 };
	snprintf(ebuf, sizeof(ebuf), "Unknown error: code %d", err);
	return ebuf;
}
#define strerror_r(err, x, size)   strerror((err))
#define rk_strerror_r(err)   strerror((err))
#define rk_strerror(err)   strerror((err))
#define strerror_l(err, locale)   strerror((err))


/** Print error message */
LIB_FUNC void perror(const char* s) {
	if (s == NULL) { s = ""; }
	const char* separator;
	if (*s == '\0') { separator = ""; }
	else { separator = ": "; }
	char buf[NL_TEXTMAX] = { 0 };
	(void)strerror(errno);
	(void)fprintf(stderr, "%s%s%s\n", s, separator, buf);
}


#endif  // ERRNO_H


/* FSSH ERRORS (<fssh_errors.h> && <fssh_errno.h>) */


#if (!(defined(_FSSH_ERRORS_H) || defined(_FSSH_ERRORS_H_) || defined(_FSSH_ERRNO_H) || defined(_FSSH_ERRNO_H_)))
#define _FSSH_ERRORS_H   (1)
#define _FSSH_ERRORS_H_   (1)
#define _FSSH_ERRNO_H   (1)
#define _FSSH_ERRNO_H_   (1)


#define FSSH_ENOERR   0
/** Some code assumes EOK exists */
#define FSSH_EOK   0


// Error baselines
#define FSSH_B_GENERAL_ERROR_BASE   INT_MIN
#define FSSH_B_OS_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x1000)
#define FSSH_B_APP_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x2000)
#define FSSH_B_INTERFACE_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x3000)
#define FSSH_B_MEDIA_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x4000)
#define FSSH_B_TRANSLATION_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x4800)
#define FSSH_B_MIDI_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x5000)
#define FSSH_B_STORAGE_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x6000)
#define FSSH_B_POSIX_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x7000)
#define FSSH_B_MAIL_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x8000)
#define FSSH_B_PRINT_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0x9000)
#define FSSH_B_DEVICE_ERROR_BASE   (FSSH_B_GENERAL_ERROR_BASE + 0xa000)
// Developer-defined errors start at (B_ERRORS_END + 1)
#define FSSH_B_ERRORS_END   (FSSH_B_GENERAL_ERROR_BASE + 0xffff)
// General Errors
#define FSSH_B_NO_MEMORY   (FSSH_B_GENERAL_ERROR_BASE + 0)
#define FSSH_B_IO_ERROR   (FSSH_B_GENERAL_ERROR_BASE + 1)
#define FSSH_B_PERMISSION_DENIED   (FSSH_B_GENERAL_ERROR_BASE + 2)
#define FSSH_B_BAD_INDEX   (FSSH_B_GENERAL_ERROR_BASE + 3)
#define FSSH_B_BAD_TYPE   (FSSH_B_GENERAL_ERROR_BASE + 4)
#define FSSH_B_BAD_VALUE   (FSSH_B_GENERAL_ERROR_BASE + 5)
#define FSSH_B_MISMATCHED_VALUES   (FSSH_B_GENERAL_ERROR_BASE + 6)
#define FSSH_B_NAME_NOT_FOUND   (FSSH_B_GENERAL_ERROR_BASE + 7)
#define FSSH_B_NAME_IN_USE   (FSSH_B_GENERAL_ERROR_BASE + 8)
#define FSSH_B_TIMED_OUT   (FSSH_B_GENERAL_ERROR_BASE + 9)
#define FSSH_B_INTERRUPTED   (FSSH_B_GENERAL_ERROR_BASE + 10)
#define FSSH_B_WOULD_BLOCK   (FSSH_B_GENERAL_ERROR_BASE + 11)
#define FSSH_B_CANCELED   (FSSH_B_GENERAL_ERROR_BASE + 12)
#define FSSH_B_NO_INIT   (FSSH_B_GENERAL_ERROR_BASE + 13)
#define FSSH_B_BUSY   (FSSH_B_GENERAL_ERROR_BASE + 14)
#define FSSH_B_NOT_ALLOWED   (FSSH_B_GENERAL_ERROR_BASE + 15)
#define FSSH_B_BAD_DATA   (FSSH_B_GENERAL_ERROR_BASE + 16)
#define FSSH_B_DONT_DO_THAT   (FSSH_B_GENERAL_ERROR_BASE + 17)
#define FSSH_B_ERROR   (-1)
#define FSSH_B_OK   ((int)0)
#define FSSH_B_NO_ERROR   ((int)0)
// Kernel Kit Errors
#define FSSH_B_BAD_SEM_ID   (FSSH_B_OS_ERROR_BASE + 0)
#define FSSH_B_NO_MORE_SEMS   (FSSH_B_OS_ERROR_BASE + 1)
#define FSSH_B_BAD_THREAD_ID   (FSSH_B_OS_ERROR_BASE + 0x100)
#define FSSH_B_NO_MORE_THREADS   (FSSH_B_OS_ERROR_BASE + 0x101)
#define FSSH_B_BAD_THREAD_STATE   (FSSH_B_OS_ERROR_BASE + 0x102)
#define FSSH_B_BAD_TEAM_ID   (FSSH_B_OS_ERROR_BASE + 0x103)
#define FSSH_B_NO_MORE_TEAMS   (FSSH_B_OS_ERROR_BASE + 0x104)
#define FSSH_B_BAD_PORT_ID   (FSSH_B_OS_ERROR_BASE + 0x200)
#define FSSH_B_NO_MORE_PORTS   (FSSH_B_OS_ERROR_BASE + 0x201)
#define FSSH_B_BAD_IMAGE_ID   (FSSH_B_OS_ERROR_BASE + 0x300)
#define FSSH_B_BAD_ADDRESS   (FSSH_B_OS_ERROR_BASE + 0x301)
#define FSSH_B_NOT_AN_EXECUTABLE   (FSSH_B_OS_ERROR_BASE + 0x302)
#define FSSH_B_MISSING_LIBRARY   (FSSH_B_OS_ERROR_BASE + 0x303)
#define FSSH_B_MISSING_SYMBOL   (FSSH_B_OS_ERROR_BASE + 0x304)
#define FSSH_B_DEBUGGER_ALREADY_INSTALLED   (FSSH_B_OS_ERROR_BASE + 0x400)


/** Application Kit Errors */
enum FSSH_B_APP_ERR {
	FSSH_B_BAD_REPLY = FSSH_B_APP_ERROR_BASE,
	FSSH_B_DUPLICATE_REPLY,
	FSSH_B_MESSAGE_TO_SELF,
	FSSH_B_BAD_HANDLER,
	FSSH_B_ALREADY_RUNNING,
	FSSH_B_LAUNCH_FAILED,
	FSSH_B_AMBIGUOUS_APP_LAUNCH,
	FSSH_B_UNKNOWN_MIME_TYPE,
	FSSH_B_BAD_SCRIPT_SYNTAX,
	FSSH_B_LAUNCH_FAILED_NO_RESOLVE_LINK,
	FSSH_B_LAUNCH_FAILED_EXECUTABLE,
	FSSH_B_LAUNCH_FAILED_APP_NOT_FOUND,
	FSSH_B_LAUNCH_FAILED_APP_IN_TRASH,
	FSSH_B_LAUNCH_FAILED_NO_PREFERRED_APP,
	FSSH_B_LAUNCH_FAILED_FILES_APP_NOT_FOUND,
	FSSH_B_BAD_MIME_SNIFFER_RULE,
	FSSH_B_NOT_A_MESSAGE,
	FSSH_B_SHUTDOWN_CANCELLED,
	FSSH_B_SHUTTING_DOWN
};


// Storage Kit/File System Errors
#define FSSH_B_FILE_ERROR   (FSSH_B_STORAGE_ERROR_BASE + 0)
#define FSSH_B_FILE_NOT_FOUND   (FSSH_B_STORAGE_ERROR_BASE + 1)
#define FSSH_B_FILE_EXISTS   (FSSH_B_STORAGE_ERROR_BASE + 2)
#define FSSH_B_ENTRY_NOT_FOUND   (FSSH_B_STORAGE_ERROR_BASE + 3)
#define FSSH_B_NAME_TOO_LONG   (FSSH_B_STORAGE_ERROR_BASE + 4)
#define FSSH_B_NOT_A_DIRECTORY   (FSSH_B_STORAGE_ERROR_BASE + 5)
#define FSSH_B_DIRECTORY_NOT_EMPTY   (FSSH_B_STORAGE_ERROR_BASE + 6)
#define FSSH_B_DEVICE_FULL   (FSSH_B_STORAGE_ERROR_BASE + 7)
#define FSSH_B_READ_ONLY_DEVICE   (FSSH_B_STORAGE_ERROR_BASE + 8)
#define FSSH_B_IS_A_DIRECTORY   (FSSH_B_STORAGE_ERROR_BASE + 9)
#define FSSH_B_NO_MORE_FDS   (FSSH_B_STORAGE_ERROR_BASE + 10)
#define FSSH_B_CROSS_DEVICE_LINK   (FSSH_B_STORAGE_ERROR_BASE + 11)
#define FSSH_B_LINK_LIMIT   (FSSH_B_STORAGE_ERROR_BASE + 12)
#define FSSH_B_BUSTED_PIPE   (FSSH_B_STORAGE_ERROR_BASE + 13)
#define FSSH_B_UNSUPPORTED   (FSSH_B_STORAGE_ERROR_BASE + 14)
#define FSSH_B_PARTITION_TOO_SMALL   (FSSH_B_STORAGE_ERROR_BASE + 15)
#define FSSH_B_PARTIAL_READ   (FSSH_B_STORAGE_ERROR_BASE + 16)
#define FSSH_B_PARTIAL_WRITE   (FSSH_B_STORAGE_ERROR_BASE + 17)
// POSIX Errors
#define FSSH_E2BIG   (FSSH_B_POSIX_ERROR_BASE + 1)
#define FSSH_ECHILD   (FSSH_B_POSIX_ERROR_BASE + 2)
#define FSSH_EDEADLK   (FSSH_B_POSIX_ERROR_BASE + 3)
#define FSSH_EFBIG   (FSSH_B_POSIX_ERROR_BASE + 4)
#define FSSH_EMLINK   (FSSH_B_POSIX_ERROR_BASE + 5)
#define FSSH_ENFILE   (FSSH_B_POSIX_ERROR_BASE + 6)
#define FSSH_ENODEV   (FSSH_B_POSIX_ERROR_BASE + 7)
#define FSSH_ENOLCK   (FSSH_B_POSIX_ERROR_BASE + 8)
#define FSSH_ENOSYS   (FSSH_B_POSIX_ERROR_BASE + 9)
#define FSSH_ENOTTY   (FSSH_B_POSIX_ERROR_BASE + 10)
#define FSSH_ENXIO   (FSSH_B_POSIX_ERROR_BASE + 11)
#define FSSH_ESPIPE   (FSSH_B_POSIX_ERROR_BASE + 12)
#define FSSH_ESRCH   (FSSH_B_POSIX_ERROR_BASE + 13)
#define FSSH_EFPOS   (FSSH_B_POSIX_ERROR_BASE + 14)
#define FSSH_ESIGPARM   (FSSH_B_POSIX_ERROR_BASE + 15)
#define FSSH_EDOM   (FSSH_B_POSIX_ERROR_BASE + 16)
#define FSSH_ERANGE   (FSSH_B_POSIX_ERROR_BASE + 17)
#define FSSH_EPROTOTYPE   (FSSH_B_POSIX_ERROR_BASE + 18)
#define FSSH_EPROTONOSUPPORT   (FSSH_B_POSIX_ERROR_BASE + 19)
#define FSSH_EPFNOSUPPORT   (FSSH_B_POSIX_ERROR_BASE + 20)
#define FSSH_EAFNOSUPPORT   (FSSH_B_POSIX_ERROR_BASE + 21)
#define FSSH_EADDRINUSE   (FSSH_B_POSIX_ERROR_BASE + 22)
#define FSSH_EADDRNOTAVAIL   (FSSH_B_POSIX_ERROR_BASE + 23)
#define FSSH_ENETDOWN   (FSSH_B_POSIX_ERROR_BASE + 24)
#define FSSH_ENETUNREACH   (FSSH_B_POSIX_ERROR_BASE + 25)
#define FSSH_ENETRESET   (FSSH_B_POSIX_ERROR_BASE + 26)
#define FSSH_ECONNABORTED   (FSSH_B_POSIX_ERROR_BASE + 27)
#define FSSH_ECONNRESET   (FSSH_B_POSIX_ERROR_BASE + 28)
#define FSSH_EISCONN   (FSSH_B_POSIX_ERROR_BASE + 29)
#define FSSH_ENOTCONN   (FSSH_B_POSIX_ERROR_BASE + 30)
#define FSSH_ESHUTDOWN   (FSSH_B_POSIX_ERROR_BASE + 31)
#define FSSH_ECONNREFUSED   (FSSH_B_POSIX_ERROR_BASE + 32)
#define FSSH_EHOSTUNREACH   (FSSH_B_POSIX_ERROR_BASE + 33)
#define FSSH_ENOPROTOOPT   (FSSH_B_POSIX_ERROR_BASE + 34)
#define FSSH_ENOBUFS   (FSSH_B_POSIX_ERROR_BASE + 35)
#define FSSH_EINPROGRESS   (FSSH_B_POSIX_ERROR_BASE + 36)
#define FSSH_EALREADY   (FSSH_B_POSIX_ERROR_BASE + 37)
#define FSSH_EILSEQ   (FSSH_B_POSIX_ERROR_BASE + 38)
#define FSSH_ENOMSG   (FSSH_B_POSIX_ERROR_BASE + 39)
#define FSSH_ESTALE   (FSSH_B_POSIX_ERROR_BASE + 40)
#define FSSH_EOVERFLOW   (FSSH_B_POSIX_ERROR_BASE + 41)
#define FSSH_EMSGSIZE   (FSSH_B_POSIX_ERROR_BASE + 42)
#define FSSH_EOPNOTSUPP   (FSSH_B_POSIX_ERROR_BASE + 43)
#define FSSH_ENOTSOCK   (FSSH_B_POSIX_ERROR_BASE + 44)
#define FSSH_EHOSTDOWN   (FSSH_B_POSIX_ERROR_BASE + 45)
#define FSSH_EBADMSG   (FSSH_B_POSIX_ERROR_BASE + 46)
#define FSSH_ECANCELED   (FSSH_B_POSIX_ERROR_BASE + 47)
#define FSSH_EDESTADDRREQ   (FSSH_B_POSIX_ERROR_BASE + 48)
#define FSSH_EDQUOT   (FSSH_B_POSIX_ERROR_BASE + 49)
#define FSSH_EIDRM   (FSSH_B_POSIX_ERROR_BASE + 50)
#define FSSH_EMULTIHOP   (FSSH_B_POSIX_ERROR_BASE + 51)
#define FSSH_ENODATA   (FSSH_B_POSIX_ERROR_BASE + 52)
#define FSSH_ENOLINK   (FSSH_B_POSIX_ERROR_BASE + 53)
#define FSSH_ENOSR   (FSSH_B_POSIX_ERROR_BASE + 54)
#define FSSH_ENOSTR   (FSSH_B_POSIX_ERROR_BASE + 55)
#define FSSH_ENOTSUP   (FSSH_B_POSIX_ERROR_BASE + 56)
#define FSSH_EPROTO   (FSSH_B_POSIX_ERROR_BASE + 57)
#define FSSH_ETIME   (FSSH_B_POSIX_ERROR_BASE + 58)
#define FSSH_ETXTBSY   (FSSH_B_POSIX_ERROR_BASE + 59)
// POSIX errors that can be mapped to BeOS error codes
#define FSSH_ENOMEM   FSSH_B_NO_MEMORY
#define FSSH_EACCES   FSSH_B_PERMISSION_DENIED
#define FSSH_EINTR   FSSH_B_INTERRUPTED
#define FSSH_EIO   FSSH_B_IO_ERROR
#define FSSH_EBUSY   FSSH_B_BUSY
#define FSSH_EFAULT   FSSH_B_BAD_ADDRESS
#define FSSH_ETIMEDOUT   FSSH_B_TIMED_OUT
#define FSSH_EAGAIN   FSSH_B_WOULD_BLOCK  // SysV compatibility
#define FSSH_EWOULDBLOCK   FSSH_B_WOULD_BLOCK  // BSD compatibility
#define FSSH_EBADF   FSSH_B_FILE_ERROR
#define FSSH_EEXIST   FSSH_B_FILE_EXISTS
#define FSSH_EINVAL   FSSH_B_BAD_VALUE
#define FSSH_ENAMETOOLONG   FSSH_B_NAME_TOO_LONG
#define FSSH_ENOENT   FSSH_B_ENTRY_NOT_FOUND
#define FSSH_EPERM   FSSH_B_NOT_ALLOWED
#define FSSH_ENOTDIR   FSSH_B_NOT_A_DIRECTORY
#define FSSH_EISDIR   FSSH_B_IS_A_DIRECTORY
#define FSSH_ENOTEMPTY   FSSH_B_DIRECTORY_NOT_EMPTY
#define FSSH_ENOSPC   FSSH_B_DEVICE_FULL
#define FSSH_EROFS   FSSH_B_READ_ONLY_DEVICE
#define FSSH_EMFILE   FSSH_B_NO_MORE_FDS
#define FSSH_EXDEV   FSSH_B_CROSS_DEVICE_LINK
#define FSSH_ELOOP   FSSH_B_LINK_LIMIT
#define FSSH_ENOEXEC   FSSH_B_NOT_AN_EXECUTABLE
#define FSSH_EPIPE   FSSH_B_BUSTED_PIPE
// New error codes that can be mapped to POSIX errors
#define FSSH_B_BUFFER_OVERFLOW   FSSH_EOVERFLOW
#define FSSH_B_TOO_MANY_ARGS   FSSH_E2BIG
#define FSSH_B_FILE_TOO_LARGE   FSSH_EFBIG
#define FSSH_B_RESULT_NOT_REPRESENTABLE   FSSH_ERANGE
#define FSSH_B_DEVICE_NOT_FOUND   FSSH_ENODEV
#define FSSH_B_NOT_SUPPORTED   FSSH_EOPNOTSUPP


/** Media Kit Errors */
enum FSSH_B_MEDIA_ERR {
	FSSH_B_STREAM_NOT_FOUND = FSSH_B_MEDIA_ERROR_BASE,
	FSSH_B_SERVER_NOT_FOUND,
	FSSH_B_RESOURCE_NOT_FOUND,
	FSSH_B_RESOURCE_UNAVAILABLE,
	FSSH_B_BAD_SUBSCRIBER,
	FSSH_B_SUBSCRIBER_NOT_ENTERED,
	FSSH_B_BUFFER_NOT_AVAILABLE,
	FSSH_B_LAST_BUFFER_ERROR
};


/** Mail Kit Errors */
enum FSSH_B_MAIL_ERR {
	FSSH_B_MAIL_NO_DAEMON = FSSH_B_MAIL_ERROR_BASE,
	FSSH_B_MAIL_UNKNOWN_USER,
	FSSH_B_MAIL_WRONG_PASSWORD,
	FSSH_B_MAIL_UNKNOWN_HOST,
	FSSH_B_MAIL_ACCESS_ERROR,
	FSSH_B_MAIL_UNKNOWN_FIELD,
	FSSH_B_MAIL_NO_RECIPIENT,
	FSSH_B_MAIL_INVALID_MAIL
};


/** Printing Errors */
enum FSSH_B_NO_PRINT_ERR {
	FSSH_B_NO_PRINT_SERVER = FSSH_B_PRINT_ERROR_BASE
};


/** Device Kit Errors */
enum FSSH_B_DEV_ERR {
	FSSH_B_DEV_INVALID_IOCTL = FSSH_B_DEVICE_ERROR_BASE,
	FSSH_B_DEV_NO_MEMORY,
	FSSH_B_DEV_BAD_DRIVE_NUM,
	FSSH_B_DEV_NO_MEDIA,
	FSSH_B_DEV_UNREADABLE,
	FSSH_B_DEV_FORMAT_ERROR,
	FSSH_B_DEV_TIMEOUT,
	FSSH_B_DEV_RECALIBRATE_ERROR,
	FSSH_B_DEV_SEEK_ERROR,
	FSSH_B_DEV_ID_ERROR,
	FSSH_B_DEV_READ_ERROR,
	FSSH_B_DEV_WRITE_ERROR,
	FSSH_B_DEV_NOT_READY,
	FSSH_B_DEV_MEDIA_CHANGED,
	FSSH_B_DEV_MEDIA_CHANGE_REQUESTED,
	FSSH_B_DEV_RESOURCE_CONFLICT,
	FSSH_B_DEV_CONFIGURATION_ERROR,
	FSSH_B_DEV_DISABLED_BY_USER,
	FSSH_B_DEV_DOOR_OPEN,
	FSSH_B_DEV_INVALID_PIPE,
	FSSH_B_DEV_CRC_ERROR,
	FSSH_B_DEV_STALLED,
	FSSH_B_DEV_BAD_PID,
	FSSH_B_DEV_UNEXPECTED_PID,
	FSSH_B_DEV_DATA_OVERRUN,
	FSSH_B_DEV_DATA_UNDERRUN,
	FSSH_B_DEV_FIFO_OVERRUN,
	FSSH_B_DEV_FIFO_UNDERRUN,
	FSSH_B_DEV_PENDING,
	FSSH_B_DEV_MULTIPLE_ERRORS,
	FSSH_B_DEV_TOO_LATE
};


#endif  // FSSH_ERRORS_H


/* SYSTEM EXIT CODES */


#if (!(defined(SYSEXITS_H) || defined(_SYSEXITS_H) || defined(_SYSEXITS_H_)))
#define SYSEXITS_H   (1)
#define _SYSEXITS_H   (1)
#define _SYSEXITS_H_   (1)


/** Successful termination */
#define EX_OK   0
/** Base value for error messages */
#define EX__BASE   64
/** Command line usage error */
#define EX_USAGE   64
/** Data format error */
#define EX_DATAERR   65
/** Cannot open input */
#define EX_NOINPUT   66
/** Addressee unknown */
#define EX_NOUSER   67
/** Hostname unknown */
#define EX_NOHOST   68
/** Service unavailable */
#define EX_UNAVAILABLE   69
/** Internal software error */
#define EX_SOFTWARE   70
/** System error (cannot fork) */
#define EX_OSERR   71
/** Critical OS file missing */
#define EX_OSFILE   72
/** Cannot create (user) output file */
#define EX_CANTCREAT   73
/** I/O error */
#define EX_IOERR   74
/** Temporary failure; user is invited to retry */
#define EX_TEMPFAIL   75
/** Remote error in protocol */
#define EX_PROTOCOL   76
/** Permission denied */
#define EX_NOPERM   77
/** Configuration error */
#define EX_CONFIG   78
/** Maximum listed value */
#define EX__MAX   78


#endif  // SYSEXITS_H


/* SYSTEM CALLS */


#if (!(defined(_SYSCALL_H) || defined(_SYSCALL_H_) || defined(_INTERNAL_SYSCALL_H) || defined(_INTERNAL_SYSCALL_H_) || defined(_SYS_SYSCALL_H) || defined(_SYS_SYSCALL_H_) || defined(_SYSCALLS_COMMON_H) || defined(_SYSCALLS_COMMON_H_)))
#define _SYSCALL_H   (1)
#define _SYSCALL_H_   (1)
#define _SYS_SYSCALL_H   (1)
#define _SYS_SYSCALL_H_   (1)
#define _INTERNAL_SYSCALL_H   (1)
#define _INTERNAL_SYSCALL_H_   (1)
#define _SYSCALLS_COMMON_H   (1)
#define _SYSCALLS_COMMON_H_   (1)


/** System call argument datatype */
typedef long   syscall_arg_t;
#ifndef SYSCALL_RLIM_INFINITY
#   ifdef MIPS
#      define SYSCALL_RLIM_INFINITY   (-1UL / 2)
#   else
#      define SYSCALL_RLIM_INFINITY   ((unsigned long long)(~0ULL))
#   endif
#endif
#ifndef SYSCALL_MMAP2_UNIT
#   define SYSCALL_MMAP2_UNIT   (4096ULL)
#endif
#ifndef __scc
#   define __scc(x)   ((long)(x))
#endif
#ifndef SYS_ify
#   define SYS_ify(syscall_name)   (__NR_##syscall_name)
#endif
#ifndef INTERNAL_SYSCALL_DECL
#   define INTERNAL_SYSCALL_DECL(err)   do {} while (0x0)
#endif
#ifndef INTERNAL_SYSCALL_ERROR_P
#   define INTERNAL_SYSCALL_ERROR_P(val, err)   (((unsigned long)(val)) >= (unsigned long)(-4095))
#endif
#ifndef INTERNAL_SYSCALL_ERRNO
#   define INTERNAL_SYSCALL_ERRNO(val, err)   (-(val))
#endif


#ifdef OSLINUX
LIB_FUNC long __syscall_ret(const unsigned long r);
LIB_FUNC long syscall(const long n, ...);
#endif


#if ((!(defined(_BITS_SYSCALLS_H) || defined(_BITS_SYSCALLS_H_))) && IS_NOT_ASSEMBLER)
#define _BITS_SYSCALLS_H  (1)
#define _BITS_SYSCALLS_H_  (1)


#if (defined(OSUNIX) && (defined(X86_64) || defined(X86) || defined(I386)))  // Unix X86


#define __SYSCALL_LL_E(x)   (x)
#define __SYSCALL_LL_O(x)   (x)
#define DO_CALL(syscall_name, args)   DOARGS_##args movq $__NR_##syscall_name, %rax; syscall;
#define DOARGS_0
#define DOARGS_1
#define DOARGS_2
#define DOARGS_3
#define DOARGS_4   movq %rcx, %r10;
#define DOARGS_5   DOARGS_4
#define DOARGS_6   DOARGS_4
#define LOAD_ARGS_0()
#define LOAD_REGS_0
#define ASM_ARGS_0
#define LOAD_ARGS_1(a1)   long __arg1 = (long)(a1); LOAD_ARGS_0()
#define LOAD_REGS_1   register long __a1 asm ("rdi") = __arg1; LOAD_REGS_0
#define ASM_ARGS_1   ASM_ARGS_0, "r"(__a1)
#define LOAD_ARGS_2(a1, a2)   long __arg2 = (long)(a2); LOAD_ARGS_1(a1)
#define LOAD_REGS_2   register long __a2 asm ("rsi") = __arg2; LOAD_REGS_1
#define ASM_ARGS_2   ASM_ARGS_1, "r"(__a2)
#define LOAD_ARGS_3(a1, a2, a3)   long __arg3 = (long)(a3); LOAD_ARGS_2(a1, a2)
#define LOAD_REGS_3   register long __a3 asm ("rdx") = __arg3; LOAD_REGS_2
#define ASM_ARGS_3   ASM_ARGS_2, "r"(__a3)
#define LOAD_ARGS_4(a1, a2, a3, a4)   long __arg4 = (long)(a4); LOAD_ARGS_3(a1, a2, a3)
#define LOAD_REGS_4   register long __a4 asm ("r10") = __arg4; LOAD_REGS_3
#define ASM_ARGS_4   ASM_ARGS_3, "r"(__a4)
#define LOAD_ARGS_5(a1, a2, a3, a4, a5)   long __arg5 = (long)(a5); LOAD_ARGS_4(a1, a2, a3, a4)
#define LOAD_REGS_5   register long __a5 asm ("r8") = __arg5; LOAD_REGS_4
#define ASM_ARGS_5   ASM_ARGS_4, "r"(__a5)
#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)   long __arg6 = (long)(a6); LOAD_ARGS_5(a1, a2, a3, a4, a5)
#define LOAD_REGS_6   register long __a6 asm ("r9") = __arg6; LOAD_REGS_5
#define ASM_ARGS_6   ASM_ARGS_5, "r"(__a6)
/** Define a macro which expands inline into the wrapper code for a system call */
#define INTERNAL_SYSCALL_NCS(name, err, nr, ...)   (__extension__ ({ unsigned long resultvar; LOAD_ARGS_##nr (__VA_ARGS__) LOAD_REGS_##nr asm volatile ("syscall;" : "=a"(resultvar) : "0"(name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx"); (long)resultvar; }))


LIB_FUNC unsigned long __syscall0(const long n) {
	unsigned long ret;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall1(const long n, const long a1) {
	unsigned long ret;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall2(const long n, const long a1, const long a2) {
	unsigned long ret;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2) : "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall3(const long n, const long a1, const long a2, const long a3) {
	unsigned long ret;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3) : "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall4(const long n, const long a1, const long a2, const long a3, const long a4) {
	unsigned long ret;
	register long r10 asm ("r10") = a4;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10): "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall5(const long n, const long a1, const long a2, const long a3, const long a4, const long a5) {
	unsigned long ret;
	register long r10 asm ("r10") = a4;
	register long r8 asm ("r8") = a5;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
	return ret;
}


LIB_FUNC unsigned long __syscall6(const long n, const long a1, const long a2, const long a3, const long a4, const long a5, const long a6) {
	unsigned long ret;
	register long r10 asm ("r10") = a4;
	register long r8 asm ("r8") = a5;
	register long r9 asm ("r9") = a6;
	asm volatile ("syscall;" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
	return ret;
}


#define __syscall_return(type, res)   do { if ((unsigned long)(res) >= (unsigned long)(-125)) { errno = -(res); res = -1; } return (type)(res); } while (0x0)
#define __inline_syscall0(name, ret)   asm volatile ("int $0x80;" : "=a"(ret) : "0"(__NR_##name));
#define __inline_syscall1(name, ret, arg1)   asm volatile ("push %%ebx;" "movl %2, %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name), "r"((long)(arg1)));
#define __inline_syscall2(name, ret, arg1, arg2)   asm volatile ("push %%ebx;" "movl %2, %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name), "r"((long)(arg1)), "c"((long)(arg2)));
#define __inline_syscall3(name, ret, arg1, arg2, arg3)   asm volatile ("push %%ebx;" "movl %2, %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name), "r"((long)(arg1)), "c"((long)(arg2)), "d"((long)(arg3)));
#define __inline_syscall4(name, ret, arg1, arg2, arg3, arg4)   asm volatile ("push %%ebx;" "movl %2, %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name), "r"((long)(arg1)), "c"((long)(arg2)), "d"((long)(arg3)), "S"((long)(arg4)));
#define __inline_syscall5(name, ret, arg1, arg2, arg3, arg4, arg5)   asm volatile ("push %%ebx;" "movl %2, %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name), "m"((long)(arg1)), "c"((long)(arg2)), "d"((long)(arg3)), "S"((long)(arg4)), "D"((long)(arg5)));
#define __inline_syscall6(name, ret, arg1, arg2, arg3, arg4, arg5, arg6)   asm volatile ("push %%ebx;" "lea 8(%%ebp), %%ebx;" "int $0x80;" "pop %%ebx;" : "=a"(ret) : "0"(__NR_##name));
#define _syscall0_base(type, name)   type __libc_##name (void) { long __res; __inline_syscall0(name, __res) __syscall_return(type, __res); }
#define _syscall1_base(type, name, type1, arg1)   type __libc_##name (type1 arg1)   { long __res; __inline_syscall1(name, __res, arg1) __syscall_return(type, __res); }
#define _syscall2_base(type, name, type1, arg1, type2, arg2)   type __libc_##name (type1 arg1, type2 arg2) { long __res; __inline_syscall2(name, __res, arg1, arg2) __syscall_return(type, __res); }
#define _syscall3_base(type, name, type1, arg1, type2, arg2, type3, arg3)   type __libc_##name (type1 arg1, type2 arg2, type3 arg3) { long __res; __inline_syscall3(name, __res, arg1, arg2, arg3) __syscall_return(type, __res); }
#define _syscall4_base(type, name, type1, arg1, type2, arg2, type3, arg3, type4, arg4)   type __libc_##name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) { long __res; __inline_syscall4(name, __res, arg1, arg2, arg3, arg4) __syscall_return(type, __res); }
#define _syscall5_base(type, name, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5)   type __libc_##name (type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5) { long __res; __inline_syscall5(name, __res, arg1, arg2, arg3, arg4, arg5) __syscall_return(type, __res); }
#define _syscall6_base(type, name, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5, type6, arg6)   type __libc_##name (type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5, type6 arg6) { long __res; __inline_syscall6(name, __res, arg1, arg2, arg3, arg4, arg5, arg6) __syscall_return(type, __res); }


#elif (defined(OSUNIX) && defined(ARM64))  // Unix ARM64


#define __SYSCALL_LL_E(x)   (x)
#define __SYSCALL_LL_O(x)   (x)
#define __asm_syscall(...)   do { asm volatile ("svc 0;" : "=r"(x0) : __VA_ARGS__ : "memory", "cc"); return x0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0");
	__asm_syscall("r"(x8));
}


LIB_FUNC long __syscall1(const long n, const long a) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	__asm_syscall("r"(x8), "0"(x0));
}


LIB_FUNC long __syscall2(const long n, const long a, const long b) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register long x1 asm ("x1") = b;
	__asm_syscall("r"(x8), "0"(x0), "r"(x1));
}


LIB_FUNC long __syscall3(const long n, const long a, const long b, const long c) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register long x1 asm ("x1") = b;
	register long x2 asm ("x2") = c;
	__asm_syscall("r"(x8), "0"(x0), "r"(x1), "r"(x2));
}


LIB_FUNC long __syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register long x1 asm ("x1") = b;
	register long x2 asm ("x2") = c;
	register long x3 asm ("x3") = d;
	__asm_syscall("r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3));
}


LIB_FUNC long __syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register long x1 asm ("x1") = b;
	register long x2 asm ("x2") = c;
	register long x3 asm ("x3") = d;
	register long x4 asm ("x4") = e;
	__asm_syscall("r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4));
}


LIB_FUNC long __syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long x8 asm ("x8") = n;
	register long x0 asm ("x0") = a;
	register long x1 asm ("x1") = b;
	register long x2 asm ("x2") = c;
	register long x3 asm ("x3") = d;
	register long x4 asm ("x4") = e;
	register long x5 asm ("x5") = f;
	__asm_syscall("r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4), "r"(x5));
}


#elif (defined(OSUNIX) && defined(ARM))  // Unix ARM (EABI)


#define __SYSCALL_LL_E(x)   ((union { long long ll; long l[2]; }){ .ll = x }).l[0], ((union { long long ll; long l[2]; }){ .ll = x }).l[1]
#define __SYSCALL_LL_O(x)   0, __SYSCALL_LL_E((x))
#define __asm_syscall(...)   do { asm volatile ("swi 0;" : "=r"(r0) : __VA_ARGS__ : "memory"); return r0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0");
	__asm_syscall("r"(r7));
}


LIB_FUNC long __syscall1(const long n, const long a) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	__asm_syscall("r"(r7), "0"(r0));
}


LIB_FUNC long __syscall2(const long n, const long a, const long b) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register long r1 asm ("r1") = b;
	__asm_syscall("r"(r7), "0"(r0), "r"(r1));
}


LIB_FUNC long __syscall3(const long n, const long a, const long b, const long c) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register long r1 asm ("r1") = b;
	register long r2 asm ("r2") = c;
	__asm_syscall("r"(r7), "0"(r0), "r"(r1), "r"(r2));
}


LIB_FUNC long __syscall4(const long n, const long a, const long b, const long c, const long d) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register long r1 asm ("r1") = b;
	register long r2 asm ("r2") = c;
	register long r3 asm ("r3") = d;
	__asm_syscall("r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3));
}


LIB_FUNC long __syscall5(const long n, const long a, const long b, const long c, const long d, const long e) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register long r1 asm ("r1") = b;
	register long r2 asm ("r2") = c;
	register long r3 asm ("r3") = d;
	register long r4 asm ("r4") = e;
	__asm_syscall("r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4));
}


LIB_FUNC long __syscall6(const long n, const long a, const long b, const long c, const long d, const long e, const long f) {
	register long r7 asm ("r7") = n;
	register long r0 asm ("r0") = a;
	register long r1 asm ("r1") = b;
	register long r2 asm ("r2") = c;
	register long r3 asm ("r3") = d;
	register long r4 asm ("r4") = e;
	register long r5 asm ("r5") = f;
	__asm_syscall("r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5));
}


#elif (defined(OSUNIX) && defined(ALPHA))  // Unix Alpha


#define __asm_syscall(...)   do { asm volatile ("callsys;" : "=r"(a0) : __VA_ARGS__ : "memory"); return a0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long v0 asm ("v0") = n;
	register long a0 asm ("a0");
	__asm_syscall("r"(v0));
}


#elif (defined(OSUNIX) && defined(ARC))  // Unix Arc


#define __asm_syscall(...)   do { asm volatile ("trap 0;" : "=r"(r0) : __VA_ARGS__ : "memory"); return r0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long r8 asm ("r8") = n;
	register long r0 asm ("r0");
	__asm_syscall("r"(r8));
}


#elif (defined(OSUNIX) && defined(BLACKFIN))  // Unix Blackfin


#define __asm_syscall(...)   do { asm volatile ("excpt 0;" : "=r"(R0) : __VA_ARGS__ : "memory"); return R0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long P0 asm ("P0") = n;
	register long R0 asm ("R0");
	__asm_syscall("r"(P0));
}


#elif (defined(OSUNIX) && defined(M68K))  // Unix M68K


#define __asm_syscall(...)   do { asm volatile ("trap 0;" : "=r"(d0) : __VA_ARGS__ : "memory"); return d0; } while (0x0)


LIB_FUNC long __syscall0(const long n) {
	register long d0 asm ("d0") = n;
	__asm_syscall("r"(d0));
}


#else


#   error   "Add syscall support for the target system."


#endif  // ARCH


#endif  // BITS_SYSCALLS_H


#ifndef _syscall0
#   define C_DECL_ARGS_0()   void
#   define C_DECL_ARGS_1(t, v)   t v
#   define C_DECL_ARGS_2(t, v, ...)   t v, C_DECL_ARGS_1(__VA_ARGS__)
#   define C_DECL_ARGS_3(t, v, ...)   t v, C_DECL_ARGS_2(__VA_ARGS__)
#   define C_DECL_ARGS_4(t, v, ...)   t v, C_DECL_ARGS_3(__VA_ARGS__)
#   define C_DECL_ARGS_5(t, v, ...)   t v, C_DECL_ARGS_4(__VA_ARGS__)
#   define C_DECL_ARGS_6(t, v, ...)   t v, C_DECL_ARGS_5(__VA_ARGS__)
#   define C_ARGS_0()
#   define C_ARGS_1(t, v)   v
#   define C_ARGS_2(t, v, ...)   v, C_ARGS_1(__VA_ARGS__)
#   define C_ARGS_3(t, v, ...)   v, C_ARGS_2(__VA_ARGS__)
#   define C_ARGS_4(t, v, ...)   v, C_ARGS_3(__VA_ARGS__)
#   define C_ARGS_5(t, v, ...)   v, C_ARGS_4(__VA_ARGS__)
#   define C_ARGS_6(t, v, ...)   v, C_ARGS_5(__VA_ARGS__)
#   define SYSCALL_FUNC(nargs, type, name, ...)   LIB_FUNC type name(C_DECL_ARGS_##nargs(__VA_ARGS__)) { return (type)syscall(SYS_##name, nargs, C_ARGS_##nargs(__VA_ARGS__)); }
#   define _syscall0(...)   SYSCALL_FUNC(0, __VA_ARGS__)
#   define _syscall1(...)   SYSCALL_FUNC(1, __VA_ARGS__)
#   define _syscall2(...)   SYSCALL_FUNC(2, __VA_ARGS__)
#   define _syscall3(...)   SYSCALL_FUNC(3, __VA_ARGS__)
#   define _syscall4(...)   SYSCALL_FUNC(4, __VA_ARGS__)
#   define _syscall5(...)   SYSCALL_FUNC(5, __VA_ARGS__)
#   define _syscall6(...)   SYSCALL_FUNC(6, __VA_ARGS__)
#endif  // _syscall0
#define __SYSCALL_NARGS_X(a, b, c, d, e, f, g, h, n, ...)   n
#define __SYSCALL_NARGS(...)   __SYSCALL_NARGS_X(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0, )
#define __SYSCALL_CONCAT_X(a, b)   a##b
#define __SYSCALL_CONCAT(a, b)   __SYSCALL_CONCAT_X(a, b)
#define __SYSCALL_DISP(b, ...)   __SYSCALL_CONCAT(b, __SYSCALL_NARGS(__VA_ARGS__)) (__VA_ARGS__)
#define __syscall(...)   __SYSCALL_DISP(__syscall, __VA_ARGS__)
#define __syscall_cp(...)   __SYSCALL_DISP(__syscall_cp, __VA_ARGS__)
#define syscall_cp(...)   __syscall_ret(__syscall_cp(__VA_ARGS__))
#define __syscall_cp0(n)   (__syscall_cp)(n, 0, 0, 0, 0, 0, 0)
#define __syscall_cp1(n, a)   (__syscall_cp)(n, __scc(a), 0, 0, 0, 0, 0)
#define __syscall_cp2(n, a, b)   (__syscall_cp)(n, __scc(a), __scc(b), 0, 0, 0, 0)
#define __syscall_cp3(n, a, b, c)   (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), 0, 0, 0)
#define __syscall_cp4(n, a, b, c, d)   (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), 0, 0)
#define __syscall_cp5(n, a, b, c, d, e)   (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), 0)
#define __syscall_cp6(n, a, b, c, d, e, f)   (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), __scc(f))
#define __syscall_cp7(n, a, b, c, d, e, f, g)   (__syscall_cp)(n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), __scc(f), __scc(g))
#define __syscall7(n, a, b, c, d, e, f, g)   (__syscall)(n, __scc(a), __scc(b), __scc(c), __scc(d), __scc(e), __scc(f), __scc(g))
#ifdef SYS_open
#   define __sys_open(...)   syscall(SYS_open, __VA_ARGS__)
#   define sys_open(...)   syscall(SYS_open, __VA_ARGS__)
#   define __sys_open_cp(...)   syscall(SYS_open, __VA_ARGS__)
#   define sys_open_cp(...)   syscall(SYS_open, __VA_ARGS__)
#   define __sys_open2(x, pn, _fl)   syscall(SYS_open, pn, ((_fl) | O_LARGEFILE))
#   define __sys_open3(x, pn, _fl, mo)   syscall(SYS_open, pn, ((_fl) | O_LARGEFILE), mo)
#   define __sys_open_cp2(x, pn, _fl)   syscall(SYS_open, pn, ((_fl) | O_LARGEFILE))
#   define __sys_open_cp3(x, pn, _fl, mo)   syscall(SYS_open, pn, ((_fl) | O_LARGEFILE), mo)
#else
#   define __sys_open(...)   syscall(SYS_openat, __VA_ARGS__)
#   define sys_open(...)   syscall(SYS_openat, __VA_ARGS__)
#   define __sys_open_cp(...)   syscall(SYS_openat, __VA_ARGS__)
#   define sys_open_cp(...)   syscall(SYS_openat, __VA_ARGS__)
#   define __sys_open2(x, pn, _fl)   syscall(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE))
#   define __sys_open3(x, pn, _fl, mo)   syscall(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE), mo)
#   define __sys_open_cp2(x, pn, _fl)   syscall(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE))
#   define __sys_open_cp3(x, pn, _fl, mo)   syscall(SYS_openat, AT_FDCWD, pn, ((_fl) | O_LARGEFILE), mo)
#endif  // SYS_open
#ifndef SYSCALL_USE_SOCKETCALL
#   define __socketcall(nm, a, b, c, d, e, f)   syscall(SYS_##nm, a, b, c, d, e, f)
#   define __socketcall_cp(nm, a, b, c, d, e, f)   syscall_cp(SYS_##nm, a, b, c, d, e, f)
#   define socketcall(nm, a, b, c, d, e, f)   syscall(SYS_##nm, a, b, c, d, e, f)
#   define socketcall_cp(nm, a, b, c, d, e, f)   syscall_cp(SYS_##nm, a, b, c, d, e, f)
#else
#   define __socketcall(nm, a, b, c, d, e, f)   syscall(SYS_socketcall, __SC_##nm, ((long [6]) { (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
#   define __socketcall_cp(nm, a, b, c, d, e, f)   syscall_cp(SYS_socketcall, __SC_##nm, ((long [6]) { (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
#   define socketcall(nm, a, b, c, d, e, f)   syscall(SYS_socketcall, __SC_##nm, ((long [6]) { (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
#   define socketcall_cp(nm, a, b, c, d, e, f)   syscall_cp(SYS_socketcall, __SC_##nm, ((long [6]) { (long)a, (long)b, (long)c, (long)d, (long)e, (long)f }))
#endif  // SYSCALL_USE_SOCKETCALL


// SYSTEM CALLS

#if (defined(OSLINUX) && defined(MIPS))


#define __NR_syscall   4000
#define __NR_exit   4001
#define __NR_fork   4002
#define __NR_read   4003
#define __NR_write   4004
#define __NR_open   4005
#define __NR_close   4006
#define __NR_waitpid   4007
#define __NR_creat   4008
#define __NR_link   4009
#define __NR_unlink   4010
#define __NR_execve   4011
#define __NR_chdir   4012
#define __NR_time   4013
#define __NR_mknod   4014
#define __NR_chmod   4015
#define __NR_lchown   4016
#define __NR_break   4017
#define __NR_unused18   4018
#define __NR_lseek   4019
#define __NR_getpid   4020
#define __NR_mount   4021
#define __NR_umount   4022
#define __NR_setuid   4023
#define __NR_getuid   4024
#define __NR_stime   4025
#define __NR_ptrace   4026
#define __NR_alarm   4027
#define __NR_unused28   4028
#define __NR_pause   4029
#define __NR_utime   4030
#define __NR_stty   4031
#define __NR_gtty   4032
#define __NR_access   4033
#define __NR_nice   4034
#define __NR_ftime   4035
#define __NR_sync   4036
#define __NR_kill   4037
#define __NR_rename   4038
#define __NR_mkdir   4039
#define __NR_rmdir   4040
#define __NR_dup   4041
#define __NR_pipe   4042
#define __NR_times   4043
#define __NR_prof   4044
#define __NR_brk   4045
#define __NR_setgid   4046
#define __NR_getgid   4047
#define __NR_signal   4048
#define __NR_geteuid   4049
#define __NR_getegid   4050
#define __NR_acct   4051
#define __NR_umount2   4052
#define __NR_lock   4053
#define __NR_ioctl   4054
#define __NR_fcntl   4055
#define __NR_mpx   4056
#define __NR_setpgid   4057
#define __NR_ulimit   4058
#define __NR_unused59   4059
#define __NR_umask   4060
#define __NR_chroot   4061
#define __NR_ustat   4062
#define __NR_dup2   4063
#define __NR_getppid   4064
#define __NR_getpgrp   4065
#define __NR_setsid   4066
#define __NR_sigaction   4067
#define __NR_sgetmask   4068
#define __NR_ssetmask   4069
#define __NR_setreuid   4070
#define __NR_setregid   4071
#define __NR_sigsuspend   4072
#define __NR_sigpending   4073
#define __NR_sethostname   4074
#define __NR_setrlimit   4075
#define __NR_getrlimit   4076
#define __NR_getrusage   4077
#define __NR_gettimeofday   4078
#define __NR_settimeofday   4079
#define __NR_getgroups   4080
#define __NR_setgroups   4081
#define __NR_reserved82   4082
#define __NR_symlink   4083
#define __NR_unused84   4084
#define __NR_readlink   4085
#define __NR_uselib   4086
#define __NR_swapon   4087
#define __NR_reboot   4088
#define __NR_readdir   4089
#define __NR_mmap   4090
#define __NR_munmap   4091
#define __NR_truncate   4092
#define __NR_ftruncate   4093
#define __NR_fchmod   4094
#define __NR_fchown   4095
#define __NR_getpriority   4096
#define __NR_setpriority   4097
#define __NR_profil   4098
#define __NR_statfs   4099
#define __NR_fstatfs   4100
#define __NR_ioperm   4101
#define __NR_socketcall   4102
#define __NR_syslog   4103
#define __NR_setitimer   4104
#define __NR_getitimer   4105
#define __NR_stat   4106
#define __NR_lstat   4107
#define __NR_fstat   4108
#define __NR_unused109   4109
#define __NR_iopl   4110
#define __NR_vhangup   4111
#define __NR_idle   4112
#define __NR_vm86   4113
#define __NR_wait4   4114
#define __NR_swapoff   4115
#define __NR_sysinfo   4116
#define __NR_ipc   4117
#define __NR_fsync   4118
#define __NR_sigreturn   4119
#define __NR_clone   4120
#define __NR_setdomainname   4121
#define __NR_uname   4122
#define __NR_modify_ldt   4123
#define __NR_adjtimex   4124
#define __NR_mprotect   4125
#define __NR_sigprocmask   4126
#define __NR_create_module   4127
#define __NR_init_module   4128
#define __NR_delete_module   4129
#define __NR_get_kernel_syms   4130
#define __NR_quotactl   4131
#define __NR_getpgid   4132
#define __NR_fchdir   4133
#define __NR_bdflush   4134
#define __NR_sysfs   4135
#define __NR_personality   4136
#define __NR_afs_syscall   4137
#define __NR_setfsuid   4138
#define __NR_setfsgid   4139
#define __NR__llseek   4140
#define __NR_getdents   4141
#define __NR_select   4142
#define __NR_flock   4143
#define __NR_msync   4144
#define __NR_readv   4145
#define __NR_writev   4146
#define __NR_cacheflush   4147
#define __NR_cachectl   4148
#define __NR_sysmips   4149
#define __NR_unused150   4150
#define __NR_getsid   4151
#define __NR_fdatasync   4152
#define __NR__sysctl   4153
#define __NR_mlock   4154
#define __NR_munlock   4155
#define __NR_mlockall   4156
#define __NR_munlockall   4157
#define __NR_sched_setparam   4158
#define __NR_sched_getparam   4159
#define __NR_sched_setscheduler   4160
#define __NR_sched_getscheduler   4161
#define __NR_sched_yield   4162
#define __NR_sched_get_priority_max  4163
#define __NR_sched_get_priority_min  4164
#define __NR_sched_rr_get_interval   4165
#define __NR_nanosleep   4166
#define __NR_mremap   4167
#define __NR_accept   4168
#define __NR_bind   4169
#define __NR_connect   4170
#define __NR_getpeername   4171
#define __NR_getsockname   4172
#define __NR_getsockopt   4173
#define __NR_listen   4174
#define __NR_recv   4175
#define __NR_recvfrom   4176
#define __NR_recvmsg   4177
#define __NR_send   4178
#define __NR_sendmsg   4179
#define __NR_sendto   4180
#define __NR_setsockopt   4181
#define __NR_shutdown   4182
#define __NR_socket   4183
#define __NR_socketpair   4184
#define __NR_setresuid   4185
#define __NR_getresuid   4186
#define __NR_query_module   4187
#define __NR_poll   4188
#define __NR_nfsservctl   4189
#define __NR_setresgid   4190
#define __NR_getresgid   4191
#define __NR_prctl   4192
#define __NR_rt_sigreturn   4193
#define __NR_rt_sigaction   4194
#define __NR_rt_sigprocmask   4195
#define __NR_rt_sigpending   4196
#define __NR_rt_sigtimedwait   4197
#define __NR_rt_sigqueueinfo   4198
#define __NR_rt_sigsuspend   4199
#define __NR_pread   4200
#define __NR_pwrite   4201
#define __NR_chown   4202
#define __NR_getcwd   4203
#define __NR_capget   4204
#define __NR_capset   4205
#define __NR_sigaltstack   4206
#define __NR_sendfile   4207
#define __NR_getpmsg   4208
#define __NR_putpmsg   4209
#define __NR_mmap2   4210
#define __NR_truncate64   4211
#define __NR_ftruncate64   4212
#define __NR_stat64   4213
#define __NR_lstat64   4214
#define __NR_fstat64   4215
#define __NR_pivot_root   4216
#define __NR_mincore   4217
#define __NR_madvise   4218
#define __NR_getdents64   4219
#define __NR_fcntl64   4220
#define __NR_reserved221   4221
#define __NR_gettid   4222
#define __NR_readahead   4223
#define __NR_setxattr   4224
#define __NR_lsetxattr   4225
#define __NR_fsetxattr   4226
#define __NR_getxattr   4227
#define __NR_lgetxattr   4228
#define __NR_fgetxattr   4229
#define __NR_listxattr   4230
#define __NR_llistxattr   4231
#define __NR_flistxattr   4232
#define __NR_removexattr   4233
#define __NR_lremovexattr   4234
#define __NR_fremovexattr   4235
#define __NR_tkill   4236
#define __NR_sendfile64   4237
#define __NR_futex   4238
#define __NR_sched_setaffinity   4239
#define __NR_sched_getaffinity   4240
#define __NR_io_setup   4241
#define __NR_io_destroy   4242
#define __NR_io_getevents   4243
#define __NR_io_submit   4244
#define __NR_io_cancel   4245
#define __NR_exit_group   4246
#define __NR_lookup_dcookie   4247
#define __NR_epoll_create   4248
#define __NR_epoll_ctl   4249
#define __NR_epoll_wait   4250
#define __NR_remap_file_pages   4251
#define __NR_set_tid_address   4252
#define __NR_restart_syscall   4253
#define __NR_fadvise   4254
#define __NR_statfs64   4255
#define __NR_fstatfs64   4256
#define __NR_timer_create   4257
#define __NR_timer_settime   4258
#define __NR_timer_gettime   4259
#define __NR_timer_getoverrun   4260
#define __NR_timer_delete   4261
#define __NR_clock_settime   4262
#define __NR_clock_gettime   4263
#define __NR_clock_getres   4264
#define __NR_clock_nanosleep   4265
#define __NR_tgkill   4266
#define __NR_utimes   4267
#define __NR_mbind   4268
#define __NR_get_mempolicy   4269
#define __NR_set_mempolicy   4270
#define __NR_mq_open   4271
#define __NR_mq_unlink   4272
#define __NR_mq_timedsend   4273
#define __NR_mq_timedreceive   4274
#define __NR_mq_notify   4275
#define __NR_mq_getsetattr   4276
#define __NR_vserver   4277
#define __NR_waitid   4278
#define __NR_add_key   4280
#define __NR_request_key   4281
#define __NR_keyctl   4282
#define __NR_set_thread_area   4283
#define __NR_inotify_init   4284
#define __NR_inotify_add_watch   4285
#define __NR_inotify_rm_watch   4286
#define __NR_migrate_pages   4287
#define __NR_openat   4288
#define __NR_mkdirat   4289
#define __NR_mknodat   4290
#define __NR_fchownat   4291
#define __NR_futimesat   4292
#define __NR_fstatat   4293
#define __NR_unlinkat   4294
#define __NR_renameat   4295
#define __NR_linkat   4296
#define __NR_symlinkat   4297
#define __NR_readlinkat   4298
#define __NR_fchmodat   4299
#define __NR_faccessat   4300
#define __NR_pselect6   4301
#define __NR_ppoll   4302
#define __NR_unshare   4303
#define __NR_splice   4304
#define __NR_sync_file_range   4305
#define __NR_tee   4306
#define __NR_vmsplice   4307
#define __NR_move_pages   4308
#define __NR_set_robust_list   4309
#define __NR_get_robust_list   4310
#define __NR_kexec_load   4311
#define __NR_getcpu   4312
#define __NR_epoll_pwait   4313
#define __NR_ioprio_set   4314
#define __NR_ioprio_get   4315
#define __NR_utimensat   4316
#define __NR_signalfd   4317
#define __NR_timerfd   4318
#define __NR_eventfd   4319
#define __NR_fallocate   4320
#define __NR_timerfd_create   4321
#define __NR_timerfd_gettime   4322
#define __NR_timerfd_settime   4323
#define __NR_signalfd4   4324
#define __NR_eventfd2   4325
#define __NR_epoll_create1   4326
#define __NR_dup3   4327
#define __NR_pipe2   4328
#define __NR_inotify_init1   4329
#define __NR_preadv   4330
#define __NR_pwritev   4331
#define __NR_rt_tgsigqueueinfo   4332
#define __NR_perf_event_open   4333
#define __NR_accept4   4334
#define __NR_recvmmsg   4335
#define __NR_fanotify_init   4336
#define __NR_fanotify_mark   4337
#define __NR_prlimit64   4338
#define __NR_name_to_handle_at   4339
#define __NR_open_by_handle_at   4340
#define __NR_clock_adjtime   4341
#define __NR_syncfs   4342
#define __NR_sendmmsg   4343
#define __NR_setns   4344
#define __NR_process_vm_readv   4345
#define __NR_process_vm_writev   4346
#define __NR_kcmp   4347
#define __NR_finit_module   4348
#define __NR_sched_setattr   4349
#define __NR_sched_getattr   4350
#define __NR_renameat2   4351
#define __NR_seccomp   4352
#define __NR_getrandom   4353
#define __NR_memfd_create   4354
#define __NR_bpf   4355
#define __NR_execveat   4356
#define __NR_userfaultfd   4357
#define __NR_membarrier   4358
#define __NR_mlock2   4359
// Repeated with SYS_ prefix
#define SYS_syscall   4000
#define SYS_exit   4001
#define SYS_fork   4002
#define SYS_read   4003
#define SYS_write   4004
#define SYS_open   4005
#define SYS_close   4006
#define SYS_waitpid   4007
#define SYS_creat   4008
#define SYS_link   4009
#define SYS_unlink   4010
#define SYS_execve   4011
#define SYS_chdir   4012
#define SYS_time   4013
#define SYS_mknod   4014
#define SYS_chmod   4015
#define SYS_lchown   4016
#define SYS_break   4017
#define SYS_unused18   4018
#define SYS_lseek   4019
#define SYS_getpid   4020
#define SYS_mount   4021
#define SYS_umount   4022
#define SYS_setuid   4023
#define SYS_getuid   4024
#define SYS_stime   4025
#define SYS_ptrace   4026
#define SYS_alarm   4027
#define SYS_unused28   4028
#define SYS_pause   4029
#define SYS_utime   4030
#define SYS_stty   4031
#define SYS_gtty   4032
#define SYS_access   4033
#define SYS_nice   4034
#define SYS_ftime   4035
#define SYS_sync   4036
#define SYS_kill   4037
#define SYS_rename   4038
#define SYS_mkdir   4039
#define SYS_rmdir   4040
#define SYS_dup   4041
#define SYS_pipe   4042
#define SYS_times   4043
#define SYS_prof   4044
#define SYS_brk   4045
#define SYS_setgid   4046
#define SYS_getgid   4047
#define SYS_signal   4048
#define SYS_geteuid   4049
#define SYS_getegid   4050
#define SYS_acct   4051
#define SYS_umount2   4052
#define SYS_lock   4053
#define SYS_ioctl   4054
#define SYS_fcntl   4055
#define SYS_mpx   4056
#define SYS_setpgid   4057
#define SYS_ulimit   4058
#define SYS_unused59   4059
#define SYS_umask   4060
#define SYS_chroot   4061
#define SYS_ustat   4062
#define SYS_dup2   4063
#define SYS_getppid   4064
#define SYS_getpgrp   4065
#define SYS_setsid   4066
#define SYS_sigaction   4067
#define SYS_sgetmask   4068
#define SYS_ssetmask   4069
#define SYS_setreuid   4070
#define SYS_setregid   4071
#define SYS_sigsuspend   4072
#define SYS_sigpending   4073
#define SYS_sethostname   4074
#define SYS_setrlimit   4075
#define SYS_getrlimit   4076
#define SYS_getrusage   4077
#define SYS_gettimeofday   4078
#define SYS_settimeofday   4079
#define SYS_getgroups   4080
#define SYS_setgroups   4081
#define SYS_reserved82   4082
#define SYS_symlink   4083
#define SYS_unused84   4084
#define SYS_readlink   4085
#define SYS_uselib   4086
#define SYS_swapon   4087
#define SYS_reboot   4088
#define SYS_readdir   4089
#define SYS_mmap   4090
#define SYS_munmap   4091
#define SYS_truncate   4092
#define SYS_ftruncate   4093
#define SYS_fchmod   4094
#define SYS_fchown   4095
#define SYS_getpriority   4096
#define SYS_setpriority   4097
#define SYS_profil   4098
#define SYS_statfs   4099
#define SYS_fstatfs   4100
#define SYS_ioperm   4101
#define SYS_socketcall   4102
#define SYS_syslog   4103
#define SYS_setitimer   4104
#define SYS_getitimer   4105
#define SYS_stat   4106
#define SYS_lstat   4107
#define SYS_fstat   4108
#define SYS_unused109   4109
#define SYS_iopl   4110
#define SYS_vhangup   4111
#define SYS_idle   4112
#define SYS_vm86   4113
#define SYS_wait4   4114
#define SYS_swapoff   4115
#define SYS_sysinfo   4116
#define SYS_ipc   4117
#define SYS_fsync   4118
#define SYS_sigreturn   4119
#define SYS_clone   4120
#define SYS_setdomainname   4121
#define SYS_uname   4122
#define SYS_modify_ldt   4123
#define SYS_adjtimex   4124
#define SYS_mprotect   4125
#define SYS_sigprocmask   4126
#define SYS_create_module   4127
#define SYS_init_module   4128
#define SYS_delete_module   4129
#define SYS_get_kernel_syms   4130
#define SYS_quotactl   4131
#define SYS_getpgid   4132
#define SYS_fchdir   4133
#define SYS_bdflush   4134
#define SYS_sysfs   4135
#define SYS_personality   4136
#define SYS_afs_syscall   4137
#define SYS_setfsuid   4138
#define SYS_setfsgid   4139
#define SYS__llseek   4140
#define SYS_getdents   4141
#define SYS_select   4142
#define SYS_flock   4143
#define SYS_msync   4144
#define SYS_readv   4145
#define SYS_writev   4146
#define SYS_cacheflush   4147
#define SYS_cachectl   4148
#define SYS_sysmips   4149
#define SYS_unused150   4150
#define SYS_getsid   4151
#define SYS_fdatasync   4152
#define SYS__sysctl   4153
#define SYS_mlock   4154
#define SYS_munlock   4155
#define SYS_mlockall   4156
#define SYS_munlockall   4157
#define SYS_sched_setparam   4158
#define SYS_sched_getparam   4159
#define SYS_sched_setscheduler   4160
#define SYS_sched_getscheduler   4161
#define SYS_sched_yield   4162
#define SYS_sched_get_priority_max  4163
#define SYS_sched_get_priority_min  4164
#define SYS_sched_rr_get_interval   4165
#define SYS_nanosleep   4166
#define SYS_mremap   4167
#define SYS_accept   4168
#define SYS_bind   4169
#define SYS_connect   4170
#define SYS_getpeername   4171
#define SYS_getsockname   4172
#define SYS_getsockopt   4173
#define SYS_listen   4174
#define SYS_recv   4175
#define SYS_recvfrom   4176
#define SYS_recvmsg   4177
#define SYS_send   4178
#define SYS_sendmsg   4179
#define SYS_sendto   4180
#define SYS_setsockopt   4181
#define SYS_shutdown   4182
#define SYS_socket   4183
#define SYS_socketpair   4184
#define SYS_setresuid   4185
#define SYS_getresuid   4186
#define SYS_query_module   4187
#define SYS_poll   4188
#define SYS_nfsservctl   4189
#define SYS_setresgid   4190
#define SYS_getresgid   4191
#define SYS_prctl   4192
#define SYS_rt_sigreturn   4193
#define SYS_rt_sigaction   4194
#define SYS_rt_sigprocmask   4195
#define SYS_rt_sigpending   4196
#define SYS_rt_sigtimedwait   4197
#define SYS_rt_sigqueueinfo   4198
#define SYS_rt_sigsuspend   4199
#define SYS_pread   4200
#define SYS_pwrite   4201
#define SYS_chown   4202
#define SYS_getcwd   4203
#define SYS_capget   4204
#define SYS_capset   4205
#define SYS_sigaltstack   4206
#define SYS_sendfile   4207
#define SYS_getpmsg   4208
#define SYS_putpmsg   4209
#define SYS_mmap2   4210
#define SYS_truncate64   4211
#define SYS_ftruncate64   4212
#define SYS_stat64   4213
#define SYS_lstat64   4214
#define SYS_fstat64   4215
#define SYS_pivot_root   4216
#define SYS_mincore   4217
#define SYS_madvise   4218
#define SYS_getdents64   4219
#define SYS_fcntl64   4220
#define SYS_reserved221   4221
#define SYS_gettid   4222
#define SYS_readahead   4223
#define SYS_setxattr   4224
#define SYS_lsetxattr   4225
#define SYS_fsetxattr   4226
#define SYS_getxattr   4227
#define SYS_lgetxattr   4228
#define SYS_fgetxattr   4229
#define SYS_listxattr   4230
#define SYS_llistxattr   4231
#define SYS_flistxattr   4232
#define SYS_removexattr   4233
#define SYS_lremovexattr   4234
#define SYS_fremovexattr   4235
#define SYS_tkill   4236
#define SYS_sendfile64   4237
#define SYS_futex   4238
#define SYS_sched_setaffinity   4239
#define SYS_sched_getaffinity   4240
#define SYS_io_setup   4241
#define SYS_io_destroy   4242
#define SYS_io_getevents   4243
#define SYS_io_submit   4244
#define SYS_io_cancel   4245
#define SYS_exit_group   4246
#define SYS_lookup_dcookie   4247
#define SYS_epoll_create   4248
#define SYS_epoll_ctl   4249
#define SYS_epoll_wait   4250
#define SYS_remap_file_pages   4251
#define SYS_set_tid_address   4252
#define SYS_restart_syscall   4253
#define SYS_fadvise   4254
#define SYS_statfs64   4255
#define SYS_fstatfs64   4256
#define SYS_timer_create   4257
#define SYS_timer_settime   4258
#define SYS_timer_gettime   4259
#define SYS_timer_getoverrun   4260
#define SYS_timer_delete   4261
#define SYS_clock_settime   4262
#define SYS_clock_gettime   4263
#define SYS_clock_getres   4264
#define SYS_clock_nanosleep   4265
#define SYS_tgkill   4266
#define SYS_utimes   4267
#define SYS_mbind   4268
#define SYS_get_mempolicy   4269
#define SYS_set_mempolicy   4270
#define SYS_mq_open   4271
#define SYS_mq_unlink   4272
#define SYS_mq_timedsend   4273
#define SYS_mq_timedreceive   4274
#define SYS_mq_notify   4275
#define SYS_mq_getsetattr   4276
#define SYS_vserver   4277
#define SYS_waitid   4278
#define SYS_add_key   4280
#define SYS_request_key   4281
#define SYS_keyctl   4282
#define SYS_set_thread_area   4283
#define SYS_inotify_init   4284
#define SYS_inotify_add_watch   4285
#define SYS_inotify_rm_watch   4286
#define SYS_migrate_pages   4287
#define SYS_openat   4288
#define SYS_mkdirat   4289
#define SYS_mknodat   4290
#define SYS_fchownat   4291
#define SYS_futimesat   4292
#define SYS_fstatat   4293
#define SYS_unlinkat   4294
#define SYS_renameat   4295
#define SYS_linkat   4296
#define SYS_symlinkat   4297
#define SYS_readlinkat   4298
#define SYS_fchmodat   4299
#define SYS_faccessat   4300
#define SYS_pselect6   4301
#define SYS_ppoll   4302
#define SYS_unshare   4303
#define SYS_splice   4304
#define SYS_sync_file_range   4305
#define SYS_tee   4306
#define SYS_vmsplice   4307
#define SYS_move_pages   4308
#define SYS_set_robust_list   4309
#define SYS_get_robust_list   4310
#define SYS_kexec_load   4311
#define SYS_getcpu   4312
#define SYS_epoll_pwait   4313
#define SYS_ioprio_set   4314
#define SYS_ioprio_get   4315
#define SYS_utimensat   4316
#define SYS_signalfd   4317
#define SYS_timerfd   4318
#define SYS_eventfd   4319
#define SYS_fallocate   4320
#define SYS_timerfd_create   4321
#define SYS_timerfd_gettime   4322
#define SYS_timerfd_settime   4323
#define SYS_signalfd4   4324
#define SYS_eventfd2   4325
#define SYS_epoll_create1   4326
#define SYS_dup3   4327
#define SYS_pipe2   4328
#define SYS_inotify_init1   4329
#define SYS_preadv   4330
#define SYS_pwritev   4331
#define SYS_rt_tgsigqueueinfo   4332
#define SYS_perf_event_open   4333
#define SYS_accept4   4334
#define SYS_recvmmsg   4335
#define SYS_fanotify_init   4336
#define SYS_fanotify_mark   4337
#define SYS_prlimit64   4338
#define SYS_name_to_handle_at   4339
#define SYS_open_by_handle_at   4340
#define SYS_clock_adjtime   4341
#define SYS_syncfs   4342
#define SYS_sendmmsg   4343
#define SYS_setns   4344
#define SYS_process_vm_readv   4345
#define SYS_process_vm_writev   4346
#define SYS_kcmp   4347
#define SYS_finit_module   4348
#define SYS_sched_setattr   4349
#define SYS_sched_getattr   4350
#define SYS_renameat2   4351
#define SYS_seccomp   4352
#define SYS_getrandom   4353
#define SYS_memfd_create   4354
#define SYS_bpf   4355
#define SYS_execveat   4356
#define SYS_userfaultfd   4357
#define SYS_membarrier   4358
#define SYS_mlock2   4359


#elif (defined(OSLINUX) && defined(X86_64))


#define __NR_read   0
#define __NR_write   1
#define __NR_open   2
#define __NR_close   3
#define __NR_stat   4
#define __NR_fstat   5
#define __NR_lstat   6
#define __NR_poll   7
#define __NR_lseek   8
#define __NR_mmap   9
#define __NR_mprotect   10
#define __NR_munmap   11
#define __NR_brk   12
#define __NR_rt_sigaction   13
#define __NR_rt_sigprocmask   14
#define __NR_rt_sigreturn   15
#define __NR_ioctl   16
#define __NR_pread64   17
#define __NR_pwrite64   18
#define __NR_readv   19
#define __NR_writev   20
#define __NR_access   21
#define __NR_pipe   22
#define __NR_select   23
#define __NR_sched_yield   24
#define __NR_mremap   25
#define __NR_msync   26
#define __NR_mincore   27
#define __NR_madvise   28
#define __NR_shmget   29
#define __NR_shmat   30
#define __NR_shmctl   31
#define __NR_dup   32
#define __NR_dup2   33
#define __NR_pause   34
#define __NR_nanosleep   35
#define __NR_getitimer   36
#define __NR_alarm   37
#define __NR_setitimer   38
#define __NR_getpid   39
#define __NR_sendfile   40
#define __NR_socket   41
#define __NR_connect   42
#define __NR_accept   43
#define __NR_sendto   44
#define __NR_recvfrom   45
#define __NR_sendmsg   46
#define __NR_recvmsg   47
#define __NR_shutdown   48
#define __NR_bind   49
#define __NR_listen   50
#define __NR_getsockname   51
#define __NR_getpeername   52
#define __NR_socketpair   53
#define __NR_setsockopt   54
#define __NR_getsockopt   55
#define __NR_clone   56
#define __NR_fork   57
#define __NR_vfork   58
#define __NR_execve   59
#define __NR_exit   60
#define __NR_wait4   61
#define __NR_kill   62
#define __NR_uname   63
#define __NR_semget   64
#define __NR_semop   65
#define __NR_semctl   66
#define __NR_shmdt   67
#define __NR_msgget   68
#define __NR_msgsnd   69
#define __NR_msgrcv   70
#define __NR_msgctl   71
#define __NR_fcntl   72
#define __NR_fcntl64   72
#define __NR_flock   73
#define __NR_fsync   74
#define __NR_fdatasync   75
#define __NR_truncate   76
#define __NR_ftruncate   77
#define __NR_getdents   78
#define __NR_getcwd   79
#define __NR_chdir   80
#define __NR_fchdir   81
#define __NR_rename   82
#define __NR_mkdir   83
#define __NR_rmdir   84
#define __NR_creat   85
#define __NR_link   86
#define __NR_unlink   87
#define __NR_symlink   88
#define __NR_readlink   89
#define __NR_chmod   90
#define __NR_fchmod   91
#define __NR_chown   92
#define __NR_fchown   93
#define __NR_lchown   94
#define __NR_umask   95
#define __NR_gettimeofday   96
#define __NR_getrlimit   97
#define __NR_getrusage   98
#define __NR_sysinfo   99
#define __NR_times   100
#define __NR_ptrace   101
#define __NR_getuid   102
#define __NR_syslog   103
#define __NR_getgid   104
#define __NR_setuid   105
#define __NR_setgid   106
#define __NR_geteuid   107
#define __NR_getegid   108
#define __NR_setpgid   109
#define __NR_getppid   110
#define __NR_getpgrp   111
#define __NR_setsid   112
#define __NR_setreuid   113
#define __NR_setregid   114
#define __NR_getgroups   115
#define __NR_setgroups   116
#define __NR_setresuid   117
#define __NR_getresuid   118
#define __NR_setresgid   119
#define __NR_getresgid   120
#define __NR_getpgid   121
#define __NR_setfsuid   122
#define __NR_setfsgid   123
#define __NR_getsid   124
#define __NR_capget   125
#define __NR_capset   126
#define __NR_rt_sigpending   127
#define __NR_rt_sigtimedwait   128
#define __NR_rt_sigqueueinfo   129
#define __NR_rt_sigsuspend   130
#define __NR_sigaltstack   131
#define __NR_utime   132
#define __NR_mknod   133
#define __NR_uselib   134
#define __NR_personality   135
#define __NR_ustat   136
#define __NR_statfs   137
#define __NR_fstatfs   138
#define __NR_sysfs   139
#define __NR_getpriority   140
#define __NR_setpriority   141
#define __NR_sched_setparam   142
#define __NR_sched_getparam   143
#define __NR_sched_setscheduler   144
#define __NR_sched_getscheduler   145
#define __NR_sched_get_priority_max   146
#define __NR_sched_get_priority_min   147
#define __NR_sched_rr_get_interval   148
#define __NR_mlock   149
#define __NR_munlock   150
#define __NR_mlockall   151
#define __NR_munlockall   152
#define __NR_vhangup   153
#define __NR_modify_ldt   154
#define __NR_pivot_root   155
#define __NR__sysctl   156
#define __NR_prctl   157
#define __NR_arch_prctl   158
#define __NR_adjtimex   159
#define __NR_setrlimit   160
#define __NR_chroot   161
#define __NR_sync   162
#define __NR_acct   163
#define __NR_settimeofday   164
#define __NR_mount   165
#define __NR_umount2   166
#define __NR_swapon   167
#define __NR_swapoff   168
#define __NR_reboot   169
#define __NR_sethostname   170
#define __NR_setdomainname   171
#define __NR_iopl   172
#define __NR_ioperm   173
#define __NR_create_module   174
#define __NR_init_module   175
#define __NR_delete_module   176
#define __NR_get_kernel_syms   177
#define __NR_query_module   178
#define __NR_quotactl   179
#define __NR_nfsservctl   180
#define __NR_getpmsg   181
#define __NR_putpmsg   182
#define __NR_afs_syscall   183
#define __NR_tuxcall   184
#define __NR_security   185
#define __NR_gettid   186
#define __NR_readahead   187
#define __NR_setxattr   188
#define __NR_lsetxattr   189
#define __NR_fsetxattr   190
#define __NR_getxattr   191
#define __NR_lgetxattr   192
#define __NR_fgetxattr   193
#define __NR_listxattr   194
#define __NR_llistxattr   195
#define __NR_flistxattr   196
#define __NR_removexattr   197
#define __NR_lremovexattr   198
#define __NR_fremovexattr   199
#define __NR_tkill   200
#define __NR_time   201
#define __NR_futex   202
#define __NR_sched_setaffinity   203
#define __NR_sched_getaffinity   204
#define __NR_set_thread_area   205
#define __NR_io_setup   206
#define __NR_io_destroy   207
#define __NR_io_getevents   208
#define __NR_io_submit   209
#define __NR_io_cancel   210
#define __NR_get_thread_area   211
#define __NR_lookup_dcookie   212
#define __NR_epoll_create   213
#define __NR_epoll_ctl_old   214
#define __NR_epoll_wait_old   215
#define __NR_remap_file_pages   216
#define __NR_getdents64   217
#define __NR_set_tid_address   218
#define __NR_restart_syscall   219
#define __NR_semtimedop   220
#define __NR_fadvise64   221
#define __NR_timer_create   222
#define __NR_timer_settime   223
#define __NR_timer_gettime   224
#define __NR_timer_getoverrun   225
#define __NR_timer_delete   226
#define __NR_clock_settime   227
#define __NR_clock_gettime   228
#define __NR_clock_getres   229
#define __NR_clock_nanosleep   230
#define __NR_exit_group   231
#define __NR_epoll_wait   232
#define __NR_epoll_ctl   233
#define __NR_tgkill   234
#define __NR_utimes   235
#define __NR_vserver   236
#define __NR_mbind   237
#define __NR_set_mempolicy   238
#define __NR_get_mempolicy   239
#define __NR_mq_open   240
#define __NR_mq_unlink   241
#define __NR_mq_timedsend   242
#define __NR_mq_timedreceive   243
#define __NR_mq_notify   244
#define __NR_mq_getsetattr   245
#define __NR_kexec_load   246
#define __NR_waitid   247
#define __NR_add_key   248
#define __NR_request_key   249
#define __NR_keyctl   250
#define __NR_ioprio_set   251
#define __NR_ioprio_get   252
#define __NR_inotify_init   253
#define __NR_inotify_add_watch   254
#define __NR_inotify_rm_watch   255
#define __NR_migrate_pages   256
#define __NR_openat   257
#define __NR_mkdirat   258
#define __NR_mknodat   259
#define __NR_fchownat   260
#define __NR_futimesat   261
#define __NR_newfstatat   262
#define __NR_unlinkat   263
#define __NR_renameat   264
#define __NR_linkat   265
#define __NR_symlinkat   266
#define __NR_readlinkat   267
#define __NR_fchmodat   268
#define __NR_faccessat   269
#define __NR_pselect6   270
#define __NR_ppoll   271
#define __NR_unshare   272
#define __NR_set_robust_list   273
#define __NR_get_robust_list   274
#define __NR_splice   275
#define __NR_tee   276
#define __NR_sync_file_range   277
#define __NR_vmsplice   278
#define __NR_move_pages   279
#define __NR_utimensat   280
#define __NR_epoll_pwait   281
#define __NR_signalfd   282
#define __NR_timerfd_create   283
#define __NR_eventfd   284
#define __NR_fallocate   285
#define __NR_timerfd_settime   286
#define __NR_timerfd_gettime   287
#define __NR_accept4   288
#define __NR_signalfd4   289
#define __NR_eventfd2   290
#define __NR_epoll_create1   291
#define __NR_dup3   292
#define __NR_pipe2   293
#define __NR_inotify_init1   294
#define __NR_preadv   295
#define __NR_pwritev   296
#define __NR_rt_tgsigqueueinfo   297
#define __NR_perf_event_open   298
#define __NR_recvmmsg   299
#define __NR_fanotify_init   300
#define __NR_fanotify_mark   301
#define __NR_prlimit64   302
#define __NR_name_to_handle_at   303
#define __NR_open_by_handle_at   304
#define __NR_clock_adjtime   305
#define __NR_syncfs   306
#define __NR_sendmmsg   307
#define __NR_setns   308
#define __NR_getcpu   309
#define __NR_process_vm_readv   310
#define __NR_process_vm_writev   311
#define __NR_kcmp   312
#define __NR_finit_module   313
#define __NR_sched_setattr   314
#define __NR_sched_getattr   315
#define __NR_renameat2   316
#define __NR_seccomp   317
#define __NR_getrandom   318
#define __NR_memfd_create   319
#define __NR_kexec_file_load   320
#define __NR_bpf   321
#define __NR_execveat   322
#define __NR_userfaultfd   323
#define __NR_membarrier   324
#define __NR_mlock2   325
// Repeat with SYS_ prefix
#define SYS_read   0
#define SYS_write   1
#define SYS_open   2
#define SYS_close   3
#define SYS_stat   4
#define SYS_fstat   5
#define SYS_lstat   6
#define SYS_poll   7
#define SYS_lseek   8
#define SYS_mmap   9
#define SYS_mprotect   10
#define SYS_munmap   11
#define SYS_brk   12
#define SYS_rt_sigaction   13
#define SYS_rt_sigprocmask   14
#define SYS_rt_sigreturn   15
#define SYS_ioctl   16
#define SYS_pread64   17
#define SYS_pwrite64   18
#define SYS_readv   19
#define SYS_writev   20
#define SYS_access   21
#define SYS_pipe   22
#define SYS_select   23
#define SYS_sched_yield   24
#define SYS_mremap   25
#define SYS_msync   26
#define SYS_mincore   27
#define SYS_madvise   28
#define SYS_shmget   29
#define SYS_shmat   30
#define SYS_shmctl   31
#define SYS_dup   32
#define SYS_dup2   33
#define SYS_pause   34
#define SYS_nanosleep   35
#define SYS_getitimer   36
#define SYS_alarm   37
#define SYS_setitimer   38
#define SYS_getpid   39
#define SYS_sendfile   40
#define SYS_socket   41
#define SYS_connect   42
#define SYS_accept   43
#define SYS_sendto   44
#define SYS_recvfrom   45
#define SYS_sendmsg   46
#define SYS_recvmsg   47
#define SYS_shutdown   48
#define SYS_bind   49
#define SYS_listen   50
#define SYS_getsockname   51
#define SYS_getpeername   52
#define SYS_socketpair   53
#define SYS_setsockopt   54
#define SYS_getsockopt   55
#define SYS_clone   56
#define SYS_fork   57
#define SYS_vfork   58
#define SYS_execve   59
#define SYS_exit   60
#define SYS_wait4   61
#define SYS_kill   62
#define SYS_uname   63
#define SYS_semget   64
#define SYS_semop   65
#define SYS_semctl   66
#define SYS_shmdt   67
#define SYS_msgget   68
#define SYS_msgsnd   69
#define SYS_msgrcv   70
#define SYS_msgctl   71
#define SYS_fcntl   72
#define SYS_fcntl64   72
#define SYS_flock   73
#define SYS_fsync   74
#define SYS_fdatasync   75
#define SYS_truncate   76
#define SYS_ftruncate   77
#define SYS_getdents   78
#define SYS_getcwd   79
#define SYS_chdir   80
#define SYS_fchdir   81
#define SYS_rename   82
#define SYS_mkdir   83
#define SYS_rmdir   84
#define SYS_creat   85
#define SYS_link   86
#define SYS_unlink   87
#define SYS_symlink   88
#define SYS_readlink   89
#define SYS_chmod   90
#define SYS_fchmod   91
#define SYS_chown   92
#define SYS_fchown   93
#define SYS_lchown   94
#define SYS_umask   95
#define SYS_gettimeofday   96
#define SYS_getrlimit   97
#define SYS_getrusage   98
#define SYS_sysinfo   99
#define SYS_times   100
#define SYS_ptrace   101
#define SYS_getuid   102
#define SYS_syslog   103
#define SYS_getgid   104
#define SYS_setuid   105
#define SYS_setgid   106
#define SYS_geteuid   107
#define SYS_getegid   108
#define SYS_setpgid   109
#define SYS_getppid   110
#define SYS_getpgrp   111
#define SYS_setsid   112
#define SYS_setreuid   113
#define SYS_setregid   114
#define SYS_getgroups   115
#define SYS_setgroups   116
#define SYS_setresuid   117
#define SYS_getresuid   118
#define SYS_setresgid   119
#define SYS_getresgid   120
#define SYS_getpgid   121
#define SYS_setfsuid   122
#define SYS_setfsgid   123
#define SYS_getsid   124
#define SYS_capget   125
#define SYS_capset   126
#define SYS_rt_sigpending   127
#define SYS_rt_sigtimedwait   128
#define SYS_rt_sigqueueinfo   129
#define SYS_rt_sigsuspend   130
#define SYS_sigaltstack   131
#define SYS_utime   132
#define SYS_mknod   133
#define SYS_uselib   134
#define SYS_personality   135
#define SYS_ustat   136
#define SYS_statfs   137
#define SYS_fstatfs   138
#define SYS_sysfs   139
#define SYS_getpriority   140
#define SYS_setpriority   141
#define SYS_sched_setparam   142
#define SYS_sched_getparam   143
#define SYS_sched_setscheduler   144
#define SYS_sched_getscheduler   145
#define SYS_sched_get_priority_max   146
#define SYS_sched_get_priority_min   147
#define SYS_sched_rr_get_interval   148
#define SYS_mlock   149
#define SYS_munlock   150
#define SYS_mlockall   151
#define SYS_munlockall   152
#define SYS_vhangup   153
#define SYS_modify_ldt   154
#define SYS_pivot_root   155
#define SYS__sysctl   156
#define SYS_prctl   157
#define SYS_arch_prctl   158
#define SYS_adjtimex   159
#define SYS_setrlimit   160
#define SYS_chroot   161
#define SYS_sync   162
#define SYS_acct   163
#define SYS_settimeofday   164
#define SYS_mount   165
#define SYS_umount2   166
#define SYS_swapon   167
#define SYS_swapoff   168
#define SYS_reboot   169
#define SYS_sethostname   170
#define SYS_setdomainname   171
#define SYS_iopl   172
#define SYS_ioperm   173
#define SYS_create_module   174
#define SYS_init_module   175
#define SYS_delete_module   176
#define SYS_get_kernel_syms   177
#define SYS_query_module   178
#define SYS_quotactl   179
#define SYS_nfsservctl   180
#define SYS_getpmsg   181
#define SYS_putpmsg   182
#define SYS_afs_syscall   183
#define SYS_tuxcall   184
#define SYS_security   185
#define SYS_gettid   186
#define SYS_readahead   187
#define SYS_setxattr   188
#define SYS_lsetxattr   189
#define SYS_fsetxattr   190
#define SYS_getxattr   191
#define SYS_lgetxattr   192
#define SYS_fgetxattr   193
#define SYS_listxattr   194
#define SYS_llistxattr   195
#define SYS_flistxattr   196
#define SYS_removexattr   197
#define SYS_lremovexattr   198
#define SYS_fremovexattr   199
#define SYS_tkill   200
#define SYS_time   201
#define SYS_futex   202
#define SYS_sched_setaffinity   203
#define SYS_sched_getaffinity   204
#define SYS_set_thread_area   205
#define SYS_io_setup   206
#define SYS_io_destroy   207
#define SYS_io_getevents   208
#define SYS_io_submit   209
#define SYS_io_cancel   210
#define SYS_get_thread_area   211
#define SYS_lookup_dcookie   212
#define SYS_epoll_create   213
#define SYS_epoll_ctl_old   214
#define SYS_epoll_wait_old   215
#define SYS_remap_file_pages   216
#define SYS_getdents64   217
#define SYS_set_tid_address   218
#define SYS_restart_syscall   219
#define SYS_semtimedop   220
#define SYS_fadvise64   221
#define SYS_timer_create   222
#define SYS_timer_settime   223
#define SYS_timer_gettime   224
#define SYS_timer_getoverrun   225
#define SYS_timer_delete   226
#define SYS_clock_settime   227
#define SYS_clock_gettime   228
#define SYS_clock_getres   229
#define SYS_clock_nanosleep   230
#define SYS_exit_group   231
#define SYS_epoll_wait   232
#define SYS_epoll_ctl   233
#define SYS_tgkill   234
#define SYS_utimes   235
#define SYS_vserver   236
#define SYS_mbind   237
#define SYS_set_mempolicy   238
#define SYS_get_mempolicy   239
#define SYS_mq_open   240
#define SYS_mq_unlink   241
#define SYS_mq_timedsend   242
#define SYS_mq_timedreceive   243
#define SYS_mq_notify   244
#define SYS_mq_getsetattr   245
#define SYS_kexec_load   246
#define SYS_waitid   247
#define SYS_add_key   248
#define SYS_request_key   249
#define SYS_keyctl   250
#define SYS_ioprio_set   251
#define SYS_ioprio_get   252
#define SYS_inotify_init   253
#define SYS_inotify_add_watch   254
#define SYS_inotify_rm_watch   255
#define SYS_migrate_pages   256
#define SYS_openat   257
#define SYS_mkdirat   258
#define SYS_mknodat   259
#define SYS_fchownat   260
#define SYS_futimesat   261
#define SYS_newfstatat   262
#define SYS_unlinkat   263
#define SYS_renameat   264
#define SYS_linkat   265
#define SYS_symlinkat   266
#define SYS_readlinkat   267
#define SYS_fchmodat   268
#define SYS_faccessat   269
#define SYS_pselect6   270
#define SYS_ppoll   271
#define SYS_unshare   272
#define SYS_set_robust_list   273
#define SYS_get_robust_list   274
#define SYS_splice   275
#define SYS_tee   276
#define SYS_sync_file_range   277
#define SYS_vmsplice   278
#define SYS_move_pages   279
#define SYS_utimensat   280
#define SYS_epoll_pwait   281
#define SYS_signalfd   282
#define SYS_timerfd_create   283
#define SYS_eventfd   284
#define SYS_fallocate   285
#define SYS_timerfd_settime   286
#define SYS_timerfd_gettime   287
#define SYS_accept4   288
#define SYS_signalfd4   289
#define SYS_eventfd2   290
#define SYS_epoll_create1   291
#define SYS_dup3   292
#define SYS_pipe2   293
#define SYS_inotify_init1   294
#define SYS_preadv   295
#define SYS_pwritev   296
#define SYS_rt_tgsigqueueinfo   297
#define SYS_perf_event_open   298
#define SYS_recvmmsg   299
#define SYS_fanotify_init   300
#define SYS_fanotify_mark   301
#define SYS_prlimit64   302
#define SYS_name_to_handle_at   303
#define SYS_open_by_handle_at   304
#define SYS_clock_adjtime   305
#define SYS_syncfs   306
#define SYS_sendmmsg   307
#define SYS_setns   308
#define SYS_getcpu   309
#define SYS_process_vm_readv   310
#define SYS_process_vm_writev   311
#define SYS_kcmp   312
#define SYS_finit_module   313
#define SYS_sched_setattr   314
#define SYS_sched_getattr   315
#define SYS_renameat2   316
#define SYS_seccomp   317
#define SYS_getrandom   318
#define SYS_memfd_create   319
#define SYS_kexec_file_load   320
#define SYS_bpf   321
#define SYS_execveat   322
#define SYS_userfaultfd   323
#define SYS_membarrier   324
#define SYS_mlock2   325


#elif (defined(OSLINUX) && defined(ARM))


#define __NR_restart_syscall   0
#define __NR_exit   1
#define __NR_fork   2
#define __NR_read   3
#define __NR_write   4
#define __NR_open   5
#define __NR_close   6
#define __NR_creat   8
#define __NR_link   9
#define __NR_unlink   10
#define __NR_execve   11
#define __NR_chdir   12
#define __NR_mknod   14
#define __NR_chmod   15
#define __NR_lchown   16
#define __NR_lseek   19
#define __NR_getpid   20
#define __NR_mount   21
#define __NR_setuid   23
#define __NR_getuid   24
#define __NR_ptrace   26
#define __NR_pause   29
#define __NR_access   33
#define __NR_nice   34
#define __NR_sync   36
#define __NR_kill   37
#define __NR_rename   38
#define __NR_mkdir   39
#define __NR_rmdir   40
#define __NR_dup   41
#define __NR_pipe   42
#define __NR_times   43
#define __NR_brk   45
#define __NR_setgid   46
#define __NR_getgid   47
#define __NR_geteuid   49
#define __NR_getegid   50
#define __NR_acct   51
#define __NR_umount2   52
#define __NR_ioctl   54
#define __NR_fcntl   55
#define __NR_setpgid   57
#define __NR_umask   60
#define __NR_chroot   61
#define __NR_ustat   62
#define __NR_dup2   63
#define __NR_getppid   64
#define __NR_getpgrp   65
#define __NR_setsid   66
#define __NR_sigaction   67
#define __NR_setreuid   70
#define __NR_setregid   71
#define __NR_sigsuspend   72
#define __NR_sigpending   73
#define __NR_sethostname   74
#define __NR_setrlimit   75
#define __NR_getrusage   77
#define __NR_gettimeofday   78
#define __NR_settimeofday   79
#define __NR_getgroups   80
#define __NR_setgroups   81
#define __NR_symlink   83
#define __NR_readlink   85
#define __NR_uselib   86
#define __NR_swapon   87
#define __NR_reboot   88
#define __NR_munmap   91
#define __NR_truncate   92
#define __NR_ftruncate   93
#define __NR_fchmod   94
#define __NR_fchown   95
#define __NR_getpriority   96
#define __NR_setpriority   97
#define __NR_statfs   99
#define __NR_fstatfs   100
#define __NR_syslog   103
#define __NR_setitimer   104
#define __NR_getitimer   105
#define __NR_stat   106
#define __NR_lstat   107
#define __NR_fstat   108
#define __NR_vhangup   111
#define __NR_wait4   114
#define __NR_swapoff   115
#define __NR_sysinfo   116
#define __NR_fsync   118
#define __NR_sigreturn   119
#define __NR_clone   120
#define __NR_setdomainname   121
#define __NR_uname   122
#define __NR_adjtimex   124
#define __NR_mprotect   125
#define __NR_sigprocmask   126
#define __NR_init_module   128
#define __NR_delete_module   129
#define __NR_quotactl   131
#define __NR_getpgid   132
#define __NR_fchdir   133
#define __NR_bdflush   134
#define __NR_sysfs   135
#define __NR_personality   136
#define __NR_setfsuid   138
#define __NR_setfsgid   139
#define __NR__llseek   140
#define __NR_getdents   141
#define __NR__newselect   142
#define __NR_flock   143
#define __NR_msync   144
#define __NR_readv   145
#define __NR_writev   146
#define __NR_getsid   147
#define __NR_fdatasync   148
#define __NR__sysctl   149
#define __NR_mlock   150
#define __NR_munlock   151
#define __NR_mlockall   152
#define __NR_munlockall   153
#define __NR_sched_setparam   154
#define __NR_sched_getparam   155
#define __NR_sched_setscheduler   156
#define __NR_sched_getscheduler   157
#define __NR_sched_yield   158
#define __NR_sched_get_priority_max   159
#define __NR_sched_get_priority_min   160
#define __NR_sched_rr_get_interval   161
#define __NR_nanosleep   162
#define __NR_mremap   163
#define __NR_setresuid   164
#define __NR_getresuid   165
#define __NR_poll   168
#define __NR_nfsservctl   169
#define __NR_setresgid   170
#define __NR_getresgid   171
#define __NR_prctl   172
#define __NR_rt_sigreturn   173
#define __NR_rt_sigaction   174
#define __NR_rt_sigprocmask   175
#define __NR_rt_sigpending   176
#define __NR_rt_sigtimedwait   177
#define __NR_rt_sigqueueinfo   178
#define __NR_rt_sigsuspend   179
#define __NR_pread64   180
#define __NR_pwrite64   181
#define __NR_chown   182
#define __NR_getcwd   183
#define __NR_capget   184
#define __NR_capset   185
#define __NR_sigaltstack   186
#define __NR_sendfile   187
#define __NR_vfork   190
#define __NR_ugetrlimit   191
#define __NR_mmap2   192
#define __NR_truncate64   193
#define __NR_ftruncate64   194
#define __NR_stat64   195
#define __NR_lstat64   196
#define __NR_fstat64   197
#define __NR_lchown32   198
#define __NR_getuid32   199
#define __NR_getgid32   200
#define __NR_geteuid32   201
#define __NR_getegid32   202
#define __NR_setreuid32   203
#define __NR_setregid32   204
#define __NR_getgroups32   205
#define __NR_setgroups32   206
#define __NR_fchown32   207
#define __NR_setresuid32   208
#define __NR_getresuid32   209
#define __NR_setresgid32   210
#define __NR_getresgid32   211
#define __NR_chown32   212
#define __NR_setuid32   213
#define __NR_setgid32   214
#define __NR_setfsuid32   215
#define __NR_setfsgid32   216
#define __NR_getdents64   217
#define __NR_pivot_root   218
#define __NR_mincore   219
#define __NR_madvise   220
#define __NR_fcntl64   221
#define __NR_gettid   224
#define __NR_readahead   225
#define __NR_setxattr   226
#define __NR_lsetxattr   227
#define __NR_fsetxattr   228
#define __NR_getxattr   229
#define __NR_lgetxattr   230
#define __NR_fgetxattr   231
#define __NR_listxattr   232
#define __NR_llistxattr   233
#define __NR_flistxattr   234
#define __NR_removexattr   235
#define __NR_lremovexattr   236
#define __NR_fremovexattr   237
#define __NR_tkill   238
#define __NR_sendfile64   239
#define __NR_futex   240
#define __NR_sched_setaffinity   241
#define __NR_sched_getaffinity   242
#define __NR_io_setup   243
#define __NR_io_destroy   244
#define __NR_io_getevents   245
#define __NR_io_submit   246
#define __NR_io_cancel   247
#define __NR_exit_group   248
#define __NR_lookup_dcookie   249
#define __NR_epoll_create   250
#define __NR_epoll_ctl   251
#define __NR_epoll_wait   252
#define __NR_remap_file_pages   253
#define __NR_set_tid_address   256
#define __NR_timer_create   257
#define __NR_timer_settime   258
#define __NR_timer_gettime   259
#define __NR_timer_getoverrun   260
#define __NR_timer_delete   261
#define __NR_clock_settime   262
#define __NR_clock_gettime   263
#define __NR_clock_getres   264
#define __NR_clock_nanosleep   265
#define __NR_statfs64   266
#define __NR_fstatfs64   267
#define __NR_tgkill   268
#define __NR_utimes   269
#define __NR_fadvise64_64   270
#define __NR_pciconfig_iobase   271
#define __NR_pciconfig_read   272
#define __NR_pciconfig_write   273
#define __NR_mq_open   274
#define __NR_mq_unlink   275
#define __NR_mq_timedsend   276
#define __NR_mq_timedreceive   277
#define __NR_mq_notify   278
#define __NR_mq_getsetattr   279
#define __NR_waitid   280
#define __NR_socket   281
#define __NR_bind   282
#define __NR_connect   283
#define __NR_listen   284
#define __NR_accept   285
#define __NR_getsockname   286
#define __NR_getpeername   287
#define __NR_socketpair   288
#define __NR_send   289
#define __NR_sendto   290
#define __NR_recv   291
#define __NR_recvfrom   292
#define __NR_shutdown   293
#define __NR_setsockopt   294
#define __NR_getsockopt   295
#define __NR_sendmsg   296
#define __NR_recvmsg   297
#define __NR_semop   298
#define __NR_semget   299
#define __NR_semctl   300
#define __NR_msgsnd   301
#define __NR_msgrcv   302
#define __NR_msgget   303
#define __NR_msgctl   304
#define __NR_shmat   305
#define __NR_shmdt   306
#define __NR_shmget   307
#define __NR_shmctl   308
#define __NR_add_key   309
#define __NR_request_key   310
#define __NR_keyctl   311
#define __NR_semtimedop   312
#define __NR_vserver   313
#define __NR_ioprio_set   314
#define __NR_ioprio_get   315
#define __NR_inotify_init   316
#define __NR_inotify_add_watch   317
#define __NR_inotify_rm_watch   318
#define __NR_mbind   319
#define __NR_get_mempolicy   320
#define __NR_set_mempolicy   321
#define __NR_openat   322
#define __NR_mkdirat   323
#define __NR_mknodat   324
#define __NR_fchownat   325
#define __NR_futimesat   326
#define __NR_fstatat64   327
#define __NR_unlinkat   328
#define __NR_renameat   329
#define __NR_linkat   330
#define __NR_symlinkat   331
#define __NR_readlinkat   332
#define __NR_fchmodat   333
#define __NR_faccessat   334
#define __NR_pselect6   335
#define __NR_ppoll   336
#define __NR_unshare   337
#define __NR_set_robust_list   338
#define __NR_get_robust_list   339
#define __NR_splice   340
#define __NR_sync_file_range2   341
#define __NR_tee   342
#define __NR_vmsplice   343
#define __NR_move_pages   344
#define __NR_getcpu   345
#define __NR_epoll_pwait   346
#define __NR_kexec_load   347
#define __NR_utimensat   348
#define __NR_signalfd   349
#define __NR_timerfd_create   350
#define __NR_eventfd   351
#define __NR_fallocate   352
#define __NR_timerfd_settime   353
#define __NR_timerfd_gettime   354
#define __NR_signalfd4   355
#define __NR_eventfd2   356
#define __NR_epoll_create1   357
#define __NR_dup3   358
#define __NR_pipe2   359
#define __NR_inotify_init1   360
#define __NR_preadv   361
#define __NR_pwritev   362
#define __NR_rt_tgsigqueueinfo   363
#define __NR_perf_event_open   364
#define __NR_recvmmsg   365
#define __NR_accept4   366
#define __NR_fanotify_init   367
#define __NR_fanotify_mark   368
#define __NR_prlimit64   369
#define __NR_name_to_handle_at   370
#define __NR_open_by_handle_at   371
#define __NR_clock_adjtime   372
#define __NR_syncfs   373
#define __NR_sendmmsg   374
#define __NR_setns   375
#define __NR_process_vm_readv   376
#define __NR_process_vm_writev   377
#define __NR_kcmp   378
#define __NR_finit_module   379
#define __NR_sched_setattr   380
#define __NR_sched_getattr   381
#define __NR_renameat2   382
#define __NR_seccomp   383
#define __NR_getrandom   384
#define __NR_memfd_create   385
#define __NR_bpf   386
#define __NR_execveat   387
#define __NR_userfaultfd   388
#define __NR_membarrier   389
#define __NR_mlock2   390
#define __ARM_NR_breakpoint   0x0f0001
#define __ARM_NR_cacheflush   0x0f0002
#define __ARM_NR_usr26   0x0f0003
#define __ARM_NR_usr32   0x0f0004
#define __ARM_NR_set_tls   0x0f0005
// Repeated with SYS_ prefix
#define SYS_restart_syscall   0
#define SYS_exit   1
#define SYS_fork   2
#define SYS_read   3
#define SYS_write   4
#define SYS_open   5
#define SYS_close   6
#define SYS_creat   8
#define SYS_link   9
#define SYS_unlink   10
#define SYS_execve   11
#define SYS_chdir   12
#define SYS_mknod   14
#define SYS_chmod   15
#define SYS_lchown   16
#define SYS_lseek   19
#define SYS_getpid   20
#define SYS_mount   21
#define SYS_setuid   23
#define SYS_getuid   24
#define SYS_ptrace   26
#define SYS_pause   29
#define SYS_access   33
#define SYS_nice   34
#define SYS_sync   36
#define SYS_kill   37
#define SYS_rename   38
#define SYS_mkdir   39
#define SYS_rmdir   40
#define SYS_dup   41
#define SYS_pipe   42
#define SYS_times   43
#define SYS_brk   45
#define SYS_setgid   46
#define SYS_getgid   47
#define SYS_geteuid   49
#define SYS_getegid   50
#define SYS_acct   51
#define SYS_umount2   52
#define SYS_ioctl   54
#define SYS_fcntl   55
#define SYS_setpgid   57
#define SYS_umask   60
#define SYS_chroot   61
#define SYS_ustat   62
#define SYS_dup2   63
#define SYS_getppid   64
#define SYS_getpgrp   65
#define SYS_setsid   66
#define SYS_sigaction   67
#define SYS_setreuid   70
#define SYS_setregid   71
#define SYS_sigsuspend   72
#define SYS_sigpending   73
#define SYS_sethostname   74
#define SYS_setrlimit   75
#define SYS_getrusage   77
#define SYS_gettimeofday   78
#define SYS_settimeofday   79
#define SYS_getgroups   80
#define SYS_setgroups   81
#define SYS_symlink   83
#define SYS_readlink   85
#define SYS_uselib   86
#define SYS_swapon   87
#define SYS_reboot   88
#define SYS_munmap   91
#define SYS_truncate   92
#define SYS_ftruncate   93
#define SYS_fchmod   94
#define SYS_fchown   95
#define SYS_getpriority   96
#define SYS_setpriority   97
#define SYS_statfs   99
#define SYS_fstatfs   100
#define SYS_syslog   103
#define SYS_setitimer   104
#define SYS_getitimer   105
#define SYS_stat   106
#define SYS_lstat   107
#define SYS_fstat   108
#define SYS_vhangup   111
#define SYS_wait4   114
#define SYS_swapoff   115
#define SYS_sysinfo   116
#define SYS_fsync   118
#define SYS_sigreturn   119
#define SYS_clone   120
#define SYS_setdomainname   121
#define SYS_uname   122
#define SYS_adjtimex   124
#define SYS_mprotect   125
#define SYS_sigprocmask   126
#define SYS_init_module   128
#define SYS_delete_module   129
#define SYS_quotactl   131
#define SYS_getpgid   132
#define SYS_fchdir   133
#define SYS_bdflush   134
#define SYS_sysfs   135
#define SYS_personality   136
#define SYS_setfsuid   138
#define SYS_setfsgid   139
#define SYS__llseek   140
#define SYS_getdents   141
#define SYS__newselect   142
#define SYS_flock   143
#define SYS_msync   144
#define SYS_readv   145
#define SYS_writev   146
#define SYS_getsid   147
#define SYS_fdatasync   148
#define SYS__sysctl   149
#define SYS_mlock   150
#define SYS_munlock   151
#define SYS_mlockall   152
#define SYS_munlockall   153
#define SYS_sched_setparam   154
#define SYS_sched_getparam   155
#define SYS_sched_setscheduler   156
#define SYS_sched_getscheduler   157
#define SYS_sched_yield   158
#define SYS_sched_get_priority_max   159
#define SYS_sched_get_priority_min   160
#define SYS_sched_rr_get_interval   161
#define SYS_nanosleep   162
#define SYS_mremap   163
#define SYS_setresuid   164
#define SYS_getresuid   165
#define SYS_poll   168
#define SYS_nfsservctl   169
#define SYS_setresgid   170
#define SYS_getresgid   171
#define SYS_prctl   172
#define SYS_rt_sigreturn   173
#define SYS_rt_sigaction   174
#define SYS_rt_sigprocmask   175
#define SYS_rt_sigpending   176
#define SYS_rt_sigtimedwait   177
#define SYS_rt_sigqueueinfo   178
#define SYS_rt_sigsuspend   179
#define SYS_pread64   180
#define SYS_pwrite64   181
#define SYS_chown   182
#define SYS_getcwd   183
#define SYS_capget   184
#define SYS_capset   185
#define SYS_sigaltstack   186
#define SYS_sendfile   187
#define SYS_vfork   190
#define SYS_ugetrlimit   191
#define SYS_mmap2   192
#define SYS_truncate64   193
#define SYS_ftruncate64   194
#define SYS_stat64   195
#define SYS_lstat64   196
#define SYS_fstat64   197
#define SYS_lchown32   198
#define SYS_getuid32   199
#define SYS_getgid32   200
#define SYS_geteuid32   201
#define SYS_getegid32   202
#define SYS_setreuid32   203
#define SYS_setregid32   204
#define SYS_getgroups32   205
#define SYS_setgroups32   206
#define SYS_fchown32   207
#define SYS_setresuid32   208
#define SYS_getresuid32   209
#define SYS_setresgid32   210
#define SYS_getresgid32   211
#define SYS_chown32   212
#define SYS_setuid32   213
#define SYS_setgid32   214
#define SYS_setfsuid32   215
#define SYS_setfsgid32   216
#define SYS_getdents64   217
#define SYS_pivot_root   218
#define SYS_mincore   219
#define SYS_madvise   220
#define SYS_fcntl64   221
#define SYS_gettid   224
#define SYS_readahead   225
#define SYS_setxattr   226
#define SYS_lsetxattr   227
#define SYS_fsetxattr   228
#define SYS_getxattr   229
#define SYS_lgetxattr   230
#define SYS_fgetxattr   231
#define SYS_listxattr   232
#define SYS_llistxattr   233
#define SYS_flistxattr   234
#define SYS_removexattr   235
#define SYS_lremovexattr   236
#define SYS_fremovexattr   237
#define SYS_tkill   238
#define SYS_sendfile64   239
#define SYS_futex   240
#define SYS_sched_setaffinity   241
#define SYS_sched_getaffinity   242
#define SYS_io_setup   243
#define SYS_io_destroy   244
#define SYS_io_getevents   245
#define SYS_io_submit   246
#define SYS_io_cancel   247
#define SYS_exit_group   248
#define SYS_lookup_dcookie   249
#define SYS_epoll_create   250
#define SYS_epoll_ctl   251
#define SYS_epoll_wait   252
#define SYS_remap_file_pages   253
#define SYS_set_tid_address   256
#define SYS_timer_create   257
#define SYS_timer_settime   258
#define SYS_timer_gettime   259
#define SYS_timer_getoverrun   260
#define SYS_timer_delete   261
#define SYS_clock_settime   262
#define SYS_clock_gettime   263
#define SYS_clock_getres   264
#define SYS_clock_nanosleep   265
#define SYS_statfs64   266
#define SYS_fstatfs64   267
#define SYS_tgkill   268
#define SYS_utimes   269
#define SYS_fadvise64_64   270
#define SYS_pciconfig_iobase   271
#define SYS_pciconfig_read   272
#define SYS_pciconfig_write   273
#define SYS_mq_open   274
#define SYS_mq_unlink   275
#define SYS_mq_timedsend   276
#define SYS_mq_timedreceive   277
#define SYS_mq_notify   278
#define SYS_mq_getsetattr   279
#define SYS_waitid   280
#define SYS_socket   281
#define SYS_bind   282
#define SYS_connect   283
#define SYS_listen   284
#define SYS_accept   285
#define SYS_getsockname   286
#define SYS_getpeername   287
#define SYS_socketpair   288
#define SYS_send   289
#define SYS_sendto   290
#define SYS_recv   291
#define SYS_recvfrom   292
#define SYS_shutdown   293
#define SYS_setsockopt   294
#define SYS_getsockopt   295
#define SYS_sendmsg   296
#define SYS_recvmsg   297
#define SYS_semop   298
#define SYS_semget   299
#define SYS_semctl   300
#define SYS_msgsnd   301
#define SYS_msgrcv   302
#define SYS_msgget   303
#define SYS_msgctl   304
#define SYS_shmat   305
#define SYS_shmdt   306
#define SYS_shmget   307
#define SYS_shmctl   308
#define SYS_add_key   309
#define SYS_request_key   310
#define SYS_keyctl   311
#define SYS_semtimedop   312
#define SYS_vserver   313
#define SYS_ioprio_set   314
#define SYS_ioprio_get   315
#define SYS_inotify_init   316
#define SYS_inotify_add_watch   317
#define SYS_inotify_rm_watch   318
#define SYS_mbind   319
#define SYS_get_mempolicy   320
#define SYS_set_mempolicy   321
#define SYS_openat   322
#define SYS_mkdirat   323
#define SYS_mknodat   324
#define SYS_fchownat   325
#define SYS_futimesat   326
#define SYS_fstatat64   327
#define SYS_unlinkat   328
#define SYS_renameat   329
#define SYS_linkat   330
#define SYS_symlinkat   331
#define SYS_readlinkat   332
#define SYS_fchmodat   333
#define SYS_faccessat   334
#define SYS_pselect6   335
#define SYS_ppoll   336
#define SYS_unshare   337
#define SYS_set_robust_list   338
#define SYS_get_robust_list   339
#define SYS_splice   340
#define SYS_sync_file_range2   341
#define SYS_tee   342
#define SYS_vmsplice   343
#define SYS_move_pages   344
#define SYS_getcpu   345
#define SYS_epoll_pwait   346
#define SYS_kexec_load   347
#define SYS_utimensat   348
#define SYS_signalfd   349
#define SYS_timerfd_create   350
#define SYS_eventfd   351
#define SYS_fallocate   352
#define SYS_timerfd_settime   353
#define SYS_timerfd_gettime   354
#define SYS_signalfd4   355
#define SYS_eventfd2   356
#define SYS_epoll_create1   357
#define SYS_dup3   358
#define SYS_pipe2   359
#define SYS_inotify_init1   360
#define SYS_preadv   361
#define SYS_pwritev   362
#define SYS_rt_tgsigqueueinfo   363
#define SYS_perf_event_open   364
#define SYS_recvmmsg   365
#define SYS_accept4   366
#define SYS_fanotify_init   367
#define SYS_fanotify_mark   368
#define SYS_prlimit64   369
#define SYS_name_to_handle_at   370
#define SYS_open_by_handle_at   371
#define SYS_clock_adjtime   372
#define SYS_syncfs   373
#define SYS_sendmmsg   374
#define SYS_setns   375
#define SYS_process_vm_readv   376
#define SYS_process_vm_writev   377
#define SYS_kcmp   378
#define SYS_finit_module   379
#define SYS_sched_setattr   380
#define SYS_sched_getattr   381
#define SYS_renameat2   382
#define SYS_seccomp   383
#define SYS_getrandom   384
#define SYS_memfd_create   385
#define SYS_bpf   386
#define SYS_execveat   387
#define SYS_userfaultfd   388
#define SYS_membarrier   389
#define SYS_mlock2   390


#elif (defined(OSFREEBSD) && (defined(I386) || defined(X86) || defined(X86_64)))


#define SYS_NOSYS   0
#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_WAIT4   7
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_OBREAK   17
#define SYS_GETPID   20
#define SYS_MOUNT   21
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_GETGID   47
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGALTSTACK   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_MSYNC   65
#define SYS_VFORK   66
#define SYS_SBRK   69
#define SYS_SSTK   70
#define SYS_OVADVISE   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SETITIMER   83
#define SYS_SWAPON   85
#define SYS_GETITIMER   86
#define SYS_GETDTABLESIZE   89
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_SELECT   93
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_GETTIMEOFDAY   116
#define SYS_GETRUSAGE   117
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_SETTIMEOFDAY   122
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_UTIMES   138
#define SYS_ADJTIME   140
#define SYS_SETSID   147
#define SYS_QUOTACTL   148
#define SYS_LGETFH   160
#define SYS_GETFH   161
#define SYS_SYSARCH   165
#define SYS_RTPRIO   166
#define SYS_FREEBSD6_PREAD   173
#define SYS_FREEBSD6_PWRITE   174
#define SYS_SETFIB   175
#define SYS_NTP_ADJTIME   176
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_STAT   188
#define SYS_FSTAT   189
#define SYS_LSTAT   190
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_GETDIRENTRIES   196
#define SYS_FREEBSD6_MMAP   197
#define SYS_FREEBSD6_LSEEK   199
#define SYS_FREEBSD6_TRUNCATE   200
#define SYS_FREEBSD6_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_FUTIMES   206
#define SYS_GETPGID   207
#define SYS_POLL   209
#define SYS_CLOCK_GETTIME   232
#define SYS_CLOCK_SETTIME   233
#define SYS_CLOCK_GETRES   234
#define SYS_KTIMER_CREATE   235
#define SYS_KTIMER_DELETE   236
#define SYS_KTIMER_SETTIME   237
#define SYS_KTIMER_GETTIME   238
#define SYS_KTIMER_GETOVERRUN   239
#define SYS_NANOSLEEP   240
#define SYS_FFCLOCK_GETCOUNTER   241
#define SYS_FFCLOCK_SETESTIMATE   242
#define SYS_FFCLOCK_GETESTIMATE   243
#define SYS_CLOCK_GETCPUCLOCKID2   247
#define SYS_NTP_GETTIME   248
#define SYS_MINHERIT   250
#define SYS_RFORK   251
#define SYS_OPENBSD_POLL   252
#define SYS_ISSETUGID   253
#define SYS_LCHOWN   254
#define SYS_GETDENTS   272
#define SYS_LCHMOD   274
#define SYS_LUTIMES   276
#define SYS_NSTAT   278
#define SYS_NFSTAT   279
#define SYS_NLSTAT   280
#define SYS_PREADV   289
#define SYS_PWRITEV   290
#define SYS_FHOPEN   298
#define SYS_FHSTAT   299
#define SYS_MODNEXT   300
#define SYS_MODSTAT   301
#define SYS_MODFNEXT   302
#define SYS_MODFIND   303
#define SYS_KLDLOAD   304
#define SYS_KLDUNLOAD   305
#define SYS_KLDFIND   306
#define SYS_KLDNEXT   307
#define SYS_KLDSTAT   308
#define SYS_KLDFIRSTMOD   309
#define SYS_GETSID   310
#define SYS_SETRESUID   311
#define SYS_SETRESGID   312
#define SYS_YIELD   321
#define SYS_MLOCKALL   324
#define SYS_MUNLOCKALL   325
#define SYS___GETCWD   326
#define SYS_SCHED_SETPARAM   327
#define SYS_SCHED_GETPARAM   328
#define SYS_SCHED_SETSCHEDULER   329
#define SYS_SCHED_GETSCHEDULER   330
#define SYS_SCHED_YIELD   331
#define SYS_SCHED_GET_PRIORITY_MAX   332
#define SYS_SCHED_GET_PRIORITY_MIN   333
#define SYS_SCHED_RR_GET_INTERVAL   334
#define SYS_UTRACE   335
#define SYS_KLDSYM   337
#define SYS_JAIL   338
#define SYS_SIGPROCMASK   340
#define SYS_SIGSUSPEND   341
#define SYS_SIGPENDING   343
#define SYS_SIGTIMEDWAIT   345
#define SYS_SIGWAITINFO   346
#define SYS___ACL_GET_FILE   347
#define SYS___ACL_SET_FILE   348
#define SYS___ACL_GET_FD   349
#define SYS___ACL_SET_FD   350
#define SYS___ACL_DELETE_FILE   351
#define SYS___ACL_DELETE_FD   352
#define SYS___ACL_ACLCHECK_FILE   353
#define SYS___ACL_ACLCHECK_FD   354
#define SYS_EXTATTRCTL   355
#define SYS_EXTATTR_SET_FILE   356
#define SYS_EXTATTR_GET_FILE   357
#define SYS_EXTATTR_DELETE_FILE   358
#define SYS_GETRESUID   360
#define SYS_GETRESGID   361
#define SYS_KQUEUE   362
#define SYS_KEVENT   363
#define SYS_EXTATTR_SET_FD   371
#define SYS_EXTATTR_GET_FD   372
#define SYS_EXTATTR_DELETE_FD   373
#define SYS___SETUGID   374
#define SYS_EACCESS   376
#define SYS_NMOUNT   378
#define SYS___MAC_GET_PROC   384
#define SYS___MAC_SET_PROC   385
#define SYS___MAC_GET_FD   386
#define SYS___MAC_GET_FILE   387
#define SYS___MAC_SET_FD   388
#define SYS___MAC_SET_FILE   389
#define SYS_KENV   390
#define SYS_LCHFLAGS   391
#define SYS_UUIDGEN   392
#define SYS_SENDFILE   393
#define SYS_MAC_SYSCALL   394
#define SYS_GETFSSTAT   395
#define SYS_STATFS   396
#define SYS_FSTATFS   397
#define SYS_FHSTATFS   398
#define SYS___MAC_GET_PID   409
#define SYS___MAC_GET_LINK   410
#define SYS___MAC_SET_LINK   411
#define SYS_EXTATTR_SET_LINK   412
#define SYS_EXTATTR_GET_LINK   413
#define SYS_EXTATTR_DELETE_LINK   414
#define SYS___MAC_EXECVE   415
#define SYS_SIGACTION   416
#define SYS_SIGRETURN   417
#define SYS_GETCONTEXT   421
#define SYS_SETCONTEXT   422
#define SYS_SWAPCONTEXT   423
#define SYS_SWAPOFF   424
#define SYS___ACL_GET_LINK   425
#define SYS___ACL_SET_LINK   426
#define SYS___ACL_DELETE_LINK   427
#define SYS___ACL_ACLCHECK_LINK   428
#define SYS_SIGWAIT   429
#define SYS_THR_CREATE   430
#define SYS_THR_EXIT   431
#define SYS_THR_SELF   432
#define SYS_THR_KILL   433
#define SYS__UMTX_LOCK   434
#define SYS__UMTX_UNLOCK   435
#define SYS_JAIL_ATTACH   436
#define SYS_EXTATTR_LIST_FD   437
#define SYS_EXTATTR_LIST_FILE   438
#define SYS_EXTATTR_LIST_LINK   439
#define SYS_THR_SUSPEND   442
#define SYS_THR_WAKE   443
#define SYS_KLDUNLOADF   444
#define SYS_AUDIT   445
#define SYS_AUDITON   446
#define SYS_GETAUID   447
#define SYS_SETAUID   448
#define SYS_GETAUDIT   449
#define SYS_SETAUDIT   450
#define SYS_GETAUDIT_ADDR   451
#define SYS_SETAUDIT_ADDR   452
#define SYS_AUDITCTL   453
#define SYS__UMTX_OP   454
#define SYS_THR_NEW   455
#define SYS_SIGQUEUE   456
#define SYS_ABORT2   463
#define SYS_THR_SET_NAME   464
#define SYS_RTPRIO_THREAD   466
#define SYS_SCTP_PEELOFF   471
#define SYS_SCTP_GENERIC_SENDMSG   472
#define SYS_SCTP_GENERIC_SENDMSG_IOV   473
#define SYS_SCTP_GENERIC_RECVMSG   474
#define SYS_PREAD   475
#define SYS_PWRITE   476
#define SYS_MMAP   477
#define SYS_LSEEK   478
#define SYS_TRUNCATE   479
#define SYS_FTRUNCATE   480
#define SYS_THR_KILL2   481
#define SYS_SHM_OPEN   482
#define SYS_SHM_UNLINK   483
#define SYS_CPUSET   484
#define SYS_CPUSET_SETID   485
#define SYS_CPUSET_GETID   486
#define SYS_CPUSET_GETAFFINITY   487
#define SYS_CPUSET_SETAFFINITY   488
#define SYS_FACCESSAT   489
#define SYS_FCHMODAT   490
#define SYS_FCHOWNAT   491
#define SYS_FEXECVE   492
#define SYS_FSTATAT   493
#define SYS_FUTIMESAT   494
#define SYS_LINKAT   495
#define SYS_MKDIRAT   496
#define SYS_MKFIFOAT   497
#define SYS_MKNODAT   498
#define SYS_OPENAT   499
#define SYS_READLINKAT   500
#define SYS_RENAMEAT   501
#define SYS_SYMLINKAT   502
#define SYS_UNLINKAT   503
#define SYS_POSIX_OPENPT   504
#define SYS_JAIL_GET   506
#define SYS_JAIL_SET   507
#define SYS_JAIL_REMOVE   508
#define SYS_CLOSEFROM   509
#define SYS_LPATHCONF   513
#define SYS_CAP_NEW   514
#define SYS_CAP_GETRIGHTS   515
#define SYS_CAP_ENTER   516
#define SYS_CAP_GETMODE   517
#define SYS_PDFORK   518
#define SYS_PDKILL   519
#define SYS_PDGETPID   520
#define SYS_PSELECT   522
#define SYS_GETLOGINCLASS   523
#define SYS_SETLOGINCLASS   524
#define SYS_RCTL_GET_RACCT   525
#define SYS_RCTL_GET_RULES   526
#define SYS_RCTL_GET_LIMITS   527
#define SYS_RCTL_ADD_RULE   528
#define SYS_RCTL_REMOVE_RULE   529
#define SYS_POSIX_FALLOCATE   530
#define SYS_POSIX_FADVISE   531
#define SYS_WAIT6   532
#define SYS_BINDAT   538
#define SYS_CONNECTAT   539
#define SYS_CHFLAGSAT   540
#define SYS_ACCEPT4   541
#define SYS_PIPE2   542
#define SYS_PROCCTL   544


#elif (defined(OSFREEBSD) && defined(ARCHARM))


#define SYS_NOSYS   0
#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_WAIT4   7
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_OBREAK   17
#define SYS_GETPID   20
#define SYS_MOUNT   21
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_GETGID   47
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGALTSTACK   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_MSYNC   65
#define SYS_VFORK   66
#define SYS_SBRK   69
#define SYS_SSTK   70
#define SYS_OVADVISE   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SETITIMER   83
#define SYS_SWAPON   85
#define SYS_GETITIMER   86
#define SYS_GETDTABLESIZE   89
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_SELECT   93
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_GETTIMEOFDAY   116
#define SYS_GETRUSAGE   117
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_SETTIMEOFDAY   122
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_UTIMES   138
#define SYS_ADJTIME   140
#define SYS_SETSID   147
#define SYS_QUOTACTL   148
#define SYS_LGETFH   160
#define SYS_GETFH   161
#define SYS_SYSARCH   165
#define SYS_RTPRIO   166
#define SYS_FREEBSD6_PREAD   173
#define SYS_FREEBSD6_PWRITE   174
#define SYS_SETFIB   175
#define SYS_NTP_ADJTIME   176
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_STAT   188
#define SYS_FSTAT   189
#define SYS_LSTAT   190
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_GETDIRENTRIES   196
#define SYS_FREEBSD6_MMAP   197
#define SYS_FREEBSD6_LSEEK   199
#define SYS_FREEBSD6_TRUNCATE   200
#define SYS_FREEBSD6_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_FUTIMES   206
#define SYS_GETPGID   207
#define SYS_POLL   209
#define SYS_CLOCK_GETTIME   232
#define SYS_CLOCK_SETTIME   233
#define SYS_CLOCK_GETRES   234
#define SYS_KTIMER_CREATE   235
#define SYS_KTIMER_DELETE   236
#define SYS_KTIMER_SETTIME   237
#define SYS_KTIMER_GETTIME   238
#define SYS_KTIMER_GETOVERRUN   239
#define SYS_NANOSLEEP   240
#define SYS_FFCLOCK_GETCOUNTER   241
#define SYS_FFCLOCK_SETESTIMATE   242
#define SYS_FFCLOCK_GETESTIMATE   243
#define SYS_CLOCK_GETCPUCLOCKID2   247
#define SYS_NTP_GETTIME   248
#define SYS_MINHERIT   250
#define SYS_RFORK   251
#define SYS_OPENBSD_POLL   252
#define SYS_ISSETUGID   253
#define SYS_LCHOWN   254
#define SYS_GETDENTS   272
#define SYS_LCHMOD   274
#define SYS_LUTIMES   276
#define SYS_NSTAT   278
#define SYS_NFSTAT   279
#define SYS_NLSTAT   280
#define SYS_PREADV   289
#define SYS_PWRITEV   290
#define SYS_FHOPEN   298
#define SYS_FHSTAT   299
#define SYS_MODNEXT   300
#define SYS_MODSTAT   301
#define SYS_MODFNEXT   302
#define SYS_MODFIND   303
#define SYS_KLDLOAD   304
#define SYS_KLDUNLOAD   305
#define SYS_KLDFIND   306
#define SYS_KLDNEXT   307
#define SYS_KLDSTAT   308
#define SYS_KLDFIRSTMOD   309
#define SYS_GETSID   310
#define SYS_SETRESUID   311
#define SYS_SETRESGID   312
#define SYS_YIELD   321
#define SYS_MLOCKALL   324
#define SYS_MUNLOCKALL   325
#define SYS___GETCWD   326
#define SYS_SCHED_SETPARAM   327
#define SYS_SCHED_GETPARAM   328
#define SYS_SCHED_SETSCHEDULER   329
#define SYS_SCHED_GETSCHEDULER   330
#define SYS_SCHED_YIELD   331
#define SYS_SCHED_GET_PRIORITY_MAX   332
#define SYS_SCHED_GET_PRIORITY_MIN   333
#define SYS_SCHED_RR_GET_INTERVAL   334
#define SYS_UTRACE   335
#define SYS_KLDSYM   337
#define SYS_JAIL   338
#define SYS_SIGPROCMASK   340
#define SYS_SIGSUSPEND   341
#define SYS_SIGPENDING   343
#define SYS_SIGTIMEDWAIT   345
#define SYS_SIGWAITINFO   346
#define SYS___ACL_GET_FILE   347
#define SYS___ACL_SET_FILE   348
#define SYS___ACL_GET_FD   349
#define SYS___ACL_SET_FD   350
#define SYS___ACL_DELETE_FILE   351
#define SYS___ACL_DELETE_FD   352
#define SYS___ACL_ACLCHECK_FILE   353
#define SYS___ACL_ACLCHECK_FD   354
#define SYS_EXTATTRCTL   355
#define SYS_EXTATTR_SET_FILE   356
#define SYS_EXTATTR_GET_FILE   357
#define SYS_EXTATTR_DELETE_FILE   358
#define SYS_GETRESUID   360
#define SYS_GETRESGID   361
#define SYS_KQUEUE   362
#define SYS_KEVENT   363
#define SYS_EXTATTR_SET_FD   371
#define SYS_EXTATTR_GET_FD   372
#define SYS_EXTATTR_DELETE_FD   373
#define SYS___SETUGID   374
#define SYS_EACCESS   376
#define SYS_NMOUNT   378
#define SYS___MAC_GET_PROC   384
#define SYS___MAC_SET_PROC   385
#define SYS___MAC_GET_FD   386
#define SYS___MAC_GET_FILE   387
#define SYS___MAC_SET_FD   388
#define SYS___MAC_SET_FILE   389
#define SYS_KENV   390
#define SYS_LCHFLAGS   391
#define SYS_UUIDGEN   392
#define SYS_SENDFILE   393
#define SYS_MAC_SYSCALL   394
#define SYS_GETFSSTAT   395
#define SYS_STATFS   396
#define SYS_FSTATFS   397
#define SYS_FHSTATFS   398
#define SYS___MAC_GET_PID   409
#define SYS___MAC_GET_LINK   410
#define SYS___MAC_SET_LINK   411
#define SYS_EXTATTR_SET_LINK   412
#define SYS_EXTATTR_GET_LINK   413
#define SYS_EXTATTR_DELETE_LINK   414
#define SYS___MAC_EXECVE   415
#define SYS_SIGACTION   416
#define SYS_SIGRETURN   417
#define SYS_GETCONTEXT   421
#define SYS_SETCONTEXT   422
#define SYS_SWAPCONTEXT   423
#define SYS_SWAPOFF   424
#define SYS___ACL_GET_LINK   425
#define SYS___ACL_SET_LINK   426
#define SYS___ACL_DELETE_LINK   427
#define SYS___ACL_ACLCHECK_LINK   428
#define SYS_SIGWAIT   429
#define SYS_THR_CREATE   430
#define SYS_THR_EXIT   431
#define SYS_THR_SELF   432
#define SYS_THR_KILL   433
#define SYS__UMTX_LOCK   434
#define SYS__UMTX_UNLOCK   435
#define SYS_JAIL_ATTACH   436
#define SYS_EXTATTR_LIST_FD   437
#define SYS_EXTATTR_LIST_FILE   438
#define SYS_EXTATTR_LIST_LINK   439
#define SYS_THR_SUSPEND   442
#define SYS_THR_WAKE   443
#define SYS_KLDUNLOADF   444
#define SYS_AUDIT   445
#define SYS_AUDITON   446
#define SYS_GETAUID   447
#define SYS_SETAUID   448
#define SYS_GETAUDIT   449
#define SYS_SETAUDIT   450
#define SYS_GETAUDIT_ADDR   451
#define SYS_SETAUDIT_ADDR   452
#define SYS_AUDITCTL   453
#define SYS__UMTX_OP   454
#define SYS_THR_NEW   455
#define SYS_SIGQUEUE   456
#define SYS_ABORT2   463
#define SYS_THR_SET_NAME   464
#define SYS_RTPRIO_THREAD   466
#define SYS_SCTP_PEELOFF   471
#define SYS_SCTP_GENERIC_SENDMSG   472
#define SYS_SCTP_GENERIC_SENDMSG_IOV   473
#define SYS_SCTP_GENERIC_RECVMSG   474
#define SYS_PREAD   475
#define SYS_PWRITE   476
#define SYS_MMAP   477
#define SYS_LSEEK   478
#define SYS_TRUNCATE   479
#define SYS_FTRUNCATE   480
#define SYS_THR_KILL2   481
#define SYS_SHM_OPEN   482
#define SYS_SHM_UNLINK   483
#define SYS_CPUSET   484
#define SYS_CPUSET_SETID   485
#define SYS_CPUSET_GETID   486
#define SYS_CPUSET_GETAFFINITY   487
#define SYS_CPUSET_SETAFFINITY   488
#define SYS_FACCESSAT   489
#define SYS_FCHMODAT   490
#define SYS_FCHOWNAT   491
#define SYS_FEXECVE   492
#define SYS_FSTATAT   493
#define SYS_FUTIMESAT   494
#define SYS_LINKAT   495
#define SYS_MKDIRAT   496
#define SYS_MKFIFOAT   497
#define SYS_MKNODAT   498
#define SYS_OPENAT   499
#define SYS_READLINKAT   500
#define SYS_RENAMEAT   501
#define SYS_SYMLINKAT   502
#define SYS_UNLINKAT   503
#define SYS_POSIX_OPENPT   504
#define SYS_JAIL_GET   506
#define SYS_JAIL_SET   507
#define SYS_JAIL_REMOVE   508
#define SYS_CLOSEFROM   509
#define SYS_LPATHCONF   513
#define SYS_CAP_NEW   514
#define SYS_CAP_GETRIGHTS   515
#define SYS_CAP_ENTER   516
#define SYS_CAP_GETMODE   517
#define SYS_PDFORK   518
#define SYS_PDKILL   519
#define SYS_PDGETPID   520
#define SYS_PSELECT   522
#define SYS_GETLOGINCLASS   523
#define SYS_SETLOGINCLASS   524
#define SYS_RCTL_GET_RACCT   525
#define SYS_RCTL_GET_RULES   526
#define SYS_RCTL_GET_LIMITS   527
#define SYS_RCTL_ADD_RULE   528
#define SYS_RCTL_REMOVE_RULE   529
#define SYS_POSIX_FALLOCATE   530
#define SYS_POSIX_FADVISE   531
#define SYS_WAIT6   532
#define SYS_BINDAT   538
#define SYS_CONNECTAT   539
#define SYS_CHFLAGSAT   540
#define SYS_ACCEPT4   541
#define SYS_PIPE2   542
#define SYS_PROCCTL   544



#elif (defined(OSNETBSD) && (defined(I386) || defined(X86) || defined(X86_64)))


#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_BREAK   17
#define SYS_GETPID   20
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_GETGID   47
#define SYS___GETLOGIN   49
#define SYS___SETLOGIN   50
#define SYS_ACCT   51
#define SYS_IOCTL   54
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_VFORK   66
#define SYS_SBRK   69
#define SYS_SSTK   70
#define SYS_VADVISE   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_SETSID   147
#define SYS_SYSARCH   165
#define SYS_PREAD   173
#define SYS_PWRITE   174
#define SYS_NTP_ADJTIME   176
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_GETPGID   207
#define SYS_REBOOT   208
#define SYS_POLL   209
#define SYS_SEMGET   221
#define SYS_SEMOP   222
#define SYS_SEMCONFIG   223
#define SYS_MSGGET   225
#define SYS_MSGSND   226
#define SYS_MSGRCV   227
#define SYS_SHMAT   228
#define SYS_SHMDT   230
#define SYS_SHMGET   231
#define SYS_TIMER_CREATE   235
#define SYS_TIMER_DELETE   236
#define SYS_TIMER_GETOVERRUN   239
#define SYS_FDATASYNC   241
#define SYS_MLOCKALL   242
#define SYS_MUNLOCKALL   243
#define SYS_SIGQUEUEINFO   245
#define SYS_MODCTL   246
#define SYS___POSIX_RENAME   270
#define SYS_SWAPCTL   271
#define SYS_MINHERIT   273
#define SYS_LCHMOD   274
#define SYS_LCHOWN   275
#define SYS___POSIX_CHOWN   283
#define SYS___POSIX_FCHOWN   284
#define SYS___POSIX_LCHOWN   285
#define SYS_GETSID   286
#define SYS___CLONE   287
#define SYS_FKTRACE   288
#define SYS_PREADV   289
#define SYS_PWRITEV   290
#define SYS___GETCWD   296
#define SYS_FCHROOT   297
#define SYS_LCHFLAGS   304
#define SYS_ISSETUGID   305
#define SYS_UTRACE   306
#define SYS_GETCONTEXT   307
#define SYS_SETCONTEXT   308
#define SYS__LWP_CREATE   309
#define SYS__LWP_EXIT   310
#define SYS__LWP_SELF   311
#define SYS__LWP_WAIT   312
#define SYS__LWP_SUSPEND   313
#define SYS__LWP_CONTINUE   314
#define SYS__LWP_WAKEUP   315
#define SYS__LWP_GETPRIVATE   316
#define SYS__LWP_SETPRIVATE   317
#define SYS__LWP_KILL   318
#define SYS__LWP_DETACH   319
#define SYS__LWP_UNPARK   321
#define SYS__LWP_UNPARK_ALL   322
#define SYS__LWP_SETNAME   323
#define SYS__LWP_GETNAME   324
#define SYS__LWP_CTL   325
#define SYS___SIGACTION_SIGTRAMP   340
#define SYS_PMC_GET_INFO   341
#define SYS_PMC_CONTROL   342
#define SYS_RASCTL   343
#define SYS_KQUEUE   344
#define SYS__SCHED_SETPARAM   346
#define SYS__SCHED_GETPARAM   347
#define SYS__SCHED_SETAFFINITY   348
#define SYS__SCHED_GETAFFINITY   349
#define SYS_SCHED_YIELD   350
#define SYS_FSYNC_RANGE   354
#define SYS_UUIDGEN   355
#define SYS_GETVFSSTAT   356
#define SYS_STATVFS1   357
#define SYS_FSTATVFS1   358
#define SYS_EXTATTRCTL   360
#define SYS_EXTATTR_SET_FILE   361
#define SYS_EXTATTR_GET_FILE   362
#define SYS_EXTATTR_DELETE_FILE   363
#define SYS_EXTATTR_SET_FD   364
#define SYS_EXTATTR_GET_FD   365
#define SYS_EXTATTR_DELETE_FD   366
#define SYS_EXTATTR_SET_LINK   367
#define SYS_EXTATTR_GET_LINK   368
#define SYS_EXTATTR_DELETE_LINK   369
#define SYS_EXTATTR_LIST_FD   370
#define SYS_EXTATTR_LIST_FILE   371
#define SYS_EXTATTR_LIST_LINK   372
#define SYS_SETXATTR   375
#define SYS_LSETXATTR   376
#define SYS_FSETXATTR   377
#define SYS_GETXATTR   378
#define SYS_LGETXATTR   379
#define SYS_FGETXATTR   380
#define SYS_LISTXATTR   381
#define SYS_LLISTXATTR   382
#define SYS_FLISTXATTR   383
#define SYS_REMOVEXATTR   384
#define SYS_LREMOVEXATTR   385
#define SYS_FREMOVEXATTR   386
#define SYS_GETDENTS   390
#define SYS_SOCKET   394
#define SYS_GETFH   395
#define SYS_MOUNT   410
#define SYS_MREMAP   411
#define SYS_PSET_CREATE   412
#define SYS_PSET_DESTROY   413
#define SYS_PSET_ASSIGN   414
#define SYS__PSET_BIND   415
#define SYS_POSIX_FADVISE   416
#define SYS_SELECT   417
#define SYS_GETTIMEOFDAY   418
#define SYS_SETTIMEOFDAY   419
#define SYS_UTIMES   420
#define SYS_ADJTIME   421
#define SYS_FUTIMES   423
#define SYS_LUTIMES   424
#define SYS_SETITIMER   425
#define SYS_GETITIMER   426
#define SYS_CLOCK_GETTIME   427
#define SYS_CLOCK_SETTIME   428
#define SYS_CLOCK_GETRES   429
#define SYS_NANOSLEEP   430
#define SYS___SIGTIMEDWAIT   431
#define SYS__LWP_PARK   434
#define SYS_KEVENT   435
#define SYS_PSELECT   436
#define SYS_POLLTS   437
#define SYS_STAT   439
#define SYS_FSTAT   440
#define SYS_LSTAT   441
#define SYS___SEMCTL   442
#define SYS_SHMCTL   443
#define SYS_MSGCTL   444
#define SYS_GETRUSAGE   445
#define SYS_TIMER_SETTIME   446
#define SYS_TIMER_GETTIME   447
#define SYS_NTP_GETTIME   448
#define SYS_WAIT4   449
#define SYS_MKNOD   450
#define SYS_FHSTAT   451
#define SYS_PIPE2   453
#define SYS_DUP3   454
#define SYS_KQUEUE1   455
#define SYS_PACCEPT   456
#define SYS_LINKAT   457
#define SYS_RENAMEAT   458
#define SYS_MKFIFOAT   459
#define SYS_MKNODAT   460
#define SYS_MKDIRAT   461
#define SYS_FACCESSAT   462
#define SYS_FCHMODAT   463
#define SYS_FCHOWNAT   464
#define SYS_FEXECVE   465
#define SYS_FSTATAT   466
#define SYS_UTIMENSAT   467
#define SYS_OPENAT   468
#define SYS_READLINKAT   469
#define SYS_SYMLINKAT   470
#define SYS_UNLINKAT   471
#define SYS_FUTIMENS   472
#define SYS___QUOTACTL   473
#define SYS_POSIX_SPAWN   474
#define SYS_RECVMMSG   475
#define SYS_SENDMMSG   476


#elif (defined(OSNETBSD) && defined(ARCHARM))


#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_BREAK   17
#define SYS_GETPID   20
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_GETGID   47
#define SYS___GETLOGIN   49
#define SYS___SETLOGIN   50
#define SYS_ACCT   51
#define SYS_IOCTL   54
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_VFORK   66
#define SYS_SBRK   69
#define SYS_SSTK   70
#define SYS_VADVISE   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_SETSID   147
#define SYS_SYSARCH   165
#define SYS_PREAD   173
#define SYS_PWRITE   174
#define SYS_NTP_ADJTIME   176
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_GETPGID   207
#define SYS_REBOOT   208
#define SYS_POLL   209
#define SYS_SEMGET   221
#define SYS_SEMOP   222
#define SYS_SEMCONFIG   223
#define SYS_MSGGET   225
#define SYS_MSGSND   226
#define SYS_MSGRCV   227
#define SYS_SHMAT   228
#define SYS_SHMDT   230
#define SYS_SHMGET   231
#define SYS_TIMER_CREATE   235
#define SYS_TIMER_DELETE   236
#define SYS_TIMER_GETOVERRUN   239
#define SYS_FDATASYNC   241
#define SYS_MLOCKALL   242
#define SYS_MUNLOCKALL   243
#define SYS_SIGQUEUEINFO   245
#define SYS_MODCTL   246
#define SYS___POSIX_RENAME   270
#define SYS_SWAPCTL   271
#define SYS_MINHERIT   273
#define SYS_LCHMOD   274
#define SYS_LCHOWN   275
#define SYS___POSIX_CHOWN   283
#define SYS___POSIX_FCHOWN   284
#define SYS___POSIX_LCHOWN   285
#define SYS_GETSID   286
#define SYS___CLONE   287
#define SYS_FKTRACE   288
#define SYS_PREADV   289
#define SYS_PWRITEV   290
#define SYS___GETCWD   296
#define SYS_FCHROOT   297
#define SYS_LCHFLAGS   304
#define SYS_ISSETUGID   305
#define SYS_UTRACE   306
#define SYS_GETCONTEXT   307
#define SYS_SETCONTEXT   308
#define SYS__LWP_CREATE   309
#define SYS__LWP_EXIT   310
#define SYS__LWP_SELF   311
#define SYS__LWP_WAIT   312
#define SYS__LWP_SUSPEND   313
#define SYS__LWP_CONTINUE   314
#define SYS__LWP_WAKEUP   315
#define SYS__LWP_GETPRIVATE   316
#define SYS__LWP_SETPRIVATE   317
#define SYS__LWP_KILL   318
#define SYS__LWP_DETACH   319
#define SYS__LWP_UNPARK   321
#define SYS__LWP_UNPARK_ALL   322
#define SYS__LWP_SETNAME   323
#define SYS__LWP_GETNAME   324
#define SYS__LWP_CTL   325
#define SYS___SIGACTION_SIGTRAMP   340
#define SYS_PMC_GET_INFO   341
#define SYS_PMC_CONTROL   342
#define SYS_RASCTL   343
#define SYS_KQUEUE   344
#define SYS__SCHED_SETPARAM   346
#define SYS__SCHED_GETPARAM   347
#define SYS__SCHED_SETAFFINITY   348
#define SYS__SCHED_GETAFFINITY   349
#define SYS_SCHED_YIELD   350
#define SYS_FSYNC_RANGE   354
#define SYS_UUIDGEN   355
#define SYS_GETVFSSTAT   356
#define SYS_STATVFS1   357
#define SYS_FSTATVFS1   358
#define SYS_EXTATTRCTL   360
#define SYS_EXTATTR_SET_FILE   361
#define SYS_EXTATTR_GET_FILE   362
#define SYS_EXTATTR_DELETE_FILE   363
#define SYS_EXTATTR_SET_FD   364
#define SYS_EXTATTR_GET_FD   365
#define SYS_EXTATTR_DELETE_FD   366
#define SYS_EXTATTR_SET_LINK   367
#define SYS_EXTATTR_GET_LINK   368
#define SYS_EXTATTR_DELETE_LINK   369
#define SYS_EXTATTR_LIST_FD   370
#define SYS_EXTATTR_LIST_FILE   371
#define SYS_EXTATTR_LIST_LINK   372
#define SYS_SETXATTR   375
#define SYS_LSETXATTR   376
#define SYS_FSETXATTR   377
#define SYS_GETXATTR   378
#define SYS_LGETXATTR   379
#define SYS_FGETXATTR   380
#define SYS_LISTXATTR   381
#define SYS_LLISTXATTR   382
#define SYS_FLISTXATTR   383
#define SYS_REMOVEXATTR   384
#define SYS_LREMOVEXATTR   385
#define SYS_FREMOVEXATTR   386
#define SYS_GETDENTS   390
#define SYS_SOCKET   394
#define SYS_GETFH   395
#define SYS_MOUNT   410
#define SYS_MREMAP   411
#define SYS_PSET_CREATE   412
#define SYS_PSET_DESTROY   413
#define SYS_PSET_ASSIGN   414
#define SYS__PSET_BIND   415
#define SYS_POSIX_FADVISE   416
#define SYS_SELECT   417
#define SYS_GETTIMEOFDAY   418
#define SYS_SETTIMEOFDAY   419
#define SYS_UTIMES   420
#define SYS_ADJTIME   421
#define SYS_FUTIMES   423
#define SYS_LUTIMES   424
#define SYS_SETITIMER   425
#define SYS_GETITIMER   426
#define SYS_CLOCK_GETTIME   427
#define SYS_CLOCK_SETTIME   428
#define SYS_CLOCK_GETRES   429
#define SYS_NANOSLEEP   430
#define SYS___SIGTIMEDWAIT   431
#define SYS__LWP_PARK   434
#define SYS_KEVENT   435
#define SYS_PSELECT   436
#define SYS_POLLTS   437
#define SYS_STAT   439
#define SYS_FSTAT   440
#define SYS_LSTAT   441
#define SYS___SEMCTL   442
#define SYS_SHMCTL   443
#define SYS_MSGCTL   444
#define SYS_GETRUSAGE   445
#define SYS_TIMER_SETTIME   446
#define SYS_TIMER_GETTIME   447
#define SYS_NTP_GETTIME   448
#define SYS_WAIT4   449
#define SYS_MKNOD   450
#define SYS_FHSTAT   451
#define SYS_PIPE2   453
#define SYS_DUP3   454
#define SYS_KQUEUE1   455
#define SYS_PACCEPT   456
#define SYS_LINKAT   457
#define SYS_RENAMEAT   458
#define SYS_MKFIFOAT   459
#define SYS_MKNODAT   460
#define SYS_MKDIRAT   461
#define SYS_FACCESSAT   462
#define SYS_FCHMODAT   463
#define SYS_FCHOWNAT   464
#define SYS_FEXECVE   465
#define SYS_FSTATAT   466
#define SYS_UTIMENSAT   467
#define SYS_OPENAT   468
#define SYS_READLINKAT   469
#define SYS_SYMLINKAT   470
#define SYS_UNLINKAT   471
#define SYS_FUTIMENS   472
#define SYS___QUOTACTL   473
#define SYS_POSIX_SPAWN   474
#define SYS_RECVMMSG   475
#define SYS_SENDMMSG   476


#elif (defined(OSOPENBSD) && (defined(I386) || defined(X86) || defined(X86_64)))


#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS___TFORK   8
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_WAIT4   11
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_OBREAK   17
#define SYS_GETDTABLECOUNT  18
#define SYS_GETRUSAGE   19
#define SYS_GETPID   20
#define SYS_MOUNT   21
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_STAT   38
#define SYS_GETPPID   39
#define SYS_LSTAT   40
#define SYS_DUP   41
#define SYS_FSTATAT   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_SIGACTION   46
#define SYS_GETGID   47
#define SYS_SIGPROCMASK   48
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGPENDING   52
#define SYS_FSTAT   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_GETFSSTAT   62
#define SYS_STATFS   63
#define SYS_FSTATFS   64
#define SYS_FHSTATFS   65
#define SYS_VFORK   66
#define SYS_GETTIMEOFDAY   67
#define SYS_SETTIMEOFDAY   68
#define SYS_SETITIMER   69
#define SYS_GETITIMER   70
#define SYS_SELECT   71
#define SYS_KEVENT   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_UTIMES   76
#define SYS_FUTIMES   77
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_UTIMENSAT   84
#define SYS_FUTIMENS   85
#define SYS_CLOCK_GETTIME   87
#define SYS_CLOCK_SETTIME   88
#define SYS_CLOCK_GETRES   89
#define SYS_DUP2   90
#define SYS_NANOSLEEP   91
#define SYS_FCNTL   92
#define SYS___THRSLEEP   94
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETDENTS   99
#define SYS_GETPRIORITY   100
#define SYS_SIGRETURN   103
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_PPOLL   109
#define SYS_PSELECT   110
#define SYS_SIGSUSPEND   111
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_ADJTIME   140
#define SYS_SETSID   147
#define SYS_QUOTACTL   148
#define SYS_NFSSVC   155
#define SYS_GETFH   161
#define SYS_SYSARCH   165
#define SYS_PREAD   173
#define SYS_PWRITE   174
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_SWAPCTL   193
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_GETPGID   207
#define SYS_UTRACE   209
#define SYS_SEMGET   221
#define SYS_MSGGET   225
#define SYS_MSGSND   226
#define SYS_MSGRCV   227
#define SYS_SHMAT   228
#define SYS_SHMDT   230
#define SYS_MINHERIT   250
#define SYS_POLL   252
#define SYS_ISSETUGID   253
#define SYS_LCHOWN   254
#define SYS_GETSID   255
#define SYS_MSYNC   256
#define SYS_PIPE   263
#define SYS_FHOPEN   264
#define SYS_PREADV   267
#define SYS_PWRITEV   268
#define SYS_KQUEUE   269
#define SYS_MLOCKALL   271
#define SYS_MUNLOCKALL   272
#define SYS_GETRESUID   281
#define SYS_SETRESUID   282
#define SYS_GETRESGID   283
#define SYS_SETRESGID   284
#define SYS_MQUERY   286
#define SYS_CLOSEFROM   287
#define SYS_SIGALTSTACK   288
#define SYS_SHMGET   289
#define SYS_SEMOP   290
#define SYS_FHSTAT   294
#define SYS___SEMCTL   295
#define SYS_SHMCTL   296
#define SYS_MSGCTL   297
#define SYS_SCHED_YIELD   298
#define SYS_GETTHRID   299
#define SYS___THRWAKEUP   301
#define SYS___THREXIT   302
#define SYS___THRSIGDIVERT  303
#define SYS___GETCWD   304
#define SYS_ADJFREQ   305
#define SYS_SETRTABLE   310
#define SYS_GETRTABLE   311
#define SYS_FACCESSAT   313
#define SYS_FCHMODAT   314
#define SYS_FCHOWNAT   315
#define SYS_LINKAT   317
#define SYS_MKDIRAT   318
#define SYS_MKFIFOAT   319
#define SYS_MKNODAT   320
#define SYS_OPENAT   321
#define SYS_READLINKAT   322
#define SYS_RENAMEAT   323
#define SYS_SYMLINKAT   324
#define SYS_UNLINKAT   325
#define SYS___SET_TCB   329
#define SYS___GET_TCB   330


#elif (defined(OSOPENBSD) && defined(ARCHARM))


#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_GETENTROPY   7
#define SYS___TFORK   8
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_WAIT4   11
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_OBREAK   17
#define SYS_GETDTABLECOUNT   18
#define SYS_GETRUSAGE   19
#define SYS_GETPID   20
#define SYS_MOUNT   21
#define SYS_UNMOUNT   22
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_STAT   38
#define SYS_GETPPID   39
#define SYS_LSTAT   40
#define SYS_DUP   41
#define SYS_FSTATAT   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_KTRACE   45
#define SYS_SIGACTION   46
#define SYS_GETGID   47
#define SYS_SIGPROCMASK   48
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGPENDING   52
#define SYS_FSTAT   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_GETFSSTAT   62
#define SYS_STATFS   63
#define SYS_FSTATFS   64
#define SYS_FHSTATFS   65
#define SYS_VFORK   66
#define SYS_GETTIMEOFDAY   67
#define SYS_SETTIMEOFDAY   68
#define SYS_SETITIMER   69
#define SYS_GETITIMER   70
#define SYS_SELECT   71
#define SYS_KEVENT   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_UTIMES   76
#define SYS_FUTIMES   77
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SENDSYSLOG   83
#define SYS_UTIMENSAT   84
#define SYS_FUTIMENS   85
#define SYS_CLOCK_GETTIME   87
#define SYS_CLOCK_SETTIME   88
#define SYS_CLOCK_GETRES   89
#define SYS_DUP2   90
#define SYS_NANOSLEEP   91
#define SYS_FCNTL   92
#define SYS_ACCEPT4   93
#define SYS___THRSLEEP   94
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETDENTS   99
#define SYS_GETPRIORITY   100
#define SYS_PIPE2   101
#define SYS_DUP3   102
#define SYS_SIGRETURN   103
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_CHFLAGSAT   107
#define SYS_PPOLL   109
#define SYS_PSELECT   110
#define SYS_SIGSUSPEND   111
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_ADJTIME   140
#define SYS_SETSID   147
#define SYS_QUOTACTL   148
#define SYS_NFSSVC   155
#define SYS_GETFH   161
#define SYS_SYSARCH   165
#define SYS_PREAD   173
#define SYS_PWRITE   174
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_SWAPCTL   193
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_GETPGID   207
#define SYS_UTRACE   209
#define SYS_SEMGET   221
#define SYS_MSGGET   225
#define SYS_MSGSND   226
#define SYS_MSGRCV   227
#define SYS_SHMAT   228
#define SYS_SHMDT   230
#define SYS_MINHERIT   250
#define SYS_POLL   252
#define SYS_ISSETUGID   253
#define SYS_LCHOWN   254
#define SYS_GETSID   255
#define SYS_MSYNC   256
#define SYS_PIPE   263
#define SYS_FHOPEN   264
#define SYS_PREADV   267
#define SYS_PWRITEV   268
#define SYS_KQUEUE   269
#define SYS_MLOCKALL   271
#define SYS_MUNLOCKALL   272
#define SYS_GETRESUID   281
#define SYS_SETRESUID   282
#define SYS_GETRESGID   283
#define SYS_SETRESGID   284
#define SYS_MQUERY   286
#define SYS_CLOSEFROM   287
#define SYS_SIGALTSTACK   288
#define SYS_SHMGET   289
#define SYS_SEMOP   290
#define SYS_FHSTAT   294
#define SYS___SEMCTL   295
#define SYS_SHMCTL   296
#define SYS_MSGCTL   297
#define SYS_SCHED_YIELD   298
#define SYS_GETTHRID   299
#define SYS___THRWAKEUP   301
#define SYS___THREXIT   302
#define SYS___THRSIGDIVERT   303
#define SYS___GETCWD   304
#define SYS_ADJFREQ   305
#define SYS_SETRTABLE   310
#define SYS_GETRTABLE   311
#define SYS_FACCESSAT   313
#define SYS_FCHMODAT   314
#define SYS_FCHOWNAT   315
#define SYS_LINKAT   317
#define SYS_MKDIRAT   318
#define SYS_MKFIFOAT   319
#define SYS_MKNODAT   320
#define SYS_OPENAT   321
#define SYS_READLINKAT   322
#define SYS_RENAMEAT   323
#define SYS_SYMLINKAT   324
#define SYS_UNLINKAT   325
#define SYS___SET_TCB   329
#define SYS___GET_TCB   330


#elif (defined(OSDARWIN) && (defined(I386) || defined(X86) || defined(X86_64)))


#define SYS_SYSCALL   0
#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_WAIT4   7
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_GETFSSTAT   18
#define SYS_GETPID   20
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_SIGACTION   46
#define SYS_GETGID   47
#define SYS_SIGPROCMASK   48
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGPENDING   52
#define SYS_SIGALTSTACK   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_MSYNC   65
#define SYS_VFORK   66
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SETITIMER   83
#define SYS_SWAPON   85
#define SYS_GETITIMER   86
#define SYS_GETDTABLESIZE   89
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_SELECT   93
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_SIGSUSPEND   111
#define SYS_GETTIMEOFDAY   116
#define SYS_GETRUSAGE   117
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_SETTIMEOFDAY   122
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_UTIMES   138
#define SYS_FUTIMES   139
#define SYS_ADJTIME   140
#define SYS_GETHOSTUUID   142
#define SYS_SETSID   147
#define SYS_GETPGID   151
#define SYS_SETPRIVEXEC   152
#define SYS_PREAD   153
#define SYS_PWRITE   154
#define SYS_NFSSVC   155
#define SYS_STATFS   157
#define SYS_FSTATFS   158
#define SYS_UNMOUNT   159
#define SYS_GETFH   161
#define SYS_QUOTACTL   165
#define SYS_MOUNT   167
#define SYS_CSOPS   169
#define SYS_WAITID   173
#define SYS_ADD_PROFIL   176
#define SYS_KDEBUG_TRACE   180
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_SIGRETURN   184
#define SYS_CHUD   185
#define SYS_FDATASYNC   187
#define SYS_STAT   188
#define SYS_FSTAT   189
#define SYS_LSTAT   190
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_GETDIRENTRIES   196
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_ATSOCKET   206
#define SYS_ATGETMSG   207
#define SYS_ATPUTMSG   208
#define SYS_ATPSNDREQ   209
#define SYS_ATPSNDRSP   210
#define SYS_ATPGETREQ   211
#define SYS_ATPGETRSP   212
#define SYS_MKCOMPLEX   216
#define SYS_STATV   217
#define SYS_LSTATV   218
#define SYS_FSTATV   219
#define SYS_GETATTRLIST   220
#define SYS_SETATTRLIST   221
#define SYS_GETDIRENTRIESATTR   222
#define SYS_EXCHANGEDATA   223
#define SYS_SEARCHFS   225
#define SYS_DELETE   226
#define SYS_COPYFILE   227
#define SYS_FGETATTRLIST   228
#define SYS_FSETATTRLIST   229
#define SYS_POLL   230
#define SYS_WATCHEVENT   231
#define SYS_WAITEVENT   232
#define SYS_MODWATCH   233
#define SYS_GETXATTR   234
#define SYS_FGETXATTR   235
#define SYS_SETXATTR   236
#define SYS_FSETXATTR   237
#define SYS_REMOVEXATTR   238
#define SYS_FREMOVEXATTR   239
#define SYS_LISTXATTR   240
#define SYS_FLISTXATTR   241
#define SYS_FSCTL   242
#define SYS_INITGROUPS   243
#define SYS_POSIX_SPAWN   244
#define SYS_FFSCTL   245
#define SYS_NFSCLNT   247
#define SYS_FHOPEN   248
#define SYS_MINHERIT   250
#define SYS_SEMSYS   251
#define SYS_MSGSYS   252
#define SYS_SHMSYS   253
#define SYS_SEMCTL   254
#define SYS_SEMGET   255
#define SYS_SEMOP   256
#define SYS_MSGCTL   258
#define SYS_MSGGET   259
#define SYS_MSGSND   260
#define SYS_MSGRCV   261
#define SYS_SHMAT   262
#define SYS_SHMCTL   263
#define SYS_SHMDT   264
#define SYS_SHMGET   265
#define SYS_SHM_OPEN   266
#define SYS_SHM_UNLINK   267
#define SYS_SEM_OPEN   268
#define SYS_SEM_CLOSE   269
#define SYS_SEM_UNLINK   270
#define SYS_SEM_WAIT   271
#define SYS_SEM_TRYWAIT   272
#define SYS_SEM_POST   273
#define SYS_SEM_GETVALUE   274
#define SYS_SEM_INIT   275
#define SYS_SEM_DESTROY   276
#define SYS_OPEN_EXTENDED   277
#define SYS_UMASK_EXTENDED   278
#define SYS_STAT_EXTENDED   279
#define SYS_LSTAT_EXTENDED   280
#define SYS_FSTAT_EXTENDED   281
#define SYS_CHMOD_EXTENDED   282
#define SYS_FCHMOD_EXTENDED   283
#define SYS_ACCESS_EXTENDED   284
#define SYS_SETTID   285
#define SYS_GETTID   286
#define SYS_SETSGROUPS   287
#define SYS_GETSGROUPS   288
#define SYS_SETWGROUPS   289
#define SYS_GETWGROUPS   290
#define SYS_MKFIFO_EXTENDED   291
#define SYS_MKDIR_EXTENDED   292
#define SYS_IDENTITYSVC   293
#define SYS_SHARED_REGION_CHECK_NP   294
#define SYS_VM_PRESSURE_MONITOR   296
#define SYS_PSYNCH_RW_LONGRDLOCK   297
#define SYS_PSYNCH_RW_YIELDWRLOCK   298
#define SYS_PSYNCH_RW_DOWNGRADE   299
#define SYS_PSYNCH_RW_UPGRADE   300
#define SYS_PSYNCH_MUTEXWAIT   301
#define SYS_PSYNCH_MUTEXDROP   302
#define SYS_PSYNCH_CVBROAD   303
#define SYS_PSYNCH_CVSIGNAL   304
#define SYS_PSYNCH_CVWAIT   305
#define SYS_PSYNCH_RW_RDLOCK   306
#define SYS_PSYNCH_RW_WRLOCK   307
#define SYS_PSYNCH_RW_UNLOCK   308
#define SYS_PSYNCH_RW_UNLOCK2   309
#define SYS_GETSID   310
#define SYS_SETTID_WITH_PID   311
#define SYS_PSYNCH_CVCLRPREPOST   312
#define SYS_AIO_FSYNC   313
#define SYS_AIO_RETURN   314
#define SYS_AIO_SUSPEND   315
#define SYS_AIO_CANCEL   316
#define SYS_AIO_ERROR   317
#define SYS_AIO_READ   318
#define SYS_AIO_WRITE   319
#define SYS_LIO_LISTIO   320
#define SYS_IOPOLICYSYS   322
#define SYS_PROCESS_POLICY   323
#define SYS_MLOCKALL   324
#define SYS_MUNLOCKALL   325
#define SYS_ISSETUGID   327
#define SYS___PTHREAD_KILL   328
#define SYS___PTHREAD_SIGMASK   329
#define SYS___SIGWAIT   330
#define SYS___DISABLE_THREADSIGNAL   331
#define SYS___PTHREAD_MARKCANCEL   332
#define SYS___PTHREAD_CANCELED   333
#define SYS___SEMWAIT_SIGNAL   334
#define SYS_PROC_INFO   336
#define SYS_SENDFILE   337
#define SYS_STAT64   338
#define SYS_FSTAT64   339
#define SYS_LSTAT64   340
#define SYS_STAT64_EXTENDED   341
#define SYS_LSTAT64_EXTENDED   342
#define SYS_FSTAT64_EXTENDED   343
#define SYS_GETDIRENTRIES64   344
#define SYS_STATFS64   345
#define SYS_FSTATFS64   346
#define SYS_GETFSSTAT64   347
#define SYS___PTHREAD_CHDIR   348
#define SYS___PTHREAD_FCHDIR   349
#define SYS_AUDIT   350
#define SYS_AUDITON   351
#define SYS_GETAUID   353
#define SYS_SETAUID   354
#define SYS_GETAUDIT   355
#define SYS_SETAUDIT   356
#define SYS_GETAUDIT_ADDR   357
#define SYS_SETAUDIT_ADDR   358
#define SYS_AUDITCTL   359
#define SYS_BSDTHREAD_CREATE   360
#define SYS_BSDTHREAD_TERMINATE   361
#define SYS_KQUEUE   362
#define SYS_KEVENT   363
#define SYS_LCHOWN   364
#define SYS_STACK_SNAPSHOT   365
#define SYS_BSDTHREAD_REGISTER   366
#define SYS_WORKQ_OPEN   367
#define SYS_WORKQ_KERNRETURN   368
#define SYS_KEVENT64   369
#define SYS___OLD_SEMWAIT_SIGNAL   370
#define SYS___OLD_SEMWAIT_SIGNAL_NOCANCEL   371
#define SYS_THREAD_SELFID   372
#define SYS___MAC_EXECVE   380
#define SYS___MAC_SYSCALL   381
#define SYS___MAC_GET_FILE   382
#define SYS___MAC_SET_FILE   383
#define SYS___MAC_GET_LINK   384
#define SYS___MAC_SET_LINK   385
#define SYS___MAC_GET_PROC   386
#define SYS___MAC_SET_PROC   387
#define SYS___MAC_GET_FD   388
#define SYS___MAC_SET_FD   389
#define SYS___MAC_GET_PID   390
#define SYS___MAC_GET_LCID   391
#define SYS___MAC_GET_LCTX   392
#define SYS___MAC_SET_LCTX   393
#define SYS_SETLCID   394
#define SYS_GETLCID   395
#define SYS_READ_NOCANCEL   396
#define SYS_WRITE_NOCANCEL   397
#define SYS_OPEN_NOCANCEL   398
#define SYS_CLOSE_NOCANCEL   399
#define SYS_WAIT4_NOCANCEL   400
#define SYS_RECVMSG_NOCANCEL   401
#define SYS_SENDMSG_NOCANCEL   402
#define SYS_RECVFROM_NOCANCEL   403
#define SYS_ACCEPT_NOCANCEL   404
#define SYS_MSYNC_NOCANCEL   405
#define SYS_FCNTL_NOCANCEL   406
#define SYS_SELECT_NOCANCEL   407
#define SYS_FSYNC_NOCANCEL   408
#define SYS_CONNECT_NOCANCEL   409
#define SYS_SIGSUSPEND_NOCANCEL   410
#define SYS_READV_NOCANCEL   411
#define SYS_WRITEV_NOCANCEL   412
#define SYS_SENDTO_NOCANCEL   413
#define SYS_PREAD_NOCANCEL   414
#define SYS_PWRITE_NOCANCEL   415
#define SYS_WAITID_NOCANCEL   416
#define SYS_POLL_NOCANCEL   417
#define SYS_MSGSND_NOCANCEL   418
#define SYS_MSGRCV_NOCANCEL   419
#define SYS_SEM_WAIT_NOCANCEL   420
#define SYS_AIO_SUSPEND_NOCANCEL   421
#define SYS___SIGWAIT_NOCANCEL   422
#define SYS___SEMWAIT_SIGNAL_NOCANCEL   423
#define SYS___MAC_MOUNT   424
#define SYS___MAC_GET_MOUNT   425
#define SYS___MAC_GETFSSTAT   426
#define SYS_FSGETPATH   427
#define SYS_AUDIT_SESSION_SELF   428
#define SYS_AUDIT_SESSION_JOIN   429
#define SYS_FILEPORT_MAKEPORT   430
#define SYS_FILEPORT_MAKEFD   431
#define SYS_AUDIT_SESSION_PORT   432
#define SYS_PID_SUSPEND   433
#define SYS_PID_RESUME   434
#define SYS_PID_HIBERNATE   435
#define SYS_PID_SHUTDOWN_SOCKETS   436
#define SYS_SHARED_REGION_MAP_AND_SLIDE_NP   438
#define SYS_MAXSYSCALL   439


#elif (defined(OSDARWIN) && defined(ARCHARM64))


#define SYS_SYSCALL   0
#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_WAIT4   7
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_GETFSSTAT   18
#define SYS_GETPID   20
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_SIGACTION   46
#define SYS_GETGID   47
#define SYS_SIGPROCMASK   48
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGPENDING   52
#define SYS_SIGALTSTACK   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_MSYNC   65
#define SYS_VFORK   66
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SETITIMER   83
#define SYS_SWAPON   85
#define SYS_GETITIMER   86
#define SYS_GETDTABLESIZE   89
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_SELECT   93
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_SIGSUSPEND   111
#define SYS_GETTIMEOFDAY   116
#define SYS_GETRUSAGE   117
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_SETTIMEOFDAY   122
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_UTIMES   138
#define SYS_FUTIMES   139
#define SYS_ADJTIME   140
#define SYS_GETHOSTUUID   142
#define SYS_SETSID   147
#define SYS_GETPGID   151
#define SYS_SETPRIVEXEC   152
#define SYS_PREAD   153
#define SYS_PWRITE   154
#define SYS_NFSSVC   155
#define SYS_STATFS   157
#define SYS_FSTATFS   158
#define SYS_UNMOUNT   159
#define SYS_GETFH   161
#define SYS_QUOTACTL   165
#define SYS_MOUNT   167
#define SYS_CSOPS   169
#define SYS_CSOPS_AUDITTOKEN   170
#define SYS_WAITID   173
#define SYS_KDEBUG_TRACE   180
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_SIGRETURN   184
#define SYS_CHUD   185
#define SYS_FDATASYNC   187
#define SYS_STAT   188
#define SYS_FSTAT   189
#define SYS_LSTAT   190
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_GETDIRENTRIES   196
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_ATSOCKET   206
#define SYS_ATGETMSG   207
#define SYS_ATPUTMSG   208
#define SYS_ATPSNDREQ   209
#define SYS_ATPSNDRSP   210
#define SYS_ATPGETREQ   211
#define SYS_ATPGETRSP   212
#define SYS_OPEN_DPROTECTED_NP   216
#define SYS_GETATTRLIST   220
#define SYS_SETATTRLIST   221
#define SYS_GETDIRENTRIESATTR   222
#define SYS_EXCHANGEDATA   223
#define SYS_SEARCHFS   225
#define SYS_DELETE   226
#define SYS_COPYFILE   227
#define SYS_FGETATTRLIST   228
#define SYS_FSETATTRLIST   229
#define SYS_POLL   230
#define SYS_WATCHEVENT   231
#define SYS_WAITEVENT   232
#define SYS_MODWATCH   233
#define SYS_GETXATTR   234
#define SYS_FGETXATTR   235
#define SYS_SETXATTR   236
#define SYS_FSETXATTR   237
#define SYS_REMOVEXATTR   238
#define SYS_FREMOVEXATTR   239
#define SYS_LISTXATTR   240
#define SYS_FLISTXATTR   241
#define SYS_FSCTL   242
#define SYS_INITGROUPS   243
#define SYS_POSIX_SPAWN   244
#define SYS_FFSCTL   245
#define SYS_NFSCLNT   247
#define SYS_FHOPEN   248
#define SYS_MINHERIT   250
#define SYS_SEMSYS   251
#define SYS_MSGSYS   252
#define SYS_SHMSYS   253
#define SYS_SEMCTL   254
#define SYS_SEMGET   255
#define SYS_SEMOP   256
#define SYS_MSGCTL   258
#define SYS_MSGGET   259
#define SYS_MSGSND   260
#define SYS_MSGRCV   261
#define SYS_SHMAT   262
#define SYS_SHMCTL   263
#define SYS_SHMDT   264
#define SYS_SHMGET   265
#define SYS_SHM_OPEN   266
#define SYS_SHM_UNLINK   267
#define SYS_SEM_OPEN   268
#define SYS_SEM_CLOSE   269
#define SYS_SEM_UNLINK   270
#define SYS_SEM_WAIT   271
#define SYS_SEM_TRYWAIT   272
#define SYS_SEM_POST   273
#define SYS_SEM_GETVALUE   274
#define SYS_SEM_INIT   275
#define SYS_SEM_DESTROY   276
#define SYS_OPEN_EXTENDED   277
#define SYS_UMASK_EXTENDED   278
#define SYS_STAT_EXTENDED   279
#define SYS_LSTAT_EXTENDED   280
#define SYS_FSTAT_EXTENDED   281
#define SYS_CHMOD_EXTENDED   282
#define SYS_FCHMOD_EXTENDED   283
#define SYS_ACCESS_EXTENDED   284
#define SYS_SETTID   285
#define SYS_GETTID   286
#define SYS_SETSGROUPS   287
#define SYS_GETSGROUPS   288
#define SYS_SETWGROUPS   289
#define SYS_GETWGROUPS   290
#define SYS_MKFIFO_EXTENDED   291
#define SYS_MKDIR_EXTENDED   292
#define SYS_IDENTITYSVC   293
#define SYS_SHARED_REGION_CHECK_NP   294
#define SYS_VM_PRESSURE_MONITOR   296
#define SYS_PSYNCH_RW_LONGRDLOCK   297
#define SYS_PSYNCH_RW_YIELDWRLOCK   298
#define SYS_PSYNCH_RW_DOWNGRADE   299
#define SYS_PSYNCH_RW_UPGRADE   300
#define SYS_PSYNCH_MUTEXWAIT   301
#define SYS_PSYNCH_MUTEXDROP   302
#define SYS_PSYNCH_CVBROAD   303
#define SYS_PSYNCH_CVSIGNAL   304
#define SYS_PSYNCH_CVWAIT   305
#define SYS_PSYNCH_RW_RDLOCK   306
#define SYS_PSYNCH_RW_WRLOCK   307
#define SYS_PSYNCH_RW_UNLOCK   308
#define SYS_PSYNCH_RW_UNLOCK2   309
#define SYS_GETSID   310
#define SYS_SETTID_WITH_PID   311
#define SYS_PSYNCH_CVCLRPREPOST   312
#define SYS_AIO_FSYNC   313
#define SYS_AIO_RETURN   314
#define SYS_AIO_SUSPEND   315
#define SYS_AIO_CANCEL   316
#define SYS_AIO_ERROR   317
#define SYS_AIO_READ   318
#define SYS_AIO_WRITE   319
#define SYS_LIO_LISTIO   320
#define SYS_IOPOLICYSYS   322
#define SYS_PROCESS_POLICY   323
#define SYS_MLOCKALL   324
#define SYS_MUNLOCKALL   325
#define SYS_ISSETUGID   327
#define SYS___PTHREAD_KILL   328
#define SYS___PTHREAD_SIGMASK   329
#define SYS___SIGWAIT   330
#define SYS___DISABLE_THREADSIGNAL   331
#define SYS___PTHREAD_MARKCANCEL   332
#define SYS___PTHREAD_CANCELED   333
#define SYS___SEMWAIT_SIGNAL   334
#define SYS_PROC_INFO   336
#define SYS_SENDFILE   337
#define SYS_STAT64   338
#define SYS_FSTAT64   339
#define SYS_LSTAT64   340
#define SYS_STAT64_EXTENDED   341
#define SYS_LSTAT64_EXTENDED   342
#define SYS_FSTAT64_EXTENDED   343
#define SYS_GETDIRENTRIES64   344
#define SYS_STATFS64   345
#define SYS_FSTATFS64   346
#define SYS_GETFSSTAT64   347
#define SYS___PTHREAD_CHDIR   348
#define SYS___PTHREAD_FCHDIR   349
#define SYS_AUDIT   350
#define SYS_AUDITON   351
#define SYS_GETAUID   353
#define SYS_SETAUID   354
#define SYS_GETAUDIT_ADDR   357
#define SYS_SETAUDIT_ADDR   358
#define SYS_AUDITCTL   359
#define SYS_BSDTHREAD_CREATE   360
#define SYS_BSDTHREAD_TERMINATE   361
#define SYS_KQUEUE   362
#define SYS_KEVENT   363
#define SYS_LCHOWN   364
#define SYS_STACK_SNAPSHOT   365
#define SYS_BSDTHREAD_REGISTER   366
#define SYS_WORKQ_OPEN   367
#define SYS_WORKQ_KERNRETURN   368
#define SYS_KEVENT64   369
#define SYS___OLD_SEMWAIT_SIGNAL   370
#define SYS___OLD_SEMWAIT_SIGNAL_NOCANCEL   371
#define SYS_THREAD_SELFID   372
#define SYS_LEDGER   373
#define SYS___MAC_EXECVE   380
#define SYS___MAC_SYSCALL   381
#define SYS___MAC_GET_FILE   382
#define SYS___MAC_SET_FILE   383
#define SYS___MAC_GET_LINK   384
#define SYS___MAC_SET_LINK   385
#define SYS___MAC_GET_PROC   386
#define SYS___MAC_SET_PROC   387
#define SYS___MAC_GET_FD   388
#define SYS___MAC_SET_FD   389
#define SYS___MAC_GET_PID   390
#define SYS___MAC_GET_LCID   391
#define SYS___MAC_GET_LCTX   392
#define SYS___MAC_SET_LCTX   393
#define SYS_SETLCID   394
#define SYS_GETLCID   395
#define SYS_READ_NOCANCEL   396
#define SYS_WRITE_NOCANCEL   397
#define SYS_OPEN_NOCANCEL   398
#define SYS_CLOSE_NOCANCEL   399
#define SYS_WAIT4_NOCANCEL   400
#define SYS_RECVMSG_NOCANCEL   401
#define SYS_SENDMSG_NOCANCEL   402
#define SYS_RECVFROM_NOCANCEL   403
#define SYS_ACCEPT_NOCANCEL   404
#define SYS_MSYNC_NOCANCEL   405
#define SYS_FCNTL_NOCANCEL   406
#define SYS_SELECT_NOCANCEL   407
#define SYS_FSYNC_NOCANCEL   408
#define SYS_CONNECT_NOCANCEL   409
#define SYS_SIGSUSPEND_NOCANCEL   410
#define SYS_READV_NOCANCEL   411
#define SYS_WRITEV_NOCANCEL   412
#define SYS_SENDTO_NOCANCEL   413
#define SYS_PREAD_NOCANCEL   414
#define SYS_PWRITE_NOCANCEL   415
#define SYS_WAITID_NOCANCEL   416
#define SYS_POLL_NOCANCEL   417
#define SYS_MSGSND_NOCANCEL   418
#define SYS_MSGRCV_NOCANCEL   419
#define SYS_SEM_WAIT_NOCANCEL   420
#define SYS_AIO_SUSPEND_NOCANCEL   421
#define SYS___SIGWAIT_NOCANCEL   422
#define SYS___SEMWAIT_SIGNAL_NOCANCEL   423
#define SYS___MAC_MOUNT   424
#define SYS___MAC_GET_MOUNT   425
#define SYS___MAC_GETFSSTAT   426
#define SYS_FSGETPATH   427
#define SYS_AUDIT_SESSION_SELF   428
#define SYS_AUDIT_SESSION_JOIN   429
#define SYS_FILEPORT_MAKEPORT   430
#define SYS_FILEPORT_MAKEFD   431
#define SYS_AUDIT_SESSION_PORT   432
#define SYS_PID_SUSPEND   433
#define SYS_PID_RESUME   434
#define SYS_PID_HIBERNATE   435
#define SYS_PID_SHUTDOWN_SOCKETS   436
#define SYS_SHARED_REGION_MAP_AND_SLIDE_NP   438
#define SYS_KAS_INFO   439
#define SYS_MAXSYSCALL   440


#elif (defined(OSDARWIN) && defined(ARCHARM))


#define SYS_SYSCALL   0
#define SYS_EXIT   1
#define SYS_FORK   2
#define SYS_READ   3
#define SYS_WRITE   4
#define SYS_OPEN   5
#define SYS_CLOSE   6
#define SYS_WAIT4   7
#define SYS_LINK   9
#define SYS_UNLINK   10
#define SYS_CHDIR   12
#define SYS_FCHDIR   13
#define SYS_MKNOD   14
#define SYS_CHMOD   15
#define SYS_CHOWN   16
#define SYS_OBREAK   17
#define SYS_OGETFSSTAT   18
#define SYS_GETFSSTAT   18
#define SYS_GETPID   20
#define SYS_SETUID   23
#define SYS_GETUID   24
#define SYS_GETEUID   25
#define SYS_PTRACE   26
#define SYS_RECVMSG   27
#define SYS_SENDMSG   28
#define SYS_RECVFROM   29
#define SYS_ACCEPT   30
#define SYS_GETPEERNAME   31
#define SYS_GETSOCKNAME   32
#define SYS_ACCESS   33
#define SYS_CHFLAGS   34
#define SYS_FCHFLAGS   35
#define SYS_SYNC   36
#define SYS_KILL   37
#define SYS_GETPPID   39
#define SYS_DUP   41
#define SYS_PIPE   42
#define SYS_GETEGID   43
#define SYS_PROFIL   44
#define SYS_SIGACTION   46
#define SYS_GETGID   47
#define SYS_SIGPROCMASK   48
#define SYS_GETLOGIN   49
#define SYS_SETLOGIN   50
#define SYS_ACCT   51
#define SYS_SIGPENDING   52
#define SYS_SIGALTSTACK   53
#define SYS_IOCTL   54
#define SYS_REBOOT   55
#define SYS_REVOKE   56
#define SYS_SYMLINK   57
#define SYS_READLINK   58
#define SYS_EXECVE   59
#define SYS_UMASK   60
#define SYS_CHROOT   61
#define SYS_MSYNC   65
#define SYS_VFORK   66
#define SYS_SBRK   69
#define SYS_SSTK   70
#define SYS_OVADVISE   72
#define SYS_MUNMAP   73
#define SYS_MPROTECT   74
#define SYS_MADVISE   75
#define SYS_MINCORE   78
#define SYS_GETGROUPS   79
#define SYS_SETGROUPS   80
#define SYS_GETPGRP   81
#define SYS_SETPGID   82
#define SYS_SETITIMER   83
#define SYS_SWAPON   85
#define SYS_GETITIMER   86
#define SYS_GETDTABLESIZE   89
#define SYS_DUP2   90
#define SYS_FCNTL   92
#define SYS_SELECT   93
#define SYS_FSYNC   95
#define SYS_SETPRIORITY   96
#define SYS_SOCKET   97
#define SYS_CONNECT   98
#define SYS_GETPRIORITY   100
#define SYS_BIND   104
#define SYS_SETSOCKOPT   105
#define SYS_LISTEN   106
#define SYS_SIGSUSPEND   111
#define SYS_GETTIMEOFDAY   116
#define SYS_GETRUSAGE   117
#define SYS_GETSOCKOPT   118
#define SYS_READV   120
#define SYS_WRITEV   121
#define SYS_SETTIMEOFDAY   122
#define SYS_FCHOWN   123
#define SYS_FCHMOD   124
#define SYS_SETREUID   126
#define SYS_SETREGID   127
#define SYS_RENAME   128
#define SYS_FLOCK   131
#define SYS_MKFIFO   132
#define SYS_SENDTO   133
#define SYS_SHUTDOWN   134
#define SYS_SOCKETPAIR   135
#define SYS_MKDIR   136
#define SYS_RMDIR   137
#define SYS_UTIMES   138
#define SYS_FUTIMES   139
#define SYS_ADJTIME   140
#define SYS_GETHOSTUUID   142
#define SYS_SETSID   147
#define SYS_GETPGID   151
#define SYS_SETPRIVEXEC   152
#define SYS_PREAD   153
#define SYS_PWRITE   154
#define SYS_NFSSVC   155
#define SYS_STATFS   157
#define SYS_FSTATFS   158
#define SYS_UNMOUNT   159
#define SYS_GETFH   161
#define SYS_QUOTACTL   165
#define SYS_MOUNT   167
#define SYS_CSOPS   169
#define SYS_TABLE   170
#define SYS_WAITID   173
#define SYS_ADD_PROFIL   176
#define SYS_KDEBUG_TRACE   180
#define SYS_SETGID   181
#define SYS_SETEGID   182
#define SYS_SETEUID   183
#define SYS_SIGRETURN   184
#define SYS_CHUD   185
#define SYS_STAT   188
#define SYS_FSTAT   189
#define SYS_LSTAT   190
#define SYS_PATHCONF   191
#define SYS_FPATHCONF   192
#define SYS_GETRLIMIT   194
#define SYS_SETRLIMIT   195
#define SYS_GETDIRENTRIES   196
#define SYS_MMAP   197
#define SYS_LSEEK   199
#define SYS_TRUNCATE   200
#define SYS_FTRUNCATE   201
#define SYS___SYSCTL   202
#define SYS_MLOCK   203
#define SYS_MUNLOCK   204
#define SYS_UNDELETE   205
#define SYS_ATSOCKET   206
#define SYS_ATGETMSG   207
#define SYS_ATPUTMSG   208
#define SYS_ATPSNDREQ   209
#define SYS_ATPSNDRSP   210
#define SYS_ATPGETREQ   211
#define SYS_ATPGETRSP   212
#define SYS_KQUEUE_FROM_PORTSET_NP   214
#define SYS_KQUEUE_PORTSET_NP   215
#define SYS_MKCOMPLEX   216
#define SYS_STATV   217
#define SYS_LSTATV   218
#define SYS_FSTATV   219
#define SYS_GETATTRLIST   220
#define SYS_SETATTRLIST   221
#define SYS_GETDIRENTRIESATTR   222
#define SYS_EXCHANGEDATA   223
#define SYS_SEARCHFS   225
#define SYS_DELETE   226
#define SYS_COPYFILE   227
#define SYS_POLL   230
#define SYS_WATCHEVENT   231
#define SYS_WAITEVENT   232
#define SYS_MODWATCH   233
#define SYS_GETXATTR   234
#define SYS_FGETXATTR   235
#define SYS_SETXATTR   236
#define SYS_FSETXATTR   237
#define SYS_REMOVEXATTR   238
#define SYS_FREMOVEXATTR   239
#define SYS_LISTXATTR   240
#define SYS_FLISTXATTR   241
#define SYS_FSCTL   242
#define SYS_INITGROUPS   243
#define SYS_POSIX_SPAWN   244
#define SYS_NFSCLNT   247
#define SYS_FHOPEN   248
#define SYS_MINHERIT   250
#define SYS_SEMSYS   251
#define SYS_MSGSYS   252
#define SYS_SHMSYS   253
#define SYS_SEMCTL   254
#define SYS_SEMGET   255
#define SYS_SEMOP   256
#define SYS_MSGCTL   258
#define SYS_MSGGET   259
#define SYS_MSGSND   260
#define SYS_MSGRCV   261
#define SYS_SHMAT   262
#define SYS_SHMCTL   263
#define SYS_SHMDT   264
#define SYS_SHMGET   265
#define SYS_SHM_OPEN   266
#define SYS_SHM_UNLINK   267
#define SYS_SEM_OPEN   268
#define SYS_SEM_CLOSE   269
#define SYS_SEM_UNLINK   270
#define SYS_SEM_WAIT   271
#define SYS_SEM_TRYWAIT   272
#define SYS_SEM_POST   273
#define SYS_SEM_GETVALUE   274
#define SYS_SEM_INIT   275
#define SYS_SEM_DESTROY   276
#define SYS_OPEN_EXTENDED   277
#define SYS_UMASK_EXTENDED   278
#define SYS_STAT_EXTENDED   279
#define SYS_LSTAT_EXTENDED   280
#define SYS_FSTAT_EXTENDED   281
#define SYS_CHMOD_EXTENDED   282
#define SYS_FCHMOD_EXTENDED   283
#define SYS_ACCESS_EXTENDED   284
#define SYS_SETTID   285
#define SYS_GETTID   286
#define SYS_SETSGROUPS   287
#define SYS_GETSGROUPS   288
#define SYS_SETWGROUPS   289
#define SYS_GETWGROUPS   290
#define SYS_MKFIFO_EXTENDED   291
#define SYS_MKDIR_EXTENDED   292
#define SYS_IDENTITYSVC   293
#define SYS_SHARED_REGION_CHECK_NP   294
#define SYS_SHARED_REGION_MAP_NP   295
#define SYS___PTHREAD_MUTEX_DESTROY   301
#define SYS___PTHREAD_MUTEX_INIT   302
#define SYS___PTHREAD_MUTEX_LOCK   303
#define SYS___PTHREAD_MUTEX_TRYLOCK   304
#define SYS___PTHREAD_MUTEX_UNLOCK   305
#define SYS___PTHREAD_COND_INIT   306
#define SYS___PTHREAD_COND_DESTROY   307
#define SYS___PTHREAD_COND_BROADCAST   308
#define SYS___PTHREAD_COND_SIGNAL   309
#define SYS_GETSID   310
#define SYS_SETTID_WITH_PID   311
#define SYS___PTHREAD_COND_TIMEDWAIT   312
#define SYS_AIO_FSYNC   313
#define SYS_AIO_RETURN   314
#define SYS_AIO_SUSPEND   315
#define SYS_AIO_CANCEL   316
#define SYS_AIO_ERROR   317
#define SYS_AIO_READ   318
#define SYS_AIO_WRITE   319
#define SYS_LIO_LISTIO   320
#define SYS___PTHREAD_COND_WAIT   321
#define SYS_IOPOLICYSYS   322
#define SYS_MLOCKALL   324
#define SYS_MUNLOCKALL   325
#define SYS_ISSETUGID   327
#define SYS___PTHREAD_KILL   328
#define SYS___PTHREAD_SIGMASK   329
#define SYS___SIGWAIT   330
#define SYS___DISABLE_THREADSIGNAL   331
#define SYS___PTHREAD_MARKCANCEL   332
#define SYS___PTHREAD_CANCELED   333
#define SYS___SEMWAIT_SIGNAL   334
#define SYS_PROC_INFO   336
#define SYS_SENDFILE   337
#define SYS_STAT64   338
#define SYS_FSTAT64   339
#define SYS_LSTAT64   340
#define SYS_STAT64_EXTENDED   341
#define SYS_LSTAT64_EXTENDED   342
#define SYS_FSTAT64_EXTENDED   343
#define SYS_GETDIRENTRIES64   344
#define SYS_STATFS64   345
#define SYS_FSTATFS64   346
#define SYS_GETFSSTAT64   347
#define SYS___PTHREAD_CHDIR   348
#define SYS___PTHREAD_FCHDIR   349
#define SYS_AUDIT   350
#define SYS_AUDITON   351
#define SYS_GETAUID   353
#define SYS_SETAUID   354
#define SYS_GETAUDIT   355
#define SYS_SETAUDIT   356
#define SYS_GETAUDIT_ADDR   357
#define SYS_SETAUDIT_ADDR   358
#define SYS_AUDITCTL   359
#define SYS_BSDTHREAD_CREATE   360
#define SYS_BSDTHREAD_TERMINATE   361
#define SYS_KQUEUE   362
#define SYS_KEVENT   363
#define SYS_LCHOWN   364
#define SYS_STACK_SNAPSHOT   365
#define SYS_BSDTHREAD_REGISTER   366
#define SYS_WORKQ_OPEN   367
#define SYS_WORKQ_OPS   368
#define SYS___MAC_EXECVE   380
#define SYS___MAC_SYSCALL   381
#define SYS___MAC_GET_FILE   382
#define SYS___MAC_SET_FILE   383
#define SYS___MAC_GET_LINK   384
#define SYS___MAC_SET_LINK   385
#define SYS___MAC_GET_PROC   386
#define SYS___MAC_SET_PROC   387
#define SYS___MAC_GET_FD   388
#define SYS___MAC_SET_FD   389
#define SYS___MAC_GET_PID   390
#define SYS___MAC_GET_LCID   391
#define SYS___MAC_GET_LCTX   392
#define SYS___MAC_SET_LCTX   393
#define SYS_SETLCID   394
#define SYS_GETLCID   395
#define SYS_READ_NOCANCEL   396
#define SYS_WRITE_NOCANCEL   397
#define SYS_OPEN_NOCANCEL   398
#define SYS_CLOSE_NOCANCEL   399
#define SYS_WAIT4_NOCANCEL   400
#define SYS_RECVMSG_NOCANCEL   401
#define SYS_SENDMSG_NOCANCEL   402
#define SYS_RECVFROM_NOCANCEL   403
#define SYS_ACCEPT_NOCANCEL   404
#define SYS_MSYNC_NOCANCEL   405
#define SYS_FCNTL_NOCANCEL   406
#define SYS_SELECT_NOCANCEL   407
#define SYS_FSYNC_NOCANCEL   408
#define SYS_CONNECT_NOCANCEL   409
#define SYS_SIGSUSPEND_NOCANCEL   410
#define SYS_READV_NOCANCEL   411
#define SYS_WRITEV_NOCANCEL   412
#define SYS_SENDTO_NOCANCEL   413
#define SYS_PREAD_NOCANCEL   414
#define SYS_PWRITE_NOCANCEL   415
#define SYS_WAITID_NOCANCEL   416
#define SYS_POLL_NOCANCEL   417
#define SYS_MSGSND_NOCANCEL   418
#define SYS_MSGRCV_NOCANCEL   419
#define SYS_SEM_WAIT_NOCANCEL   420
#define SYS_AIO_SUSPEND_NOCANCEL   421
#define SYS___SIGWAIT_NOCANCEL   422
#define SYS___SEMWAIT_SIGNAL_NOCANCEL   423
#define SYS___MAC_MOUNT   424
#define SYS___MAC_GET_MOUNT   425
#define SYS___MAC_GETFSSTAT   426
#define SYS_MAXSYSCALL   427


#elif (defined(OSDRAGONFLY))


#define SYS_NOSYS   0
#define SYS_UMTX_SLEEP   469
#define SYS_UMTX_WAKEUP   470
#define SYS_JAIL_ATTACH   471
#define SYS_SET_TLS_AREA   472
#define SYS_GET_TLS_AREA   473
#define SYS_CLOSEFROM   474
#define SYS_STAT   475
#define SYS_FSTAT   476
#define SYS_LSTAT   477
#define SYS_FHSTAT   478
#define SYS_GETDIRENTRIES   479
#define SYS_GETDENTS   480
#define SYS_USCHED_SET   481
#define SYS_EXTACCEPT   482
#define SYS_EXTCONNECT   483
#define SYS_MCONTROL   485
#define SYS_VMSPACE_CREATE   486
#define SYS_VMSPACE_DESTROY   487
#define SYS_VMSPACE_CTL   488
#define SYS_VMSPACE_MMAP   489
#define SYS_VMSPACE_MUNMAP   490
#define SYS_VMSPACE_MCONTROL   491
#define SYS_VMSPACE_PREAD   492
#define SYS_VMSPACE_PWRITE   493
#define SYS_EXTEXIT   494
#define SYS_LWP_CREATE   495
#define SYS_LWP_GETTID   496
#define SYS_LWP_KILL   497
#define SYS_LWP_RTPRIO   498
#define SYS_PSELECT   499
#define SYS_STATVFS   500
#define SYS_FSTATVFS   501
#define SYS_FHSTATVFS   502
#define SYS_GETVFSSTAT   503
#define SYS_OPENAT   504
#define SYS_FSTATAT   505
#define SYS_FCHMODAT   506
#define SYS_FCHOWNAT   507
#define SYS_UNLINKAT   508
#define SYS_FACCESSAT   509
#define SYS_MQ_OPEN   510
#define SYS_MQ_CLOSE   511
#define SYS_MQ_UNLINK   512
#define SYS_MQ_GETATTR   513
#define SYS_MQ_SETATTR   514
#define SYS_MQ_NOTIFY   515
#define SYS_MQ_SEND   516
#define SYS_MQ_RECEIVE   517
#define SYS_MQ_TIMEDSEND   518
#define SYS_MQ_TIMEDRECEIVE   519
#define SYS_IOPRIO_SET   520
#define SYS_IOPRIO_GET   521
#define SYS_CHROOT_KERNEL   522
#define SYS_RENAMEAT   523
#define SYS_MKDIRAT   524
#define SYS_MKFIFOAT   525
#define SYS_MKNODAT   526
#define SYS_READLINKAT   527
#define SYS_SYMLINKAT   528
#define SYS_SWAPOFF   529
#define SYS_VQUOTACTL   530
#define SYS_LINKAT   531
#define SYS_EACCESS   532
#define SYS_LPATHCONF   533
#define SYS_VMM_GUEST_CTL   534
#define SYS_VMM_GUEST_SYNC_ADDR   535


#elif (defined(OSBSD))


#define SYS_MAXSYSARGS   8
/** "syscall" ret: "int" args: "int" "..." */
#define SYS_syscall   0
/** "exit" ret: "void" args: "int" */
#define SYS_exit   1
/** "fork" ret: "int" args: */
#define SYS_fork   2
/** "read" ret: "ssize_t" args: "int" "void *" "size_t" */
#define SYS_read   3
/** "write" ret: "ssize_t" args: "int" "const void *" "size_t" */
#define SYS_write   4
/** "open" ret: "int" args: "const char *" "int" "..." */
#define SYS_open   5
/** "close" ret: "int" args: "int" */
#define SYS_close   6
/** "compat_50_wait4" ret: "int" args: "pid_t" "int *" "int" "struct rusage50 *" */
#define SYS_compat_50_wait4   7
/** "compat_43_ocreat" ret: "int" args: "const char *" "mode_t" */
#define SYS_compat_43_ocreat   8
/** "link" ret: "int" args: "const char *" "const char *" */
#define SYS_link   9
/** "unlink" ret: "int" args: "const char *" */
#define SYS_unlink   10
/** "chdir" ret: "int" args: "const char *" */
#define SYS_chdir   12
/** "fchdir" ret: "int" args: "int" */
#define SYS_fchdir   13
/** "compat_50_mknod" ret: "int" args: "const char *" "mode_t" "uint32_t" */
#define SYS_compat_50_mknod   14
/** "chmod" ret: "int" args: "const char *" "mode_t" */
#define SYS_chmod   15
/** "chown" ret: "int" args: "const char *" "uid_t" "gid_t" */
#define SYS_chown   16
/** "break" ret: "int" args: "char *" */
#define SYS_break   17
/** "compat_20_getfsstat" ret: "int" args: "struct statfs12 *" "long" "int" */
#define SYS_compat_20_getfsstat   18
/** "compat_43_olseek" ret: "long" args: "int" "long" "int" */
#define SYS_compat_43_olseek   19
/** "getpid" ret: "pid_t" args: */
#define SYS_getpid   20
/** "compat_40_mount" ret: "int" args: "const char *" "const char *" "int" "void *" */
#define SYS_compat_40_mount   21
/** "unmount" ret: "int" args: "const char *" "int" */
#define SYS_unmount   22
/** "setuid" ret: "int" args: "uid_t" */
#define SYS_setuid   23
/** "getuid" ret: "uid_t" args: */
#define SYS_getuid   24
/** "geteuid" ret: "uid_t" args: */
#define SYS_geteuid   25
/** "ptrace" ret: "int" args: "int" "pid_t" "void *" "int" */
#define SYS_ptrace   26
/** "recvmsg" ret: "ssize_t" args: "int" "struct msghdr *" "int" */
#define SYS_recvmsg   27
/** "sendmsg" ret: "ssize_t" args: "int" "const struct msghdr *" "int" */
#define SYS_sendmsg   28
/** "recvfrom" ret: "ssize_t" args: "int" "void *" "size_t" "int" "struct sockaddr *" "socklen_t *" */
#define SYS_recvfrom   29
/** "accept" ret: "int" args: "int" "struct sockaddr *" "socklen_t *" */
#define SYS_accept   30
/** "getpeername" ret: "int" args: "int" "struct sockaddr *" "socklen_t *" */
#define SYS_getpeername   31
/** "getsockname" ret: "int" args: "int" "struct sockaddr *" "socklen_t *" */
#define SYS_getsockname   32
/** "access" ret: "int" args: "const char *" "int" */
#define SYS_access   33
/** "chflags" ret: "int" args: "const char *" "u_long" */
#define SYS_chflags   34
/** "fchflags" ret: "int" args: "int" "u_long" */
#define SYS_fchflags   35
/** "sync" ret: "void" args: */
#define SYS_sync   36
/** "kill" ret: "int" args: "pid_t" "int" */
#define SYS_kill   37
/** "compat_43_stat43" ret: "int" args: "const char *" "struct stat43 *" */
#define SYS_compat_43_stat43   38
/** "getppid" ret: "pid_t" args: */
#define SYS_getppid   39
/** "compat_43_lstat43" ret: "int" args: "const char *" "struct stat43 *" */
#define SYS_compat_43_lstat43   40
/** "dup" ret: "int" args: "int" */
#define SYS_dup   41
/** "pipe" ret: "int" args: */
#define SYS_pipe   42
/** "getegid" ret: "gid_t" args: */
#define SYS_getegid   43
/** "profil" ret: "int" args: "char *" "size_t" "u_long" "u_int" */
#define SYS_profil   44
/** "ktrace" ret: "int" args: "const char *" "int" "int" "pid_t" */
#define SYS_ktrace   45
/** "compat_13_sigaction13" ret: "int" args: "int" "const struct sigaction13 *" "struct sigaction13 *" */
#define SYS_compat_13_sigaction13   46
/** "getgid" ret: "gid_t" args: */
#define SYS_getgid   47
/** "compat_13_sigprocmask13" ret: "int" args: "int" "int" */
#define SYS_compat_13_sigprocmask13   48
/** "__getlogin" ret: "int" args: "char *" "size_t" */
#define SYS___getlogin   49
/** "__setlogin" ret: "int" args: "const char *" */
#define SYS___setlogin   50
/** "acct" ret: "int" args: "const char *" */
#define SYS_acct   51
/** "compat_13_sigpending13" ret: "int" args: */
#define SYS_compat_13_sigpending13   52
/** "compat_13_sigaltstack13" ret: "int" args: "const struct sigaltstack13 *" "struct sigaltstack13 *" */
#define SYS_compat_13_sigaltstack13   53
/** "ioctl" ret: "int" args: "int" "u_long" "..." */
#define SYS_ioctl   54
/** "compat_12_oreboot" ret: "int" args: "int" */
#define SYS_compat_12_oreboot   55
/** "revoke" ret: "int" args: "const char *" */
#define SYS_revoke   56
/** "symlink" ret: "int" args: "const char *" "const char *" */
#define SYS_symlink   57
/** "readlink" ret: "ssize_t" args: "const char *" "char *" "size_t" */
#define SYS_readlink   58
/** "execve" ret: "int" args: "const char *" "char *const *" "char *const *" */
#define SYS_execve   59
/** "umask" ret: "mode_t" args: "mode_t" */
#define SYS_umask   60
/** "chroot" ret: "int" args: "const char *" */
#define SYS_chroot   61
/** "compat_43_fstat43" ret: "int" args: "int" "struct stat43 *" */
#define SYS_compat_43_fstat43   62
/** "compat_43_ogetkerninfo" ret: "int" args: "int" "char *" "int *" "int" */
#define SYS_compat_43_ogetkerninfo   63
/** "compat_43_ogetpagesize" ret: "int" args: */
#define SYS_compat_43_ogetpagesize   64
/** "compat_12_msync" ret: "int" args: "void *" "size_t" */
#define SYS_compat_12_msync   65
/** "vfork" ret: "int" args: */
#define SYS_vfork   66
/** "sbrk" ret: "int" args: "intptr_t" */
#define SYS_sbrk   69
/** "sstk" ret: "int" args: "int" */
#define SYS_sstk   70
/** "compat_43_ommap" ret: "int" args: "void *" "size_t" "int" "int" "int" "long" */
#define SYS_compat_43_ommap   71
/** "vadvise" ret: "int" args: "int" */
#define SYS_vadvise   72
/** "munmap" ret: "int" args: "void *" "size_t" */
#define SYS_munmap   73
/** "mprotect" ret: "int" args: "void *" "size_t" "int" */
#define SYS_mprotect   74
/** "madvise" ret: "int" args: "void *" "size_t" "int" */
#define SYS_madvise   75
/** "mincore" ret: "int" args: "void *" "size_t" "char *" */
#define SYS_mincore   78
/** "getgroups" ret: "int" args: "int" "gid_t *" */
#define SYS_getgroups   79
/** "setgroups" ret: "int" args: "int" "const gid_t *" */
#define SYS_setgroups   80
/** "getpgrp" ret: "int" args: */
#define SYS_getpgrp   81
/** "setpgid" ret: "int" args: "pid_t" "pid_t" */
#define SYS_setpgid   82
/** "compat_50_setitimer" ret: "int" args: "int" "const struct itimerval50 *" "struct itimerval50 *" */
#define SYS_compat_50_setitimer   83
/** "compat_43_owait" ret: "int" args: */
#define SYS_compat_43_owait   84
/** "compat_12_oswapon" ret: "int" args: "const char *" */
#define SYS_compat_12_oswapon   85
/** "compat_50_getitimer" ret: "int" args: "int" "struct itimerval50 *" */
#define SYS_compat_50_getitimer   86
/** "compat_43_ogethostname" ret: "int" args: "char *" "u_int" */
#define SYS_compat_43_ogethostname   87
/** "compat_43_osethostname" ret: "int" args: "char *" "u_int" */
#define SYS_compat_43_osethostname   88
/** "compat_43_ogetdtablesize" ret: "int" args: */
#define SYS_compat_43_ogetdtablesize   89
/** "dup2" ret: "int" args: "int" "int" */
#define SYS_dup2   90
/** "fcntl" ret: "int" args: "int" "int" "..." */
#define SYS_fcntl   92
/** "compat_50_select" ret: "int" args: "int" "fd_set *" "fd_set *" "fd_set *" "struct timeval50 *" */
#define SYS_compat_50_select   93
/** "fsync" ret: "int" args: "int" */
#define SYS_fsync   95
/** "setpriority" ret: "int" args: "int" "id_t" "int" */
#define SYS_setpriority   96
/** "compat_30_socket" ret: "int" args: "int" "int" "int" */
#define SYS_compat_30_socket   97
/** "connect" ret: "int" args: "int" "const struct sockaddr *" "socklen_t" */
#define SYS_connect   98
/** "compat_43_oaccept" ret: "int" args: "int" "void *" "socklen_t *" */
#define SYS_compat_43_oaccept   99
/** "getpriority" ret: "int" args: "int" "id_t" */
#define SYS_getpriority   100
/** "compat_43_osend" ret: "int" args: "int" "void *" "int" "int" */
#define SYS_compat_43_osend   101
/** "compat_43_orecv" ret: "int" args: "int" "void *" "int" "int" */
#define SYS_compat_43_orecv   102
/** "compat_13_sigreturn13" ret: "int" args: "struct sigcontext13 *" */
#define SYS_compat_13_sigreturn13   103
/** "bind" ret: "int" args: "int" "const struct sockaddr *" "socklen_t" */
#define SYS_bind   104
/** "setsockopt" ret: "int" args: "int" "int" "int" "const void *" "socklen_t" */
#define SYS_setsockopt   105
/** "listen" ret: "int" args: "int" "int" */
#define SYS_listen   106
/** "compat_43_osigvec" ret: "int" args: "int" "struct sigvec *" "struct sigvec *" */
#define SYS_compat_43_osigvec   108
/** "compat_43_osigblock" ret: "int" args: "int" */
#define SYS_compat_43_osigblock   109
/** "compat_43_osigsetmask" ret: "int" args: "int" */
#define SYS_compat_43_osigsetmask   110
/** "compat_13_sigsuspend13" ret: "int" args: "int" */
#define SYS_compat_13_sigsuspend13   111
/** "compat_43_osigstack" ret: "int" args: "struct sigstack *" "struct sigstack *" */
#define SYS_compat_43_osigstack   112
/** "compat_43_orecvmsg" ret: "int" args: "int" "struct omsghdr *" "int" */
#define SYS_compat_43_orecvmsg   113
/** "compat_43_osendmsg" ret: "int" args: "int" "void *" "int" */
#define SYS_compat_43_osendmsg   114
/** "compat_50_gettimeofday" ret: "int" args: "struct timeval50 *" "void *" */
#define SYS_compat_50_gettimeofday   116
/** "compat_50_getrusage" ret: "int" args: "int" "struct rusage50 *" */
#define SYS_compat_50_getrusage   117
/** "getsockopt" ret: "int" args: "int" "int" "int" "void *" "socklen_t *" */
#define SYS_getsockopt   118
/** "readv" ret: "ssize_t" args: "int" "const struct iovec *" "int" */
#define SYS_readv   120
/** "writev" ret: "ssize_t" args: "int" "const struct iovec *" "int" */
#define SYS_writev   121
/** "compat_50_settimeofday" ret: "int" args: "const struct timeval50 *" "const void *" */
#define SYS_compat_50_settimeofday   122
/** "fchown" ret: "int" args: "int" "uid_t" "gid_t" */
#define SYS_fchown   123
/** "fchmod" ret: "int" args: "int" "mode_t" */
#define SYS_fchmod   124
/** "compat_43_orecvfrom" ret: "int" args: "int" "void *" "size_t" "int" "void *" "socklen_t *" */
#define SYS_compat_43_orecvfrom   125
/** "setreuid" ret: "int" args: "uid_t" "uid_t" */
#define SYS_setreuid   126
/** "setregid" ret: "int" args: "gid_t" "gid_t" */
#define SYS_setregid   127
/** "rename" ret: "int" args: "const char *" "const char *" */
#define SYS_rename   128
/** "compat_43_otruncate" ret: "int" args: "const char *" "long" */
#define SYS_compat_43_otruncate   129
/** "compat_43_oftruncate" ret: "int" args: "int" "long" */
#define SYS_compat_43_oftruncate   130
/** "flock" ret: "int" args: "int" "int" */
#define SYS_flock   131
/** "mkfifo" ret: "int" args: "const char *" "mode_t" */
#define SYS_mkfifo   132
/** "sendto" ret: "ssize_t" args: "int" "const void *" "size_t" "int" "const struct sockaddr *" "socklen_t" */
#define SYS_sendto   133
/** "shutdown" ret: "int" args: "int" "int" */
#define SYS_shutdown   134
/** "socketpair" ret: "int" args: "int" "int" "int" "int *" */
#define SYS_socketpair   135
/** "mkdir" ret: "int" args: "const char *" "mode_t" */
#define SYS_mkdir   136
/** "rmdir" ret: "int" args: "const char *" */
#define SYS_rmdir   137
/** "compat_50_utimes" ret: "int" args: "const char *" "const struct timeval50 *" */
#define SYS_compat_50_utimes   138
/** "compat_50_adjtime" ret: "int" args: "const struct timeval50 *" "struct timeval50 *" */
#define SYS_compat_50_adjtime   140
/** "compat_43_ogetpeername" ret: "int" args: "int" "void *" "socklen_t *" */
#define SYS_compat_43_ogetpeername   141
/** "compat_43_ogethostid" ret: "int32_t" args: */
#define SYS_compat_43_ogethostid   142
/** "compat_43_osethostid" ret: "int" args: "int32_t" */
#define SYS_compat_43_osethostid   143
/** "compat_43_ogetrlimit" ret: "int" args: "int" "struct orlimit *" */
#define SYS_compat_43_ogetrlimit   144
/** "compat_43_osetrlimit" ret: "int" args: "int" "const struct orlimit *" */
#define SYS_compat_43_osetrlimit   145
/** "compat_43_okillpg" ret: "int" args: "int" "int" */
#define SYS_compat_43_okillpg   146
/** "setsid" ret: "int" args: */
#define SYS_setsid   147
/** "compat_50_quotactl" ret: "int" args: "const char *" "int" "int" "void *" */
#define SYS_compat_50_quotactl   148
/** "compat_43_oquota" ret: "int" args: */
#define SYS_compat_43_oquota   149
/** "compat_43_ogetsockname" ret: "int" args: "int" "void *" "socklen_t *" */
#define SYS_compat_43_ogetsockname   150
/** "nfssvc" ret: "int" args: "int" "void *" */
#define SYS_nfssvc   155
/** "compat_43_ogetdirentries" ret: "int" args: "int" "char *" "u_int" "long *" */
#define SYS_compat_43_ogetdirentries   156
/** "compat_20_statfs" ret: "int" args: "const char *" "struct statfs12 *" */
#define SYS_compat_20_statfs   157
/** "compat_20_fstatfs" ret: "int" args: "int" "struct statfs12 *" */
#define SYS_compat_20_fstatfs   158
/** "compat_30_getfh" ret: "int" args: "const char *" "struct compat_30_fhandle *" */
#define SYS_compat_30_getfh   161
/** "compat_09_ogetdomainname" ret: "int" args: "char *" "int" */
#define SYS_compat_09_ogetdomainname   162
/** "compat_09_osetdomainname" ret: "int" args: "char *" "int" */
#define SYS_compat_09_osetdomainname   163
/** "compat_09_ouname" ret: "int" args: "struct outsname *" */
#define SYS_compat_09_ouname   164
/** "sysarch" ret: "int" args: "int" "void *" */
#define SYS_sysarch   165
#if ((defined(SYSVSEM) || (!defined(_KERNEL_OPT))) && (!defined(_LP64)))
/** "compat_10_osemsys" ret: "int" args: "int" "int" "int" "int" "int" */
#   define SYS_compat_10_osemsys   169
#endif
#if ((defined(SYSVMSG) || (!defined(_KERNEL_OPT))) && (!defined(_LP64)))
/** "compat_10_omsgsys" ret: "int" args: "int" "int" "int" "int" "int" "int" */
#   define SYS_compat_10_omsgsys   170
#endif
#if ((defined(SYSVSHM) || (!defined(_KERNEL_OPT))) && (!defined(_LP64)))
/** "compat_10_oshmsys" ret: "int" args: "int" "int" "int" "int" */
#   define SYS_compat_10_oshmsys   171
#endif
/** "pread" ret: "ssize_t" args: "int" "void *" "size_t" "int" "off_t" */
#define SYS_pread   173
/** "pwrite" ret: "ssize_t" args: "int" "const void *" "size_t" "int" "off_t" */
#define SYS_pwrite   174
/** "compat_30_ntp_gettime" ret: "int" args: "struct ntptimeval30 *" */
#define SYS_compat_30_ntp_gettime   175
#if (defined(NTP) || (!defined(_KERNEL_OPT)))
/** "ntp_adjtime" ret: "int" args: "struct timex *" */
#   define SYS_ntp_adjtime   176
#endif
/** "setgid" ret: "int" args: "gid_t" */
#define SYS_setgid   181
/** "setegid" ret: "int" args: "gid_t" */
#define SYS_setegid   182
/** "seteuid" ret: "int" args: "uid_t" */
#define SYS_seteuid   183
/** "lfs_bmapv" ret: "int" args: "fsid_t *" "struct block_info *" "int" */
#define SYS_lfs_bmapv   184
/** "lfs_markv" ret: "int" args: "fsid_t *" "struct block_info *" "int" */
#define SYS_lfs_markv   185
/** "lfs_segclean" ret: "int" args: "fsid_t *" "u_long" */
#define SYS_lfs_segclean   186
/** "compat_50_lfs_segwait" ret: "int" args: "fsid_t *" "struct timeval50 *" */
#define SYS_compat_50_lfs_segwait   187
/** "compat_12_stat12" ret: "int" args: "const char *" "struct stat12 *" */
#define SYS_compat_12_stat12   188
/** "compat_12_fstat12" ret: "int" args: "int" "struct stat12 *" */
#define SYS_compat_12_fstat12   189
/** "compat_12_lstat12" ret: "int" args: "const char *" "struct stat12 *" */
#define SYS_compat_12_lstat12   190
/** "pathconf" ret: "long" args: "const char *" "int" */
#define SYS_pathconf   191
/** "fpathconf" ret: "long" args: "int" "int" */
#define SYS_fpathconf   192
/** "getrlimit" ret: "int" args: "int" "struct rlimit *" */
#define SYS_getrlimit   194
/** "setrlimit" ret: "int" args: "int" "const struct rlimit *" */
#define SYS_setrlimit   195
/** "compat_12_getdirentries" ret: "int" args: "int" "char *" "u_int" "long *" */
#define SYS_compat_12_getdirentries   196
/** "mmap" ret: "void *" args: "void *" "size_t" "int" "int" "int" "long" "off_t" */
#define SYS_mmap   197
/** "__syscall" ret: "quad_t" args: "quad_t" "..." */
#define SYS___syscall   198
/** "lseek" ret: "off_t" args: "int" "int" "off_t" "int" */
#define SYS_lseek   199
/** "truncate" ret: "int" args: "const char *" "int" "off_t" */
#define SYS_truncate   200
/** "ftruncate" ret: "int" args: "int" "int" "off_t" */
#define SYS_ftruncate   201
/** "__sysctl" ret: "int" args: "const int *" "u_int" "void *" "size_t *" "const void *" "size_t" */
#define SYS___sysctl   202
/** "mlock" ret: "int" args: "const void *" "size_t" */
#define SYS_mlock   203
/** "munlock" ret: "int" args: "const void *" "size_t" */
#define SYS_munlock   204
/** "undelete" ret: "int" args: "const char *" */
#define SYS_undelete   205
/** "compat_50_futimes" ret: "int" args: "int" "const struct timeval50 *" */
#define SYS_compat_50_futimes   206
/** "getpgid" ret: "pid_t" args: "pid_t" */
#define SYS_getpgid   207
/** "reboot" ret: "int" args: "int" "char *" */
#define SYS_reboot   208
/** "poll" ret: "int" args: "struct pollfd *" "u_int" "int" */
#define SYS_poll   209
/** "afssys" ret: "int" args: "long" "long" "long" "long" "long" "long" "long" */
#define SYS_afssys   210
#if (defined(SYSVSEM) || (!defined(_KERNEL_OPT)))
/** "compat_14___semctl" ret: "int" args: "int" "int" "int" "union __semun *" */
#   define SYS_compat_14___semctl   220
/** "semget" ret: "int" args: "key_t" "int" "int" */
#   define SYS_semget   221
/** "semop" ret: "int" args: "int" "struct sembuf *" "size_t" */
#   define SYS_semop   222
/** "semconfig" ret: "int" args: "int" */
#   define SYS_semconfig   223
#endif
#if (defined(SYSVMSG) || (!defined(_KERNEL_OPT)))
/** "compat_14_msgctl" ret: "int" args: "int" "int" "struct msqid_ds14 *" */
#   define SYS_compat_14_msgctl   224
/** "msgget" ret: "int" args: "key_t" "int" */
#   define SYS_msgget   225
/** "msgsnd" ret: "int" args: "int" "const void *" "size_t" "int" */
#   define SYS_msgsnd   226
/** "msgrcv" ret: "ssize_t" args: "int" "void *" "size_t" "long" "int" */
#   define SYS_msgrcv   227
#endif
#if (defined(SYSVSHM) || (!defined(_KERNEL_OPT)))
/** "shmat" ret: "void *" args: "int" "const void *" "int" */
#   define SYS_shmat   228
/** "compat_14_shmctl" ret: "int" args: "int" "int" "struct shmid_ds14 *" */
#   define SYS_compat_14_shmctl   229
/** "shmdt" ret: "int" args: "const void *" */
#   define SYS_shmdt   230
/** "shmget" ret: "int" args: "key_t" "size_t" "int" */
#   define SYS_shmget   231
#endif
/** "compat_50_clock_gettime" ret: "int" args: "clockid_t" "struct timespec50 *" */
#define SYS_compat_50_clock_gettime   232
/** "compat_50_clock_settime" ret: "int" args: "clockid_t" "const struct timespec50 *" */
#define SYS_compat_50_clock_settime   233
/** "compat_50_clock_getres" ret: "int" args: "clockid_t" "struct timespec50 *" */
#define SYS_compat_50_clock_getres   234
/** "timer_create" ret: "int" args: "clockid_t" "struct sigevent *" "timer_t *" */
#define SYS_timer_create   235
/** "timer_delete" ret: "int" args: "timer_t" */
#define SYS_timer_delete   236
/** "compat_50_timer_settime" ret: "int" args: "timer_t" "int" "const struct itimerspec50 *" "struct itimerspec50 *" */
#define SYS_compat_50_timer_settime   237
/** "compat_50_timer_gettime" ret: "int" args: "timer_t" "struct itimerspec50 *" */
#define SYS_compat_50_timer_gettime   238
/** "timer_getoverrun" ret: "int" args: "timer_t" */
#define SYS_timer_getoverrun   239
/** "compat_50_nanosleep" ret: "int" args: "const struct timespec50 *" "struct timespec50 *" */
#define SYS_compat_50_nanosleep   240
/** "fdatasync" ret: "int" args: "int" */
#define SYS_fdatasync   241
/** "mlockall" ret: "int" args: "int" */
#define SYS_mlockall   242
/** "munlockall" ret: "int" args: */
#define SYS_munlockall   243
/** "compat_50___sigtimedwait" ret: "int" args: "const sigset_t *" "siginfo_t *" "struct timespec50 *" */
#define SYS_compat_50___sigtimedwait   244
/** "sigqueueinfo" ret: "int" args: "pid_t" "const siginfo_t *" */
#define SYS_sigqueueinfo   245
/** "modctl" ret: "int" args: "int" "void *" */
#define SYS_modctl   246
/** "_ksem_init" ret: "int" args: "unsigned int" "intptr_t *" */
#define SYS__ksem_init   247
/** "_ksem_open" ret: "int" args: "const char *" "int" "mode_t" "unsigned int" "intptr_t *" */
#define SYS__ksem_open   248
/** "_ksem_unlink" ret: "int" args: "const char *" */
#define SYS__ksem_unlink   249
/** "_ksem_close" ret: "int" args: "intptr_t" */
#define SYS__ksem_close   250
/** "_ksem_post" ret: "int" args: "intptr_t" */
#define SYS__ksem_post   251
/** "_ksem_wait" ret: "int" args: "intptr_t" */
#define SYS__ksem_wait   252
/** "_ksem_trywait" ret: "int" args: "intptr_t" */
#define SYS__ksem_trywait   253
/** "_ksem_getvalue" ret: "int" args: "intptr_t" "unsigned int *" */
#define SYS__ksem_getvalue   254
/** "_ksem_destroy" ret: "int" args: "intptr_t" */
#define SYS__ksem_destroy   255
/** "_ksem_timedwait" ret: "int" args: "intptr_t" "const struct timespec *" */
#define SYS__ksem_timedwait   256
/** "mq_open" ret: "mqd_t" args: "const char *" "int" "mode_t" "struct mq_attr *" */
#define SYS_mq_open   257
/** "mq_close" ret: "int" args: "mqd_t" */
#define SYS_mq_close   258
/** "mq_unlink" ret: "int" args: "const char *" */
#define SYS_mq_unlink   259
/** "mq_getattr" ret: "int" args: "mqd_t" "struct mq_attr *" */
#define SYS_mq_getattr   260
/** "mq_setattr" ret: "int" args: "mqd_t" "const struct mq_attr *" "struct mq_attr *" */
#define SYS_mq_setattr   261
/** "mq_notify" ret: "int" args: "mqd_t" "const struct sigevent *" */
#define SYS_mq_notify   262
/** "mq_send" ret: "int" args: "mqd_t" "const char *" "size_t" "unsigned" */
#define SYS_mq_send   263
/** "mq_receive" ret: "ssize_t" args: "mqd_t" "char *" "size_t" "unsigned *" */
#define SYS_mq_receive   264
/** "compat_50_mq_timedsend" ret: "int" args: "mqd_t" "const char *" "size_t" "unsigned" "const struct timespec50 *" */
#define SYS_compat_50_mq_timedsend   265
/** "compat_50_mq_timedreceive" ret: "ssize_t" args: "mqd_t" "char *" "size_t" "unsigned *" "const struct timespec50 *" */
#define SYS_compat_50_mq_timedreceive   266
/** "__posix_rename" ret: "int" args: "const char *" "const char *" */
#define SYS___posix_rename   270
/** "swapctl" ret: "int" args: "int" "void *" "int" */
#define SYS_swapctl   271
/** "compat_30_getdents" ret: "int" args: "int" "char *" "size_t" */
#define SYS_compat_30_getdents   272
/** "minherit" ret: "int" args: "void *" "size_t" "int" */
#define SYS_minherit   273
/** "lchmod" ret: "int" args: "const char *" "mode_t" */
#define SYS_lchmod   274
/** "lchown" ret: "int" args: "const char *" "uid_t" "gid_t" */
#define SYS_lchown   275
/** "compat_50_lutimes" ret: "int" args: "const char *" "const struct timeval50 *" */
#define SYS_compat_50_lutimes   276
/** "__msync13" ret: "int" args: "void *" "size_t" "int" */
#define SYS___msync13   277
/** "compat_30___stat13" ret: "int" args: "const char *" "struct stat13 *" */
#define SYS_compat_30___stat13   278
/** "compat_30___fstat13" ret: "int" args: "int" "struct stat13 *" */
#define SYS_compat_30___fstat13   279
/** "compat_30___lstat13" ret: "int" args: "const char *" "struct stat13 *" */
#define SYS_compat_30___lstat13   280
/** "__sigaltstack14" ret: "int" args: "const struct sigaltstack *" "struct sigaltstack *" */
#define SYS___sigaltstack14   281
/** "__vfork14" ret: "int" args: */
#define SYS___vfork14   282
/** "__posix_chown" ret: "int" args: "const char *" "uid_t" "gid_t" */
#define SYS___posix_chown   283
/** "__posix_fchown" ret: "int" args: "int" "uid_t" "gid_t" */
#define SYS___posix_fchown   284
/** "__posix_lchown" ret: "int" args: "const char *" "uid_t" "gid_t" */
#define SYS___posix_lchown   285
/** "getsid" ret: "pid_t" args: "pid_t" */
#define SYS_getsid   286
/** "__clone" ret: "pid_t" args: "int" "void *" */
#define SYS___clone   287
/** "fktrace" ret: "int" args: "int" "int" "int" "pid_t" */
#define SYS_fktrace   288
/** "preadv" ret: "ssize_t" args: "int" "const struct iovec *" "int" "int" "off_t" */
#define SYS_preadv   289
/** "pwritev" ret: "ssize_t" args: "int" "const struct iovec *" "int" "int" "off_t" */
#define SYS_pwritev   290
/** "compat_16___sigaction14" ret: "int" args: "int" "const struct sigaction *" "struct sigaction *" */
#define SYS_compat_16___sigaction14   291
/** "__sigpending14" ret: "int" args: "sigset_t *" */
#define SYS___sigpending14   292
/** "__sigprocmask14" ret: "int" args: "int" "const sigset_t *" "sigset_t *" */
#define SYS___sigprocmask14   293
/** "__sigsuspend14" ret: "int" args: "const sigset_t *" */
#define SYS___sigsuspend14   294
/** "compat_16___sigreturn14" ret: "int" args: "struct sigcontext *" */
#define SYS_compat_16___sigreturn14   295
/** "__getcwd" ret: "int" args: "char *" "size_t" */
#define SYS___getcwd   296
/** "fchroot" ret: "int" args: "int" */
#define SYS_fchroot   297
/** "compat_30_fhopen" ret: "int" args: "const struct compat_30_fhandle *" "int" */
#define SYS_compat_30_fhopen   298
/** "compat_30_fhstat" ret: "int" args: "const struct compat_30_fhandle *" "struct stat13 *" */
#define SYS_compat_30_fhstat   299
/** "compat_20_fhstatfs" ret: "int" args: "const struct compat_30_fhandle *" "struct statfs12 *" */
#define SYS_compat_20_fhstatfs   300
#if (defined(SYSVSEM) || (!defined(_KERNEL_OPT)))
/** "compat_50_____semctl13" ret: "int" args: "int" "int" "int" "..." */
#   define SYS_compat_50_____semctl13   301
#endif
#if (defined(SYSVMSG) || (!defined(_KERNEL_OPT)))
/** "compat_50___msgctl13" ret: "int" args: "int" "int" "struct msqid_ds *" */
#   define SYS_compat_50___msgctl13   302
#endif
#if (defined(SYSVSHM) || (!defined(_KERNEL_OPT)))
/** "compat_50___shmctl13" ret: "int" args: "int" "int" "struct shmid_ds13 *" */
#   define SYS_compat_50___shmctl13   303
#endif
/** "lchflags" ret: "int" args: "const char *" "u_long" */
#define SYS_lchflags   304
/** "issetugid" ret: "int" args: */
#define SYS_issetugid   305
/** "utrace" ret: "int" args: "const char *" "void *" "size_t" */
#define SYS_utrace   306
/** "getcontext" ret: "int" args: "struct __ucontext *" */
#define SYS_getcontext   307
/** "setcontext" ret: "int" args: "const struct __ucontext *" */
#define SYS_setcontext   308
/** "_lwp_create" ret: "int" args: "const struct __ucontext *" "u_long" "lwpid_t *" */
#define SYS__lwp_create   309
/** "_lwp_exit" ret: "int" args: */
#define SYS__lwp_exit   310
/** "_lwp_self" ret: "lwpid_t" args: */
#define SYS__lwp_self   311
/** "_lwp_wait" ret: "int" args: "lwpid_t" "lwpid_t *" */
#define SYS__lwp_wait   312
/** "_lwp_suspend" ret: "int" args: "lwpid_t" */
#define SYS__lwp_suspend   313
/** "_lwp_continue" ret: "int" args: "lwpid_t" */
#define SYS__lwp_continue   314
/** "_lwp_wakeup" ret: "int" args: "lwpid_t" */
#define SYS__lwp_wakeup   315
/** "_lwp_getprivate" ret: "void *" args: */
#define SYS__lwp_getprivate   316
/** "_lwp_setprivate" ret: "void" args: "void *" */
#define SYS__lwp_setprivate   317
/** "_lwp_kill" ret: "int" args: "lwpid_t" "int" */
#define SYS__lwp_kill   318
/** "_lwp_detach" ret: "int" args: "lwpid_t" */
#define SYS__lwp_detach   319
/** "compat_50__lwp_park" ret: "int" args: "const struct timespec50 *" "lwpid_t" "const void *" "const void *" */
#define SYS_compat_50__lwp_park   320
/** "_lwp_unpark" ret: "int" args: "lwpid_t" "const void *" */
#define SYS__lwp_unpark   321
/** "_lwp_unpark_all" ret: "ssize_t" args: "const lwpid_t *" "size_t" "const void *" */
#define SYS__lwp_unpark_all   322
/** "_lwp_setname" ret: "int" args: "lwpid_t" "const char *" */
#define SYS__lwp_setname   323
/** "_lwp_getname" ret: "int" args: "lwpid_t" "char *" "size_t" */
#define SYS__lwp_getname   324
/** "_lwp_ctl" ret: "int" args: "int" "struct lwpctl **" */
#define SYS__lwp_ctl   325
/** "compat_60_sa_register" ret: "int" args: "void *" "void **" "int" "ssize_t" */
#define SYS_compat_60_sa_register   330
/** "compat_60_sa_stacks" ret: "int" args: "int" "stack_t *" */
#define SYS_compat_60_sa_stacks   331
/** "compat_60_sa_enable" ret: "int" args: */
#define SYS_compat_60_sa_enable   332
/** "compat_60_sa_setconcurrency" ret: "int" args: "int" */
#define SYS_compat_60_sa_setconcurrency   333
/** "compat_60_sa_yield" ret: "int" args: */
#define SYS_compat_60_sa_yield   334
/** "compat_60_sa_preempt" ret: "int" args: "int" */
#define SYS_compat_60_sa_preempt   335
/** "__sigaction_sigtramp" ret: "int" args: "int" "const struct sigaction *" "struct sigaction *" "const void *" "int" */
#define SYS___sigaction_sigtramp   340
/** "pmc_get_info" ret: "int" args: "int" "int" "void *" */
#define SYS_pmc_get_info   341
/** "pmc_control" ret: "int" args: "int" "int" "void *" */
#define SYS_pmc_control   342
/** "rasctl" ret: "int" args: "void *" "size_t" "int" */
#define SYS_rasctl   343
/** "kqueue" ret: "int" args: */
#define SYS_kqueue   344
/** "compat_50_kevent" ret: "int" args: "int" "const struct kevent *" "size_t" "struct kevent *" "size_t" "const struct timespec50 *" */
#define SYS_compat_50_kevent   345
/** "_sched_setparam" ret: "int" args: "pid_t" "lwpid_t" "int" "const struct sched_param *" */
#define SYS__sched_setparam   346
/** "_sched_getparam" ret: "int" args: "pid_t" "lwpid_t" "int *" "struct sched_param *" */
#define SYS__sched_getparam   347
/** "_sched_setaffinity" ret: "int" args: "pid_t" "lwpid_t" "size_t" "const cpuset_t *" */
#define SYS__sched_setaffinity   348
/** "_sched_getaffinity" ret: "int" args: "pid_t" "lwpid_t" "size_t" "cpuset_t *" */
#define SYS__sched_getaffinity   349
/** "sched_yield" ret: "int" args: */
#define SYS_sched_yield   350
/** "fsync_range" ret: "int" args: "int" "int" "off_t" "off_t" */
#define SYS_fsync_range   354
/** "uuidgen" ret: "int" args: "struct uuid *" "int" */
#define SYS_uuidgen   355
/** "getvfsstat" ret: "int" args: "struct statvfs *" "size_t" "int" */
#define SYS_getvfsstat   356
/** "statvfs1" ret: "int" args: "const char *" "struct statvfs *" "int" */
#define SYS_statvfs1   357
/** "fstatvfs1" ret: "int" args: "int" "struct statvfs *" "int" */
#define SYS_fstatvfs1   358
/** "compat_30_fhstatvfs1" ret: "int" args: "const struct compat_30_fhandle *" "struct statvfs *" "int" */
#define SYS_compat_30_fhstatvfs1   359
/** "extattrctl" ret: "int" args: "const char *" "int" "const char *" "int" "const char *" */
#define SYS_extattrctl   360
/** "extattr_set_file" ret: "int" args: "const char *" "int" "const char *" "const void *" "size_t" */
#define SYS_extattr_set_file   361
/** "extattr_get_file" ret: "ssize_t" args: "const char *" "int" "const char *" "void *" "size_t" */
#define SYS_extattr_get_file   362
/** "extattr_delete_file" ret: "int" args: "const char *" "int" "const char *" */
#define SYS_extattr_delete_file   363
/** "extattr_set_fd" ret: "int" args: "int" "int" "const char *" "const void *" "size_t" */
#define SYS_extattr_set_fd   364
/** "extattr_get_fd" ret: "ssize_t" args: "int" "int" "const char *" "void *" "size_t" */
#define SYS_extattr_get_fd   365
/** "extattr_delete_fd" ret: "int" args: "int" "int" "const char *" */
#define SYS_extattr_delete_fd   366
/** "extattr_set_link" ret: "int" args: "const char *" "int" "const char *" "const void *" "size_t" */
#define SYS_extattr_set_link   367
/** "extattr_get_link" ret: "ssize_t" args: "const char *" "int" "const char *" "void *" "size_t" */
#define SYS_extattr_get_link   368
/** "extattr_delete_link" ret: "int" args: "const char *" "int" "const char *" */
#define SYS_extattr_delete_link   369
/** "extattr_list_fd" ret: "ssize_t" args: "int" "int" "void *" "size_t" */
#define SYS_extattr_list_fd   370
/** "extattr_list_file" ret: "ssize_t" args: "const char *" "int" "void *" "size_t" */
#define SYS_extattr_list_file   371
/** "extattr_list_link" ret: "ssize_t" args: "const char *" "int" "void *" "size_t" */
#define SYS_extattr_list_link   372
/** "compat_50_pselect" ret: "int" args: "int" "fd_set *" "fd_set *" "fd_set *" "const struct timespec50 *" "const sigset_t *" */
#define SYS_compat_50_pselect   373
/** "compat_50_pollts" ret: "int" args: "struct pollfd *" "u_int" "const struct timespec50 *" "const sigset_t *" */
#define SYS_compat_50_pollts   374
/** "setxattr" ret: "int" args: "const char *" "const char *" "const void *" "size_t" "int" */
#define SYS_setxattr   375
/** "lsetxattr" ret: "int" args: "const char *" "const char *" "const void *" "size_t" "int" */
#define SYS_lsetxattr   376
/** "fsetxattr" ret: "int" args: "int" "const char *" "const void *" "size_t" "int" */
#define SYS_fsetxattr   377
/** "getxattr" ret: "int" args: "const char *" "const char *" "void *" "size_t" */
#define SYS_getxattr   378
/** "lgetxattr" ret: "int" args: "const char *" "const char *" "void *" "size_t" */
#define SYS_lgetxattr   379
/** "fgetxattr" ret: "int" args: "int" "const char *" "void *" "size_t" */
#define SYS_fgetxattr   380
/** "listxattr" ret: "int" args: "const char *" "char *" "size_t" */
#define SYS_listxattr   381
/** "llistxattr" ret: "int" args: "const char *" "char *" "size_t" */
#define SYS_llistxattr   382
/** "flistxattr" ret: "int" args: "int" "char *" "size_t" */
#define SYS_flistxattr   383
/** "removexattr" ret: "int" args: "const char *" "const char *" */
#define SYS_removexattr   384
/** "lremovexattr" ret: "int" args: "const char *" "const char *" */
#define SYS_lremovexattr   385
/** "fremovexattr" ret: "int" args: "int" "const char *" */
#define SYS_fremovexattr   386
/** "compat_50___stat30" ret: "int" args: "const char *" "struct stat30 *" */
#define SYS_compat_50___stat30   387
/** "compat_50___fstat30" ret: "int" args: "int" "struct stat30 *" */
#define SYS_compat_50___fstat30   388
/** "compat_50___lstat30" ret: "int" args: "const char *" "struct stat30 *" */
#define SYS_compat_50___lstat30   389
/** "__getdents30" ret: "int" args: "int" "char *" "size_t" */
#define SYS___getdents30   390
/** "compat_30___fhstat30" ret: "int" args: "const struct compat_30_fhandle *" "struct stat30 *" */
#define SYS_compat_30___fhstat30   392
/** "compat_50___ntp_gettime30" ret: "int" args: "struct ntptimeval50 *" */
#define SYS_compat_50___ntp_gettime30   393
/** "__socket30" ret: "int" args: "int" "int" "int" */
#define SYS___socket30   394
/** "__getfh30" ret: "int" args: "const char *" "void *" "size_t *" */
#define SYS___getfh30   395
/** "__fhopen40" ret: "int" args: "const void *" "size_t" "int" */
#define SYS___fhopen40   396
/** "__fhstatvfs140" ret: "int" args: "const void *" "size_t" "struct statvfs *" "int" */
#define SYS___fhstatvfs140   397
/** "compat_50___fhstat40" ret: "int" args: "const void *" "size_t" "struct stat30 *" */
#define SYS_compat_50___fhstat40   398
/** "aio_cancel" ret: "int" args: "int" "struct aiocb *" */
#define SYS_aio_cancel   399
/** "aio_error" ret: "int" args: "const struct aiocb *" */
#define SYS_aio_error   400
/** "aio_fsync" ret: "int" args: "int" "struct aiocb *" */
#define SYS_aio_fsync   401
/** "aio_read" ret: "int" args: "struct aiocb *" */
#define SYS_aio_read   402
/** "aio_return" ret: "int" args: "struct aiocb *" */
#define SYS_aio_return   403
/** "compat_50_aio_suspend" ret: "int" args: "const struct aiocb *const *" "int" "const struct timespec50 *" */
#define SYS_compat_50_aio_suspend   404
/** "aio_write" ret: "int" args: "struct aiocb *" */
#define SYS_aio_write   405
/** "lio_listio" ret: "int" args: "int" "struct aiocb *const *" "int" "struct sigevent *" */
#define SYS_lio_listio   406
/** "__mount50" ret: "int" args: "const char *" "const char *" "int" "void *" "size_t" */
#define SYS___mount50   410
/** "mremap" ret: "void *" args: "void *" "size_t" "void *" "size_t" "int" */
#define SYS_mremap   411
/** "pset_create" ret: "int" args: "psetid_t *" */
#define SYS_pset_create   412
/** "pset_destroy" ret: "int" args: "psetid_t" */
#define SYS_pset_destroy   413
/** "pset_assign" ret: "int" args: "psetid_t" "cpuid_t" "psetid_t *" */
#define SYS_pset_assign   414
/** "_pset_bind" ret: "int" args: "idtype_t" "id_t" "id_t" "psetid_t" "psetid_t *" */
#define SYS__pset_bind   415
/** "__posix_fadvise50" ret: "int" args: "int" "int" "off_t" "off_t" "int" */
#define SYS___posix_fadvise50   416
/** "__select50" ret: "int" args: "int" "fd_set *" "fd_set *" "fd_set *" "struct timeval *" */
#define SYS___select50   417
/** "__gettimeofday50" ret: "int" args: "struct timeval *" "void *" */
#define SYS___gettimeofday50   418
/** "__settimeofday50" ret: "int" args: "const struct timeval *" "const void *" */
#define SYS___settimeofday50   419
/** "__utimes50" ret: "int" args: "const char *" "const struct timeval *" */
#define SYS___utimes50   420
/** "__adjtime50" ret: "int" args: "const struct timeval *" "struct timeval *" */
#define SYS___adjtime50   421
/** "__lfs_segwait50" ret: "int" args: "fsid_t *" "struct timeval *" */
#define SYS___lfs_segwait50   422
/** "__futimes50" ret: "int" args: "int" "const struct timeval *" */
#define SYS___futimes50   423
/** "__lutimes50" ret: "int" args: "const char *" "const struct timeval *" */
#define SYS___lutimes50   424
/** "__setitimer50" ret: "int" args: "int" "const struct itimerval *" "struct itimerval *" */
#define SYS___setitimer50   425
/** "__getitimer50" ret: "int" args: "int" "struct itimerval *" */
#define SYS___getitimer50   426
/** "__clock_gettime50" ret: "int" args: "clockid_t" "struct timespec *" */
#define SYS___clock_gettime50   427
/** "__clock_settime50" ret: "int" args: "clockid_t" "const struct timespec *" */
#define SYS___clock_settime50   428
/** "__clock_getres50" ret: "int" args: "clockid_t" "struct timespec *" */
#define SYS___clock_getres50   429
/** "__nanosleep50" ret: "int" args: "const struct timespec *" "struct timespec *" */
#define SYS___nanosleep50   430
/** "____sigtimedwait50" ret: "int" args: "const sigset_t *" "siginfo_t *" "struct timespec *" */
#define SYS_____sigtimedwait50   431
/** "__mq_timedsend50" ret: "int" args: "mqd_t" "const char *" "size_t" "unsigned" "const struct timespec *" */
#define SYS___mq_timedsend50   432
/** "__mq_timedreceive50" ret: "ssize_t" args: "mqd_t" "char *" "size_t" "unsigned *" "const struct timespec *" */
#define SYS___mq_timedreceive50   433
/** "compat_60__lwp_park" ret: "int" args: "const struct timespec *" "lwpid_t" "const void *" "const void *" */
#define SYS_compat_60__lwp_park   434
/** "__kevent50" ret: "int" args: "int" "const struct kevent *" "size_t" "struct kevent *" "size_t" "const struct timespec *" */
#define SYS___kevent50   435
/** "__pselect50" ret: "int" args: "int" "fd_set *" "fd_set *" "fd_set *" "const struct timespec *" "const sigset_t *" */
#define SYS___pselect50   436
/** "__pollts50" ret: "int" args: "struct pollfd *" "u_int" "const struct timespec *" "const sigset_t *" */
#define SYS___pollts50   437
/** "__aio_suspend50" ret: "int" args: "const struct aiocb *const *" "int" "const struct timespec *" */
#define SYS___aio_suspend50   438
/** "__stat50" ret: "int" args: "const char *" "struct stat *" */
#define SYS___stat50   439
/** "__fstat50" ret: "int" args: "int" "struct stat *" */
#define SYS___fstat50   440
/** "__lstat50" ret: "int" args: "const char *" "struct stat *" */
#define SYS___lstat50   441
#if (defined(SYSVSEM) || (!defined(_KERNEL_OPT)))
/** "____semctl50" ret: "int" args: "int" "int" "int" "..." */
#   define SYS_____semctl50   442
#endif
#if (defined(SYSVSHM) || (!defined(_KERNEL_OPT)))
/** "__shmctl50" ret: "int" args: "int" "int" "struct shmid_ds *" */
#   define SYS___shmctl50   443
#endif
#if (defined(SYSVMSG) || (!defined(_KERNEL_OPT)))
/** "__msgctl50" ret: "int" args: "int" "int" "struct msqid_ds *" */
#   define SYS___msgctl50   444
#endif
/** "__getrusage50" ret: "int" args: "int" "struct rusage *" */
#define SYS___getrusage50   445
/** "__timer_settime50" ret: "int" args: "timer_t" "int" "const struct itimerspec *" "struct itimerspec *" */
#define SYS___timer_settime50   446
/** "__timer_gettime50" ret: "int" args: "timer_t" "struct itimerspec *" */
#define SYS___timer_gettime50   447
#if (defined(NTP) || (!defined(_KERNEL_OPT)))
/** "__ntp_gettime50" ret: "int" args: "struct ntptimeval *" */
#   define SYS___ntp_gettime50   448
#endif
/** "__wait450" ret: "int" args: "pid_t" "int *" "int" "struct rusage *" */
#define SYS___wait450   449
/** "__mknod50" ret: "int" args: "const char *" "mode_t" "dev_t" */
#define SYS___mknod50   450
/** "__fhstat50" ret: "int" args: "const void *" "size_t" "struct stat *" */
#define SYS___fhstat50   451
/** "pipe2" ret: "int" args: "int *" "int" */
#define SYS_pipe2   453
/** "dup3" ret: "int" args: "int" "int" "int" */
#define SYS_dup3   454
/** "kqueue1" ret: "int" args: "int" */
#define SYS_kqueue1   455
/** "paccept" ret: "int" args: "int" "struct sockaddr *" "socklen_t *" "const sigset_t *" "int" */
#define SYS_paccept   456
/** "linkat" ret: "int" args: "int" "const char *" "int" "const char *" "int" */
#define SYS_linkat   457
/** "renameat" ret: "int" args: "int" "const char *" "int" "const char *" */
#define SYS_renameat   458
/** "mkfifoat" ret: "int" args: "int" "const char *" "mode_t" */
#define SYS_mkfifoat   459
/** "mknodat" ret: "int" args: "int" "const char *" "mode_t" "int" "dev_t" */
#define SYS_mknodat   460
/** "mkdirat" ret: "int" args: "int" "const char *" "mode_t" */
#define SYS_mkdirat   461
/** "faccessat" ret: "int" args: "int" "const char *" "int" "int" */
#define SYS_faccessat   462
/** "fchmodat" ret: "int" args: "int" "const char *" "mode_t" "int" */
#define SYS_fchmodat   463
/** "fchownat" ret: "int" args: "int" "const char *" "uid_t" "gid_t" "int" */
#define SYS_fchownat   464
/** "fexecve" ret: "int" args: "int" "char *const *" "char *const *" */
#define SYS_fexecve   465
/** "fstatat" ret: "int" args: "int" "const char *" "struct stat *" "int" */
#define SYS_fstatat   466
/** "utimensat" ret: "int" args: "int" "const char *" "const struct timespec *" "int" */
#define SYS_utimensat   467
/** "openat" ret: "int" args: "int" "const char *" "int" "..." */
#define SYS_openat   468
/** "readlinkat" ret: "int" args: "int" "const char *" "char *" "size_t" */
#define SYS_readlinkat   469
/** "symlinkat" ret: "int" args: "const char *" "int" "const char *" */
#define SYS_symlinkat   470
/** "unlinkat" ret: "int" args: "int" "const char *" "int" */
#define SYS_unlinkat   471
/** "futimens" ret: "int" args: "int" "const struct timespec *" */
#define SYS_futimens   472
/** "__quotactl" ret: "int" args: "const char *" "struct quotactl_args *" */
#define SYS___quotactl   473
/** "posix_spawn" ret: "int" args: "pid_t *" "const char *" "const struct posix_spawn_file_actions *" "const struct posix_spawnattr *" "char *const *" "char *const *" */
#define SYS_posix_spawn   474
/** "recvmmsg" ret: "int" args: "int" "struct mmsghdr *" "unsigned int" "unsigned int" "struct timespec *" */
#define SYS_recvmmsg   475
/** "sendmmsg" ret: "int" args: "int" "struct mmsghdr *" "unsigned int" "unsigned int" */
#define SYS_sendmmsg   476
/** "clock_nanosleep" ret: "int" args: "clockid_t" "int" "const struct timespec *" "struct timespec *" */
#define SYS_clock_nanosleep   477
/** "___lwp_park60" ret: "int" args: "clockid_t" "int" "const struct timespec *" "lwpid_t" "const void *" "const void *" */
#define SYS____lwp_park60   478
#define SYS_MAXSYSCALL   479
#define SYS_NSYSENT   512


#elif (defined(OSPLAN9))


#define SYS_SYSR1   0
#define SYS_BIND   2
#define SYS_CHDIR   3
#define SYS_CLOSE   4
#define SYS_DUP   5
#define SYS_ALARM   6
#define SYS_EXEC   7
#define SYS_EXITS   8
#define SYS_FAUTH   10
#define SYS_SEGBRK   12
#define SYS_OPEN   14
#define SYS_OSEEK   16
#define SYS_SLEEP   17
#define SYS_RFORK   19
#define SYS_PIPE   21
#define SYS_CREATE   22
#define SYS_FD2PATH   23
#define SYS_BRK_   24
#define SYS_REMOVE   25
#define SYS_NOTIFY   28
#define SYS_NOTED   29
#define SYS_SEGATTACH   30
#define SYS_SEGDETACH   31
#define SYS_SEGFREE   32
#define SYS_SEGFLUSH   33
#define SYS_RENDEZVOUS   34
#define SYS_UNMOUNT   35
#define SYS_SEMACQUIRE   37
#define SYS_SEMRELEASE   38
#define SYS_SEEK   39
#define SYS_FVERSION   40
#define SYS_ERRSTR   41
#define SYS_STAT   42
#define SYS_FSTAT   43
#define SYS_WSTAT   44
#define SYS_FWSTAT   45
#define SYS_MOUNT   46
#define SYS_AWAIT   47
#define SYS_PREAD   50
#define SYS_PWRITE   51
#define SYS_TSEMACQUIRE   52
#define SYS_NSEC   53


#elif (defined(OSSOLARIS))


#define SYS_EXECVE   59
#define SYS_FCNTL   62


#endif


#if ((!defined(SYS_sysctl)) && defined(SYS__sysctl))
#   define SYS_sysctl   SYS__sysctl
#endif


/** Syscalls enum for Bell-Lab's Plan 9 operating system */
enum PLAN9_SYSCALLS {
	SYSR1 = 0,
	_ERRSTR = 1,
	BIND = 2,
	CHDIR = 3,
	CLOSE = 4,
	DUP = 5,
	ALARM = 6,
	EXEC = 7,
	EXITS = 8,
	_FSESSION = 9,
	FAUTH = 10,
	_FSTAT = 11,
	SEGBRK = 12,
	_MOUNT = 13,
	OPEN = 14,
	_READ = 15,
	OSEEK = 16,
	SLEEP = 17,
	_STAT = 18,
	RFORK = 19,
	_WRITE = 20,
	PIPE = 21,
	CREATE = 22,
	FD2PATH = 23,
	BRK_ = 24,
	REMOVE = 25,
	_WSTAT = 26,
	_FWSTAT = 27,
	NOTIFY = 28,
	NOTED = 29,
	SEGATTACH = 30,
	SEGDETACH = 31,
	SEGFREE = 32,
	SEGFLUSH = 33,
	RENDEZVOUS = 34,
	UNMOUNT = 35,
	_WAIT = 36,
	SEMACQUIRE = 37,
	SEMRELEASE = 38,
	SEEK = 39,
	FVERSION = 40,
	ERRSTR = 41,
	STAT = 42,
	FSTAT = 43,
	WSTAT = 44,
	FWSTAT = 45,
	MOUNT = 46,
	AWAIT = 47,
	PREAD = 50,
	PWRITE = 51,
	TSEMACQUIRE = 52
};


// SOCKETCALL CALLS

#ifdef OSLINUX


#define __SC_socket   1
#define __SC_bind   2
#define __SC_connect   3
#define __SC_listen   4
#define __SC_accept   5
#define __SC_getsockname 6
#define __SC_getpeername 7
#define __SC_socketpair  8
#define __SC_send   9
#define __SC_recv   10
#define __SC_sendto   11
#define __SC_recvfrom   12
#define __SC_shutdown   13
#define __SC_setsockopt  14
#define __SC_getsockopt  15
#define __SC_sendmsg   16
#define __SC_recvmsg   17
#define __SC_accept4   18
#define __SC_recvmmsg   19
#define __SC_sendmmsg   20


#endif


// LEGACY MACROS

#ifdef OSLINUX


#ifdef SYS_getuid32
#   undef SYS_lchown
#   undef SYS_getuid
#   undef SYS_getgid
#   undef SYS_geteuid
#   undef SYS_getegid
#   undef SYS_setreuid
#   undef SYS_setregid
#   undef SYS_getgroups
#   undef SYS_setgroups
#   undef SYS_fchown
#   undef SYS_setresuid
#   undef SYS_getresuid
#   undef SYS_setresgid
#   undef SYS_getresgid
#   undef SYS_chown
#   undef SYS_setuid
#   undef SYS_setgid
#   undef SYS_setfsuid
#   undef SYS_setfsgid
#   define SYS_lchown   SYS_lchown32
#   define SYS_getuid   SYS_getuid32
#   define SYS_getgid   SYS_getgid32
#   define SYS_geteuid   SYS_geteuid32
#   define SYS_getegid   SYS_getegid32
#   define SYS_setreuid   SYS_setreuid32
#   define SYS_setregid   SYS_setregid32
#   define SYS_getgroups   SYS_getgroups32
#   define SYS_setgroups   SYS_setgroups32
#   define SYS_fchown   SYS_fchown32
#   define SYS_setresuid   SYS_setresuid32
#   define SYS_getresuid   SYS_getresuid32
#   define SYS_setresgid   SYS_setresgid32
#   define SYS_getresgid   SYS_getresgid32
#   define SYS_chown   SYS_chown32
#   define SYS_setuid   SYS_setuid32
#   define SYS_setgid   SYS_setgid32
#   define SYS_setfsuid   SYS_setfsuid32
#   define SYS_setfsgid   SYS_setfsgid32
#endif
// Legacy 32-bit-vs-lfs64 macros
#ifdef SYS_fcntl64
#   undef SYS_fcntl
#   define SYS_fcntl   SYS_fcntl64
#endif
#ifdef SYS_getdents64
#   undef SYS_getdents
#   define SYS_getdents   SYS_getdents64
#endif
#ifdef SYS_ftruncate64
#   undef SYS_ftruncate
#   undef SYS_truncate
#   define SYS_ftruncate   SYS_ftruncate64
#   define SYS_truncate   SYS_truncate64
#endif
#ifdef SYS_stat64
#   undef SYS_stat
#   define SYS_stat   SYS_stat64
#endif
#ifdef SYS_fstat64
#   undef SYS_fstat
#   define SYS_fstat   SYS_fstat64
#endif
#ifdef SYS_lstat64
#   undef SYS_lstat
#   define SYS_lstat   SYS_lstat64
#endif
#ifdef SYS_statfs64
#   undef SYS_statfs
#   define SYS_statfs   SYS_statfs64
#endif
#ifdef SYS_fstatfs64
#   undef SYS_fstatfs
#   define SYS_fstatfs   SYS_fstatfs64
#endif
#ifdef SYS_newfstatat
#   undef SYS_fstatat
#   define SYS_fstatat   SYS_newfstatat
#elif defined(SYS_fstatat64)
#   undef SYS_fstatat
#   define SYS_fstatat   SYS_fstatat64
#endif
#ifdef SYS_ugetrlimit
#   undef SYS_getrlimit
#   define SYS_getrlimit   SYS_ugetrlimit
#endif
#ifdef SYS__newselect
#   undef SYS_select
#   define SYS_select   SYS__newselect
#endif
#ifdef SYS_pread64
#   undef SYS_pread
#   undef SYS_pwrite
#   define SYS_pread   SYS_pread64
#   define SYS_pwrite   SYS_pwrite64
#endif
#ifdef SYS_fadvise64_64
#   undef SYS_fadvise
#   define SYS_fadvise   SYS_fadvise64_64
#elif defined(SYS_fadvise64)
#   undef SYS_fadvise
#   define SYS_fadvise   SYS_fadvise64
#endif
#ifdef SYS_sendfile64
#   undef SYS_sendfile
#   define SYS_sendfile   SYS_sendfile64
#endif


#endif  // LEGACY MACROS


// SYSCALL FUNCTIONS

LIB_FUNC long __syscall_ret(const unsigned long r) {
	if (r > (-4096UL)) { errno = (int)(-r); return -1; }
	return (long)r;
}


LIB_FUNC long syscall(const long n, ...) {
	va_list ap;
	va_start(ap, n);
	syscall_arg_t a, b, c, d, e, f;
	a = va_arg(ap, syscall_arg_t);
	b = va_arg(ap, syscall_arg_t);
	c = va_arg(ap, syscall_arg_t);
	d = va_arg(ap, syscall_arg_t);
	e = va_arg(ap, syscall_arg_t);
	f = va_arg(ap, syscall_arg_t);
	va_end(ap);
	return (long)__syscall_ret(__syscall(n, a, b, c, d, e, f));
}


// IMPORTANT SYSCALLS


LIB_FUNC ssize_t read(const int fd, const void* buf, const size_t count) {
	return (ssize_t)(__syscall3(SYS_read, fd, (long)buf, (long)count));
}
#define __read(fd, buffer, size)   read((fd), (buffer), (size))


LIB_FUNC ssize_t write(const int fd, const void* buf, const size_t count) {
	return (ssize_t)(__syscall3(SYS_write, fd, (long)buf, (long)count));
}
#define __write(fd, buffer, size)   write((fd), (buffer), (size))


LIB_FUNC int close(const int fd) {
	return (int)(__syscall1(SYS_close, fd));
}
#define __close(fd)   close((fd))


LIB_FUNC off_t lseek(const int fd, const off_t offset, const int whence) {
#ifdef SYS__llseek
	off_t result;
	return (off_t)syscall(SYS__llseek, fd, (offset >> 32), offset, &result, whence) ? -1 : result;
#else
	return (off_t)syscall(SYS_lseek, fd, offset, whence);
#endif
}
#define __lseek(fd, pos, whence)   lseek((fd), (pos), (whence))
#define lseek64(fd, pos, whence)   lseek((fd), (pos), (whence))


#endif  // SYSCALL_H


/* SYSCTL (<sysctl.h>) */


#if (!(defined(SYS_SYSCTL_H) || defined(_SYS_SYSCTL_H) || defined(_SYS_SYSCTL_H_)))
#define SYS_SYSCTL_H   (1)
#define _SYS_SYSCTL_H   (1)
#define _SYS_SYSCTL_H_   (1)


/** Unused */
#define CTL_UNSPEC   0
/** "High kernel": proc, limits */
#define CTL_KERN   1
/** Virtual memory */
#define CTL_VM   2
/** File system, mount type is next */
#define CTL_VFS   3
/** Network */
#define CTL_NET   4
/** Debugging parameters */
#define CTL_DEBUG   5
/** Generic CPU/IO */
#define CTL_HW   6
/** Machine dependent */
#define CTL_MACHDEP   7
/** User-level */
#define CTL_USER   8
/** In-kernel debugger */
#define CTL_DDB   9
/** Per-proc attr */
#define CTL_PROC   10
/** Vendor-specific data */
#define CTL_VENDOR   11
/** Emulation-specific data */
#define CTL_EMUL   12
/** Security */
#define CTL_SECURITY   13
/** Number of valid top-level ids */
#define CTL_MAXID   14
/** Largest number of components supported */
#define CTL_MAXNAME   12
/** Longest name allowed for a node */
#define SYSCTL_NAMELEN   32
/** Start of dynamic mib allocation */
#define CREATE_BASE   1024
/** Initial size of a child set */
#define SYSCTL_DEFSIZE   8


struct attr_packed __sysctl_args {
	int* name;
	int nlen;
	void* oldval;
	size_t* oldlenp;
	void* newval;
	size_t newlen;
	unsigned long unused[4];
};


LIB_FUNC int sysctl(int* name, const int nlen, void* oldval, size_t* oldlenp, void* newval, const size_t newlen) {
	struct __sysctl_args args;
	args.name = name;
	args.nlen = nlen;
	args.oldval = oldval;
	args.oldlenp = oldlenp;
	args.newval = newval;
	args.newlen = newlen;
	return (int)syscall(SYS_sysctl, 1, &args);
}


#endif  // SYS_SYSCTL_H


/* ABORT (<abort-instr.h>) */


#if (!(defined(_ABORT_INSTR_H) || defined(_ABORT_INSTR_H_)))
#define _ABORT_INSTR_H   (1)
#define _ABORT_INSTR_H_   (1)


#if (defined(X86) || defined(X86_64))  // x86
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("hlt;")
#   define DebugBreak()   asm("int $3;")
#elif defined(ARM64)  // Aarch64
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("brk #1000;")
#elif defined(HPPA)  // HPPA
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("iitlbp %r0, (%sr0, %r0);")
#elif defined(ITANIUM)  // IA64
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("break 0;")
#elif defined(M68K)  // M68K
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("illegal;")
#elif defined(MICROBLAZE)  // Microblaze
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("brki r0, -1;")
#elif defined(MIPS)  // MIPS
#   ifdef __mips16
/** An instruction that should crash any program */
#      define ABORT_INSTRUCTION   asm volatile ("break 63;")
#   else
/** An instruction that should crash any program */
#      define ABORT_INSTRUCTION   asm volatile ("break 255;")
#   endif
#elif defined(NIOS2)  // NIOS2
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("trap 31;")
#elif defined(POWERPC)  // PowerPC
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile (".long 0;")
#elif defined(S390)  // S390
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile (".word 0;")
#elif defined(SPARC)  // Sparc
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("unimp 0xf00;")
#elif defined(SUPERH)  // SuperH
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("sleep;")
#elif defined(TILE)  // Tile
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   asm volatile ("ill;")
#else
/** An instruction that should crash any program */
#   define ABORT_INSTRUCTION   do { asm volatile (";"); } while (0x1)
#endif
#ifndef ABORT
/** Privileged instruction to crash a userspace program; this directly calls assembly code */
#   define ABORT   ABORT_INSTRUCTION
#endif
#ifndef os_hardware_trap
/** Privileged instruction to crash a userspace program; this directly calls assembly code */
#   define os_hardware_trap()   ABORT_INSTRUCTION
#endif
#ifndef DebugBreak
#   define DebugBreak()
#endif


/** Print the error indicated by the h_errno value */
LIB_FUNC void herror(const char* s) {
	const char* c = colon_space;
	if (!s || !*s) { c += 2; }
	const char* p = error_msg;
	if ((h_errno >= 0) && (h_errno < h_nerr)) { p = h_errlist[h_errno]; }
	fprintf(stderr, "%s%s%s\n", s, c, p);
}
#define _herror(x)   herror((x))


/** Abnormal program termination; this flushes streams before directly calling assembly code */
LIB_FUNC noreturn COLD void _abort(void) {
	fflush(NULL);  // Flush all streams
	ABORT_INSTRUCTION;
	UNREACHABLE
}
#ifndef abort
/** Alias to calling _abort(); Abnormal program termination; this flushes streams before directly calling assembly code */
#   define abort()   _abort()
#endif
#ifndef memory_full
/** Alias to calling _abort(); Abnormal program termination; this flushes streams before directly calling assembly code */
#   define memory_full()   _abort()
#endif


/** Abort the program and supply an error message */
LIB_FUNC noreturn COLD NONNULL void __chk_fail(const char* restrict message) {
	fprintf(stderr, "%s\n", message);
	abort();
	UNREACHABLE
}
#ifndef chk_fail
/** Alias to calling __chk_fail() */
#   define chk_fail(message)   __chk_fail((message))
#endif
#ifndef __fortify_fail
/** Alias to calling __chk_fail() */
#   define __fortify_fail(message)   __chk_fail((message))
#endif
#ifndef fortify_fail
/** Alias to calling __chk_fail() */
#   define fortify_fail(message)   __chk_fail((message))
#endif
#ifndef __libc_fatal
/** Alias to calling __chk_fail() */
#   define __libc_fatal(message)   __chk_fail((message))
#endif
#ifndef libc_fatal
/** Alias to calling __chk_fail() */
#   define libc_fatal(message)   __chk_fail((message))
#endif


/** Force a compile-time error if the condition is zero, but also produce a result (of value 0 and type size_t); Code from the Linux kernel */
#define BUILD_BUG_ON_ZERO(e)   (sizeof(struct { int :-!!(e); }))
/** Force a compile-time error if the condition is NULL, but also produce a result (of value 0 and type size_t); Code from the Linux kernel */
#define BUILD_BUG_ON_NULL(e)   ((void*)sizeof(struct { int :-!!(e); }))


#endif  // ABORT_INSTR_H


/* LOGGING (<err.h> & <syslog.h>) */


#if (!(defined(_SYSLOG_H) || defined(_SYSLOG_H_) || defined(_SYS_SYSLOG_H_) || defined(_LOG_H) || defined(_ERR_H_) || defined(ERR_H_) || defined(__LOG_H__) || defined(_LOGGING_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/syslog.h.html
#define SYSLOG_H   (1)
#define _SYSLOG_H   (1)
#define _SYSLOG_H_   (1)
#define SYS_SYSLOG_H   (1)
#define _SYS_SYSLOG_H_   (1)
#define _LOG_H   (1)
#define _LOG_H_   (1)
#define __LOG_H__   (1)
#define _ERR_H_   (1)
#define ERR_H_   (1)
#define _LOGGING_H   (1)
#define SYS_SUBRPRF_H   (1)
#define _SYS_SUBRPRF_H_   (1)


#define HAVE_DECL_WARNC   (1)
#define HAVE_DECL_VWARNC   (1)
#define HAVE_DECL_ERRC   (1)
#define HAVE_DECL_VERRC   (1)


// Log Levels & Datatypes
/** System is unusable */
#define LOG_EMERG   0
/** Action must be taken immediately */
#define LOG_ALERT   1
/** Critical conditions */
#define LOG_CRIT   2
/** Error conditions */
#define LOG_ERR   3
/** Warning conditions */
#define LOG_WARNING   4
/** Warning conditions */
#define LOG_WARN   LOG_WARNING
/** Normal, but significant condition */
#define LOG_NOTICE   5
/** Informational logging */
#define LOG_INFO   6
/** Debug-level messages */
#define LOG_DEBUG   7
/** Do not log anything */
#define LOG_NONE   8
/** System is unusable */
#define LEVEL_EMERG   LOG_EMERG
/** Action must be taken immediately */
#define LEVEL_ALERT   LOG_ALERT
/** Critical conditions */
#define LEVEL_CRIT   LOG_CRIT
/** Error conditions */
#define LEVEL_ERR   LOG_ERR
/** Warning conditions */
#define LEVEL_WARNING   LOG_WARNING
/** Normal, but significant condition */
#define LEVEL_NOTICE   LOG_NOTICE
/** Informational logging */
#define LEVEL_INFO   LOG_INFO
/** Debug-level messages */
#define LEVEL_DEBUG   LOG_DEBUG
/** Do not log anything */
#define LEVEL_NONE   LOG_NONE
/** Mask to extract logging priority */
#define LOG_PRIMASK   7
/** Extract priority */
#define LOG_PRI(p)   ((p) & LOG_PRIMASK)
#define LOG_MAKEPRI(fac, pri)   (((fac) << 3) | (pri))
/** The "no priority" priority */
#define INTERNAL_NOPRI   0x10
#define LOG_TYPE_OFF   0
#define LOG_TYPE_TTY   1
#define LOG_TYPE_FILE   2
/** Current number of log facilities */
#define LOG_NFACILITIES   24
/** Log mask to extract facility part */
#define LOG_FACMASK   0x03f8
#define LOG_FAC(p)   (((p) & LOG_FACMASK) >> 3)
#define LOG_MASK(pri)   (1 << (pri))
#define LOG_UPTO(pri)   ((1 << ((pri) + 1)) - 1)
/** Log the pid with each message */
#define LOG_PID   1
/** Log on the console if errors in sending */
#define LOG_CONS   2
/** Delay open until first syslog() */
#define LOG_ODELAY   4
/** Do not delay open */
#define LOG_NDELAY   8
/** Do not wait for console forks */
#define LOG_NOWAIT   0x10
/** Log to stderr as well */
#define LOG_PERROR   0x20
// Facility codes
/** Kernel messages */
#define LOG_KERN   (0)
/** Random user-level messages */
#define LOG_USER   (8)
/** Mail system */
#define LOG_MAIL   (16)
/** System daemons */
#define LOG_DAEMON   (24)
/** Security/authorization messages */
#define LOG_AUTH   (32)
/** Messages generated internally by syslogd */
#define LOG_SYSLOG   (40)
/** Line printer subsystem */
#define LOG_LPR   (48)
/** Network news subsystem */
#define LOG_NEWS   (56)
/** UUCP subsystem */
#define LOG_UUCP   (64)
/** Clock daemon */
#define LOG_CRON   (72)
/** Security/authorization messages (private) */
#define LOG_AUTHPRIV   (80)
/** FTP daemon */
#define LOG_FTP   (88)
// Other codes through 15 (reserved for system use) */
#define LOG_LOCAL0   (128)
#define LOG_LOCAL1   (136)
#define LOG_LOCAL2   (144)
#define LOG_LOCAL3   (152)
#define LOG_LOCAL4   (160)
#define LOG_LOCAL5   (168)
#define LOG_LOCAL6   (176)
#define LOG_LOCAL7   (184)
// "flags" argument to prf()
/** Output to console */
#define TOCONS   1
/** Output to tty */
#define TOTTY   2
/** Output to log (log lock not held) */
#define TOLOG   4
/** Output to string */
#define TOSTR   8
/** Output to log (log lock held) */
#define TOLOGLOCKED   0x10

static UNUSED int log_type = LOG_TYPE_OFF;
/** Log file, if needed */
static UNUSED FILE* log_file = NULL;
#if (defined(DEBUG) && (!(defined(NODEBUG) || defined(NDEBUG))))
/** Debug level */
static UNUSED int log_level = LOG_DEBUG;
#else
/** Debug level */
static UNUSED int log_level = LOG_NONE;
#endif

typedef struct attr_packed _code { char* c_name; int c_val; }   CODE;

typedef struct attr_packed syslog_data {
	int log_version, log_file, log_connected, log_opened, log_stat;
	const char* log_tag;
	char log_hostname[256];
	int log_fac, log_mask;
} syslog_data_t;


#define SYSLOG_DATA_INIT   { -1, 0, 0, 0, 0, (const char*)0, "\0", LOG_USER, 0xff }
static UNUSED struct syslog_data sdata = SYSLOG_DATA_INIT;


// ERROR FUNCTIONS

/** Issue an error message and then exit */
LIB_FUNC noreturn __printflike(2, 0) void verr(const int eval, const char* restrict fmt, va_list ap) {
	const int sverrno = errno;
	(void)fprintf(stderr, "%s: ", getprogname());
	if (fmt != NULL) {
		(void)vfprintf(stderr, fmt, ap);
		(void)fprintf(stderr, ": ");
	}
	(void)fprintf(stderr, "%s\n", strerror(sverrno));
	_Exit(eval);
}
#define sh_verr(eval, fmt, ...)   verr((eval), (fmt), (__VA_ARGS__))
#define _verr(eval, fmt, ...)   verr((eval), (fmt), (__VA_ARGS__))


/** Issue an error message and then exit */
LIB_FUNC noreturn __printflike(2, 0) void verrx(const int eval, const char* restrict fmt, va_list ap) {
	(void)fprintf(stderr, "%s: ", getprogname());
	if (fmt != NULL) { (void)vfprintf(stderr, fmt, ap); }
	(void)fprintf(stderr, "\n");
	_Exit(eval);
}
#define sh_verrx(eval, fmt, ap)   verrx((eval), (fmt), (ap))
#define _verrx(eval, fmt, ap)   verrx((eval), (fmt), (ap))


/** Issue an error message and then exit */
LIB_FUNC noreturn __printflike(2, 3) void err(const int eval, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	_verr(eval, fmt, ap);
	va_end(ap);
}
#define sh_err(eval, fmt, ...)   err((eval), (fmt), (__VA_ARGS__))
#define _err(eval, fmt, ...)   err((eval), (fmt), (__VA_ARGS__))


/** Issue an error message and then exit */
LIB_FUNC noreturn __printflike(2, 3) void errx(const int eval, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	_verrx(eval, fmt, ap);
	va_end(ap);
}
#define sh_errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))
#define _sh_errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))
#define _errx(eval, fmt, ...)   errx((eval), (fmt), (__VA_ARGS__))


// WARNING FUNCTIONS

/** Issue an warning message, but do not exit */
LIB_FUNC __printflike(1, 0) void vwarn(const char* restrict fmt, va_list ap) {
	int sverrno = errno;
	(void)fprintf(stderr, "%s: ", getprogname());
	if (fmt != NULL) {
		(void)vfprintf(stderr, fmt, ap);
		(void)fprintf(stderr, ": ");
	}
	(void)fprintf(stderr, "%s\n", strerror(sverrno));
}
#define sh_vwarn(fmt, ap)   vwarn((fmt), (ap))
#define _sh_vwarn(fmt, ap)   vwarn((fmt), (ap))
#define _vwarn(fmt, ap)   vwarn((fmt), (ap))


/** Issue an warning message, but do not exit */
LIB_FUNC __printflike(1, 0) void vwarnx(const char* restrict fmt, va_list ap) {
	(void)fprintf(stderr, "%s: ", getprogname());
	if (fmt != NULL) { (void)vfprintf(stderr, fmt, ap); }
	(void)fprintf(stderr, "\n");
}
#define sh_vwarnx(fmt, ap)   vwarnx((fmt), (ap))
#define _sh_vwarnx(fmt, ap)   vwarnx((fmt), (ap))
#define _vwarnx(fmt, ap)   vwarnx((fmt), (ap))


/** Issue an warning message, but do not exit */
LIB_FUNC __printflike(1, 2) void warn(const char* fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	vwarn(fmt, ap);
	va_end(ap);
}
#define sh_warn(fmt, ...)   warn((fmt), (__VA_ARGS__))
#define _sh_warn(fmt, ...)   warn((fmt), (__VA_ARGS__))
#define _warn(fmt, ...)   warn((fmt), (__VA_ARGS__))


/** Issue an warning message, but do not exit */
LIB_FUNC __printflike(1, 2) void warnx(const char* fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
}
#define sh_warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))
#define _sh_warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))
#define _warnx(fmt, ...)   warnx((fmt), (__VA_ARGS__))


LIB_FUNC void fail(const char* fmt, ...) {
	va_list ap;
	char buf[4096] = { 0 };
	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	warnx("%s", buf);
	warnx("%s", "");
	warnx("This is probably a bug in this application or one of the libraries it uses.");
	abort();
}


// MISCELLANEOUS LOGGING FUNCTIONS

/** Open logging to TTY */
LIB_FUNC void log_open_tty(const int level) {
	log_type = LOG_TYPE_TTY;
	log_level = level;
	setlinebuf(stderr);
	setlinebuf(stdout);
	tzset();
}


/** Open logging to file */
LIB_FUNC void log_open_file(const int level, const char* path) {
	log_file = fopen(path, "w");
	if (log_file == (FILE*)NULL) { return; }
	log_type = LOG_TYPE_FILE;
	log_level = level;
	setlinebuf(log_file);
	tzset();
}


/** Close logging */
LIB_FUNC void log_close(void) {
	if (log_type == LOG_TYPE_FILE) { fclose(log_file); }
	log_type = LOG_TYPE_OFF;
}
#define closelog()   log_close()


/** Write a log message */
LIB_FUNC void log_vwrite(const int pri, const char* msg, va_list ap) {
	FILE* f = log_file;
	switch (log_type) {
		case LOG_TYPE_TTY:
			if (pri == LOG_INFO) { f = stdout; }
			else { f = stderr; }
			fflush(f);
			break;
		case LOG_TYPE_FILE:
			if ((putc('\n', f) == -1) || (vfprintf(f, msg, ap) == -1)) { _Exit(1); }
		default:
			fflush(f);
			break;
	}
}


/** Log a warning with error string */
LIB_FUNC void printflike1 log_warn(const char* msg, ...) {
	va_list ap;
	va_start(ap, msg);
	char* fmt;
	if (asprintf(&fmt, "%s: %s", msg, strerror(errno)) == -1) { _Exit(1); }
	log_vwrite(LOG_CRIT, fmt, ap);
	free(fmt);
	va_end(ap);
}


/** Log a warning */
LIB_FUNC void printflike1 log_warnx(const char* msg, ...) {
	va_list ap;
	va_start(ap, msg);
	log_vwrite(LOG_WARNING, msg, ap);
	va_end(ap);
}


/** Log an informational message */
LIB_FUNC void printflike1 log_info(const char* msg, ...) {
	if (log_level >= LOG_INFO) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_INFO, msg, ap);
		va_end(ap);
	}
}


/** Log a debugging message */
LIB_FUNC void printflike1 log_debug(const char* msg, ...) {
	if (log_level >= LOG_DEBUG) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_DEBUG, msg, ap);
		va_end(ap);
	}
}


/** Log a debugging message at level 2 */
LIB_FUNC noreturn void printflike1 log_debug2(const char* msg, ...) {
	if (log_level == LOG_DEBUG) {
		va_list ap;
		va_start(ap, msg);
		log_vwrite(LOG_DEBUG, msg, ap);
		va_end(ap);
	}
}


/** Log a critical error, with error string if necessary, and die */
LIB_FUNC noreturn void log_vfatal(const char* msg, va_list ap) {
	char* fmt;
	if (errno != 0) {
		if (asprintf(&fmt, "fatal: %s: %s", msg, strerror(errno)) == -1) { _Exit(1); }
		log_vwrite(LOG_CRIT, fmt, ap);
	} else {
		if (asprintf(&fmt, "fatal: %s", msg) == -1) { _Exit(1); }
		log_vwrite(LOG_CRIT, fmt, ap);
	}
	free(fmt);
	_Exit(1);
}


/** Log a critical error, with error string, and die */
LIB_FUNC noreturn void printflike1 log_fatal(const char* msg, ...) {
	va_list ap;
	va_start(ap, msg);
	log_vfatal(msg, ap);
}


/** Log a critical error and die */
LIB_FUNC noreturn void printflike1 log_fatalx(const char* msg, ...) {
	errno = 0;
	va_list ap;
	va_start(ap, msg);
	log_vfatal(msg, ap);
}


/** Display a hex-dump */
LIB_FUNC void hexdump(const unsigned char* d, const unsigned int size) {
	register unsigned int s;
	for (s = 0; s < size; s += 4) {
		fprintf(stdout, "0x%04x 0x%02X%02X%02X%02X %c%c%c%c\n", s, (unsigned int)d[s], (unsigned int)d[s + 1], (unsigned int)d[s + 2], (unsigned int)d[s + 3], d[s], d[s + 1], d[s + 2], d[s + 3]);
	}
}


/** Signal that a fatal error occurred */
#define fatal(msg)   log_fatal("%s: %s", __func__, msg);
/** Signal that a fatal error occurred */
#define fatalx(msg)   log_fatalx("%s: %s", __func__, msg);


/** Set the log mask level */
LIB_FUNC int setlogmask_r(const int pmask, struct syslog_data* data) {
	int omask = data->log_mask;
	if (pmask != 0) { data->log_mask = pmask; }
	return omask;
}


/** Set the log mask level */
LIB_FUNC int setlogmask(const int pmask) {
	return setlogmask_r(pmask, &sdata);
}


/* TODO: Add err.h & syslog.h functions
err_set_exit
err_set_file
void logpri(int);
void log(int, const char*, ...) __printflike(2, 3);
void vlog(int, const char*, __va_list) __printflike(2, 0);
void addlog(const char*, ...) __printflike(1, 2);
void logwakeup(void);
void openlog(const char*, int, int);
void syslog(int, const char*, ...);
*/


#endif  // LOGGING


/* ASSERT (<assert.h>) */


#if (!(defined(_ASSERT_H) || defined(_ASSERT_H_) || defined(_PDCLIB_ASSERT_H)))  // http://www.cplusplus.com/reference/cassert/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/assert.h.html
#define _ASSERT_H   (1)
#define _ASSERT_H_   (1)
#define _PDCLIB_ASSERT_H   (1)


#if (AT_LEAST_GCC46 || IS_STDC_2011)
#   define _FP_STATIC_ASSERT(expr, msg)   _Static_assert((expr), msg)
#else
#endif


#undef assert
#undef _assert
#undef __assert
#undef __ASSERT_VOID_CAST
#if IS_CPLUSPLUS
#   define __ASSERT_VOID_CAST   static_cast<void>
#else
#   define __ASSERT_VOID_CAST   ((void)0)
#endif
#if (defined(__lint__) && (!defined(NDEBUG)))
#   define NDEBUG   (1)
#endif


#if (IS_CPLUSPLUS && defined(__GNUC__))
#   define __ASSERT_FUNCTION   __PRETTY_FUNCTION__
#   define __func__   __PRETTY_FUNCTION__
#else
#   if IS_STDC_1999
#      define __ASSERT_FUNCTION   __FUNCTION__
#      define __func__   __FUNCTION__
#   elif ((__GNUC_PREREQ__(2, 4)) || defined(_MSC_VER))
#      define __ASSERT_FUNCTION   __FUNCTION__
#      define __func__   __FUNCTION__
#   else
#      define __ASSERT_FUNCTION   ((const char*)0)
#      define __func__   ((const char*)0)
#   endif
#endif


#if __GNUC__
#   define __OS_COMPILETIME_ASSERT__(e)   ( __extension__ ({ char __compile_time_assert__[(e) ? 1 : (-1)]; (void)__compile_time_assert__; }))
#   define OS_COMPILETIME_ASSERT(e)   ( __extension__ ({ char __compile_time_assert__[(e) ? 1 : (-1)]; (void)__compile_time_assert__; }))
#else
#   define __OS_COMPILETIME_ASSERT__(e)   (e)
#   define OS_COMPILETIME_ASSERT(e)   (e)
#endif
#define DIAGASSERT_ABORT   1
#define DIAGASSERT_STDERR   2
#define DIAGASSERT_SYSLOG   4

static UNUSED int diagassert_flags = -1;


/* If NDEBUG is defined, do nothing; If not, and EXPRESSION is zero, then print an error message and abort */
#ifdef NDEBUG

#   define assert(expr)   __ASSERT_VOID_CAST
#   define diagassert(expr)   __ASSERT_VOID_CAST
#   define __diagassert(expr)   __ASSERT_VOID_CAST
#   define __assert_fail(expr, file, line, func)   __ASSERT_VOID_CAST

#else  // No NDEBUG


#define __assert(expr, file, line, func)   ((void)fprintf(stderr, "%s:%u: Failed assertion `%s` in `%s`\n", file, line, expr, func), abort())

LIB_FUNC noreturn void __diagassert(const char* restrict failedexpr, const char* restrict file, const int line, const char* restrict function) {
	char buf[1024] = { 0 };
	if (diagassert_flags == -1) {
		diagassert_flags = DIAGASSERT_SYSLOG;
		char* p;
		for (p = getenv("LIBC_DIAGASSERT"); p && *p; p++) {
			switch (*p) {
				case 'a':
					diagassert_flags |= DIAGASSERT_ABORT;
					break;
				case 'A':
					diagassert_flags &= (~DIAGASSERT_ABORT);
					break;
				case 'e':
					diagassert_flags |= DIAGASSERT_STDERR;
					break;
				case 'E':
					diagassert_flags &= (~DIAGASSERT_STDERR);
					break;
				case 'l':
					diagassert_flags |= DIAGASSERT_SYSLOG;
					break;
				case 'L':
					diagassert_flags &= (~DIAGASSERT_SYSLOG);
					break;
				default: break;
			}
		}
	}
	snprintf(buf, sizeof(buf), "assertion \"%s\" failed: file \"%s\", line %d%s%s%s", failedexpr, file, line, function ? ", function \"" : "", function ? function : "", function ? "\"" : "");
	if (diagassert_flags & DIAGASSERT_STDERR) { (void)fprintf(stderr, "%s: %s\n", getprogname(), buf); }
	if (diagassert_flags & DIAGASSERT_SYSLOG) { syslog((LOG_DEBUG | LOG_USER), "%s", buf); }
	if (diagassert_flags & DIAGASSERT_ABORT) { abort(); }
}


#ifdef __GNUC__
#   define assert(expr)   (__builtin_expect(!(expr), 0) ? __assert(#expr, __FILE__, __LINE__, __func__) : (void)0)
#   define diagassert(expression)   (__builtin_expect(!(expression), 0) ? __diagassert(#expression, __FILE__, __LINE__, __func__) : __static_cast(void, 0))
#else  // Not GNU-GCC
#   define assert(expr)   ((void)((expr) ? ((void)0) : __assert(#expr, __FILE__, __LINE__, __func__)))
#   define diagassert(expression)   ((void)((expression) ? __static_cast(void, 0) : __diagassert(#expression, __FILE__, __LINE__, __func__)))
#endif  // __GNUC__


LIB_FUNC void __assert_fail(const char* expr, const char* file, int line, const char* func) {
	fprintf(stderr, "Assertion failed: %s (%s: %s: %d)\n", expr, file, func, line);
	fflush(NULL);
	abort();
}


#endif  // NDEBUG


#define _assert(expression)   assert(expression)
#define __assert13(expression)   assert(expression)
#define ASSERT(expression)   assert(expression)
#define ASSERTION(expression)   assert(expression)
#define assertion(expression)   assert(expression)
#define __diagassert13(expression)   diagassert(expression)
#define diagassert13(expression)   diagassert(expression)
#define _DIAGASSERT(expression)   diagassert(expression)
#define DIAGASSERT(expression)   diagassert(expression)
#define __warn_references(x, y)


#if DEBUG
#   define __reent_assert(x)   assert(x)
#else
#   define __reent_assert(x)   ((void)0)
#endif
/** Debugging macros that prints the line number and filename indicating the location of the macro; This allows developers to more quickly debug applications by getting a location printed to stdout; `TAG` must be a string; A newline is append to the end */
#define DEBUGPRINT(TAG)   fprintf(stderr, WHERESTR "%s\n", WHEREARG, TAG)


#ifndef BUG_ON
#   define BUG_ON(c)   assert(!(c))
#endif
#ifndef WARN_ON
#   define WARN_ON(c)   BUG_ON((c))
#endif


#endif  // ASSERT_H


/* STAT (<sys/stat.h>) */


#if (!(defined(_SYS_STAT_H) || defined(STAT_H) || defined(_BITS_STAT_STRUCT_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html
#define SYS_STAT_H   (1)
#define _SYS_STAT_H   (1)
#define _SYS_STAT_H_   (1)
#define STAT_H   (1)
#define _BITS_STAT_STRUCT_H   (1)
#define __JSRE_H   (1)


// Versions of the `struct stat` data structure
#ifndef _STAT_VER_LINUX_OLD
#   define _STAT_VER_LINUX_OLD   1
#endif
#ifndef _STAT_VER_KERNEL
#   define _STAT_VER_KERNEL   1
#endif
#ifndef _STAT_VER_SVR4
#   define _STAT_VER_SVR4   2
#endif
#ifndef _STAT_VER_LINUX
#   define _STAT_VER_LINUX   3
#endif
#ifndef _STAT_VER
#   define _STAT_VER   _STAT_VER_LINUX
#endif
// Versions of the `xmknod` interface
#define _MKNOD_VER_LINUX   1
#define _MKNOD_VER_SVR4   2
#define _MKNOD_VER   _MKNOD_VER_LINUX
/** For 32-bit architectures, this struct is similar to the stat64 but it uses 32-bit members along with 32-bit padding. For 64-bit architectures this struct is exactly the same with the stat64 one */
typedef struct ARCH_64BIT_ALIGNMENT stat {
#ifndef __USE_FILE_OFFSET64
#   if IS_LITTLE_ENDIAN
	unsigned long st_dev;  // Device
	unsigned long __pad1;
	unsigned long st_ino;  // 32-bit file serial number
	unsigned long __pad2;
	unsigned int st_mode;  // File mode
	unsigned int st_nlink;  // Link count
	unsigned int st_uid;  // User ID of the file's owner
	unsigned int st_gid;  // Group ID of the file's group.
	unsigned long st_rdev;  // Device number, if device
	unsigned long __pad3;
	unsigned long long __pad4;
	long st_size;  // SIze of file, in bytes
	long __pad5;
	int st_blksize;  // Optimal block size for I/O
	int __pad6;
	long st_blocks;  // Number 512-byte blocks allocated
	long __pad7;
#   else
	unsigned long __pad1;
	unsigned long st_dev;  // Device
	unsigned long __pad2;
	unsigned long st_ino;  // 32bit file serial number
	unsigned int st_mode;  // File mode
	unsigned int st_nlink;  // Link count
	unsigned int st_uid;  // User ID of the file's owner
	unsigned int st_gid;  // Group ID of the file's group.
	unsigned long __pad3;
	unsigned long st_rdev;  // Device number, if device
	unsigned long long __pad4;
	long __pad5;
	long st_size;  // Size of file, in bytes
	int st_blksize;  // Optimal block size for I/O
	int __pad6;
	long __pad7;
	long st_blocks;  // Number 512-byte blocks allocated
#   endif  // LITTLE_ENDIAN
#else
	unsigned long long st_dev;  // Device
	unsigned long long st_ino;  // 32bit file serial number
	unsigned int st_mode;  // File mode
	unsigned int st_nlink;  // Link count
	unsigned int st_uid;  // User ID of the file's owner
	unsigned int st_gid;  // Group ID of the file's group.
	unsigned long long st_rdev;  // Device number, if device
	unsigned long long _pad1;
	long long st_size;  // SIze of file, in bytes
	int st_blksize;  // Optimal block size for I/O
	int __pad2;
	long long st_blocks;  // Number 512-byte blocks allocated
#endif
#ifdef __USE_MISC
#   ifndef __USE_FILE_OFFSET64
	long st_atime;  // Time of last access
	unsigned long st_atime_nsec;
	long st_mtime;  // Time of last modification
	unsigned long st_mtime_nsec;
	long st_ctime;  // Time of last status change
	unsigned long st_ctime_nsec;
#   else
	int st_atime;  // Time of last access
	unsigned int st_atime_nsec;
	int st_mtime;  // Time of last modification
	unsigned int st_mtime_nsec;
	int st_ctime;  // Time of last status change
	unsigned int st_ctime_nsec;
#   endif
#else
	struct timespec st_atim;  // Time of last access
	struct timespec st_mtim;  // Time of last modification
	struct timespec st_ctim;  // Time of last status change
#   define st_atime   st_atim.tv_sec  // Backward compatibility
#   define st_mtime   st_mtim.tv_sec
#   define st_ctime   st_ctim.tv_sec
#endif
	unsigned int __unused4, __unused5;
} stat_t;
#ifdef __USE_LARGEFILE64  // stat64
typedef struct stat64 {
	unsigned long long st_dev;  // Device
	unsigned long long st_ino;  // 32bit file serial number
	unsigned int st_mode;  // File mode
	unsigned int st_nlink;  // Link count
	unsigned int st_uid;  // User ID of the file's owner
	unsigned int st_gid;  // Group ID of the file's group.
	unsigned long long st_rdev;  // Device number, if device
	unsigned long long __pad3;
	long long st_size;  // Size of file, in bytes
	int st_blksize;  // Optimal block size for I/O
	int __pad4;
	long long st_blocks;  // Number 512-byte blocks allocated
#   ifdef __USE_MISC
	int st_atime;  // Time of last access
	unsigned int st_atime_nsec;
	int st_mtime;  // Time of last modification
	unsigned int st_mtime_nsec;
	int st_ctime;  // Time of last status change
	unsigned int st_ctime_nsec;
#   else
	struct timespec st_atim;  // Time of last access
	struct timespec st_mtim;  // Time of last modification
	struct timespec st_ctim;  // Time of last status change
#   endif
	unsigned int __unused4, __unused5;
} stat64_t;
#   define kernel_stat64   stat64
#else
#   define kernel_stat64   stat
#   define stat64   stat
#endif  // stat64


// Tell code we have these members
#define _STATBUF_ST_BLKSIZE
#define _STATBUF_ST_RDEV
/** Nanosecond resolution time values are supported */
#define _STATBUF_ST_NSEC
/** Encoding of the file mode */
#define __S_IFMT   (0170000)


// FILE-TYPES

/** Directory */
#define __S_IFDIR   (040000)
/** Character device */
#define __S_IFCHR   (020000)
/** Block device */
#define __S_IFBLK   (060000)
/** Regular file */
#define __S_IFREG   (0100000)
/** FIFO */
#define __S_IFIFO   (010000)
/** Symbolic link */
#define __S_IFLNK   (0120000)
/** Socket */
#define __S_IFSOCK   (0140000)
// POSIX.1b objects; Note that these macros always evaluate to zero
#define __S_TYPEISMQ(buf)   ((buf)->st_mode - (buf)->st_mode)
#define __S_TYPEISSEM(buf)   ((buf)->st_mode - (buf)->st_mode)
#define __S_TYPEISSHM(buf)   ((buf)->st_mode - (buf)->st_mode)


// PROTECTION BITS

/** Set user ID on execution */
#define __S_ISUID   (04000)
/** Set user ID on execution */
#define _S_ISUID   (04000)
/** Set group ID on execution */
#define __S_ISGID   (02000)
/** Set group ID on execution */
#define _S_ISGID   (02000)
/** Save swapped text after use (sticky) */
#define __S_ISVTX   (01000)
/** Save swapped text after use (sticky) */
#define _S_ISVTX   (01000)
/** Read by owner */
#define __S_IREAD   (0400)
/** Read by owner */
#define _S_IREAD   (0400)
/** Write by owner */
#define __S_IWRITE   (0200)
/** Write by owner */
#define _S_IWRITE   (0200)
/** Execute by owner */
#define __S_IEXEC   (0100)
/** Execute by owner */
#define _S_IEXEC   (0100)
#define ALL_S_IREAD   (_S_IREAD  | (_S_IREAD  >> 3) | (_S_IREAD  >> 6))
#define ALL_S_IWRITE   (_S_IWRITE | (_S_IWRITE >> 3) | (_S_IWRITE >> 6))
#define ALL_S_IEXEC   (_S_IEXEC  | (_S_IEXEC  >> 3) | (_S_IEXEC  >> 6))
#ifndef UTIME_NOW
#   define UTIME_NOW   (0x3fffffffL)
#endif
#ifndef UTIME_OMIT
#   define UTIME_OMIT   (0x3ffffffeL)
#endif
#define S_IFMT   __S_IFMT
#define S_IFDIR   __S_IFDIR
#define S_IFCHR   __S_IFCHR
#define S_IFBLK   __S_IFBLK
#define S_IFREG   __S_IFREG
#ifdef __S_IFIFO
#   define S_IFIFO   __S_IFIFO
#endif
#ifdef __S_IFLNK
#   define S_IFLNK   __S_IFLNK
#endif
#ifdef __S_IFSOCK
#   define S_IFSOCK   __S_IFSOCK
#endif
/** Set user ID on execution */
#define S_ISUID   __S_ISUID
/** Set group ID on execution */
#define S_ISGID   __S_ISGID
/** Save swapped text after use (sticky bit) */
#define S_ISVTX   __S_ISVTX
/** Read by owner */
#define S_IRUSR   __S_IREAD
/** Write by owner */
#define S_IWUSR   __S_IWRITE
/** Execute by owner */
#define S_IXUSR   __S_IEXEC
/** Read, write, and execute by owner */
#define S_IRWXU   (__S_IREAD | __S_IWRITE | __S_IEXEC)
/** Read by owner */
#define S_IREAD   S_IRUSR
/** Write by owner */
#define S_IWRITE   S_IWUSR
/** Read, write, and execute by owner */
#define S_IEXEC   S_IXUSR
/** Read by group */
#define S_IRGRP   (S_IRUSR >> 3)
/** Write by group */
#define S_IWGRP   (S_IWUSR >> 3)
/** Execute by group */
#define S_IXGRP   (S_IXUSR >> 3)
/** Read, write, and execute by group */
#define S_IRWXG   (S_IRWXU >> 3)
/** Read by others */
#define S_IROTH   (S_IRGRP >> 3)
/** Write by others */
#define S_IWOTH   (S_IWGRP >> 3)
/** Execute by others */
#define S_IXOTH   (S_IXGRP >> 3)
/** Read, write, and execute by others */
#define S_IRWXO   (S_IRWXG >> 3)
#define AT_FDCWD   (-100)
#define AT_SYMLINK_NOFOLLOW   0x100
#define AT_REMOVEDIR   0x200
#define AT_SYMLINK_FOLLOW   0x400
#define AT_EACCESS   0x200


// TEST MACROS FOR FILETYPES

#define __S_ISTYPE(mode, mask)   (((mode) & __S_IFMT) == (mask))
#define S_ISDIR(mode)   __S_ISTYPE((mode), __S_IFDIR)
#define S_ISCHR(mode)   __S_ISTYPE((mode), __S_IFCHR)
#define S_ISBLK(mode)   __S_ISTYPE((mode), __S_IFBLK)
#define S_ISREG(mode)   __S_ISTYPE((mode), __S_IFREG)
#ifdef __S_IFIFO
#   define S_ISFIFO(mode)   __S_ISTYPE((mode), __S_IFIFO)
#endif
#ifdef __S_IFLNK
#   define S_ISLNK(mode)   __S_ISTYPE((mode), __S_IFLNK)
#endif
#ifndef __S_IFLNK
#   define S_ISLNK(mode)   (0)
#endif
#ifdef __S_IFSOCK
#   define S_ISSOCK(mode)   __S_ISTYPE((mode), __S_IFSOCK)
#endif
#define S_TYPEISMQ(buf)   __S_TYPEISMQ(buf)
#define S_TYPEISSEM(buf)   __S_TYPEISSEM(buf)
#define S_TYPEISSHM(buf)   __S_TYPEISSHM(buf)


// MACROS FOR COMMON MODE BIT MASKS

/** 0777 */
#define ACCESSPERMS   (S_IRWXU | S_IRWXG | S_IRWXO)
/** 07777 */
#define ALLPERMS   (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
/** 0666 */
#define DEFFILEMODE   (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)
#ifndef S_BLKSIZE
/** Block size for `st_blocks` */
#   define S_BLKSIZE   (512)
#endif
#ifndef S_ISTXT
#   ifdef S_ISVTX
#      define S_ISTXT   S_ISVTX
#   else
#      define S_ISTXT   (0)
#   endif
#endif


// MISC FILE-STATUS FLAGS

#if (defined(I386) || defined(X86_64) || defined(S390) || defined(ITANIUM))
/** Open for reading only */
#   define O_RDONLY   0
/** Open for writing only */
#   define O_WRONLY   1
/** Open for reading and writing */
#   define O_RDWR   2
/** Mask for above modes */
#   define O_ACCMODE   3
/** Create if nonexistent */
#   define O_CREAT   0100
#   define O_TMPFILE   020200000
#   define __O_TMPFILE   020200000
/** Error if already exists */
#   define O_EXCL   0200
/** Do not assign controlling terminal */
#   define O_NOCTTY   0400
/** Truncate to zero length */
#   define O_TRUNC   01000
/** Set append mode */
#   define O_APPEND   02000
/** No delay */
#   define O_NONBLOCK   04000
#   define O_NDELAY   O_NONBLOCK
/** Synchronous writes */
#   define O_SYNC   010000
#   define FASYNC   020000
/** Direct I/O hint */
#   define O_DIRECT   040000
#   define O_LARGEFILE   0100000
/** Fail if not a directory */
#   define O_DIRECTORY   0200000
/** Do not follow symlinks on the last */
#   define O_NOFOLLOW   0400000
#   define O_NOATIME   01000000
/** Resolve pathname but do not open file */
#   define O_PATH   010000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   5
#   define F_SETLK   6
#   define F_SETLKW   7
#   define F_SETOWN   8
#   define F_GETOWN   9
#   define F_SETSIG   10
#   define F_GETSIG   11
#   define F_GETLK64   12
#   define F_SETLK64   13
#   define F_SETLKW64   14
#   define FD_CLOEXEC   1
#   define F_RDLCK   0
#   define F_WRLCK   1
#   define F_UNLCK   2
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct attr_packed flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
typedef struct attr_packed flock64 {
	int16_t l_type, l_whence;
	loff_t l_start, l_len;
	pid_t  l_pid;
} flock64_t;

#elif defined(ALPHA)

#   define O_ACCMODE   3
#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_CREAT   01000
#   define O_TMPFILE   020040000
#   define __O_TMPFILE   020040000
#   define O_TRUNC   02000
#   define O_EXCL   04000
#   define O_NOCTTY   010000
#   define O_NONBLOCK   4
#   define O_APPEND   010
#   define O_NDELAY   O_NONBLOCK
#   define O_SYNC   040000
#   define FASYNC   020000
#   define O_DIRECTORY   0100000
#   define O_NOFOLLOW   0200000
#   define O_LARGEFILE   0400000
#   define O_DIRECT   02000000
#   define O_NOATIME   04000000
#   define O_PATH   040000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   7
#   define F_SETLK   8
#   define F_SETLKW   9
#   define F_SETOWN   5
#   define F_GETOWN   6
#   define F_SETSIG   10
#   define F_GETSIG   11
#   define FD_CLOEXEC   1
#   define F_RDLCK   1
#   define F_WRLCK   2
#   define F_UNLCK   8
#   define F_EXLCK   16
#   define F_SHLCK   32
#   define F_INPROGRESS   64
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;

#elif defined(MIPS)

#   define O_ACCMODE   3
#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_APPEND   8
#   define O_SYNC   0x10
#   define O_NONBLOCK   0x80
#   define O_CREAT   0x100
#   define O_TMPFILE   020200000
#   define __O_TMPFILE   020200000
#   define O_TRUNC   0x200
#   define O_EXCL   0x400
#   define O_NOCTTY   0x800
#   define FASYNC   0x1000
#   define O_LARGEFILE   0x2000
#   define O_DIRECT   0x8000
#   define O_DIRECTORY   0x10000
#   define O_NOFOLLOW   0x20000
#   define O_NOATIME   0x40000
#   define O_NDELAY   O_NONBLOCK
#   define O_PATH   010000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   14
#   define F_SETLK   6
#   define F_SETLKW   7
#   define F_SETOWN   24
#   define F_GETOWN   23
#   define F_SETSIG   10
#   define F_GETSIG   11
#   ifndef __mips64__
#      define F_GETLK64   33
#      define F_SETLK64   34
#      define F_SETLKW64   35
#   endif
#   define FD_CLOEXEC   1
#   define F_RDLCK   0
#   define F_WRLCK   1
#   define F_UNLCK   2
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
#   ifndef __mips64__
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	long l_sysid;
	pid_t l_pid;
	long  pad[4];
} flock_t;
typedef struct flock64 {
	int16_t l_type, l_whence;
	loff_t l_start, l_len;
	pid_t l_pid;
} flock64_t;
#   else
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
#      define flock64   flock
#   endif

#elif defined(SPARC)

#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_ACCMODE   3
#   define O_APPEND   8
#   define FASYNC   0x40
#   define O_CREAT   0x200
#   define O_TMPFILE   020200000
#   define __O_TMPFILE   020200000
#   define O_TRUNC   0x400
#   define O_EXCL   0x800
#   define O_SYNC   0x2000
#   define O_NONBLOCK   0x4000
#   define O_NDELAY   (4 | O_NONBLOCK)
#   define O_NOCTTY   0x8000
#   define O_DIRECTORY   0x10000
#   define O_NOFOLLOW   0x20000
#   define O_LARGEFILE  0x40000
#   define O_DIRECT   0x100000
#   define O_NOATIME   0x200000
#   define O_PATH   0x1000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETOWN   5
#   define F_SETOWN   6
#   define F_GETLK   7
#   define F_SETLK   8
#   define F_SETLKW   9
#   define F_SETSIG   10
#   define F_GETSIG   11
#   define F_GETLK64   12
#   define F_SETLK64   13
#   define F_SETLKW64   14
#   define FD_CLOEXEC   1
#   define F_RDLCK   1
#   define F_WRLCK   2
#   define F_UNLCK   3
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
#   ifdef __arch64__
#      define flock64 flock
#   else
typedef struct flock64 {
	int16_t l_type, l_whence;
	loff_t l_start, l_len;
	pid_t l_pid;
} flock64_t;
#   endif

#elif (defined(POWERPC) || defined(POWERPC64))

#   define O_ACCMODE   3
#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_CREAT   0100
#   define O_TMPFILE   020040000
#   define __O_TMPFILE   020040000
#   define O_EXCL   0200
#   define O_NOCTTY   0400
#   define O_TRUNC   01000
#   define O_APPEND   02000
#   define O_NONBLOCK   04000
#   define O_NDELAY   O_NONBLOCK
#   define O_SYNC   010000
#   define FASYNC   020000
#   define O_DIRECTORY   040000
#   define O_NOFOLLOW   0100000
#   define O_LARGEFILE   0200000
#   define O_DIRECT   0400000
#   define O_NOATIME   01000000
#   define O_PATH   010000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   5
#   define F_SETLK   6
#   define F_SETLKW   7
#   define F_SETOWN   8
#   define F_GETOWN   9
#   define F_SETSIG   10
#   define F_GETSIG   11
#   define F_GETLK64   12
#   define F_SETLK64   13
#   define F_SETLKW64   14
#   define FD_CLOEXEC   1
#   define F_RDLCK   0
#   define F_WRLCK   1
#   define F_UNLCK   2
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
typedef struct flock64 {
	int16_t l_type, l_whence;
	loff_t l_start, l_len;
	pid_t  l_pid;
} flock64_t;

#elif defined(ARM)

#   define O_ACCMODE   3
#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_CREAT   0100
#   define O_TMPFILE   020040000
#   define __O_TMPFILE   020040000
#   define O_EXCL   0200
#   define O_NOCTTY   0400
#   define O_TRUNC   01000
#   define O_APPEND   02000
#   define O_NONBLOCK   04000
#   define O_NDELAY   O_NONBLOCK
#   define O_SYNC   010000
#   define FASYNC   020000
#   define O_DIRECTORY   040000
#   define O_NOFOLLOW   0100000
#   define O_DIRECT   0200000
#   define O_LARGEFILE   0400000
#   define O_NOATIME   01000000
#   define O_PATH   010000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   5
#   define F_SETLK   6
#   define F_SETLKW   7
#   define F_SETOWN   8
#   define F_GETOWN   9
#   define F_SETSIG   10
#   define F_GETSIG   11
#   define F_GETLK64   12
#   define F_SETLK64   13
#   define F_SETLKW64   14
#   define FD_CLOEXEC   1
#   define F_RDLCK   0
#   define F_WRLCK   1
#   define F_UNLCK   2
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
typedef struct flock64 {
	int16_t l_type, l_whence;
	loff_t l_start, l_len;
	pid_t  l_pid;
} flock64_t;

#elif defined(HPPA)

#   define O_RDONLY   0
#   define O_WRONLY   1
#   define O_RDWR   2
#   define O_ACCMODE   3
#   define O_APPEND   010
#   define O_BLKSEEK   0100
#   define O_CREAT   0400
#   define O_TRUNC   01000
#   define O_EXCL   02000
#   define O_LARGEFILE   04000
#   define O_ASYNC   020000
#   define O_SYNC   0100000
#   define O_NONBLOCK   0200004
#   define O_NDELAY   O_NONBLOCK
#   define O_NOCTTY   0400000
#   define O_DSYNC   01000000
#   define O_RSYNC   02000000
#   define O_NOATIME   04000000
#   define O_DIRECTORY   010000
#   define O_DIRECT   040000
#   define O_NOFOLLOW   0200
#   define O_INVISIBLE   04000000
#   define O_PATH   020000000
#   define F_DUPFD   0
#   define F_GETFD   1
#   define F_SETFD   2
#   define F_GETFL   3
#   define F_SETFL   4
#   define F_GETLK   5
#   define F_SETLK   6
#   define F_SETLKW   7
#   define F_GETLK64   8
#   define F_SETLK64   9
#   define F_SETLKW64   10
#   define F_GETOWN   11
#   define F_SETOWN   12
#   define F_SETSIG   13
#   define F_GETSIG   14
#   define FD_CLOEXEC   1
#   define F_RDLCK   1
#   define F_WRLCK   2
#   define F_UNLCK   3
#   define F_EXLCK   4
#   define F_SHLCK   8
#   define F_INPROGRESS   16
#   define LOCK_SH   1
#   define LOCK_EX   2
#   define LOCK_NB   4
#   define LOCK_UN   8
#   define LOCK_MAND   32
#   define LOCK_READ   64
#   define LOCK_WRITE   128
#   define LOCK_RW   192
typedef struct flock {
	int16_t l_type, l_whence;
	off_t l_start, l_len;
	pid_t l_pid;
} flock_t;
typedef struct flock64 {
	int16_t l_type, l_whence;
	off64_t l_start, l_len;
	pid_t l_pid;
} flock64_t;

#endif
#if (defined(HAVE_STRUCT_STAT_ST_FLAGS) && HAVE_STRUCT_STAT_ST_FLAGS && (defined(OSNETBSD) || defined(OSMINIX)))
#   define UF_SETTABLE   0xffff
#   define UF_NODUMP   1
#   define UF_IMMUTABLE   2
#   define UF_APPEND   4
#   define UF_OPAQUE   8
#   define SF_SETTABLE   0xffff0000
#   define SF_ARCHIVED   0x10000
#   define SF_IMMUTABLE   0x20000
#   define SF_APPEND   0x40000
#endif
#ifndef F_SETLKW
#   define F_SETLKW   14
#endif
#define F_SETOWN_EX   15
#define F_GETOWN_EX   16
#define F_GETOWNER_UIDS   17
#define FREAD   1
#define FWRITE   2
/** Open with shared file lock */
#define O_SHLOCK   0x10
/** Open with exclusive file lock */
#define O_EXLOCK   0x20
/** Write: I/O data completion */
#define O_DSYNC   0x10000
/** Read: I/O completion as for write */
#define O_RSYNC   0x20000
/** Use alternate I/O semantics */
#define O_ALT_IO   0x40000
/** Set close on exec */
#define O_CLOEXEC   0x400000
/** Do not deliver sigpipe */
#define O_NOSIGPIPE   0x1000000
#ifndef O_ASYNC
/** Signal pgrp when data ready */
#   define O_ASYNC   0x40
#endif
/** All settable bits during open(2) */
#define O_MASK   (O_ACCMODE | O_NONBLOCK | O_APPEND | O_SHLOCK | O_EXLOCK | O_ASYNC | O_SYNC | O_CREAT | O_TRUNC | O_EXCL | O_DSYNC | O_RSYNC | O_NOCTTY | O_ALT_IO | O_NOFOLLOW | O_DIRECT | O_DIRECTORY | O_CLOEXEC | O_NOSIGPIPE)
/** All the mode bits that can be affected by chmod */
#define CHMOD_MODE_BITS   (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
/** Read only */
#define FSSH_B_READ_ONLY   O_RDONLY
/** Read only */
#define FSSH_O_RDONLY   O_RDONLY
/** Write only */
#define FSSH_B_WRITE_ONLY   O_WRONLY
/** Write only */
#define FSSH_O_WRONLY   O_WRONLY
#define JSRE_POSIX1_SIGNALCODE   0x2101
#define SPE_POSIX1_FTOK   5
#define SPE_POSIX1_MMAP   0xb
#define SPE_POSIX1_MUNMAP   0xe
#define SPE_POSIX1_MREMAP   0xc
#define SPE_POSIX1_MSYNC   0xd
#define SPE_POSIX1_SHMGET   0x14
#define SPE_POSIX1_SHMCTL   0x12
#define SPE_POSIX1_SHMAT   0x11
#define SPE_POSIX1_SHMDT   0x13
#define SPE_POSIX1_SHM_OPEN   0x15
#define SPE_POSIX1_SHM_UNLINK   0x16
#define JSRE_LIBEA_SIGNALCODE   0x2105
#define SPE_LIBEA_CALLOC   1
#define SPE_LIBEA_FREE   2
#define SPE_LIBEA_MALLOC   3
#define SPE_LIBEA_REALLOC   4
#define SPE_LIBEA_POSIX_MEMALIGN   5
#define JSRE_POSIX1_SIGNALCODE   0x2101
#define JSRE_CLOSE   2
#define JSRE_FSTAT   4
#define JSRE_GETPAGESIZE   6
#define JSRE_GETTIMEOFDAY   7
#define JSRE_LSEEK   9
#define JSRE_LSTAT   10
#define JSRE_MMAP   11
#define JSRE_MREMAP   12
#define JSRE_MSYNC   13
#define JSRE_MUNMAP   14
#define JSRE_OPEN   15
#define JSRE_READ   16
#define JSRE_SHM_OPEN   21
#define JSRE_SHM_UNLINK   22
#define JSRE_STAT   23
#define JSRE_UNLINK   24
#define JSRE_WRITE   27
#define JSRE_FTRUNCATE   28
#define JSRE_ACCESS   29
#define JSRE_DUP   30
#define JSRE_NANOSLEEP   32
#define JSRE_CHDIR   33
#define JSRE_FCHDIR   34
#define JSRE_MKDIR   35
#define JSRE_MKNOD   36
#define JSRE_RMDIR   37
#define JSRE_CHMOD   38
#define JSRE_FCHMOD   39
#define JSRE_CHOWN   40
#define JSRE_FCHOWN   41
#define JSRE_LCHOWN   42
#define JSRE_GETCWD   43
#define JSRE_LINK   44
#define JSRE_SYMLINK   45
#define JSRE_READLINK   46
#define JSRE_SYNC   47
#define JSRE_FSYNC   48
#define JSRE_FDATASYNC   49
#define JSRE_DUP2   50
#define JSRE_LOCKF   51
#define JSRE_TRUNCATE   52
#define JSRE_MKSTEMP   53
#define JSRE_MKTEMP   54
#define JSRE_OPENDIR   55
#define JSRE_CLOSEDIR   56
#define JSRE_READDIR   57
#define JSRE_REWINDDIR   58
#define JSRE_SEEKDIR   59
#define JSRE_TELLDIR   60
#define JSRE_SCHED_YIELD   61
#define JSRE_UMASK   62
#define JSRE_UTIME   63
#define JSRE_UTIMES   64
#define JSRE_PREAD   65
#define JSRE_PWRITE   66
#define JSRE_READV   67
#define JSRE_WRITEV   68


static const UNUSED char* mode_rwa[16] = {
	"r", "rb", "r+", "rb+", "r+b",
	"w", "wb", "w+", "wb+", "w+b",
	"a", "ab", "a+", "ab+", "a+b",
	NULL
};
static const UNUSED char* mode_r[8] = { "r", "rb", "r+", "rb+", "r+b", NULL };
static const UNUSED char* mode_w[8] = { "w", "wb", "w+", "wb+", "w+b", NULL };
static const UNUSED char* mode_a[8] = { "a", "ab", "a+", "ab+", "a+b", NULL };


LIB_FUNC int fstat(const int fd, struct stat* st) {
	const int ret = (int)__syscall2(SYS_fstat, fd, (long)st);
	if (ret != -EBADF || ((long)(__syscall2(SYS_fcntl, fd, F_GETFD)) < 0)) {
		return (int)__syscall_ret((unsigned long)ret);
	}
	char _buf[15 + (3 * SIZEOF_INT)] = { 0 };
	procfdname(_buf, (unsigned int)fd);
#ifdef SYS_stat
	return (int)syscall(SYS_stat, _buf, st);
#else
	return (int)syscall(SYS_fstatat, AT_FDCWD, _buf, st, 0);
#endif
}
#define __fstat(f, _buf)   fstat((f), (_buf))
#define fstat64(f, _buf)   fstat((f), (_buf))
#define __fstat64(f, _buf)   fstat((f), (_buf))
#define fxstat64(f, _buf)   fstat((f), (_buf))
#define __fxstat64(f, _buf)   fstat((f), (_buf))
#define fxstat(f, _buf)   fstat((f), (_buf))
#define __fxstat(f, _buf)   fstat((f), (_buf))


#ifdef ARCHMIPS


/** Get information about the file NAME in BUF */
LIB_FUNC int lxstat64(const UNUSED int vers, const char* name, struct stat64* buf) {
	return (int)syscall(SYS_lstat64, 2, (long)&name, (long)&buf);
}
#define ___lxstat64(vers, name, buf)   lxstat64((vers), (name), (buf))
#define __lxstat64(vers, name, buf)   lxstat64((vers), (name), (buf))
#define __lxstat(vers, name, buf)   lxstat64((vers), (name), (buf))
#define lxstat(vers, name, buf)   lxstat64((vers), (name), (buf))


LIB_FUNC int lstat64(const char* file, struct stat64* buf) {
	return lxstat64(_STAT_VER, file, buf);
}
#define lstat(file, buf)   lstat64((file), (buf))


/** Get information about the file NAME in BUF */
LIB_FUNC int xstat64(const int vers, const char* name, struct stat64* buf) {
	if (vers == _STAT_VER_KERNEL) {
		return (int)syscall(SYS_fstatat64, 4, AT_FDCWD, (long)&name, (long)&buf, 0);
	}
	errno = EINVAL;
	return -1;
}


LIB_FUNC int stat64(const char* file, struct stat64* buf) {
	return xstat64(_STAT_VER, file, buf);
}


#else


/** Get information about the file NAME in BUF */
LIB_FUNC int xstat64(const int vers, const char* name, struct stat64* buf) {
	if (vers == _STAT_VER_KERNEL) {
		return (int)syscall(SYS_fstatat, 4, AT_FDCWD, (long)&name, (long)&buf, 0);
	}
	errno = EINVAL;
	return -1;
}


LIB_FUNC int stat64(const char* name, struct stat* buf) {
	const int fd = open(name, 0, 0);
	if (fd < 0) { return -1; }
	const int rv = fstat(fd, buf);
	(void)close(fd);
	return rv;
}


#endif
#define ___xstat64(vers, name, buf)   xstat64((vers), (name), (buf))
#define __xstat64(vers, name, buf)   xstat64((vers), (name), (buf))
#define __xstat(vers, name, buf)   xstat64((vers), (name), (buf))
#define xstat(vers, name, buf)   xstat64((vers), (name), (buf))


/* TODO: Add sys/stat functions
int chmod(const char*, mode_t);
int fchmod(int, mode_t);
int fchmodat(int, const char*, mode_t, int);
int fstatat(int, const char* restrict, struct stat* restrict, int);
int futimens(int, const struct timespec[2]);
int lstat(const char* restrict, struct stat* restrict);
int mkdir(const char*, mode_t);
int mkdirat(int, const char*, mode_t);
int mkfifo(const char*, mode_t);
int mkfifoat(int, const char*, mode_t);
int mknod(const char*, mode_t, dev_t);
int mknodat(int, const char*, mode_t, dev_t);
int stat(const char* restrict, struct stat* restrict);
mode_t umask(mode_t);
int utimensat(int, const char*, const struct timespec[2], int);
*/


#endif  // SYS_STAT_H


/* PRE-TERMIOS TERMINAL IOCTLS DATATYPES; GENERIC UNIX VERSION (<ioctl.h>, <saioctl.h>, <ttycom.h>, <termios.h> & <bits/ioctl-types.h>) */


#if (!(defined(_IOCTL_TYPES_H) || defined(_IOCTL_TYPES_H_) || defined(_SYS_IOCTL_H) || defined(_SYS_IOCTL_H_) || defined(_SYS_TTYCOM_H_) || defined(TERMIOS_H) || defined(_TERMIOS_H_)))
#define IOCTL_TYPES_H   (1)
#define _IOCTL_TYPES_H   (1)
#define _IOCTL_TYPES_H_   (1)
#define BITS_IOCTLS_H   (1)
#define _BITS_IOCTLS_H   (1)
#define _BITS_IOCTLS_H_   (1)
#define __BITS_IOCTLS_H   (1)
#define __BITS_IOCTLS_H_   (1)
#define SYS_IOCTL_H   (1)
#define _SYS_IOCTL_H   (1)
#define _SYS_IOCTL_H_   (1)
#define _SYS_TTYCOM_H_   (1)
#define TERMIOS_H   (1)
#define _TERMIOS_H_   (1)


// Modem Lines
#ifdef ARCHMIPS
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   0x10
#   define TIOCM_SR   0x20
#   define TIOCM_CTS   0x40
#   define TIOCM_CAR   0x100
#   define TIOCM_RNG   0x200
#   define TIOCM_DSR   0x400
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#else
#   define TIOCM_LE   1
#   define TIOCM_DTR   2
#   define TIOCM_RTS   4
#   define TIOCM_ST   8
#   define TIOCM_SR   0x10
#   define TIOCM_CTS   0x20
#   define TIOCM_CAR   0x40
#   define TIOCM_RNG   0x80
#   define TIOCM_DSR   0x100
#   define TIOCM_CD   TIOCM_CAR
#   define TIOCM_RI   TIOCM_RNG
#   define TIOCM_OUT1   0x2000
#   define TIOCM_OUT2   0x4000
#   define TIOCM_LOOP   0x8000
#endif


// c_cc characters
#ifdef ARCHALPHA
#   define VEOF   0
#   define VEOL   1
#   define VEOL2   2
#   define VERASE   3
#   define VWERASE   4
#   define VKILL   5
#   define VREPRINT   6
#   define VSWTC   7
#   define VINTR   8
#   define VQUIT   9
#   define VSUSP   10
#   define VSTART   12
#   define VSTOP   13
#   define VLNEXT   14
#   define VDISCARD   15
#   define VMIN   16
#   define VTIME   17
#elif defined(ARCHMIPS)
#   define VINTR   0
#   define VQUIT   1
#   define VERASE   2
#   define VKILL   3
#   define VMIN   4
#   define VTIME   5
#   define VEOL2   6
#   define VSWTC   7
#   define VSWTCH   VSWTC
#   define VSTART   8
#   define VSTOP   9
#   define VSUSP   10
#   define VREPRINT   12
#   define VDISCARD   13
#   define VWERASE   14
#   define VLNEXT   15
#   define VEOF   16
#   define VEOL   17
#elif (defined(ARCHPOWERPC) || defined(ARCHPOWERPC64))
#   define VINTR   0
#   define VQUIT   1
#   define VERASE   2
#   define VKILL   3
#   define VEOF   4
#   define VMIN   5
#   define VEOL   6
#   define VTIME   7
#   define VEOL2   8
#   define VSWTC   9
#   define VWERASE   10
#   define VREPRINT   11
#   define VSUSP   12
#   define VSTART   13
#   define VSTOP   14
#   define VLNEXT   15
#   define VDISCARD   16
#elif defined(ARCHSPARC)
#   define VINTR   0
#   define VQUIT   1
#   define VERASE   2
#   define VKILL   3
#   define VEOF   4
#   define VEOL   5
#   define VEOL2   6
#   define VSWTC   7
#   define VSTART   8
#   define VSTOP   9
#   define VSUSP   10
#   define VDSUSP   11
#   define VREPRINT   12
#   define VDISCARD   13
#   define VWERASE   14
#   define VLNEXT   15
#   define VMIN   VEOF
#   define VTIME   VEOL
#else
#   define VINTR   0
#   define VQUIT   1
#   define VERASE   2
#   define VKILL   3
#   define VEOF   4
#   define VTIME   5
#   define VMIN   6
#   define VSWTC   7
#   define VSTART   8
#   define VSTOP   9
#   define VSUSP   10
#   define VEOL   11
#   define VREPRINT   12
#   define VDISCARD   13
#   define VWERASE   14
#   define VLNEXT   15
#   define VEOL2   16
#endif


// Line Disciplines
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6  // X.25 async
#define N_6PACK   7
#define N_MASC   8  // Reserved for Mobitex module
#define N_R3964   9  // Reserved for Simatic R3964 module
#define N_PROFIBUS_FDL   10  // Reserved for Profibus
#define N_IRDA   11  // Linux IR
#define N_SMSBLOCK   12  // SMS block mode; talking to GSM data cards about SMS messages
#define N_HDLC   13  // Synchronous HDLC
#define N_SYNC_PPP   14  // Synchronous PPP
#define N_HCI   15  // Bluetooth HCI UART


// c_iflag bits
#define IGNBRK   1
#define BRKINT   2
#define IGNPAR   4
#define PARMRK   010
#define INPCK   020
#define ISTRIP   040
#define INLCR   0100
#define IGNCR   0200
#define ICRNL   0400
#define IUCLC   01000
#define IXON   02000
#define IXANY   04000
#define IXOFF   010000
#define IMAXBEL   020000
#define IUTF8   040000


// c_oflag bits
#define OPOST   1
#define OLCUC   2
#define ONLCR   4
#define OCRNL   010
#define ONOCR   020
#define ONLRET   040
#define OFILL   0100
#define OFDEL   0200
#define NLDLY   0400
#define NL0   0
#define NL1   0400
#define CRDLY   03000
#define CR0   0
#define CR1   01000
#define CR2   02000
#define CR3   03000
#define TABDLY   014000
#define TAB0   0
#define TAB1   04000
#define TAB2   010000
#define TAB3   014000
#define XTABS   014000
#define BSDLY   020000
#define BS0   0
#define BS1   020000
#define VTDLY   040000
#define VT0   0
#define VT1   040000
#define FFDLY   0100000
#define FF0   0
#define FF1   0100000


// c_cflag bit meaning
#define CBAUD   010017
#define B0   0
#define B50   1
#define B75   2
#define B110   3
#define B134   4
#define B150   5
#define B200   6
#define B300   7
#define B600   010
#define B1200   011
#define B1800   012
#define B2400   013
#define B4800   014
#define B9600   015
#define B19200   016
#define B38400   017
#define EXTA   B19200
#define EXTB   B38400
#define CSIZE   060
#define CS5   0
#define CS6   020
#define CS7   040
#define CS8   060
#define CSTOPB   0100
#define CREAD   0200
#define PARENB   0400
#define PARODD   01000
#define HUPCL   02000
#define CLOCAL   04000
#define CBAUDEX   010000
#define B57600   010001
#define B115200   010002
#define B230400   010003
#define B460800   010004
#define B500000   010005
#define B576000   010006
#define B921600   010007
#define B1000000   010010
#define B1152000   010011
#define B1500000   010012
#define B2000000   010013
#define B2500000   010014
#define B3000000   010015
#define B3500000   010016
#define B4000000   010017
#define CIBAUD   002003600000  // Input baud rate (not used)
#define CMSPAR   010000000000  // Mark or space (stick) parity
#define CRTSCTS   020000000000  // Flow control


// c_lflag bits
#if (defined(ARCHPOWERPC) || defined(ARCHALPHA))
#   define ISIG   0x80
#   define ICANON   0x100
#   define XCASE   0x4000
#   define ECHO   8
#   define ECHOE   2
#   define ECHOK   4
#   define ECHONL   0x10
#   define NOFLSH   0x80000000
#   define TOSTOP   0x400000
#   define ECHOCTL   0x40
#   define ECHOPRT   0x20
#   define ECHOKE   1
#   define FLUSHO   0x800000
#   define IEXTEN   0x400
#   define PENDIN   0x20000000
#else
#   define ISIG   1
#   define ICANON   2
#   define XCASE   4
#   define ECHO   010
#   define ECHOE   020
#   define ECHOK   040
#   define ECHONL   0100
#   define NOFLSH   0200
#   define ECHOCTL   01000
#   define ECHOPRT   02000
#   define ECHOKE   04000
#endif


#ifdef ARCHMIPS
#   define IEXTEN   0400
#   define FLUSHO   020000
#   define TOSTOP   0100000
#else
#   define TOSTOP   0400
#   define FLUSHO   010000
#   define IEXTEN   0100000
#endif
#define PENDIN   040000
#define TCOOFF   0
#define TCOON   1
#define TCIOFF   2
#define TCION   3
#define TCIFLUSH   0
#define TCOFLUSH   1
#define TCIOFLUSH   2
#ifdef ARCHMIPS
#   define TCSANOW   0x540e
#   define TCSADRAIN   0x540f
#   define TCSAFLUSH   0x5410
#else
#   define TCSANOW   0
#   define TCSADRAIN   1
#   define TCSAFLUSH   2
#endif


/** Number of Control Characters */
#define NCC   8
struct attr_packed termio {
	uint16_t c_iflag;  // Input mode flags
	uint16_t c_oflag;  // Output mode flags
	uint16_t c_cflag;  // Control mode flags
	uint16_t c_lflag;  // Local mode flags
	unsigned char c_line;  // Line discipline
	unsigned char c_cc[NCC];  // Control characters
};


typedef unsigned char   cc_t;
typedef uint32_t   speed_t;
typedef uint32_t   tcflag_t;


#if (defined(I386) || defined(ARCHARM) || defined(ARCHITANIUM) || defined(ARCHHPPA) || defined(ARCHS390) || defined(ARCHS390X) || defined(ARCHX86_64))


#define NCCS   19
struct termios {
	tcflag_t c_iflag;  // Input mode flags
	tcflag_t c_oflag;  // Output mode flags
	tcflag_t c_cflag;  // Control mode flags
	tcflag_t c_lflag;  // Local mode flags
	cc_t c_line;  // Line discipline
	cc_t c_cc[NCCS];  // Control characters
};

#elif defined(ARCHMIPS)

#define NCCS   23
struct termios {
	tcflag_t c_iflag;  // Input mode flags
	tcflag_t c_oflag;  // Output mode flags
	tcflag_t c_cflag;  // Control mode flags
	tcflag_t c_lflag;  // Local mode flags
	cc_t c_line;  // Line discipline
	cc_t c_cc[NCCS];  // Control characters
};

#elif (defined(ARCHPOWERPC) || defined(ARCHPOWERPC64) || defined(ARCHALPHA))

#define NCCS   19
struct termios {
	tcflag_t c_iflag;  // Input mode flags
	tcflag_t c_oflag;  // Output mode flags
	tcflag_t c_cflag;  // Control mode flags
	tcflag_t c_lflag;  // Local mode flags
	cc_t c_cc[NCCS];  // Control characters
	cc_t c_line;  // Line discipline
	speed_t c_ispeed;  // Input speed
	speed_t c_ospeed;  // Output speed
};

#elif defined(ARCHSPARC)

#define NCCS   17
struct termios {
	tcflag_t c_iflag;  // Input mode flags
	tcflag_t c_oflag;  // Output mode flags
	tcflag_t c_cflag;  // Control mode flags
	tcflag_t c_lflag;  // Local mode flags
	cc_t c_line;  // Line discipline
	cc_t c_cc[NCCS];  // Control characters
};

#else
#   error   "Struct termios IS undefined for the target architecture"
#endif


typedef enum __ioctl_dir {
	IOC_VOID = 0,  // No parameters
	IOC_OUT = 1,  // Data is written into the user's buffer
	IOC_IN = 2,  // Data is read from the user's buffer
	IOC_INOUT = 3
} ioctl_dir_t;


typedef enum __ioctl_datum { IOC_8, IOC_16, IOC_32, IOC_64 }   ioctl_datum_t;


typedef struct ioctl_pt {
	unsigned long com;
	void* data;
} ioctl_pt_t;


/** For /dev/ptm pty getting ioctl TIOCPTMGET, and for TIOCPTSNAME */
typedef struct ptmget {
	int cfd, sfd;
	char cn[PATH_MAX];
	char sn[PATH_MAX];
} ptmget_t;


/** The maximum length of a line discipline's name */
#define TTLINEDNAMELEN   32
typedef char    linedn_t[TTLINEDNAMELEN];
/** Termios tty line discipline */
#define TTYDISC   0
/** Tablet discipline */
#define TABLDISC   3
/** Serial IP discipline */
#define SLIPDISC   4
/** PPP discipline */
#define PPPDISC   5
/** Metricom wireless IP discipline */
#define STRIPDISC   6
/** HDLC discipline */
#define HDLCDISC   9
/** Next i/o includes header */
#define SAIOHDR   (('d' << 8) | 1)
/** Next i/o checks data */
#define SAIOCHECK   (('d' << 8) | 2)
/** Next i/o checks header & data */
#define SAIOHCHECK   (('d' << 8) | 3)
/** Inhibit bad sector forwarding */
#define SAIONOBAD   (('d' << 8) | 4)
/** Enable bad sector forwarding */
#define SAIODOBAD   (('d' << 8) | 5)
/** Set limit to ecc correction, bits */
#define SAIOECCLIM   (('d' << 8) | 6)
/** Use standard ecc procedures */
#define SAIOECCUNL   (('d' << 8) | 7)
/** Set retry count for unit */
#define SAIORETRIES   (('d' << 8) | 8)
/** Get pointer to pack label */
#define SAIODEVDATA   (('d' << 8) | 9)
/** Set skip sector inhibit */
#define SAIOSSI   (('d' << 8) | 10)
/** Inhibit skip sector handling */
#define SAIONOSSI   (('d' << 8) | 11)
/** Is device skip sector type? */
#define SAIOSSDEV   (('d' << 8) | 12)
/** Enable/disable debugging */
#define SAIODEBUG   (('d' << 8) | 13)
/** Get bad-sector table */
#define SAIOGBADINFO   (('d' << 8) | 14)


#if (defined(X86_64) || defined(X86))


#define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   0U
#define _IOC_WRITE   1U
#define _IOC_READ   2U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define TCGETS   0x5401
#define TCSETS   0x5402
#define TCSETSW   0x5403
#define TCSETSF   0x5404
#define TCGETA   0x5405
#define TCSETA   0x5406
#define TCSETAW   0x5407
#define TCSETAF   0x5408
#define TCSBRK   0x5409
#define TCXONC   0x540A
#define TCFLSH   0x540B
#define TIOCEXCL   0x540C
#define TIOCNXCL   0x540D
#define TIOCSCTTY   0x540E
#define TIOCGPGRP   0x540F
#define TIOCSPGRP   0x5410
#define TIOCOUTQ   0x5411
#define TIOCSTI   0x5412
#define TIOCGWINSZ   0x5413
#define TIOCSWINSZ   0x5414
#define TIOCMGET   0x5415
#define TIOCMBIS   0x5416
#define TIOCMBIC   0x5417
#define TIOCMSET   0x5418
#define TIOCGSOFTCAR   0x5419
#define TIOCSSOFTCAR   0x541A
#define FIONREAD   0x541B
#define TIOCINQ   FIONREAD
#define TIOCLINUX   0x541C
#define TIOCCONS   0x541D
#define TIOCGSERIAL   0x541E
#define TIOCSSERIAL   0x541F
#define TIOCPKT   0x5420
#define FIONBIO   0x5421
#define TIOCNOTTY   0x5422
#define TIOCSETD   0x5423
#define TIOCGETD   0x5424
#define TCSBRKP   0x5425
#define TIOCTTYGSTRUCT   0x5426
#define TIOCSBRK   0x5427
#define TIOCCBRK   0x5428
#define TIOCGSID   0x5429
#define TIOCGPTN   0x80045430
#define TIOCSPTLCK   0x40045431
#define TCGETX   0x5432
#define TCSETX   0x5433
#define TCSETXF   0x5434
#define TCSETXW   0x5435
#define FIONCLEX   0x5450
#define FIOCLEX   0x5451
#define FIOASYNC   0x5452
#define TIOCSERCONFIG   0x5453
#define TIOCSERGWILD   0x5454
#define TIOCSERSWILD   0x5455
#define TIOCGLCKTRMIOS   0x5456
#define TIOCSLCKTRMIOS   0x5457
#define TIOCSERGSTRUCT   0x5458
#define TIOCSERGETLSR   0x5459
#define TIOCSERGETMULTI   0x545A
#define TIOCSERSETMULTI   0x545B
#define TIOCMIWAIT   0x545C
#define TIOCGICOUNT   0x545D
#define TIOCGHAYESESP   0x545E
#define TIOCSHAYESESP   0x545F
#define FIOQSIZE   0x5460
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCSER_TEMT   1
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define FIOSETOWN   0x8901
#define SIOCSPGRP   0x8902
#define FIOGETOWN   0x8903
#define SIOCGPGRP   0x8904
#define SIOCATMARK   0x8905
#define SIOCGSTAMP   0x8906
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#elif defined(ARM64)


#define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   0U
#define _IOC_WRITE   1U
#define _IOC_READ   2U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define TCGETS   0x5401
#define TCSETS   0x5402
#define TCSETSW   0x5403
#define TCSETSF   0x5404
#define TCGETA   0x5405
#define TCSETA   0x5406
#define TCSETAW   0x5407
#define TCSETAF   0x5408
#define TCSBRK   0x5409
#define TCXONC   0x540A
#define TCFLSH   0x540B
#define TIOCEXCL   0x540C
#define TIOCNXCL   0x540D
#define TIOCSCTTY   0x540E
#define TIOCGPGRP   0x540F
#define TIOCSPGRP   0x5410
#define TIOCOUTQ   0x5411
#define TIOCSTI   0x5412
#define TIOCGWINSZ   0x5413
#define TIOCSWINSZ   0x5414
#define TIOCMGET   0x5415
#define TIOCMBIS   0x5416
#define TIOCMBIC   0x5417
#define TIOCMSET   0x5418
#define TIOCGSOFTCAR   0x5419
#define TIOCSSOFTCAR   0x541A
#define FIONREAD   0x541B
#define TIOCINQ   FIONREAD
#define TIOCLINUX   0x541C
#define TIOCCONS   0x541D
#define TIOCGSERIAL   0x541E
#define TIOCSSERIAL   0x541F
#define TIOCPKT   0x5420
#define FIONBIO   0x5421
#define TIOCNOTTY   0x5422
#define TIOCSETD   0x5423
#define TIOCGETD   0x5424
#define TCSBRKP   0x5425
#define TIOCTTYGSTRUCT   0x5426
#define TIOCSBRK   0x5427
#define TIOCCBRK   0x5428
#define TIOCGSID   0x5429
#define TIOCGRS485   0x542E
#define TIOCSRS485   0x542F
#define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#define TIOCSPTLCK   _IOW('T', 0x31, int)
#define TIOCGDEV   _IOR('T', 0x32, unsigned int)
#define TCGETX   0x5432
#define TCSETX   0x5433
#define TCSETXF   0x5434
#define TCSETXW   0x5435
#define TIOCSIG   0x40045436
#define TIOCVHANGUP   0x5437
#define TIOCGPKT   0x80045438
#define TIOCGPTLCK   0x80045439
#define TIOCGEXCL   0x80045440
#define FIONCLEX   0x5450
#define FIOCLEX   0x5451
#define FIOASYNC   0x5452
#define TIOCSERCONFIG   0x5453
#define TIOCSERGWILD   0x5454
#define TIOCSERSWILD   0x5455
#define TIOCGLCKTRMIOS   0x5456
#define TIOCSLCKTRMIOS   0x5457
#define TIOCSERGSTRUCT   0x5458
#define TIOCSERGETLSR   0x5459
#define TIOCSERGETMULTI   0x545A
#define TIOCSERSETMULTI   0x545B
#define TIOCMIWAIT   0x545C
#define TIOCGICOUNT   0x545D
#define FIOQSIZE   0x5460
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCSER_TEMT   1
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define N_GIGASET_M101   16
#define N_SLCAN   17
#define N_PPS   18
#define N_V253   19
#define N_CAIF   20
#define N_GSM0710   21
#define N_TI_WL   22
#define N_TRACESINK   23
#define N_TRACEROUTER   24
#define FIOSETOWN   0x8901
#define SIOCSPGRP   0x8902
#define FIOGETOWN   0x8903
#define SIOCGPGRP   0x8904
#define SIOCATMARK   0x8905
#define SIOCGSTAMP   0x8906
#define SIOCGSTAMPNS   0x8907
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#elif defined(MIPS)


#define _IOC(a, b, c, d)   (((a) << 29) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   1U
#define _IOC_READ   2U
#define _IOC_WRITE   4U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define TCGETA   0x5401
#define TCSETA   0x5402
#define TCSETAW   0x5403
#define TCSETAF   0x5404
#define TCSBRK   0x5405
#define TCXONC   0x5406
#define TCFLSH   0x5407
#define TCGETS   0x540D
#define TCSETS   0x540E
#define TCSETSW   0x540F
#define TCSETSF   0x5410
#define TIOCEXCL   0x740D
#define TIOCNXCL   0x740E
#define TIOCOUTQ   0x7472
#define TIOCSTI   0x5472
#define TIOCMGET   0x741D
#define TIOCMBIS   0x741B
#define TIOCMBIC   0x741C
#define TIOCMSET   0x741D
#define TIOCPKT   0x5470
#define TIOCSWINSZ   _IOW('t', 103, struct winsize)
#define TIOCGWINSZ   _IOR('t', 104, struct winsize)
#define TIOCNOTTY   0x5471
#define TIOCSETD   0x7401
#define TIOCGETD   0x7400
#define FIOCLEX   0x6601
#define FIONCLEX   0x6602
#define FIOASYNC   0x667D
#define FIONBIO   0x667E
#define FIOQSIZE   0x667F
#define TIOCGLTC   0x7474
#define TIOCSLTC   0x7475
#define TIOCSPGRP   _IOW('t', 118, int)
#define TIOCGPGRP   _IOR('t', 119, int)
#define TIOCCONS   _IOW('t', 120, int)
#define FIONREAD   0x467F
#define TIOCINQ   FIONREAD
#define TIOCGETP   0x7408
#define TIOCSETP   0x7409
#define TIOCSETN   0x740A
#define TIOCSBRK   0x5427
#define TIOCCBRK   0x5428
#define TIOCGSID   0x7416
#define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#define TIOCSPTLCK   _IOW('T', 0x31, int)
#define TIOCSCTTY   0x5480
#define TIOCGSOFTCAR   0x5481
#define TIOCSSOFTCAR   0x5482
#define TIOCLINUX   0x5483
#define TIOCGSERIAL   0x5484
#define TIOCSSERIAL   0x5485
#define TCSBRKP   0x5486
#define TIOCSERCONFIG   0x5488
#define TIOCSERGWILD   0x5489
#define TIOCSERSWILD   0x548A
#define TIOCGLCKTRMIOS   0x548B
#define TIOCSLCKTRMIOS   0x548C
#define TIOCSERGSTRUCT   0x548D
#define TIOCSERGETLSR   0x548E
#define TIOCSERGETMULTI   0x548F
#define TIOCSERSETMULTI   0x5490
#define TIOCMIWAIT   0x5491
#define TIOCGICOUNT   0x5492
#define TIOCGHAYESESP   0x5493
#define TIOCSHAYESESP   0x5494
#define TIOCTTYGSTRUCT   0x5426
#define TCGETX   0x5432
#define TCSETX   0x5433
#define TCSETXF   0x5434
#define TCSETXW   0x5435
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCSER_TEMT   1
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define FIOSETOWN   0x8901
#define SIOCSPGRP   0x8902
#define FIOGETOWN   0x8903
#define SIOCGPGRP   0x8904
#define SIOCATMARK   0x8905
#define SIOCGSTAMP   0x8906
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#elif defined(POWERPC)


#define _IOC(a, b, c, d)   (((a) << 29) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   1U
#define _IOC_WRITE   4U
#define _IOC_READ   2U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define FIONCLEX   _IO('f', 2)
#define FIOCLEX   _IO('f', 1)
#define FIOASYNC   _IOW('f', 125, int)
#define FIONBIO   _IOW('f', 126, int)
#define FIONREAD   _IOR('f', 127, int)
#define TIOCINQ   FIONREAD
#define FIOQSIZE   _IOR('f', 128, char[8])
#define TIOCGETP   _IOR('t', 8, char[6])
#define TIOCSETP   _IOW('t', 9, char[6])
#define TIOCSETN   _IOW('t', 10, char[6])
#define TIOCSETC   _IOW('t', 17, char[6])
#define TIOCGETC   _IOR('t', 18, char[6])
#define TCGETS   _IOR('t', 19, char[44])
#define TCSETS   _IOW('t', 20, char[44])
#define TCSETSW   _IOW('t', 21, char[44])
#define TCSETSF   _IOW('t', 22, char[44])
#define TCGETA   _IOR('t', 23, char[20])
#define TCSETA   _IOW('t', 24, char[20])
#define TCSETAW   _IOW('t', 25, char[20])
#define TCSETAF   _IOW('t', 28, char[20])
#define TCSBRK   _IO('t', 29)
#define TCXONC   _IO('t', 30)
#define TCFLSH   _IO('t', 31)
#define TIOCSWINSZ   _IOW('t', 103, char[8])
#define TIOCGWINSZ   _IOR('t', 104, char[8])
#define TIOCSTART   _IO('t', 110)
#define TIOCSTOP   _IO('t', 111)
#define TIOCOUTQ   _IOR('t', 115, int)
#define TIOCGLTC   _IOR('t', 116, char[6])
#define TIOCSLTC   _IOW('t', 117, char[6])
#define TIOCSPGRP   _IOW('t', 118, int)
#define TIOCGPGRP   _IOR('t', 119, int)
#define TIOCEXCL   0x540C
#define TIOCNXCL   0x540D
#define TIOCSCTTY   0x540E
#define TIOCSTI   0x5412
#define TIOCMGET   0x5415
#define TIOCMBIS   0x5416
#define TIOCMBIC   0x5417
#define TIOCMSET   0x5418
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCGSOFTCAR   0x5419
#define TIOCSSOFTCAR   0x541A
#define TIOCLINUX   0x541C
#define TIOCCONS   0x541D
#define TIOCGSERIAL   0x541E
#define TIOCSSERIAL   0x541F
#define TIOCPKT   0x5420
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCNOTTY   0x5422
#define TIOCSETD   0x5423
#define TIOCGETD   0x5424
#define TCSBRKP   0x5425
#define TIOCSBRK   0x5427
#define TIOCCBRK   0x5428
#define TIOCGSID   0x5429
#define TIOCGRS485   0x542e
#define TIOCSRS485   0x542f
#define TIOCGPTN   _IOR('T', 0x30, unsigned int)
#define TIOCSPTLCK   _IOW('T', 0x31, int)
#define TIOCGDEV   _IOR('T', 0x32, unsigned int)
#define TIOCSIG   _IOW('T', 0x36, int)
#define TIOCVHANGUP   0x5437
#define TIOCSERCONFIG   0x5453
#define TIOCSERGWILD   0x5454
#define TIOCSERSWILD   0x5455
#define TIOCGLCKTRMIOS   0x5456
#define TIOCSLCKTRMIOS   0x5457
#define TIOCSERGSTRUCT   0x5458
#define TIOCSERGETLSR   0x5459
#define TIOCSER_TEMT   0x01
#define TIOCSERGETMULTI   0x545A
#define TIOCSERSETMULTI   0x545B
#define TIOCMIWAIT   0x545C
#define TIOCGICOUNT   0x545D
#define TIOCTTYGSTRUCT   0x5426
#define TCGETX   0x5432
#define TCSETX   0x5433
#define TCSETXF   0x5434
#define TCSETXW   0x5435
#define TIOCGHAYESESP   0x545E
#define TIOCSHAYESESP   0x545F
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define FIOSETOWN   0x8901
#define SIOCSPGRP   0x8902
#define FIOGETOWN   0x8903
#define SIOCGPGRP   0x8904
#define SIOCATMARK   0x8905
#define SIOCGSTAMP   0x8906
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#elif defined(SUPERH)


#define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   0U
#define _IOC_WRITE   1U
#define _IOC_READ   2U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define FIOCLEX   _IO('f',  1)
#define FIONCLEX   _IO('f',  2)
#define FIOASYNC   _IOW('f', 125, int)
#define FIONBIO   _IOW('f', 126, int)
#define FIONREAD   _IOR('f', 127, int)
#define TIOCINQ   FIONREAD
#define FIOQSIZE   _IOR('f', 128, char[8])
#define TCGETA   _IOR('t', 23, char[18])
#define TCSETA   _IOW('t', 24, char[18])
#define TCSETAW   _IOW('t', 25, char[18])
#define TCSETAF   _IOW('t', 28, char[18])
#define TCSBRK   _IO('t', 29)
#define TCXONC   _IO('t', 30)
#define TCFLSH   _IO('t', 31)
#define TIOCSWINSZ   _IOW('t', 103, char[8])
#define TIOCGWINSZ   _IOR('t', 104, char[8])
#define TIOCSTART   _IO('t',  110)
#define TIOCSTOP   _IO('t',  111)
#define TIOCOUTQ   _IOR('t', 115, int)
#define TIOCSPGRP   _IOW('t', 118, int)
#define TIOCGPGRP   _IOR('t', 119, int)
#define TIOCEXCL   _IO('T', 12)
#define TIOCNXCL   _IO('T', 13)
#define TIOCSCTTY   _IO('T', 14)
#define TIOCSTI   _IOW('T', 18, char)
#define TIOCMGET   _IOR('T', 21, unsigned int)
#define TIOCMBIS   _IOW('T', 22, unsigned int)
#define TIOCMBIC   _IOW('T', 23, unsigned int)
#define TIOCMSET   _IOW('T', 24, unsigned int)
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCGSOFTCAR   _IOR('T', 25, unsigned int)
#define TIOCSSOFTCAR   _IOW('T', 26, unsigned int)
#define TIOCLINUX   _IOW('T', 28, char)
#define TIOCCONS   _IO('T',  29)
#define TIOCGSERIAL   _IOR('T', 30, char[60])
#define TIOCSSERIAL   _IOW('T', 31, char[60])
#define TIOCPKT   _IOW('T', 32, int)
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCNOTTY   _IO('T',  34)
#define TIOCSETD   _IOW('T', 35, int)
#define TIOCGETD   _IOR('T', 36, int)
#define TCSBRKP   _IOW('T', 37, int)
#define TIOCSBRK   _IO('T',  39)
#define TIOCCBRK   _IO('T',  40)
#define TIOCGSID   _IOR('T', 41, int)
#define TCGETS   _IO('T', 1)
#define TCSETS   _IO('T', 2)
#define TCSETSW   _IO('T', 3)
#define TCSETSF   _IO('T', 4)
#define TCGETS2   _IOR('T', 42, char[44])
#define TCSETS2   _IOW('T', 43, char[44])
#define TCSETSW2   _IOW('T', 44, char[44])
#define TCSETSF2   _IOW('T', 45, char[44])
#define TIOCGPTN   _IOR('T', 48, unsigned int)
#define TIOCSPTLCK   _IOW('T', 49, int)
#define TIOCGDEV   _IOR('T', 50, unsigned int)
#define TIOCSIG   _IOW('T', 54, int)
#define TIOCVHANGUP   _IO('T',  55)
#define TIOCGPKT   _IOR('T', 56, int)
#define TIOCGPTLCK   _IOR('T', 57, int)
#define TIOCGEXCL   _IOR('T', 64, int)
#define TIOCSERCONFIG   _IO('T',  83)
#define TIOCSERGWILD   _IOR('T', 84, int)
#define TIOCSERSWILD   _IOW('T', 85, int)
#define TIOCGLCKTRMIOS   _IO('T',  86)
#define TIOCSLCKTRMIOS   _IO('T',  87)
#define TIOCSERGSTRUCT   _IOR('T', 88, char[216])
#define TIOCSERGETLSR   _IOR('T', 89, unsigned int)
#define TIOCSER_TEMT   0x01
#define TIOCSERGETMULTI   _IOR('T', 90, char[168])
#define TIOCSERSETMULTI   _IOW('T', 91, char[168])
#define TIOCMIWAIT   _IO('T', 92)
#define TIOCGICOUNT   _IO('T', 93)
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define FIOGETOWN   _IOR('f', 123, int)
#define FIOSETOWN   _IOW('f', 124, int)
#define SIOCATMARK   _IOR('s', 7, int)
#define SIOCSPGRP   _IOW('s', 8, int)
#define SIOCGPGRP   _IOW('s', 9, int)
#define SIOCGSTAMP   _IOR('s', 100, char[8])
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#else


#define _IOC(a, b, c, d)   (((a) << 30) | ((b) << 8) | (c) | ((d) << 16))
#define _IOC_NONE   0U
#define _IOC_WRITE   1U
#define _IOC_READ   2U
#define _IO(a, b)   _IOC(_IOC_NONE, (a), (b), 0)
#define _IOW(a, b, c)   _IOC(_IOC_WRITE, (a), (b), sizeof(c))
#define _IOR(a, b, c)   _IOC(_IOC_READ, (a), (b), sizeof(c))
#define _IOWR(a, b, c)   _IOC((_IOC_READ | _IOC_WRITE), (a), (b), sizeof(c))
#define TCGETS   0x5401
#define TCSETS   0x5402
#define TCSETSW   0x5403
#define TCSETSF   0x5404
#define TCGETA   0x5405
#define TCSETA   0x5406
#define TCSETAW   0x5407
#define TCSETAF   0x5408
#define TCSBRK   0x5409
#define TCXONC   0x540A
#define TCFLSH   0x540B
#define TIOCEXCL   0x540C
#define TIOCNXCL   0x540D
#define TIOCSCTTY   0x540E
#define TIOCGPGRP   0x540F
#define TIOCSPGRP   0x5410
#define TIOCOUTQ   0x5411
#define TIOCSTI   0x5412
#define TIOCGWINSZ   0x5413
#define TIOCSWINSZ   0x5414
#define TIOCMGET   0x5415
#define TIOCMBIS   0x5416
#define TIOCMBIC   0x5417
#define TIOCMSET   0x5418
#define TIOCGSOFTCAR   0x5419
#define TIOCSSOFTCAR   0x541A
#define FIONREAD   0x541B
#define TIOCINQ   FIONREAD
#define TIOCLINUX   0x541C
#define TIOCCONS   0x541D
#define TIOCGSERIAL   0x541E
#define TIOCSSERIAL   0x541F
#define TIOCPKT   0x5420
#define FIONBIO   0x5421
#define TIOCNOTTY   0x5422
#define TIOCSETD   0x5423
#define TIOCGETD   0x5424
#define TCSBRKP   0x5425
#define TIOCTTYGSTRUCT   0x5426
#define TIOCSBRK   0x5427
#define TIOCCBRK   0x5428
#define TIOCGSID   0x5429
#define TIOCGPTN   0x80045430
#define TIOCSPTLCK   0x40045431
#define TCGETX   0x5432
#define TCSETX   0x5433
#define TCSETXF   0x5434
#define TCSETXW   0x5435
#define FIONCLEX   0x5450
#define FIOCLEX   0x5451
#define FIOASYNC   0x5452
#define TIOCSERCONFIG   0x5453
#define TIOCSERGWILD   0x5454
#define TIOCSERSWILD   0x5455
#define TIOCGLCKTRMIOS   0x5456
#define TIOCSLCKTRMIOS   0x5457
#define TIOCSERGSTRUCT   0x5458
#define TIOCSERGETLSR   0x5459
#define TIOCSERGETMULTI   0x545A
#define TIOCSERSETMULTI   0x545B
#define TIOCMIWAIT   0x545C
#define TIOCGICOUNT   0x545D
#define TIOCGHAYESESP   0x545E
#define TIOCSHAYESESP   0x545F
#define FIOQSIZE   0x5460
#define TIOCPKT_DATA   0
#define TIOCPKT_FLUSHREAD   1
#define TIOCPKT_FLUSHWRITE   2
#define TIOCPKT_STOP   4
#define TIOCPKT_START   8
#define TIOCPKT_NOSTOP   16
#define TIOCPKT_DOSTOP   32
#define TIOCPKT_IOCTL   64
#define TIOCSER_TEMT   1
#define TIOCM_LE   1
#define TIOCM_DTR   2
#define TIOCM_RTS   4
#define TIOCM_ST   8
#define TIOCM_SR   0x10
#define TIOCM_CTS   0x20
#define TIOCM_CAR   0x40
#define TIOCM_RNG   0x80
#define TIOCM_DSR   0x100
#define TIOCM_CD   TIOCM_CAR
#define TIOCM_RI   TIOCM_RNG
#define TIOCM_OUT1   0x2000
#define TIOCM_OUT2   0x4000
#define TIOCM_LOOP   0x8000
#define TIOCM_MODEM_BITS   TIOCM_OUT2
#define N_TTY   0
#define N_SLIP   1
#define N_MOUSE   2
#define N_PPP   3
#define N_STRIP   4
#define N_AX25   5
#define N_X25   6
#define N_6PACK   7
#define N_MASC   8
#define N_R3964   9
#define N_PROFIBUS_FDL   10
#define N_IRDA   11
#define N_SMSBLOCK   12
#define N_HDLC   13
#define N_SYNC_PPP   14
#define N_HCI   15
#define FIOSETOWN   0x8901
#define SIOCSPGRP   0x8902
#define FIOGETOWN   0x8903
#define SIOCGPGRP   0x8904
#define SIOCATMARK   0x8905
#define SIOCGSTAMP   0x8906
#define SIOCADDRT   0x890B
#define SIOCDELRT   0x890C
#define SIOCRTMSG   0x890D
#define SIOCGIFNAME   0x8910
#define SIOCSIFLINK   0x8911
#define SIOCGIFCONF   0x8912
#define SIOCGIFFLAGS   0x8913
#define SIOCSIFFLAGS   0x8914
#define SIOCGIFADDR   0x8915
#define SIOCSIFADDR   0x8916
#define SIOCGIFDSTADDR   0x8917
#define SIOCSIFDSTADDR   0x8918
#define SIOCGIFBRDADDR   0x8919
#define SIOCSIFBRDADDR   0x891a
#define SIOCGIFNETMASK   0x891b
#define SIOCSIFNETMASK   0x891c
#define SIOCGIFMETRIC   0x891d
#define SIOCSIFMETRIC   0x891e
#define SIOCGIFMEM   0x891f
#define SIOCSIFMEM   0x8920
#define SIOCGIFMTU   0x8921
#define SIOCSIFMTU   0x8922
#define SIOCSIFHWADDR   0x8924
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
#define SIOCGIFHWADDR   0x8927
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
#define SIOCGIFINDEX   0x8933
#define SIOGIFINDEX   SIOCGIFINDEX
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
#define SIOCDIFADDR   0x8936
#define SIOCSIFHWBROADCAST   0x8937
#define SIOCGIFCOUNT   0x8938
#define SIOCGIFBR   0x8940
#define SIOCSIFBR   0x8941
#define SIOCGIFTXQLEN   0x8942
#define SIOCSIFTXQLEN   0x8943
#define SIOCDARP   0x8953
#define SIOCGARP   0x8954
#define SIOCSARP   0x8955
#define SIOCDRARP   0x8960
#define SIOCGRARP   0x8961
#define SIOCSRARP   0x8962
#define SIOCGIFMAP   0x8970
#define SIOCSIFMAP   0x8971
#define SIOCADDDLCI   0x8980
#define SIOCDELDLCI   0x8981
#define SIOCDEVPRIVATE   0x89F0
#define SIOCPROTOPRIVATE   0x89E0


#endif  // ARCH


#ifndef _IOC
/** Construct an ioctl from constructed type plus other fields */
#   define _IOC(inout, _group, num, type)   ((num) | ((((_group) - 'f') | ((type) | (inout) << 19) << 4) << 7))
#endif
/** Dissect an ioctl into its component fields */
#define _IOC_INOUT(request)   (((unsigned int)(request) >> 30) & IOC_INOUT)
#define _IOC_GROUP(request)   ('f' + (((unsigned int)(request) >> 7) & 0xf))
#define _IOC_COMMAND(request)   ((unsigned int)(request) & 0x7f)
#define _IOC_TYPE(request)   (((unsigned int)(request) >> 11) & 0x7ffff)
#define _IOC_NOTYPE(request)   ((unsigned int)(request) & 0x3ff)
/** Construct a type information field from the broken-out type and count fields */
#define _IOT(t0, c0, t1, c1, t2, c2)   ((c2) | (((c1) | ((c0) | ((t2) | ((t1) | (t0) << 2) << 2) << 5) << 5) << 3))
/** Dissect a type information field into the type and count fields */
#define _IOT_TYPE0(type)   (((unsigned int)(type) >> 17) & 3)
#define _IOT_TYPE1(type)   (((unsigned int)(type) >> 15) & 3)
#define _IOT_TYPE2(type)   (((unsigned int)(type) >> 13) & 3)
#define _IOT_COUNT0(type)   (((unsigned int)(type) >> 8) & 0x1f)
#define _IOT_COUNT1(type)   (((unsigned int)(type) >> 3) & 0x1f)
#define _IOT_COUNT2(type)   (((unsigned int)(type) >> 0) & 7)
/** Construct an ioctl from all the broken-out fields */
#define _IOCT(inout, _group, num, t0, c0, t1, c1, t2, c2)   _IOC((inout), (_group), (num), _IOT((t0), (c0), (t1), (c1), (t2), (c2)))
/** Construct an individual type field for TYPE */
#define _IOTS(type)   ((sizeof(type) == 8) ? IOC_64 : (enum __ioctl_datum)(sizeof(type) >> 1))
/** Construct a type information field for a single argument of the scalar TYPE */
#define _IOT_SIMPLE(type)   _IOT(_IOTS(type), 1, 0, 0, 0, 0)
#define _IOC_ENCODE_TYPE(typespec)   _IOC_ENCODE_TYPE_1(_IOTBASE_##typespec)
#define _IOC_ENCODE_TYPE_1(typespec)   _IOC_ENCODE_TYPE_2(typespec)
#define _IOC_ENCODE_TYPE_2(typespec)   _IOT_##typespec
#ifndef _IOIW
#   define _IOIW(g, n, t)   _IOC(IOC_VOID, (g), (n), _IOC_ENCODE_TYPE(t))
#endif
#define PTIOCNETBSD   _IOW('Z', 0, struct ioctl_pt)
#define PTIOCSUNOS   _IOW('Z', 1, struct ioctl_pt)
#define PTIOCSVR4   _IOW('Z', 2, struct ioctl_pt)
#define PTIOCLINUX   _IOW('Z', 3, struct ioctl_pt)
#define PTIOCFREEBSD   _IOW('Z', 4, struct ioctl_pt)
#define PTIOCOSF1   _IOW('Z', 5, struct ioctl_pt)
#define PTIOCULTRIX   _IOW('Z', 6, struct ioctl_pt)
#define PTIOCWIN32   _IOW('Z', 7, struct ioctl_pt)
#define TIOCGRANTPT   _IO('t', 71)
/** Hurd ioctl type field for tchars */
#define _IOT_tchars   _IOT(_IOTS(char), 6, 0, 0, 0, 0)
/** Hurd ioctl type field for ltchars */
#define _IOT_ltchars   _IOT(_IOTS(char), 6, 0, 0, 0, 0)
/** Hurd ioctl type field for sgttyb */
#define _IOT_sgttyb   _IOT(_IOTS(char), 4, _IOTS(short), 1, 0, 0)
/** Hurd ioctl type field for winsize */
#define _IOT_winsize   _IOT(_IOTS(unsigned short), 4, 0, 0, 0, 0)
#define _IOT_ttysize   _IOT_winsize
// Basic C Datatypes
#define _IOT_char   _IOT_SIMPLE(char)
#define _IOT_short   _IOT_SIMPLE(short)
#define _IOT_int   _IOT_SIMPLE(int)
#define _IOT_long   _IOT_SIMPLE(long)
#define _IOT_long_long   _IOT_SIMPLE(long long)
#define _IOT_int8_t   _IOT_SIMPLE(int8_t)
#define _IOT_uint8_t   _IOT_SIMPLE(uint8_t)
#define _IOT_int16_t   _IOT_SIMPLE(int16_t)
#define _IOT_uint16_t   _IOT_SIMPLE(uint16_t)
#define _IOT_int32_t   _IOT_SIMPLE(int32_t)
#define _IOT_uint32_t   _IOT_SIMPLE(uint32_t)
#define _IOT_int64_t   _IOT_SIMPLE(int64_t)
#define _IOT_uint64_t   _IOT_SIMPLE(uint64_t)
#define _IOT_size_t   _IOT_SIMPLE(size_t)
#define _IOT_ssize_t   _IOT_SIMPLE(ssize_t)
#define _IOT__IOTBASE_char   _IOT_SIMPLE(char)
#define _IOT__IOTBASE_short   _IOT_SIMPLE(short)
#define _IOT__IOTBASE_int   _IOT_SIMPLE(int)
#define _IOT__IOTBASE_long   _IOT_SIMPLE(long)
#define _IOT__IOTBASE_long_long   _IOT_SIMPLE(long long)
#define _IOT__IOTBASE_int8_t   _IOT_SIMPLE(int8_t)
#define _IOT__IOTBASE_uint8_t   _IOT_SIMPLE(uint8_t)
#define _IOT__IOTBASE_int16_t   _IOT_SIMPLE(int16_t)
#define _IOT__IOTBASE_uint16_t   _IOT_SIMPLE(uint16_t)
#define _IOT__IOTBASE_int32_t   _IOT_SIMPLE(int32_t)
#define _IOT__IOTBASE_uint32_t   _IOT_SIMPLE(uint32_t)
#define _IOT__IOTBASE_int64_t   _IOT_SIMPLE(int64_t)
#define _IOT__IOTBASE_uint64_t   _IOT_SIMPLE(uint64_t)
#define _IOT__IOTBASE_size_t   _IOT_SIMPLE(size_t)
#define _IOT__IOTBASE_ssize_t   _IOT_SIMPLE(ssize_t)
// Routing table calls
/** Add routing table entry */
#define SIOCADDRT   0x890B
/** Delete routing table entry */
#define SIOCDELRT   0x890C
/** Call to routing system */
#define SIOCRTMSG   0x890D
// Socket configuration controls
/** Get iface name */
#define SIOCGIFNAME   0x8910
/** Set iface channel */
#define SIOCSIFLINK   0x8911
/** Get iface list */
#define SIOCGIFCONF   0x8912
/** Get flags */
#define SIOCGIFFLAGS   0x8913
/** Set flags */
#define SIOCSIFFLAGS   0x8914
/** Get PA address */
#define SIOCGIFADDR   0x8915
/** Set PA address */
#define SIOCSIFADDR   0x8916
/** Get remote PA address */
#define SIOCGIFDSTADDR   0x8917
/** Set remote PA address */
#define SIOCSIFDSTADDR   0x8918
/** Get broadcast PA address */
#define SIOCGIFBRDADDR   0x8919
/** Set broadcast PA address */
#define SIOCSIFBRDADDR   0x891a
/** Get network PA mask */
#define SIOCGIFNETMASK   0x891b
/** Set network PA mask */
#define SIOCSIFNETMASK   0x891c
/** Get metric */
#define SIOCGIFMETRIC   0x891d
/** Set metric */
#define SIOCSIFMETRIC   0x891e
/** Get memory address (BSD) */
#define SIOCGIFMEM   0x891f
/** Set memory address (BSD) */
#define SIOCSIFMEM   0x8920
/** Get MTU size */
#define SIOCGIFMTU   0x8921
/** Set MTU size */
#define SIOCSIFMTU   0x8922
/** Set interface name */
#define SIOCSIFNAME   0x8923
/** Set hardware address */
#define SIOCSIFHWADDR   0x8924
/** Get/Set encapsulations */
#define SIOCGIFENCAP   0x8925
#define SIOCSIFENCAP   0x8926
/** Get hardware address */
#define SIOCGIFHWADDR   0x8927
/** Driver slaving support */
#define SIOCGIFSLAVE   0x8929
#define SIOCSIFSLAVE   0x8930
/** Multicast address lists */
#define SIOCADDMULTI   0x8931
#define SIOCDELMULTI   0x8932
/** name -> if_index mapping */
#define SIOCGIFINDEX   0x8933
/** misprint compatibility */
#define SIOGIFINDEX  SIOCGIFINDEX
/** Set/Get extended flags set */
#define SIOCSIFPFLAGS   0x8934
#define SIOCGIFPFLAGS   0x8935
/** Delete PA address */
#define SIOCDIFADDR   0x8936
/** Set hardware broadcast addr */
#define SIOCSIFHWBROADCAST   0x8937
/** Get number of devices */
#define SIOCGIFCOUNT   0x8938
/** Bridging support */
#define SIOCGIFBR   0x8940
/** Set bridging options */
#define SIOCSIFBR   0x8941
/** Get the tx queue length */
#define SIOCGIFTXQLEN   0x8942
/** Set the tx queue length */
#define SIOCSIFTXQLEN   0x8943
// ARP cache control calls
/** Delete ARP table entry */
#define SIOCDARP   0x8953
/** Get ARP table entry */
#define SIOCGARP   0x8954
/** Set ARP table entry */
#define SIOCSARP   0x8955
// RARP cache control calls
/** Delete RARP table entry */
#define SIOCDRARP   0x8960
/** Get RARP table entry */
#define SIOCGRARP   0x8961
/** Set RARP table entry */
#define SIOCSRARP   0x8962
// Driver configuration calls
/** Get device parameters */
#define SIOCGIFMAP   0x8970
/** Set device parameters */
#define SIOCSIFMAP   0x8971
// DLCI configuration calls
/** Create new DLCI device */
#define SIOCADDDLCI   0x8980
/** Delete DLCI device */
#define SIOCDELDLCI   0x8981
// Device private ioctl calls
/** These 16 ioctls are available to devices via the do_ioctl() device vector; Each device should include this file and redefine these names as their own */
#define SIOCDEVPRIVATE   0x89F0  // to 89FF
/** Protocol private */
#define SIOCPROTOPRIVATE   0x89E0  // to 89EF


#ifdef SYS_ioctl


LIB_FUNC int ioctl(const int fd, const int req, ...) {
	void* arg;
	va_list ap;
	va_start(ap, req);
	arg = va_arg(ap, void*);
	va_end(ap);
	return (int)syscall(SYS_ioctl, fd, req, arg);
}
#define HAVE_IOCTL   (1)


/** Version of ioctl that retries after a signal is caught */
LIB_FUNC int xioctl(const int fd, const int request, char* arg) {
	register int i;
	while ((i = ioctl(fd, request, arg)) == -1 && (errno == EINTR));
	return i;
}


#endif


LIB_FUNC int tcgetattr(const int fildes, struct termios* termios_p) {
	return ioctl(fildes, TCGETS, termios_p);
}


LIB_FUNC int tcsetattr(int fd, int act, const struct termios* tio) {
	if (act < 0 || act > 2) {
		errno = EINVAL;
		return -1;
	}
	return ioctl(fd, (TCSETS + act), tio);
}


LIB_FUNC int isatty(const int fd) {
	struct termios term;
	register const int save = errno;
	register const int is_tty = (ioctl(fd, TCGETS, &term) == 0);
	errno = save;
	return is_tty;
}


#endif  // IOCTL_TYPES_H


/* TTY (<tty.h>) */


#if (!(defined(SYS_TTY_H) || defined(_SYS_TTY_H_) || defined(TTY_H) || defined(_TTY_H_)))
#define SYS_TTY_H   (1)
#define _SYS_TTY_H   (1)
#define _SYS_TTY_H_   (1)
#define TTY_H   (1)
#define _TTY_H   (1)
#define _TTY_H_   (1)


#ifndef TTYCLSIZE
#   define TTYCLSIZE   (1024)
#endif


/** NetBSD Clists are actually ring buffers. The c_cc, c_cf, and c_cl fields have exactly the same behaviour as in true clists. If c_cq is NULL, the ring buffer has no TTY_QUOTE functionality, but saves memory and cpu time */
struct clist {
	/** Count of characters in queue */
	int c_cc;
	/** Total ring buffer length */
	int c_cn;
	/** Points to first character */
	unsigned char* c_cf;
	/** Points to next open character */
	unsigned char* c_cl;
	/** Start of ring buffer */
	unsigned char* c_cs;
	/** c_ce + c_len */
	unsigned char* c_ce;
	/** N bits/bytes long */
	unsigned char* c_cq;
};


#endif  // TTY_H


/* FILE CONTROL (<fcntl.h>) */


#if (!(defined(_FCNTL_H) || defined(_FCNTL_H_) || defined(_INC_FCNTL)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html
#define _FCNTL_H   (1)
#define _FCNTL_H_   (1)
#define _INC_FCNTL   (1)
#define _LIBC_FCNTL_H_   (1)


#define F_LINUX_SPECIFIC_BASE   1024

/** Skip search permission checks */
#define O_SEARCH   O_PATH
#define O_EXEC   O_PATH
#define F_OFD_GETLK   36
#define F_OFD_SETLK   37
#define F_OFD_SETLKW   38
#define F_DUPFD_CLOEXEC   1030
#define F_RDLCK   0
#define F_WRLCK   1
#define F_UNLCK   2
#define FD_CLOEXEC   1
#define POSIX_FADV_NORMAL   0
#define POSIX_FADV_RANDOM   1
#define POSIX_FADV_SEQUENTIAL 2
#define POSIX_FADV_WILLNEED   3
#define POSIX_FADV_DONTNEED   4
#define POSIX_FADV_NOREUSE    5
#define AT_NO_AUTOMOUNT   0x800
#define AT_EMPTY_PATH   0x1000
#define FAPPEND   O_APPEND
#define FFSYNC   O_FSYNC
#ifndef FASYNC
#   define FASYNC   O_ASYNC
#endif
#define FNONBLOCK   O_NONBLOCK
#define FNDELAY   O_NDELAY
#define F_SETLEASE   1024
#define F_GETLEASE   1025
#define F_NOTIFY   1026
#define F_CANCELLK   1029
#define F_SETPIPE_SZ   1031
#define F_GETPIPE_SZ   1032
#define F_ADD_SEALS   1033
#define F_GET_SEALS   1034
#define F_SEAL_SEAL   1
#define F_SEAL_SHRINK   2
#define F_SEAL_GROW   4
#define F_SEAL_WRITE   8
#define DN_ACCESS   1
#define DN_MODIFY   2
#define DN_CREATE   4
#define DN_DELETE   8
#define DN_RENAME   0x10
#define DN_ATTRIB   0x20
#define DN_MULTISHOT   0x80000000
#define F_OWNER_TID   0
#define F_OWNER_PID   1
#define F_OWNER_PGRP   2
#define F_OWNER_GID   2
#define FALLOC_FL_KEEP_SIZE   1
#define FALLOC_FL_PUNCH_HOLE   2
#define SPLICE_F_MOVE   1
#define SPLICE_F_NONBLOCK   2
#define SPLICE_F_MORE   4
#define SPLICE_F_GIFT   8


typedef struct f_owner_ex { int type; pid_t pid; }   f_owner_ex_t;
typedef struct attr_packed Radvisory { int64_t Offset; int32_t Count; }   Radvisory_t;
typedef struct attr_packed Log2phys { uint32_t Flags; int64_t Contigbytes, Devoffset; }   Log2phys_t;


typedef struct Fstore {
	uint32_t Flags;
	int32_t Posmode;
	int64_t Offset, Length, Bytesalloc;
} Fstore_t;


/** No further special treatment */
#define POSIX_FADV_NORMAL   0
/** Expect random page references */
#define POSIX_FADV_RANDOM   1
/** Expect sequential page references */
#define POSIX_FADV_SEQUENTIAL   2
/** Will need these pages */
#define POSIX_FADV_WILLNEED   3
/** Do not need these pages */
#define POSIX_FADV_DONTNEED   4
/** Data will be accessed once */
#define POSIX_FADV_NOREUSE   5
/** Move pages instead of copying */
#define SPLICE_F_MOVE   1
#define SPLICE_F_NONBLOCK   2
/** Expect more data */
#define SPLICE_F_MORE   4
/** Pages passed in are a gift */
#define SPLICE_F_GIFT   8
#define _O_RDONLY   0
#define _O_WRONLY   1
#define _O_RDWR   2
#define _O_APPEND   8
#define _O_CREAT   0x100
#define _O_TRUNC   0x200
#define _O_EXCL   0x400
#define _O_TEXT   0x4000
#define _O_BINARY   0x8000
#define _O_WTEXT   0x10000
#define _O_U16TEXT   0x20000
#define _O_U8TEXT   0x40000
#define _O_ACCMODE   (_O_RDONLY | _O_WRONLY | _O_RDWR)
#define _O_RAW   _O_BINARY
#define _O_NOINHERIT   0x80
#define _O_TEMPORARY   0x40
#define _O_SHORT_LIVED   0x1000
#define _O_SEQUENTIAL   0x20
#define _O_RANDOM   0x10


/** Manipulate file descriptor */
LIB_FUNC int fcntl64(const int fd, int cmd, ...) {
	va_list list;
	va_start(list, cmd);
	long arg = va_arg(list, long);
	va_end(list);
	return (int)(syscall(SYS_fcntl64, fd, cmd, arg));
}


/** Manipulate file descriptor */
LIB_FUNC int __fcntl(const int fd, int cmd, ...) {
	va_list ap;
	void* arg;
	va_start(ap, cmd);
	arg = va_arg(ap, void*);
	va_end(ap);
	return (int)fcntl64(fd, cmd, arg);
}


/** Manipulate file descriptor */
LIB_FUNC int fcntl(const int fd, const int cmd, ...) {
	va_list ap;
	va_start(ap, cmd);
	unsigned long arg = va_arg(ap, unsigned long);
	va_end(ap);
	if (cmd == F_SETFL) { arg |= O_LARGEFILE; }
	if (cmd == F_SETLKW) { return (int)syscall(SYS_fcntl, fd, cmd, (void*)arg); }
	else if (cmd == F_GETOWN) {
		struct f_owner_ex ex;
		int ret = (int)syscall(SYS_fcntl, fd, F_GETOWN_EX, &ex);
		if (ret == -EINVAL) { return (int)syscall(SYS_fcntl, fd, cmd, (void*)arg); }
		else if (ret) { return (int)__syscall_ret((unsigned long)ret); }
		else { return (ex.type == F_OWNER_PGRP ? -ex.pid : ex.pid); }
		UNREACHABLE
	} else if (cmd == F_DUPFD_CLOEXEC) {
		int ret = (int)syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, arg);
		if (ret != -EINVAL) {
			if (ret >= 0) { syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC); }
			return (int)__syscall_ret((unsigned long)ret);
		}
		ret = (int)syscall(SYS_fcntl, fd, F_DUPFD_CLOEXEC, 0);
		if (ret != -EINVAL) {
			if (ret >= 0) { syscall(SYS_close, ret); }
			return (int)__syscall_ret((unsigned long)-EINVAL);
		}
		ret = (int)syscall(SYS_fcntl, fd, F_DUPFD, arg);
		if (ret >= 0) { syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC); }
		return (int)__syscall_ret((unsigned long)ret);
		UNREACHABLE
	}
	switch (cmd) {
		case F_SETLK:
		case F_GETLK:
		case F_GETOWN_EX:
		case F_SETOWN_EX:
			return (int)syscall(SYS_fcntl, fd, cmd, (void*)arg);
		default:
			return (int)syscall(SYS_fcntl, fd, cmd, arg);
	}
	UNREACHABLE
}


/** Preallocate space to a file */
LIB_FUNC int fallocate(int fd, int mode, off_t base, off_t len) {
	return (int)syscall(SYS_fallocate, fd, mode, __SYSCALL_LL_E(base), __SYSCALL_LL_E(len));
}
#define fallocate64(fd, mode, base, len)   fallocate((fd), (mode), (base), (len))


/** Preallocate space to a file */
LIB_FUNC int posix_fallocate(int fd, off_t base, off_t len) {
	return (int)(-(__syscall(SYS_fallocate, fd, 0, (__SYSCALL_LL_E(base)), (__SYSCALL_LL_E(len)))));
}
#define posix_fallocate64(fd, base, len)   fallocate((fd), (base), (len))


/** Perform file readahead into page cache */
LIB_FUNC ssize_t readahead(int fd, off_t pos, size_t len) {
	return (ssize_t)syscall(SYS_readahead, fd, __SYSCALL_LL_O(pos), len);
}


/** Sync a file segment with disk */
LIB_FUNC int sync_file_range(const int fd, const off_t pos, const off_t len, const unsigned flags) {
#   ifdef SYS_sync_file_range2
	return (int)syscall(SYS_sync_file_range2, fd, flags, __SYSCALL_LL_E(pos), __SYSCALL_LL_E(len));
#   elif defined(SYS_sync_file_range)
	return (int)syscall(SYS_sync_file_range, fd, __SYSCALL_LL_O(pos), __SYSCALL_LL_E(len), flags);
#   else
	return (int)__syscall_ret(-ENOSYS);
#   endif
}


/** Splice user pages into a pipe */
LIB_FUNC ssize_t vmsplice(int fd, const struct iovec* iov, size_t cnt, unsigned int flags) {
	return (ssize_t)syscall(SYS_vmsplice, fd, iov, cnt, flags);
}


/** Splice data to/from a pipe */
LIB_FUNC ssize_t splice(int fd_in, off_t* off_in, int fd_out, off_t* off_out, size_t len, unsigned int flags) {
	return (ssize_t)syscall(SYS_splice, fd_in, off_in, fd_out, off_out, len, flags);
}


/** Duplicating pipe content */
LIB_FUNC ssize_t tee(int src, int dest, size_t len, unsigned int flags) {
	return (ssize_t)syscall(SYS_tee, src, dest, len, flags);
}


/** Apply, test, or remove a POSIX lock on an open file */
LIB_FUNC int lockf(const int fd, const int op, const off_t size) {
	struct flock l = { .l_type = F_WRLCK, .l_whence = SEEK_CUR, .l_len = size };
	switch (op) {
		case F_TEST:
			l.l_type = F_RDLCK;
			if (fcntl(fd, F_GETLK, &l) < 0) { return -1; }
			else if (l.l_type == F_UNLCK || l.l_pid == getpid()) { return 0; }
			errno = EACCES;
			return -1;
		case F_ULOCK:
			l.l_type = F_UNLCK;
		case F_TLOCK:
			return fcntl(fd, F_SETLK, &l);
		case F_LOCK:
			return fcntl(fd, F_SETLKW, &l);
		default:
			errno = EINVAL;
			return -1;
	}
	UNREACHABLE
}
#define _lockf(fd, op, size)   lockf((fd), (op), (size))
#define __lockf(fd, op, size)   lockf((fd), (op), (size))
#define lockf64(fd, op, size)   lockf((fd), (op), (size))


/** Open and possibly create a file */
LIB_FUNC int open(const char* filename, const int flags, ...) {
	register mode_t mode = 0;
	if ((flags & O_CREAT) || (flags & O_TMPFILE) == O_TMPFILE) {
		va_list ap;
		va_start(ap, flags);
		mode = va_arg(ap, mode_t);
		va_end(ap);
	}
	const int fd = (int)syscall(SYS_open, filename, flags, mode);
	if (fd >= 0 && (flags & O_CLOEXEC)) { syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC); }
	return (int)__syscall_ret((unsigned long)fd);
}
#define _open(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))
#define __open(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))
#define open64(filename, flags, ...)   open((filename), (flags), (__VA_ARGS__))


/** Open and possibly create a file */
LIB_FUNC int openat(const int fd, const char* filename, const int flags, ...) {
	register mode_t mode = 0;
	if ((flags & O_CREAT) || (flags & O_TMPFILE) == O_TMPFILE) {
		va_list ap;
		va_start(ap, flags);
		mode = va_arg(ap, mode_t);
		va_end(ap);
	}
	return (int)syscall(SYS_openat, fd, filename, (flags | O_LARGEFILE), mode);
}
#define _openat(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))
#define __openat(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))
#define openat64(fd, filename, flags, ...)   openat((fd), (filename), (flags), (__VA_ARGS__))


/** Open and possibly create a file */
LIB_FUNC int creat(const char* filename, const mode_t mode) {
	return (int)open(filename, (O_CREAT | O_WRONLY | O_TRUNC), mode);
}
#define _creat(filename, mode)   creat((filename), (mode))
#define creat64(filename, mode)   creat((filename), (mode))


/** Predeclare an access pattern for file data */
LIB_FUNC int posix_fadvise(const int fd, const off_t base, const off_t len, const int advice) {
	return -(int)(syscall(SYS_fadvise, fd, __SYSCALL_LL_O(base), __SYSCALL_LL_E(len), advice));
}
#define _fadvise(fd, base, len, advice)   posix_fadvise((fd), (base), (len), (advice))
#define posix_fadvise64(fd, base, len, advice)   posix_fadvise((fd), (base), (len), (advice))


#endif  // FCNTL_H


/* LOCALIZATION (<locale.h> and <xlocale.h>) */


#if (!(defined(LOCALE_H) || defined(_LOCALE_H) || defined(_LOCALE_H_) || defined(_UCLIBC_LOCALE_H) || defined(_XLOCALE_H) || defined(_BITS_LOCALE_H)))  // http://www.cplusplus.com/reference/clocale/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/locale.h.html
#define LOCALE_H   (1)
#define _LOCALE_H   (1)
#define _LOCALE_H_   (1)
#define _UCLIBC_LOCALE_H   (1)
#define _UCLIBC_LOCALE_H_   (1)
#define __PDCLIB_LOCALE_H   (1)
#define __PDCLIB_LOCALE_H_   (1)
#define XLOCALE_H   (1)
#define _XLOCALE_H   (1)
#define _XLOCALE_H_   (1)
#define _BITS_LOCALE_H   (1)  // <bits/locale.h>


// These are the bits that can be set in the CATEGORY_MASK argument for `newlocale`
#define LC_CTYPE_MASK   (1 << __LC_CTYPE)
#define LC_NUMERIC_MASK   (1 << __LC_NUMERIC)
#define LC_TIME_MASK   (1 << __LC_TIME)
#define LC_COLLATE_MASK   (1 << __LC_COLLATE)
#define LC_MONETARY_MASK   (1 << __LC_MONETARY)
#define LC_MESSAGES_MASK   (1 << __LC_MESSAGES)
#ifdef LC_PAPER
#   define LC_PAPER_MASK   (1 << __LC_PAPER)
#   define LC_NAME_MASK   (1 << __LC_NAME)
#   define LC_ADDRESS_MASK   (1 << __LC_ADDRESS)
#   define LC_TELEPHONE_MASK   (1 << __LC_TELEPHONE)
#   define LC_MEASUREMENT_MASK   (1 << __LC_MEASUREMENT)
#   define LC_IDENTIFICATION_MASK   (1 << __LC_IDENTIFICATION)
#   define LC_ALL_MASK   (LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK | LC_PAPER_MASK | LC_NAME_MASK | LC_ADDRESS_MASK | LC_TELEPHONE_MASK | LC_MEASUREMENT_MASK | LC_IDENTIFICATION_MASK)
#else  // LC_PAPER
#   define LC_ALL_MASK    (LC_CTYPE_MASK | LC_NUMERIC_MASK | LC_TIME_MASK | LC_COLLATE_MASK | LC_MONETARY_MASK | LC_MESSAGES_MASK)
#endif  // LC_PAPER
#define LOCALE_STRING_SIZE   (14)
/** Special weight constant for the collation data */
#define IGNORE_CHAR   (2)
#define MAX_USAGE_COUNT   (UINT_MAX - 1)
#define UNDELETABLE   UINT_MAX
#define LOCFILE_ALIGN   BYTES_PER_INT
#define LOCFILE_ALIGN_MASK   (LOCFILE_ALIGN - 1)
#define LOCFILE_ALIGN_UP(x)   (((x) + (LOCFILE_ALIGN_MASK)) & (~(LOCFILE_ALIGN_MASK)))
#define LOCFILE_ALIGNED_P(x)   (((x) & (LOCFILE_ALIGN_MASK)) == 0x0)
/** This value can be passed to `uselocale` and may be returned by it; Passing this value to any other function has undefined behavior */
#define LC_GLOBAL_LOCALE   ((__locale_t)-1L)
#define __XL_NPP(N)   N
#define __LOCALE_PARAM   , __locale_t locale_arg
#define __LOCALE_ARG   , locale_arg
#define __LOCALE_PTR   locale_arg
#define NMBSTATET   (10)
/** Magic number at the beginning of a locale data file for CATEGORY */
#define LIMAGIC(category)   (category == LC_COLLATE ? ((unsigned int)(0x20051014 ^ (category))) : category == LC_CTYPE ? ((unsigned int)(0x20090720 ^ (category))) : ((unsigned int)(0x20031115 ^ (category))))
// Definitions for `era` information from LC_TIME
#define ERA_NAME_FORMAT_MEMBERS   (4)
#define ERA_M_NAME   (0)
#define ERA_M_FORMAT   (1)
#define ERA_W_NAME   (2)
#define ERA_W_FORMAT   (3)
#define _LOCALE_METHOD_TSS   't'
#define _LOCALE_METHOD_THREAD_LOCAL   'T'
#define _PDCLIB_LOCALE_METHOD_TSS   't'
#define _PDCLIB_LOCALE_METHOD_THREAD_LOCAL   'T'
#ifndef _LOCALE_METHOD
#   define _LOCALE_METHOD   't'
#   define _PDCLIB_LOCALE_METHOD   't'
#endif
#define MB_CUR_MAX   (5)
#define __ctype_get_mb_cur_max()   ((size_t)5)
#define LOCALE_NAME_MAX   15


/** We need to have the error status variable of the resolver accessible in the libc */
extern Thread_local UNUSED locale_t locale_tls;
extern Thread_local UNUSED tss_t locale_tss;
#define _PDCLIB_locale_tls   locale_tls
#define PDCLIB_locale_tls   locale_tls
#define _locale_tls   locale_tls
#define _PDCLIB_locale_tss   locale_tss
#define PDCLIB_locale_tss   locale_tss
#define _locale_tss   locale_tss


/** Structure to access `era` information from LC_TIME */
typedef struct attr_packed era_entry {
	uint32_t direction;  // Contains '+' or '-'
	int32_t offset;
	int32_t start_date[3];
	int32_t stop_date[3];
	const char* era_name;
	const char* era_format;
	const wchar_t* era_wname;
	const wchar_t* era_wformat;
	int absolute_direction;  // +1 indicates that year number is higher in the future (like A.D.); -1 indicates that year number is higher in the past (like B.C.)
} era_entry_t;


/** Structure caching computed data about information from LC_TIME; The `private.time` member of `struct __locale_data` points to this */
typedef struct attr_packed lc_time_data {
	struct era_entry* eras;
	size_t num_eras;
	int era_initialized;
	const char** alt_digits;
	const wchar_t** walt_digits;
	int alt_digits_initialized, walt_digits_initialized;
} lc_time_data_t;


struct __locale_map {
	const void* map;
	size_t map_size;
	char name[LOCALE_NAME_MAX + 1];
	const struct __locale_map* next;
};


/** Structure giving information about numeric and monetary notation */
typedef struct attr_packed lconv {
	// Numeric (non-monetary) information
	/** Decimal point character */
	const char* decimal_point;
	/** Thousands separator */
	const char* thousands_sep;
	/** Specifies the amount of digits that form each of the groups to be separated by thousands_sep separator for non-monetary quantities. This is a zero-terminated sequence of char values that may contain different grouping sizes for each successive group starting from the right, each number indicating the amount of digits for the group; the last number before the ending zero in this string is used for the remaining groups */
	const char* grouping;
	// Monetary information
	/** First three chars are a currency symbol from ISO4217, the fourth char is the separator, and the fifth char is '\0' */
	const char* int_curr_symbol;
	/** Local currency symbol */
	const char* currency_symbol;
	/** Decimal point character */
	const char* mon_decimal_point;
	/** Thousands separator */
	const char* mon_thousands_sep;
	/** Like `grouping` element (above) */
	const char* mon_grouping;
	/** Sign for positive values */
	const char* positive_sign;
	/** Sign for negative values */
	const char* negative_sign;
	/** International fractional digits */
	char int_frac_digits;
	/** Local fractional digits */
	char frac_digits;
	/** 1 if currency_symbol precedes a positive value, 0 if succeeds */
	char p_cs_precedes;
	/** 1 if a space separates currency_symbol from a positive value */
	char p_sep_by_space;
	/** 1 if currency_symbol precedes a negative value, 0 if succeeds */
	char n_cs_precedes;
	/** 1 iff a space separates currency_symbol from a negative value */
	char n_sep_by_space;
	/** Positive and negative sign positions:
	 - 0: Parentheses surround the quantity and currency_symbol
	 - 1: The sign string precedes the quantity and currency_symbol
	 - 2: The sign string follows the quantity and currency_symbol
	 - 3: The sign string immediately precedes the currency_symbol
	 - 4: The sign string immediately follows the currency_symbol
	*/
	char p_sign_posn, n_sign_posn;
	/** 1 if int_curr_symbol precedes a positive value, 0 if succeeds */
	char int_p_cs_precedes;
	/** 1 iff a space separates int_curr_symbol from a positive value */
	char int_p_sep_by_space;
	/** 1 if int_curr_symbol precedes a negative value, 0 if succeeds */
	char int_n_cs_precedes;
	/** 1 iff a space separates int_curr_symbol from a negative value */
	char int_n_sep_by_space;
	/** Positive and negative sign positions:
	 - 0: Parentheses surround the quantity and int_curr_symbol
	 - 1: The sign string precedes the quantity and int_curr_symbol
	 - 2: The sign string follows the quantity and int_curr_symbol
	 - 3: The sign string immediately precedes the int_curr_symbol
	 - 4: The sign string immediately follows the int_curr_symbol
	*/
	char int_p_sign_posn, int_n_sign_posn;
} lconv_t;


static UNUSED struct lconv C_LOCALE_INITIALIZER = {
	".", "", "", "", "", "",  // Decimal_point - mon_decimal_point
	"", "", "", "", 127, 127,  // mon_thousands_sep - frac_digits
	127, 127, 127, 127, 127, 127,  // p_cs_precedes - n_sign_posn
	127, 127, 127, 127, 127, 127  // int_p_cs_precedes - int_n_sign_posn
};


#define locale_table   C_LOCALE_INITIALIZER
/** Locale object for global C locale */
static UNUSED locale_t __global_locale = NULL;
/** Locale object for global C locale */
#define _NL_CURRENT_LOCALE   __global_locale
#define CURRENT_LOCALE   __global_locale
#define _nl_C_locobj   __global_locale
#define _nl_C_locobj_ptr   ((locale_t*)&_nl_C_locobj)
UNUSED _RuneLocale _DefaultRuneLocale;
UNUSED _RuneLocale* _CurrentRuneLocale;
/** Return a pointer to the global locale */
#define __current_locale()   (locale_t)(&__global_locale)
/** Return a pointer to the global locale */
#define current_locale()   (locale_t)(&__global_locale)
#define DEFAULT_CURRENT_LOCALE(x)   if ((x) == NULL) { (x) = current_locale(); } else if ((x) == LC_GLOBAL_LOCALE) { (x) = &__global_locale; }
#define NORMALIZE_LOCALE(x)   if ((x) == NULL) { (x) = __global_locale; } else if ((x) == LC_GLOBAL_LOCALE) { (x) = __global_locale; }
/** Set libc.global_locale to __global_locale */
#define sync_libc_locale()   do { _libc_global_locale = __global_locale; } while (0x0)


// LOCALE FUNCTIONS


LIB_FUNC const char* __lctrans(const char* msg, UNUSED int cat, const UNUSED locale_t loc) {
	return msg;
}
#define lctrans(msg, cat, loc)   __lctrans((msg), (cat), (loc))
#define LCTRANS(msg, cat, loc)   __lctrans((msg), (cat), (loc))


LIB_FUNC const char* __lctrans_cur(const char* msg) {
	return msg;
}
#define lctrans_cur(msg)   __lctrans_cur((msg))
#define LCTRANS_CUR(msg)   __lctrans_cur((msg))


/** Return the numeric/monetary information for the current locale */
LIB_FUNC struct lconv* localeconv(void) {
	return &locale_table;
}


/** Charset name normalization */
LIB_FUNC void strip(char* wp, const char* s) {
	register int slash_count = 0;
	while (*s != '\0') {
		if (isalnum_l(*s, _nl_C_locobj_ptr) || *s == '_' || *s == '-' || *s == '.' || *s == ',' || *s == ':') { *wp++ = (char)toupper_l(*s, _nl_C_locobj_ptr); }
		else if (*s == '/') { if (++slash_count == 3) { break; } else { *wp++ = '/'; } }
		++s;
	}
	while (slash_count++ < 2) { *wp++ = '/'; }
	*wp = '\0';
}


LIB_FUNC char* upstr(char* dst, const char* str) {
	char* cp = dst;
	while ((*cp = (char)toupper_l(*str, _nl_C_locobj_ptr)) != '\0') { ++cp; ++str; };
	return dst;
}


/** Return a pointer to the current locale */
LIB_FUNC locale_t locale_ptr(locale_t loc) {
	NORMALIZE_LOCALE(loc);
	return loc;
}


/** Set and/or return the current locale */
LIB_FUNC const char* setlocale(const UNUSED int __category, const char* restrict __locale) {
	lc_ctype = CT_8BIT;
	if (PREDICT_LIKELY((__locale && (__category == LC_ALL || __category == LC_CTYPE)))) {
		if (!*__locale) {
			const char* x = getenv("LC_CTYPE");
			if (!x) { x = getenv("LC_ALL"); }
			if (!x) { x = "C"; }
			__locale = x;
		}
	}
	if (__locale) {
		if (strstr(__locale, ".UTF-8") || strstr(__locale, ".UTF8")) { lc_ctype = CT_UTF8; }
		if (__locale[0] != 'C' || __locale[1]) { return (const char*)0; }
	}
	return (const char*)"C";
}


LIB_FUNC int alias_compare(const struct alias_map* map1, const struct alias_map* map2) {
	if (map1->alias == map2->alias) { return 0; }
	const unsigned char* p1 = (const unsigned char*)map1->alias;
	const unsigned char* p2 = (const unsigned char*)map2->alias;
	register unsigned char c1, c2;
	do {
		c1 = (unsigned char)(((0x40 < *p1) && (*p1 < 0x5B)) ? (*p1 + 0x20) : *p1);
		c2 = (unsigned char)(((0x40 < *p2) && (*p2 < 0x5B)) ? (*p2 + 0x20) : *p2);
		if (c1 == '\0') { break; }
		++p1;
		++p2;
	} while (c1 == c2);
	return (int)(c1 - c2);
}


/* TODO: Add locale functions
locale_t duplocale(locale_t);
void freelocale(locale_t);
locale_t newlocale(int, const char*, locale_t);
locale_t uselocale(locale_t);
*/


#endif  // LOCALE_H


/* LANGUAGE INFORMATION CONSTANTS (<langinfo.h> & <nl_types.h>) */


#if (!(defined(NL_TYPES_H) || defined(_NL_TYPES_H) || defined(_NL_TYPES_H_) || defined(_LANGINFO_H) || defined(_LANGINFO_H_) || defined(_POSIX_LANGINFO_H) || defined(_LIBC_LANGINFO_H_)))  //  http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/nl_types.h.html & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html
#define NL_TYPES_H   (1)
#define _NL_TYPES_H   (1)
#define _NL_TYPES_H_   (1)
#define _LIBC_NL_TYPES_H_   (1)
#define LANGINFO_H   (1)
#define _LANGINFO_H   (1)
#define _LANGINFO_H_   (1)
#define _POSIX_LANGINFO_H   (1)
#define _POSIX_LANGINFO_H_   (1)
#define _LIBC_LANGINFO_H_   (1)


/** The default message set used by the gencat program */
#define NL_SETD   (1)
/** Value for FLAG parameter of `catgets` to set XPG4 compliance */
#define NL_CAT_LOCALE   (1)
/** Construct an `nl_item` value for `nl_langinfo` from a locale category (LC_*) and an item index within the category; Some code may depend on the item values within a category increasing monotonically with the indices */
#define _NL_ITEM(category, index)   (((category) << 0x10) | (index))
/** Extract the category and item index from a constructed `nl_item` value */
#define _NL_ITEM_CATEGORY(item)   ((int)(item) >> 0x10)
/** Extract the category and item index from a constructed `nl_item` value */
#define _NL_ITEM_INDEX(item)   ((int)(item) & 0xFFFF)
// The abbreviated seven days of the week
/** Sunday */
#define ABDAY_1   0x20000
#define ABDAY_2   0x20001
#define ABDAY_3   0x20002
#define ABDAY_4   0x20003
#define ABDAY_5   0x20004
#define ABDAY_6   0x20005
#define ABDAY_7   0x20006
// The seven days of the week
/** Sunday */
#define DAY_1   0x20007
/** Monday */
#define DAY_2   0x20008
/** Tuesday */
#define DAY_3   0x20009
/** Wednesday */
#define DAY_4   0x2000A
/** Thursday */
#define DAY_5   0x2000B
/** Friday */
#define DAY_6   0x2000C
/** Saturday */
#define DAY_7   0x2000D
// The abbreviated twelve months
/** Jan */
#define ABMON_1   0x2000E
#define ABMON_2   0x2000F
#define ABMON_3   0x20010
#define ABMON_4   0x20011
#define ABMON_5   0x20012
#define ABMON_6   0x20013
#define ABMON_7   0x20014
#define ABMON_8   0x20015
#define ABMON_9   0x20016
#define ABMON_10   0x20017
#define ABMON_11   0x20018
/** Dec */
#define ABMON_12   0x20019
// The full names of the twelve months
/** January */
#define MON_1   0x2001A
#define MON_2   0x2001B
/** March */
#define MON_3   0x2001C
/** April */
#define MON_4   0x2001D
/** May */
#define MON_5   0x2001E
/** June */
#define MON_6   0x2001F
/** July */
#define MON_7   0x20020
#define MON_8   0x20021
#define MON_9   0x20022
#define MON_10   0x20023
#define MON_11   0x20024
/** December */
#define MON_12   0x20025
// Format date and time
/** AM string */
#define AM_STR   0x20026
/** PM string */
#define PM_STR   0x20027
/** String for formatting date and time */
#define D_T_FMT   0x20028
/** Date format */
#define D_FMT   0x20029
/** Time format */
#define T_FMT   0x2002A
/** AM or PM time format string */
#define T_FMT_AMPM   0x2002B
/** Era description segments */
#define ERA   0x2002C
#define ERA_D_FMT   0x2002E
/** Alternative symbols for digits */
#define ALT_DIGITS   0x2002F
#define ERA_D_T_FMT   0x20030
#define ERA_T_FMT   0x20031
/** Codeset name */
#define CODESET   14
/** Currency symbol */
#define CRNCYSTR   0x4000F
/** Radix character */
#define RADIXCHAR   0x10000
/** Separator for thousand */
#define THOUSEP   0x10001
#define YESEXPR   0x50000
#define NOEXPR   0x50001
/** Affirmative response for yes/no queries */
#define YESSTR   0x50002
/** Negative response for yes/no queries */
#define NOSTR   0x50003
#ifndef MAXSTRMSG
/** Maximum number of strings in langinfo */
#   define MAXSTRMSG   58
#endif


static const UNUSED char c_time[] = "Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0" "Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0" "Thursday\0" "Friday\0" "Saturday\0" "Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0" "Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0" "January\0" "February\0" "March\0" "April\0" "May\0" "June\0" "July\0" "August\0" "September\0" "October\0" "November\0" "December\0" "AM\0" "PM\0" "%a %b %e %T %Y\0" "%m/%d/%y\0" "%H:%M:%S\0" "%I:%M:%S %p\0" "\0" "\0" "%m/%d/%y\0" "0123456789\0" "%a %b %e %T %Y\0" "%H:%M:%S";


static const UNUSED char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
static const UNUSED char c_numeric[] = ".\0" "";
static const UNUSED char sweekdays[8][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "\0" };


static const UNUSED char weekdays[8][16] = {
	"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "\0"
};


static const UNUSED char smonths[16][4] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "\0", "\0", "\0", "\0"
};


static const UNUSED char months[16][16] = {
	"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "\0", "\0", "\0", "\0"
};


/** Open a message catalog */
LIB_FUNC nl_catd catopen(const UNUSED char* restrict name, const UNUSED int oflag) {
	return ((nl_catd)-1);
}


/** Read a program message */
LIB_FUNC const char* catgets(const UNUSED nl_catd catd, const UNUSED int set_id, const UNUSED int msg_id, const UNUSED char* restrict s) {
	return (const char*)s;
}


/** Close a message catalog descriptor */
LIB_FUNC int catclose(const UNUSED nl_catd catd) {
	return 0;
}


/** Get a string from the database */
LIB_FUNC const char* nl_langinfo_l(const nl_item item, const locale_t loc) {
	if (item == CODESET) { return (MB_CUR_MAX == 1 ? "ASCII" : "UTF-8"); }
	register int cat = item >> 16;
	register int idx = item & 65535;
	const char* str;
	switch (cat) {
		case LC_NUMERIC:
			if (idx > 1) { return ""; }
			str = c_numeric;
			break;
		case LC_TIME:
			if (idx > 0x31) { return ""; }
			str = c_time;
			break;
		case LC_MONETARY:
			if (idx > 0) { return ""; }
			str = "";
			break;
		case LC_MESSAGES:
			if (idx > 3) { return ""; }
			str = c_messages;
			break;
		default: return "";
	}
	for (; idx; idx--, str++) { for (; *str; str++); }
	if ((cat != LC_NUMERIC) && *str) { str = lctrans(str, cat, loc); }
	return (const char*)str;
}
#define __nl_langinfo_l(item, loc)   nl_langinfo_l((item), (loc))


/** Return a string with the data for locale-dependent parameter ITEM */
LIB_FUNC const char* nl_langinfo(const nl_item item) {
	return __nl_langinfo_l(item, __global_locale);
}
#define __nl_langinfo(item)   nl_langinfo((item))


LIB_FUNC const char* get_codeset(void) {
	if (lc_ctype == CT_UTF8) { return "UTF-8"; }
	else { return "ISO-8859-1"; }
	const char* s = getenv("LC_CTYPE");
	if (!s) { return getenv("LC_ALL"); }
	return s;
}


LIB_FUNC const char* nl_langinfo_fast(nl_item x) {
	if (x >= DAY_1 && x <= DAY_7) { return weekdays[x - DAY_1]; }
	else if (x >= ABDAY_1 && x <= ABDAY_7) { return sweekdays[x - ABDAY_1]; }
	else if (x >= MON_1 && x <= MON_12) { return months[x - MON_1]; }
	else if (x >= ABMON_1 && x <= ABMON_12) { return smonths[x - ABMON_1]; }
	switch (x) {
		case CODESET: return get_codeset();
		case D_T_FMT: return "%b %a %d %k:%M:%S %Z %Y";
		case D_FMT: return "%b %a %d";
		case T_FMT: return "%H:%M";
		case T_FMT_AMPM: return "%I:%M:%S %p";
		case AM_STR: return "am";
		case PM_STR: return "pm";
		case ERA: return 0;
		case ERA_D_FMT:
		case ERA_D_T_FMT:
		case ERA_T_FMT:
		case ALT_DIGITS: return "";
		case RADIXCHAR: return ".";
		case THOUSEP: return "";
		case YESEXPR: return "^[yY]";
		case NOEXPR: return "^[nN]";
		case CRNCYSTR: return "$";
		default: return NULL;
	}
	UNREACHABLE
}


#endif  // NL_TYPES_H


/* MONETARY VALUE FORMATTING FUNCTIONS (<monetary.h>) */


#if (!(defined(_MONETARY_H) || defined(_MONETARY_H_) || defined(_LMONETARY_H_) || defined(_XLOCALE__MONETARY_H_)))
#define MONETARY_H   (1)
#define _MONETARY_H   (1)
#define _MONETARY_H_   (1)
#define _LMONETARY_H_   (1)
#define _XLOCALE__MONETARY_H_   (1)
#define _XLOCALE_MONETARY_H_   (1)


static const UNUSED uint32_t conversion_rate[2] = { 1, 1 };
static const UNUSED char numempty[2] = { CHAR_MAX, '\0'};


typedef struct lc_monetary_T {
	const char* int_curr_symbol;
	const char* currency_symbol;
	const char* mon_decimal_point;
	const char* mon_thousands_sep;
	const char* mon_grouping;
	const char* positive_sign;
	const char* negative_sign;
	const char* int_frac_digits;
	const char* frac_digits;
	const char* p_cs_precedes;
	const char* p_sep_by_space;
	const char* n_cs_precedes;
	const char* n_sep_by_space;
	const char* p_sign_posn;
	const char* n_sign_posn;
#   ifdef __HAVE_LOCALE_INFO_EXTENDED__
	const char* int_p_cs_precedes;
	const char* int_p_sep_by_space;
	const char* int_n_cs_precedes;
	const char* int_n_sep_by_space;
	const char* int_p_sign_posn;
	const char* int_n_sign_posn;
	const char* codeset;  // Codeset for mbtowc conversion
	const wchar_t* wint_curr_symbol;
	const wchar_t* wcurrency_symbol;
	const wchar_t* wmon_decimal_point;
	const wchar_t* wmon_thousands_sep;
	const wchar_t* wpositive_sign;
	const wchar_t* wnegative_sign;
#   endif
} lc_monetary_T;


/** The real definition of the struct for the LC_MONETARY locale */
typedef struct attr_packed locale_monetary_t {
	const char* int_curr_symbol;
	const char* currency_symbol;
	const char* mon_decimal_point;
	const char* mon_thousands_sep;
	uint32_t mon_decimal_point_wc, mon_thousands_sep_wc;
	char* mon_grouping;
	size_t mon_grouping_len;
	const char* positive_sign;
	const char* negative_sign;
	signed char int_frac_digits, frac_digits;
	signed char p_cs_precedes, p_sep_by_space;
	signed char n_cs_precedes, n_sep_by_space;
	signed char p_sign_posn, n_sign_posn;
	signed char int_p_cs_precedes, int_p_sep_by_space;
	signed char int_n_cs_precedes, int_n_sep_by_space;
	signed char int_p_sign_posn, int_n_sign_posn;
	const char* duo_int_curr_symbol;
	const char* duo_currency_symbol;
	signed char duo_int_frac_digits, duo_frac_digits;
	signed char duo_p_cs_precedes, duo_p_sep_by_space;
	signed char duo_n_cs_precedes, duo_n_sep_by_space;
	signed char duo_p_sign_posn, duo_n_sign_posn;
	signed char duo_int_p_cs_precedes, duo_int_p_sep_by_space;
	signed char duo_int_n_cs_precedes, duo_int_n_sep_by_space;
	signed char duo_int_p_sign_posn, duo_int_n_sign_posn;
	uint32_t uno_valid_from, uno_valid_to, duo_valid_from, duo_valid_to;
	uint32_t conversion_rate[2];
	char* crncystr;
} locale_monetary_t;


#define LCMONETARY_SIZE_FULL   (sizeof(struct lc_monetary_T) / SIZEOF_POINTER)
#define LCMONETARY_SIZE_MIN   (offsetof(struct lc_monetary_T, int_p_cs_precedes) / SIZEOF_POINTER)
/** The content iof the field int_curr_symbol has to be taken from ISO-4217 */
#define DEFINE_INT_CURR(str)   str,


static const UNUSED char* const valid_int_curr[] = {
#   include "./iso-4217.def"
};
#define NR_VALID_INT_CURR   ((sizeof(valid_int_curr) / sizeof(valid_int_curr[0])))


static const UNUSED struct lc_monetary_T _C_monetary_locale = {
	empty,  // int_curr_symbol
	empty,  // currency_symbol
	empty,  // mon_decimal_point
	empty,  // mon_thousands_sep
	empty,  // mon_grouping
	empty,  // positive_sign
	empty,  // negative_sign
	empty,  // int_frac_digits
	empty,  // frac_digits
	empty,  // p_cs_precedes
	empty,  // p_sep_by_space
	empty,  // n_cs_precedes
	empty,  // n_sep_by_space
	empty,  // p_sign_posn
	empty,  // n_sign_posn
#   ifdef __HAVE_LOCALE_INFO_EXTENDED__
	empty,  // int_p_cs_precedes
	empty,  // int_n_cs_precedes
	empty,  // int_p_sep_by_space
	empty,  // int_n_sep_by_space
	empty,  // int_p_sign_posn
	empty,  // int_n_sign_posn
	empty,  // codeset
	wempty,  // wint_curr_symbol
	wempty,  // wcurrency_symbol
	wempty,  // wmon_decimal_point
	wempty,  // wmon_thousands_sep
	wempty,  // wpositive_sign
	wempty  // wnegative_sign
#   endif
};


LIB_FUNC char cnv(const char* restrict _str) {
	register int i = (int)atoi(_str);
	if (i == -1) { i = CHAR_MAX; }
	return (char)i;
}


LIB_FUNC int curr_strcmp(const char* restrict s1, const char** s2) {
	return strcmp(s1, *s2);
}


/* TODO: Add monetary functions
// Formatting a monetary value according to the current locale
ssize_t strfmon(char *restrict __s, size_t __maxsize, const char *restrict __format, ...) __attribute_format_strfmon__(3, 4);
// Formatting a monetary value according to the current locale
ssize_t strfmon_l(char *restrict __s, size_t __maxsize, __locale_t __loc, const char *restrict __format, ...) __attribute_format_strfmon__ (4, 5);
ssize_t __vstrfmon_l(char *s, size_t maxsize, __locale_t loc, const char *format, va_list ap);
const char * __fix_locale_grouping_str(const char *);
struct lc_monetary_T* __get_current_monetary_locale(locale_t);
int __monetary_load_locale(const char *, locale_t);

static void monetary_startup(struct linereader* lr, struct localedef_t* locale, int ignore_content) {
	if (!ignore_content) {
		struct locale_monetary_t *monetary;
		locale->categories[LC_MONETARY].monetary = monetary = (struct locale_monetary_t *) xmalloc (sizeof (*monetary));
		memset(monetary, '\0', sizeof (struct locale_monetary_t));
		monetary->mon_grouping = NULL;
		monetary->mon_grouping_len = 0;
		monetary->int_frac_digits = -2;
		monetary->frac_digits = -2;
		monetary->p_cs_precedes = -2;
		monetary->p_sep_by_space = -2;
		monetary->n_cs_precedes = -2;
		monetary->n_sep_by_space = -2;
		monetary->p_sign_posn = -2;
		monetary->n_sign_posn = -2;
		monetary->int_p_cs_precedes = -2;
		monetary->int_p_sep_by_space = -2;
		monetary->int_n_cs_precedes = -2;
		monetary->int_n_sep_by_space = -2;
		monetary->int_p_sign_posn = -2;
		monetary->int_n_sign_posn = -2;
		monetary->duo_int_frac_digits = -2;
		monetary->duo_frac_digits = -2;
		monetary->duo_p_cs_precedes = -2;
		monetary->duo_p_sep_by_space = -2;
		monetary->duo_n_cs_precedes = -2;
		monetary->duo_n_sep_by_space = -2;
		monetary->duo_p_sign_posn = -2;
		monetary->duo_n_sign_posn = -2;
		monetary->duo_int_p_cs_precedes = -2;
		monetary->duo_int_p_sep_by_space = -2;
		monetary->duo_int_n_cs_precedes = -2;
		monetary->duo_int_n_sep_by_space = -2;
		monetary->duo_int_p_sign_posn = -2;
		monetary->duo_int_n_sign_posn = -2;
	}
	if (lr != NULL) {
		lr->translate_strings = 1;
		lr->return_widestr = 0;
	}
}

*/


#endif  // MONETARY_H


/* ATOMIC OPERATIONS (<stdatomic.h> & <atomic.h>) */


#if (!(defined(_ATOMIC_H) || defined(_ATOMIC_H_) || defined(__ASM_GENERIC_ATOMIC_H) || defined(_BITS_ATOMIC_H) || defined(_BITS_ATOMIC_H_) || defined(BITS_ATOMIC_H) || defined(_STDATOMIC_H) || defined(_STDATOMIC_H_) || defined(__CLANG_STDATOMIC_H) || defined(__CLANG_STDATOMIC_H_)))  // http://en.cppreference.com/w/c/atomic & http://www.cplusplus.com/reference/atomic/
#define ATOMIC_H   (1)
#define _ATOMIC_H   (1)
#define _ATOMIC_H_   (1)
#define _ATOMIC_MACHINE_H   (1)
#define __ASM_GENERIC_ATOMIC_H   (1)
#define _ASM_GENERIC_ATOMIC_H   (1)
#define _ASM_GENERIC_ATOMIC_H_   (1)
#define __ASM_GENERIC_ATOMIC64_H   (1)
#define _ASM_GENERIC_ATOMIC64_H   (1)
#define _ASM_GENERIC_ATOMIC64_H_   (1)
#define LIBATOMIC_H   (1)
#define _LIBATOMIC_H   (1)
#define _LIBATOMIC_H_   (1)
#define BITS_ATOMIC_H   (1)
#define _BITS_ATOMIC_H   (1)
#define _BITS_ATOMIC_H_   (1)
#define _STDATOMIC_H   (1)
#define __STDATOMIC_H   (1)
#define _STDATOMIC_H_   (1)
#define __CLANG_STDATOMIC_H   (1)
#define __CLANG_STDATOMIC_H_   (1)
#define _OS_OSATOMIC_H   (1)
#define _OS_OSATOMIC_H_   (1)
#define _I386_ATOMIC_H   (1)
#define _I386_ATOMIC_H_   (1)
#undef __NEED__Atomic
#undef NEED__Atomic


#if ATOMIC_DEBUG
#   define ALIGN_TEST(p, t)   do { if ((uintptr_t)p & (sizeof(t) - 1)) { panic("Unaligned atomic pointer %p!\n", p); } } while (0x0)
#else
#   define ALIGN_TEST(p, t)
#endif
#ifndef __ATOMIC_RELAXED
#   define __ATOMIC_RELAXED   0
#endif
#ifndef ATOMIC_RELAXED
#   define ATOMIC_RELAXED   __ATOMIC_RELAXED
#endif
#ifndef __ATOMIC_CONSUME
#   define __ATOMIC_CONSUME   1
#endif
#ifndef ATOMIC_CONSUME
#   define ATOMIC_CONSUME   __ATOMIC_CONSUME
#endif
#ifndef __ATOMIC_ACQUIRE
#   define __ATOMIC_ACQUIRE   2
#endif
#ifndef ATOMIC_ACQUIRE
#   define ATOMIC_ACQUIRE   __ATOMIC_ACQUIRE
#endif
#ifndef __ATOMIC_RELEASE
#   define __ATOMIC_RELEASE   3
#endif
#ifndef ATOMIC_RELEASE
#   define ATOMIC_RELEASE   __ATOMIC_RELEASE
#endif
#ifndef __ATOMIC_ACQ_REL
#   define __ATOMIC_ACQ_REL   4
#endif
#ifndef ATOMIC_ACQ_REL
#   define ATOMIC_ACQ_REL   __ATOMIC_ACQ_REL
#endif
#ifndef __ATOMIC_SEQ_CST
#   define __ATOMIC_SEQ_CST   5
#endif
#ifndef ATOMIC_SEQ_CST
#   define ATOMIC_SEQ_CST   __ATOMIC_SEQ_CST
#endif
#ifndef __ATOMIC_HLE_ACQUIRE
/** Start lock elision on a lock variable; Memory order must be __ATOMIC_ACQUIRE or stronger */
#   define __ATOMIC_HLE_ACQUIRE   65536
#endif
#ifndef ATOMIC_HLE_ACQUIRE
/** Start lock elision on a lock variable; Memory order must be __ATOMIC_ACQUIRE or stronger */
#   define ATOMIC_HLE_ACQUIRE   __ATOMIC_HLE_ACQUIRE
#endif
#ifndef __ATOMIC_HLE_RELEASE
/** End lock elision on a lock variable; Memory order must be __ATOMIC_RELEASE or stronger */
#   define __ATOMIC_HLE_RELEASE   131072
#endif
#ifndef ATOMIC_HLE_RELEASE
/** End lock elision on a lock variable; Memory order must be __ATOMIC_RELEASE or stronger */
#   define ATOMIC_HLE_RELEASE   __ATOMIC_HLE_RELEASE
#endif
#ifndef PAGE_SIZE
#   define PAGE_SIZE   libc.page_size  // struct libc.page_size
#endif
#ifndef AO_HASH_SIZE
#   define AO_HASH_SIZE   (16)
#endif
#define AO_HASH(x)   (((unsigned long)(x) >> 12) & (AO_HASH_SIZE - 1))

/** Used as an argument to functions that conduct atomic operations to specify how other operations on different threads are synchronized */
typedef enum memory_order_enum {
	memory_order_relaxed = 0,  // ATOMIC_RELAXED
	memory_order_consume = 1,  // ATOMIC_CONSUME
	memory_order_acquire = 2,  // ATOMIC_ACQUIRE
	memory_order_release = 3,  // ATOMIC_RELEASE
	memory_order_acq_rel = 4,  // ATOMIC_ACQ_REL
	memory_order_seq_cst = 5  // ATOMIC_SEQ_CST
} memory_order;

#if IS_SMP
#   define memory_order_consume_smp   memory_order_consume
#   define memory_order_acquire_smp   memory_order_acquire
#   define memory_order_release_smp   memory_order_release
#   define memory_order_acq_rel_smp   memory_order_acq_rel
#   define memory_order_seq_cst_smp   memory_order_seq_cst
#else
#   define memory_order_consume_smp   memory_order_relaxed
#   define memory_order_acquire_smp   memory_order_relaxed
#   define memory_order_release_smp   memory_order_relaxed
#   define memory_order_acq_rel_smp   memory_order_relaxed
#   define memory_order_seq_cst_smp   memory_order_relaxed
#endif


/* Indicate that the given atomic-type is lock-free
 - 0 if the types are never lock-free
 - 1 it the types are sometimes lock-free
 - 2 if the types are always lock-free
*/
#if (defined(__GCC_ATOMIC_BOOL_LOCK_FREE) && defined(__GCC_ATOMIC_INT_LOCK_FREE))
#   define ATOMIC_BOOL_LOCK_FREE   __GCC_ATOMIC_BOOL_LOCK_FREE
#   define ATOMIC_CHAR_LOCK_FREE   __GCC_ATOMIC_CHAR_LOCK_FREE
#   define ATOMIC_CHAR16_T_LOCK_FREE   __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#   define ATOMIC_CHAR32_T_LOCK_FREE   __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#   define ATOMIC_WCHAR_T_LOCK_FREE   __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#   define ATOMIC_SHORT_LOCK_FREE   __GCC_ATOMIC_SHORT_LOCK_FREE
#   define ATOMIC_INT_LOCK_FREE   __GCC_ATOMIC_INT_LOCK_FREE
#   define ATOMIC_LONG_LOCK_FREE   __GCC_ATOMIC_LONG_LOCK_FREE
#   define ATOMIC_LLONG_LOCK_FREE   __GCC_ATOMIC_LLONG_LOCK_FREE
#   define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
#else
#   define ATOMIC_BOOL_LOCK_FREE   2
#   define ATOMIC_CHAR_LOCK_FREE   2
#   define ATOMIC_CHAR16_T_LOCK_FREE   2
#   define ATOMIC_CHAR32_T_LOCK_FREE   2
#   define ATOMIC_WCHAR_T_LOCK_FREE   2
#   define ATOMIC_SHORT_LOCK_FREE   2
#   define ATOMIC_INT_LOCK_FREE   2
#   define ATOMIC_LONG_LOCK_FREE   2
#   define ATOMIC_LLONG_LOCK_FREE   2
#   define ATOMIC_POINTER_LOCK_FREE   2
#endif


// ATOMIC DATATYPES

typedef struct atomic_struct { int counter; }   atomic_t;
typedef struct atomicl_struct { long counter; }    atomic_long_t;
typedef struct atomicll_struct { long long counter; }    atomic_long_long_t;
typedef Atomic int32_t    atomic32_t;
typedef Atomic int64_t    atomic64_t;
#if IS_CPLUSPLUS
typedef Atomic bool   atomic_bool;
#else
typedef Atomic _Bool   atomic_bool;
#endif
#define abool   atomic_bool
typedef Atomic char   atomic_char;
typedef Atomic signed char   atomic_schar;
typedef Atomic unsigned char   atomic_uchar;
#define achar   atomic_char
#define aschar   atomic_schar
#define auchar   atomic_uchar
typedef Atomic __WINT_TYPE__   atomic_wint_t;
#define awint_t   atomic_wint_t
typedef Atomic __WCHAR_TYPE__   atomic_wchar_t;
#define awchar_t   atomic_wchar_t
typedef Atomic __CHAR16_TYPE__   atomic_char16_t;
#define achar16_t   atomic_char16_t
typedef Atomic __CHAR32_TYPE__   atomic_char32_t;
#define achar32_t   atomic_char32_t
typedef Atomic short   atomic_short;
typedef Atomic unsigned short   atomic_ushort;
#define ashort   atomic_short
#define aushort   atomic_ushort
typedef Atomic int   atomic_int;
typedef Atomic unsigned int   atomic_uint;
#define aint   atomic_int
#define auint   atomic_uint
typedef Atomic long   atomic_long;
typedef Atomic unsigned long   atomic_ulong;
#define along   atomic_long
#define aulong   atomic_ulong
typedef Atomic long long   atomic_llong;
typedef Atomic unsigned long long   atomic_ullong;
#define allong   atomic_llong
#define aullong   atomic_ullong
#define alonglong   atomic_llong
#define aulonglong   atomic_ullong
typedef Atomic float   atomic_float;
#define afloat   atomic_float
typedef Atomic double   atomic_double;
#define adouble   atomic_double
#if SUPPORTS_LONG_DOUBLE
typedef Atomic long double   atomic_long_double;
#   define aldouble   atomic_long_double
#   define alongdouble   atomic_long_double
#   define atomic_ldouble   atomic_long_double
#endif
#if SUPPORTS_FLOAT128
typedef Atomic float128   atomic_float128;
#   define afloat128   atomic_float128
#   define afloat128_t   atomic_float128
#endif
#if SUPPORTS_DECIMAL_FLOATS
typedef Atomic decimal32   atomic_decimal32;
#   define adecimal32   atomic_decimal32
#   define adecimal32_t   atomic_decimal32
typedef Atomic decimal64   atomic_decimal64;
#   define adecimal64   atomic_decimal64
#   define adecimal64_t   atomic_decimal64
#endif
#if SUPPORTS_DECIMAL_LONG_DOUBLE
typedef Atomic decimal128   atomic_decimal128;
#   define adecimal128   atomic_decimal128
#   define adecimal128_t   atomic_decimal128
#endif
#if SUPPORTS_COMPLEX
typedef Atomic float_complex   atomic_float_complex;
#   define afloat_complex   atomic_float_complex
#   define afloat_complex_t   atomic_float_complex
typedef Atomic double_complex   atomic_double_complex;
#   define adouble_complex   atomic_double_complex
#   define adouble_complex_t   atomic_double_complex
#   if SUPPORTS_LONG_DOUBLE
typedef Atomic long_double_complex   atomic_long_double_complex;
#      define aldouble_complex   atomic_long_double_complex
#      define aldouble_complex_t   atomic_long_double_complex
#   endif
#endif
typedef Atomic int8_t   atomic_int8_t;
typedef Atomic uint8_t   atomic_uint8_t;
typedef Atomic int16_t   atomic_int16_t;
typedef Atomic uint16_t   atomic_uint16_t;
typedef Atomic int32_t   atomic_int32_t;
typedef Atomic uint32_t   atomic_uint32_t;
typedef Atomic int64_t   atomic_int64_t;
typedef Atomic uint64_t   atomic_uint64_t;
#define aint8_t   atomic_int8_t
#define auint8_t   atomic_uint8_t
#define aint16_t   atomic_int16_t
#define auint16_t   atomic_uint16_t
#define aint32_t   atomic_int32_t
#define auint32_t   atomic_uint32_t
#define aint64_t   atomic_int64_t
#define auint64_t   atomic_uint64_t
#define atomic8_t   atomic_int8_t
#define uatomic8_t   atomic_uint8_t
#define atomic16_t   atomic_int16_t
#define uatomic16_t   atomic_uint16_t
#define atomic32_t   atomic_int32_t
#define uatomic32_t   atomic_uint32_t
#define atomic64_t   atomic_int64_t
#define uatomic64_t   atomic_uint64_t
#if (SIZEOF_LONG == 4)
#   define memusage_cntr_t   uatomic32_t
#   define memusage_size_t   uatomic32_t
#else
#   define memusage_cntr_t   uatomic64_t
#   define memusage_size_t   uatomic64_t
#endif
typedef Atomic __INT_LEAST8_TYPE__   atomic_int_least8_t;
typedef Atomic __UINT_LEAST8_TYPE__   atomic_uint_least8_t;
typedef Atomic __INT_LEAST16_TYPE__   atomic_int_least16_t;
typedef Atomic __UINT_LEAST16_TYPE__   atomic_uint_least16_t;
typedef Atomic __INT_LEAST32_TYPE__   atomic_int_least32_t;
typedef Atomic __UINT_LEAST32_TYPE__   atomic_uint_least32_t;
typedef Atomic __INT_LEAST64_TYPE__   atomic_int_least64_t;
typedef Atomic __UINT_LEAST64_TYPE__   atomic_uint_least64_t;
#define aleast8_t   atomic_int_least8_t
#define auleast8_t   atomic_uint_least8_t
#define aleast16_t   atomic_int_least16_t
#define auleast16_t   atomic_uint_least16_t
#define aleast32_t   atomic_int_least32_t
#define auleast32_t   atomic_uint_least32_t
#define aleast64_t   atomic_int_least64_t
#define auleast64_t   atomic_uint_least64_t
#define atomic_least8_t   atomic_int_least8_t
#define uatomic_least8_t   atomic_uint_least8_t
#define atomic_least16_t   atomic_int_least16_t
#define uatomic_least16_t   atomic_uint_least16_t
#define atomic_least32_t   atomic_int_least32_t
#define uatomic_least32_t   atomic_uint_least32_t
#define atomic_least64_t   atomic_int_least64_t
#define uatomic_least64_t   atomic_uint_least64_t
typedef Atomic __INT_FAST8_TYPE__   atomic_int_fast8_t;
typedef Atomic __UINT_FAST8_TYPE__   atomic_uint_fast8_t;
typedef Atomic __INT_FAST16_TYPE__   atomic_int_fast16_t;
typedef Atomic __UINT_FAST16_TYPE__   atomic_uint_fast16_t;
typedef Atomic __INT_FAST32_TYPE__   atomic_int_fast32_t;
typedef Atomic __UINT_FAST32_TYPE__   atomic_uint_fast32_t;
typedef Atomic __INT_FAST64_TYPE__   atomic_int_fast64_t;
typedef Atomic __UINT_FAST64_TYPE__   atomic_uint_fast64_t;
#define afast8_t   atomic_int_fast8_t
#define aufast8_t   atomic_uint_fast8_t
#define afast16_t   atomic_int_fast16_t
#define aufast16_t   atomic_uint_fast16_t
#define afast32_t   atomic_int_fast32_t
#define aufast32_t   atomic_uint_fast32_t
#define afast64_t   atomic_int_fast64_t
#define aufast64_t   atomic_uint_fast64_t
#define atomic_fast8_t   atomic_int_fast8_t
#define uatomic_fast8_t   atomic_uint_fast8_t
#define atomic_fast16_t   atomic_int_fast16_t
#define uatomic_fast16_t   atomic_uint_fast16_t
#define atomic_fast32_t   atomic_int_fast32_t
#define uatomic_fast32_t   atomic_uint_fast32_t
#define atomic_fast64_t   atomic_int_fast64_t
#define uatomic_fast64_t   atomic_uint_fast64_t
#ifdef __INTPTR_TYPE__
typedef Atomic __INTPTR_TYPE__   atomic_intptr_t;
#else
typedef Atomic intptr_t   atomic_intptr_t;
#endif
#ifndef atomicptr_t
#   define atomicptr_t   atomic_intptr_t
#endif
#define aintptr_t   atomic_intptr_t
#ifdef __UINTPTR_TYPE__
typedef Atomic __UINTPTR_TYPE__   atomic_uintptr_t;
#else
typedef Atomic uintptr_t   atomic_uintptr_t;
#endif
#ifndef uatomicptr_t
#   define uatomicptr_t   atomic_uintptr_t
#endif
#define auintptr_t   atomic_uintptr_t
#ifdef __PTRDIFF_TYPE__
typedef Atomic __PTRDIFF_TYPE__   atomic_ptrdiff_t;
#else
typedef Atomic ptrdiff_t   atomic_ptrdiff_t;
#endif
#define aptrdiff_t   atomic_ptrdiff_t
#ifdef __SIZE_TYPE__
typedef Atomic __SIZE_TYPE__   atomic_size_t;
#else
typedef Atomic size_t   atomic_size_t;
#endif
#define asize_t   atomic_size_t
#ifdef __SSIZE_TYPE__
typedef Atomic __SSIZE_TYPE__   atomic_ssize_t;
#else
typedef Atomic ssize_t   atomic_ssize_t;
#endif
#define assize_t   atomic_ssize_t
#ifdef __INTMAX_TYPE__
typedef Atomic __INTMAX_TYPE__   atomic_intmax_t;
#else
typedef Atomic intmax_t   atomic_intmax_t;
#endif
#define atomic_max_t   atomic_intmax_t
#define aintmax_t   atomic_intmax_t
#ifdef __UINTMAX_TYPE__
typedef Atomic __UINTMAX_TYPE__   atomic_uintmax_t;
#else
typedef Atomic uintmax_t   atomic_uintmax_t;
#endif
#define uatomic_max_t   atomic_uintmax_t
#define auintmax_t   atomic_uintmax_t
// STDFIX ATOMIC DATATYPES
#if SUPPORTS_STDFIX
typedef Atomic _Accum   atomic_accum_t;
typedef Atomic _Fract   atomic_fract_t;
typedef Atomic fx_t   atomic_fx_t;
typedef Atomic satfx_t   atomic_satfx_t;
typedef Atomic fx_hr_t   atomic_fx_hr_t;
typedef Atomic fx_r_t   atomic_fx_r_t;
typedef Atomic fx_lr_t   atomic_fx_lr_t;
typedef Atomic fx_llr_t   atomic_fx_llr_t;
typedef Atomic fx_uhr_t   atomic_fx_uhr_t;
typedef Atomic fx_ur_t   atomic_fx_ur_t;
typedef Atomic fx_ulr_t   atomic_fx_ulr_t;
typedef Atomic fx_ullr_t   atomic_fx_ullr_t;
typedef Atomic fx_hk_t   atomic_fx_hk_t;
typedef Atomic fx_k_t   atomic_fx_k_t;
typedef Atomic fx_lk_t   atomic_fx_lk_t;
typedef Atomic fx_llk_t   atomic_fx_llk_t;
typedef Atomic fx_uhk_t   atomic_fx_uhk_t;
typedef Atomic fx_uk_t   atomic_fx_uk_t;
typedef Atomic fx_ulk_t   atomic_fx_ulk_t;
typedef Atomic fx_ullk_t   atomic_fx_ullk_t;
#endif
// SPECIAL ATOMIC DATATYPES
typedef Atomic struct atomic_flag_struct { atomic_bool __val; }   atomic_flag;
typedef Atomic imaxdiv_t   atomic_imaxdiv_t;
#define aimaxdiv   atomic_imaxdiv_t
#define atomic_imaxdiv   atomic_imaxdiv_t
typedef Atomic sig_atomic_t   atomic_sig_atomic_t;
#define asig_atomic_t   atomic_sig_atomic_t
typedef Atomic mach_port_t   atomic_mach_port_t;
#define amach_port_t   atomic_mach_port_t
typedef Atomic clock_t   atomic_clock_t;
#define aclock_t   atomic_clock_t
typedef Atomic clockid_t   atomic_clockid_t;
#define aclockid_t   atomic_clockid_t
typedef Atomic time_t   atomic_time_t;
#define atime_t   atomic_time_t
typedef Atomic timer_t   atomic_timer_t;
#define atimer_t   atomic_timer_t
typedef Atomic suseconds_t   atomic_suseconds_t;
#define asuseconds_t   atomic_suseconds_t
typedef Atomic useconds_t   atomic_useconds_t;
#define auseconds_t   atomic_useconds_t
typedef Atomic timeval_t   atomic_timeval_t;
#define atimeval_t   atomic_timeval_t
typedef Atomic timeval32_t   atomic_timeval32_t;
#define atimeval32_t   atomic_timeval32_t
typedef Atomic timeval64_t   atomic_timeval64_t;
#define atimeval64_t   atomic_timeval64_t
typedef Atomic id_t   atomic_id_t;
#define aid_t   atomic_id_t
typedef Atomic pid_t   atomic_pid_t;
#define apid_t   atomic_pid_t
typedef Atomic gid_t   atomic_gid_t;
#define agid_t   atomic_gid_t
typedef Atomic uid_t   atomic_uid_t;
#define auid_t   atomic_uid_t
typedef Atomic dev_t   atomic_dev_t;
#define adev_t   atomic_dev_t
typedef Atomic blkcnt_t   atomic_blkcnt_t;
#define ablkcnt_t   atomic_blkcnt_t
typedef Atomic blksize_t   atomic_blksize_t;
#define ablksize_t   atomic_blksize_t
typedef Atomic fsblkcnt_t   atomic_fsblkcnt_t;
#define afsblkcnt_t   atomic_fsblkcnt_t
typedef Atomic fsfilcnt_t   atomic_fsfilcnt_t;
#define afsfilcnt_t   atomic_fsfilcnt_t
typedef Atomic off_t   atomic_off_t;
#define aoff_t   atomic_off_t
typedef Atomic ino_t   atomic_ino_t;
#define aino_t   atomic_ino_t
typedef Atomic ino64_t   atomic_ino64_t;
#define aino64_t   atomic_ino64_t
typedef Atomic mode_t   atomic_mode_t;
#define amode_t   atomic_mode_t
typedef Atomic sigset_t   atomic_sigset_t;
#define asigset_t   atomic_sigset_t
typedef Atomic slint   atomic_slint;
#define aslint   atomic_slint
typedef Atomic sllint   atomic_sllint;
#define asllint   atomic_sllint
typedef Atomic ulint   atomic_ulint;
#define aulint   atomic_ulint
typedef Atomic ullint   atomic_ullint;
#define aullint   atomic_ullint


// MISCELLANEOUS ATOMIC DATATYPES & CONSTANTS

static volatile UNUSED int vmlock[2] = { 0, 0 };

static const UNUSED char debruijn32[32] = {
	0, 1, 23, 2, 29, 24, 19, 3, 30, 27, 25, 11, 20, 8, 4, 13, 31, 22, 28, 18, 26, 10, 7, 12, 21, 17, 9, 6, 16, 5, 15, 14
};

static const UNUSED char debruijn64[64] = {
	0, 1, 2, 53, 3, 7, 54, 27, 4, 38, 41, 8, 34, 55, 48, 28, 62, 5, 39, 46, 44, 42, 22, 9, 24, 35, 59, 56, 49, 18, 29, 11, 63, 52, 6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10, 51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
};


// ATOMIC FUNCTIONS

#ifdef __GNUC__
/** Breaks a dependency chain for memory_order_consume */
#   define kill_dependency(x)   do { auto_type __kill_dependency_tmp = (x); __kill_dependency_tmp; } while (0x0)
#endif


LIB_FUNC size_t __CAS(size_t* ptr, const size_t oldval, const size_t newval) {
	if (*ptr == oldval) {
		*ptr = newval;
		return oldval;
	} else { return *ptr; }
	UNREACHABLE
}


LIB_FUNC size_t __atomic_add(size_t* ptr, const size_t val) {
	register size_t r, o;
	do { r = __CAS(ptr, (size_t)(o = *ptr), (size_t)(*ptr + val)); } while (r != o);
	return r;
}


#define ATOMIC_OP(op, c_op) \
LIB_FUNC void atomic_##op(int i, atomic_t* v) { \
	int c = v->counter, old; \
	while ((old = (int)cmpxchg(&v->counter, c, (c c_op i))) != c) { c = old; } \
}


#define ATOMIC_OP_RETURN(op, c_op) \
LIB_FUNC int atomic_##op##_return(int i, atomic_t* v) { \
	int c = v->counter, old; \
	while ((old = (int)cmpxchg(&v->counter, c, (c c_op i))) != c) { c = old; } \
	return (int)(c c_op i); \
}


#ifndef atomic_add_return
ATOMIC_OP_RETURN(add, +)
#endif
#ifndef atomic_sub_return
ATOMIC_OP_RETURN(sub, -)
#endif
#ifndef atomic_clear_mask
ATOMIC_OP(and, &)
#   define atomic_clear_mask(i, v)   atomic_and((~(i)), (v))
#endif
#ifndef atomic_set_mask
#   define CONFIG_ARCH_HAS_ATOMIC_OR
ATOMIC_OP(or, |)
#   define atomic_set_mask(i, v)   atomic_or((i), (v))
#endif


/** Memory barrier */
LIB_FUNC void do_sync(void) {
#   if (defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__))
asm volatile ("dmb;" : : : "memory");
#   elif (defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__))
asm volatile ("mcr p15, 0, %0, c7, c10, 5;" : : "r"(0) : "memory");
#   elif (defined(I386) || defined(X86_64))
asm volatile("mfence;" : : : "memory");
#   else
asm volatile (";" : : : "memory");
#   endif
}


#ifndef OSMemoryBarrier
#   define OSMemoryBarrier()   do_sync()
#endif
#ifndef atomic_full_barrier
/** Atomic barrier macro */
#   define atomic_full_barrier()   asm volatile (";" : : : "memory")
#endif
#ifndef atomic_read_barrier
#   define atomic_read_barrier()   atomic_full_barrier()
#endif
#ifndef atomic_write_barrier
#   define atomic_write_barrier()   atomic_full_barrier()
#endif
#ifndef atomic_forced_read
#   define atomic_forced_read(x)   do { typeof(x) __x; asm volatile (";" : "=r"(__x) : "0"(x)); __x; } while (0x0)
#endif
#ifndef atomic_delay
#   define atomic_delay()
#endif
#define barrier()   asm volatile (";" : : : "memory")
#define barrier_data(ptr)   asm volatile (";" : : "r"(ptr) : "memory")
#define xchg(a, b, type)   type t; t = a; a = b; b = t


/** Compare and exchange value */
#define atomic_compare_and_exchange_val_acq(mem, newval, oldval)   __extension__ ({ typeof(mem) __gmemp = (mem); typeof(*mem) __gret = *__gmemp; typeof(*mem) __gnewval = (newval); if (__gret == (oldval)) { *__gmemp = __gnewval; } __gret; })
/** Compare and exchange boolean */
#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval)   __extension__ ({ typeof(mem) __gmemp = (mem); typeof(*mem) __gnewval = (newval); *__gmemp == (oldval) ? (*__gmemp = __gnewval, 0) : 1; })


#ifdef X86_64


LIB_FUNC uint32_t cmpxchg(int* ptr, const int _old, const int _new) {
	volatile uint32_t* __ptr = (volatile uint32_t*)(ptr);
	uint32_t __ret;
	asm volatile ("lock;" "cmpxchgl %2, %1;" : "=a"(__ret), "+m"(*__ptr)  : "r"(_new), "0"(_old) : "memory");
	return __ret;
}

LIB_FUNC int a_cas(volatile int* p, int t, int s) {
	asm volatile ("lock;" "cmpxchg %3, %1;" : "=a"(t), "=m"(*p) : "a"(t), "r"(s) : "memory");
	return t;
}

LIB_FUNC void* a_cas_p(volatile void* p, void* t, void* s) {
	asm ("lock;" "cmpxchg %3, %1;" : "=a"(t), "=m"(*(void* volatile*)p) : "a"(t), "r"(s) : "memory");
	return t;
}

LIB_FUNC int a_swap(volatile int* p, int v) {
	asm volatile ("xchg %0, %1;" : "=r"(v), "=m"(*p) : "0"(v) : "memory");
	return v;
}

LIB_FUNC int a_fetch_add(volatile int* p, int v) {
	asm volatile ("lock;" "xadd %0, %1;" : "=r"(v), "=m"(*p) : "0"(v) : "memory");
	return v;
}

LIB_FUNC void a_and(volatile int* p, int v) {
	asm volatile ("lock;" "and %1, %0;" : "=m"(*p) : "r"(v) : "memory");
}

LIB_FUNC void a_or(volatile int* p, int v) {
	asm volatile ("lock;" "or %1, %0;" : "=m"(*p) : "r"(v) : "memory");
}

LIB_FUNC void a_and_64(volatile uint64_t* p, uint64_t v) {
	asm volatile ("lock;" "and %1, %0;" : "=m"(*p) : "r"(v) : "memory");
}

LIB_FUNC void a_or_64(volatile uint64_t* p, uint64_t v) {
	asm volatile ("lock;" "or %1, %0;" : "=m"(*p) : "r"(v) : "memory");
}

LIB_FUNC void a_inc(volatile int* p) {
	asm volatile ("lock;" "incl %0;" : "=m"(*p) : "m"(*p) : "memory");
}

LIB_FUNC void a_dec(volatile int* p) {
	asm volatile ("lock;" "decl %0;" : "=m"(*p) : "m"(*p) : "memory");
}

LIB_FUNC void a_store(volatile int* p, int x) {
	asm volatile ("mov %1, %0;" "lock;" "orl $0, (%%rsp);" : "=m"(*p) : "r"(x) : "memory");
}

LIB_FUNC void a_barrier(void) { asm volatile (";" : : : "memory"); }

LIB_FUNC void a_spin(void) { asm volatile ("pause;" : : : "memory"); }

LIB_FUNC void a_crash(void) { asm volatile ("hlt;" : : : "memory"); }

LIB_FUNC int a_ctz_64(uint64_t x) {
	asm ("bsf %1, %0;" : "=r"(x) : "r"(x));
	return (int)x;
}

#define a_ctz_l_NEEDED


#elif defined(MIPS)


LIB_FUNC int a_ll(volatile int* p) {
	int v;
	asm volatile (".set push;" ".set mips2;" "ll %0, %1;" ".set pop;" : "=r"(v) : "m"(*p));
	return v;
}

LIB_FUNC int a_sc(volatile int* p, int v) {
	int r;
	asm volatile (".set push;" ".set mips2;" "sc %0, %1;" ".set pop;" : "=r"(r), "=m"(*p) : "0"(v) : "memory");
	return r;
}

LIB_FUNC void a_barrier(void) { asm volatile (".long 0xf;" : : : "memory"); }

#define a_pre_llsc   a_barrier
#define a_post_llsc   a_barrier
#define a_ll_DEFINED
#define a_cas_NEEDED
#define a_swap_NEEDED
#define a_fetch_add_NEEDED
#define a_fetch_and_NEEDED
#define a_fetch_or_NEEDED
#define a_and_NEEDED
#define a_or_NEEDED
#define a_inc_NEEDED
#define a_dec_NEEDED
#define a_store_NEEDED
#define a_spin_NEEDED


#elif defined(ARM)


static const UNUSED void* __arm_atomics[3];

#if (((defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6ZK__)) && (!defined(ARM_THUMB))) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) ||  (__ARM_ARCH >= 7))


#define a_ll_DEFINED
LIB_FUNC int a_ll(volatile int *p) {
	int v;
	asm volatile ("ldrex %0, %1;" : "=r"(v) : "Q"(*p));
	return v;
}


#define a_sc_DEFINED
LIB_FUNC int a_sc(volatile int *p, int v) {
	int r;
	asm volatile ("strex %0, %2, %1;" : "=&r"(r), "=Q"(*p) : "r"(v) : "memory");
	return !r;
}


#if (defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) ||  (__ARM_ARCH >= 7))
#   define a_barrier_DEFINED
LIB_FUNC void a_barrier(void) {
	asm volatile ("dmb ish;" : : : "memory");
}
#endif
#define a_pre_llsc()   a_barrier()
#define a_post_llsc()   a_barrier()
#define a_cas_NEEDED

#else

#define a_cas_DEFINED
LIB_FUNC int a_cas(volatile int *p, int t, int s) {
	for (;;) {
		register int r0 asm ("r0") = t, r1 asm ("r1") = s;
		register volatile int *r2 asm ("r2") = p;
		int old;
		asm volatile ("bl __a_cas;" : "+r"(r0) : "r"(r1), "r"(r2) : "memory", "r3", "lr", "ip", "cc");
		if (!r0) { return t; }
		else if ((old = *p) != t) { return old; }
	}
}

#endif


#ifndef a_barrier_DEFINED
LIB_FUNC void a_barrier(void) {
	asm volatile ("bl __a_barrier;" : : : "memory", "cc", "ip", "lr");
}
#   define a_pre_llsc()   a_barrier()
#   define a_post_llsc()   a_barrier()
#endif


LIB_FUNC void a_crash(void) {
#   ifndef ARM_THUMB
	asm volatile (".word 0xe7f000f0;" : : : "memory");
#   else
	asm volatile (".short 0xdeff;" : : : "memory");
#   endif
}

#define a_swap_NEEDED
#define a_fetch_add_NEEDED
#define a_fetch_and_NEEDED
#define a_fetch_or_NEEDED
#define a_and_NEEDED
#define a_or_NEEDED
#define a_inc_NEEDED
#define a_dec_NEEDED
#define a_store_NEEDED
#define a_spin_NEEDED


#else
#   error   "This library does not support atomic functions for this platform!"
#endif  // ARCH


#ifdef a_ll_DEFINED


#ifdef a_cas_NEEDED
LIB_FUNC int a_cas(volatile int* p, int t, int s) {
	register int old;
	a_pre_llsc();
	do { old = a_ll(p); } while (old == t && !a_sc(p, s));
	a_post_llsc();
	return old;
}
#endif


#ifdef a_swap_NEEDED
LIB_FUNC int a_swap(volatile int* p, int v) {
	register int old;
	a_pre_llsc();
	do { old = a_ll(p); } while (!a_sc(p, v));
	a_post_llsc();
	return old;
}
#endif


#ifdef a_fetch_add_NEEDED
LIB_FUNC int a_fetch_add(volatile int* p, int v) {
	register int old;
	a_pre_llsc();
	do { old = a_ll(p); } while (!a_sc(p, ((unsigned)old + v)));
	a_post_llsc();
	return old;
}
#endif


#ifdef a_fetch_and_NEEDED
LIB_FUNC int a_fetch_and(volatile int* p, int v) {
	register int old;
	a_pre_llsc();
	do { old = a_ll(p); } while (!a_sc(p, (old & v)));
	a_post_llsc();
	return old;
}
#endif


#ifdef a_fetch_or_NEEDED
LIB_FUNC int a_fetch_or(volatile int* p, int v) {
	register int old;
	a_pre_llsc();
	do { old = a_ll(p); } while (!a_sc(p, (old | v)));
	a_post_llsc();
	return old;
}
#endif


#else  // a_ll_DEFINED


#ifdef a_swap_NEEDED
LIB_FUNC int a_swap(volatile int* p, int v) {
	register int old;
	do { old = *p; } while (a_cas(p, old, v) != old);
	return old;
}
#endif


#ifdef a_fetch_add_NEEDED
LIB_FUNC int a_fetch_add(volatile int *p, int v) {
	register int old;
	do { old = *p; } while (a_cas(p, old, ((unsigned)old + v)) != old);
	return old;
}
#endif


#ifdef a_fetch_and_NEEDED
LIB_FUNC int a_fetch_and(volatile int* p, int v) {
	register int old;
	do { old = *p; } while (a_cas(p, old, (old & v)) != old);
	return old;
}
#endif


#ifdef a_fetch_or_NEEDED
LIB_FUNC int a_fetch_or(volatile int* p, int v) {
	register int old;
	do { old = *p; } while (a_cas(p, old, (old | v)) != old);
	return old;
}
#endif


#endif  // a_ll_DEFINED


#ifdef a_and_NEEDED
LIB_FUNC void a_and(volatile int* p, int v) { a_fetch_and(p, v); }
#endif


#ifdef a_or_NEEDED
LIB_FUNC void a_or(volatile int* p, int v) { a_fetch_or(p, v); }
#endif


#ifdef a_inc_NEEDED
LIB_FUNC void a_inc(volatile int* p) { a_fetch_add(p, 1); }
#endif


#ifdef a_dec_NEEDED
LIB_FUNC void a_dec(volatile int* p) { a_fetch_add(p, -1); }
#endif


#ifdef a_store_NEEDED
LIB_FUNC void a_store(volatile int* p, int v) {
#ifdef a_barrier
	a_barrier();
	*p = v;
	a_barrier();
#else
	a_swap(p, v);
#endif
}
#endif


#ifdef a_barrier_NEEDED
static void a_barrier(void) { volatile int tmp = 0; a_cas((&tmp), 0, 0); }
#endif


#ifdef a_spin_NEEDED
#   define a_spin()   a_barrier()
#endif


#ifdef a_and_64_NEEDED
LIB_FUNC void a_and_64(volatile uint64_t* p, uint64_t v) {
	union { uint64_t v; uint32_t r[2]; } u = { v };
	if (u.r[0] + 1) { a_and((int*)p, u.r[0]); }
	if (u.r[1] + 1) { a_and(((int*)p + 1), u.r[1]); }
}
#endif


#ifdef a_or_64_NEEDED
LIB_FUNC void a_or_64(volatile uint64_t* p, uint64_t v) {
	union { uint64_t v; uint32_t r[2]; } u = { v };
	if (u.r[0]) { a_or((int*)p, u.r[0]); }
	if (u.r[1]) { a_or(((int*)p + 1), u.r[1]); }
}
#endif


#ifdef a_cas_p_NEEDED
LIB_FUNC void *a_cas_p(volatile void* p, void* t, void* s) { return (void*)a_cas((volatile int*)p, (int)t, (int)s); }
#endif


#ifdef a_or_l_NEEDED
LIB_FUNC void a_or_l(volatile void* p, long v) {
	if (BYTES_PER_LONG == BYTES_PER_INT) { a_or(p, v); }
	else { a_or_64(p, v); }
}
#endif


#ifdef a_crash_NEEDED
LIB_FUNC void a_crash(void) { *(volatile char*)0 = 0; }
#endif


#ifdef a_ctz_64_NEEDED
LIB_FUNC int a_ctz_64(const uint64_t x) {
	if (SIZEOF_LONG < 8) {
		register uint32_t y = x;
		if (!y) {
			y = x >> 32;
			return (int)(32 + debruijn32[(y & (-y)) * 0x076be629 >> 27]);
		} else { return (int)(debruijn32[(y & (-y)) * 0x076be629 >> 27]); }
	}
	return (int)(debruijn64[(x & (-x)) * 0x022fdd63cc95386dULL >> 58]);
}
#endif


#ifdef a_ctz_l_NEEDED
LIB_FUNC int a_ctz_l(const unsigned long x) {
	if (SIZEOF_LONG == 8) { return a_ctz_64(x); }
	return (int)(debruijn32[(x & (-x)) * 0x076be629 >> 27]);
}
#endif


#define ntz(x)   a_ctz_l((x))


#ifdef COMPILER_CLANG
/** Initializes a new atomic object */
#   define ATOMIC_VAR_INIT(value)   (value)
/** Initializes an existing atomic object */
#   define atomic_init(obj, value)   __c11_atomic_init(obj, value)
/** Generic memory order-dependent fence synchronization primitive */
#   define atomic_thread_fence(order)   __c11_atomic_thread_fence(order)
/** Generic memory order-dependent fence synchronization primitive */
#   define __atomic_thread_fence(order)   atomic_thread_fence(order)
/** Fence between a thread and a signal handler executed in the same thread */
#   define atomic_signal_fence(order)   __c11_atomic_signal_fence(order)
/** Fence between a thread and a signal handler executed in the same thread */
#   define __atomic_signal_fence(order)   atomic_signal_fence(order)
/** Indicates whether the atomic object is lock-free */
#   define atomic_is_lock_free(obj)   __c11_atomic_is_lock_free(sizeof(*(obj)))
/** Indicates whether the atomic object is lock-free */
#   define __atomic_is_lock_free(obj)   atomic_is_lock_free(obj)
/** Atomic addition */
#   define __atomic_fetch_add(PTR, VAL, x)   __c11_atomic_fetch_add((PTR), (VAL), (x))
#else
/** Initializes a new atomic object */
#   define ATOMIC_VAR_INIT(value)   (value)
/** Initializes an existing atomic object */
#   define atomic_init(PTR, VAL)   do { *(PTR) = (VAL); } while (0x0)
/** Initializes an existing atomic object */
#   define __c11_atomic_init(PTR, VAL)   do { *(PTR) = (VAL); } while (0x0)
/** Generic memory order-dependent fence synchronization primitive */
#   define atomic_thread_fence(order)   __atomic_thread_fence(order)
/** Generic memory order-dependent fence synchronization primitive */
#   define __c11_atomic_thread_fence(order)   atomic_thread_fence(order)
/** Fence between a thread and a signal handler executed in the same thread */
#   define atomic_signal_fence(order)   __atomic_signal_fence(order)
/** Fence between a thread and a signal handler executed in the same thread */
#   define __c11_atomic_signal_fence(order)   atomic_signal_fence(order)
/** Indicates whether the atomic object is lock-free */
#   define atomic_is_lock_free(x)   __atomic_is_lock_free(sizeof(*(x)), (x))
/** Indicates whether the atomic object is lock-free */
#   define __c11_atomic_is_lock_free(obj)   atomic_is_lock_free(obj)
/** Atomic addition */
#   define __c11_atomic_fetch_add(PTR, VAL, x)   __atomic_fetch_add((PTR), (VAL), (x))
#endif  // Not Clang
#if (defined(__atomic_bool_compare_swap) && (!defined(__sync_bool_compare_and_swap)))
#   define __sync_bool_compare_and_swap(p, o, n)   __atomic_bool_compare_swap((p), (o), (n))
#endif
#define os_atomic_cmpxchg(p, o, n)   __sync_bool_compare_and_swap((p), (o), (n))
#define compare_and_swap(p, o, n)   __sync_bool_compare_and_swap((p), (o), (n))
#define __compare_and_swap(p, o, n)   __sync_bool_compare_and_swap((p), (o), (n))
#define testandset(p)   !__compare_and_swap((long int*)(p), 0, 1)
#define __testandset(p)   !__compare_and_swap((long int*)(p), 0, 1)
#define atomic_cmpxchg(val, old, new)   (cmpxchg(&((val)->counter), (old), (new)))  // __sync_bool_compare_and_swap((val), (old), (new))
/** Atomically sets the value of @v to @i */
#define atomic_set(v, i)   (((v)->counter) = (i))
/** Initializes an existing atomic object */
#define ATOMIC_INIT(PTR, VAL)   atomic_init((PTR), (VAL))
/** Initializes an existing 64-bit atomic object */
#define ATOMIC64_INIT(i)   { (i) }
/** Initializes a new atomic_flag */
#define ATOMIC_FLAG_INIT   ATOMIC_VAR_INIT(0)
/** Stores a value in an atomic object */
#define atomic_store_explicit(PTR, VAL, order)   do { auto_type __atomic_store_ptr = (PTR); typeof(*__atomic_store_ptr) __atomic_store_tmp = (VAL); __atomic_store(__atomic_store_ptr, &__atomic_store_tmp, (order)); } while (0x0)
/** Stores a value in an atomic object */
#define atomic_store(PTR, VAL)   atomic_store_explicit((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Reads a value from an atomic object */
#define atomic_load_explicit(PTR, order)   do { auto_type __atomic_load_ptr = (PTR); typeof(*__atomic_load_ptr) __atomic_load_tmp; __atomic_load(__atomic_load_ptr, &__atomic_load_tmp, (order)); __atomic_load_tmp; } while (0x0)
/** Reads a value from an atomic object */
#define atomic_load(PTR)   atomic_load_explicit((PTR), (__ATOMIC_SEQ_CST))
/** Sets an atomic_flag to true and returns the old value */
#define atomic_flag_test_and_set(PTR)   __atomic_test_and_set((PTR), (__ATOMIC_SEQ_CST))
/** Sets an atomic_flag to true and returns the old value */
#define atomic_flag_test_and_set_explicit(PTR, MO)   __atomic_test_and_set((PTR), (MO))
/** Sets an atomic_flag to false */
#define atomic_flag_clear(PTR)   __atomic_clear((PTR), __ATOMIC_SEQ_CST)
/** Sets an atomic_flag to false */
#define atomic_flag_clear_explicit(PTR, MO)   __atomic_clear((PTR), (MO))
/** Atomic addition */
#define atomic_fetch_add(PTR, VAL)   __atomic_fetch_add((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Atomic increment */
#define __atomic_inc(PTR)   __atomic_fetch_add((PTR), 1, __ATOMIC_SEQ_CST)
/** Atomic increment */
#define atomic_inc(PTR)   atomic_add_return(1, v)
/** Atomic addition */
#define __sync_fetch_and_add(PTR, VAL)   __atomic_fetch_add((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Atomic addition */
#define atomic_fetch_add_explicit(PTR, VAL, MO)   __atomic_fetch_add((PTR), (VAL), (MO))
/** Atomic subtraction */
#define atomic_fetch_sub(PTR, VAL)   __atomic_fetch_sub((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Atomic decrement */
#define __atomic_dec(PTR)   __atomic_fetch_sub((PTR), 1, __ATOMIC_SEQ_CST)
/** Atomic decrement */
#define atomic_dec(PTR)   atomic_sub_return(1, v)
/** Atomic subtraction */
#define __sync_fetch_and_sub(PTR, VAL)   __atomic_fetch_sub((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Atomic subtraction */
#define atomic_fetch_sub_explicit(PTR, VAL, MO)   __atomic_fetch_sub((PTR), (VAL), (MO))
/** Atomic logical OR */
#define atomic_fetch_or(PTR, VAL)   __atomic_fetch_or((PTR), (VAL),  __ATOMIC_SEQ_CST)
#ifndef __c11_atomic_fetch_or
#   define __c11_atomic_fetch_or(PTR, VAL, x)   __atomic_fetch_or((PTR), (VAL), (x))
#endif
/** Atomic logical OR */
#define atomic_fetch_or_explicit(PTR, VAL, MO)   __atomic_fetch_or((PTR), (VAL), (MO))
/** Atomic logical XOR */
#define atomic_fetch_xor(PTR, VAL)   __atomic_fetch_xor((PTR), (VAL), __ATOMIC_SEQ_CST)
#ifndef __c11_atomic_fetch_xor
#   define __c11_atomic_fetch_xor(PTR, VAL, x)   __atomic_fetch_xor((PTR), (VAL), (x))
#endif
/** Atomic logical XOR */
#define atomic_fetch_xor_explicit(PTR, VAL, MO)   __atomic_fetch_xor((PTR), (VAL), (MO))
/** Atomic logical AND */
#define atomic_fetch_and(PTR, VAL)   __atomic_fetch_and((PTR), (VAL), __ATOMIC_SEQ_CST)
#ifndef __c11_atomic_fetch_and
#   define __c11_atomic_fetch_and(PTR, VAL, x)   __atomic_fetch_and((PTR), (VAL), (x))
#endif
/** Atomic logical AND */
#define atomic_fetch_and_explicit(PTR, VAL, MO)   __atomic_fetch_and((PTR), (VAL), (MO))
/** Swaps a value with the value of an atomic object */
#define atomic_exchange_explicit(PTR, VAL, MO)   do { auto_type __atomic_exchange_ptr = (PTR); typeof(*__atomic_exchange_ptr) __atomic_exchange_val = (VAL); typeof(*__atomic_exchange_ptr) __atomic_exchange_tmp; __atomic_exchange(__atomic_exchange_ptr, &__atomic_exchange_val, &__atomic_exchange_tmp, (MO)); __atomic_exchange_tmp; } while (0x0)
/** Swaps a value with the value of an atomic object */
#define atomic_exchange(PTR, VAL)   atomic_exchange_explicit((PTR), (VAL), __ATOMIC_SEQ_CST)
/** Swaps a value with the an atomic object if the old value is what is expected, otherwise reads the old value */
#define atomic_compare_exchange_strong_explicit(PTR, VAL, DES, SUC, FAIL)   do { auto_type __atomic_compare_exchange_ptr = (PTR); typeof(*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange(__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 0, (SUC), (FAIL)); } while(0x0)
#ifndef atomic_compare_exchange_strong
/** Swaps a value with the an atomic object if the old value is what is expected, otherwise reads the old value */
#   define atomic_compare_exchange_strong(PTR, VAL, DES)   atomic_compare_exchange_strong_explicit((PTR), (VAL), (DES), __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#endif
#define __atomic_compare_exchange_strong(PTR, VAL, DES)   atomic_compare_exchange_strong_explicit((PTR), (VAL), (DES), __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#define __c11_atomic_compare_exchange_strong(PTR, VAL, DES)   atomic_compare_exchange_strong_explicit((PTR), (VAL), (DES), __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#ifndef __c11_atomic_compare_exchange_strong_explicit
#   define __c11_atomic_compare_exchange_strong_explicit(PTR, VAL, DES, x, y)   atomic_compare_exchange_strong_explicit((PTR), (VAL), (DES), (x), (y))
#endif
#ifndef __atomic_compare_exchange_strong_explicit
#   define __atomic_compare_exchange_strong_explicit(PTR, VAL, DES, x, y)   atomic_compare_exchange_strong_explicit((PTR), (VAL), (DES), (x), (y))
#endif
/** Swaps a value with the an atomic object if the old value is what is expected, otherwise reads the old value */
#define atomic_compare_exchange_weak_explicit(PTR, VAL, DES, SUC, FAIL)   do { auto_type __atomic_compare_exchange_ptr = (PTR); typeof(*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp = (DES); __atomic_compare_exchange(__atomic_compare_exchange_ptr, (VAL), &__atomic_compare_exchange_tmp, 1, (SUC), (FAIL)); } while(0x0)
/** Swaps a value with the an atomic object if the old value is what is expected, otherwise reads the old value */
#define atomic_compare_exchange_weak(PTR, VAL, DES)   atomic_compare_exchange_weak_explicit((PTR), (VAL), (DES), __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
/** Wrapper macros to call pre_NN_post (mem, ...) where NN is the bit width of *MEM.  The calling macro puts parens around MEM and following args */
#define __atomic_val_bysize(pre, post, mem, ...)   do { typeof(*mem) __atg1_result; if (sizeof(*mem) == 1) { __atg1_result = pre##_8_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 2) { __atg1_result = pre##_16_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 4) { __atg1_result = pre##_32_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 8) { __atg1_result = pre##_64_##post (mem, __VA_ARGS__); } else { abort(); } __atg1_result; } while (0x0)
#define __atomic_bool_bysize(pre, post, mem, ...)   do { int __atg2_result; if (sizeof(*mem) == 1) { __atg2_result = pre##_8_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 2) { __atg2_result = pre##_16_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 4) { __atg2_result = pre##_32_##post (mem, __VA_ARGS__); } else if (sizeof(*mem) == 8) { __atg2_result = pre##_64_##post (mem, __VA_ARGS__); } else { abort(); } __atg2_result; } while (0x0)
#define __arch_compare_and_exchange_bool_8_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); (!__atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED)); } while (0x0)
#define __arch_compare_and_exchange_bool_16_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); (!__atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED)); } while (0x0)
#define __arch_compare_and_exchange_bool_32_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); (!__atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED)); } while (0x0)
#define __arch_compare_and_exchange_bool_64_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); (!__atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED)); } while (0x0)
#define __arch_compare_and_exchange_val_8_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); __atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED); __oldval; } while (0x0)
#define __arch_compare_and_exchange_val_16_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); __atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED); __oldval; } while (0x0)
#define __arch_compare_and_exchange_val_32_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); __atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED); __oldval; } while (0x0)
#define __arch_compare_and_exchange_val_64_int(mem, newval, oldval, model)   do { typeof(*mem) __oldval = (oldval); __atomic_compare_exchange_n(mem, (void*)&__oldval, newval, 0, model, __ATOMIC_RELAXED); __oldval; } while (0x0)
/** Atomic exchange (without compare) */
#define __arch_exchange_8_int(mem, newval, model)   __atomic_exchange_n(mem, newval, model)
#define __arch_exchange_16_int(mem, newval, model)   __atomic_exchange_n(mem, newval, model)
#define __arch_exchange_32_int(mem, newval, model)   __atomic_exchange_n(mem, newval, model)
#define __arch_exchange_64_int(mem, newval, model)   __atomic_exchange_n(mem, newval, model)
#define atomic_exchange_acq(mem, value)   __atomic_val_bysize(__arch_exchange, int, mem, value, __ATOMIC_ACQUIRE)
#define atomic_exchange_rel(mem, value)   __atomic_val_bysize(__arch_exchange, int, mem, value, __ATOMIC_RELEASE)
/** Atomically add value and return the previous (unincremented) value */
#define __arch_exchange_and_add_8_int(mem, value, model)   __atomic_fetch_add(mem, value, model)
#define __arch_exchange_and_add_16_int(mem, value, model)   __atomic_fetch_add(mem, value, model)
#define __arch_exchange_and_add_32_int(mem, value, model)   __atomic_fetch_add(mem, value, model)
#define __arch_exchange_and_add_64_int(mem, value, model)   __atomic_fetch_add(mem, value, model)
#define atomic_exchange_and_add_acq(mem, value)   __atomic_val_bysize(__arch_exchange_and_add, int, mem, value, __ATOMIC_ACQUIRE)
#define atomic_exchange_and_add_rel(mem, value)   __atomic_val_bysize(__arch_exchange_and_add, int, mem, value, __ATOMIC_RELEASE)
#if ((!defined(atomic_compare_and_exchange_val_acq)) && defined(__arch_compare_and_exchange_val_32_acq))
/** Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL; Return the old *MEM value */
#   define atomic_compare_and_exchange_val_acq(MEM, NEWVAL, OLDVAL)   __atomic_val_bysize(__arch_compare_and_exchange_val, (acq), (MEM), (NEWVAL), (OLDVAL))
#endif
#ifndef catomic_compare_and_exchange_val_acq
#   ifdef __arch_c_compare_and_exchange_val_32_acq
#      define catomic_compare_and_exchange_val_acq(MEM, NEWVAL, OLDVAL)   __atomic_val_bysize(__arch_c_compare_and_exchange_val, acq, (MEM), (NEWVAL), (OLDVAL))
#   else
#      define catomic_compare_and_exchange_val_acq(MEM, NEWVAL, OLDVAL)   atomic_compare_and_exchange_val_acq((MEM), (NEWVAL), (OLDVAL))
#   endif
#endif
#ifndef catomic_compare_and_exchange_val_rel
#   ifndef atomic_compare_and_exchange_val_rel
#      define catomic_compare_and_exchange_val_rel(MEM, NEWVAL, OLDVAL)   catomic_compare_and_exchange_val_acq((MEM), (NEWVAL), (OLDVAL))
#   else
#      define catomic_compare_and_exchange_val_rel(MEM, NEWVAL, OLDVAL)   atomic_compare_and_exchange_val_rel((MEM), (NEWVAL), (OLDVAL))
#   endif
#endif
#ifndef atomic_compare_and_exchange_val_rel
#   define atomic_compare_and_exchange_val_rel(MEM, NEWVAL, OLDVAL)   atomic_compare_and_exchange_val_acq((MEM), (NEWVAL), (OLDVAL))
#endif
#ifndef atomic_compare_and_exchange_bool_acq
#   ifdef __arch_compare_and_exchange_bool_32_acq
/** Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL; Return zero if *MEM was changed or non-zero if no exchange happened */
#      define atomic_compare_and_exchange_bool_acq(MEM, NEWVAL, OLDVAL)   __atomic_bool_bysize(__arch_compare_and_exchange_bool, (acq), (MEM), (NEWVAL), (OLDVAL))
#   else
/** Atomically store NEWVAL in *MEM if *MEM is equal to OLDVAL; Return zero if *MEM was changed or non-zero if no exchange happened */
#      define atomic_compare_and_exchange_bool_acq(MEM, NEWVAL, OLDVAL)   do { typeof(OLDVAL) __atg3_old = (oldval); atomic_compare_and_exchange_val_acq ((MEM), (NEWVAL), __atg3_old) != __atg3_old; } while (0x0)
#   endif
#endif
#ifndef catomic_compare_and_exchange_bool_acq
#   ifdef __arch_c_compare_and_exchange_bool_32_acq
#      define catomic_compare_and_exchange_bool_acq(MEM, NEWVAL, OLDVAL)   __atomic_bool_bysize(__arch_c_compare_and_exchange_bool, (acq), (MEM), (NEWVAL), (OLDVAL))
#   else
#      define catomic_compare_and_exchange_bool_acq(MEM, NEWVAL, OLDVAL)   do { typeof(OLDVAL) __atg4_old = (OLDVAL); catomic_compare_and_exchange_val_acq((MEM), (NEWVAL), __atg4_old) != __atg4_old; } while (0x0)
#   endif
#endif
#ifndef catomic_compare_and_exchange_bool_rel
#   ifndef atomic_compare_and_exchange_bool_rel
#      define catomic_compare_and_exchange_bool_rel(MEM, NEWVAL, OLDVAL)   catomic_compare_and_exchange_bool_acq((MEM), (NEWVAL), (OLDVAL))
#   else
#      define catomic_compare_and_exchange_bool_rel(MEM, NEWVAL, OLDVAL)   atomic_compare_and_exchange_bool_rel((MEM), (NEWVAL), (OLDVAL))
#   endif
#endif
#ifndef atomic_compare_and_exchange_bool_rel
#   define atomic_compare_and_exchange_bool_rel(MEM, NEWVAL, OLDVAL)   atomic_compare_and_exchange_bool_acq((MEM), (NEWVAL), (OLDVAL))
#endif
#ifndef atomic_exchange_acq
/** Store NEWVALUE in *MEM and return the old value */
#   define atomic_exchange_acq(mem, NEWVALUE)   do { typeof(*(mem)) __atg5_oldval; typeof(mem) __atg5_memp = (mem); typeof(*(mem)) __atg5_value = (NEWVALUE); do { __atg5_oldval = *__atg5_memp; } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg5_memp, __atg5_value, __atg5_oldval), 0)); __atg5_oldval; } while (0x0)
#endif
#ifndef atomic_exchange_rel
#   define atomic_exchange_rel(MEM, NEWVALUE)   atomic_exchange_acq((MEM), (NEWVALUE))
#endif
#ifndef atomic_exchange_and_add
/** Add VALUE to *MEM and return the old value of *MEM */
#   define atomic_exchange_and_add(mem, value)   do { typeof(*(mem)) __atg6_oldval; typeof(mem) __atg6_memp = (mem); typeof(*(mem)) __atg6_value = (value); do { __atg6_oldval = *__atg6_memp; } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg6_memp, (__atg6_oldval + __atg6_value), __atg6_oldval), 0)); __atg6_oldval; } while(0x0)
#endif
#ifndef catomic_exchange_and_add
#   define catomic_exchange_and_add(mem, value)   do { typeof(*(mem)) __atg7_oldv; typeof(mem) __atg7_memp = (mem); typeof(*(mem)) __atg7_value = (value); do { __atg7_oldv = *__atg7_memp; } while (__builtin_expect(catomic_compare_and_exchange_bool_acq(__atg7_memp, (__atg7_oldv + __atg7_value), __atg7_oldv), 0)); __atg7_oldv; } while(0x0)
#endif
#ifndef atomic_max
#   define atomic_max(mem, value)   do { typeof(*(mem)) __atg8_oldval; typeof(mem) __atg8_memp = (mem); typeof(*(mem)) __atg8_value = (value); do { __atg8_oldval = *__atg8_memp; if (__atg8_oldval >= __atg8_value) { break; } } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg8_memp, __atg8_value, __atg8_oldval), 0)); } while (0x0)
#endif
#ifndef catomic_max
#   define catomic_max(mem, value)   do { typeof(*(mem)) __atg9_oldv; typeof(mem) __atg9_memp = (mem); typeof(*(mem)) __atg9_value = (value); do { __atg9_oldv = *__atg9_memp; if (__atg9_oldv >= __atg9_value) { break; } } while (__builtin_expect(catomic_compare_and_exchange_bool_acq(__atg9_memp, __atg9_value, __atg9_oldv), 0)); } while (0x0)
#endif
#ifndef atomic_min
#   define atomic_min(mem, value)   do { typeof(*(mem)) __atg10_oldval; typeof(mem) __atg10_memp = (mem); typeof(*(mem)) __atg10_value = (value); do { __atg10_oldval = *__atg10_memp; if (__atg10_oldval <= __atg10_value) { break; } } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg10_memp, __atg10_value, __atg10_oldval), 0)); } while (0x0)
#endif
#ifndef atomic_add
#   define atomic_add(mem, value)   ((void)atomic_exchange_and_add((mem), (value)))
#endif
#ifndef catomic_add
#   define catomic_add(mem, value)   ((void)catomic_exchange_and_add((mem), (value)))
#endif
#ifndef atomic_increment
#   define atomic_increment(mem)   (atomic_add((mem), 1))
#endif
#ifndef catomic_increment
#   define catomic_increment(mem)   (catomic_add((mem), 1))
#endif
#ifndef atomic_increment_val
#   define atomic_increment_val(mem)   (atomic_exchange_and_add((mem), 1) + 1)
#endif
#ifndef catomic_increment_val
#   define catomic_increment_val(mem)   (catomic_exchange_and_add((mem), 1) + 1)
#endif
#ifndef atomic_increment_and_test
/** Add one to *MEM and return true iff it is now zero */
#   define atomic_increment_and_test(mem)   ((atomic_exchange_and_add((mem), 1) + 1) == 0)
#endif
#ifndef atomic_decrement
#   define atomic_decrement(mem)   (atomic_add((mem), -1))
#endif
#ifndef catomic_decrement
#   define catomic_decrement(mem)   (catomic_add((mem), -1))
#endif
#ifndef atomic_decrement_val
#   define atomic_decrement_val(mem)   (atomic_exchange_and_add((mem), -1) - 1)
#endif
#ifndef catomic_decrement_val
#   define catomic_decrement_val(mem)   (catomic_exchange_and_add((mem), -1) - 1)
#endif
#ifndef atomic_decrement_and_test
/** Subtract 1 from *MEM and return true iff it is now zero */
#   define atomic_decrement_and_test(mem)   ((atomic_exchange_and_add((mem), -1)) == 1)
#endif
#ifndef atomic_decrement_if_positive
/** Decrement *MEM if it is > 0, and return the old value */
#   define atomic_decrement_if_positive(mem)   do { typeof(*(mem)) __atg11_oldval; typeof(mem) __atg11_memp = (mem); do { __atg11_oldval = *__atg11_memp; if (__builtin_expect(__atg11_oldval <= 0, 0)) { break; } } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg11_memp, __atg11_oldval - 1, __atg11_oldval), 0)); __atg11_oldval; } while (0x0)
#endif
#ifndef atomic_add_negative
#   define atomic_add_negative(mem, value)   do { typeof(value) __atg12_value = (value); atomic_exchange_and_add(mem, __atg12_value) < (-__atg12_value); } while (0x0)
#endif
#ifndef atomic_add_zero
#   define atomic_add_zero(mem, value)   do { typeof(value) __atg13_value = (value); atomic_exchange_and_add(mem, __atg13_value) == (-__atg13_value); } while (0x0)
#endif
#ifndef atomic_bit_test_set
#   define atomic_bit_test_set(mem, bit)   do { typeof(*(mem)) __atg14_old; typeof(mem) __atg14_memp = (mem); typeof(*(mem)) __atg14_mask = ((typeof(*(mem))) 1 << (bit)); do { __atg14_old = (*__atg14_memp); } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg14_memp, (__atg14_old | __atg14_mask), __atg14_old), 0)); __atg14_old & __atg14_mask; } while (0x0)
#endif
#ifndef atomic_bit_set
#   define atomic_bit_set(mem, bit)   (void)atomic_bit_test_set(mem, bit)
#endif
#ifndef atomic_and
/** Atomically *mem &= mask */
#   define atomic_and(mem, mask)   do { typeof(*(mem)) __atg15_old; typeof(mem) __atg15_memp = (mem); typeof(*(mem)) __atg15_mask = (mask); do { __atg15_old = (*__atg15_memp); } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg15_memp, (__atg15_old & __atg15_mask), __atg15_old), 0)); } while (0x0)
#endif
#ifndef catomic_and
#   define catomic_and(mem, mask)   do { typeof(*(mem)) __atg20_old; typeof(mem) __atg20_memp = (mem); typeof(*(mem)) __atg20_mask = (mask); do { __atg20_old = (*__atg20_memp); } while (__builtin_expect(catomic_compare_and_exchange_bool_acq(__atg20_memp, (__atg20_old & __atg20_mask), __atg20_old), 0)); } while (0x0)
#endif
#ifndef atomic_and_val
/** Atomically *mem &= mask and return the old value of *mem */
#   define atomic_and_val(mem, mask)   do { typeof(*(mem)) __atg16_old; typeof(mem) __atg16_memp = (mem); typeof(*(mem)) __atg16_mask = (mask); do { __atg16_old = (*__atg16_memp); } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg16_memp, (__atg16_old & __atg16_mask), __atg16_old), 0)); __atg16_old; } while(0x0)
#endif
#ifndef atomic_or
/** Atomically *mem |= mask and return the old value of *mem */
#   define atomic_or(mem, mask)   do { typeof(*(mem)) __atg17_old; typeof(mem) __atg17_memp = (mem); typeof(*(mem)) __atg17_mask = (mask); do { __atg17_old = (*__atg17_memp); } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg17_memp, (__atg17_old | __atg17_mask), __atg17_old), 0)); } while (0x0)
#endif
#ifndef catomic_or
#   define catomic_or(mem, mask)   do { typeof(*(mem)) __atg18_old; typeof(mem) __atg18_memp = (mem); typeof(*(mem)) __atg18_mask = (mask); do { __atg18_old = (*__atg18_memp); } while (__builtin_expect(catomic_compare_and_exchange_bool_acq(__atg18_memp, (__atg18_old | __atg18_mask), __atg18_old), 0)); } while (0x0)
#endif
#ifndef atomic_or_val
/** Atomically *mem |= mask and return the old value of *mem */
#   define atomic_or_val(mem, mask)   do { typeof(*(mem)) __atg19_old; typeof(mem) __atg19_memp = (mem); typeof(*(mem)) __atg19_mask = (mask); do { __atg19_old = (*__atg19_memp); } while (__builtin_expect(atomic_compare_and_exchange_bool_acq(__atg19_memp, (__atg19_old | __atg19_mask), __atg19_old), 0)); __atg19_old; } while (0x0)
#endif
#define atomic_dec_return(v)   atomic_sub_return(1, (v))
#define atomic_inc_return(v)   atomic_add_return(1, (v))
#define atomic_sub_and_test(i, v)   (atomic_sub_return((i), (v)) == 0)
#define atomic_dec_and_test(v)   (atomic_dec_return(v) == 0)
#define atomic_inc_and_test(v)   (atomic_inc_return(v) == 0)
#define atomic_xchg(ptr, v)   (xchg(&(ptr)->counter, (v)))


LIB_FUNC int8_t OSAddAtomic8(UNUSED int32_t amount, UNUSED int8_t* address) {
	return __c11_atomic_fetch_add((_Atomic int8_t*)address, amount, memory_order_relaxed);
}


LIB_FUNC int16_t OSAddAtomic16(UNUSED int32_t amount, UNUSED int16_t* address) {
	return __c11_atomic_fetch_add((_Atomic int16_t*)address, amount, memory_order_relaxed);
}


LIB_FUNC int32_t OSAddAtomic(UNUSED int32_t amount, UNUSED int32_t* address) {
	ALIGN_TEST(address, uint32_t);
	return __c11_atomic_fetch_add((_Atomic int32_t*)address, amount, memory_order_relaxed);
}


/** 64-bit atomic add operation */
LIB_FUNC int64_t OSAddAtomic64(int64_t amount, int64_t* address) {
	_Atomic int64_t* aligned_address = (_Atomic int64_t*)(uintptr_t)address;
	ALIGN_TEST(address, int64_t);
	return __c11_atomic_fetch_add(aligned_address, amount, memory_order_relaxed);
}


/** Atomic add operation */
LIB_FUNC long OSAddAtomicLong(long theAmount, long* address) {
#   ifdef DATAMODEL_LP64
	return (long)OSAddAtomic64((int64_t)theAmount, (int64_t*)address);
#   else
	return (long)OSAddAtomic((int32_t)theAmount, address);
#   endif
}


/** Increment */
LIB_FUNC long OSIncrementAtomicLong(long* address) {
#   ifdef DATAMODEL_LP64
	return (long)OSAddAtomic64(((int64_t)1), (int64_t*)address);
#   else
	return (long)OSAddAtomic(((int32_t)1), address);
#   endif
}


/** Decrement */
LIB_FUNC long OSDecrementAtomicLong(long* address) {
	return OSAddAtomicLong(((long)-1), address);
}


LIB_FUNC int32_t OSIncrementAtomic(int32_t* value) {
	return OSAddAtomic(1, value);
}


LIB_FUNC int32_t OSDecrementAtomic(int32_t* value) {
	return OSAddAtomic(-1, value);
}


LIB_FUNC uint32_t OSBitAndAtomic(uint32_t mask, uint32_t* value) {
	return __c11_atomic_fetch_and((auint32_t*)value, mask, memory_order_relaxed);
}


LIB_FUNC uint32_t OSBitOrAtomic(uint32_t mask, uint32_t* value) {
	return __c11_atomic_fetch_or((auint32_t*)value, mask, memory_order_relaxed);
}


LIB_FUNC uint32_t OSBitXorAtomic(uint32_t mask, uint32_t* value) {
	return __c11_atomic_fetch_xor((auint32_t*)value, mask, memory_order_relaxed);
}


/** 8-bit increment */
LIB_FUNC int8_t OSIncrementAtomic8(int8_t* value) {
	return OSAddAtomic8(1, value);
}


LIB_FUNC int8_t OSDecrementAtomic8(int8_t* value) {
	return OSAddAtomic8(-1, value);
}


/** 8-bit Bitwise AND */
LIB_FUNC uint8_t OSBitAndAtomic8(uint32_t mask, uint8_t* value) {
	return __c11_atomic_fetch_and((auint8_t*)value, mask, memory_order_relaxed);
}


LIB_FUNC uint8_t OSBitOrAtomic8(uint32_t mask, uint8_t* value) {
	return __c11_atomic_fetch_or((auint8_t*)value, mask, memory_order_relaxed);
}


/** 8-bit Bitwise XOR */
LIB_FUNC uint8_t OSBitXorAtomic8(uint32_t mask, uint8_t* value) {
	return __c11_atomic_fetch_xor((auint8_t*)value, mask, memory_order_relaxed);
}


/** 16-bit increment */
LIB_FUNC int16_t OSIncrementAtomic16(int16_t* value) {
	return OSAddAtomic16(1, value);
}


LIB_FUNC int16_t  OSDecrementAtomic16(int16_t* value) {
	return OSAddAtomic16(-1, value);
}


LIB_FUNC uint16_t  OSBitAndAtomic16(uint32_t mask, uint16_t* value) {
	return __c11_atomic_fetch_and((auint16_t*)value, mask, memory_order_relaxed);
}


LIB_FUNC uint16_t  OSBitOrAtomic16(uint32_t mask, uint16_t* value) {
	return __c11_atomic_fetch_or((auint16_t*)value, mask, memory_order_relaxed);
}


LIB_FUNC uint16_t OSBitXorAtomic16(uint32_t mask, uint16_t* value) {
	return __c11_atomic_fetch_xor((auint16_t*)value, mask, memory_order_relaxed);
}


/** 64-bit increment */
LIB_FUNC int64_t OSIncrementAtomic64(int64_t* address) {
	return OSAddAtomic64(((int64_t)1), address);
}


/** 64-bit decrement */
LIB_FUNC int64_t OSDecrementAtomic64(int64_t* address) {
	return OSAddAtomic64(((int64_t)-1), address);
}


#define atomic_add_16_ov(a, n)   ((uint16_t)OSAddAtomic16(n, (int16_t*)a))
#define atomic_add_16(a, n)   ((void)atomic_add_16_ov(a, n))
#define atomic_add_32_ov(a, n)   ((uint32_t)OSAddAtomic(n, (int32_t*)a))
#define atomic_add_32(a, n)   ((void)atomic_add_32_ov(a, n))
#define atomic_add_64_ov(a, n)   ((uint64_t)OSAddAtomic64(n, (int64_t*)a))
#define atomic_add_64(a, n)   ((void)atomic_add_64_ov(a, n))
#define atomic_set_64(a, n)   do { while (!(OSCompareAndSwap64(*a, n, (uint64_t*)a))); } while (0x0)
#ifdef DATAMODEL_LP64
#   define atomic_get_64(n, a)   do { (n) = *(a); } while (0x0)
#else
#   define atomic_get_64(n, a)   do { (n) = atomic_add_64_ov(a, 0); } while (0x0)
#endif
#define atomic_or_8_ov(a, n)   ((uint8_t)OSBitOrAtomic8(n, (uint8_t*)a))
#define atomic_or_8(a, n)   ((void)atomic_or_8_ov(a, n))
#define atomic_bitset_8(a, n)   atomic_or_8(a, n)
#define atomic_or_16_ov(a, n)   ((uint16_t)OSBitOrAtomic16(n, (uint16_t*)a))
#define atomic_or_16(a, n)   ((void)atomic_or_16_ov(a, n))
#define atomic_bitset_16(a, n)   atomic_or_16(a, n)
#define atomic_or_32_ov(a, n)   ((uint32_t)OSBitOrAtomic(n, (uint32_t*)a))
#define atomic_or_32(a, n)   ((void)atomic_or_32_ov(a, n))
#define atomic_bitset_32(a, n)   atomic_or_32(a, n)
#define atomic_and_8_ov(a, n)   ((uint8_t)OSBitAndAtomic8(n, (uint8_t*)a))
#define atomic_and_8(a, n)   ((void)atomic_and_8_ov(a, n))
#define atomic_bitclear_8(a, n)   atomic_and_8(a, ~(n))
#define atomic_and_16_ov(a, n)   ((uint16_t)OSBitAndAtomic16(n, (uint16_t*)a))
#define atomic_and_16(a, n)   ((void)atomic_and_16_ov(a, n))
#define atomic_bitclear_16(a, n)   atomic_and_16(a, ~(n))
#define atomic_and_32_ov(a, n)   ((uint32_t)OSBitAndAtomic(n, (uint32_t*)a))
#define atomic_and_32(a, n)   ((void)atomic_and_32_ov(a, n))
#define atomic_bitclear_32(a, n)   atomic_and_32(a, ~(n))
/** Atomically set bit N of bitstring name (atomic) */
#define bit_set_atomic(name, bit)   atomic_bitset_8(&((name)[_bit_byte(bit)]), _bit_mask(bit))
/** Atomically clear bit N of bitstring name (atomic) */
#define bit_clear_atomic(name, bit)   atomic_bitclear_8(&((name)[_bit_byte(bit)]), _bit_mask(bit))


LIB_FUNC int __atomic_cmpxchg(int oldVal, int newVal, volatile int* ptr) {
	return (__sync_val_compare_and_swap(ptr, oldVal, newVal) != oldVal);
}


LIB_FUNC int __atomic_swap(int newVal, volatile int* ptr) {
	register int oldVal;
	do { oldVal = *ptr; } while (__sync_val_compare_and_swap(ptr, oldVal, newVal) != oldVal);
	return oldVal;
}


LIB_FUNC void spin_lock(int* p) {
	while (!__sync_bool_compare_and_swap(p, 0, 1)) { while(*p); }
}


LIB_FUNC void spin_unlock(int volatile* p) {
	asm volatile (";");
	*p = 0;
}


#endif  // ATOMIC_H


/* IEEE754 & IEEE854 MACROS */


#if (!(defined(_IEEE754_H) || defined(_IEEE754_H_) || defined(IEEE754_H)))
#define _IEEE754_H   (1)
#define _IEEE754_H_   (1)
#define IEEE754_H   (1)


#ifndef IEEE754_FLOAT_BIAS
/** Added to exponent */
#   define IEEE754_FLOAT_BIAS   (0x7F)
#endif
#ifndef IEEE754_DOUBLE_BIAS
/** Added to exponent */
#   define IEEE754_DOUBLE_BIAS   (0x3FF)
#endif
#ifndef IEEE854_LONG_DOUBLE_BIAS
/** Added to exponent */
#   define IEEE854_LONG_DOUBLE_BIAS   (0x3FFF)
#endif
#ifndef DBL_MANH_SIZE
#   define DBL_MANH_SIZE   (20)
#endif
#ifndef DBL_MANL_SIZE
#   define DBL_MANL_SIZE   (32)
#endif
#ifndef TININESS_AFTER_ROUNDING
#   define TININESS_AFTER_ROUNDING   (0x0)
#endif


#ifndef HUGE_VALF  // HUGE_VALF (<bits/huge_valf.h>)
typedef union union_huge_valf { unsigned char __c[4]; float __f; }   __huge_valf_t;
#   if IS_BIG_ENDIAN
#      define __HUGE_VALF_bytes   { 0x7f, 0x80, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __HUGE_VALF_bytes   { 0x0, 0x0, 0x80, 0x7f }
#   endif
static const UNUSED __huge_valf_t __huge_valf = { __HUGE_VALF_bytes };
/** IEEE Positive Infinity (-HUGE_VAL is negative infinity) */
#   define HUGE_VALF   (__huge_valf.__f)  // 0x7f800000
#endif  // HUGE_VALF (<bits/huge_valf.h>)
#define __aeabi_HUGE_VALF   HUGE_VALF
#define CRT_INFINITY   HUGE_VALF

#ifndef HUGE_VAL  // HUGE_VAL (<bits/huge_val.h>)
typedef union union_huge_val { unsigned char __c[8]; double __d; }   __huge_val_t;
#   if IS_BIG_ENDIAN
#      define __HUGE_VAL_bytes   { 0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __HUGE_VAL_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0, 0x7f }
#   endif
static const UNUSED __huge_val_t __huge_val = { __HUGE_VAL_bytes };
/** IEEE Positive Infinity (-HUGE_VAL is negative infinity) */
#   define HUGE_VAL   (__huge_val.__d)  // 0x7ff0000000000000
#endif  // HUGE_VAL (<bits/huge_val.h>)
#define __aeabi_HUGE_VAL   HUGE_VAL

#if SUPPORTS_LONG_DOUBLE  // HUGE_VALL (<bits/huge_vall.h>)
#   ifndef HUGE_VALL
typedef union union_huge_vall { unsigned char __c[12]; long double __ld; }   __huge_vall_t;
#      if IS_BIG_ENDIAN
#         define __HUGE_VALL_bytes   { 0x7F, 0xFF, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __HUGE_VALL_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xFF, 0x7F }
#      endif
static const UNUSED __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
#      define HUGE_VALL   (__huge_vall.__ld)  // 0x7fff8000000000000000000000
#   endif
#   define __aeabi_HUGE_VALL   HUGE_VALL
#endif  // HUGE_VALL (<bits/huge_vall.h>)


#if IS_BIG_ENDIAN  // nan_bytes
#   define __nan_bytes   { 0x7f, 0xc0, 0x0, 0x0 }
#elif IS_LITTLE_ENDIAN
#   define __nan_bytes   { 0x0, 0x0, 0xc0, 0x7f }
#endif  // nan_bytes
static const UNUSED union { unsigned char __c[4]; float __d; } nan_union = { __nan_bytes };
#define __nan_union   nan_union
#define qnan_bytes   __nan_bytes
#define __qnan_bytes   __nan_bytes
#define nan_bytes   __nan_bytes


// NAN (<bits/nan.h>)

// NAN float8_t
#if SUPPORTS_FLOAT8
#   ifndef NAN8
typedef union union_NAN8 { unsigned char __c; float8_t __f; }   __NAN8_t;
#      define __NAN8_bytes   (unsigned char)0b01111100
static const UNUSED __NAN8_t __nan8 = __NAN8_bytes;
/** float8 IEEE Not A Number (NAN) */
#      define NAN8   (__nan8.__f)  // 0b01111100
#   endif  // NAN8
#   ifndef SNAN8
typedef union union_SNAN8 { unsigned char __c; float8_t __f; }   __SNAN8_t;
#      define __SNAN8_bytes   (unsigned char)0b01111101
static const UNUSED __SNAN8_t __snan8 = __SNAN8_bytes;
/** float8 IEEE Signalling Not A Number (SNAN) */
#      define SNAN8   (__snan8.__f)  // 0b01111101
#   endif  // SNAN8
/** float8 IEEE Quiet Not A Number (QNAN) */
#   define QNAN8   NAN8
#endif
// NAN float16_t
#if SUPPORTS_FLOAT16
#   ifndef NAN16
typedef union union_NAN16 { unsigned char __c[2]; float16_t __f; }   __NAN16_t;
#      if IS_BIG_ENDIAN
#         define __NAN16_bytes   { 0b01111110, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __NAN16_bytes   { 0x0, 0b01111110 }
#      endif
static const UNUSED __NAN16_t __nan16 = { __NAN16_bytes };
/** float16 IEEE Not A Number (NAN) */
#      define NAN16   (__nan16.__f)  // 0b0111111000000000
#   endif  // NAN16
#   ifndef SNAN16
typedef union union_SNAN16 { unsigned char __c[2]; float16_t __f; }   __SNAN16_t;
#      if IS_BIG_ENDIAN
#         define __SNAN16_bytes   { 0b01111110, 0x1 }
#      elif IS_LITTLE_ENDIAN
#         define __SNAN16_bytes   { 0x1, 0b01111110 }
#      endif
static const UNUSED __SNAN16_t __snan16 = { __SNAN16_bytes };
/** float16 IEEE Signalling Not A Number (SNAN) */
#      define SNAN16   (__snan16.__f)  // 0b0111110000000001
#   endif  // SNAN16
/** float16 IEEE Quiet Not A Number (QNAN) */
#   define QNAN16   NAN16
#endif
// NAN float
#ifndef NANF
typedef union union_NANF { unsigned char __c[4]; float __f; }   __NANF_t;
#   if IS_BIG_ENDIAN
#      define __NANF_bytes   { 0x7f, 0xc0, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __NANF_bytes   { 0x0, 0x0, 0xc0, 0x7f }
#   endif
static const UNUSED __NANF_t __nanf = { __NANF_bytes };
/** IEEE Not A Number (NAN) */
#   define NANF   (__nanf.__f)  // 0x7fc00000 || 0b01111111110000000000000000000000
#endif  // NANF
#ifndef NANSF
typedef union union_NANSF { unsigned char __c[4]; float __f; }   __NANSF_t;
#   if IS_BIG_ENDIAN
#      define __NANSF_bytes   { 0x7f, 0xc0, 0x0, 0x1 }
#   elif IS_LITTLE_ENDIAN
#      define __NANSF_bytes   { 0x1, 0x0, 0xc0, 0x7f }
#   endif
static const UNUSED __NANSF_t __nansf = { __NANSF_bytes };
/** Signaling IEEE Not A Number (NANS) */
#   define NANSF   (__nansf.__f)  // 0x7fc00001
#endif  // NANSF
#define FLT_SNAN   NANSF
#define FLT_NANS   NANSF
#define SNANF   NANSF
#define __QNANF   NANF
#define QNANF   NANF
// NAN double
#ifndef NAN
typedef union union_NAN { unsigned char __c[8]; double __d; }   __NAN_t;
#   if IS_BIG_ENDIAN
#      define __NAN_bytes   { 0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __NAN_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8, 0x7f }
#   endif
static const UNUSED __NAN_t __nan = { __NAN_bytes };
/** IEEE Not A Number (NAN) */
#   define NAN   (double)(__nan.__d)  // 0x7ff8000000000000
#endif  // NAN
#define NAN_DOUBLE   NAN
#define __aeabi_NAN   NAN
#ifndef NANS
typedef union union_NANS { unsigned char __c[8]; double __d; }   __NANS_t;
#   if IS_BIG_ENDIAN
#      define __NANS_bytes   { 0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1 }
#   elif IS_LITTLE_ENDIAN
#      define __NANS_bytes   { 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8, 0x7f }
#   endif
static const UNUSED __NANS_t __nans = { __NANS_bytes };
/** Signed IEEE Not A Number (NANS) */
#   define NANS   (double)(__nans.__d)  // 0x7ff8000000000001 || __builtin_nans("")
#endif  // NANS
#define DBL_SNAN   NANS
#define DBL_NANS   NANS
#define SNAN   NANS
#define NANS_DOUBLE   NANS
#define __QNAN   NAN
#define QNAN   NAN
// NAN long double
#if (SUPPORTS_LONG_DOUBLE && IS_LDBL_128)
#   define NANL   ((long double)NAN)  // ((long double)0x7fff8000000000000000000000000000L)
#   define NANSL   ((long double)NANS)  // ((long double)0x7fffc000000000000000000000000001L)
#   define LBL_SNAN   NANSL
#   define LBL_NANS   NANSL
#   define SNANL   NANSL
#   define __QNANL   NANL
#   define QNANL   NANL
#endif
// NAN float128_t
#if (SUPPORTS_FLOAT128)
#   define NAN128   ((float128_t)0x7fff8000000000000000000000000000)
#   define NANS128   ((float128_t)0x7fffc000000000000000000000000001)
#   define FLOAT128_SNAN   NANS128
#   define FLOAT128_NANS   NANS128
#   define SNAN128   NANS128
#   define __QNAN128   NAN128
#   define QNAN128   NAN128
#endif
// NAN decimal floats
#if SUPPORTS_DECIMAL_FLOATS
#   define NAND32   ((decimal32)0b01111100000000000000000000000000DF)  // __builtin_nand32("")
#   define QNAND32   ((decimal32)0b01111100000000000000000000000000DF)
#   define SNAND32   ((decimal32)0b01111110000000000000000000000000DF)
#   define NANSD32   SNAND32  // 0x7e000000DF
#   define NAND64   ((decimal64)0x7c00000000000000DD)  // __builtin_nand64("")
#   define QNAND64   ((decimal64)0x7c00000000000000DD)
#   define SNANSD64   ((decimal64)0x7c00000000000001DD)
#   define NANSD64   SNANSD64
#   if SUPPORTS_DECIMAL128
#      define NAND128   ((decimal128)0x7c000000000000000000000000000000DL)  // __builtin_nand128("")
#      define QNAND128   ((decimal128)0x7c000000000000000000000000000000DL)
#      define SNANSD128   ((decimal128)0x7c000000000000000000000000000001DL)
#      define NANSD128   SNANSD128
#   endif
#endif
#if AT_LEAST_GCC33  // __nan()
#   define __nanf(str)   __builtin_nanf((str))
#   define __nan(str)   __builtin_nan((str))
#   define __nanl(str)  __builtin_nanl((str))
#   define __nansf(str)   __builtin_nansf((str))
#   define __nans(str)   __builtin_nans((str))
#   define __nansl(str)   __builtin_nansl((str))
#   if SUPPORTS_DECIMAL_FLOATS
#      define __nand32   __builtin_nand32((str))
#      define __nand64   __builtin_nand64((str))
#      if SUPPORTS_DECIMAL128
#         define __nand128   __builtin_nand128((str))
#      endif
#   endif
#else
#   define __nanf(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NANF : nanf(str))
#   define __nan(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NAN : nan(str))
#   define __nanl(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NANL : nanl(str))
#   define __nansf(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NANSF : nansf(str))
#   define __nans(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NANS : nans(str))
#   define __nansl(str)   (__builtin_constant_p((str)) && (str[0] == '\0') ? NANSL : nansl(str))
#endif  // __nan()


// INF (<bits/inf.h>)

// INF float8_t
#if SUPPORTS_FLOAT8
#   ifndef INFINITY8
typedef union union_INFINITY8 { unsigned char __c; float8_t __f; }   __INFINITY8_t;
#      define __INFINITY8_bytes   (unsigned char)0b01111000
static const UNUSED __INFINITY8_t __infinity8 = __INFINITY8_bytes;
/** Positive infinity (float8) */
#      define INFINITY8   (__infinity8.__f)  // 0b01111000
#   endif  // INFINITY8
/** Positive infinity (float16) */
#   define INF8   INFINITY8
/** Positive infinity (float16) */
#   define PINF8   INFINITY8
#   ifndef NINF8
typedef union union_NINF8 { unsigned char __c; float8_t __f; }   __NINF8_t;
#      define __NINF8_bytes   (unsigned char)0b11111000
static const UNUSED __NINF8_t __ninf8 = __NINF8_bytes;
/** Negative infinity (float16) */
#      define NINF8   (__ninf8.__f)  // 0b11111000
#   endif  // NINF8
#endif
// INF float16_t
#if SUPPORTS_FLOAT16
#   ifndef INFINITY16
typedef union union_INFINITY16 { unsigned char __c[2]; float16_t __f; }   __INFINITY16_t;
#      if IS_BIG_ENDIAN
#         define __INFINITY16_bytes   { 0b01111100, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __INFINITY16_bytes   { 0x0, 0b01111100 }
#      endif
static const UNUSED __INFINITY16_t __infinity16 = { __INFINITY16_bytes };
/** Positive infinity (float16) */
#      define INFINITY16   (__infinity16.__f)  // 0b0111110000000000
#   endif  // INFINITY16
/** Positive infinity (float16) */
#   define INF16   INFINITY16
/** Positive infinity (float16) */
#   define PINF16   INFINITY16
#   ifndef NINF16
typedef union union_NINF16 { unsigned char __c[2]; float16_t __f; }   __NINF16_t;
#      if IS_BIG_ENDIAN
#         define __NINF16_bytes   { 0b11111100, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __NINF16_bytes   { 0x0, 0b11111100 }
#      endif
static const UNUSED __NINF16_t __ninf16 = { __NINF16_bytes };
/** Negative infinity (float16) */
#      define NINF16   (__ninf16.__f)  // 0b1111110000000000
#   endif  // NINF16
#endif
// INF float
#ifndef INFINITYF
typedef union union_INFINITYF { unsigned char __c[4]; float __f; }   __INFINITYF_t;
#   if IS_BIG_ENDIAN
#      define __INFINITYF_bytes   { 0x7f, 0x80, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __INFINITYF_bytes   { 0x0, 0x0, 0x80, 0x7f }
#   endif
static const UNUSED __INFINITYF_t __infinityf = { __INFINITYF_bytes };
/** IEEE Positive Infinity (INF) */
#   define INFINITYF   (__infinityf.__f)  // 0x7f800000 || __builtin_inff()
#endif  // INFINITYF
#define INFF   INFINITYF
#define FLT_INFINITY   INFINITYF
/** Positive infinity (float) */
#define PINFF   INFINITYF
/** Positive infinity (float) */
#define PINFINITYF   PINFF
#ifndef NINFF
typedef union union_NINFF { unsigned char __c[4]; float __f; }   __NINFF_t;
#   if IS_BIG_ENDIAN
#      define __NINFF_bytes   { 0xff, 0x80, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __NINFF_bytes   { 0x0, 0x0, 0x80, 0xff }
#   endif
static const UNUSED __NINFF_t __ninff = { __NINFF_bytes };
/** Negative infinity (float) */
#   define NINFF   (__ninff.__f)  // 0xff800000
#endif  // NINFF
/** IEEE Negative Infinity (INF) */
#define NEG_INFINITYF   NINFF
// INF double
#ifndef INFINITY
typedef union union_INFINITY { unsigned char __c[8]; double __d; }   __INFINITY_t;
#   if IS_BIG_ENDIAN
#      define __INFINITY_bytes   { 0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __INFINITY_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0, 0x7f }
#   endif
static const UNUSED __INFINITY_t __infinity = { __INFINITY_bytes };
/** IEEE Infinity (INF) */
#   define INFINITY   (double)(__infinity.__d)  // 0x7ff0000000000000 || __builtin_inff()
#endif  // INFINITY
#define __aeabi_INFINITY   INFINITY
#define INF   INFINITY
/** Positive infinity (double) */
#define PINF   INFINITY
/** Positive infinity (double) */
#define PINFINITY   PINF
#ifndef NINF
typedef union union_NINF { unsigned char __c[8]; double __d; }   __NINF_t;
#   if IS_BIG_ENDIAN
#      define __NINF_bytes   { 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#   elif IS_LITTLE_ENDIAN
#      define __NINF_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0, 0xff }
#   endif
static const UNUSED __NINF_t __ninf = { __NINF_bytes };
/** Negative infinity (double) */
#   define NINF   (double)(__ninf.__d)  // 0xfff0000000000000
#endif  // NINF
/** Negative infinity (double) */
#define NEG_INFINITY   NINF
// INF long double
#if ((!defined(__NO_LONG_DOUBLE_MATH)) && SUPPORTS_LONG_DOUBLE && IS_LDBL_128)
#   define INFINITYL   ((long double)INFINITY)  // ((long double)0x7ff00000000000000000000000000000L)
#   define INFL   INFINITYL
#   define PINFL   INFINITYL
#   define PINFINITYL   PINFL
#   define NINFL   ((long double)NINF)  // ((long double)0xfff00000000000000000000000000000L)
#   define NEG_INFINITYL   NINFL
#endif
// INF float128_t
#if SUPPORTS_FLOAT128
#   define INFINITY128   ((float128_t)0x7ff00000000000000000000000000000)
#   define INF128   INFINITY128
#   define PINF128   ((float128_t)0x7ff00000000000000000000000000000)
#   define PINFINITY128   PINF128
#   define NINF128   ((float128_t)0xfff00000000000000000000000000000)
#   define NEG_INFINITY128   NINF128
#endif
// INF decimal floats
#if (SUPPORTS_DECIMAL_FLOATS && (!defined(INFINITYD64)))
#   ifndef INFINITYD32
typedef union union_INFINITYD32 { unsigned char __c[4]; decimal32 __f; }   __INFINITYD32_t;
#      if IS_BIG_ENDIAN
#         define __INFINITYD32_bytes   { 0x78, 0x0, 0x0, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __INFINITYD32_bytes   { 0x0, 0x0, 0x0, 0x78 }
#      endif
static const UNUSED __INFINITYD32_t __infinityd32 = { __INFINITYD32_bytes };
/** Decimal float infinity (32-bit) */
#      define INFINITYD32   (__infinityd32.__f)  // 0b01111000000000000000000000000000DF || __builtin_infd32()
#   endif  // INFINITYD32
#   define INFD32   INFINITYD32
#   define POS_INFINITYD32   INFINITYD32
#   define PINFD32   POS_INFINITYD32
#   ifndef NEG_INFINITYD32
typedef union union_NEG_INFINITYD32 { unsigned char __c[4]; decimal32 __f; }   __NEG_INFINITYD32_t;
#      if IS_BIG_ENDIAN
#         define __NEG_INFINITYD32_bytes   { 0xf8, 0x0, 0x0, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __NEG_INFINITYD32_bytes   { 0x0, 0x0, 0x0, 0xf8 }
#      endif
static const UNUSED __NEG_INFINITYD32_t __neg_infinityd32 = { __NEG_INFINITYD32_bytes };
/** Decimal float infinity (32-bit) */
#      define NEG_INFINITYD32   (__neg_infinityd32.__f)  // 0b11111000000000000000000000000000DF
#   endif  // NEG_INFINITYD32
#   define NINFD32   NEG_INFINITYD32
#   ifndef INFINITYD64
typedef union union_INFINITYD64 { unsigned char __c[8]; decimal64 __d; }   __INFINITYD64_t;
#      if IS_BIG_ENDIAN
#         define __INFINITYD64_bytes   { 0x78, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __INFINITYD64_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78 }
#      endif
static const UNUSED __INFINITYD64_t __infinityd64 = { __INFINITYD64_bytes };
/** IEEE Infinity (INF) */
#      define INFINITYD64   (decimal64)(__infinityd64.__d)  // 0b0111100000000000000000000000000000000000000000000000000000000000DD || __builtin_infd64()
#   endif  // INFINITYD64
#   define INFD64   INFINITYD64
#   define POS_INFINITYD64   INFINITYD64
#   define PINFD64   POS_INFINITYD64
#   ifndef NEG_INFINITYD64
typedef union union_NEG_INFINITYD64 { unsigned char __c[8]; decimal64 __d; }   __NEG_INFINITYD64_t;
#      if IS_BIG_ENDIAN
#         define __NEG_INFINITYD64_bytes   { 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }
#      elif IS_LITTLE_ENDIAN
#         define __NEG_INFINITYD64_bytes   { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8 }
#      endif
static const UNUSED __NEG_INFINITYD64_t __neg_infinityd64 = { __NEG_INFINITYD64_bytes };
#      define NEG_INFINITYD64   (decimal64)(__neg_infinityd64.__d)  // 0b1111100000000000000000000000000000000000000000000000000000000000DD || __builtin_infd64()
#   endif  // NEG_INFINITYD64
#   define NINFD64   NEG_INFINITYD64
#   ifdef SUPPORTS_DECIMAL128  // __builtin_infd128()
#      define INFINITYD128   ((decimal128)0x78000000000000000000000000000000DL)
#      define INFD128   INFINITYD128
#      define POS_INFINITYD128   INFINITYD128
#      define PINFD128   POS_INFINITYD128
#      define NEG_INFINITYD128   ((decimal128)0xf8000000000000000000000000000000DL)
#      define NINFD128   NEG_INFINITYD128
#   endif
#endif


// IEEE 754 DATATYPES

typedef union ieee754_remainder_double { int i[2]; double x; }   ieee754_remainder_double;


/** IEEE2bits for float; This is used to access various parts of a float */
typedef union IEEEf2bits {
	float f;
	struct IEEEf_bits {
#   if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exp:8;
		unsigned int man:23;
#   else  // LITTLE_ENDIAN
		unsigned int man:23;
		unsigned int exp:8;
		unsigned int sign:1;
#   endif
	} bits;
} IEEEf2bits;


/** IEEE2bits for double; This is used to access various parts of a double */
typedef union IEEEd2bits {
	double d;
	struct IEEEd_bits {
#   if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exp:11;
		unsigned int manh:20;
		unsigned int manl:32;
#   else  // LITTLE_ENDIAN
		unsigned int manl:32;
		unsigned int manh:20;
		unsigned int exp:11;
		unsigned int sign:1;
#   endif
	} bits;
} IEEEd2bits;


#if ((defined(X86) || defined(X86_64)) && SUPPORTS_LONG_DOUBLE)  // Define IEEEl2bits for long double

/** IEEE2bits for long double; This is used to access various parts of a long double */
typedef union IEEEl2bits {
	long double e;
	struct IEEEl_bits {
		unsigned int manl:32;
		unsigned int manh:32;
		unsigned int exp:15;
		unsigned int sign:1;
		unsigned int junk:16;
	} bits;
} IEEEl2bits;
#   define mask_nbit_l(x)   ((x).bits.manh &= 0x7fffffff)
#   define LDBL_MANH_SIZE   (32)
#   define LDBL_MANL_SIZE   (32)
#   define LDBL_TO_ARRAY32(LDBL_NUM, val32)   do { (val32)[0] = (uint32_t)(LDBL_NUM).bits.manl; (val32)[1] = (uint32_t)(LDBL_NUM).bits.manh; } while(0x0)

#elif (defined(ARM) && SUPPORTS_LONG_DOUBLE)

/** IEEE2bits for long double; This is used to access various parts of a long double */
typedef union IEEEl2bits {
	long double e;
	struct IEEEl_bits {
#   if IS_LITTLE_ENDIAN
		unsigned int manl:32;
		unsigned int manh:20;
		unsigned int exp:11;
		unsigned int sign:1;
#   else
		unsigned int sign:1;
		unsigned int exp:11;
		unsigned int manh:20;
		unsigned int manl:32;
#   endif
	} bits;
} IEEEl2bits;

#define LDBL_NBIT   (0)
#define mask_nbit_l(x)   ((void)0)
#define LDBL_MANH_SIZE   (20)
#define LDBL_MANL_SIZE   (32)
#define LDBL_TO_ARRAY32(LDBL_NUM, val32)   do { (val32)[0] = (uint32_t)(LDBL_NUM).bits.manl; (val32)[1] = (uint32_t)(LDBL_NUM).bits.manh; } while(0x0)

#else
#   error   "Unsupported architecture (union IEEEl2bits)"
#endif


/** IEEE 754 single-precision format */
typedef union ieee754_float {
	float f;
	struct s754f_bits {
#   if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exponent:8;
		unsigned int quiet:1;
		unsigned int significand:22;
#   else  // LITTLE_ENDIAN
		unsigned int significand:22;
		unsigned int quiet:1;
		unsigned int exponent:8;
		unsigned int sign:1;
#   endif
	} s;
	struct ieee754f_bits {
#   if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:8;
		unsigned int mantissa:23;
#   else  // LITTLE_ENDIAN
		unsigned int mantissa:23;
		unsigned int exponent:8;
		unsigned int negative:1;
#   endif
	} ieee;
	struct ieee754f_nan_bits {  // This format makes it easier to see if a NaN is a signalling NaN
#   if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:8;
		unsigned int quiet_nan:1;
		unsigned int mantissa:22;
#   else  // LITTLE_ENDIAN
		unsigned int mantissa:22;
		unsigned int quiet_nan:1;
		unsigned int exponent:8;
		unsigned int negative:1;
#   endif
	} ieee_nan;
} Float;


/** IEEE 754 double-precision format */
typedef union ieee754_double {
	double d;
	struct s754_bits {
#   if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exponent:11;
		unsigned int quiet:1;
		uint64_t significand:51;
#   else  // LITTLE_ENDIAN
		uint64_t significand:51;
		unsigned int quiet:1;
		unsigned int exponent:11;
		unsigned int sign:1;
#   endif
	} s;
	struct ieee754_bits {
#   if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:11;
		unsigned int mantissa0:20;  // Together these make the mantissa
		unsigned int mantissa1:32;
#   else  // LITTLE_ENDIAN
		unsigned int mantissa1:32;
		unsigned int mantissa0:20;
		unsigned int exponent:11;
		unsigned int negative:1;
#   endif
	} ieee;
	struct ieee754_nan_bits {  // This format makes it easier to see if a NaN is a signalling NaN
#   if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:11;
		unsigned int quiet_nan:1;
		unsigned int mantissa0:19;
		unsigned int mantissa1:32;
#   else  // LITTLE_ENDIAN
		unsigned int mantissa1:32;
		unsigned int mantissa0:19;
		unsigned int quiet_nan:1;
		unsigned int exponent:11;
		unsigned int negative:1;
#   endif
	} ieee_nan;
} Double;


#if SUPPORTS_LONG_DOUBLE
/** IEEE 854 quad-precision format

On a PowerPC, a long double is implemented either as two doubles (with -mlong-double-128, the default) or as a single double (with -mlong-double-64, for Unix 2003 compliance). In a long double NaN, the value of the second double (if present) is ignored; Only the significand of the first double is used.

On IA-32, a long double has a different format, with an explicit integer bit in the significand.
*/
typedef union ieee854_long_double {
	long double ld;
	double d;
#ifdef POWERPC
	struct s854_bits {
#      if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exponent:11;
		unsigned int quiet:1;
		uint64_t significand:51;
#         if SUPPORTS_LONG_DOUBLE
		double d;
#         endif
#      else  // LITTLE_ENDIAN
#       if SUPPORTS_LONG_DOUBLE
		double d;
#         endif
		uint64_t significand:51;
		unsigned int quiet:1;
		unsigned int exponent:11;
		unsigned int sign:1;
#      endif
	} s;
#      define LDBL_EXP_BITS   11
#   elif defined(ARM)
	struct s854_bits {
#      if IS_LITTLE_ENDIAN
		uint64_t significand:51;
		unsigned int quiet:1;
		unsigned int exponent:11;
		unsigned int sign:1;
#      else
		unsigned int sign:1;
		unsigned int exponent:11;
		unsigned int quiet:1;
		uint64_t significand:51;
#      endif
	} s;
#      define LDBL_EXP_BITS   11
#   elif (defined(I386) || defined(X86_64))
	struct attr_packed s854_bits {
#      if IS_BIG_ENDIAN
		unsigned int sign:1;
		unsigned int exponent:15;
		unsigned int integer:1;
		unsigned int quiet:1;
		uint64_t significand:62;
#      else  // LITTLE_ENDIAN
		uint64_t significand:62;
		unsigned int quiet:1;
		unsigned int integer:1;
		unsigned int exponent:15;
		unsigned int sign:1;
#      endif
		} s;
#      define LDBL_EXP_BITS   15
#   endif
	struct ieee854_bits {
#      if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:15;
		unsigned int mantissa0:16;  // Together these comprise the mantissa
		unsigned int mantissa1:32;
		unsigned int mantissa2:32;
		unsigned int mantissa3:32;
#      else  // LITTLE_ENDIAN
		unsigned int mantissa3:32;
		unsigned int mantissa2:32;
		unsigned int mantissa1:32;
		unsigned int mantissa0:16;
		unsigned int exponent:15;
		unsigned int negative:1;
#      endif
	} ieee;
	struct ieee854_nan_bits {  // This format makes it easier to see if a NaN is a signalling NaN
#      if IS_BIG_ENDIAN
		unsigned int negative:1;
		unsigned int exponent:15;
		unsigned int quiet_nan:1;
		unsigned int mantissa0:15;
		unsigned int mantissa1:32;
		unsigned int mantissa2:32;
		unsigned int mantissa3:32;
#      else  // LITTLE_ENDIAN
		unsigned int mantissa3:32;
		unsigned int mantissa2:32;
		unsigned int mantissa1:32;
		unsigned int mantissa0:15;
		unsigned int quiet_nan:1;
		unsigned int exponent:15;
		unsigned int negative:1;
#      endif
	} ieee_nan;
} LongDouble;
#endif


#if (SUPPORTS_LONG_DOUBLE && (SIZEOF_LONG_DOUBLE == 128))
/** IBM extended format for long double */
typedef union ibm_extended_long_double {
	long double ld;
	union ieee754_double d[2];
} IBM_Long_Double;
#endif


#endif  // IEEE754_H


/* STANDARD I/O (<stdio.h>) */


#if (!(defined(_STDIO_H) || defined(_STDIO_H_) || defined(_STDIO_IMPL_H) || defined(_STDIO_IMPL_H_) || defined(_STDIO_EXT_H) || defined(_STDIO_EXT_H_)))  // http://www.cplusplus.com/reference/cstdio/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html
#define _STDIO_H   (1)
#define _STDIO_H_   (1)
#define _STDIO_IMPL_H   (1)
#define _STDIO_IMPL_H_   (1)
#define _STDIO_EXT_H   (1)
#define _STDIO_EXT_H_   (1)
#define __STDIO_H__   (1)
#define H_STDIO   (1)
#define _IO_STDIO_H   (1)
#define _G_config_h   (1)


#ifndef _READ_WRITE_RETURN_TYPE
#   define _READ_WRITE_RETURN_TYPE   size_t
#endif
#ifndef _READ_WRITE_BUFSIZE_TYPE
#   define _READ_WRITE_BUFSIZE_TYPE   size_t
#endif
#ifdef __TANDEM  // NonStop Kernel
#   ifndef _IOERR
#      define _IOERR   0x40
#      define _IOREAD   0x80
#      define _IOWRT   4
#      define _IORW   0x100
#   endif
#endif
#define CVT_BUF_SIZE   128
#define NDYNAMIC   4
#define ERRORINDICATOR   1
#define EOFINDICATOR   2
#define BUFINPUT   4
#define BUFLINEWISE   8
#define NOBUF   16
#define STATICBUF   32
#define FDPIPE   64
#define CANREAD   128
#define CANWRITE   256
#define CHECKLINEWISE   512
#define FPARSELN_UNESCESC   1
#define FPARSELN_UNESCCONT   2
#define FPARSELN_UNESCCOMM   4
#define FPARSELN_UNESCREST   8
#define FPARSELN_UNESCALL   0xf
#define __MASK_READING   3U
#define __FLAG_READING   1U
#define __FLAG_UNGOT   2U
#define __FLAG_EOF   4U
#define __FLAG_ERROR   8U
#define __FLAG_WRITEONLY   0x10U
#define __FLAG_READONLY   0x20U
#define __FLAG_WRITING   0x40U
#define __FLAG_NARROW   0x80U
#define __FLAG_FBF   0U
#define __FLAG_LBF   0x100U
#define __FLAG_NBF   0x200U
#define __MASK_BUFMODE   0x300U
#define __FLAG_APPEND   0x400U
#define __FLAG_WIDE   0x800U
#define __FLAG_FREEFILE   0x2000U
#define __FLAG_FREEBUF   0x4000U
#define __FLAG_LARGEFILE   0x8000U
#define __FLAG_FAILED_FREOPEN   __FLAG_LARGEFILE
/** FOPEN_MAX is a minimum maximum, and is the number of streams that stdio can provide without attempting to allocate further resources (which could fail) */
#define FOPEN_MAX   20  // Must be <= OPEN_MAX
#define FILENAME_MAX   1024  // Must be <= PATH_MAX
#define L_tmpnam   1024
#define TMP_MAX   308915776
/** Size for ctermid(); PATH_MAX */
#define L_ctermid   1024
/** Size for cuserid(); UT_NAMESIZE + 1 */
#define L_cuserid   9
static UNUSED FILE* volatile dummy = 0;
#define shcnt(f)   ((f)->shcnt + (off_t)((f)->rpos - (f)->rend))
#define shunget(f)   ((f)->shend ? (void)(f)->rpos-- : (void)0)
/** Test whether the given stdio file has an active ungetc buffer; release such a buffer, without restoring ordinary unread data */
#define HASUB(fp)   ((fp)->_ub._base != NULL)
#define FREEUB(fp)   if ((fp)->_ub._base != (fp)->_ubuf) { free((fp)->_ub._base); } (fp)->_ub._base = NULL;
/** Test for an fgetln() buffer */
#define HASLB(fp)   ((fp)->_lb._base != NULL)
#define FREELB(fp)   free((char*)(fp)->_lb._base); (fp)->_lb._base = NULL;
#define PRINT(ptr, len)   do { if (__SPRINT(data, fp, (ptr), (len)) == EOF) { goto error; } } while (0x0)
#define PAD(howmany, with)   do { if ((n = (howmany)) > 0) { while (n > PADSIZE) { PRINT(with, PADSIZE); n -= PADSIZE; } PRINT(with, n); } } while (0x0)
#define PRINTANDPAD(p, ep, len, with)   do { int n = (ep) - (p); if (n > (len)) { n = (len); } if (n > 0) { PRINT((p), n); } PAD((len) - (n > 0 ? n : 0), (with)); } while (0x0)
// Convenient bit representation for modifier flags
#define ALT_FORM   (1U << ('#' - ' '))
#define ZERO_PAD   (1U << ('0' - ' '))
#define LEFT_ADJ   (1U << ('-' - ' '))
#define PAD_POS   (1U << (' ' - ' '))
#define MARK_POS   (1U << ('+' - ' '))
#define GROUPED   (1U << ('\'' - ' '))
#define FLAGMASK   (ALT_FORM | ZERO_PAD | LEFT_ADJ | PAD_POS | MARK_POS | GROUPED)
#define OOB(x)   (((unsigned)(x) - 'A') > ('z' - 'A'))


// TYPES USED IN POSITIONAL ARGUMENT SUPPORT IN VFPRINF/VFWPRINTF

typedef enum __CH_CLASS {
	CH_ZERO,  // '0'
	DIGIT,  // '1-9'
	DOLLAR,  // '$'
	MODFR,  // spec modifier
	SPEC,  // format specifier
	DOT,  // '.'
	STAR,  // '*'
	FLAG,  // format flag
	OTHER,  // All other chars
	MAX_CH_CLASS  // Place-holder
} CH_CLASS_T;


typedef enum __STATE {
	START,  // Start
	SFLAG,  // Seen a flag
	WDIG,  // Seen digits in width area
	WIDTH,  // Processed width
	SMOD,  // Seen spec modifier
	SDOT,  // Seen dot
	VARW,  // Have variable width specifier
	VARP,  // Have variable precision specifier
	PREC,  // Processed precision
	VWDIG,  // Have digits in variable width specification
	VPDIG,  // Have digits in variable precision specification
	DONE,  // Done
	MAX_STATE  // Place-holder
} STATE_T;


typedef enum __ACTION {
	NOOP,  // Do nothing
	NUMBER,  // Build a number from digits
	SKIPNUM,  // Skip over digits
	GETMOD,  // Get and process format modifier
	GETARG,  // Get and process argument
	GETPW,  // Get variable precision or width
	GETPWB,  // Get variable precision or width and pushback fmt char
	GETPOS,  // Get positional parameter value
	PWPOS  // Get positional parameter value for variable width or precision
} ACTION_T;


static const CH_CLASS_T __chclass[256] = {
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	FLAG, OTHER, OTHER, FLAG, DOLLAR, OTHER, OTHER, FLAG,
	OTHER, OTHER, STAR, FLAG, OTHER, FLAG, DOT, OTHER,
	CH_ZERO, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT, DIGIT,
	DIGIT, DIGIT, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, SPEC, OTHER, SPEC, SPEC, SPEC, SPEC, SPEC,
	OTHER, OTHER, OTHER, OTHER, MODFR, OTHER, OTHER, SPEC,
	OTHER, OTHER, OTHER, SPEC, OTHER, SPEC, OTHER, OTHER,
	SPEC, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, SPEC, OTHER, SPEC, SPEC, SPEC, SPEC, SPEC,
	MODFR, SPEC, MODFR, OTHER, MODFR, OTHER, SPEC, SPEC,
	SPEC, MODFR, OTHER, SPEC, MODFR, SPEC, OTHER, OTHER,
	SPEC, OTHER, MODFR, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER,
	OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER, OTHER
};


static const STATE_T __state_table[MAX_STATE][MAX_CH_CLASS] = {
	/* '0'   '1-9' '$'   MODFR SPEC  '.'    '*'  FLAG  OTHER */
	{ SFLAG, WDIG, DONE, SMOD, DONE, SDOT, VARW, SFLAG, DONE },  // START
	{ SFLAG, WDIG, DONE, SMOD, DONE, SDOT, VARW, SFLAG, DONE },  // SFLAG
	{ DONE, DONE, WIDTH, SMOD, DONE, SDOT, DONE, DONE, DONE },  // WDIG
	{ DONE, DONE, DONE, SMOD, DONE, SDOT, DONE, DONE, DONE },  // WIDTH
	{ DONE, DONE, DONE, DONE, DONE, DONE, DONE, DONE, DONE },  // SMOD
	{ SDOT, PREC, DONE, SMOD, DONE, DONE, VARP, DONE, DONE },  // SDOT
	{ DONE, VWDIG, DONE, SMOD, DONE, SDOT, DONE, DONE, DONE },  // VARW
	{ DONE, VPDIG, DONE, SMOD, DONE, DONE, DONE, DONE, DONE },  // VARP
	{ DONE, DONE, DONE, SMOD, DONE, DONE, DONE, DONE, DONE },  // PREC
	{ DONE, DONE, WIDTH, DONE, DONE, DONE, DONE, DONE, DONE },  // VWDIG
	{ DONE, DONE, PREC, DONE, DONE, DONE, DONE, DONE, DONE }  // VPDIG
};


static const ACTION_T __action_table[MAX_STATE][MAX_CH_CLASS] = {
	/* '0'   '1-9'  '$'    MODFR   SPEC   '.'   '*'   FLAG  OTHER */
	{ NOOP, NUMBER, NOOP, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // START
	{ NOOP, NUMBER, NOOP, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // SFLAG
	{ NOOP, NOOP, GETPOS, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // WDIG
	{ NOOP, NOOP, NOOP, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // WIDTH
	{ NOOP, NOOP, NOOP, NOOP, GETARG, NOOP, NOOP, NOOP, NOOP },  // SMOD
	{ NOOP, SKIPNUM, NOOP, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // SDOT
	{ NOOP, NUMBER, NOOP, GETPW, GETPWB, GETPW, NOOP, NOOP, NOOP },  // VARW
	{ NOOP, NUMBER, NOOP, GETPW, GETPWB, NOOP, NOOP, NOOP, NOOP },  // VARP
	{ NOOP, NOOP, NOOP, GETMOD, GETARG, NOOP, NOOP, NOOP, NOOP },  // PREC
	{ NOOP, NOOP, PWPOS, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP },  // VWDIG
	{ NOOP, NOOP, PWPOS, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP }  // VPDIG
};


static const char sizeprefix['y' - 'a'] = {
	['a' - 'a'] = 'L',
	['e' - 'a'] = 'L',
	['f' - 'a'] = 'L',
	['g' - 'a'] = 'L',
	['d' - 'a'] = 'j',
	['i' - 'a'] = 'j',
	['o' - 'a'] = 'j',
	['u' - 'a'] = 'j',
	['x' - 'a'] = 'j',
	['p' - 'a'] = 'j'
};


/** State machine to accept length modifiers + conversion specifiers; Result is 0 on failure, or an argument type to pop on success */
enum PRINTF_ENUM_VALUES {
	PRINTF_BARE, PRINTF_LPRE, PRINTF_LLPRE, PRINTF_HPRE, PRINTF_HHPRE, PRINTF_BIGLPRE, PRINTF_ZTPRE, PRINTF_JPRE,
	PRINTF_STOP,
	PRINTF_PTR, PRINTF_INT, PRINTF_UINT, PRINTF_ULLONG,
#ifndef LONG_IS_INT
	PRINTF_LONG, PRINTF_ULONG,
#else
#   define PRINTF_LONG   PRINTF_INT
#   define PRINTF_ULONG   PRINTF_UINT
#endif
	PRINTF_SHORT, PRINTF_USHORT, PRINTF_CHAR, PRINTF_UCHAR,
#ifdef ODD_TYPES
	PRINTF_LLONG, PRINTF_SIZET, PRINTF_IMAX, PRINTF_UMAX, PRINTF_PDIFF, PRINTF_UIPTR,
#else
#   define PRINTF_LLONG   PRINTF_ULLONG
#   define PRINTF_SIZET   PRINTF_ULONG
#   define PRINTF_IMAX   PRINTF_LLONG
#   define PRINTF_UMAX   PRINTF_ULLONG
#   define PRINTF_PDIFF   PRINTF_LONG
#   define PRINTF_UIPTR   PRINTF_ULONG
#endif
	PRINTF_DBL, PRINTF_LDBL,
	PRINTF_NOARG, PRINTF_MAXSTATE
};


#define sub_ascii_a(x)   [(x) - 'A']


static const UNUSED unsigned char printf_states[]['z' - 'A' + 1] = {
	{ // 0: bare types
		sub_ascii_a('d') = PRINTF_INT,
		sub_ascii_a('i') = PRINTF_INT,
		sub_ascii_a('o') = PRINTF_UINT,
		sub_ascii_a('u') = PRINTF_UINT,
		sub_ascii_a('x') = PRINTF_UINT,
		sub_ascii_a('X') = PRINTF_UINT,
		sub_ascii_a('e') = PRINTF_DBL,
		sub_ascii_a('f') = PRINTF_DBL,
		sub_ascii_a('g') = PRINTF_DBL,
		sub_ascii_a('a') = PRINTF_DBL,
		sub_ascii_a('E') = PRINTF_DBL,
		sub_ascii_a('F') = PRINTF_DBL,
		sub_ascii_a('G') = PRINTF_DBL,
		sub_ascii_a('A') = PRINTF_DBL,
		sub_ascii_a('c') = PRINTF_CHAR,
		sub_ascii_a('C') = PRINTF_INT,
		sub_ascii_a('s') = PRINTF_PTR,
		sub_ascii_a('S') = PRINTF_PTR,
		sub_ascii_a('p') = PRINTF_UIPTR,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('m') = PRINTF_NOARG,
		sub_ascii_a('l') = PRINTF_LPRE,
		sub_ascii_a('h') = PRINTF_HPRE,
		sub_ascii_a('L') = PRINTF_BIGLPRE,
		sub_ascii_a('z') = PRINTF_ZTPRE,
		sub_ascii_a('j') = PRINTF_JPRE,
		sub_ascii_a('t') = PRINTF_ZTPRE
	}, { // 1: l-prefixed
		sub_ascii_a('d') = PRINTF_LONG,
		sub_ascii_a('i') = PRINTF_LONG,
		sub_ascii_a('o') = PRINTF_ULONG,
		sub_ascii_a('u') = PRINTF_ULONG,
		sub_ascii_a('x') = PRINTF_ULONG,
		sub_ascii_a('X') = PRINTF_ULONG,
		sub_ascii_a('e') = PRINTF_DBL,
		sub_ascii_a('f') = PRINTF_DBL,
		sub_ascii_a('g') = PRINTF_DBL,
		sub_ascii_a('a') = PRINTF_DBL,
		sub_ascii_a('E') = PRINTF_DBL,
		sub_ascii_a('F') = PRINTF_DBL,
		sub_ascii_a('G') = PRINTF_DBL,
		sub_ascii_a('A') = PRINTF_DBL,
		sub_ascii_a('c') = PRINTF_INT,
		sub_ascii_a('s') = PRINTF_PTR,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('l') = PRINTF_LLPRE
	}, { // 2: ll-prefixed
		sub_ascii_a('d') = PRINTF_LLONG,
		sub_ascii_a('i') = PRINTF_LLONG,
		sub_ascii_a('o') = PRINTF_ULLONG,
		sub_ascii_a('u') = PRINTF_ULLONG,
		sub_ascii_a('x') = PRINTF_ULLONG,
		sub_ascii_a('X') = PRINTF_ULLONG,
		sub_ascii_a('n') = PRINTF_PTR
	}, { // 3: h-prefixed
		sub_ascii_a('d') = PRINTF_SHORT,
		sub_ascii_a('i') = PRINTF_SHORT,
		sub_ascii_a('o') = PRINTF_USHORT,
		sub_ascii_a('u') = PRINTF_USHORT,
		sub_ascii_a('x') = PRINTF_USHORT,
		sub_ascii_a('X') = PRINTF_USHORT,
		sub_ascii_a('n') = PRINTF_PTR,
		sub_ascii_a('h') = PRINTF_HHPRE
	}, { // 4: hh-prefixed
		sub_ascii_a('d') = PRINTF_CHAR,
		sub_ascii_a('i') = PRINTF_CHAR,
		sub_ascii_a('o') = PRINTF_UCHAR,
		sub_ascii_a('u') = PRINTF_UCHAR,
		sub_ascii_a('x') = PRINTF_UCHAR,
		sub_ascii_a('X') = PRINTF_UCHAR,
		sub_ascii_a('n') = PRINTF_PTR
	}, { // 5: L-prefixed
		sub_ascii_a('e') = PRINTF_LDBL,
		sub_ascii_a('f') = PRINTF_LDBL,
		sub_ascii_a('g') = PRINTF_LDBL,
		sub_ascii_a('a') = PRINTF_LDBL,
		sub_ascii_a('E') = PRINTF_LDBL,
		sub_ascii_a('F') = PRINTF_LDBL,
		sub_ascii_a('G') = PRINTF_LDBL,
		sub_ascii_a('A') = PRINTF_LDBL,
		sub_ascii_a('n') = PRINTF_PTR
	}, { // 6: z- or t-prefixed (assumed to be same size)
		sub_ascii_a('d') = PRINTF_PDIFF,
		sub_ascii_a('i') = PRINTF_PDIFF,
		sub_ascii_a('o') = PRINTF_SIZET,
		sub_ascii_a('u') = PRINTF_SIZET,
		sub_ascii_a('x') = PRINTF_SIZET,
		sub_ascii_a('X') = PRINTF_SIZET,
		sub_ascii_a('n') = PRINTF_PTR
	}, { // 7: j-prefixed
		sub_ascii_a('d') = PRINTF_IMAX,
		sub_ascii_a('i') = PRINTF_IMAX,
		sub_ascii_a('o') = PRINTF_UMAX,
		sub_ascii_a('u') = PRINTF_UMAX,
		sub_ascii_a('x') = PRINTF_UMAX,
		sub_ascii_a('X') = PRINTF_UMAX,
		sub_ascii_a('n') = PRINTF_PTR
	}
};


#if ((!defined(__rtems__)) && (!defined(__tirtos__)))
#   define _STDIO_CLOSE_PER_REENT_STD_STREAMS   (1)
#endif
#if (SUPPORTS_THREADS && defined(_POSIX_THREADS) && (!defined(__rtems__)))
#   define _STDIO_WITH_THREAD_CANCELLATION_SUPPORT   (1)
#endif
#if (!SUPPORTS_THREADS)
#   define __sfp_lock_acquire()
#   define __sfp_lock_release()
#   define __sinit_lock_acquire()
#   define __sinit_lock_release()
#   define __fp_lock(ptr)
#   define __fp_unlock(ptr)
#   define __fp_lock_all()
#   define __fp_unlock_all()
#else
#   define __sfp_lock_acquire()   __lock_acquire_recursive(__sfp_lock)
#   define __sfp_lock_release()   __lock_release_recursive(__sfp_lock)
#   define __sinit_lock_acquire()   __lock_acquire_recursive(__sinit_lock)
#   define __sinit_lock_release()   __lock_release_recursive(__sinit_lock)
/** Walkable file locking routine */
#   define __fp_lock(ptr)   if (!((FILE*)ptr->flags2 & __SNLK)) { flockfile((FILE*)ptr); } return 0
/** Walkable file unlocking routine */
#   define __fp_unlock(ptr)   if (!((FILE*)ptr->flags2 & __SNLK)) { funlockfile((FILE*)ptr); } return 0
#   define __fp_lock_all()   __sfp_lock_acquire(); (void)_fwalk(_REENT, __fp_lock)
#   define __fp_unlock_all()   (void)_fwalk(_REENT, __fp_unlock); __sfp_lock_release()
#endif
#if ((!SUPPORTS_THREADS) || defined(__IMPL_UNLOCKED__))
#   define _flockfile_start(_fp)
#   define _flockfile_exit(_fp)
#   define _flockfile_end(_fp)
#   define _sfp_lock_start()
#   define _sfp_lock_exit()
#   define _sfp_lock_end()
#elif defined(_STDIO_WITH_THREAD_CANCELLATION_SUPPORT)
/** Exit from a stream oriented critical section prematurely */
#   define _flockfile_exit(_fp)   if (!(_fp->flags2 & __SNLK)) { funlockfile(_fp); } pthread_setcancelstate(__oldfpcancel, &__oldfpcancel);
/** End a stream oriented critical section */
#   define _flockfile_end(_fp)   if (!(_fp->flags2 & __SNLK)) { funlockfile(_fp); } pthread_setcancelstate(__oldfpcancel, &__oldfpcancel);
/** Start a stream oriented critical section */
#   define _flockfile_start(_fp)   int __oldfpcancel; pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &__oldfpcancel); if (!(_fp->flags2 & __SNLK)) { flockfile(_fp) } _flockfile_exit(_fp); _flockfile_end(_fp)
/** Exit from a stream list oriented critical section prematurely */
#   define _sfp_lock_exit()   __sfp_lock_release(); pthread_setcancelstate(__oldsfpcancel, &__oldsfpcancel)
/** End a stream list oriented critical section */
#   define _sfp_lock_end()   __sfp_lock_release(); pthread_setcancelstate(__oldsfpcancel, &__oldsfpcancel)
/** Start a stream list oriented critical section */
#   define _sfp_lock_start()   int __oldsfpcancel; pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &__oldsfpcancel); __sfp_lock_acquire(); _sfp_lock_exit(); _sfp_lock_end()
#else
#   define _flockfile_start(_fp)   if (!(_fp->flags2 & __SNLK)) { flockfile(_fp); }
#   define _flockfile_exit(_fp)   if (!(_fp->flags2 & __SNLK)) { funlockfile(_fp); }
#   define _flockfile_end(_fp)   if (!(_fp->flags2 & __SNLK)) { funlockfile(_fp); }
#   define _sfp_lock_start()   __sfp_lock_acquire()
#   define _sfp_lock_exit()   __sfp_lock_release()
#   define _sfp_lock_end()   __sfp_lock_release()
#endif


#ifdef _WIDE_ORIENT
/** Set the orientation for a stream; If o > 0, the stream has wide-orientation; If o < 0, the stream has byte-orientation */
#   define ORIENT(fp, ori)   do { if (!((fp)->flags & (unsigned int)__SORD)) { (fp)->flags |= (unsigned int)__SORD; if (ori > 0) { (fp)->flags2 |= (unsigned int)__SWID; } else { (fp)->flags2 &= (unsigned int)(~__SWID); } } } while (0x0)
#else
#   define ORIENT(fp, ori)
#endif


#ifndef  _PRINTF_H
#define  _PRINTF_H   (1)


#ifndef BLOCK_OUT
#   define BLOCK_OUT   (-2)
#endif
#define _G_HAVE_MMAP   1
#define _G_HAVE_MREMAP   1
#define _G_IO_IO_FILE_VERSION   0x20001
#define _G_HAVE_ST_BLKSIZE   _STATBUF_ST_BLKSIZE
#define _G_BUFSIZ   8192
#define _IO_seek_set   0
#define _IO_seek_cur   1
#define _IO_seek_end   2
#define _IOS_INPUT   1
#define _IOS_OUTPUT   2
#define _IOS_ATEND   4
#define _IOS_APPEND   8
#define _IOS_TRUNC   16
#define _IOS_NOCREATE   32
#define _IOS_NOREPLACE   64
#define _IOS_BIN   128
#define _IO_UNIFIED_JUMPTABLES   1
/** Magic number */
#define _IO_MAGIC   0xFBAD0000
/** Emulate old stdio */
#define _OLD_STDIO_MAGIC   0xFABC0000
#define _IO_MAGIC_MASK   0xFFFF0000
/** User owns buffer; do not delete it on close */
#define _IO_USER_BUF   1
#define _IO_UNBUFFERED   2
/** Reading not allowed */
#define _IO_NO_READS   4
/** Writing not allowd */
#define _IO_NO_WRITES   8
#define _IO_EOF_SEEN   0x10
#define _IO_ERR_SEEN   0x20
/** Do not call close(_fileno) on cleanup */
#define _IO_DELETE_DONT_CLOSE   0x40
/** Set if linked (using _chain) to streambuf::_list_all */
#define _IO_LINKED   0x80
#define _IO_IN_BACKUP   0x100
#define _IO_LINE_BUF   0x200
/** Set if put and get pointer logicly tied */
#define _IO_TIED_PUT_GET   0x400
#define _IO_CURRENTLY_PUTTING   0x800
#define _IO_IS_APPENDING   0x1000
#define _IO_IS_FILEBUF   0x2000
#define _IO_BAD_SEEN   0x4000
#define _IO_USER_LOCK   0x8000
#define _IO_FLAGS2_MMAP   1
#define _IO_FLAGS2_NOTCANCEL   2
#define _IO_FLAGS2_FORTIFY   4
#define _IO_FLAGS2_USER_WBUF   8
#define _IO_FLAGS2_SCANF_STD   16
#define _IO_FLAGS2_NOCLOSE   32
#define _IO_FLAGS2_CLOEXEC   64
#define _IO_SKIPWS   1
#define _IO_LEFT   2
#define _IO_RIGHT   4
#define _IO_INTERNAL   010
#define _IO_DEC   020
#define _IO_OCT   040
#define _IO_HEX   0100
#define _IO_SHOWBASE   0200
#define _IO_SHOWPOINT   0400
#define _IO_UPPERCASE   01000
#define _IO_SHOWPOS   02000
#define _IO_SCIENTIFIC   04000
#define _IO_FIXED   010000
#define _IO_UNITBUF   020000
#define _IO_STDIO   040000
#define _IO_DONT_CLOSE   0100000
#define _IO_BOOLALPHA   0200000
// Flag bits that can be set in a type returned by `parse_printf_format`
#define PA_FLAG_MASK   (0xff00)
#define PA_FLAG_LONG_LONG   (0x100)
#define PA_FLAG_LONG_DOUBLE   PA_FLAG_LONG_LONG
#define PA_FLAG_LONG   (0x200)
#define PA_FLAG_SHORT   (0x400)
#define PA_FLAG_PTR   (0x800)
#define _G_IO_NO_BACKWARD_COMPAT   1
#define _IO_JUMPS_OFFSET   0
#define _IO_HAVE_ST_BLKSIZE   _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ   _G_BUFSIZ


typedef union printf_arg {
	uintmax_t i;
	long double f;
	void* p;
} printf_arg_t;


LIB_FUNC size_t sn_write(FILE* f, const unsigned char* s, const size_t l) {
	register size_t k = (size_t)((f->wend) - (f->wpos));
	if (k > l) { k = l; }
	memcpy_no_output(f->wpos, s, k);
	f->wpos += k;
	return l;
}


LIB_FUNC size_t sw_write(FILE* f, const unsigned char* s, const size_t l) {
	const size_t l0 = l;
	register size_t l1 = l, i = 0;
	struct cookie* c = f->_cookie;
	if ((s != f->wbase) && (sw_write(f, f->wbase, (size_t)(f->wpos - f->wbase)) == (size_t)-1)) {
		return (size_t)-1;
	}
	while (c->l && l1 && (i = (size_t)(mbtowc(c->ws, (const void*)s, l1) >= 0))) {
		s += i;
		l1 -= i;
		c->l--;
		c->ws++;
	}
	*c->ws = 0;
	return (size_t)(i <= 1 ? i : l0);
}


LIB_FUNC size_t sw_write_helper(void* f, const unsigned char* buf, const size_t len) {
	return sw_write((FILE*)f, buf, len);
}


LIB_FUNC size_t wrap_write(void* f, const unsigned char* buf, const size_t len) {
	return __stdio_write((FILE*)f, buf, len);
}


LIB_FUNC int __towrite(FILE* f) {
	f->mode |= (signed char)(f->mode - (signed char)1);
	if (f->flags & (unsigned int)(F_NOWR)) {
		f->flags |= (unsigned int)F_ERR;
		return EOF;
	}
	f->rpos = f->rend = 0;
	f->wpos = f->wbase = f->buf;
	f->wend = (f->buf + f->buf_size);
	return 0;
}


LIB_FUNC int __overflow(FILE* f, const int _c) {
	unsigned char c = (unsigned char)_c;
	if (!f->wend && __towrite(f)) { return EOF; }
	else if (f->wpos < f->wend && (c != f->lbf)) { return *f->wpos++ = c; }
	else if (f->write(f, &c, 1) != 1) { return EOF; }
	return (int)c;
}


/** Writes to file, but requires that the string end in '\n' (not counting the NULL terminator) */
LIB_FUNC size_t __fwritex(const unsigned char* restrict s, const size_t len, FILE* restrict f) {
	register size_t l = len, i = 0;
	if (!f->wend && __towrite(f)) { return 0; }
	else if (l > (size_t)(f->wend - f->wpos)) { return f->write(f, s, l); }
	else if (f->lbf >= 0) {
		for (i = l; i && (s[i - 1] != '\n'); i--);
		if (i) {
			register size_t n = f->write(f, s, i);
			if (n < i) { return n; }
			s += i;
			l -= i;
		}
	}
	memcpy_no_output(f->wpos, s, l);
	f->wpos += l;
	return (size_t)(l + i);
}


/** Version of write which resumes after a signal is caught */
LIB_FUNC int xwrite(const int fd, char* buf, const int nbytes) {
	register int ntry = 0, i, n = nbytes;
	for (;;) {
		i = (int)write(fd, buf, (size_t)n);
		if (i > 0) {
			if ((n -= i) <= 0) { return nbytes; }
			buf += i;
			ntry = 0;
		} else if (i == 0) {
			if (++ntry > 10) { return nbytes - n; }
		} else if (errno != EINTR) { return -1; }
	}
}


LIB_FUNC ssize_t REGPARM(1) __write1(const char* s) {
	return write(1, s, strlen(s));
}


LIB_FUNC ssize_t REGPARM(1) __write2(const char* s) {
	return write(2, s, strlen(s));
}


LIB_FUNC void out_char(FILE* f, const char* s, const size_t len) {
	if (!(f->flags & (unsigned int)F_ERR)) { __stdio_write(f, (const unsigned char*)s, len); }
}


LIB_FUNC void out_wchar(FILE* f, const wchar_t* s, size_t l) {
	while (l-- && !(f->flags & (unsigned int)F_ERR)) { fputwc(*s++, f); }
}


LIB_FUNC void pad_char(FILE* f, const char c, const int w, int l, const int _fl) {
	if (_fl & (int)(LEFT_ADJ | ZERO_PAD) || l >= w) { return; }
	char pad[256] = { 0 };
	l = w - l;
	memset_no_output(pad, c, (size_t)(((size_t)l) > sizeof(pad) ? sizeof(pad) : ((size_t)l)));
	for (; l >= (int)sizeof(pad); l -= (int)sizeof(pad)) { out_char(f, pad, sizeof(pad)); }
	out_char(f, pad, (size_t)l);
}


LIB_FUNC int getint(const char** s) {
	register int i;
	for (i = 0; isdigit(**s); (*s)++) { i = (10 * i + (**s - '0')); }
	return i;
}


LIB_FUNC int getint_nonconst(char** s) {
	register int i;
	for (i = 0; isdigit(**s); (*s)++) { i = (10 * i + (**s - '0')); }
	return i;
}


LIB_FUNC int getintw(wchar_t** s) {
	register int i;
	for (i = 0; iswdigit(**s); (*s)++) { i = 10 * i + (**s - '0'); }
	return i;
}


LIB_FUNC size_t fwrite(const void* restrict src, const size_t size, const size_t nmemb, FILE* restrict f) {
	register size_t l = (size * nmemb), _nmemb = nmemb;
	if (!size) { _nmemb = 0; }
	FLOCK(f);
	size_t k = __stdio_write(f, src, l);
	FUNLOCK(f);
	return (size_t)(k == l ? _nmemb : k / size);
}
#define fwrite_unlocked(src, size, nmemb, f)   fwrite((src), (size), (nmemb), (f))


LIB_FUNC int __fwrite(const void* restrict ptr, const size_t nmemb, FILE* restrict f) {
	return (int)fwrite(ptr, 1, nmemb, f);
}


LIB_FUNC int __fwrite_helper(const void* ptr, const size_t nmemb, void* f) {
	return (int)fwrite((const void* restrict)ptr, 1, nmemb, (FILE* restrict)f);
}


LIB_FUNC char* fmt_x(const uintmax_t x, char* s, const int lower) {
	register uintmax_t y = x;
	for (; y; y >>= 4) { *--s = (char)((int)xdigits[(y & 15)] | lower); }
	return s;
}


LIB_FUNC char* fmt_o(const uintmax_t x, char* s) {
	register uintmax_t y = x;
	for (; y; y >>= 3) { *--s = (char)('0' + (char)(y & 7)); }
	return s;
}


LIB_FUNC char* fmt_u(const uintmax_t x, char* s) {
	register unsigned long y;
	register uintmax_t z = x;
	for (; z > ULONG_MAX; z /= 10) { *--s = (char)('0' + (char)(z % 10)); }
	for (y = (unsigned long)z; y; y /= 10) { *--s = (char)('0' + (char)(y % 10)); }
	return s;
}


#ifdef COMPILER_CLANG
#   pragma clang diagnostic push
#   pragma clang diagnostic ignored "-Wstrict-overflow"
#elif defined(COMPILER_GNUC)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wstrict-overflow"
#endif


LIB_FUNC int fmt_fp(FILE* f, long double y, int w, int p, const int _fl, int t) {
	uint32_t big[(LDBL_MANT_DIG + 28) / 29 + 1 + (LDBL_MAX_EXP + LDBL_MANT_DIG + 36) / 9] = { 0 }; // exponent expansion
	uint32_t *a, *d, *r, *z;
	int e2 = 0, pl = 1, e, i, j, l;
	char buf[(9 + LDBL_MANT_DIG) >> 2] = { 0 };
	const char* prefix = "-0X+0X 0X-0x+0x 0x";
	char ebuf0[3 * SIZEOF_INT] = { 0 }, *ebuf = &ebuf0[3 * SIZEOF_INT], *estr;
	if (signbitl(y)) { y = -y; }
	else if (_fl & (signed)MARK_POS) { prefix += 3; }
	else if (_fl & (signed)PAD_POS) { prefix += 6; }
	else { prefix++; pl = 0; }
	char* s;
	char inf_str[4][4] = { "nan", "NAN", "inf", "INF" };
	if (!isfinitel(y)) {
		if (y != y) { s = ((t & 32) ? inf_str[0] : inf_str[1]); }
		else { s = ((t & 32) ? inf_str[2] : inf_str[3]); }
		pad_char(f, ' ', w, (3 + pl), (int)(_fl & (int)(~ZERO_PAD)));
		out_char(f, prefix, (size_t)pl);
		out_char(f, (const char*)s, 3);
		pad_char(f, ' ', w, (3 + pl), (int)(_fl ^ (int)LEFT_ADJ));
		return MAX(w, (3 + pl));
	}
	y = frexpl(y, &e2) * 2;
	if (y) { --e2; }
	if ((t | 32) == 'a') {
		long double round = 8.0L;
		register int re;
		if (t & 32) { prefix += 9; }
		pl += 2;
		if (p < 0 || p >= ((LDBL_MANT_DIG >> 2) - 1)) { re = 0; }
		else { re = (LDBL_MANT_DIG >> 2) - 1 - p; }
		if (re) {
			while (re--) { round *= 16; }
			if (*prefix == '-') {
				y = -y;
				y -= round;
				y += round;
				y = -y;
			} else {
				y += round;
				y -= round;
			}
		}
		estr = fmt_u((uintmax_t)(e2 < 0 ? -e2 : e2), ebuf);
		if (estr == ebuf) { *--estr = '0'; }
		*--estr = (e2 < 0 ? '-' : '+');
		*--estr = (char)(t + ('p' - 'a'));
		s = buf;
		do {
			int x = (int)y;
			*s++ = (char)(hexdigits[x] | (t & 32));
			y = 16 * (y - x);
			if (s - buf == 1 && (y || p > 0 || (_fl & (int)ALT_FORM))) { *s++ = '.'; }
		} while (y);
		if (p && (s - buf - 2) < p) { l = (int)((p + 2) + (ebuf - estr)); }
		else { l = (int)((s - buf) + (ebuf - estr)); }
		pad_char(f, ' ', w, (pl + l), (int)_fl);
		out_char(f, prefix, (size_t)pl);
		pad_char(f, '0', w, (pl + l), (int)(_fl ^ (int)ZERO_PAD));
		out_char(f, buf, (size_t)(s - buf));
		pad_char(f, '0', (int)(l - (ebuf - estr) - (s - buf)), 0, 0);
		out_char(f, estr, (size_t)(ebuf - estr));
		pad_char(f, ' ', w, (pl + l), (int)(_fl ^ (int)LEFT_ADJ));
		return MAX(w, (pl + l));
	}
	if (p < 0) { p = 6; }
	if (y) { y *= 0x1p28; e2 -= 28; }
	if (e2 < 0) { a = r = z = big; }
	else { a = r = z = big + sizeof(big) / sizeof(*big) - LDBL_MANT_DIG - 1; }
	do {
		*z = (uint32_t)y;
		y = 1000000000 * (y - *z++);
	} while (y);
	register uint32_t carry;
	while (e2 > 0) {
		carry = 0;
		int sh = MIN(29, e2);
		for (d = z - 1; d >= a; d--) {
			uint64_t x = ((uint64_t)*d << sh) + carry;
			*d = (uint32_t)(x % 1000000000);
			carry = (uint32_t)(x / 1000000000);
		}
		if (carry) { *--a = carry; }
		while (z > a && !(z[-1])) { z--; }
		e2 -= sh;
	}
	while (e2 < 0) {
		carry = 0;
		uint32_t* b;
		const int sh = MIN(9, -e2);
		const int need = (1 + (p + LDBL_MANT_DIG / 3 + 8) / 9);
		for (d = a; d < z; d++) {
			uint32_t rm = (uint32_t)((*d & (uint32_t)(1 << sh)) - 1);
			*d = (*d >> sh) + carry;
			carry = (uint32_t)((uint32_t)(1000000000 >> sh) * rm);
		}
		if (!*a) { ++a; }
		if (carry) { *z++ = carry; }
		b = (((t | 32) == 'f') ? r : a);
		if (z - b > need) { z = b + need; }
		e2 += sh;
	}
	if (a < z) { for (i = 10, e = (int)(9 * (int)(r - a)); *a >= (uint32_t)i; i *= 10, e++); }
	else { e = 0; }
	// Perform rounding: j is precision after the radix (possibly neg)
	j = p - ((t | 32) != 'f') * e - ((t | 32) == 'g' && p);
	if (j < (9 * (z - r - 1))) {
		uint32_t x;
		d = r + 1 + ((j + 9 * LDBL_MAX_EXP) / 9 - LDBL_MAX_EXP);
		j += 9 * LDBL_MAX_EXP;
		j %= 9;
		for (i = 10, j++; j < 9; i *= 10, j++);
		x = *d % (uint32_t)i;
		if (x || d + 1 != z) {  // Significant digits past j
			long double round = (long double)(2.0L / LDBL_EPSILON);
			long double small;
			if (*d / (uint32_t)i & 1) { round += 2; }
			if (x < (uint32_t)(i / 2)) { small = 0x0.8p0; }
			else if (x == (uint32_t)(i >> 1) && ((d + 1) == z)) { small = 0x1.0p0; }
			else { small = 0x1.8p0; }
			if (pl && *prefix == '-') { round *= -1, small *= -1; }
			*d -= x;
			if (round + small != round) {  // Decide whether to round by probing round+small
				*d = *d + (uint32_t)i;
				while (*d > 999999999) {
					*d-- = 0;
					if (d < a) { *--a = 0; }
					(*d)++;
				}
				for (i = 10, e = (int)((9 * (r - a))); *a >= (uint32_t)i; i *= 10, e++);
			}
		}
		if (z > d + 1) { z = d + 1; }
	}
	for (; z > a && !(z[-1]); z--);
	if ((char)(t | 32) == 'g') {
		if (!p) { p++; }
		if (p > e && e >= -4) {
			--t;
			p -= e + 1;
		} else {
			t -= 2;
			p--;
		}
		if (!(_fl & (int)ALT_FORM)) {  // Count trailing zeros in last place
			if (z > a && z[-1]) { for (i = 10, j = 0; z[-1] % (uint32_t)i == 0; i *= 10, j++); }
			else { j = 9; }
			if ((char)(t | 32) == 'f') { p = (int)MIN(p, (int)MAX(0, (int)(9 * (z - r - 1) - j))); }
			else { p = (int)MIN(p, (int)MAX(0, (int)(9 * (z - r - 1) + e - j))); }
		}
	}
	l = (int)(1 + p + (p || (_fl & (int)ALT_FORM)));
	if ((char)(t | 32) == 'f') { if (e > 0) { l += e; } }
	else {
		estr = fmt_u((uintmax_t)(e < 0 ? -e : e), ebuf);
		while ((ebuf - estr) < 2) { *--estr = '0'; }
		*--estr = (char)(e < 0 ? '-' : '+');
		*--estr = (char)t;
		l += (int)(ebuf - estr);
	}
	pad_char(f, ' ', w, (pl + l), _fl);
	out_char(f, prefix, (size_t)pl);
	pad_char(f, '0', w, (pl + l), (int)(_fl ^ (int)ZERO_PAD));
	if ((char)(t | 32) == 'f') {
		if (a > r) { a = r; }
		for (d = a; d <= r; d++) {
			char* s = fmt_u(*d, (buf + 9));
			if (d != a) { while (s > buf) { *--s = '0'; } }
			else if (s == (buf + 9)) { *--s = '0'; }
			out_char(f, s, (size_t)(buf + 9 - s));
		}
		if (p || (_fl & (int)ALT_FORM)) { out_char(f, ".", 1); }
		for (; d < z && p > 0; d++, p -= 9) {
			char* s = fmt_u(*d, (buf + 9));
			while (s > buf) { *--s = '0'; }
			out_char(f, s, (size_t)(MIN(9, p)));
		}
		pad_char(f, '0', (p + 9), 9, 0);
	} else {
		if (z <= a) { z = a + 1; }
		for (d = a; (d < z) && (p >= 0); d++) {
			char* s = fmt_u(*d, (buf + 9));
			if (s == buf + 9) { *--s = '0'; }
			if (d != a) { while (s > buf) { *--s = '0'; } }
			else {
				out_char(f, s++, 1);
				if (p > 0 || (_fl & (int)ALT_FORM)) { out_char(f, ".", 1); }
			}
			out_char(f, s, (size_t)MIN((int)(buf + 9 - s), p));
			p -= (int)(buf + 9 - s);
		}
		pad_char(f, '0', (p + 18), 18, 0);
		out_char(f, estr, (size_t)(ebuf - estr));
	}
	pad_char(f, ' ', w, (pl + l), (int)(_fl ^ (int)LEFT_ADJ));
	return MAX(w, (pl + l));
}


#ifdef COMPILER_CLANG
#   pragma clang diagnostic pop
#elif defined(COMPILER_GNUC)
#   pragma GCC diagnostic pop
#endif


LIB_FUNC Rune* runefmtstrflush(Fmt* f) {
	if (f->start == NULL) { return NULL; }
	*(Rune*)f->to = '\0';
	return f->start;
}


LIB_FUNC char* fmtstrflush(Fmt* f) {
	if(f->start == NULL) { return NULL; }
	*(char*)f->to = '\0';
	// f->to = f->start;
	return (char*)f->start;
}


LIB_FUNC int runeFmtStrFlush(Fmt* f) {
	Rune* s;
	register size_t n = (size_t)f->farg;
	n += 256;
	f->farg = (void*)n;
	s = (Rune*)f->start;
	f->start = realloc(s, (size_t)(SIZEOF_RUNE * n));
	if (f->start == NULL) {
		f->start = s;
		return 0;
	}
	f->to = (Rune*)f->start + ((Rune*)f->to - s);
	f->stop = (Rune*)f->start + n - 1;
	return 1;
}


LIB_FUNC int fmtStrFlush(Fmt* f) {
	register size_t n = (size_t)f->farg;
	n += 256;
	f->farg = (void*)n;
	char* s = (char*)f->start;
	f->start = realloc(s, n);
	if (f->start == NULL) {
		f->start = s;
		return 0;
	}
	f->to = (char*)f->start + ((char*)f->to - s);
	f->stop = (char*)f->start + n - 1;
	return 1;
}


LIB_FUNC int runefmtstrinit(Fmt* f) {
	f->runes = 1;
	const size_t n = 32;
	f->start = malloc((size_t)(SIZEOF_RUNE * n));
	if (f->start == NULL) { return -1; }
	f->to = f->start;
	f->stop = (Rune*)f->start + n - 1;
	f->flush = runeFmtStrFlush;
	f->farg = (void*)n;
	f->nfmt = 0;
	return 0;
}


LIB_FUNC int fmtstrinit(Fmt* f) {
	f->runes = 0;
	const size_t n = 32;
	f->start = malloc(n);
	if (f->start == NULL) { return -1; }
	f->to = f->start;
	f->stop = (char*)f->start + n - 1;
	f->flush = fmtStrFlush;
	f->farg = (void*)n;
	f->nfmt = 0;
	return 0;
}


struct arg_printf {
	void* data;
	int (*put)(const void*, const size_t, void*);
};


#define V_PRINTF_MAX_WIDTH   10240
#define A_WRITE(fn, buf, sz)   ((fn)->put((const void*)(buf), (size_t)(sz), (fn)->data))
#define B_WRITE(fn, buf, sz)   do { if ((unsigned long)(sz) > (((unsigned long)(int)(-1)) >> 1) || (unsigned int)len + (unsigned int)sz < (unsigned int)len) { return -1; } A_WRITE(fn, buf, sz); } while (0x0)


static const UNUSED char pad_line[2][16] = { "                ", "0000000000000000" };


LIB_FUNC unsigned long skip_to(const char* format) {
	register unsigned long nr;
	for (nr = 0; format[nr] && (format[nr] != '%'); ++nr);
	return nr;
}


LIB_FUNC int write_pad(unsigned int* dlen, struct arg_printf* fn, const unsigned int length, const int padwith) {
	register unsigned int len = length;
	if ((int)len <= 0) { return 0; }
	else if ((*dlen + len) < len) { return -1; }
	register int nr = 0;
	for (; len > 15; len -= 16, nr += 16) {
		A_WRITE(fn, pad_line[(padwith == '0') ? 1 : 0], 16);
	}
	if (len > 0) {
		A_WRITE(fn, pad_line[(padwith == '0') ? 1 : 0], (unsigned int)len);
		nr = nr + (int)len;
	}
	*dlen += (unsigned int)nr;
	return 0;
}


/** Main printf function
@section Defines
 - NO_PRINT_M: The `m` (error code) symbol is disabled
 - NO_PRINT_FLOATS: The `f` and `g` (float-points) symbols are disabled
 - NO_PRINT_INTS: All integer-related symbols are disabled
*/
LIB_FUNC int __v_printf(struct arg_printf* fn, const char* format, va_list arg_ptr) {
	unsigned int len = 0;
	while (*format) {
		unsigned long sz = skip_to(format);
		if (sz) {
			B_WRITE(fn, format, sz);
			len += (unsigned int)sz;
			format += sz;
		}
		if (*format == '%') {
			char buf[128] = { 0 };
			union { const char* s; char* s_constr; } u_str;
#   define s   u_str.s
			unsigned char _ch, padwith = ' ', precpadwith = ' ';
			char flag_in_sign = 0, flag_hash = 0;
			char flag_left = 0, flag_space = 0, flag_sign = 0, flag_dot = 0;
			signed char flag_long = 0;
			unsigned int width = 0, preci = 0;
			long tmpl;
			int tmpi, todo = 0;
#   ifndef NO_PRINT_INTS
			char flag_upcase = 0;
			register int retval;
			unsigned int base;
			long number = 0;
			long long llnumber = 0;
#   endif
#   ifndef NO_PRINT_FLOATS
			char *tmp, *tmp1;
			double d;
			register int g;
#   endif
			const char* sign;
			++format;
inn_printf:
			switch (_ch = (unsigned char)(*format++)) {
				case 0:
					return -1;
					break;
				// FLAGS
				case '#':
					flag_hash = -1;
				case 'h':
					--flag_long;
					goto inn_printf;
#   if WORDSIZE_IS_64
				case 'j':
#   endif
				case 'q':  // BSD
				case 'L':
					++flag_long;  // Fall through
#   if WORDSIZE_IS_32
				case 'j':
#   endif
				case 'z':
				case 'l':
					++flag_long;
					goto inn_printf;
				case '-':
					flag_left = 1;
					goto inn_printf;
				case ' ':
					flag_space = 1;
					goto inn_printf;
				case '+':
					flag_sign = 1;
					goto inn_printf;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					if (flag_dot) { return -1; }
					width = (unsigned int)strtoul((format - 1), (const char**)&s, 10);
					if (width > V_PRINTF_MAX_WIDTH) { return -1; }
					else if (_ch == '0' && !flag_left) { padwith = '0'; }
					format = s;
					goto inn_printf;
				case '*':
					if ((tmpi = (int)va_arg(arg_ptr, int)) < 0) {
						flag_left = 1;
						tmpi = -tmpi;
					}
					if ((width = (unsigned int)tmpi) > V_PRINTF_MAX_WIDTH) { return -1; }
					goto inn_printf;
				case '.':
					flag_dot = 1;
					if (*format == '*') {
						tmpi = (int)va_arg(arg_ptr, int);
						preci = (unsigned int)((tmpi < 0) ? 0 : tmpi);
						++format;
					} else {
						tmpl = (long)strtol(format, (const char**)&s, 10);
						preci = (unsigned int)((tmpl < 0) ? 0 : tmpl);
						format = s;
					}
					if (preci > V_PRINTF_MAX_WIDTH) { return -1; }
					goto inn_printf;
				// Print a char or %
				case 'c':
					_ch = (unsigned char)va_arg(arg_ptr, int);
				case '%':
					B_WRITE(fn, &_ch, 1);
					++len;
					break;
				// Print an error message
#   ifndef NO_PRINT_M
				case 'm':
					s = strerror(errno);
					sz = strlen(s);
					B_WRITE(fn, s, sz);
					len += (unsigned int)sz;
					break;
#   endif
				// Print a string
				case 's':
					s = va_arg(arg_ptr, char*);
#   ifdef WANT_NULL_PRINTF
					if (!s) { s = "(null)"; }
#   endif
					sz = strlen(s);
					if (flag_dot && sz > preci) { sz = preci; }
					preci = 0;
					flag_dot ^= flag_dot;
					padwith = precpadwith = ' ';
print_out:
					{
						sign = s;
						todo = 0;
						if (!(width || preci)) {
							B_WRITE(fn, s, sz);
							len += (unsigned int)sz;
							break;
						}
						if (flag_in_sign) { todo = 1; }
						if (flag_hash > 0) { todo = flag_hash; }
						if (todo) {
							s += todo;
							sz -= (unsigned long)todo;
							width -= (unsigned int)todo;
						}
						if (flag_dot && width == 0) { width = preci; }
						if (!flag_dot) { preci = (unsigned int)sz; }
						if (!flag_left && padwith == ' ') {  // Left-side padding with spaces
							if (write_pad(&len, fn, (width - preci), padwith)) { return -1; }
						}
						if (todo) {
							B_WRITE(fn, sign, todo);
							len += (unsigned int)todo;
						}
						if (!flag_left && padwith != ' ') {  // Left-side padding with '0'
							if (write_pad(&len, fn, (width - preci), padwith)) { return -1; }
						}
						// Preci padding
						if (write_pad(&len, fn, (unsigned int)(preci - sz), precpadwith)) { return -1; }
						// Write actual string
						B_WRITE(fn, s, sz);
						len += (unsigned int)sz;
						if (flag_left) {
							if (write_pad(&len, fn, width - preci, padwith)) { return -1; }
						}
						break;
					}
				// Print an integer value
#   ifndef NO_PRINT_INTS
				case 'b':
					base = 2;
					sz = 0;
					goto num_printf;
				case 'p':
					flag_hash = 2;
					flag_long = 1;
					_ch = 'x';
				case 'X':
					flag_upcase = (_ch == 'X');
				case 'x':
					base = 16;
					sz = 0;
					if (flag_hash) {
						buf[1] = '0';
						buf[2] = (char)_ch;
						flag_hash = 2;
						sz = 2;
					}
					if (preci > width) { width = preci; }
					goto num_printf;
				case 'd':
				case 'i':
					flag_in_sign = 1;
				case 'u':
					base = 10;
					sz = 0;
					goto num_printf;
				case 'o':
					base = 8;
					sz = 0;
					if (flag_hash) {
						buf[1] = '0';
						flag_hash = 1;
						++sz;
					}
num_printf:
					s = buf + 1;
					if (flag_long > 0) {
						if (flag_long > 1) { llnumber = va_arg(arg_ptr, long long); }
						else { number = va_arg(arg_ptr, long); }
					} else {
						number = va_arg(arg_ptr, int);
						if (SIZEOF_INT != SIZEOF_LONG && !flag_in_sign) { number &= ((unsigned int)-1); }
					}
					if (flag_in_sign) {
						if ((flag_long > 1) && (llnumber < 0)) {
							llnumber = -llnumber;
							flag_in_sign = 2;
						} else {
							if (number < 0) {
								number = -number;
								flag_in_sign = 2;
							}
						}
					}
					if (flag_long < 0) { number &= 0xffff; }
					if (flag_long < -1) { number &= 0xff; }
					if (flag_long > 1) { retval = __lltostr((u_str.s_constr + sz), (sizeof(buf) - 5), (unsigned long long)llnumber, (int)base, flag_upcase); }
					else {
						retval = __ltostr((u_str.s_constr + sz), (sizeof(buf) - 5), (unsigned long)number, base, flag_upcase);
					}
					// When 0 is printed with an explicit precision 0, the output is empty
					if (flag_dot && retval == 1 && s[sz] == '0') {
						if (preci == 0 || flag_hash > 0) { sz = 0; }
						flag_hash = 0;
					} else { sz += (unsigned long)retval; }
					if (flag_in_sign == 2) {
						*(--u_str.s_constr) = '-';
						++sz;
					} else if ((flag_in_sign) && (flag_sign || flag_space)) {
						*(--u_str.s_constr) = ((flag_sign) ? '+' : ' ');
						++sz;
					} else { flag_in_sign = 0; }
					precpadwith = '0';
					goto print_out;
#   endif
				// Print a floating-point
#   ifndef NO_PRINT_FLOATS
				case 'f':
				case 'g':
					{
						g = (_ch == 'g');
						d = (double)va_arg(arg_ptr, double);
						s = buf + 1;
						if (width == 0) { width = 1; }
						if (!flag_dot) { preci = 6; }
						if (flag_sign || d < +0.0) { flag_in_sign = 1; }
						sz = (unsigned long)__dtostr((double)d, u_str.s_constr, (sizeof(buf) - 1), width, preci, g);
						if (flag_dot) {
							if ((tmp = strchr_nc(u_str.s_constr, '.'))) {
								if (preci || flag_hash) { ++tmp; }
								while (preci > 0 && *++tmp) { --preci; }
								*tmp = 0;
							} else if (flag_hash) {
								u_str.s_constr[sz] = '.';
								u_str.s_constr[++sz] = '\0';
							}
						}
						if (g) {
							if ((tmp = strchr_nc(u_str.s_constr, '.'))) {
								tmp1 = strchr_nc(tmp, 'e');
								while (*tmp) { ++tmp; }
								if (tmp1) { tmp = tmp1; }
								while (*--tmp == '0') ;
								if (*tmp != '.') { ++tmp; }
								*tmp = 0;
								if (tmp1) { strcpy(tmp, tmp1); }
							}
						}
						if ((flag_sign || flag_space) && d >= 0) {
							*(--u_str.s_constr) = ((flag_sign) ? '+' : ' ');
							++sz;
						}
						sz = strlen(s);
						if (width < sz) { width = (unsigned int)sz; }
						precpadwith = '0';
						flag_dot = 0;
						flag_hash = 0;
						goto print_out;
					}
#   endif
				default: break;
			}
		}
	}
	return (int)len;
#   undef s
}


/** Writes the C string pointed by format to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by `ap` instead of additional function arguments */
LIB_FUNC int vfprintf(FILE* stream, const char* format, va_list arg_ptr) {
	struct arg_printf ap = { stream, &__fwrite_helper };
	return __v_printf(&ap, format, arg_ptr);
}


/** Writes the C string pointed by fmt to the stream; If fmt includes format specifiers (subsequences beginning with %), the additional arguments following fmt are formatted and inserted in the resulting string replacing their respective specifiers */
LIB_FUNC int fprintf(FILE* restrict f, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	struct arg_printf ap2 = { f, &__fwrite_helper };
	register const int ret = __v_printf(&ap2, fmt, ap);
	va_end(ap);
	return ret;
}
#define __fprintf(f, fmt, ...)   fprintf((f), (fmt), (__VA_ARGS__))


/** Write formatted output to stdout according to the format string FORMAT, using the argument list in ARG */
LIB_FUNC int vprintf(const char* format, va_list arg) {
	struct arg_printf ap = { stdout, &__fwrite_helper };
	return __v_printf(&ap, format, arg);
}
#define __vprintf(format, arg)   vprintf((format), (arg))
#define __vprintfW(format, arg)   vprintf((format), (arg))


/** Write formatted output to stdout from the format string FORMAT */
LIB_FUNC int printf(const char* restrict format, ...) {
	va_list arg;
	va_start(arg, format);
	struct arg_printf ap2 = { stdout, &__fwrite_helper };
	register const int done = __v_printf(&ap2, format, arg);
	va_end(arg);
	fflush(stdout);
	return done;
}
#define __printf(format, ...)   printf((format), (__VA_ARGS__))
#define __printfW(format, ...)   printf((format), (__VA_ARGS__))
#define _IO_printf(format, ...)   printf((format), (__VA_ARGS__))


LIB_FUNC int vdprintf(const int fd, char* restrict fmt, va_list ap) {
	FILE f = {
		.fd = fd,
		.lbf = EOF,
		.write = &wrap_write,
		.buf = (void*)fmt,
		.buf_size = 0,
		.lock = -1
	};
	return vfprintf(&f, fmt, ap);
}


LIB_FUNC int dprintf(int fd, char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vdprintf(fd, fmt, ap);
	va_end(ap);
	return ret;
}


/** Print formatted output to string STR; Similar to vsprintf, but additional length SIZE limit how much is written into STR; Returns string length of formatted string (which may be larger than SIZE); STR may be NULL, in which case nothing will be written; On error, return a negative value */
LIB_FUNC int vsnprintf(char* restrict str, const size_t size, const char* restrict fmt, va_list ap) {
	register size_t n = size;
	char dummy;
	FILE f;
	struct __sfileext fext;
	_FILEEXT_SETUP(&f, &fext);
	if (n > INT_MAX) { n = INT_MAX; }
	if (n == 0) {
		str = &dummy;
		n = 1;
	}
	f._file = -1;
	f.flags = (__SWR | __SSTR);
	f._bf._base = f._p = (unsigned char*)str;
	f._bf._size = f._w = (int)(n - 1);
	const int ret = vfprintf(&f, fmt, ap);
	*f._p = '\0';
	return ret;
}
#define _IO_vsnprintf(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))
#define __vsnprintf(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))
#define __vsnprintfW(_string, maxlen, format, args)   vsnprintf((_string), (maxlen), (format), (args))


/** Write formatted output into S, according to the format string FORMAT, writing no more than MAXLEN characters */
LIB_FUNC int snprintf(char* s, const size_t maxlen, const char* format, ...) {
	va_list arg;
	va_start(arg, format);
	register const int done = vsnprintf(s, maxlen, format, arg);
	va_end(arg);
	return done;
}
#define __snprintf(s, maxlen, format, ...)   snprintf((s), (maxlen), (format), (__VA_ARGS__))
#define __snprintfW(s, maxlen, format, ...)   snprintf((s), (maxlen), (format), (__VA_ARGS__))


/** Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by `ap` instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by `s` */
LIB_FUNC int vsprintf(char* restrict s, const char* restrict fmt, va_list ap) {
	return (int)vsnprintf(s, INT_MAX, fmt, ap);
}


/** Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by `s` */
LIB_FUNC int sprintf(char* restrict s, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = (int)vsnprintf(s, INT_MAX, fmt, ap);
	va_end(ap);
	return ret;
}
#define SPRINTF(s, fmt, ...)   sprintf((s), (fmt), __VA_ARGS__)


LIB_FUNC int vasprintf(char** s, const char* fmt, va_list ap) {
	va_list ap2;
	va_copy(ap2, ap);
	register const int l = vsnprintf(0, 0, fmt, ap2);
	va_end(ap2);
	if (l < 0 || (!(*s = malloc((size_t)(l + 1))))) { return -1; }
	return vsnprintf(*s, (size_t)(l + 1), fmt, ap);
}
#define _IO_vasprintf(result_ptr, format, args)   vasprintf((result_ptr), (format), (args))


LIB_FUNC int asprintf(char** s, const char* fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vasprintf(s, fmt, ap);
	va_end(ap);
	return ret;
}
#define ASPRINTF(s, fmt, ...)   asprintf((s), (fmt), __VA_ARGS__)


#endif  // PRINTF_H


/** Test if writting to the File Pointer is not possible */
#define cantwrite(fp)   (((fp)->flags & (unsigned int)__SWR) == 0 || (fp)->_bf._base == NULL)


LIB_FUNC void __shlim(FILE* f, const off_t lim) {
	f->shlim = lim;
	f->shcnt = f->rend - f->rpos;
	if (lim && f->shcnt > lim) { f->shend = (f->rpos + lim); }
	else { f->shend = f->rend; }
}
#define shlim(f, lim)   __shlim((f), (lim))


LIB_FUNC int __shgetc(FILE* f) {
	register int c;
	if ((f->shlim && (f->shcnt >= f->shlim)) || (c = __uflow(f)) < 0) { f->shend = 0; return EOF; }
	if (f->shlim && ((f->rend - f->rpos) > (f->shlim - f->shcnt - 1))) { f->shend = f->rpos + (f->shlim - f->shcnt - 1); }
	else { f->shend = f->rend; }
	if (f->rend) { f->shcnt += f->rend - f->rpos + 1; }
	if (f->rpos[-1] != c) { f->rpos[-1] = (unsigned char)c; }
	return c;
}
#define shgetc(f)   __shgetc(f)


/** Internal routine to determine proper buffering for a file */
LIB_FUNC int __swhatbuf(FILE* fp, size_t* bufsize, int* couldbetty) {
	struct stat st;
	if (fp->_file < 0 || fstat(fp->_file, &st) < 0) {
		*couldbetty = 0;
		*bufsize = BUFSIZ;
		return __SNPT;
	}
	*couldbetty = S_ISCHR(st.st_mode);
	if (st.st_blksize == 0) {
		*bufsize = BUFSIZ;
		return __SNPT;
	}
	*bufsize = (size_t)st.st_blksize;
	fp->blksize = st.st_blksize;
	return ((st.st_mode & S_IFMT) == S_IFREG && fp->seek == __sseek ? __SOPT : __SNPT);
}


/** Allocate a file buffer, or switch to unbuffered I/O; Per the ANSI C standard, ALL tty devices default to line buffered */
LIB_FUNC void __smakebuf(FILE* fp) {
	void* p;
	if (fp->flags & (unsigned int)__SNBF) {
		fp->_bf._base = fp->_p = fp->_nbuf;
		fp->_bf._size = 1;
		return;
	}
	size_t size;
	int couldbetty;
	register int _flags = __swhatbuf(fp, &size, &couldbetty);
	if ((p = malloc(size)) == NULL) {
		fp->flags |= (unsigned int)__SNBF;
		fp->_bf._base = fp->_p = fp->_nbuf;
		fp->_bf._size = 1;
		return;
	}
	_flags |= (int)__SMBF;
	fp->_bf._base = fp->_p = p;
	fp->_bf._size = (int)size;
	if (couldbetty && isatty(fp->_file)) { _flags |= (int)__SLBF; }
	fp->flags |= (unsigned int)_flags;
}


/** Refill a stdio buffer; Return EOF on eof or error, 0 otherwise */
LIB_FUNC int __srefill(FILE* fp) {
	fp->_r = 0;
	if (fp->flags & (unsigned int)__SEOF) { return EOF; }
	else if ((fp->flags & (unsigned int)__SRD) == 0) {
		if ((fp->flags & (unsigned int)__SRW) == 0) {
			errno = EBADF;
			fp->flags |= (unsigned int)__SERR;
			return EOF;
		} else if (fp->flags & (unsigned int)__SWR) {
			if (__sflush(fp)) { return EOF; }
			fp->flags &= (unsigned int)(~__SWR);
			fp->_w = 0;
			fp->lbfsize = 0;
		}
		fp->flags |= (unsigned int)__SRD;
	} else {
		if (HASUB(fp)) {
			FREEUB(fp);
			if ((fp->_r = fp->_ur) != 0) {
				fp->_p = fp->_up;
				return 0;
			}
		}
	}
	if (fp->_bf._base == NULL) { __smakebuf(fp); }
	if (fp->flags & (unsigned int)(__SLBF | __SNBF)) {
		fp->flags |= (unsigned int)__SIGN;
		(void)_fwalk(lflush);
		fp->flags &= (unsigned int)(~__SIGN);
		if ((fp->flags & (unsigned int)(__SLBF | __SWR)) == (unsigned int)(__SLBF | __SWR)) { __sflush(fp); }
	}
	fp->_p = fp->_bf._base;
	fp->_r = (int)(*fp->read)(fp->_cookie, (unsigned char*)fp->_p, (size_t)fp->_bf._size);
	fp->flags &= (unsigned int)(~__SMOD);
	if (fp->_r <= 0) {
		if (fp->_r == 0) { fp->flags |= (unsigned int)__SEOF; }
		else {
			fp->_r = 0;
			fp->flags |= (unsigned int)__SERR;
		}
		return EOF;
	}
	return 0;
}


/** Handle getc() when the buffer ran out: Refill, then return the first character in the newly-filled buffer */
LIB_FUNC int __srget(FILE* fp) {
	_SET_ORIENTATION(fp, -1);
	if (__srefill(fp) == 0) { fp->_r--; return (int)(*fp->_p++); }
	return EOF;
}
#define __sgetc(p)   (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))
#define getc_unlocked(fp)   __sgetc((fp))
#define _IO_getc_unlocked(fp)   __sgetc((fp))
#define getchar_unlocked()   getc_unlocked(stdin)
#define fgetc_unlocked(fp)   __sgetc((fp))


LIB_FUNC int __sflush(FILE* fp) {
	register int t = (int)(fp->flags);
	if ((t & __SWR) == 0) { return 0; }
	unsigned char* p;
	if ((p = fp->_bf._base) == NULL) { return 0; }
	register int n = (int)(fp->_p - p);
	fp->_p = p;
	fp->_w = ((t & (int)(__SLBF | __SNBF)) ? 0 : fp->_bf._size);
	for (; n > 0; n -= t, p += t) {
		t = (int)((*fp->write)(fp->_cookie, (unsigned char*)p, (size_t)n));
		if (t <= 0) {
			fp->flags |= (unsigned int)__SERR;
			return EOF;
		}
	}
	return 0;
}
#define sflush(fp)   __sflush((fp))


LIB_FUNC int __sflush_locked(FILE* fp) {
	flockfile(fp);
	const int r = __sflush(fp);
	funlockfile(fp);
	return r;
}


LIB_FUNC int _fwalk(int (*function)(FILE*)) {
	FILE* fp;
	register int n;
	struct glue* g;
	register int ret = 0;
	for (g = &__sglue; g != NULL; g = g->next) {
		for (fp = g->iobs, n = g->niobs; --n >= 0; fp++) {
			if ((fp->flags != 0) && ((fp->flags & (unsigned int)__SIGN) == 0)) { ret |= (*function)(fp); }
		}
	}
	return ret;
}


LIB_FUNC int fflush_unlocked(FILE* f) {
	if (f->wpos > f->wbase) {
		f->write(f, 0, 0);
		if (!f->wpos) { return EOF; }
	}
	if (f->rpos < f->rend) { f->seek(f, f->rpos-f->rend, SEEK_CUR); }
	f->wpos = f->wbase = f->wend = 0;
	f->rpos = f->rend = 0;
	return 0;
}
#define __fflush_unlocked(f)   fflush_unlocked((f))


/** Flush a single file, or (if f is NULL) all files */
LIB_FUNC int fflush(FILE* f) {
	if (f) {
		FLOCK(f);
		const int r = __fflush_unlocked(f);
		FUNLOCK(f);
		return r;
	}
	register int r = (int)(STDOUT ? fflush(STDOUT) : 0);
	for (f = *__ofl_lock(); f; f = f->next_locked) {
		FLOCK(f);
		if (f->wpos > f->wbase) { r |= __fflush_unlocked(f); }
		FUNLOCK(f);
	}
	__ofl_unlock();
	return r;
}
#define __fflush(f)   fflush((f))
#define _IO_fflush(f)   fflush((f))


LIB_FUNC int lflush(FILE* _fp) {
	_DIAGASSERT(_fp != NULL);
	if ((_fp->flags & (unsigned int)(__SLBF | __SWR)) == (unsigned int)(__SLBF | __SWR)) { return __sflush(_fp); }
	return 0;
}


LIB_FUNC int __sread(void* _cookie, char* buf, const int n) {
	FILE* fp = _cookie;
	register const int ret = (int)read(fp->_file, buf, (size_t)n);
	if (ret >= 0) { fp->offset += ret; }
	else { fp->flags &= (unsigned int)(~__SOFF); }
	return ret;
}


LIB_FUNC int __swrite(void* _cookie, const char* buf, const int n) {
	FILE* fp = _cookie;
	if (fp->flags & (unsigned int)__SAPP) { (void)lseek(fp->_file, (off_t)0, SEEK_END); }
	fp->flags &= (unsigned int)(~__SOFF);
	return (int)write(fp->_file, buf, (size_t)n);
}


LIB_FUNC fpos_t __sseek(void* _cookie, const fpos_t offset, const int whence) {
	FILE* fp = _cookie;
	register const off_t ret = lseek(fp->_file, (off_t)offset, whence);
	if (ret == (off_t)-1) { fp->flags &= (unsigned int)(~__SOFF); }
	else {
		fp->flags |= (unsigned int)__SOFF;
		fp->offset = ret;
	}
	return (fpos_t)ret;
}
#define _sseek(_cookie, offset, whence)   __sseek((_cookie), (offset), (whence))
#define sseek(_cookie, offset, whence)   __sseek((_cookie), (offset), (whence))


LIB_FUNC int __sclose(void* _cookie) {
	return close(((FILE*)_cookie)->_file);
}
#define _sclose(_cookie)   __sclose((_cookie))


/** Write character to stream */
LIB_FUNC int putc(int c, FILE* f) {
	flockfile(f);
	register const int ret = (int)f->write(f, (unsigned char*)&c, SIZEOF_CHAR);
	funlockfile(f);
	if (ret) { return ret; }
	return EOF;
}
#define _IO_putc_unlocked(c, f)   fputc_unlocked((f), (c))
/** Write character to stream */
#define fputc(c, f)   putc((c), (f))
/** Write character to stdout */
#define putchar(x)   putc(x, STDOUT)
#define putchar_unlocked(x)   putc(x, STDOUT)
#define outchar(c)   putc(((c) & 0177), STDOUT)


LIB_FUNC int getc(FILE* f) {
	if (f->lock < 0 || (!__lockfile(f))) { return getc_unlocked(f); }
	register const int c = getc_unlocked(f);
	__unlockfile(f);
	return c;
}
#define _IO_getc(f)   getc((f))


LIB_FUNC char* fgets(char* as, int n, FILE* f) {
	register int c = EOF;
	char* s = as;
	while (n > 1 && ((c = getc(f)) != EOF)) {
		*s++ = (char)c;
		--n;
		if (c == '\n') { break; }
	}
	if ((c == EOF && s == as) || ferror(f)) { return NULL; }
	else if (n) { *s = '\0'; }
	return as;
}


LIB_FUNC int feof(FILE* f) {
	FLOCK(f);
	const int ret = !(!(f->flags & F_EOF));
	FUNLOCK(f);
	return ret;
}
#define __FEOF(f)   feof((f))
#define __sfeof(p)   (((p)->flags & __SEOF) != 0)
#define __FEOF_UNLOCKED(_fp)   __sfeof((_fp))
#define feof_unlocked(_fp)   __FEOF_UNLOCKED((_fp))
#define _IO_feof_unlocked(_fp)   __FEOF_UNLOCKED((_fp))


LIB_FUNC int fileno(FILE* f) {
	FLOCK(f);
	FUNLOCK(f);
	return (int)f->fd;
}
#define fileno_unlocked(f)   fileno((f))
#define __fileno_unlocked(f)   fileno((f))
#define __fileno(f)   fileno((f))
#define __sfileno(p)   ((p)->_file == -1 ? -1 : (int)(unsigned short)(p)->_file)


/** Clear the error and EOF indicators for STREAM */
LIB_FUNC void clearerr(FILE* f) {
	FLOCK(f);
	f->flags &= (unsigned int)(~(F_EOF | F_ERR));
	FUNLOCK(f);
}
#define __CLEARERR(_fp)   clearerr((_fp))
#define __sclearerr(p)   ((void)((p)->flags &= (~(__SERR | __SEOF))))
#define __CLEARERR_UNLOCKED(_fp)   __sclearerr((_fp))
#define clearerr_unlocked(_fp)   __CLEARERR_UNLOCKED((_fp))



/** A subroutine version of the macro ferror */
LIB_FUNC int ferror(FILE* fp) {
	diagassert(fp != NULL);
	flockfile(fp);
	register const int r = ((fp->flags & (unsigned int)__SERR) != 0);
	funlockfile(fp);
	return r;
}
#define _IO_ferror_unlocked(f)   ferror((f))
#define ferror_unlocked(f)   ferror((f))
#define __FERROR(_fp)   ferror((_fp))
#define __sferror(p)   (((p)->flags & (unsigned int)__SERR) != 0)
#define __FERROR_UNLOCKED(_fp)   __sferror((_fp))


LIB_FUNC int set_flags(FILE* stream, const int flags) {
	switch (flags) {
		case _IONBF:
			stream->flags = (unsigned int)(stream->flags & (unsigned int)(~(BUFLINEWISE))) | NOBUF;
			break;
		case _IOLBF:
			stream->flags = (unsigned int)(stream->flags & (unsigned int)(~(NOBUF))) | BUFLINEWISE;
			break;
		case _IOFBF:
			stream->flags = stream->flags & (unsigned int)(~(NOBUF | BUFLINEWISE));
			break;
		default: return -1;
	}
	return 0;
}


LIB_FUNC int setvbuf_unlocked(FILE* stream, char* buf, const int flags, const size_t size) {
	if (buf) {
		if (!(stream->flags & STATICBUF)) { free(stream->buf); }
		stream->buf = (unsigned char*)buf;
	} else {
		unsigned char* tmp;
		if (!size) { return set_flags(stream, flags); }
		else if (!(tmp = malloc(size))) { return -1; }
		else if (!(stream->flags & STATICBUF)) { free(stream->buf); }
		stream->buf = tmp;
	}
	stream->flags &= (unsigned int)(~STATICBUF);
	stream->buf_size = size;
	return set_flags(stream, flags);
}
#define _IO_setvbuf(fp, buf, mode, size)   setvbuf_unlocked((fp), (buf), (mode), (size))
#define setvbuf(fp, buf, mode, size)   setvbuf_unlocked((fp), (buf), (mode), (size))


LIB_FUNC void setbuf(FILE* restrict f, char* restrict buf) {
	setvbuf(f, buf, (buf ? _IOFBF : _IONBF), BUFSIZ);
}


LIB_FUNC void setbuffer(FILE* f, char* buf, const size_t size) {
	setvbuf(f, buf, (buf ? _IOFBF : _IONBF), size);
}


LIB_FUNC void setlinebuf(FILE* f) {
	setvbuf(f, 0, _IOLBF, 0);
}


LIB_FUNC void store_int(void* dest, const int size, const unsigned long long i) {
	if (!dest) { return; }
	switch (size) {
		case SIZE_hh:
			*(char*)dest = (char)i;
			return;
		case SIZE_h:
			*(short*)dest = (short)i;
			return;
		case SIZE_def:
			*(int*)dest = (int)i;
			return;
		case SIZE_l:
			*(long*)dest = (long)i;
			return;
		case SIZE_ll:
			*(long long*)dest = (long long)i;
			return;
		default: return;
	}
	UNREACHABLE
}


LIB_FUNC void* arg_n(va_list ap, const unsigned int n) {
	register unsigned int i;
	va_list ap2;
	va_copy(ap2, ap);
	for (i = n; i > 1; i--) { va_arg(ap2, void*); }
	void* p;
	p = va_arg(ap2, void*);
	va_end(ap2);
	return p;
}


LIB_FUNC size_t do_read(FILE* f, unsigned char* buf, const size_t len) {
	wchar_t* wcs = f->_cookie;
	if ((!(wcs[0]))) { wchar_t wcs_str[2] = L"@"; wcs = wcs_str; }
	register size_t i;
	for (i = 0; i < f->buf_size && wcs[i]; i++) { f->buf[i] = (unsigned char)(wcs[i] < 128 ? wcs[i] : '@'); }
	f->rpos = f->buf;
	f->rend = f->buf + i;
	f->_cookie = (void*)(wcs + i);
	if (i && len) { *buf = *f->rpos++; return 1; }
	return 0;
}


LIB_FUNC size_t do_read_helper(void* f, unsigned char* buf, const size_t len) {
	return do_read((FILE*)f, buf, len);
}


LIB_FUNC size_t __string_read(FILE* f, unsigned char* buf, const size_t len) {
	char* src = f->_cookie;
	register size_t k = len + 256, _len = len;
	char* end = memchr_nonconst(src, 0, k);
	if (end) { k = (size_t)(end - src); }
	if (k < _len) { _len = k; }
	memcpy_no_output(buf, src, _len);
	f->rpos = (void*)(src + _len);
	f->rend = (void*)(src + k);
	f->_cookie = src + k;
	return _len;
}


/** Reads data from the stream and stores them according to parameter `fmt` into the locations pointed by the elements in the variable argument list identified by `ap` */
LIB_FUNC int vfscanf(FILE* restrict f, const char* restrict fmt, va_list ap) {
	int width, size, alloc, base, c, t, invert, matches = 0;
	const unsigned char* p;
	char* s;
	wchar_t* wcs;
	mbstate_t st;
	void* dest = NULL;
	unsigned long long x;
	long double y;
	register off_t pos = 0;
	unsigned char scanset[257] = { 0 };
	size_t i, k;
	wchar_t wc;
	FLOCK(f);
	for (p = (const unsigned char*)fmt; *p; p++) {
		alloc = 0;
		if (isspace(*p)) {
			while (isspace(p[1])) { p++; }
			shlim(f, 0);
			while (isspace(shgetc(f)));
			shunget(f);
			pos += shcnt(f);
			continue;
		} else if (*p != '%' || p[1] == '%') {
			p += (*p == '%');
			shlim(f, 0);
			c = shgetc(f);
			if (c != *p) {
				shunget(f);
				if (c < 0) { goto input_fail; }
				goto match_fail;
			}
			++pos;
			continue;
		}
		++p;
		if (*p=='*') { dest = 0; p++; }
		else if (isdigit(*p) && p[1] == '$') { dest = arg_n(ap, (unsigned int)(*p - '0')); p += 2; }
		else { dest = va_arg(ap, void*); }
		for (width = 0; isdigit(*p); p++) { width = (10 * width + *p - '0'); }
		if (*p == 'm') {
			wcs = 0;
			s = 0;
			alloc = !!dest;
			++p;
		} else { alloc = 0; }
		size = SIZE_def;
		switch (*p++) {
			case 'h':
				if (*p == 'h') { ++p; size = SIZE_hh; }
				else { size = SIZE_h; }
				break;
			case 'l':
				if (*p == 'l') { ++p; size = SIZE_ll; }
				else { size = SIZE_l; }
				break;
			case 'j':
				size = SIZE_ll;
				break;
			case 'z':
			case 't':
				size = SIZE_l;
				break;
			case 'L':
				size = SIZE_L;
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 's':
			case 'c':
			case '[':
			case 'S':
			case 'C':
			case 'p':
			case 'n':
				--p;
				break;
			default: goto fmt_fail;
		}
		t = *p;
		if ((t & 0x2f) == 3) {
			t |= 32;
			size = SIZE_l;
		}
		switch (t) {
			case 'c':
				if (width < 1) { width = 1; }
			case '[':
				break;
			case 'n':
				store_int(dest, size, (unsigned long long)pos);
				continue;
			default:
				shlim(f, 0);
				while (isspace(shgetc(f)));
				shunget(f);
				pos += shcnt(f);
		}
		shlim(f, width);
		if (shgetc(f) < 0) { goto input_fail; }
		shunget(f);
		switch (t) {
			case 's':
			case 'c':
			case '[':
				if (t == 'c' || t == 's') {
					memset_no_output(scanset, -1, sizeof(scanset));
					scanset[0] = 0;
					if (t == 's') {
						scanset[1 + '\t'] = 0;
						scanset[1 + '\n'] = 0;
						scanset[1 + '\v'] = 0;
						scanset[1 + '\f'] = 0;
						scanset[1 + '\r'] = 0;
						scanset[1 + ' '] = 0;
					}
				} else {
					if (*++p == '^') { p++, invert = 1; }
					else { invert = 0; }
					memset_no_output(scanset, invert, sizeof scanset);
					scanset[0] = 0;
					if (*p == '-') { ++p; scanset[1 + '-'] = (unsigned char)(1 - invert); }
					else if (*p == ']') { ++p; scanset[1 + ']'] = (unsigned char)(1 - invert); }
					for (; *p != ']'; p++) {
						if (!*p) { goto fmt_fail; }
						else if (*p == '-' && p[1] && p[1] != ']') {
							for (c = p++[-1]; c < *p; c++) { scanset[1 + c] = (unsigned char)(1 - invert); }
						}
						scanset[1 + *p] = (unsigned char)(1 - invert);
					}
				}
				wcs = 0;
				s = 0;
				i = 0;
				k = (size_t)(t == 'c' ? ((unsigned int)width + 1U) : 31);
				if (size == SIZE_l) {
					if (alloc) {
						wcs = malloc(k * SIZEOF_WCHAR_T);
						if (!wcs) { goto alloc_fail; }
					} else { wcs = dest; }
					st = (mbstate_t) { 0 };
					while (scanset[(c = shgetc(f)) + 1]) {
						switch (mbrtowc(&wc, (char*)&c, 1, &st)) {
							case (size_t)-1: goto input_fail;
							default: continue;
						}
						if (wcs) { wcs[i++] = wc; }
						if (alloc && i == k) {
							k += (k + 1);
							wchar_t* tmp = realloc(wcs, (k * SIZEOF_WCHAR_T));
							if (!tmp) { goto alloc_fail; }
							wcs = tmp;
						}
					}
					if (!mbsinit(&st)) { goto input_fail; }
				} else if (alloc) {
					s = malloc(k);
					if (!s) { goto alloc_fail; }
					while (scanset[(c = shgetc(f)) + 1]) {
						s[i++] = (char)c;
						if (i == k) {
							k += (k + 1);
							char* tmp = realloc(s, k);
							if (!tmp) { goto alloc_fail; }
							s = tmp;
						}
					}
				} else if ((s = dest)) { while (scanset[(c = shgetc(f)) + 1]) { s[i++] = (char)c; } }
				else { while (scanset[(c = shgetc(f)) + 1]); }
				shunget(f);
				if (!shcnt(f)) { goto match_fail; }
				if (t == 'c' && shcnt(f) != width) { goto match_fail; }
				if (alloc) {
					if (size == SIZE_l) { *(wchar_t**)dest = wcs; }
					else { *(char**)dest = s; }
				}
				if (t != 'c') {
					if (wcs) { wcs[i] = 0; }
					if (s) { s[i] = 0; }
				}
				break;
			case 'p':
			case 'X':
			case 'x':
				base = 16;
				goto int_common;
			case 'o':
				base = 8;
				goto int_common;
			case 'd':
			case 'u':
				base = 10;
				goto int_common;
			case 'i':
				base = 0;
			int_common:
				x = intscan(f, (unsigned int)base, 0, ULLONG_MAX);
				if (!shcnt(f)) { goto match_fail; }
				if (t == 'p' && dest) { *(void**)dest = (void*)(uintptr_t)x; }
				else { store_int(dest, size, x); }
				break;
			case 'a':
			case 'A':
			case 'e':
			case 'E':
			case 'f':
			case 'F':
			case 'g':
			case 'G':
				y = __floatscan(f, size, 0);
				if (!shcnt(f)) { goto match_fail; }
				else if (dest) {
					switch (size) {
						case SIZE_def: *(float*)dest = (float)y; break;
						case SIZE_l: *(double*)dest = (double)y; break;
						case SIZE_L: *(long double*)dest = (long double)y; break;
						default: goto match_fail;
					}
				}
				break;
			default: goto match_fail;
		}
		pos += shcnt(f);
		if (dest) { ++matches; }
	}
	if (0) {
fmt_fail:
alloc_fail:
input_fail:
		if (!matches) { --matches; }
match_fail:
		if (alloc) {
			free(s);
			free(wcs);
		}
	}
	FUNLOCK(f);
	return matches;
}
#define __isoc99_vfscanf(f, fmt, ap)   vfscanf((f), (fmt), (ap))
#define isoc99_vfscanf(f, fmt, ap)   vfscanf((f), (fmt), (ap))


/** Reads data from the stream and stores them according to the parameter `format` into the locations pointed by the additional arguments */
LIB_FUNC int fscanf(FILE* stream, const char* format, ...) {
	va_list args;
	va_start(args, format);
	const int retval = vfscanf(stream, format, args);
	va_end(args);
	return retval;
}
#define __isoc99_fscanf(stream, format, ...)   fscanf((stream), (format), (__VA_ARGS__))
#define isoc99_fscanf(stream, format, ...)   fscanf((stream), (format), (__VA_ARGS__))


/** Reads data from the standard input (stdin) and stores them according to parameter `format` into the locations pointed by the elements in the variable argument list identified by `args` */
LIB_FUNC int vscanf(const char* format, va_list args) {
	return vfscanf(stdin, format, args);
}
#define __isoc99_vscanf(format, args)   vscanf((format), (args))
#define isoc99_vscanf(format, args)   vscanf((format), (args))


/** Reads data from stdin and stores them according to the parameter `format` into the locations pointed by the additional arguments */
LIB_FUNC int scanf(const char* format, ...) {
	va_list args;
	va_start(args, format);
	const int retval = vfscanf(stdin, format, args);
	va_end(args);
	return retval;
}
#define __isoc99_scanf(format, ...)   scanf((format), (__VA_ARGS__))
#define isoc99_scanf(format, ...)   scanf((format), (__VA_ARGS__))


/** Reads data from s and stores them according to parameter `fmt` into the locations pointed by the elements in the variable argument list identified by `ap` */
LIB_FUNC int vsscanf(char* restrict s, const char* restrict fmt, va_list ap) {
	FILE f = {
		.buf = (void*)s,
		._cookie = (void*)s,
		.read = &do_read_helper,
		.lock = -1
	};
	return vfscanf(&f, fmt, ap);
}
#define __isoc99_vsscanf(s, fmt, ap)   vsscanf((s), (fmt), (ap))
#define isoc99_vsscanf(s, fmt, ap)   vsscanf((s), (fmt), (ap))


/** Reads data from s and stores them according to parameter format into the locations given by the additional arguments, as if scanf was used, but reading from s instead of the standard input (stdin) */
LIB_FUNC int sscanf(char* restrict s, const char* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	register const int ret = vsscanf(s, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_sscanf(s, fmt, ...)   sscanf((s), (fmt), (__VA_ARGS__))
#define isoc99_sscanf(s, fmt, ...)   sscanf((s), (fmt), (__VA_ARGS__))


LIB_FUNC int fgetc(FILE* f) {
	if (f->lock < 0 || (!__lockfile(f))) { return getc_unlocked(f); }
	const int c = getc_unlocked(f);
	__unlockfile(f);
	return c;
}
#define getchar()   (int)fgetc(stdin)
#define __getchar()   (int)fgetc(stdin)


LIB_FUNC int ungetc(const int c, FILE* f) {
	if (c == EOF) { return c; }
	FLOCK(f);
	if (!f->rpos) { __toread(f); }
	if (!f->rpos || f->rpos <= (f->buf - UNGET)) {
		FUNLOCK(f);
		return EOF;
	}
	*--f->rpos = (unsigned char)c;
	f->flags &= (unsigned int)(~F_EOF);
	FUNLOCK(f);
	return c;
}


/** Write the given string to the given file */
LIB_FUNC int fputs(const char* restrict s, FILE* restrict fp) {
	const size_t l = strlen(s);
	return (int)((fwrite(s, 1, l, fp) == l) - 1);
}


LIB_FUNC int fputs_unlocked(register const char* restrict s, FILE* restrict stream) {
	size_t n = strlen(s);
	return ((fwrite_unlocked(s, 1, n, stream) == n) ? (int)n : (int)EOF);
}


#define putc_unlocked(c, f)   (((unsigned char)(c) != (f)->lbf && ((f)->wpos < (f)->wend)) ? *(f)->wpos++ = (unsigned char)(c) : __overflow((f), (int)(c)))


/** Write string to stdout */
LIB_FUNC int puts(const char* s) {
	FLOCK(STDOUT);
	const int r = -(fputs(s, STDOUT) < 0 || putc_unlocked('\n', STDOUT) < 0);
	FUNLOCK(STDOUT);
	return r;
}


/** Write string to stderr */
LIB_FUNC int puts_err(const char* s) {
	FLOCK(STDERR);
	const int r = -(fputs(s, STDERR) < 0 || putc_unlocked('\n', STDERR) < 0);
	FUNLOCK(STDERR);
	return r;
}


LIB_FUNC ssize_t getdelim(char** restrict s, size_t* restrict n, const int delim, FILE* restrict f) {
	char* tmp;
	unsigned char* z;
	size_t k, i = 0;
	int c;
	FLOCK(f);
	if (!n || !s) {
		f->flags |= (unsigned int)F_ERR;
		FUNLOCK(f);
		errno = EINVAL;
		return -1;
	}
	if (!*s) { *n = 0; }
	LOOP_FOREVER {
		z = (unsigned char*)memchr_nonconst(f->rpos, delim, (size_t)(f->rend - f->rpos));
		k = (size_t)(z ? (z - f->rpos + 1) : (f->rend - f->rpos));
		if ((i + k + 1) >= *n) {
			if (k >= SIZE_MAX / 2 - i) { goto getdelim_oom; }
			size_t m = (i + k + 2);
			if (!z && (m < (SIZE_MAX / 4))) { m += (size_t)(m / 2); }
			tmp = realloc(*s, m);
			if (!tmp) {
				m = i + k + 2;
				tmp = realloc(*s, m);
				if (!tmp) { goto getdelim_oom; }
			}
			*s = tmp;
			*n = m;
		}
		memcpy_no_output(*s + i, f->rpos, k);
		f->rpos += k;
		i += k;
		if (z) { break; }
		else if ((c = getc_unlocked(f)) == EOF) {
			if (!i || (!feof(f))) {
				FUNLOCK(f);
				return -1;
			}
			break;
		}
		if (((*s)[i++] = (char)c) == delim) { break; }
	}
	(*s)[i] = 0;
	FUNLOCK(f);
	return (ssize_t)i;
getdelim_oom:
	f->flags |= (unsigned int)F_ERR;
	FUNLOCK(f);
	errno = ENOMEM;
	return -1;
}
#define __getdelim(s, n, delim, f)   getdelim((s), (n), (delim), (f))


LIB_FUNC ssize_t getline(char** restrict s, size_t* restrict n, FILE* restrict f) {
	return getdelim(s, n, '\n', f);
}


LIB_FUNC int __toread(FILE* f) {
	f->mode |= (char)(f->mode - 1);
	if (f->wpos > f->buf) { f->write(f, 0, 0); }
	f->wpos = f->wbase = f->wend = 0;
	if (f->flags & (unsigned int)F_NORD) {
		f->flags |= (unsigned int)F_ERR;
		return EOF;
	}
	f->rpos = f->rend = (f->buf + f->buf_size);
	return (f->flags & (unsigned int)F_EOF) ? EOF : 0;
}


LIB_FUNC int __uflow(FILE* f) {
	unsigned char c;
	if (!__toread(f) && f->read(f, &c, 1) == 1) { return c; }
	return EOF;
}


LIB_FUNC int dup3(const int old, const int new, const int flags) {
	int r;
#ifdef SYS_dup2
	if (old == new) { return (int)__syscall_ret((unsigned long)(-EINVAL)); }
	else if (flags & O_CLOEXEC) {
		while ((r = (int)__syscall(SYS_dup3, old, new, flags)) == -EBUSY);
		if (r != -ENOSYS) { return (int)__syscall_ret((unsigned long)r); }
	}
	while ((r = (int)__syscall(SYS_dup2, old, new)) == -EBUSY);
	if (flags & O_CLOEXEC) { r = (int)__syscall(SYS_fcntl, new, F_SETFD, FD_CLOEXEC); }
#else
	while ((r = (int)__syscall(SYS_dup3, old, new, flags)) == -EBUSY);
#endif
	return (int)__syscall_ret((unsigned long)r);
}
#define __dup3(old, new, flags)   dup3((old), (new), (flags))


LIB_FUNC ssize_t readlink(const char* restrict path, char* restrict buf, size_t bufsize) {
#ifdef SYS_readlink
	return (ssize_t)syscall(SYS_readlink, path, buf, bufsize);
#else
	return (ssize_t)syscall(SYS_readlinkat, AT_FDCWD, path, buf, bufsize);
#endif
}


LIB_FUNC ssize_t readlinkat(const int fd, const char* restrict path, char* restrict buf, const size_t bufsize) {
	return (ssize_t)syscall(SYS_readlinkat, fd, path, buf, bufsize);
}


LIB_FUNC int symlink(const char* existing, const char* new) {
#ifdef SYS_symlink
	return (int)syscall(SYS_symlink, existing, new);
#else
	return (int)syscall(SYS_symlinkat, existing, AT_FDCWD, new);
#endif
}
#define __symlink(from, to)   symlink((from), (to))


LIB_FUNC int symlinkat(const char* existing, int fd, const char* new) {
	return (int)syscall(SYS_symlinkat, existing, fd, new);
}


LIB_FUNC int unlink(const char* path) {
#ifdef SYS_unlink
	return (int)syscall(SYS_unlink, path);
#else
	return (int)syscall(SYS_unlinkat, AT_FDCWD, path, 0);
#endif
}
#define __unlink(buf)   unlink((buf))


LIB_FUNC int unlinkat(int fd, const char* path, const int flag) {
	return (int)syscall(SYS_unlinkat, fd, path, flag);
}


LIB_FUNC int link(const char* existing, const char* new) {
#ifdef SYS_link
	return (int)syscall(SYS_link, existing, new);
#else
	return (int)syscall(SYS_linkat, AT_FDCWD, existing, AT_FDCWD, new, 0);
#endif
}


LIB_FUNC int linkat(const int fd1, const char* existing, const int fd2, const char* new, const int flag) {
	return (int)syscall(SYS_linkat, fd1, existing, fd2, new, flag);
}


static UNUSED FILE* ofl_head;
static volatile UNUSED int ofl_lock[2] = { 0 };


LIB_FUNC FILE** __ofl_lock(void) {
	__lock(ofl_lock);
	return &ofl_head;
}


LIB_FUNC void __ofl_unlock(void) {
	__unlock(ofl_lock);
}


LIB_FUNC FILE* __ofl_add(FILE* f) {
	FILE** _head = __ofl_lock();
	f->next_locked = *_head;
	if (*_head) { (*_head)->prev_locked = f; }
	*_head = f;
	__ofl_unlock();
	return f;
}


/** Opens the file (given by the file descriptor) and associates a stream to the file */
LIB_FUNC FILE* fdopen(const int fd, const char* mode) {
	FILE* f;
	struct winsize wsz;
	// Check for valid initial mode character
	if (!strchr("rwa", *mode)) {
		errno = EINVAL;
		return 0;
	}
	// Allocate FILE+buffer or fail
	if (!(f = malloc(sizeof(*f) + UNGET + BUFSIZ))) { return 0; }
	// Zero-fill only the struct, not the buffer
	memset_no_output(f, 0, sizeof(*f));
	// Impose mode restrictions
	if (!strchr(mode, '+')) { f->flags = (unsigned int)((*mode == 'r') ? F_NOWR : F_NORD); }
	// Apply close-on-exec flag
	if (strchr(mode, 'e')) { __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC); }
	// Set append mode on fd if opened for append
	if (*mode == 'a') {
		int flags = (int)__syscall(SYS_fcntl, fd, F_GETFL);
		if (!(flags & O_APPEND)) { __syscall(SYS_fcntl, fd, F_SETFL, (flags | O_APPEND)); }
		f->flags |= (unsigned int)F_APP;
	}
	f->fd = fd;
	f->buf = (unsigned char*)f + sizeof(*f) + UNGET;
	f->buf_size = BUFSIZ;
	// Activate line buffered mode for terminals
	f->lbf = EOF;
	long wsz_addr = (long)(&wsz);
	if (!(f->flags & (unsigned int)F_NOWR) && (!syscall(SYS_ioctl, fd, TIOCGWINSZ, (int)wsz_addr))) { f->lbf = '\n'; }
	// Initialize op ptrs
	f->read = &__stdio_read_helper;
	f->write = &__stdio_write_helper;
	f->seek = &__stdio_seek_helper;
	f->close = &__stdio_close_helper;
	if (!libc.threaded) { f->lock = -1; }
	return __ofl_add(f);
}
#define _fdopen(fd, m)   fdopen((fd), (m))
#define __fdopen(fd, m)   fdopen((fd), (m))
#define _IO_fdopen(fd, m)   fdopen((fd), (m))


/** Opens the file (given by the string) and associates a stream to the file */
LIB_FUNC FILE* fopen(const char* restrict filename, const char* restrict mode) {
	FILE* f;
	if (!(strchr("rwa", *mode))) { errno = EINVAL; return 0; }
	const int flags = fmodeflags(mode);
	int fd = (int)sys_open(filename, flags, 0666);
	if (fd < 0) { return 0; }
	else if (flags & O_CLOEXEC) { __syscall3(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC); }
	f = fdopen(fd, mode);
	if (f) { return f; }
	__syscall1(SYS_close, fd);
	return 0;
}
#define fopen64(filename, mode)   fopen((filename), (mode))
#define _IO_fopen(filename, mode)   fopen((filename), (mode))
#define _fopen(filename, mode)   fopen((filename), (mode))
#define __fopen(filename, mode)   fopen((filename), (mode))


/** Close a stream */
LIB_FUNC int fclose(FILE* f) {
	int r, perm;
	FLOCK(f);
	__unlist_locked_file(f);
	if (!(perm = (int)((int)f->flags & F_PERM))) {
		FILE** head = __ofl_lock();
		if (f->prev_locked) { f->prev_locked->next_locked = f->next_locked; }
		if (f->next_locked) { f->next_locked->prev_locked = f->prev_locked; }
		if (*head == f) { *head = f->next_locked; }
		__ofl_unlock();
	}
	r = fflush(f);
	r |= f->close(f);
	if (f->_lb._base) { free(f->_lb._base); }
	if (!perm) { free(f); }
	else { FUNLOCK(f); }
	return r;
}


LIB_FUNC int __fclose_ca(FILE* f) {
	return f->close(f);
}


LIB_FUNC FILE* freopen(const char* restrict filename, const char* restrict mode, FILE* restrict f) {
	int _fl = fmodeflags(mode);
	FLOCK(f);
	fflush(f);
	if (!filename) {
		if (_fl & O_CLOEXEC) { __syscall(SYS_fcntl, f->fd, F_SETFD, FD_CLOEXEC); }
		_fl &= (int)(~(O_CREAT | O_EXCL | O_CLOEXEC));
		if (syscall(SYS_fcntl, f->fd, F_SETFL, _fl) < 0) { fclose(f); return NULL; }
	} else {
		FILE* f2;
		f2 = fopen(filename, mode);
		if (!f2) { fclose(f); return NULL; }
		else if (f2->fd == f->fd) { f2->fd = -1; }
		else if ((__dup3(f2->fd, f->fd, (_fl & O_CLOEXEC)) < 0)) { fclose(f2); fclose(f); return NULL; }
		f->flags = (unsigned int)((f->flags & (unsigned int)F_PERM) | (unsigned int)f2->flags);
		f->read = f2->read;
		f->write = f2->write;
		f->seek = f2->seek;
		f->close = f2->close;
		fclose(f2);
	}
	FUNLOCK(f);
	return f;
}
#define freopen64(filename, mode, f)   freopen((filename), (mode), (f))


LIB_FUNC FILE* funopen(void* cookie, size_t (*readfn)(void*, unsigned char*, const size_t), size_t (*writefn)(void*, const unsigned char*, const size_t), off_t (*seekfn)(void*, const off_t, const int), int (*closefn)(void*)) {
	FILE* fp;
	int flags;
	if (readfn == NULL) {
		if (writefn == NULL) { errno = EINVAL; return NULL; }  // Illegal
		else { flags = __SWR; }  // Write-only
	} else {
		if (writefn == NULL) { flags = __SRD; }  // Read-only
		else { flags = __SRW; }  // Read-write
	}
	fp->flags = (unsigned int)flags;
	fp->_file = -1;
	fp->_cookie = (void*)cookie;
	fp->read = readfn;
	fp->write = writefn;
	fp->seek = seekfn;
	fp->close = closefn;
	return fp;
}
#define fropen(cookie, fn)   funopen((cookie), (fn), (0), (0), (0))
#define fwopen(cookie, fn)   funopen((cookie), (0), (fn), (0), (0))


LIB_FUNC void __stdio_exit(void) {
	FILE* f;
	for (f = *__ofl_lock(); f; f = f->next_locked) { __stdio_close(f); }
	__stdio_close(STDIN);
	__stdio_close(STDOUT);
}
#define stdio_exit()   __stdio_exit()
#define __stdio_exit_needed()   __stdio_exit()
#define stdio_exit_needed()   __stdio_exit()
#define __toread_needs_stdio_exit()   __stdio_exit()
#define __towrite_needs_stdio_exit()   __stdio_exit()


LIB_FUNC int __aio_close(const int fd) {
	return fd;
}


LIB_FUNC int __stdio_close(FILE* f) {
	return (int)__syscall1(SYS_close, __aio_close(f->fd));
}
#define close_file(f)   __stdio_close((f))
#define stdio_close(f)   __stdio_close((f))


LIB_FUNC int __stdio_close_helper(void* f) {
	return __stdio_close((FILE*)f);
}


LIB_FUNC off_t __stdio_seek(FILE* f, const off_t off, const int whence) {
	off_t ret;
#   ifdef SYS__llseek
	if (syscall(SYS__llseek, f->fd, (off >> 32), off, &ret, whence) < 0) { ret = -1; }
#   else
	ret = (off_t)syscall(SYS_lseek, f->fd, off, whence);
#   endif
	return ret;
}


LIB_FUNC off_t __stdio_seek_helper(void* f, const off_t off, const int whence) {
	return __stdio_seek((FILE*)f, off, whence);
}


LIB_FUNC size_t __stdio_read(FILE* f, unsigned char* buf, const size_t len) {
	const struct iovec iov[2] = { { .iov_base = buf, .iov_len = len - (!!(f->buf_size)) }, { .iov_base = f->buf, .iov_len = f->buf_size } };
	register ssize_t cnt = (ssize_t)__syscall3(SYS_readv, f->fd, (long)iov, 2);
	if (cnt <= 0) { f->flags |= (unsigned int)(F_EOF ^ ((F_ERR ^ F_EOF) & cnt)); return (size_t)cnt; }
	else if ((size_t)cnt <= iov[0].iov_len) { return (size_t)cnt; }
	cnt -= (ssize_t)iov[0].iov_len;
	f->rpos = f->buf;
	f->rend = (f->buf + cnt);
	if (f->buf_size) { buf[len - 1] = *f->rpos++; }
	return len;
}


LIB_FUNC size_t __stdio_read_helper(void* f, unsigned char* buf, const size_t len) {
	return __stdio_read((FILE*)f, buf, len);
}


LIB_FUNC size_t __stdio_write(FILE* f, const unsigned char* buf, const size_t len) {
	struct iovec iovs[2] = { { .iov_base = f->wbase, .iov_len = (unsigned long)(f->wpos - f->wbase) }, { .iov_base = (const void*)buf, .iov_len = len } };
	struct iovec* iov = iovs;
	register size_t rem = iov[0].iov_len + iov[1].iov_len;
	register int iovcnt = 2;
	register ssize_t cnt;
	for (;;) {
		cnt = (ssize_t)__syscall3(SYS_writev, f->fd, (long)iov, (long)iovcnt);
		if ((size_t)cnt == rem) {
			f->wend = (f->buf + f->buf_size);
			f->wpos = f->wbase = f->buf;
			return len;
		} else if (cnt < 0) {
			f->wpos = f->wbase = f->wend = 0;
			f->flags |= (unsigned int)F_ERR;
			return (iovcnt == 2 ? 0 : (len - iov[0].iov_len));
		}
		rem -= (size_t)cnt;
		if ((size_t)cnt > iov[0].iov_len) { cnt -= (ssize_t)iov[0].iov_len; iov++; iovcnt--; }
		iov[0].iov_base = (const char*)iov[0].iov_base + cnt;
		iov[0].iov_len -= (unsigned long)cnt;
	}
}


LIB_FUNC size_t __stdio_write_helper(void* f, const unsigned char* buf, const size_t len) {
	return __stdio_write((FILE*)f, buf, len);
}


LIB_FUNC size_t __stdout_write(FILE* f, const unsigned char* buf, const size_t len) {
	struct winsize wsz;
	f->write = &__stdio_write_helper;
	if (!(f->flags & (unsigned int)F_SVB) && __syscall3(SYS_ioctl, f->fd, TIOCGWINSZ, (long)&wsz)) { f->lbf = -1; }
	return __stdio_write(f, buf, len);
}


LIB_FUNC size_t __stdout_write_helper(void* f, const unsigned char* buf, const size_t len) {
	return __stdout_write((FILE*)f, buf, len);
}


LIB_FUNC void rewind(FILE* f) {
	FLOCK(f);
	fseeko_unlocked(f, 0, SEEK_SET);
	f->flags &= (unsigned int)(~F_ERR);
	FUNLOCK(f);
}


LIB_FUNC int fmodeflags(const char* mode) {
	register int flags;
	if (strchr(mode, '+')) { flags = O_RDWR; }
	else if (*mode == 'r') { flags = O_RDONLY; }
	else { flags = O_WRONLY; }
	if (strchr(mode, 'x')) { flags |= O_EXCL; }
	if (strchr(mode, 'e')) { flags |= O_CLOEXEC; }
	if (*mode != 'r') { flags |= O_CREAT; }
	if (*mode == 'w') { flags |= O_TRUNC; }
	if (*mode == 'a') { flags |= O_APPEND; }
	return flags;
}
#define __fmodeflags(mode)   fmodeflags((mode))


LIB_FUNC int fseeko_unlocked(FILE* f, off_t off, const int whence) {
	if (whence == SEEK_CUR) { off -= f->rend - f->rpos; }
	if (f->wpos > f->wbase) {  // Flush write buffer, and report error on failure
		f->write(f, 0, 0);
		if (!f->wpos) { return -1; }
	}
	f->wpos = f->wbase = f->wend = 0;  // Leave writing mode
	if (f->seek(f, off, whence) < 0) { return -1; }  // Perform the underlying seek
	f->rpos = f->rend = 0;  // If seek succeeded, file is seekable and we discard read buffer
	f->flags &= (unsigned int)(~F_EOF);
	return 0;
}
#define __fseeko_unlocked(f, off, whence)   fseeko_unlocked((f), (off), (whence))


LIB_FUNC int fseeko(FILE* f, off_t off, const int whence) {
	FLOCK(f);
	const int result = fseeko_unlocked(f, off, whence);
	FUNLOCK(f);
	return result;
}
#define __fseeko(f, off, whence)   fseeko((f), (off), (whence))
#define __fseeko64(f, off, whence)   fseeko((f), (off), (whence))
#define fseeko64(f, off, whence)   fseeko((f), (off), (whence))


/** Sets the file position indicator to the desired point */
LIB_FUNC int fseek(FILE* f, long off, const int whence) {
	return fseeko(f, off, whence);
}
#define __fseek(f, off, whence)   fseek((f), (off), (whence))
#define __fseek64(f, off, whence)   fseek((f), (off), (whence))
#define fseek64(f, off, whence)   fseek((f), (off), (whence))


/** Get the current file position */
LIB_FUNC int fgetpos(FILE* restrict f, fpos_t* restrict pos) {
	const off_t off = ftello(f);
	if (off < 0) { return -1; }
	*(off_t*)pos = off;
	return 0;
}
#define fgetpos64(f, pos)   fgetpos((f), (pos))


/** Set the current file position */
LIB_FUNC int fsetpos(FILE* f, const fpos_t* pos) {
	return __fseeko(f, *(const off_t*)pos, SEEK_SET);
}
#define fsetpos64(f, pos)   fsetpos((f), (pos))


LIB_FUNC off_t __ftello_unlocked(FILE* f) {
	const off_t pos = f->seek(f, 0, ((f->flags & F_APP) && f->wpos > f->wbase ? SEEK_END : SEEK_CUR));
	if (pos < 0) { return pos; }
	return (off_t)(pos - (f->rend - f->rpos) + (f->wpos - f->wbase));
}


/** Returns the current value of the file position indicator */
LIB_FUNC off_t ftello(FILE* f) {
	FLOCK(f);
	const off_t pos = __ftello_unlocked(f);
	FUNLOCK(f);
	return pos;
}
#define __ftello(f)   ftello((f))
#define __ftello64(f)   ftello((f))
#define ftello64(f)   ftello((f))


/** Returns the current value of the file position indicator */
LIB_FUNC long ftell(FILE* f) {
	const off_t pos = ftello(f);
	if (pos > LONG_MAX) {
		errno = EOVERFLOW;
		return -1;
	}
	return pos;
}


/** Set and determine the orientation of a FILE stream */
LIB_FUNC int fwide(FILE* f, int mode) {
	FLOCK(f);
	if (mode) { if (!f->mode) { f->mode = (mode > 0 ? 1 : -1); } }
	mode = f->mode;
	FUNLOCK(f);
	return mode;
}


/** Deletes a file or directory from the file system */
LIB_FUNC int remove(const char* path) {
#   ifdef SYS_unlink
	int r = (int)__syscall(SYS_unlink, (long)&path);
#   else
	int r = (int)__syscall(SYS_unlinkat, AT_FDCWD, (long)&path, 0);
#   endif
#   ifdef SYS_rmdir
	if (r == -EISDIR) { r = (int)__syscall(SYS_rmdir, (long)&path); }
#   else
	if (r == -EISDIR) { r = (int)__syscall(SYS_unlinkat, AT_FDCWD, (long)&path, AT_REMOVEDIR); }
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


/** Renames a file or directory on the file system */
LIB_FUNC int rename(const char* old, const char* new) {
#   ifdef SYS_rename
	return (int)syscall(SYS_rename, old, new);
#   else
	return (int)syscall(SYS_renameat, AT_FDCWD, old, AT_FDCWD, new);
#   endif
}


/** Rename a file relative to directory file descriptors */
LIB_FUNC int renameat(const int oldfd, const char* old, const int newfd, const char* new) {
	return (int)syscall(SYS_renameat, oldfd, old, newfd, new);
}


LIB_FUNC const char* trailsl(const char *f) {
	const char* s = f;
	while (*s) { s++; }
	return ((f != s && s[-1] == '/') ? (const char*)"" : (const char*)"/");
}


#ifndef TMPFILE_MAXTRIES
#   define TMPFILE_MAXTRIES   4
#endif


LIB_FUNC FILE* tmpfile(void) {
	char s[32] = "/tmp/tmpfile_XXXXXX\0";
	int fd;
	FILE* f;
	register int try;
	for (try = 0; try < TMPFILE_MAXTRIES; try++) {
		randname(s + 13);
		fd = (int)sys_open(s, (O_RDWR | O_CREAT | O_EXCL), 0600);
		if (fd >= 0) {
#   ifdef SYS_unlink
			__syscall(SYS_unlink, (long)&s);
#   else
			__syscall(SYS_unlinkat, AT_FDCWD, s, 0);
#   endif
			f = fdopen(fd, "w+");
			if (!f) { __syscall(SYS_close, fd); }
			return f;
		}
	}
	return 0;
}
#define tmpfile64()   tmpfile()


LIB_FUNC char* tmpnam(char* buf) {
	char s[32] = "/tmp/tmpnam_XXXXXX\0";
	int try, r;
	for (try = 0; try < TMPFILE_MAXTRIES; try++) {
		randname(s + 12);
#   ifdef SYS_lstat
		r = (int)__syscall(SYS_lstat, (long)&s, (long)&(struct stat) {0});
#   else
		r = (int)__syscall(SYS_fstatat, AT_FDCWD, s, (long)&(struct stat) {0}, AT_SYMLINK_NOFOLLOW);
#   endif
		static char internal[L_tmpnam] = { 0 };
		if (r == -ENOENT) { return strcpy((buf ? buf : internal), s); }
	}
	return 0;
}


LIB_FUNC char* tempnam(const char* dir, const char* pfx) {
	char s[PATH_MAX];
	int try, r;
	if (!dir) { dir = P_tmpdir; }
	if (!pfx) { pfx = "temp"; }
	const size_t dl = strlen(dir);
	const size_t pl = strlen(pfx);
	size_t l = dl + pl + 8;
	if (l >= PATH_MAX) {
		errno = ENAMETOOLONG;
		return 0;
	}
	memcpy_no_output(s, dir, dl);
	s[dl] = '/';
	memcpy_no_output(s + dl + 1, pfx, pl);
	s[dl + 1 + pl] = '_';
	s[l] = 0;
	for (try = 0; try < 100; try++) {
		randname(s + l - 6);
#   ifdef SYS_lstat
		r = (int)__syscall(SYS_lstat, (long)s, (long)&(struct stat) {0});
#   else
		r = (int)__syscall(SYS_fstatat, AT_FDCWD, (long)s, (long)&(struct stat) {0}, AT_SYMLINK_NOFOLLOW);
#   endif
		if (r == -ENOENT) { return strdup(s); }
	}
	return 0;
}


/** Return the name of the controlling terminal. If S is not NULL, the name is copied into it (it should be at least L_ctermid bytes long), otherwise we return a pointer to a non-const but read-only string literal, that POSIX states the caller must not modify */
LIB_FUNC char* ctermid(char* s) {
	static char def[16] = _PATH_TTY;
	if (s) {
		strncpy_no_output(s, def, (size_t)L_ctermid);
		return s;
	}
	return def;
}


/* TODO: Add stdio functions
FILE* fmemopen(void* restrict, size_t, const char* restrict);
int pclose(FILE*);
FILE* popen(const char*, const char*);
*/


#endif  // STDIO_H


/* SIGNAL HANDLING (<signal.h>, <bits/signum.h>, <bits/sigset.h>, & <sys/select.h>) */


#if (!(defined(_SIGNAL_H) || defined(_SIGSET_H_types) || defined(_SIGSET_H_TYPES) || defined(_SIGSET_H_fns) || defined(_SIGSET_H_FNS) || defined(_SCHILY_SIGSET_H) || defined(_SYS__SIGSET_H_) || defined(_SYS_SELECT_H) || defined(_SYS_SIGNALFD_H)))  // http://www.cplusplus.com/reference/csetjmp/ & http://www.cplusplus.com/reference/csignal/
#define SIGNAL_H   (1)
#define _SIGNAL_H   (1)
#define _SIGSET_H_types   (1)
#define _SIGSET_H_TYPES   (1)
#define _SIGSET_H_fns   (1)
#define _SIGSET_H_FNS   (1)
#define _SYS_SIGNALFD_H   (1)
#define _SYS_SIGNALFD_H_   (1)
#define _SCHILY_SIGSET_H   (1)
#define _SYS__SIGSET_H_   (1)
#define _SIGSET_CVT_MASK_H   (1)
#define _SYS_SELECT_H   (1)  // Select from File Descriptor Sets (<sys/select.h>)


/** Helper function to abort the program due to fd_set-related fortification errors */
LIB_FUNC long __fdelt_chk(const long d) {
	if (d < 0 || d >= FD_SETSIZE) {
		fprintf(stderr, "Bit outside of fd_set selected!\n");
		abort();
		UNREACHABLE
	}
	return (long)(d / __NFDBITS);
}


/** Return a mask that includes the bit for SIG only */
#define __sigmask(sig)   (((unsigned long)1) << (unsigned long)((unsigned long)((sig) - 1) % BITS_PER_LONG))
/** Return a mask that includes the bit for SIG only */
#define sigmask(sig)   __sigmask((sig))
/** Return the word index for SIG */
#define __sigword(sig)   (((unsigned)((sig) - 1) / BITS_PER_LONG))
/** Return the word index for SIG */
#define sigword(sig)   __sigword((sig))


LIB_FUNC int __sigfillset(sigset_t* set) {
	if (_SIGSET_NWORDS <= 2) {
		set->__bits[0] = (unsigned long)(~0UL);
		if (_SIGSET_NWORDS == 2) { set->__bits[1] = (unsigned long)(~0UL); }
	} else {
		register int cnt = _SIGSET_NWORDS;
		while (--cnt >= 0) { set->__bits[cnt] = (unsigned long)(~0UL); }
	}
	return 0;
}
#define sigfillset(set)   __sigfillset(set)


LIB_FUNC int __sigemptyset(sigset_t* set) {
	set->__bits[0] = 0;
	if (SIZEOF_LONG == 4 || _NSIG > 65) { set->__bits[1] = 0; }
	if (SIZEOF_LONG == 4 && _NSIG > 65) {
		set->__bits[2] = 0;
		set->__bits[3] = 0;
	}
	return 0;
}
#define sigemptyset(set)   __sigemptyset(set)


LIB_FUNC int __sigisemptyset(const sigset_t* set) {
	static const unsigned long zeroset[_NSIG / 8 / SIZEOF_LONG];
	return (int)(!(memcmp(set, &zeroset, (_NSIG / 8))));
}
#define sigisemptyset(set)   __sigisemptyset(set)


LIB_FUNC int sigandset(sigset_t* dest, const sigset_t* left, const sigset_t* right) {
	unsigned long i = 0, *d = (void*)dest;
	const unsigned long *l = (const void*)left, *r = (const void*)right;
	for(; i < (_NSIG / 8 / SIZEOF_LONG); i++) { d[i] = l[i] & r[i]; }
	return 0;
}
#define sigandset(dest, left, right)   __sigandset(dest, left, right)


LIB_FUNC int sigorset(sigset_t* dest, const sigset_t* left, const sigset_t* right) {
	unsigned long i = 0, *d = (void*)dest;
	const unsigned long *l = (const void*)left, *r = (const void*)right;
	for(; i < (_NSIG / 8 / SIZEOF_LONG); i++) { d[i] = l[i] | r[i]; }
	return 0;
}
#define sigorset(dest, left, right)   __sigorset(dest, left, right)


/** Get and/or change the set of blocked signals */
LIB_FUNC int __sigprocmask(const int how, const sigset_t* restrict set, sigset_t* restrict old) {
	const int r = pthread_sigmask(how, set, old);
	if (!r) { return r; }
	errno = r;
	return -1;
}
#define sigprocmask(how, set, oset)   __sigprocmask((how), (set), (oset))


/** Return 1 if SIGNO is in SET, 0 if not */
LIB_FUNC int sigismember(const sigset_t* set, int sig) {
	unsigned int s = (unsigned int)sig - 1;
	if (s >= (_NSIG - 1)) { return 0; }
	return !(!(set->__bits[s / 8 / sizeof(*set->__bits)] & 1UL << ((s & 8 * sizeof(*set->__bits)) - 1)));
}
#define __sigismember(_set, __sig)   sigismember(_set, __sig)


LIB_FUNC int __sigaddset(sigset_t* set, const int sig) {
	unsigned int s = (unsigned int)sig - 1;
	if (s >= (_NSIG - 1) || ((unsigned int)sig - 32U) < 3) {
		errno = EINVAL;
		return -1;
	}
	set->__bits[s / 8 / sizeof(*set->__bits)] |= (1UL << ((s & 8 * sizeof(*set->__bits)) - 1));
	return 0;
}
#define sigaddset(_set, __sig)   __sigaddset((_set), (__sig))
#define _sigaddset(_set, __sig)   __sigaddset((_set), (__sig))


LIB_FUNC int __sigdelset(sigset_t* set, int sig) {
	unsigned int s = (unsigned int)sig - 1;
	if (s >= (_NSIG - 1) || ((unsigned int)sig - 32U) < 3) {
		errno = EINVAL;
		return -1;
	}
	set->__bits[s / 8 / sizeof(*set->__bits)] &= (~(1UL << ((s & 8 * sizeof(*set->__bits)) - 1)));
	return 0;
}
#define sigdelset(_set, __sig)   __sigdelset(_set, __sig)


LIB_FUNC UNUSED void sigset_set_old_mask(sigset_t* set, const int mask) {
	if (PREDICT_LIKELY(_SIGSET_NWORDS == 2)) { set->__bits[1] = 0; }
	if (_SIGSET_NWORDS > 2) { memset_no_output(set, 0, sizeof(*set)); }
	set->__bits[0] = (unsigned long)mask;
}


LIB_FUNC UNUSED int sigset_get_old_mask(const sigset_t* set) {
	return (int)(set->__bits[0]);
}


/** Set the mask of blocked signals to MASK, returning the old mask */
LIB_FUNC int sigsetmask(const int mask) {
	sigset_t set, oset;
	sigset_set_old_mask(&set, mask);
	sigprocmask(SIG_SETMASK, &set, &oset);
	return sigset_get_old_mask(&oset);
}
#define HAVE_SIGSETMASK   (1)
#define __sigsetmask(mask)   sigsetmask(mask)


/** Add signal to the calling process' signal mask */
LIB_FUNC int sighold(const int sig) {
	sigset_t mask;
	sigemptyset(&mask);
	if (sigaddset(&mask, sig) < 0) { return -1; }
	return sigprocmask(SIG_BLOCK, &mask, 0);
}
#define __sighold(sig)   sighold(sig)
#define _sighold(sig)   sighold(sig)


/** Block signals in MASK, returning the old mask */
LIB_FUNC int sigblock(const int mask) {
	sigset_t set, oset;
	sigset_set_old_mask(&set, mask);
	sigprocmask(SIG_BLOCK, &set, &oset);
	return sigset_get_old_mask(&oset);
}
#define __sigblock(sig)   sigblock(sig)


/** Remove SIG from the calling process' signal mask */
LIB_FUNC int sigrelse(const int sig) {
	sigset_t set;
	sigprocmask(SIG_SETMASK, NULL, &set);
	sigdelset(&set, sig);
	return sigprocmask(SIG_SETMASK, &set, NULL);
}
#define __sigrelse(sig)   sigrelse((sig))
#define sigrelease(sig)   sigrelse((sig))
#define __sigrelease(sig)   sigrelse((sig))


/** Set the disposition of SIG to SIG_IGN */
LIB_FUNC int sigignore(const int sig) {
	struct sigaction act;
	memset_no_output(&act, 0, sizeof(act));
	act.sa_handler = SIG_IGN;
	return __sigaction(sig, &act, 0);
}


/** If INTERRUPT is nonzero, make signal SIG interrupt system calls (causing them to fail with EINTR); if INTERRUPT is zero, make system calls be restarted after signal SIG */
LIB_FUNC int siginterrupt(const int sig, const int flag) {
	struct sigaction sa;
	__sigaction(sig, 0, &sa);
	if (flag) { sa.sa_flags &= (unsigned long)(~SA_RESTART); }
	else { sa.sa_flags |= SA_RESTART; }
	return __sigaction(sig, &sa, 0);
}
#define __siginterrupt(sig)   siginterrupt(sig)
#define sigintr(sig)   siginterrupt(sig)
#define __sigintr(sig)   siginterrupt(sig)


/** Set the handler for the signal SIG to HANDLER, returning the old handler, or SIG_ERR on error */
LIB_FUNC void (*sigset(const int sig, void (*handler)(int)))(int) {
	struct sigaction sa, sa_old;
	sigset_t mask;
	sigemptyset(&mask);
	if (sigaddset(&mask, sig) < 0) { return SIG_ERR; }
	if (handler == SIG_HOLD) {
		if (__sigaction(sig, 0, &sa_old) < 0) { return SIG_ERR; }
		if (sigprocmask(SIG_BLOCK, &mask, &mask) < 0) { return SIG_ERR; }
	} else {
		sa.sa_handler = handler;
		sa.sa_flags = 0;
		sigemptyset(&sa.sa_mask);
		if (__sigaction(sig, &sa, &sa_old) < 0) { return SIG_ERR; }
		if (sigprocmask(SIG_UNBLOCK, &mask, &mask) < 0) { return SIG_ERR; }
	}
	return (sigismember(&mask, sig) ? SIG_HOLD : sa_old.sa_handler);
}
#define __signal(sig, handler)   sigset((sig), (handler))
#define bsd_signal(sig, handler)   __signal((sig), (handler))
#define __bsd_signal(sig, handler)   __signal((sig), (handler))
#define signal(sig, handler)   __signal((sig), (handler))


/** Set the handler for the signal SIG to HANDLER, returning the old handler, or SIG_ERR on error */
LIB_FUNC __sighandler_t __sysv_signal(int sig, __sighandler_t handler) {
	struct sigaction act, oact;
	if (handler == SIG_ERR || sig < 1 || sig >= NSIG) {
		__set_errno (EINVAL);
		return SIG_ERR;
	}
	act.sa_handler = handler;
	__sigemptyset (&act.sa_mask);
	act.sa_flags = (unsigned long)((unsigned long)(SA_ONESHOT | SA_NOMASK | SA_INTERRUPT) & (unsigned long)(~SA_RESTART));
	if (__sigaction(sig, &act, &oact) < 0) { return SIG_ERR; }
	return oact.sa_handler;
}
#define sysv_signal(sig, handler)   sysv_signal(sig, handler)


LIB_FUNC int kill(const pid_t pid, const int sig) {
	return (int)__syscall2(SYS_kill, pid, sig);
}


/** Raise a signal */
LIB_FUNC int raise(const int signo) {
	return kill(getpid(), signo);
}
/** SVID name for raise() */
#define gsignal(sig)   raise((sig))


/** Allocate real-time signal with highest/lowest available priority */
LIB_FUNC int __libc_allocate_rtsig(const int high) {
	if (__SIGRTMIN == -1 || __SIGRTMIN > __SIGRTMAX) { return -1; }
	return high;
}
#define __libc_allocate_rtsig_private   __libc_allocate_rtsig


LIB_FUNC const char* strsignal(const int signum) {
	static char buf[_STRSIGNAL_BUFSIZE] = { 0 };
	static const char unknown[16] = "Unknown Signal\0";
	return memcpy(uintmaxtostr((signed long)signum, buf), unknown, 16);
}


/** Print a message describing the meaning of the given signal number */
LIB_FUNC void psignal(const int signum, register const char* message) {
	register const char* sep = ": ";
	if (!(message && *message)) { message = (sep += 2); }
	fprintf(stderr, "%s%s%s\n", message, sep, strsignal(signum));
}


LIB_FUNC int select(int n, fd_set* restrict rfds, fd_set* restrict wfds, fd_set* restrict efds, struct timeval* restrict tv) {
#   ifdef SYS_select
	return (int)__syscall(SYS_select, n, (long)&rfds, (long)&wfds, (long)&efds, (long)&tv);
#   else
	syscall_arg_t data[2] = { 0, (_NSIG / 8) };
	struct timespec ts;
	if (tv) {
		if (tv->tv_sec < 0 || tv->tv_usec < 0) { return (int)__syscall_ret(-EINVAL); }
		time_t extra_secs = (tv->tv_usec / 1000000);
		ts.tv_nsec = tv->tv_usec % 1000000 * 1000;
		const time_t max_time = (time_t)((1ULL << 8 * SIZEOF_TIME_T - 1) - 1);
		ts.tv_sec = (extra_secs > (max_time - tv->tv_sec) ? max_time : (tv->tv_sec + extra_secs));
	}
	return (int)__syscall(SYS_pselect6, n, (long)&rfds, (long)&wfds, (long)&efds, (tv ? &ts : 0), data);
#   endif
}


/** PM passes the address of a structure of this type to the Minix kernel when sys_sigsend() is invoked as part of the signal catching mechanism; The structure contain all the information that the Minix kernel needs to build the signal stack */
typedef struct attr_packed sigmsg {
	int sm_signo;  // Signal number being caught
	sigset_t sm_mask;  // Mask to restore when handler returns
	vir_bytes sm_sighandler;  // Address of handler
	vir_bytes sm_sigreturn;  // Address of _sigreturn in C library
	vir_bytes sm_stkptr;  // User stack pointer
} sigmsg_t;


/* TODO: Add signal.h functions
int  pselect(int, fd_set* restrict, fd_set* restrict, fd_set* restrict, const struct timespec* restrict, const sigset_t* restrict);
*/


#endif  // SIGNAL_H


/* POSIX 1003.1B-1993 (POSIX 4) SCHEDULING INTERFACE (<bits/sched.h>) */


#if (!(defined(_SCHED_H) || defined(_SCHED_H_)))
#define _SCHED_H   (1)
#define _SCHED_H_   (1)


// Scheduling algorithms
#define SCHED_OTHER   0
#define SCHED_FIFO   1
#define SCHED_RR   2
#define SCHED_BATCH   3
#define SCHED_IDLE   5
#define SCHED_RESET_ON_FORK   0x40000000


/** Signal mask to be sent at exit */
#define CSIGNAL   0xff
/** Set if VM shared between processes */
#define CLONE_VM   0x100
/** Set if fs info shared between processes */
#define CLONE_FS   0x200
/** Set if open files shared between processes */
#define CLONE_FILES   0x400
/** Set if signal handlers shared */
#define CLONE_SIGHAND   0x800
/** Set if tracing continues on the child */
#define CLONE_PTRACE   0x2000
/** Set if the parent wants the child to wake it up on mm_release */
#define CLONE_VFORK   0x4000
/** Set if we want to have the same parent as the cloner */
#define CLONE_PARENT   0x8000
/** Set to add to same thread group */
#define CLONE_THREAD   0x10000
/** Set to create new namespace */
#define CLONE_NEWNS   0x20000
/** Set to shared SVID SEM_UNDO semantics */
#define CLONE_SYSVSEM   0x40000
/** Set TLS info */
#define CLONE_SETTLS   0x80000
/** Store TID in userlevel buffer before MM copy */
#define CLONE_PARENT_SETTID   0x100000
/** Register exit futex and memory location to clear */
#define CLONE_CHILD_CLEARTID   0x200000
/** Create clone detached */
#define CLONE_DETACHED   0x400000
/** Set if the tracing process cannot force CLONE_PTRACE on this clone */
#define CLONE_UNTRACED   0x800000
/** Store TID in userlevel buffer in the child */
#define CLONE_CHILD_SETTID   0x1000000
/** New utsname group */
#define CLONE_NEWUTS   0x4000000
/** New ipcs */
#define CLONE_NEWIPC   0x8000000
/** New user namespace */
#define CLONE_NEWUSER   0x10000000
/** New pid namespace */
#define CLONE_NEWPID   0x20000000
/** New network namespace */
#define CLONE_NEWNET   0x40000000
/** Clone I/O context */
#define CLONE_IO   0x80000000


// Basic access functions
#define __CPUELT(cpu)   ((cpu) / __NCPUBITS)
#define __CPUMASK(cpu)   ((__cpu_mask)1 << ((cpu) % __NCPUBITS))
// Access functions for CPU masks
#define __CPU_ZERO_S(setsize, cpusetp)   do { size_t __i, __imax = ((setsize) / SIZEOF_LONG); __cpu_mask* __bits = (cpusetp)->__bits; for (__i = 0; __i < __imax; ++__i) { __bits[__i] = 0; } } while (0x0)
#define __CPU_SET_S(cpu, setsize, cpusetp)   (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask*)((cpusetp)->__bits))[__CPUELT(__cpu)] |= __CPUMASK(__cpu)) : 0; }))
#define __CPU_CLR_S(cpu, setsize, cpusetp)   (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask*)((cpusetp)->__bits))[__CPUELT(__cpu)] &= ~__CPUMASK(__cpu)) : 0; }))
#define __CPU_ISSET_S(cpu, setsize, cpusetp)   (__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? ((((const __cpu_mask*)((cpusetp)->__bits))[__CPUELT(__cpu)] & __CPUMASK(__cpu))) != 0 : 0; }))
#define __CPU_COUNT_S(setsize, cpusetp)   __sched_cpucount(setsize, cpusetp)
#define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)   (memcmp(cpusetp1, cpusetp2, setsize) == 0)
#define __CPU_OP_S(setsize, destset, srcset1, srcset2, op)   (__extension__ ({ cpu_set_t* __dest = (destset); const __cpu_mask* __arr1 = (srcset1)->__bits; const __cpu_mask* __arr2 = (srcset2)->__bits; size_t __imax = (setsize) / SIZEOF_LONG; size_t __i; for (__i = 0; __i < __imax; ++__i) { ((__cpu_mask*) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i]; } __dest; }))
#define __sched_cpualloc(cnt)   ((cpu_set_t*)malloc(__CPU_ALLOC_SIZE(cnt)))
#define __sched_cpufree(__set)   free(__set)
#define __CPU_ALLOC_SIZE(count)   ((((count) + __NCPUBITS - 1) / __NCPUBITS) * SIZEOF_LONG)
#define __CPU_ALLOC(count)   __sched_cpualloc(count)
#define __CPU_FREE(cpuset)   __sched_cpufree(cpuset)
#define CPU_ALLOC_SIZE(count)   __CPU_ALLOC_SIZE(count)
#define CPU_ALLOC(count)   __sched_cpualloc(count)
#define CPU_FREE(cpuset)   __sched_cpufree(cpuset)
// Access macros for `cpu_set`
#define CPU_SETSIZE   __CPU_SETSIZE
#define CPU_SET(cpu, cpusetp)   __CPU_SET_S(cpu, SIZEOF_LONG, cpusetp)
#define CPU_CLR(cpu, cpusetp)   __CPU_CLR_S(cpu, SIZEOF_LONG, cpusetp)
#define CPU_ISSET(cpu, cpusetp)   __CPU_ISSET_S(cpu, SIZEOF_LONG, cpusetp)
#define CPU_ZERO(cpusetp)   __CPU_ZERO_S(SIZEOF_LONG, cpusetp)
#define CPU_COUNT(cpusetp)  __CPU_COUNT_S(SIZEOF_LONG, cpusetp)
#define CPU_SET_S(cpu, setsize, cpusetp)   __CPU_SET_S(cpu, setsize, cpusetp)
#define CPU_CLR_S(cpu, setsize, cpusetp)   __CPU_CLR_S(cpu, setsize, cpusetp)
#define CPU_ISSET_S(cpu, setsize, cpusetp)   __CPU_ISSET_S(cpu, setsize, cpusetp)
#define CPU_ZERO_S(setsize, cpusetp)   __CPU_ZERO_S(setsize, cpusetp)
#define CPU_COUNT_S(setsize, cpusetp)   __CPU_COUNT_S(setsize, cpusetp)
#define CPU_EQUAL(cpusetp1, cpusetp2)   __CPU_EQUAL_S(SIZEOF_LONG, cpusetp1, cpusetp2)
#define CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)   __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)
#define CPU_AND(destset, srcset1, srcset2)   __CPU_OP_S(SIZEOF_LONG, destset, srcset1, srcset2, &)
#define CPU_OR(destset, srcset1, srcset2)   __CPU_OP_S(SIZEOF_LONG, destset, srcset1, srcset2, |)
#define CPU_XOR(destset, srcset1, srcset2)   __CPU_OP_S(SIZEOF_LONG, destset, srcset1, srcset2, ^)
#define CPU_AND_S(setsize, destset, srcset1, srcset2)   __CPU_OP_S(setsize, destset, srcset1, srcset2, &)
#define CPU_OR_S(setsize, destset, srcset1, srcset2)   __CPU_OP_S(setsize, destset, srcset1, srcset2, |)
#define CPU_XOR_S(setsize, destset, srcset1, srcset2)   __CPU_OP_S(setsize, destset, srcset1, srcset2, ^)
#ifdef MIPS
#   define _KERNEL_NSIG_WORDS   (_NSIG / _MIPS_SZLONG)
typedef struct __kernel_sigset {
	unsigned long sig[_KERNEL_NSIG_WORDS];
} kernel_sigset_t;
#   define __SYSCALL_SIGSET_T_SIZE   (sizeof(kernel_sigset_t))
#else
#   define __SYSCALL_SIGSET_T_SIZE   (_NSIG / 8)
#endif


LIB_FUNC int sched_yield(void) {
	return (int)syscall(SYS_sched_yield, 0);
}


/** Signal handler datatype */
typedef void (*handler_t)(int signal);
/** Set of current actions; If sa_handler for an entry is NULL, then that signal is not currently handled by the sigaction handler */
static UNUSED struct sigaction volatile action_array[NSIG];


#define __NR___syscall_rt_sigaction   __NR_rt_sigaction
LIB_FUNC int rt_sigaction(int signum, const struct sigaction* act, struct sigaction* oldact, size_t size) {
	return (int)syscall(SYS_rt_sigaction, signum, (long)&act, (long)&oldact, (long)size);
}


LIB_FUNC int sched_get_priority_max(int policy) {
	return (int)syscall(SYS_sched_get_priority_max, policy);
}


LIB_FUNC int sched_get_priority_min(int policy) {
	return (int)syscall(SYS_sched_get_priority_min, policy);
}


/** Signal handler that is installed for signals */
LIB_FUNC void sigaction_handler(int sig) {
	handler_t handler;
	sigset_t mask, oldmask;
	int saved_errno = errno;
	if (sig < 0 || NSIG <= sig || (!action_array[sig].sa_handler)) {
			if (sig == SIGABRT) { signal(SIGABRT, SIG_DFL); }
			abort();
		}
	// Reinstall the signal handler when required; otherwise update the bookkeeping
	handler = action_array[sig].sa_handler;
	if ((action_array[sig].sa_flags & SA_RESETHAND) == 0) { signal(sig, sigaction_handler); }
	else { action_array[sig].sa_handler = NULL; }
	// Block appropriate signals
	mask = action_array[sig].sa_mask;
	if ((action_array[sig].sa_flags & SA_NODEFER) == 0) { sigaddset(&mask, sig); }
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	// Invoke the user's handler, then restore prior mask
	errno = saved_errno;
	handler(sig);
	saved_errno = errno;
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	errno = saved_errno;
}


#if (defined(ARCHX86_64) || defined(ARCHX86))
UNUSED void __restore_rt(void);
asm (".text;" ".align 16;" "__restore_rt:" "movq $15, %rax;" "syscall;" "hlt;");
#endif


LIB_FUNC int __rt_sigaction(const int signum, const struct sigaction* act, struct sigaction* oldact, const long nr) {
	return (int)syscall(SYS_rt_sigaction, signum, (long)&act, (long)&oldact, nr);
}


#define __NR___syscall_sigaction   __NR_sigaction
/** If ACT is not NULL, change the action for SIG to *ACT; If OACT is not NULL, put the old action for SIG in *OACT */
LIB_FUNC int __sigaction(const int _sig, const struct sigaction* act, struct sigaction* oact) {
	struct sigaction* newact = (struct sigaction*)__UNCONST(act);
	if (act) {
		newact->sa_handler = act->sa_handler;
		newact->sa_flags = (act->sa_flags | SA_RESTORER);
		newact->sa_restorer = &__restore_rt;
		newact->sa_mask = act->sa_mask;
	}
	return (int)syscall(SYS_rt_sigaction, _sig, (long)&newact, (long)&oact, (long)(_NSIG / 8));
}
#define __libc_sigaction(sig, act, oact)   __sigaction((sig), (act), (oact))


#define __NR___syscall_sched_getparam   SYS_sched_getparam
LIB_FUNC int sched_getparam(const pid_t pid, struct sched_param* p) {
	return (int)syscall(SYS_sched_getparam, pid, p);
}


#define __NR___syscall_sched_setparam   SYS_sched_setparam
LIB_FUNC int sched_setparam(const pid_t pid, const struct sched_param* p) {
	return (int)syscall(SYS_sched_setparam, (long)pid, (long)&p);
}


#define __NR___syscall_sched_getaffinity   __NR_sched_getaffinity
/** Get the CPU affinity for a task */
LIB_FUNC int sched_getaffinity(const pid_t pid, const size_t cpusetsize, cpu_set_t* cpuset) {
	register int res = (int)syscall(SYS_sched_getaffinity, (long)pid, (long)MIN((long)INT_MAX, (long)cpusetsize), (long)&cpuset);
	if (res != -1) {
		memset_no_output((char*)(cpuset + res), '\0', (size_t)(cpusetsize - (size_t)res));
		res = 0;
	}
	return res;
}


#if STACK_GROWS_DOWN
#   define extend_alloca(buf, len, newlen)   __extension__ ((typeof(buf)) ({ size_t __newlen = (newlen); char*__newbuf = alloca(__newlen); if ((__newbuf + __newlen) == (char*)buf) { len += __newlen; } else { len = __newlen; } __newbuf; }))
#elif STACK_GROWS_UP
#   define extend_alloca(buf, len, newlen)   __extension__ ((typeof(buf)) ({ size_t __newlen = (newlen); char*__newbuf = alloca(__newlen); char* __buf = (buf); if ((__buf + __newlen) == __newbuf) { len += __newlen; __newbuf = __buf; } else { len = __newlen; } __newbuf; }))
#else
#   define extend_alloca(buf, len, newlen)   alloca(((len) = (newlen)))
#endif


#define __NR___syscall_sched_setaffinity   __NR_sched_setaffinity
static UNUSED size_t __kernel_cpumask_size;
/** Set the CPU affinity for a task */
LIB_FUNC int sched_setaffinity(const pid_t pid, const size_t cpusetsize, const cpu_set_t* cpuset) {
	size_t cnt;
	if (PREDICT_UNLIKELY(__kernel_cpumask_size == 0)) {
		INTERNAL_SYSCALL_DECL(err);
		int res;
		size_t psize = 128;
		void* p = alloca(psize);
		while (res = (int)syscall(SYS_sched_getaffinity, err, 3, getpid(), psize, p), INTERNAL_SYSCALL_ERROR_P(res, err) && INTERNAL_SYSCALL_ERRNO(res, err) == EINVAL) {
			p = extend_alloca(p, psize, (2 * psize));
		}
		if (res == 0 || INTERNAL_SYSCALL_ERROR_P(res, err)) {
			__set_errno (INTERNAL_SYSCALL_ERRNO(res, err));
			return -1;
		}
		__kernel_cpumask_size = (size_t)res;
	}
	for (cnt = __kernel_cpumask_size; cnt < cpusetsize; ++cnt)
		if (((const char*)cpuset)[cnt] != '\0') {
			__set_errno(EINVAL);
			return -1;
		}
	return (int)syscall(SYS_sched_setaffinity, (long)pid, (long)cpusetsize, (long)&cpuset);
}


#define __NR___syscall_sched_getscheduler   __NR_sched_getscheduler
LIB_FUNC int sched_getscheduler(const pid_t pid) {
	return (int)syscall(SYS_sched_getscheduler, (long)pid);
}


#define __NR___syscall_sched_setscheduler   __NR_sched_setscheduler
LIB_FUNC int sched_setscheduler(const pid_t pid, const int policy, const struct sched_param* p) {
	return (int)syscall(SYS_sched_setscheduler, (long)pid, policy, (long)&p);
}


#define __NR___syscall_sched_rr_get_interval   __NR_sched_rr_get_interval
LIB_FUNC int sched_rr_get_interval(const pid_t pid, struct timespec* tp) {
	return (int)syscall(SYS_sched_rr_get_interval, (long)pid, (long)&tp);
}


LIB_FUNC int sched_getcpu(void) {
	unsigned int cpu;
	register int r = (int)syscall(SYS_getcpu, 3, (long)&cpu, NULL, NULL);
	return ((r == (-1)) ? r : (int)cpu);
}


LIB_FUNC int __sched_cpucount(const size_t setsize, const cpu_set_t* setp) {
	int s = 0;
	const __cpu_mask* p = setp->__bits;
	const __cpu_mask* end = &setp->__bits[setsize / SIZEOF_CPU_MASK];
	while (p < end) {
		__cpu_mask l = *p++;
#ifdef POPCNT
		s += (int)POPCNT(l);
#else
		if (l == 0) { continue; }
#   if (LONG_BIT > 32)
		l = (__cpu_mask)((l & 0x5555555555555555UL) + ((l >> 1) & 0x5555555555555555UL));
		l = (l & 0x3333333333333333UL) + ((l >> 2) & 0x3333333333333333UL);
		l = (l & 0xf0f0f0f0f0f0f0fUL) + ((l >> 4) & 0xf0f0f0f0f0f0f0fUL);
		l = (l & 0xff00ff00ff00ffUL) + ((l >> 8) & 0xff00ff00ff00ffUL);
		l = (l & 0xffff0000ffffUL) + ((l >> 16) & 0xffff0000ffffUL);
		l = (l & 0xffffffffUL) + ((l >> 32) & 0xffffffffUL);
#   else
		l = (l & 0x55555555UL) + ((l >> 1) & 0x55555555UL);
		l = (l & 0x33333333UL) + ((l >> 2) & 0x33333333UL);
		l = (l & 0xf0f0f0fUL) + ((l >> 4) & 0xf0f0f0fUL);
		l = (l & 0xff00ffUL) + ((l >> 8) & 0xff00ffUL);
		l = (l & 0xffffUL) + ((l >> 16) & 0xffffUL);
#   endif
		s += (int)l;
#endif
	}
	return s;
}


#ifndef FORK
#   define FORK()   syscall(SYS_clone, 3, (int)(CLONE_PARENT_SETTID | SIGCHLD), 0, (long)&pid)
#endif


#endif  // SCHED_H


/* NONLOCAL JUMPS (<setjmp.h>) */


#if (!(defined(_SETJMP_H) || defined(_SETJMP_H_) || defined(_V1_SETJMP_H) || defined(__V1_JMPBUF) || defined(__NOVMX_SETJMP_H)))  // http://www.cplusplus.com/reference/csetjmp/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/setjmp.h.html
#define SETJMP_H   (1)
#define _SETJMP_H   (1)
#define _SETJMP_H_   (1)
#define _BITS_SETJMP_H   (1)
#define _BITS_SETJMP_H_   (1)
#define BITS_SETJMP_H   (1)
#define _V1_SETJMP_H   (1)
#define __V1_JMPBUF   (1)
#define __NOVMX_SETJMP_H   (1)


// setjmp and longjmp
#ifdef __GNUC__


LIB_FUNC int __setjmp_(struct __jmp_buf_tag env[1]) {
	__builtin_setjmp(env);
	UNREACHABLE
}


/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(struct __jmp_buf_tag env[1], int val) {
	__builtin_longjmp(env, val);
	UNREACHABLE
}


#elif (defined(X86_64) || defined(X86) || defined(I386))

// Private macros for accessing __jmp_buf contents
#if IS_WORDSIZE_64

#   define JB_RBX   0
#   define JB_RBP   1
#   define JB_R12   2
#   define JB_R13   3
#   define JB_R14   4
#   define JB_R15   5
#   define JB_RSP   6
#   define JB_PC   7
#   define JB_SIZE   (64)

/** Test if longjmp to JMPBUF would unwind the frame containing a local variable at ADDRESS */
#define _JMPBUF_UNWINDS(jmpbuf, address)   ((void*)(address) < (void*)(jmpbuf)[JB_RSP])

LIB_FUNC int __setjmp_(UNUSED struct __jmp_buf_tag env[1]) {
	asm volatile (
		"mov %rbx, (%rdi);"  // rdi is jmp_buf, move registers onto it
		"mov %rbp, 8(%rdi);"
		"mov %r12, 16(%rdi);"
		"mov %r13, 24(%rdi);"
		"mov %r14, 32(%rdi);"
		"mov %r15, 40(%rdi);"
		"lea 8(%rsp), %rdx;"  // This is our rsp WITHOUT current ret addr
		"mov %rdx, 48(%rdi);"
		"mov (%rsp), %rdx;"  // Save return addr ptr for new rip
		"mov %rdx, 56(%rdi);"
	);
	return 0;
}

/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(UNUSED struct __jmp_buf_tag env[1], UNUSED int val) {
	asm volatile (
		// Restore registers
		"movq (0)(%%rdi), %%rbx;"
		"movq (8)(%%rdi), %%rbp;"
		"movq (16)(%%rdi), %%r12;"
		"movq (24)(%%rdi), %%r13;"
		"movq (32)(%%rdi), %%r14;"
		"movq (40)(%%rdi), %%r15;"
		// Set return value for setjmp
		"test %%esi, %%esi;"
		"mov $01, %%eax;"
		"cmove %%eax, %%esi;"
		"mov %%esi, %%eax;"
		"movq (56)(%%rdi), %%rdx;"
		"movq (48)(%%rdi), %%rsp;"
		"jmpq *%%rdx;"
	);
}

#else  // x86

#   define JB_BX   0
#   define JB_SI   1
#   define JB_DI   2
#   define JB_BP   3
#   define JB_SP   4
#   define JB_PC   5
#   define JB_SIZE   24

/** Test if longjmp to JMPBUF would unwind the frame containing a local variable at ADDRESS */
#define _JMPBUF_UNWINDS(jmpbuf, address)   ((void*)(address) < (void*)(jmpbuf)[JB_SP])

LIB_FUNC int __setjmp_(struct __jmp_buf_tag env[1]) {
	asm volatile (
		"movl 4 (%esp), %eax;"
		// Save registers
		"movl %ebx, (0)(%eax);"
		"movl %esi, (4)(%eax);"
		"movl %edi, (8)(%eax);"
		// Save SP as it will be after we return
		"leal 4(%esp), %ecx;"
		"movl %ecx, (16)(%eax);"
		// Save PC we are returning to now
		"movl 0(%esp), %ecx;"
		"movl %ecx, (20)(%eax);"
		// Save caller's frame pointer
		"movl %ebp, (16)(%eax);"
		// Make a tail call to __sigjmp_save
#   ifdef __PIC__
		"call setjmp_here;"
setjmp_here:
		"popl %ecx;"
		"addl $_GLOBAL_OFFSET_TABLE_+[.- setjmp_here ], %ecx;"
		"movl __sigjmp_save @GOT (%ecx), %ecx;"
		"jmp *%ecx;"
#   else
		"jmp __sigjmp_save;"
#   endif
	: : : "setjmp_here", "__sigjmp_save");
	return 0;
}

/** Jump to the position specified by ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __longjmp(struct __jmp_buf_tag env[1], int val) {
	asm volatile (
		"movl 4(%esp), %ecx;"  // User's jmp_buf in %ecx
		"movl 8(%esp), %eax;"  // Second argument is return value
		// Save the return address now
		"movl (20)(%ecx), %edx;"
		// Restore registers
		"movl (0)(%ecx), %ebx;"
		"movl (4)(%ecx), %esi;"
		"movl (8)(%ecx), %edi;"
		"movl (12)(%ecx), %ebp;"
		"movl (16)(%ecx), %esp;"
		// Jump to saved PC
		"jmp *%edx;"
	);
}

#endif


#endif  // setjmp and longjmp


/** This function is called by the `sigsetjmp` macro before doing a `__setjmp` on ENV[0]._jmpbuf; Always return 0 */
LIB_FUNC int sigjmp_save(struct __jmp_buf_tag env[1], const int savemask) {
	env[0].__mask_was_saved = (savemask && __sigprocmask(SIG_BLOCK, (sigset_t*)NULL, &env[0].__saved_mask) == 0);
	return 0;
}
#define _sigjmp_save(__env, savemask)   sigjmp_save((__env), (savemask))
#define __sigjmp_save(__env, savemask)   sigjmp_save((__env), (savemask))
#define __sigjmp_save_symbol(__env, savemask)   sigjmp_save((__env), (savemask))


/** Store the calling environment in ENV and return 0 */
LIB_FUNC int __sigsetjmp(struct __jmp_buf_tag env[1], const int savemask) {
	__sigjmp_save(env, savemask);
	__setjmp_(env);
	return 0;
}
#ifdef _BSD_SOURCE
#   define setjmp(__env)   __sigsetjmp((__env), 1)
#   define _setjmp(__env)   __sigsetjmp((__env), 1)
#   define __setjmp(__env)   __sigsetjmp((__env), 1)
#   define _sigsetjmp(__env)   __sigsetjmp((__env), 1)
#   define sigsetjmp(__env)   __sigsetjmp((__env), 1)
#else
#   define setjmp(__env)   __sigsetjmp((__env), 0)
#   define _setjmp(__env)   __sigsetjmp((__env), 0)
#   define __setjmp(__env)   __sigsetjmp((__env), 0)
#   define _sigsetjmp(__env)   __sigsetjmp((__env), 0)
#   define sigsetjmp(__env)   __sigsetjmp((__env), 0)
#endif
#define __libc_sigsetjmp(__env, __savemask)   __sigsetjmp((__env), __savemask)
#define ossetjmp(buf)   sigsetjmp(buf, 1)


/** Set the signal mask to the one specified in ENV, and jump to the position specified in ENV, causing the setjmp call there to return VAL, or 1 if VAL is 0 */
LIB_FUNC noreturn void __siglongjmp(struct __jmp_buf_tag _env[1], int __savemask) {
	if (_env[0].__mask_was_saved) {  // Restore the saved signal mask
		(void)__sigprocmask(SIG_SETMASK, &_env[0].__saved_mask, (sigset_t*)NULL);
	}
	__longjmp((struct __jmp_buf_tag*)_env[0].__jmpbuf, (int)(__savemask ? __savemask : 1));  // Call the machine-dependent function to restore machine state
}
#define __libc_longjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define _siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
#define __libc_siglongjmp(__env, __savemask)   __siglongjmp((__env), (__savemask))
/** Use the normal longjmp for unwinding */
#define __libc_unwind_longjmp(buf, val)   __siglongjmp((buf), (val))


#endif  // SETJMP_H


/* FUTEX (<futex.h>) */


#if ((!(defined(_INTERNAL_FUTEX_H) || defined(_INTERNAL_FUTEX_H_) || defined(_FUTEX_H) || defined(_FUTEX_H_))) && defined(OSLINUX))
#define _INTERNAL_FUTEX_H   (1)
#define _INTERNAL_FUTEX_H_   (1)
#define _FUTEX_H   (1)
#define _FUTEX_H_   (1)


#define FUTEX_WAIT   0
#define FUTEX_WAKE   1
#define FUTEX_FD   2
#define FUTEX_REQUEUE   3
#define FUTEX_CMP_REQUEUE   4
#define FUTEX_WAKE_OP   5
#define FUTEX_LOCK_PI   6
#define FUTEX_UNLOCK_PI   7
#define FUTEX_TRYLOCK_PI   8
#define FUTEX_WAIT_BITSET   9
#define FUTEX_PRIVATE   128
#define FUTEX_CLOCK_REALTIME   256


/** A method for a program to wait for a value at a given address to change and to wake up any process waiting on a particular address */
LIB_FUNC int futex(volatile int* addr, const int op, const int val, void* ts) {
	return (int)__syscall4((long)SYS_futex, (long)&addr, (long)op, (long)val, (long)&ts);
}
#define _futex(addr, op, val, ts)   futex((addr), (op), (val), (ts))
#define __futex(addr, op, val, ts)   futex((addr), (op), (val), (ts))


#endif  // FUTEX_H


/* XSI RESOURCE OPERATIONS (<sys/resource.h> & <ulimit.h>) */


#if (!(defined(_SYS_RESOURCE_H) || defined(_SYS_RESOURCE_H_) || defined(_ULIMIT_H) || defined(_ULIMIT_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_resource.h.html
#define SYS_RESOURCE_H   (1)
#define _SYS_RESOURCE_H   (1)
#define _SYS_RESOURCE_H_   (1)
#define _ASM_GENERIC_RESOURCE_H   (1)
#define ULIMIT_H   (1)
#define _ULIMIT_H   (1)
#define _ULIMIT_H_   (1)


typedef struct rlimit { rlim_t rlim_cur, rlim_max; }   rlimit_t;


typedef struct ctx { int _id, eid, sid, nr, err; }   ctx_t;


typedef struct ctx_rlimit {
	const struct rlimit* rlim;
	int res, err;
} ctx_rlimit_t;


typedef struct rusage {
	struct timeval ru_utime, ru_stime;
	long ru_maxrss, ru_ixrss, ru_idrss, ru_isrss;
	long ru_minflt, ru_majflt, ru_nswap, ru_inblock;
	long ru_oublock, ru_msgsnd, ru_msgrcv, ru_nsignals, ru_nvcsw, ru_nivcsw;
} rusage_t;


#define PRIO_MIN   (-20)
#define PRIO_MAX   20
#define PRIO_PROCESS   0
#define PRIO_PGRP   1
#define PRIO_USER   2
#define RUSAGE_SELF   0
#define RUSAGE_CHILDREN   1
#define RLIM_SAVED_CUR   RLIM_INFINITY
#define RLIM64_SAVED_CUR   RLIM64_INFINITY
#define RLIM_SAVED_MAX   RLIM_INFINITY
#define RLIM64_SAVED_MAX   RLIM64_INFINITY
#define RLIMIT_CPU   0
#define RLIMIT_FSIZE   1
#define RLIMIT_DATA   2
#define RLIMIT_STACK   3
#define RLIMIT_CORE   4
#ifdef MIPS
#   define RLIMIT_NOFILE   5
#   define RLIMIT_AS   6
#   define RLIMIT_RSS   7
#   define RLIMIT_NPROC   8
#   define RLIMIT_MEMLOCK   9
#else
#   define RLIMIT_RSS   5
#   define RLIMIT_NPROC   6
#   define RLIMIT_NOFILE   7
#   define RLIMIT_MEMLOCK   8
#   define RLIMIT_AS   9
#endif
#define RLIMIT_LOCKS   10
#define RLIMIT_SIGPENDING   11
#define RLIMIT_MSGQUEUE   12
#define RLIMIT_NICE   13
#define RLIMIT_RTPRIO   14
#define RLIMIT_NLIMITS   15
#define RLIM_NLIMITS   RLIMIT_NLIMITS
#ifndef _STK_LIM_MAX
#   define _STK_LIM_MAX   RLIM_INFINITY
#endif
#define fix__rlimit(x)   do { if ((x) >= SYSCALL_RLIM_INFINITY) { (x) = RLIM_INFINITY; } } while (0x0)


static const UNUSED unsigned long sigs_all_mask[] = {
#if ((ULONG_MAX == 0xffffffff) && (_NSIG == 129))
	-1UL, -1UL, -1UL, -1UL
#elif (ULONG_MAX == 0xffffffff)
	-1UL, -1UL
#else
	-1UL
#endif
};


static const UNUSED unsigned long sigs_app_mask[] = {
#if (ULONG_MAX == 0xffffffff)
#   if (_NSIG == 65)
	0x7fffffff, 0xfffffffc
#   else
	0x7fffffff, 0xfffffffc, -1UL, -1UL
#   endif
#else
#   if (_NSIG == 65)
	0xfffffffc7fffffff
#   else
	0xfffffffc7fffffff, -1UL
#   endif
#endif
};


LIB_FUNC void __block_all_sigs(void* set) {
	syscall(SYS_rt_sigprocmask, SIG_BLOCK, (long)&sigs_all_mask, set, (_NSIG / 8));
}


LIB_FUNC void __block_app_sigs(void* set) {
	syscall(SYS_rt_sigprocmask, SIG_BLOCK, (long)&sigs_app_mask, set, (_NSIG / 8));
}


LIB_FUNC void __restore_sigs(void* set) {
	syscall(SYS_rt_sigprocmask, SIG_SETMASK, set, 0, (_NSIG / 8));
}


LIB_FUNC int getrlimit(const int resource, struct rlimit* rlim) {
	unsigned long k_rlim[2] = { 0 };
	int ret = (int)syscall(SYS_prlimit64, 0, resource, 0, (long)&rlim);
	if (!ret) {
		fix__rlimit(rlim->rlim_cur);
		fix__rlimit(rlim->rlim_max);
	}
	if (!ret || errno != ENOSYS) { return ret; }
	else if (syscall(SYS_getrlimit, resource, (long)&k_rlim) < 0) { return -1; }
	rlim->rlim_cur = ((k_rlim[0] == -1UL) ? RLIM_INFINITY : k_rlim[0]);
	rlim->rlim_max = ((k_rlim[1] == -1UL) ? RLIM_INFINITY : k_rlim[1]);
	fix__rlimit(rlim->rlim_cur);
	fix__rlimit(rlim->rlim_max);
	return 0;
}
#define getrlimit64(resource, rlim)   getrlimit((resource), (rlim))


LIB_FUNC int __setrlimit(const int resource, const struct rlimit* rlim) {
	unsigned long k_rlim[2] = { 0 };
	struct rlimit tmp;
	if (SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		tmp = *rlim;
		fix__rlimit(tmp.rlim_cur);
		fix__rlimit(tmp.rlim_max);
		rlim = &tmp;
	}
	const int ret = (int)syscall(SYS_prlimit64, 0, resource, (long)&rlim, 0);
	if (ret != -ENOSYS) { return ret; }
	k_rlim[0] = MIN(rlim->rlim_cur, MIN(-1UL, SYSCALL_RLIM_INFINITY));
	k_rlim[1] = MIN(rlim->rlim_max, MIN(-1UL, SYSCALL_RLIM_INFINITY));
	return (int)__syscall(SYS_setrlimit, resource, (long)&k_rlim);
}


LIB_FUNC  void do_setrlimit(void* p) {
	struct ctx_rlimit* c = p;
	if (c->err > 0) { return; }
	c->err = (-__setrlimit(c->res, c->rlim));
}


#define __NR___syscall_setrlimit   __NR_setrlimit
LIB_FUNC int __syscall_setrlimit(const int resource, const struct rlimit* rlim) {
	return (int)syscall(SYS_setrlimit, resource, (long)&rlim);
}


LIB_FUNC int setrlimit(rlimit_resource_t resource, const struct rlimit* rlimits) {
	struct rlimit rlimits_small;
	if (rlimits == NULL) {
		__set_errno(EINVAL);
		return -1;
	}
	rlimits_small.rlim_cur = MIN((unsigned long)rlimits->rlim_cur, (unsigned long)(RLIM_INFINITY >> 1));
	rlimits_small.rlim_max = MIN((unsigned long)rlimits->rlim_max, (unsigned long)(RLIM_INFINITY >> 1));
	return (int)__syscall_setrlimit(resource, &rlimits_small);
}
#define setrlimit64(resource, rlim)   setrlimit((resource), (rlim))


LIB_FUNC void do_setxid(void* p) {
	struct ctx* c = p;
	if (c->err > 0) { return; }
	const int ret = -(int)__syscall(c->nr, c->_id, c->eid, c->sid);
	if (ret && !(c->err)) {
		__block_all_sigs(0);
		__syscall(SYS_kill, ((int)__syscall(SYS_getpid)), SIGKILL);
	}
	c->err = ret;
}


LIB_FUNC int getrusage(int who, struct rusage* ru) {
	return (int)syscall(SYS_getrusage, who, (long)&ru);
}


LIB_FUNC int getpriority(const int which, const id_t who) {
	register const int ret = (int)syscall(SYS_getpriority, which, (long)who);
	if (ret < 0) { return ret; }
	return (20 - ret);
}


LIB_FUNC int setpriority(int which, id_t who, int prio) {
	return (int)syscall(SYS_setpriority, which, (long)who, prio);
}


LIB_FUNC int prlimit(pid_t pid, int resource, const struct rlimit* new_limit, struct rlimit* old_limit) {
	struct rlimit tmp;
	int r;
	if (new_limit && SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		tmp = *new_limit;
		fix__rlimit(tmp.rlim_cur);
		fix__rlimit(tmp.rlim_max);
		new_limit = &tmp;
	}
	r = (int)syscall(SYS_prlimit64, (long)pid, resource, (long)&new_limit, (long)&old_limit);
	if (!r && old_limit && SYSCALL_RLIM_INFINITY != RLIM_INFINITY) {
		fix__rlimit(old_limit->rlim_cur);
		fix__rlimit(old_limit->rlim_max);
	}
	return r;
}
#define prlimit64(pid, resource, new_limit, old_limit)   prlimit((pid), (resource), (new_limit), (old_limit))


#endif  // SYS_RESOURCE_H


/* XSI INTERPROCESS COMMUNICATION ACCESS STRUCTURE (<sys/ipc.h>) */


#if (!(defined(_SYS_IPC_H) || defined(_SYS_IPC_H_) || defined(_IPC_H) || defined(_IPC_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_ipc.h.html
#define SYS_IPC_H   (1)
#define _SYS_IPC_H   (1)
#define _SYS_IPC_H_   (1)
#define IPC_H   (1)
#define _IPC_H   (1)
#define _IPC_H_   (1)


#define IPCOP_semop   1
#define IPCOP_semget   2
#define IPCOP_semctl   3
#define IPCOP_semtimedop   4
#define IPCOP_msgsnd   11
#define IPCOP_msgrcv   12
#define IPCOP_msgget   13
#define IPCOP_msgctl   14
#define IPCOP_shmat   21
#define IPCOP_shmdt   22
#define IPCOP_shmget   23
#define IPCOP_shmctl   24
/** Create entry if key does not exist */
#define IPC_CREAT   01000
/** Fail if key exists */
#define IPC_EXCL   02000
/** Error if request must wait */
#define IPC_NOWAIT   04000
/** Remove identifier */
#define IPC_RMID   0
/** Set options */
#define IPC_SET   1
/** Get options */
#define IPC_STAT   2
#define IPC_INFO   3
/** Private key */
#define IPC_PRIVATE   ((key_t)0)


#ifdef X86_64


typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
} ipc_perm_t;
#define IPC_64   0


#elif (defined(I386) || defined(X86))


typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	long long __pad1, __pad2;
} ipc_perm_t;
#define IPC_64   0


#elif defined(POWERPC)


typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	int __pad1;
	long long __pad2, __pad3;
} ipc_perm_t;
#define IPC_64   0x100


#elif defined(AARCH64)


typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	unsigned short ipc_perm_seq;
	unsigned long __pad1, __pad2;
} ipc_perm_t;
#define IPC_64   0


#else


typedef struct ipc_perm {
	key_t ipc_perm_key;
	uid_t uid;
	gid_t gid;
	uid_t cuid;
	gid_t cgid;
	mode_t mode;
	int ipc_perm_seq;
	long __pad1, __pad2;
} ipc_perm_t;
#define IPC_64   0x100


#endif  // ARCH


/** Convert a pathname and a project identifier to a System V IPC key */
LIB_FUNC key_t ftok(const char* pathname, const int proj_id) {
	struct stat64 st;
	if (stat64(pathname, &st) < 0) { return (key_t)-1; }
	const key_t key = (key_t)((key_t)(st.st_ino & 0xffff) | (key_t)((st.st_dev & 0xff) << 16) | (key_t)((proj_id & 0xff) << 24));
	return key;
}


#endif  // SYS_IPC_H


/* XSI SEMAPHORE FACILITY (<sys/sem.h>) */


#if (!(defined(_SYS_SEM_H) || defined(_SYS_SEM_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_sem.h.html
#define SYS_SEM_H   (1)
#define _SYS_SEM_H   (1)
#define _SYS_SEM_H_   (1)


#define SEM_UNDO   0x1000
#define GETPID   11
#define GETVAL   12
#define GETALL   13
#define GETNCNT   14
#define GETZCNT   15
#define SETVAL   16
/** Set all cases of semval */
#define SETALL   17
#define SEM_STAT   18
#define SEM_INFO   19
#define _SEM_SEMUN_UNDEFINED   1


typedef struct seminfo {
	int semmap, semmni, semmns, semmnu, semmsl, semopm, semume, semusz, semvmx, semaem;
} seminfo_t;


typedef struct sembuf {
	unsigned short sem_num;
	short sem_op, sem_flg;
} sembuf_t;


#ifdef ARM64  // semid_ds


typedef struct semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, sem_ctime;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
	time_t __unused3, __unused4;
} semid_t;


#elif defined(MIPS)


typedef struct semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, sem_ctime;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
	time_t __unused3, __unused4;
} semid_t;


#else


typedef struct attr_packed semid_ds {
	struct ipc_perm sem_perm;
	time_t sem_otime, __unused1, sem_ctime, __unused2;
#   if IS_LITTLE_ENDIAN
	unsigned short sem_nsems;
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
#   else
	char __sem_nsems_pad[SIZEOF_TIME_T - SIZEOF_SHORT];
	unsigned short sem_nsems;
#   endif
} semid_t;


#endif  // semid_ds


/** semctl(2)'s argument structure */
typedef union semun {
	int val;
	struct semid_ds* buf;  // Buffer for IPC_STAT & IPC_SET
	unsigned short* array;  // Array for GETALL & SETALL
} semun_t;
#define __semun   semun


LIB_FUNC int semctl(const int _id, const int num, const int cmd, ...) {
	union semun arg = { 0 };
	va_list ap;
	va_start(ap, cmd);
	arg = va_arg(ap, union semun);
	va_end(ap);
#   ifdef SYS_semctl
	return (int)syscall(SYS_semctl, _id, num, (cmd | IPC_64), arg.buf);
#   else
	return (int)syscall(SYS_ipc, IPCOP_semctl, _id, num, (cmd | IPC_64), (long)&arg.buf);
#   endif
}


LIB_FUNC int semget(const key_t key, const int n, const int _fl) {
	if (n > USHRT_MAX) { return (int)__syscall_ret((unsigned long)(-EINVAL)); }
#   ifdef SYS_semget
	return (int)syscall(SYS_semget, key, n, _fl);
#   else
	return (int)syscall(SYS_ipc, IPCOP_semget, key, n, _fl);
#   endif
}


LIB_FUNC int semop(const int _id, struct sembuf* buf, const size_t n) {
#   ifdef SYS_semop
	return (int)syscall(SYS_semop, _id, (long)&buf, n);
#   else
	return (int)syscall(SYS_ipc, IPCOP_semop, _id, n, 0, (long)&buf);
#   endif
}


LIB_FUNC int semtimedop(const int _id, struct sembuf* buf, const size_t n, const struct timespec* ts) {
#   ifdef SYS_semtimedop
	return (int)syscall(SYS_semtimedop, _id, (long)&buf, n, (long)&ts);
#   else
	return (int)syscall(SYS_ipc, IPCOP_semtimedop, _id, n, 0, buf, (long)&ts);
#   endif
}


#endif  // SYS_SEM_H


/* XSI SHARED MEMORY FACILITY (<sys/shm.h>) */


#if (!(defined(_SHM_H) || defined(_SHM_H_) || defined(_SYS_SHM_H) || defined(_SYS_SHM_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_shm.h.html
#define SHM_H   (1)
#define _SHM_H   (1)
#define _SHM_H_   (1)
#define SYS_SHM_H   (1)
#define _SYS_SHM_H   (1)
#define _SYS_SHM_H_   (1)


#define SHM_R   0400
#define SHM_W   0200
/** Attach read-only (else read-write) */
#define SHM_RDONLY   010000
/** Round attach address to SHMLBA */
#define SHM_RND   020000
#define SHM_REMAP   040000
#define SHM_EXEC   0100000
#define SHM_LOCK   11
#define SHM_UNLOCK   12
#define SHM_STAT   13
#define SHM_INFO   14
#define SHM_DEST   01000
#define SHM_LOCKED   02000
#define SHM_HUGETLB   04000
#define SHM_NORESERVE   010000


/** Unsigned integer used for the number of current attaches */
typedef unsigned long   shmatt_t;


#ifdef X86_64


/** Segment low boundary address multiple */
#define SHMLBA   4096

typedef struct attr_packed shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall;
} shminfo_t;

typedef struct attr_packed shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;


#elif defined(AARCH64)


#define SHMLBA   4096

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;


#elif defined(MIPS)


#define SHMLBA   4096

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;


#elif defined(POWERPC)


#define SHMLBA   4096

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	int __unused1;
	time_t shm_atime;
	int __unused2;
	time_t shm_dtime;
	int __unused3;
	time_t shm_ctime;
	int __unused4;
	size_t shm_segsz;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swpm, swap_attempts, swap_successes;
} shm_info_t;


#elif defined(SUPERH)


#define SHMLBA   16384

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime;
	int __unused1;
	time_t shm_dtime;
	int __unused2;
	time_t shm_ctime;
	int __unused3;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;


#elif (defined(I386) || defined(X86))


#define SHMLBA   4096

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime, shm_dtime, shm_ctime;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad0;
	unsigned long long __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, __pad0, shmmin, __pad1, shmmni, __pad2, shmseg, __pad3, shmall, __pad4;
	unsigned long long __unused[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids, __pad_ids;
	unsigned long shm_tot, __pad0, shm_rss, __pad1, shm_swp, __pad2, swap_attempts, __pad3, swap_successes, __pad4;
} align8 shm_info_t;


#else


#define SHMLBA   4096

typedef struct shmid_ds {
	struct ipc_perm shm_perm;
	size_t shm_segsz;
	time_t shm_atime;
	int __unused1;
	time_t shm_dtime;
	int __unused2;
	time_t shm_ctime;
	int __unused3;
	pid_t shm_cpid, shm_lpid;
	unsigned long shm_nattch, __pad1, __pad2;
} shmid_ds_t;

typedef struct shminfo {
	unsigned long shmmax, shmmin, shmmni, shmseg, shmall, unused0[4];
} shminfo_t;

typedef struct shm_info {
	int used_ids;
	unsigned long shm_tot, shm_rss, shm_swp, swap_attempts, swap_successes;
} shm_info_t;


#endif  // ARCH


#ifdef SYS_shmat
LIB_FUNC void* shmat(const int identification, const void* addr, const int flag) {
	long ret = (long)syscall(SYS_shmat, identification, addr, flag);
	return (void*)ret;
}
#else
LIB_FUNC void* shmat(const int identification, const void* addr, const int flag) {
	unsigned long ret = (unsigned long)syscall(SYS_ipc, IPCOP_shmat, identification, flag, &addr, addr);
	return ((ret > -(unsigned long)SHMLBA) ? (void*)ret : (void*)addr);
}
#endif


LIB_FUNC int shmctl(const int identification, int cmd, struct shmid_ds* buf) {
#ifdef SYS_shmctl
	return (int)syscall(SYS_shmctl, identification, (cmd | IPC_64), (long)&buf);
#else
	return (int)syscall(SYS_ipc, IPCOP_shmctl, identification, (cmd | IPC_64), 0, (long)&buf, 0);
#endif
}


LIB_FUNC int shmdt(const void* addr) {
#ifdef SYS_shmdt
	return (int)syscall(SYS_shmdt, (long)&addr);
#else
	return (int)syscall(SYS_ipc, IPCOP_shmdt, 0, 0, 0, (long)&addr);
#endif
}


LIB_FUNC int shmget(const key_t key, const size_t __size, const int flag) {
	size_t maxlen = __size;
	if (maxlen > PTRDIFF_MAX) { maxlen = SIZE_MAX; }
#ifdef SYS_shmget
	return (int)syscall(SYS_shmget, key, maxlen, flag);
#else
	return (int)syscall(SYS_ipc, IPCOP_shmget, key, maxlen, flag);
#endif
}


#endif  // SYS_SHM_H


/* WAITING (<sys/wait.h>) */


#if ((!(defined(_SYS_WAIT_H) || defined(_SYS_WAIT_H_) || defined(_BSD_SYS_WAIT_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html
#define SYS_WAIT_H   (1)
#define _SYS_WAIT_H   (1)
#define _SYS_WAIT_H_   (1)
#define _BSD_SYS_WAIT_H_   (1)


/** Do not block waiting */
#define WNOHANG   1
/** Report status of stopped children */
#define WUNTRACED   2
/** Report stopped child (same as WUNTRACED) */
#define WSTOPPED   2
/** Report dead child */
#define WEXITED   4
/** Report continued child */
#define WCONTINUED   8
/** Do not reap, just poll status */
#define WNOWAIT   0x1000000
/** Do not wait on children of other threads in this group */
#define __WNOTHREAD   0x20000000
/** Wait for any child */
#define __WALL   0x40000000
/** Wait for cloned process */
#define __WCLONE   0x80000000
#define WEXITSTATUS(s)   (((s) & 0xff00) >> 8)
#define WTERMSIG(s)   ((s) & 0x7f)
#define WSTOPSIG(s)   WEXITSTATUS(s)
#define WCOREDUMP(s)   ((s) & 0x80)
#define WIFEXITED(s)   (!WTERMSIG(s))
#define WIFSTOPPED(s)   ((short)((((s) & 0xffff) * 0x10001) >> 8) > 0x7f00)
#define WIFSIGNALED(s)   (((s) & 0xffff) - 1U < 0xffu)
#define WIFCONTINUED(s)   ((s) == 0xffff)


typedef struct attr_packed pthread {
	struct pthread* self;
	void **dtv, *unused1, *unused2;
	uintptr_t sysinfo, canary, canary2;
	pid_t tid, pid;
	int tsd_used, errno_val;
	volatile int cancel, canceldisable, cancelasync;
	int detached;
	unsigned char* map_base;
	size_t map_size;
	void* stack;
	size_t stack_size;
	void* start_arg;
	void* (*start)(void*);
	void* result;
	struct __ptcb* cancelbuf;
	void** tsd;
	pthread_attr_t attr;
	volatile int dead;
	struct _pthread_robust_list {
		volatile void* volatile head;
		long off;
		volatile void* volatile pending;
	} robust_list;
	int unblock_cancel;
	volatile int timer_id;
	locale_t locale;
	volatile int killlock[2];
	volatile int exitlock[2];
	volatile int startlock[2];
	unsigned long sigmask[(_NSIG >> 3) / SIZEOF_LONG];
	char* dlerror_buf;
	int dlerror_flag;
	void* stdio_locks;
	uintptr_t canary_at_end;
	void** dtv_copy;
} struct_pthread_t;
#define _pthread   pthread
#define __pthread   pthread


/** Suspends execution of the calling process until a child specified by pid argument has changed state */
LIB_FUNC pid_t waitpid(const pid_t pid, int* status, const int options) {
	return (pid_t)syscall((long)SYS_wait4, (long)pid, (long)&status, (long)options, (long)0);
}


/** Suspends execution of the calling process until a child specified by an ID argument has changed state */
LIB_FUNC int waitid(const idtype_t type, const id_t _id, siginfo_t* info, const int options) {
	return (int)syscall((long)SYS_waitid, (long)type, (long)_id, (long)&info, (long)options, (long)0);
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC pid_t wait(int* status) {
	return (pid_t)waitpid((pid_t)-1, status, 0);
}


LIB_FUNC pid_t wait4(const pid_t pid, int* status, const int options, struct rusage* usage) {
	return (pid_t)syscall((long)SYS_wait4, (long)pid, (long)&status, (long)options, (long)&usage);
}


LIB_FUNC pid_t wait3(int* status, const int options, struct rusage* usage) {
	return (pid_t)wait4(-1, status, options, usage);
}


/** Suspends execution of the calling process until one of its children terminates */
LIB_FUNC void __wait(volatile int* addr, volatile int* waiters, const int val, int priv) {
	register int spins = 100;
	if (priv) { priv = FUTEX_PRIVATE; }
	while (spins-- && (!waiters || !(*waiters))) {
		if (*addr == val) { a_spin(); }
		else { return; }
	}
	if (waiters) { a_inc(waiters); }
	register UNUSED int tmp_out;
	while (*addr == val) {
		tmp_out = (syscall(SYS_futex, (long)&addr, (FUTEX_WAIT | priv), val, 0) != (-ENOSYS)) || syscall(SYS_futex, (long)&addr, FUTEX_WAIT, val, 0);
	}
	if (waiters) { a_dec(waiters); }
}


LIB_FUNC void wake(volatile void* addr, int cnt, int priv) {
	if (priv) { priv = 128; }
	if (cnt < 0) { cnt = INT_MAX; }
	register UNUSED int tmp_out;
	tmp_out = (syscall(SYS_futex, (long)&addr, (FUTEX_WAKE | priv), cnt) != (-ENOSYS)) || (syscall(SYS_futex, (long)&addr, FUTEX_WAKE, cnt));
}
#define _wake(addr, cnt, priv)   wake((addr), (cnt), (priv))
#define __wake(addr, cnt, priv)   wake((addr), (cnt), (priv))


LIB_FUNC void __lock(volatile int* l) {
	if (libc.threads_minus_1) { while (a_swap(l, 1)) { __wait(l, (l + 1), 1, 1); } }
}
#define LOCK(x)   __lock((x))
#define _LOCK(x)   __lock((x))
#define lock(x)   __lock((x))
#define _lock(x)   __lock((x))


LIB_FUNC void __unlock(volatile int* l) {
	if (l[0]) { a_store(l, 0); if (l[1]) { __wake(l, 1, 1); } }
}
#define UNLOCK(x)   __unlock((x))
#define _UNLOCK(x)   __unlock((x))
#define unlock(x)   __unlock((x))
#define _unlock(x)   __unlock((x))


LIB_FUNC void unlock_requeue(volatile int* l, volatile int* r, const int w) {
	a_store(l, 0);
	if (w) { __wake(l, 1, 1); }
	else {
		register UNUSED int tmp_out;
		tmp_out = ((int)__syscall(SYS_futex, (long)&l, (FUTEX_REQUEUE | 128), 0, 1, (long)&r) != (-ENOSYS)) || (int)(__syscall(SYS_futex, (long)&l, FUTEX_REQUEUE, 0, 1, (long)&r));
	}
}


LIB_FUNC int __lockfile(FILE* f) {
	int owner, tid = (int)(__pthread_self()->tid);
	if (f->lock == tid) { return 0; }
	while ((owner = a_cas(&f->lock, 0, tid))) { __wait(&f->lock, &f->waiters, owner, 1); }
	return 1;
}
#define LOCKFILE(x)   __lockfile((x))
#define _LOCKFILE(x)   __lockfile((x))
#define lockfile(x)   __lockfile((x))
#define _lockfile(x)   __lockfile((x))


LIB_FUNC void __unlockfile(FILE* f) {
	a_store(&f->lock, 0);
	if (f->waiters) { __wake(&f->lock, 1, 1); }
}
#define UNLOCKFILE(x)   __unlockfile((x))
#define _UNLOCKFILE(x)   __unlockfile((x))
#define unlockfile(x)   __unlockfile((x))
#define _unlockfile(x)   __unlockfile((x))


LIB_FUNC int ftrylockfile(FILE* f) {
	struct pthread* self = __pthread_self();
	int tid = self->tid;
	if (f->lock == tid) {
		if (f->lockcount == LONG_MAX) { return -1; }
		f->lockcount++;
		return 0;
	}
	if (f->lock < 0) { f->lock = 0; }
	if (f->lock || a_cas(&f->lock, 0, tid)) { return -1; }
	f->lockcount = 1;
	f->prev_locked = 0;
	f->next_locked = self->stdio_locks;
	if (f->next_locked) { f->next_locked->prev_locked = f; }
	self->stdio_locks = f;
	return 0;
}
#define FTRYLOCKFILE(f)   ftrylockfile((f))
#define _FTRYLOCKFILE(f)   ftrylockfile((f))
#define _ftrylockfile(f)   ftrylockfile((f))


LIB_FUNC void flockfile(FILE* f) {
	while (ftrylockfile(f)) {
		const int owner = f->lock;
		if (owner) { __wait(&f->lock, &f->waiters, owner, 1); }
	}
}
#define _flockfile(f)   flockfile((f))
#define _FLOCKFILE(f)   flockfile((f))
#define FLOCKFILE(f)   flockfile((f))
#define _IO_flockfile(f)   flockfile((f))


LIB_FUNC void funlockfile(FILE* f) {
	if (f->lockcount == 1) {
		__unlist_locked_file(f);
		f->lockcount = 0;
		__unlockfile(f);
	} else { f->lockcount--; }
}
#define _funlockfile(f)   funlockfile((f))
#define _FUNLOCKFILE(f)   funlockfile((f))
#define FUNLOCKFILE(f)   funlockfile((f))
#define _IO_funlockfile(f)   funlockfile((f))


LIB_FUNC void __do_orphaned_stdio_locks(void) {
	FILE* f;
	for (f = __pthread_self()->stdio_locks; f; f = f->next_locked) {
		a_store(&f->lock, 0x40000000);
	}
}


LIB_FUNC void __unlist_locked_file(FILE* f) {
	if (f->lockcount) {
		if (f->next_locked) { f->next_locked->prev_locked = f->prev_locked; }
		if (f->prev_locked) { f->prev_locked->next_locked = f->next_locked; }
		else { __pthread_self()->stdio_locks = f->next_locked; }
	}
}


#define __vm_wait()   do { register int tmp; while ((tmp = vmlock[0])) { __wait(vmlock, (vmlock + 1), tmp, 1); } } while (0x0)
#define vm_wait()   __vm_wait()
#define __vm_lock()   a_inc(vmlock)
#define vm_lock()   a_inc(vmlock)
#define __vm_unlock()   if (a_fetch_add(vmlock, -1) == 1 && vmlock[1]) { __wake(vmlock, -1, 1); }
#define vm_unlock()   __vm_unlock()


#endif  // SYS_WAIT_H


/* POSIX THREADS (<pthread.h>) */


#if (!(defined(_PTHREAD_H) || defined(_PTHREAD_H_) || defined(_PTHREAD_IMPL_H) || defined(_PTHREAD_IMPL_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html
#define _PTHREAD_H   (1)
#define _PTHREAD_H_   (1)
#define _PTHREAD_IMPL_H   (1)
#define _PTHREAD_IMPL_H_   (1)
#define _PDCLIB_THREADCONFIG_H   (1)
#define _SYS_SEMAPHORE_H_   (1)
#define SYS_SEMAPHORE_H   (1)
#define SEMAPHORE_H   (1)
#define __SEMAPHORE_H__   (1)
#define _SYS_SPAWN_H_   (1)
#define SYS_SPAWN_H   (1)
#define SPAWN_H   (1)
#define _SPAWN_H_   (1)
#define AIO_MISC_H   (1)
#define _AIO_MISC_H_   (1)
#define _AIO_MISC_H   (1)


#define PTHREAD_CREATE_JOINABLE   0
#define PTHREAD_CREATE_DETACHED   1
#define PTHREAD_MUTEX_NORMAL   0
#define PTHREAD_MUTEX_DEFAULT   0
#define PTHREAD_MUTEX_RECURSIVE   1
#define PTHREAD_MUTEX_ERRORCHECK   2
#define PTHREAD_MUTEX_STALLED   0
#define PTHREAD_MUTEX_ROBUST   1
#define PTHREAD_PRIO_NONE   0
#define PTHREAD_PRIO_INHERIT   1
#define PTHREAD_PRIO_PROTECT   2
#define PTHREAD_INHERIT_SCHED   0
#define PTHREAD_EXPLICIT_SCHED   1
#define PTHREAD_SCOPE_SYSTEM   0
#define PTHREAD_SCOPE_PROCESS   1
#define PTHREAD_PROCESS_PRIVATE   0
#define PTHREAD_PROCESS_SHARED   1
/** Initial value of a spinlock; Most platforms should use zero, unless they only implement a "test and clear" operation instead of the usual "test and set" */
#define __LT_SPINLOCK_INIT   (0)
#define __LOCK_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define __ALT_LOCK_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define __ATOMIC_INITIALIZER   { 0, __LT_SPINLOCK_INIT }
#define PTHREAD_RWLOCK_INITIALIZER   {{ 0 }}
#define PTHREAD_COND_INITIALIZER   {{ 0 }}
#define PTHREAD_MUTEX_INITIALIZER   { {PTHREAD_SPIN_UNLOCKED}, 0, PTHREAD_MUTEX_FAST_NP, 0 }
#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { 0 } }}
#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, 0, { 0 } }}
#define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP   {{ 0, 0, (void*)0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { 0 } }}
#define PTHREAD_ONCE_INIT   0
#define PTHREAD_CANCEL_ENABLE   0
#define PTHREAD_CANCEL_DISABLE   1
#define PTHREAD_CANCEL_MASKED   2
#define PTHREAD_CANCEL_DEFERRED   0
#define PTHREAD_CANCEL_ASYNCHRONOUS   1
#define PTHREAD_CANCELED   ((void*)-1)
#define PTHREAD_BARRIER_SERIAL_THREAD   (-1)
#define MUTEX_INITIALIZER   PTHREAD_MUTEX_INITIALIZER
#define MUTEX_TYPE_NORMAL   PTHREAD_MUTEX_NORMAL
#define MUTEX_TYPE_ERRORCHECK   PTHREAD_MUTEX_ERRORCHECK
#define MUTEX_TYPE_RECURSIVE   PTHREAD_MUTEX_RECURSIVE
#define COND_INITIALIZER   PTHREAD_COND_INITIALIZER
#define RWLOCK_INITIALIZER   PTHREAD_RWLOCK_INITIALIZER
#define ONCE_INITIALIZER   PTHREAD_ONCE_INIT
#define POSIX_SPAWN_RESETIDS   1
#define POSIX_SPAWN_SETPGROUP   2
#ifdef OSBSD
#   define POSIX_SPAWN_SETSCHEDPARAM   4
#   define POSIX_SPAWN_SETSCHEDULER   8
#   define POSIX_SPAWN_SETSIGDEF   0x10
#   define POSIX_SPAWN_SETSIGMASK   0x20
#else
#   define POSIX_SPAWN_SETSIGDEF   4
#   define POSIX_SPAWN_SETSIGMASK   8
#   define POSIX_SPAWN_SETSCHEDPARAM   0x10
#   define POSIX_SPAWN_SETSCHEDULER   0x20
#endif
#ifdef __USE_GNU
#   define POSIX_SPAWN_USEVFORK   0x40
#elif defined(_NETBSD_SOURCE)
#   define POSIX_SPAWN_RETURNERROR   0x40
#endif
#define SPAWN_XFLAGS_USE_PATH   1
#define SPAWN_XFLAGS_TRY_SHELL   2
#define PTHREAD_THREADS_MAX   1024
#define MAX_SPIN_COUNT   50
#define SPIN_SLEEP_DURATION   2000001
#define PTHREAD_STACK_SIZE   16384
#if (defined(ARCHALPHA) || defined(ARCHX86_64) || defined(ARCHSPARC64))
#   define PTHREAD_STACK_MAXSIZE   (33554432)
#elif defined(ARCHITANIUM)
#   define PTHREAD_STACK_MAXSIZE   (16777216)
#else
#   define PTHREAD_STACK_MAXSIZE   (8388608)
#endif
#define PTHREAD_STACK_MINSIZE   16384
/** Operation codes for `aio_lio_opcode` */
enum LIO_OP_CODES { LIO_READ, LIO_WRITE, LIO_NOP };
/** Synchronization options for `lio_listio` function */
enum LIO_SYNC_CODES { LIO_WAIT, LIO_NOWAIT };
/** Extended LIO operations */
enum LIO_OPS {
	LIO_DSYNC = LIO_NOP + 1,
	LIO_SYNC,
	LIO_READ64 = (LIO_READ | 128),
	LIO_WRITE64 = (LIO_WRITE | 128)
};
/** Status of a request */
enum AIO_REQUEST { aio_no, aio_queued, aio_yes, aio_allocated, aio_done };


typedef struct attr_packed __timer { int timerid; pthread_t thread; }   pthread_timer_t;


typedef struct sem_struct { volatile unsigned int count; }   sem_t;
#define SEM_FAILED   ((sem_t*)-1)
/* typedef struct {
	pthread_mutex_t lock;
	pthread_cond_t cond;
	int value;
	uint32_t magic;
} sem_t; */


/** Asynchronous I/O control block */
struct attr_packed aiocb {
	int aio_fildes, aio_lio_opcode, aio_reqprio;
	volatile void* aio_buf;
	size_t aio_nbytes;
	struct sigevent aio_sigevent;
	struct aiocb* __next_prio;
	int __abs_prio, __policy, __error_code;
	ssize_t __return_value;
#ifndef __USE_FILE_OFFSET64
	off_t aio_offset;
#else
	off64_t aio_offset;
#endif
};


struct attr_packed aiocb64 {
	int aio_fildes, aio_lio_opcode, aio_reqprio;
	volatile void* aio_buf;
	size_t aio_nbytes;
	struct sigevent aio_sigevent;
	struct aiocb* __next_prio;
	int __abs_prio, __policy, __error_code;
	ssize_t __return_value;
	off64_t aio_offset;
};


struct attr_packed aio_args {
	struct aiocb* cb;
	int op, err;
	sem_t sem;
};


struct attr_packed aio_thread {
	pthread_t td;
	struct aiocb* cb;
	struct aio_thread *next, *prev;
	struct aio_queue* q;
	volatile int running;
	int err, op;
	ssize_t ret;
};


struct aio_queue {
	int fd, seekable, append, ref, init;
	pthread_mutex_t lock;
	pthread_cond_t cond;
	struct aio_thread* head;
};


/** Union of the two request types */
typedef union {
	struct aiocb aiocb;
	struct aiocb64 aiocb64;
} aiocb_union;


struct waitlist {
	struct waitlist* next;
#ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t* cond;
#endif
	int* result;
	volatile unsigned int* counterp;
	struct sigevent* sigevp;
#ifdef BROKEN_THREAD_SIGNALS
	pid_t caller_pid;
#endif
};


struct attr_packed requestlist {
	int running;
	struct requestlist *last_fd, *next_fd, *next_prio, *next_run;
	aiocb_union* aiocbp;
#ifdef BROKEN_THREAD_SIGNALS
	pid_t caller_pid;
#endif
	struct waitlist* waiting;
};


typedef struct attr_packed lio_state {
	struct sigevent* sev;
	int cnt;
	struct aiocb* cbs[];
} lio_state_t;


struct attr_packed clparam {
	struct aiocb* __list;
	struct waitlist* __waitlist;
	struct requestlist** __requestlist;
#ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t* cond;
#endif
	int nent;
};


struct attr_packed _thread_key { int used; void (*destructor)(void*); };


struct posix_spawn_args {
	int p[2];
	sigset_t oldmask;
	const char* path;
	int (*exec)(const char*, char *const*, char *const*);
	const posix_spawn_file_actions_t* fa;
	const posix_spawnattr_t* restrict attr;
	char *const* argv, *const* envp;
};


static UNUSED struct _pthread_descr_struct _main_thread = {
	.stack_begin = 0,
	.stack_end = (void*)(~0),
	.lock = { PTHREAD_SPIN_UNLOCKED }
};
static UNUSED pthread_rwlock_t maplock;
static UNUSED struct aio_queue***** map;
static UNUSED volatile int aio_fd_cnt;
static UNUSED volatile int __aio_fut;
static UNUSED _pthread_descr manager_thread;
static UNUSED pthread_once_t __thread_started = PTHREAD_ONCE_INIT;
static UNUSED unsigned long __thread_pagesize;
static UNUSED int __manager_pipe[2] = { -1, -1 };
#define mgr_recv_fd   __manager_pipe[0]
#define mgr_send_fd   __manager_pipe[1]


#ifdef I386  // pthread_self


LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self;
	asm volatile ("movl %%gs:0, %0;" : "=r"(self));
	return self;
}
#define TP_ADJ(p)   (p)
#define MC_PC   gregs[REG_EIP]


#elif defined(X86_64)


LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self;
	asm volatile ("mov %%fs:0, %0;" : "=r"(self));
	return self;
}
#define TP_ADJ(p)   (p)
#define MC_PC   gregs[REG_RIP]


#elif defined(X86)


LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self;
	asm volatile ("mov %%fs:0, %0;" : "=r"(self));
	return self;
}
#define TP_ADJ(p)   (p)
#define MC_PC   gregs[REG_RIP]
#define CANARY   canary2


#elif defined(SUPERH)


LIB_FUNC struct pthread* __pthread_self(void) {
	char* self;
	asm volatile ("stc gbr, %0;" : "=r"(self));
	return (struct pthread*)(self + 0x8000 - sizeof(struct pthread));
}
#define TLS_ABOVE_TP
#define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 0x8000)
#define MC_PC   sc_pc


#elif defined(POWERPC)


LIB_FUNC struct pthread* __pthread_self(void) {
#   ifdef COMPILER_CLANG
	char* tp;
	asm volatile ("mr %0, 2;" : "=r"(tp));
#   else
	register char* tp asm ("r2");
	asm volatile (";" : "=r"(tp));
#   endif
	return (pthread_t)(tp - 0x7000 - sizeof(struct pthread));
}
#define TLS_ABOVE_TP
#define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) + 0x7000)
#define DTP_OFFSET   0x8000
#define MC_PC   gregs[32]
#define CANARY   canary_at_end


#elif defined(MICROBLAZE)


LIB_FUNC struct pthread* __pthread_self(void) {
	struct pthread* self;
	asm volatile ("ori %0, r21, 0;" : "=r"(self));
	return self;
}
#define TP_ADJ(p)   (p)
#define MC_PC   regs.pc


#elif defined(ARM64)


LIB_FUNC struct pthread* __pthread_self(void) {
	char* self;
	asm volatile ("mrs %0, tpidr_el0;" : "=r"(self));
	return (void*)(self + 16 - sizeof(struct pthread));
}
#define TLS_ABOVE_TP
#define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 16)
#define MC_PC   pc


#elif defined(ARM)


#if ((defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6ZK__)) && (!defined(ARM_THUMB))) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || (__ARM_ARCH >= 7)

LIB_FUNC pthread_t __pthread_self(void) {
	char* p;
	asm volatile ("mrc p15, 0, %0, c13, c0, 3;" : "=r"(p));
	return (void*)(p + 0x8000 - sizeof(struct pthread));
}

#else

LIB_FUNC pthread_t __pthread_self(void) {
#ifdef CLANG
	char* p;
	asm volatile ("bl __a_gettp;" "mov %0, r0;" : "=r"(p) : : "cc", "r0", "lr");
#else
	register char* p asm ("r0");
	asm volatile ("bl __a_gettp;" : "=r"(p) : : "cc", "lr");
#endif
	return (void*)(p + 0x8000 - sizeof(struct pthread));
}

#endif
#define TLS_ABOVE_TP
#define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) - 0x8000)
#define MC_PC   arm_pc


#elif defined(MIPS)


LIB_FUNC struct pthread* __pthread_self(void) {
#   ifdef COMPILER_CLANG
	char* tp;
	asm volatile (".word 0x7c03e83b;" "move %0, $3;" : "=r"(tp) : : "$3");
#   else
	register char* tp asm ("$3");
	asm volatile (".word 0x7c03e83b;" : "=r"(tp));
#   endif
	return (pthread_t)(tp - 0x7000 - sizeof(struct pthread));
}
#define TLS_ABOVE_TP
#define TP_ADJ(p)   ((char*)(p) + sizeof(struct pthread) + 0x7000)
#define DTP_OFFSET   8
#define MC_PC   pc


#else
#   error   "This library does not support POSIX-Threads for your system"
#endif  // pthread_self


LIB_FUNC struct pthread* __pthread_self_internal(void) {
	return (struct pthread*)__pthread_self();
}
#define thrd_current()   __pthread_self_internal()
#define __thrd_current()   __pthread_self_internal()
#define pthread_self_internal()   __pthread_self_internal()


#define PTHREAD_SIG_RESTART   (SIGRTMAX)
#define PTHREAD_SIG_CANCEL   (SIGRTMAX - 1)
#define DEFAULT_STACK_SIZE   (81920)
#define DEFAULT_GUARD_SIZE   (PAGE_SIZE)
#define __ATTRP_C11_THREAD   ((void*)(uintptr_t)-1)
#ifndef CANARY
#   define CANARY   canary
#endif
#ifndef DTP_OFFSET
#   define DTP_OFFSET   (0)
#endif
#define SIGTIMER   (32)
#define SIGCANCEL   (33)
#define SIGSYNCCALL   (34)
#define __SU   (SIZEOF_SIZE_T / SIZEOF_INT)
#define _a_stacksize   __u.__s[0]
#define _a_guardsize   __u.__s[1]
#define _a_stackaddr   __u.__s[2]
#define _a_detach   __u.__i[3 * __SU]
#define _a_sched   __u.__i[3 * __SU + 1]
#define _a_policy   __u.__i[3 * __SU + 2]
#define _a_prio   __u.__i[3 * __SU + 3]
#define _m_type   __u.__i[0]
#define _m_lock   __u.__vi[1]
#define _m_waiters   __u.__vi[2]
#define _m_prev   __u.__p[3]
#define _m_next   __u.__p[4]
#define _m_count   __u.__i[5]
#define _c_shared   __u.__p[0]
#define _c_seq   __u.__vi[2]
#define _c_waiters   __u.__vi[3]
#define _c_clock   __u.__i[4]
#define _c_lock   __u.__vi[8]
#define _c_head   __u.__p[1]
#define _c_tail   __u.__p[5]
#define _rw_lock   __u.__vi[0]
#define _rw_waiters   __u.__vi[1]
#define _rw_shared   __u.__i[2]
#define _b_lock   __u.__vi[0]
#define _b_waiters   __u.__vi[1]
#define _b_limit   __u.__i[2]
#define _b_count   __u.__vi[3]
#define _b_waiters2   __u.__vi[4]
#define _b_inst   __u.__p[3]
#define SIGALL_SET   ((const sigset_t*)(const unsigned long long [2]) { (unsigned long long)-1, (unsigned long long)-1 })
#define SIGPT_SET   ((sigset_t*)(const unsigned long [(_NSIG >> 3) / SIZEOF_LONG]) { [SIZEOF_LONG == 4] = 3UL << (32 * (SIZEOF_LONG > 4)) })
#define SIGTIMER_SET   ((sigset_t*)(const unsigned long [(_NSIG >> 3) / SIZEOF_LONG]) { 0x80000000 })
#define thread_sig_mask   jmp_exit->__saved_mask
#define NR_BUCKETS   256
static UNUSED _pthread_descr _thread_hash_tid[256] = { 0 };
/** Lock for global I/O list of requests */
static UNUSED pthread_mutex_t __aio_requests_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
static UNUSED pthread_cond_t __aio_new_request_notification = PTHREAD_COND_INITIALIZER;
/** Number of threads currently running */
static UNUSED int nthreads;
/** Number of threads waiting for work to arrive */
static UNUSED int idle_thread_count;
/** List of available entries */
static UNUSED struct requestlist* freelist;
/** List of request waiting to be processed */
static UNUSED struct requestlist* runlist;
/** Structure list of all currently processed requests */
static UNUSED struct requestlist* requests;


LIB_FUNC unsigned long hash_tid(const int tid) {
	return (unsigned long)(tid & (NR_BUCKETS - 1));
}


LIB_FUNC int pthread_sigmask(const int how, const sigset_t* restrict set, sigset_t* restrict old) {
	if ((unsigned int)how - SIG_BLOCK > 2U) { return EINVAL; }
	const int ret = (int)(-((int)__syscall(SYS_rt_sigprocmask, (long)how, (long)&set, (long)&old, (long)(_NSIG / 8))));
	if ((!ret) && old) {
		if (sizeof(old->__bits[0]) == 8) {
			old->__bits[0] &= (unsigned long)(~0x380000000ULL);
		} else {
			old->__bits[0] &= (unsigned long)(~0x80000000UL);
			old->__bits[1] &= (unsigned long)(~0x3UL);
		}
	}
	return ret;
}


/** Find thread by thread-id */
LIB_FUNC _pthread_descr __thread_find_(const int pid) {
	if (__thread_started == PTHREAD_ONCE_INIT) {
		__lock((volatile int*)&_main_thread);
		return &_main_thread;
	}
	_pthread_descr cur = _thread_hash_tid[hash_tid(pid)];
	_pthread_descr next;
	while (cur) {
		next = cur->next;
		if (pid == cur->pid) { __lock((volatile int*)cur); break; }
		cur = next;
	}
	return cur;
}
#ifdef ARCHI386
LIB_FUNC __attribute__((regparm(1))) _pthread_descr __thread_find(const int pid) {
	return __thread_find_(pid);
}
#else
#   define __thread_find(pid)   __thread_find_((pid))
#endif


/** Get thread-self descriptor */
LIB_FUNC _pthread_descr __thread_self(void) {
#ifdef ARCHALPHA
	register _pthread_descr cur asm ("$0");
	asm ("call_pal 158;" : "=r"(cur));
#else
	register _pthread_descr cur = 0;
#   ifdef ARCHSPARC
	asm ("mov %%g6, %0;" : "=r"(cur));
#   elif defined(ARCHS390)
	asm ("ear %0, %%a0;" : "=d"(cur));
#   elif defined(ARCHITANIUM)
	asm ("mov %0 = r13;" : "=r"(cur));
#   elif defined(ARCHX86_64)
	asm ("mov %%fs:(16), %0;" : "=r"(cur));
#   elif defined(ARCHI386)
	asm ("mov %%gs:(8), %0;" : "=r"(cur));
#   else
	cur = __thread_find_(getpid());
	if (cur) { __unlock(cur); }
#   endif
#endif
	return (_pthread_descr)(cur ? cur : &_main_thread);
}


/** Set canceltype of thread */
LIB_FUNC int __thread_setcanceltype(const int type, int* oldtype, _pthread_descr td) {
	if ((type != PTHREAD_CANCEL_DEFERRED) && (type != PTHREAD_CANCEL_ASYNCHRONOUS)) { return EINVAL; }
	if (oldtype) { *oldtype = td->canceltype; }
	td->canceltype = (unsigned char)type;
	return 0;
}


#define __NO_ASYNC_CANCEL_BEGIN_(t)   int __oldtype__; __thread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &__oldtype__, (t))
#define __NO_ASYNC_CANCEL_END_(t)   __thread_setcanceltype(__oldtype__, 0, (t)); __thread_testcancel((t))
#define __NO_ASYNC_CANCEL_STOP


/** Exit a thread */
LIB_FUNC void pthread_exit(void* retval) {
	_pthread_descr this = __thread_self();
	if (this == &_main_thread) { _Exit((int)SYS_exit); }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	__lock((volatile int*)this);
	this->cancelstate = PTHREAD_CANCEL_DISABLE;
	this->retval = retval;
	__unlock((volatile int*)this);
	siglongjmp(this->jmp_exit, 1);
}
#define __pthread_exit(retval)   pthread_exit((retval))


/** Test canceled */
LIB_FUNC void __thread_testcancel(_pthread_descr td) {
	register int cancel = 0;
	if (td && (td->cancelstate == PTHREAD_CANCEL_ENABLE)) { cancel = td->canceled; }
	if (cancel) { __pthread_exit(PTHREAD_CANCELED); }
}
#define pthread_testcancel()   __thread_testcancel(__thread_self())
#define __TEST_CANCEL_(t)   __thread_testcancel((t))
#define __TEST_CANCEL()   pthread_testcancel()


LIB_FUNC int pthread_setcancelstate(const int new, int* old) {
	if (new > 2) { return EINVAL; }
	struct pthread* self = __pthread_self();
	if (old) { *old = self->canceldisable; }
	self->canceldisable = new;
	return 0;
}
#define __pthread_setcancelstate(new, old)   pthread_setcancelstate((new), (old))


LIB_FUNC int pthread_setcanceltype(const int new, int* old) {
	struct pthread* self = __pthread_self();
	if (new > 1) { return EINVAL; }
	if (old) { *old = self->cancelasync; }
	self->cancelasync = new;
	if (new) { pthread_testcancel(); }
	return 0;
}


LIB_FUNC int __thread_mutex_lock(pthread_mutex_t* mutex, _pthread_descr this) {
	if (mutex->__data.__owner != this) {
		__lock((volatile int*)&mutex);
		mutex->__data.__owner = this;
		mutex->__data.__count = 0;
	}
	else if (mutex->__data.__kind == PTHREAD_MUTEX_ERRORCHECK_NP) { return EDEADLK; }
	if (mutex->__data.__kind == PTHREAD_MUTEX_RECURSIVE_NP) { ++(mutex->__data.__count); }
	return 0;
}
#define __pthread_mutex_lock(mutex, this)   __thread_mutex_lock((mutex), (this))


LIB_FUNC int pthread_mutex_lock(pthread_mutex_t* mutex) {
	return __thread_mutex_lock(mutex, __thread_self());
}


LIB_FUNC int __thread_mutex_unlock(pthread_mutex_t* mutex, _pthread_descr this) {
	if (mutex->__data.__owner == this) {
		if (mutex->__data.__kind == PTHREAD_MUTEX_RECURSIVE_NP) {
			if (--(mutex->__data.__count)) { return 0; }
		}
		mutex->__data.__owner = 0;
		__unlock((volatile int*)&mutex);
	}
	else if (mutex->__data.__kind == PTHREAD_MUTEX_ERRORCHECK_NP) { return EPERM; }
	return 0;
}
#define __pthread_mutex_unlock(mutex, this)   __thread_mutex_unlock((mutex), (this))


LIB_FUNC int pthread_mutex_unlock(pthread_mutex_t* mutex) {
	return __thread_mutex_unlock(mutex, __thread_self());
}


LIB_FUNC void pthread_cleanup_push(void(*func)(void*), void* arg) {
	_pthread_descr this = __thread_self();
	struct thread_cleanup_t* tmp;
	__NO_ASYNC_CANCEL_BEGIN_(this);
	tmp = (struct thread_cleanup_t*)malloc(sizeof(struct thread_cleanup_t));
	tmp->func = func;
	tmp->arg = arg;
	__lock((volatile int*)this);
	tmp->next = this->cleanup_stack;
	this->cleanup_stack = tmp;
	free(tmp);
	__unlock((volatile int*)this);
}


LIB_FUNC void pthread_cleanup_pop(int execute) {
	_pthread_descr this = __thread_self();
	struct thread_cleanup_t* tmp;
	__NO_ASYNC_CANCEL_BEGIN_(this);
	__lock((volatile int*)this);
	tmp = this->cleanup_stack;
	this->cleanup_stack = tmp->next;
	__unlock((volatile int*)this);
	if (execute) { tmp->func(tmp->arg); }
	tmp = (struct thread_cleanup_t*)NULL;
}


LIB_FUNC void __pthread_lock(struct _pthread_fastlock* lock) {
	int cnt = 0;
	struct timespec tm;
	while (__testandset(&lock->__spinlock)) {
		if (cnt < MAX_SPIN_COUNT) {
			sched_yield();
			cnt++;
		} else {
			tm.tv_sec = 0;
			tm.tv_nsec = SPIN_SLEEP_DURATION;
			nanosleep(&tm, 0);
			cnt = 0;
		}
	}
}


LIB_FUNC int __pthread_trylock(struct _pthread_fastlock* lock) {
	return __testandset(&lock->__spinlock);
}
#define TRYLOCK(td)   __pthread_trylock(&((td)->lock))


LIB_FUNC int __pthread_unlock(struct _pthread_fastlock* lock) {
	lock->__spinlock = PTHREAD_SPIN_UNLOCKED;
	return 0;
}


/** Sleep a little (reschedule for this time) */
LIB_FUNC void __thread_sleep(void) {
	struct timespec reg;
	reg.tv_sec = 0;
	reg.tv_nsec = SPIN_SLEEP_DURATION;
	nanosleep(&reg, 0);
}


/** Cleanup / remove zombie thread */
LIB_FUNC int __thread_cleanup(_pthread_descr td) {
	register int cnt = 0;
	do {
		++cnt;
		sched_yield();
		__thread_sleep();
		sched_yield();
	} while (TRYLOCK(td) && (cnt < MAX_SPIN_COUNT));
	if (td->stack_free) { munmap(td->stack_begin, td->stack_size); }
	return 0;
}


/** Cleanup / remove zombie thread */
LIB_FUNC void __thread_cleanup_helper(void* td) {
	register int cnt = 0;
	do {
		++cnt;
		sched_yield();
		__thread_sleep();
		sched_yield();
	} while (TRYLOCK((_pthread_descr)td) && (cnt < MAX_SPIN_COUNT));
	if (((_pthread_descr)td)->stack_free) { munmap(((_pthread_descr)td)->stack_begin, ((_pthread_descr)td)->stack_size); }
}


/** Suspend until timeout or restart signal */
LIB_FUNC int __thread_suspend_till(_pthread_descr this, int cancel, const struct timespec* abstime) {
	sigset_t newmask, oldmask;
	struct timeval tv;
	struct timespec reg;
	int retval = 0;
	gettimeofday(&tv, 0);
	reg.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
	reg.tv_sec = abstime->tv_sec - tv.tv_sec;
	if (reg.tv_nsec < 0) {
		reg.tv_nsec += 1000000000;
		reg.tv_sec -= 1;
	}
	this->p_sig = 0;
	sigemptyset(&newmask);
	if (sigaddset(&newmask, PTHREAD_SIG_RESTART) < 0) { return -1; }
	sigprocmask(SIG_UNBLOCK, &newmask, &oldmask);
	while(this->p_sig != PTHREAD_SIG_RESTART) {
		if (cancel && (this->cancelstate == PTHREAD_CANCEL_ENABLE) && this->canceled) { break; }
		if (reg.tv_sec < 0 || nanosleep(&reg, &reg) == 0) {
			retval = ETIMEDOUT;
			break;
		}
	}
	sigprocmask(SIG_SETMASK, &oldmask, 0);
	return retval;
}


LIB_FUNC int __rt_sigsuspend(const sigset_t* mask, long nr) {
	return (int)syscall(SYS_rt_sigsuspend, (long)&mask, nr);
}


LIB_FUNC int sigsuspend(const sigset_t* mask) {
	return __rt_sigsuspend(mask, (_NSIG / 8));
}
#define __libc_sigsuspend(mask)   sigsuspend((mask))


/** Suspend until restart signal */
LIB_FUNC void __thread_suspend(_pthread_descr this, int cancel) {
	sigset_t mask;
	this->p_sig = 0;
	sigprocmask(SIG_SETMASK, 0, &mask);
	sigdelset(&mask, PTHREAD_SIG_RESTART);
	while (this->p_sig != PTHREAD_SIG_RESTART) {
		if (cancel && (this->cancelstate == PTHREAD_CANCEL_ENABLE) && this->canceled) { break; }
		sigsuspend(&mask);
	}
}

/** Restart a thread */
LIB_FUNC void __thread_restart(_pthread_descr td) {
	kill(td->pid, PTHREAD_SIG_RESTART);
	sched_yield();
	sched_yield();
}


/** Restart signal handler */
LIB_FUNC void pthread_handle_sigrestart(int sig) {
	_pthread_descr this = __thread_self();
	this->p_sig = (char)sig;
}


/** Dispatch a signal to ALL threads used for SIG{SEGV, FPE, ...} and main thread exits */
LIB_FUNC void kill_all_threads(const int sig, const int main2) {
	if (main2) { kill(_main_thread.pid, sig); }
	_pthread_descr cur;
	register int i;
	for (i = 0;i < NR_BUCKETS; ++i) {
		cur = _thread_hash_tid[i];
		for (; (cur && (cur != manager_thread)); cur = cur->next) { kill(cur->pid, sig); }
	}
}


/** Cancel signal */
LIB_FUNC void pthread_handle_sigcancel(UNUSED int sig, siginfo_t* info, UNUSED void* arg) {
	_pthread_descr this = __thread_self();
	if (this == manager_thread) {
		int pid = info->si_pid;
		if (pid == _main_thread.pid) {
			sched_yield();
			kill_all_threads(PTHREAD_SIG_CANCEL, 0);
			sched_yield();
			__thread_sleep();
			kill_all_threads(SIGKILL, 0);
			__thread_sleep();
			_Exit(0);
		}
	} else if (this == &_main_thread) {
		kill(manager_thread->pid, PTHREAD_SIG_CANCEL);
		waitpid(manager_thread->pid, 0, (int)(WNOHANG | __WCLONE));
		siglongjmp(_main_thread.jmp_exit, 1);
	} else if (this->cancelstate == PTHREAD_CANCEL_ENABLE) {
		this->canceled = 1;
		if (this->canceltype == PTHREAD_CANCEL_ASYNCHRONOUS) { __pthread_exit(PTHREAD_CANCELED); }
	}
}


/** NOP function */
LIB_FUNC int __thread_nop(void) {
	return 0;
}


LIB_FUNC int pthread_condattr_init(UNUSED pthread_condattr_t* attr) {
	return 0;
}


LIB_FUNC int pthread_condattr_destroy(UNUSED pthread_condattr_t* attr) {
	return 0;
}


LIB_FUNC void __thread_start__key(UNUSED _pthread_descr td) {
	return;
}


LIB_FUNC void __thread_exit__key(UNUSED _pthread_descr td) {
	return;
}


/** Machine depending thread register */
LIB_FUNC _pthread_descr __thread_set_register(void* arg) {
#ifdef ARCHALPHA
	asm volatile ("call_pal 159;" : : "r"(arg) );
#elif defined(ARCHSPARC)
	asm volatile ("mov %0, %%g6;" : : "r"(arg) );
#elif defined(ARCHS390)
	asm volatile ("sar %%a0, %0;" : : "d"(arg) );
#elif defined(ARCHITANIUM)
	asm volatile ("mov r13 = %0;" : : "r"(arg) );
#endif
	return (_pthread_descr)arg;
}


LIB_FUNC int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex) {
	_pthread_descr this = __thread_self();
	_pthread_descr* tmp;
	if (mutex->__data.__owner != this) { return EINVAL; }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	__lock((volatile int*)cond);
	tmp = &(cond->__data.wait_chain);
	this->waitnext = 0;
	while (*tmp) { tmp = &((*tmp)->waitnext); }
	this->waitprev = tmp;
	*tmp = this;
	__unlock((volatile int*)cond);
	pthread_mutex_unlock(mutex);
	__thread_suspend(this, 1);
	pthread_mutex_lock(mutex);
	__lock((volatile int*)cond);
	if (this->waitnext) {
		this->waitnext->waitprev = this->waitprev;
		*(this->waitprev) = this->waitnext;
	}
	else { *(this->waitprev) = 0; }
	__unlock((volatile int*)cond);
	return 0;
}


LIB_FUNC int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec*abstime) {
	_pthread_descr this = __thread_self();
	_pthread_descr* tmp;
	int retval;
	if (mutex->__data.__owner != this) { return EINVAL; }
	__NO_ASYNC_CANCEL_BEGIN_(this);
	__lock((volatile int*)cond);
	tmp = &(cond->__data.wait_chain);
	this->waitnext = 0;
	while (*tmp) { tmp = &((*tmp)->waitnext); }
	this->waitprev = tmp;
	*tmp = this;
	__unlock((volatile int*)cond);
	pthread_mutex_unlock(mutex);
	retval = __thread_suspend_till(this, 1, abstime);
	pthread_mutex_lock(mutex);
	__lock((volatile int*)cond);
	if (this->waitnext) {
		this->waitnext->waitprev = this->waitprev;
		*(this->waitprev) = this->waitnext;
	} else { *(this->waitprev) = 0; }
	__unlock((volatile int*)cond);
	__NO_ASYNC_CANCEL_END_(this);
	return retval;
}


LIB_FUNC int pthread_cond_destroy(pthread_cond_t* c) {
	if (c->__data.__lock && c->__data.__nwaiters) {
		int cnt;
		a_or((volatile int*)&c->__data.__nwaiters, (int)0x80000000);
		a_inc((volatile int*)&c->__data.__broadcast_seq);
		__wake(&c->__data.__broadcast_seq, -1, 0);
		while ((cnt = (int)c->__data.__nwaiters) & 0x7fffffff) {
			__wait((volatile int*)&c->__data.__nwaiters, 0, cnt, 0);
		}
	}
	return 0;
}


LIB_FUNC int posix_spawnattr_init(posix_spawnattr_t* attr) {
	*attr = (posix_spawnattr_t) { 0 };
	return 0;
}


LIB_FUNC int posix_spawnattr_destroy(UNUSED posix_spawnattr_t* attr) {
	return 0;
}


LIB_FUNC int posix_spawnattr_setflags(posix_spawnattr_t* attr, const short flags) {
	attr->__flags = flags;
	return 0;
}


LIB_FUNC int posix_spawnattr_setsigdefault(posix_spawnattr_t* restrict attr, const sigset_t* restrict def) {
	attr->__sd = *def;
	return 0;
}


LIB_FUNC int posix_spawnattr_setsigmask(posix_spawnattr_t* restrict attr, const sigset_t* restrict mask) {
	attr->__ss = *mask;
	return 0;
}


LIB_FUNC int __timedwait_cp(volatile int* addr, const int val, clockid_t clk, const struct timespec* at, int priv) {
	int r;
	struct timespec to, *top = 0;
	if (priv) { priv = 128; }
	if (at) {
		if ((unsigned long)at->tv_nsec >= 1000000000UL) { return EINVAL; }
		else if (clock_gettime(clk, &to)) { return EINVAL; }
		to.tv_sec = at->tv_sec - to.tv_sec;
		if ((to.tv_nsec = at->tv_nsec - to.tv_nsec) < 0) {
			to.tv_sec--;
			to.tv_nsec += 1000000000;
		}
		if (to.tv_sec < 0) { return ETIMEDOUT; }
		top = &to;
	}
	r = -(int)syscall(SYS_futex, (long)&addr, (FUTEX_WAIT | priv), val, (long)&top);
	if (r == ENOSYS) { r = -(int)(syscall(SYS_futex, (long)&addr, FUTEX_WAIT, val, (long)&top)); }
	if (r != EINTR && r != ETIMEDOUT && r != ECANCELED) { r = 0; }
	return r;
}


LIB_FUNC int __timedwait(volatile int* addr, const int val, clockid_t clk, const struct timespec* at, int priv) {
	int cs;
	__pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	int r = __timedwait_cp(addr, val, clk, at, priv);
	__pthread_setcancelstate(cs, 0);
	return r;
}


/** Return error status of asynchronous I/O request */
LIB_FUNC int aio_error(const struct aiocb* aiocbp) {
	pthread_mutex_lock(&__aio_requests_mutex);
	const int ret = aiocbp->__error_code;
	pthread_mutex_unlock(&__aio_requests_mutex);
	return ret;
}
#define aio_error64(aiocbp)   aio_error((aiocbp))


LIB_FUNC struct requestlist* __aio_find_req(aiocb_union* elem) {
	struct requestlist* runp = requests;
	int fildes = elem->aiocb.aio_fildes;
	while (runp != NULL && runp->aiocbp->aiocb.aio_fildes < fildes) { runp = runp->next_fd; }
	if (runp != NULL) {
		if (runp->aiocbp->aiocb.aio_fildes != fildes) { runp = NULL; }
		else { while (runp != NULL && runp->aiocbp != elem) { runp = runp->next_prio; } }
	}
	return runp;
}


LIB_FUNC struct requestlist* __aio_find_req_fd(int fildes) {
	struct requestlist* runp = requests;
	while (runp != NULL && runp->aiocbp->aiocb.aio_fildes < fildes) { runp = runp->next_fd; }
	return (struct requestlist*)((runp != NULL) && (runp->aiocbp->aiocb.aio_fildes == fildes) ? runp : NULL);
}


LIB_FUNC void __aio_free_request(struct requestlist* elem) {
	elem->running = no;
	elem->next_prio = freelist;
	freelist = elem;
}


/** Suspend until termination of a requests */
LIB_FUNC int aio_suspend(struct aiocb* list[], int nent, const struct timespec* timeout) {
	if (PREDICT_UNLIKELY(nent < 0)) {
		__set_errno(EINVAL);
		return -1;
	}
	struct waitlist _waitlist[nent];
	struct requestlist* _requestlist[nent];
#   ifndef DONT_NEED_AIO_MISC_COND
	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
#   endif
	bool any = false;
	int result = 0, cnt;
	unsigned int cntr = 1;
	pthread_mutex_lock(&__aio_requests_mutex);
	for (cnt = 0; cnt < nent; ++cnt) {
		if (list[cnt] != NULL) {
			if (list[cnt]->__error_code == EINPROGRESS) {
				_requestlist[cnt] = __aio_find_req((aiocb_union*)list[cnt]);
				if (_requestlist[cnt] != NULL) {
#   ifndef DONT_NEED_AIO_MISC_COND
					_waitlist[cnt].cond = &cond;
#   endif
					_waitlist[cnt].result = NULL;
					_waitlist[cnt].next = _requestlist[cnt]->waiting;
					_waitlist[cnt].counterp = &cntr;
					_waitlist[cnt].sigevp = NULL;
#   ifdef BROKEN_THREAD_SIGNALS
					_waitlist[cnt].caller_pid = 0;
#   endif
					_requestlist[cnt]->waiting = &_waitlist[cnt];
					any = true;
				} else { break; }
			} else { break; }
		}
	}
	if (cnt == nent && any) {
		struct clparam _clparam = {
			.__list = (struct aiocb*)&list,
			.__waitlist = _waitlist,
			.__requestlist = _requestlist,
#   ifndef DONT_NEED_AIO_MISC_COND
			.cond = &cond,
#   endif
			.nent = nent
		};
		pthread_cleanup_push(__thread_cleanup_helper, &_clparam);
#   ifdef DONT_NEED_AIO_MISC_COND
		result = do_aio_misc_wait(&cntr, timeout);
#   else
		if (timeout == NULL) {
			result = pthread_cond_wait(&cond, &__aio_requests_mutex);
		} else {
			struct timeval now;
			struct timespec abstime;
			gettimeofday(&now, NULL);
			abstime.tv_nsec = timeout->tv_nsec + now.tv_usec * 1000;
			abstime.tv_sec = timeout->tv_sec + now.tv_sec;
			if (abstime.tv_nsec >= 1000000000) {
				abstime.tv_nsec -= 1000000000;
				abstime.tv_sec += 1;
			}
			result = pthread_cond_timedwait(&cond, &__aio_requests_mutex, &abstime);
		}
#   endif
		pthread_cleanup_pop(0);
	}
	while (cnt-- > 0) {
		if (list[cnt] != NULL && list[cnt]->__error_code == EINPROGRESS) {
			struct waitlist** listp;
			assert(_requestlist[cnt] != NULL);
			listp = &_requestlist[cnt]->waiting;
			while (*listp != NULL && *listp != &_waitlist[cnt]) { listp = &(*listp)->next; }
			if (*listp != NULL) { *listp = (*listp)->next; }
		}
	}
#   ifndef DONT_NEED_AIO_MISC_COND
	if (PREDICT_UNLIKELY(pthread_cond_destroy(&cond) != 0)) { abort(); }
#   endif
	if (result != 0) {
#   ifndef DONT_NEED_AIO_MISC_COND
		if (result == ETIMEDOUT) { __set_errno(EAGAIN); }
		else
#   endif
		__set_errno(result);
		result = -1;
	}
	pthread_mutex_unlock(&__aio_requests_mutex);
	return result;
}
#define aio_suspend64(list, nent, timeout)   aio_suspend((list), (nent), (timeout))


LIB_FUNC int lio_wait(struct lio_state* st) {
	int i, err, got_err = 0;
	int cnt = st->cnt;
	struct aiocb** cbs = st->cbs;
	for (;;) {
		for (i = 0; i < cnt; i++) {
			if (!cbs[i]) continue;
			err = aio_error(cbs[i]);
			if (err == EINPROGRESS) { break; }
			else if (err) { got_err = 1; }
			cbs[i] = 0;
		}
		if (i == cnt) {
			if (got_err) { errno = EIO; return -1; }
			return 0;
		} else if (aio_suspend((void*)cbs, cnt, 0)) return -1; }
}


LIB_FUNC void notify_signal(struct sigevent* sev) {
	siginfo_t si = {
		.si_signo = sev->sigev_signo,
		.si_value = sev->sigev_value,
		.si_code = SI_ASYNCIO,
		.si_pid = getpid(),
		.si_uid = getuid()
	};
	__syscall(SYS_rt_sigqueueinfo, si.si_pid, si.si_signo, (long)&si);
}


LIB_FUNC void* wait_thread(void* p) {
	struct lio_state* st = p;
	struct sigevent* sev = st->sev;
	lio_wait(st);
	free(st);
	switch (sev->sigev_notify) {
		case SIGEV_SIGNAL:
			notify_signal(sev);
			return 0;
		case SIGEV_THREAD:
			sev->sigev_notify_function(sev->sigev_value);
			return 0;
		default: return 0;
	}
	UNREACHABLE
}


/* TODO: Add PTHREAD functions
int pthread_create(pthread_t *restrict, const pthread_attr_t *restrict, void *(*)(void*), void *restrict);
int pthread_detach(pthread_t);
_Noreturn void pthread_exit(void*);
int pthread_join(pthread_t, void **);
pthread_t pthread_self(void);
#if IS_NOT_CPLUSPLUS
#   define pthread_equal(x, y)   ((x)==(y))
#else
int pthread_equal(pthread_t, pthread_t);
#endif
int pthread_setcancelstate(int, int *);
int pthread_setcanceltype(int, int *);
void pthread_testcancel(void);
int pthread_cancel(pthread_t);
int pthread_getschedparam(pthread_t, int *restrict, struct sched_param *restrict);
int pthread_setschedparam(pthread_t, int, const struct sched_param *);
int pthread_setschedprio(pthread_t, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_mutex_init(pthread_mutex_t *restrict, const pthread_mutexattr_t *restrict);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_timedlock(pthread_mutex_t *restrict, const struct timespec *restrict);
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_consistent(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict, int *restrict);
int pthread_mutex_setprioceiling(pthread_mutex_t *restrict, int, int *restrict);
int pthread_cond_init(pthread_cond_t *restrict, const pthread_condattr_t *restrict);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_wait(pthread_cond_t *restrict, pthread_mutex_t *restrict);
int pthread_cond_timedwait(pthread_cond_t *restrict, pthread_mutex_t *restrict, const struct timespec *restrict);
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_signal(pthread_cond_t *);
int pthread_rwlock_init(pthread_rwlock_t *restrict, const pthread_rwlockattr_t *restrict);
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict, const struct timespec *restrict);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict, const struct timespec *restrict);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_spin_init(pthread_spinlock_t *, int);
int pthread_spin_destroy(pthread_spinlock_t *);
int pthread_spin_lock(pthread_spinlock_t *);
int pthread_spin_trylock(pthread_spinlock_t *);
int pthread_spin_unlock(pthread_spinlock_t *);
int pthread_barrier_init(pthread_barrier_t *restrict, const pthread_barrierattr_t *restrict, unsigned);
int pthread_barrier_destroy(pthread_barrier_t *);
int pthread_barrier_wait(pthread_barrier_t *);
int pthread_key_create(pthread_key_t *, void (*)(void*));
int pthread_key_delete(pthread_key_t);
void *pthread_getspecific(pthread_key_t);
int pthread_setspecific(pthread_key_t, const void *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getguardsize(const pthread_attr_t *restrict, size_t *restrict);
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
int pthread_attr_getstacksize(const pthread_attr_t *restrict, size_t *restrict);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_attr_getstack(const pthread_attr_t *restrict, void **restrict, size_t *restrict);
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int pthread_attr_getscope(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_getschedpolicy(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_getschedparam(const pthread_attr_t *restrict, struct sched_param *restrict);
int pthread_attr_setschedparam(pthread_attr_t *restrict, const struct sched_param *restrict);
int pthread_attr_getinheritsched(const pthread_attr_t *restrict, int *restrict);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict, int *restrict);
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *, int);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_condattr_getclock(const pthread_condattr_t *restrict, clockid_t *restrict);
int pthread_condattr_getpshared(const pthread_condattr_t *restrict, int *restrict);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict, int *restrict);
int pthread_barrierattr_destroy(pthread_barrierattr_t *);
int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict, int *restrict);
int pthread_barrierattr_init(pthread_barrierattr_t *);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
int pthread_getconcurrency(void);
int pthread_setconcurrency(int);
int pthread_getcpuclockid(pthread_t, clockid_t *);
void _pthread_cleanup_push(struct __ptcb *, void (*)(void*), void *);
void _pthread_cleanup_pop(struct __ptcb *, int);
#define pthread_cleanup_push(f, x)   do { struct __ptcb __cb; _pthread_cleanup_push(&__cb, f, x);
#define pthread_cleanup_pop(r)   _pthread_cleanup_pop(&__cb, (r)); } while(0x0)
int pthread_getaffinity_np(pthread_t, size_t, struct cpu_set_t *);
int pthread_setaffinity_np(pthread_t, size_t, const struct cpu_set_t *);
int pthread_getattr_np(pthread_t, pthread_attr_t *);
pthread_t __pthread_self_init(void);
int __clone(int (*)(void*), void *, int, void *, ...);
int __set_thread_area(void*);
int __libc_sigprocmask(int, const sigset_t *, sigset_t *);
void __unmapself(void *, size_t);
void __vm_wait(void);
void __vm_lock(void);
void __vm_unlock(void);
int __timedwait(volatile int *, int, clockid_t, const struct timespec *, int);
int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec *, int);
void __wait(volatile int *, volatile int *, int, int);
void __acquire_ptc(void);
void __release_ptc(void);
void __inhibit_ptc(void);
void __block_all_sigs(void*);
void __block_app_sigs(void*);
*/


#endif  // PTHREAD_H


/* LINKAGE SYMBOLS */


#ifndef STANDARDLIB_H
#define STANDARDLIB_H   (1)  // FIXME


#ifdef MAIN_AUXVEC_ARG
#   define MAIN_AUXVEC_DECL   , void*
#   define MAIN_AUXVEC_PARAM   , auxvec
#else
#   define MAIN_AUXVEC_DECL
#   define MAIN_AUXVEC_PARAM
#endif


static UNUSED void (*funcs[32])(void);
typedef int (*cmpfun)(const void*, const void*);


static UNUSED struct fl {
	struct fl* next;
	void (*f[32])(void*);
	void *a[32];
} exit_struct, *head;


LIB_FUNC void call(void* p) {
	((void(*)(void))(uintptr_t)p)();
}


LIB_FUNC noreturn void _Exit(const int code) {
	__syscall(SYS_exit_group, code);
	for (;;) { __syscall(SYS_exit, code); }
}
#define quick_exit(code)   _Exit((code))
#define _exit(code)   _Exit((code))
#define exit(code)   _Exit((code))


LIB_FUNC void __funcs_on_exit(void) {
	void (*func)(void*), *arg;
	__lock(lock);
	for (; head; head = head->next, slot = 32) {
		while ((slot--) > 0) {
			func = head->f[slot];
			arg = head->a[slot];
			__unlock(lock);
			func(arg);
			__lock(lock);
		}
	}
}


LIB_FUNC int __cxa_atexit(void (*func)(void*), void* arg, UNUSED void* dso) {
	__lock(lock);
	if (!head) { head = &exit_struct; }
	if (slot == 32) {
		struct fl* new_fl = calloc(sizeof(struct fl), 1);
		if (!new_fl) { __unlock(lock); return -1; }
		new_fl->next = head;
		head = new_fl;
		slot = 0;
	}
	head->f[slot] = func;
	head->a[slot] = arg;
	++slot;
	__unlock(lock);
	return 0;
}


#ifdef ARM
LIB_FUNC int __aeabi_atexit(void* obj, void (*func)(void*), void* d) {
	return __cxa_atexit(func, obj, d);
}
#endif


LIB_FUNC int atexit(void (*func)(void)) {
	return __cxa_atexit(call, (void*)(uintptr_t)func, 0);
}


LIB_FUNC void __funcs_on_quick_exit(void) {
	void (*func)(void);
	__lock(lock);
	while (exit_counter > 0) {
		func = funcs[--exit_counter];
		__unlock(lock);
		func();
		__lock(lock);
	}
}


LIB_FUNC int at_quick_exit(void (*func)(void)) {
	if (exit_counter == 32) { return -1; }
	__lock(lock);
	funcs[exit_counter++] = func;
	__unlock(lock);
	return 0;
}


#if 0


extern UNUSED int __libc_multiple_libcs;
UNUSED attribute_hidden int __libc_argc;
UNUSED attribute_hidden char** __libc_argv;
extern UNUSED attribute_hidden void (*__preinit_array_start[])(int, char**, char**);
extern UNUSED attribute_hidden void (*__preinit_array_end[])(int, char**, char**);
extern UNUSED attribute_hidden void (*__init_array_start[])(int, char**, char**);
extern UNUSED attribute_hidden void (*__init_array_end[])(int, char**, char**);
extern UNUSED void (*__fini_array_start[])(void) attribute_hidden;
extern UNUSED void (*__fini_array_end[])(void) attribute_hidden;


extern void __stack_chk_fail(void);
void __stack_chk_fail(void) {
	a_crash();
}
#define __stack_chk_fail_local()   __stack_chk_fail()


#ifndef NO_INITFINI
extern void _init(void);
extern void _fini(void);
#endif


extern void __libc_csu_init(int argc, char** argv, char** envp);
void __libc_csu_init(int argc, char** argv, char** envp) {
#   ifndef LIBC_NONSHARED  // For static executables, preinit happens right before init
	const size_t size_pre = (size_t)(__preinit_array_end - __preinit_array_start);
	size_t i;
	for (i = 0; i < size_pre; i++) {
		(*__preinit_array_start[i]) (argc, argv, envp);
	}
#   endif
#   ifndef NO_INITFINI
	_init();
#   endif
	const size_t size = (size_t)(__init_array_end - __init_array_start);
	for (size_t i = 0; i < size; i++) {
		(*__init_array_start[i]) (argc, argv, envp);
	}
}


extern void __libc_csu_fini (void);
void __libc_csu_fini (void) {
#   ifndef LIBC_NONSHARED
	size_t i = (size_t)(__fini_array_end - __fini_array_start);
	while (i-- > 0) { (*__fini_array_start[i]) (); }
#      ifndef NO_INITFINI
	_fini();
#      endif
#   endif
}


UNUSED int __libc_start_main(int (*main)(int, char**, char**), int argc, char** argv);
UNUSED int __libc_start_main(int (*main)(int, char**, char**), int argc, char** argv) {
	char** envp = argv + argc + 1;
	// __init_libc(envp, argv[0]);
	// libc_start_init();
	exit(main(argc, argv, envp));
	return 0;
}
#ifndef LIBC_START_MAIN
#   define LIBC_START_MAIN   __libc_start_main
#endif


#ifdef NEEDS_STARTUP


#ifndef SHARED
#   ifndef THREAD_SET_STACK_GUARD
/** Only exported for architectures that do not store the stack guard canary in thread local area */
uintptr_t attribute_relro __stack_chk_guard;
#   endif
#   ifndef THREAD_SET_POINTER_GUARD
/** Only exported for architectures that do not store the pointer guard value in thread local area */
uintptr_t attribute_relro attribute_hidden __attribute__((nocommon)) __pointer_chk_guard_local;
#   endif
#endif
#define DEFINE_INIT   1
#define DEFINE_FINI   1
UNUSED int __data_start = 0;
#define data_start   __data_start


extern noreturn void _dl_start(void);
noreturn void _dl_start(void) {
	abort();
}


extern noreturn void __libc_main(void);
noreturn void __libc_main(void) {
	_Exit(0);
}


LIB_FUNC void __init_ssp(void* entropy) {
	if (entropy) { memcpy_no_output(&__stack_chk_guard, entropy, sizeof(uintptr_t)); }
	else { __stack_chk_guard = (uintptr_t)&__stack_chk_guard * 1103515245; }
	struct pthread* pself = __pthread_self();
	pself->CANARY = (uintptr_t)__stack_chk_guard;
}


/*
static UNUSED void libc_start_init(void) {
	_init();
	uintptr_t a = (uintptr_t)&__init_array_start;
	for (; a < (uintptr_t)&__init_array_end; a += sizeof(void(*)())) {
		(*(void (**)())a)();
	}
}
#define __libc_start_init()   libc_start_init()
*/


#endif  // NEEDS_STARTUP


#endif  // 0


#endif


/* STANDARD LIBRARY DEFINITIONS (<stdlib.h>) */


#if (!(defined(_STDLIB_H) || defined(_STDLIB_H_) || defined(_STDLIB_IMPL_H) || defined(_STDLIB_IMPL_H_) || defined(_STDLIB_EXT_H) || defined(_STDLIB_EXT_H_) || defined(ITOA_H) || defined(_ITOA_H) || defined(_ITOA_H_)))  // http://www.cplusplus.com/reference/cstdlib/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdlib.h.html
#define STDLIB_H   (1)
#define _STDLIB_H   (1)
#define _STDLIB_H_   (1)
#define _STDLIB_IMPL_H   (1)
#define _STDLIB_IMPL_H_   (1)
#define _STDLIB_EXT_H   (1)
#define _STDLIB_EXT_H_   (1)
#define ITOA_H   (1)  // <itoa.h>
#define _ITOA_H   (1)
#define _ITOA_H_   (1)
#define YESNO_H_   (1)
#define _PTY_H   (1)
#define PTY_H   (1)
#define SYS_PTY_H   (1)
#define _SYS_PTY_H_   (1)


#ifdef VMS  // VMS is nonstandard
/** This macro expands to a system-dependent integral expression that signifies that the application failed (when used as the argument for the function exit) */
#   define EXIT_FAILURE   (0)
/** This macro expands to a system-dependent integral expression that signifies that the application was successful (when used as the argument for the function exit) */
#   define EXIT_SUCCESS   (1)
#else
/** This macro expands to a system-dependent integral expression that signifies that the application failed (when used as the argument for the function exit) */
#   define EXIT_FAILURE   (1)
/** This macro expands to a system-dependent integral expression that signifies that the application was successful (when used as the argument for the function exit) */
#   define EXIT_SUCCESS   (0)
#endif
#ifndef exit_success
/** This macro expands to a system-dependent integral expression that signifies that the application was successful (when used as the argument for the function exit) */
#   define exit_success   EXIT_SUCCESS
#endif
#ifndef exit_failure
/** This macro expands to a system-dependent integral expression that signifies that the application failed (when used as the argument for the function exit) */
#   define exit_failure   EXIT_FAILURE
#endif
#define FSETLOCKING_QUERY   0
#define FSETLOCKING_INTERNAL   1
#define FSETLOCKING_BYCALLER   2
/** The largest number rand will return (same as INT_MAX) */
#define RAND_MAX   (0x7fffffff)
#define WNOHANG   1
#define WUNTRACED   2
#define FDOP_CLOSE   1
#define FDOP_DUP2   2
#define FDOP_OPEN   3
#define CLOCKS_PER_SEC   (1000000L)
#define CLK_TCK   CLOCKS_PER_SEC
#define TIME_UTC   (1)
#define CLOCK_REALTIME   (0)


typedef struct attr_packed fdop {
	struct fdop *next, *prev;
	int cmd, fd, srcfd, oflag;
	mode_t mode;
	char path[];
} fdop_t;


#ifndef PTYNAME1
/** Letters indicating a series of pseudo terminals */
#   define PTYNAME1   "pqrsPQRS"
#endif
#ifndef PTYNAME2
/** Letters indicating the position within a series */
#   define PTYNAME2   "0123456789abcdefghijklmnopqrstuv"
#endif
const UNUSED attribute_hidden char __libc_ptyname1[16] = PTYNAME1;
const UNUSED attribute_hidden char __libc_ptyname2[64] = PTYNAME2;


// DATATYPE <-> STRING CONVERSIONS

#define _ITOA_WORD_TYPE   unsigned long long
#define ITOA_T   unsigned long long
#ifndef _ITOA_NEEDED
#   define _ITOA_NEEDED    (LONG_MAX != LLONG_MAX)
#endif


LIB_FUNC int digitval(const int ch) {
	if (ch >= '0' && ch <= '9') { return (int)(ch - '0'); }
	else if (ch >= 'A' && ch <= 'Z') { return (int)(ch - 'A' + 10); }
	else if (ch >= 'a' && ch <= 'z') { return (int)(ch - 'a' + 10); }
	return -1;
}


LIB_FUNC int hexval(const unsigned int x) {
	if ((x - '0') < 10) { return (int)(x - '0'); }
	register unsigned y = x | 32;
	if ((y - 'a') < 6) { return (int)(y - ('a' + 10)); }
	return -1;
}


LIB_FUNC int digittoint(const char ch) {
	register int d = (int)(ch - '0');
	if ((unsigned)d < 10) { return d; }
	d = (int)(ch - 'a');
	if ((unsigned)d < 6) { return (int)(d + 10); }
	d = (int)(ch - 'A');
	if ((unsigned)d < 6) { return (int)(d + 10); }
	return -1;
}


/** Convert an unsigned char value into a char value without relying on signed overflow behavior */
LIB_FUNC char wrapv(const unsigned char _char) {
	if (((unsigned int)_char) >= 0x80U) { return (char)(_char - 0x100); }
	return (char)_char;
}


/** Convert string to short */
LIB_FUNC short atos(const char* restrict s) {
	register short n = 0;
	register int neg = 0;
	while ((isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1; break;
		case '+': ++s;
		default: break;
	}
	while ((isdigit(*s))) { n = (short)((10 * n) - (*s++ - '0')); }
	return (short)(neg ? n : -n);
}


/** Convert string to int */
LIB_FUNC int atoi(const char* restrict s) {
	register int n = 0, neg = 0;
	while ((isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1; break;
		case '+': ++s;
		default: break;
	}
	while ((isdigit(*s))) { n = (int)((10 * n) - (*s++ - '0')); }
	return (int)(neg ? n : -n);
}


/** Convert string to long int */
LIB_FUNC long atol(const char* restrict s) {
	register long n = 0;
	register int neg = 0;
	while ((isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1; break;
		case '+': ++s;
		default: break;
	}
	while ((isdigit(*s))) { n = (long)((10 * n) - (*s++ - '0')); }
	return (long)(neg ? n : -n);
}


/** Convert string to long long int */
LIB_FUNC long long atoll(const char* restrict s) {
	register long long n = 0;
	register int neg = 0;
	while ((isspace(*s))) { ++s; }
	switch (*s) {
		case '-': neg = 1; break;
		case '+': ++s;
		default: break;
	}
	while ((isdigit(*s))) { n = (long long)((10 * n) - (*s++ - '0')); }
	return (long long)(neg ? n : -n);
}


LIB_FUNC long a64l(const char* s) {
	register int e;
	register uint32_t x = 0;
	for (e = 0; e < 36 && *s; e += 6, s++) { x |= (uint32_t)((strchr(a64l_digits, *s) - a64l_digits) << e); }
	return (long)x;
}


/** Convert an integer to a string */
LIB_FUNC char* itoa(int i, char b[]) {
	char* p = b;
	if (i < 0) { *p++ = '-'; i *= -1; }
	register unsigned int shifter = (unsigned int)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do{  // Move back, inserting digits
		*--p = str_digit[i % 10];
		i /= 10;
	} while (i);
	return b;
}
#define _itoa(i, b)   itoa((i), (b))


LIB_FUNC char* ui32toa(uint32_t value, char* restrict _string, const int radix) {
	char buffer[65] = { 0 };
	char* pos;
	register int _digit;
	pos = &buffer[64];
	*pos = '\0';
	do {
		_digit = (int)((int)value % radix);
		value = (uint32_t)((int)value / radix);
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (value != 0L);
	return memcpy(_string, pos, (size_t)(&buffer[64] - pos + 1));
}
#define _ui32toa(value, _string, radix)   ui32toa((value), (_string), (radix))


LIB_FUNC char* i64toa(const int64_t value, char* restrict _string, const int radix) {
	register unsigned long long val;
	register int negative;
	char buffer[65] = { 0 };
	char* pos;
	if (value < 0 && radix == 10) {
		negative = 1;
		val = (unsigned long long)-value;
	} else {
		negative = 0;
		val = (unsigned long long)value;
	}
	pos = &buffer[64];
	*pos = '\0';
	register int _digit;
	do {
		_digit = (int)((int)val % radix);
		val = val / (unsigned long long)radix;
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (val != 0L);
	if (negative) { *--pos = '-'; }
	return memcpy(_string, pos, (size_t)(&buffer[64] - pos + 1));
}


LIB_FUNC char* ui64toa(uint64_t value, char* restrict str, const int radix) {
	char buffer[65] = { 0 };
	char* pos;
	register uint64_t _digit;
	pos = &buffer[64];
	*pos = '\0';
	do {
		_digit = (uint64_t)(value % (uint64_t)radix);
		value = (uint64_t)(value / (uint64_t)radix);
		if (_digit < 10) { *--pos = (char)('0' + _digit); }
		else { *--pos = (char)('a' + _digit - 10); }
	} while (value != (uint64_t)0);
	return memcpy(str, pos, (size_t)(&buffer[64] - pos + 1));
}


LIB_FUNC int l64a_r(const long value, char* buffer, int buflen) {
	char* s = buffer;
	register int _digit;
	unsigned long v = (unsigned long)value;
	_DIAGASSERT(buffer != NULL);
	if (value == 0UL) {
		*s = '\0';
		return (v == 0UL ? 0 : -1);
	}
	for (; v != 0 && buflen > 1; s++, buflen--) {
		_digit = (int)(v & 0x3f);
		if (_digit < 2) { *s = (char)(_digit + '.'); }
		else if (_digit < 12) { *s = (char)(_digit + '0' - 2); }
		else if (_digit < 38) { *s = (char)(_digit + 'A' - 12); }
		else { *s = (char)(_digit + 'a' - 38); }
		v >>= 6;
	}
	*s = '\0';
	return (v == 0UL ? 0 : -1);
}
#define _l64a_r(value, buffer, buflen)   l64a_r((value), (buffer), (buflen))


LIB_FUNC char* l64a(const long value) {
	static char buf[8] = { 0 };
	(void)l64a_r(value, buf, 8);
	return buf;
}
#define _l64a(value)   l64a((value))


/** Convert unsigned long long to string given the value, string buffer, and number base */
LIB_FUNC void ulltostr(const uint64_t value, char* restrict strbuf, const int base) {
	register int count = 0;
	if (NULL == strbuf) { return; }
	else if (value == 0) { ++count; }
	register uint64_t t = 0, tmp = value, tmpval = value;
	while (tmp > 0) {
		tmp = tmp / (uint64_t)base;
		++count;
	}
	strbuf += count;
	*strbuf = '\0';
	register uint64_t res = 0;
	do {
		res = tmpval - (uint64_t)base * (t = tmpval / (uint64_t)base);
		if (res < 10) { *--strbuf = (char)('0' + res); }
		else if ((res >= 10) && (res < 16)) { *--strbuf = (char)((uint64_t)('A' - 10) + res); }
	} while ((tmpval = t) != 0);
}
#define ulltoa(value, strbuf, base)   ulltostr((value), (strbuf), (base))


/** Convert unsigned long to string given the value, string buffer, and number base */
LIB_FUNC void ultostr(const unsigned long value, char* restrict strbuf, const int base) {
	ulltostr((uint64_t)value, strbuf, base);
}
#define ultoa(value, strbuf, base)   ultostr((value), (strbuf), (base))


/** Convert unsigned long to string */
LIB_FUNC int __ltostr(char* s, unsigned int size, unsigned long i, unsigned int base, const int UpCase) {
	register unsigned int j = 0;
	s[--size] = 0;
	char* tmp;
	tmp = s + size;
	if ((base == 0) || (base > 36)) { base = 10; }
	j = 0;
	if (!i) {
		*(--tmp) = '0';
		j = 1;
	}
	register char tmpc;
	while ((tmp > s) && i) {
		tmp--;
		if ((*tmp = (char)(i % (unsigned long)base + '0')) > '9') {
			tmpc = (char)((UpCase ? 'A' : 'a') - '9' - (char)1);
			*tmp = (char)(*tmp + tmpc);
		}
		i = i / (unsigned long)base;
		j++;
	}
	memmove(s, tmp, (size_t)(j + 1));
	return (int)j;
}


/** Convert unsigned long long to string */
LIB_FUNC int __lltostr(char* s, int size, unsigned long long i, int base, const char UpCase) {
	char* tmp;
	register unsigned int j = 0;
	s[--size] = 0;
	tmp = s + size;
	if ((base == 0) || (base > 36)) { base = 10; }
	j = 0;
	if (!i) {
		*(--tmp) = '0';
		j = 1;
	}
	register char tmpc;
	while ((tmp > s) && i) {
		tmp--;
		if ((*tmp = (char)(i % (unsigned long long)base + '0')) > '9') {
			tmpc = (char)((UpCase ? 'A' : 'a') - '9' - 1);
			*tmp = (char)(*tmp + tmpc);
		}
		i = i / (unsigned long long)base;
		j++;
	}
	memmove(s, tmp, (size_t)(j + 1));
	return (int)j;
}
#define lltostr(s, size, i, base, UpCase)   __lltostr((s), (size), (i), (base), (UpCase))


/** Convert double to string */
LIB_FUNC int __dtostr(double d, char* buf, unsigned int maxlen, unsigned int prec, unsigned int prec2, int g) {
	union {
		unsigned long long l;
		double d;
	} u = { .d = d };
	// Extract sign, mantissa and exponent
	signed long e10, e = (signed long)(((u.l >> 52) & 0x7ff) - 1023);
	unsigned int i;
	double backup = d, tmp;
	char* oldbuf = buf;
	if ((i = (unsigned int)__isinf(d))) { return copystring(buf, (int)maxlen, (i > 0 ? "inf" : "-inf")); }
	else if (__isnan(d)) { return copystring(buf, (int)maxlen, "nan"); }
	e10 = 1 + (signed long)(e * (signed long)0.30102999566398119802);
	if (d == 0.0) {
		prec2 = ((prec2 == 0) ? 1 : prec2 + 2);
		prec2 = ((prec2 > maxlen) ? 8 : prec2);
		i = 0;
		if (prec2 && (long long)u.l < 0) { buf[0] = '-'; ++i; }
		for (; i < prec2; ++i) { buf[i] = '0'; }
		buf[((buf[0] == '0') ? 1 : 2)] = '.';
		buf[i] = 0;
		return (int)i;
	} else if (d < 0.0) { d = -d; *buf = '-'; --maxlen; ++buf; }
	// Perform rounding
	tmp = 0.5;
	for (i = 0; i < prec2; i++) { tmp *= 0.1; }
	d += tmp;
	if (d < 1.0) { *buf = '0'; --maxlen; ++buf; }
	if (e10 > 0) {
		int first = 1;
		tmp = 10.0;
		i = (unsigned int)e10;
		while (i > 10) { tmp = tmp * 1e10; i -= 10; }
		while (i > 1) { tmp = tmp * 10; --i; }
		while (tmp > 0.9) {
			char _digit;
			double fraction = d / tmp;
			_digit = (char)((int)fraction);
			if (!first || _digit) {
				first = 0;
				*buf = (char)((char)_digit + '0');
				++buf;
				if (!maxlen) {  // Use scientific notation
					int len = __dtostr((backup / tmp), oldbuf, maxlen, prec, prec2, 0);
					int initial = 1;
					if (len == 0) { return 0; }
					maxlen -= (unsigned int)len;
					buf += len;
					if (maxlen > 0) {
						*buf = 'e';
						++buf;
					}
					--maxlen;
					for (len = 1000; len > 0; len /= 10) {
						if (e10 >= len || !initial) {
							if (maxlen > 0) {
								*buf = (char)((char)(e10 / (signed long)len) + '0');
								++buf;
							}
							--maxlen;
							initial = 0;
							e10 = e10 % len;
						}
					}
					if (maxlen > 0) { goto dtostr_fini; }
					return 0;
				}
				d -= (_digit * tmp);
				--maxlen;
			}
			tmp /= 10.0;
		}
	} else { tmp = 0.1; }
	if (buf == oldbuf) {
		if (!maxlen) { return 0; }
		--maxlen;
		*buf = '0';
		++buf;
	}
	if (prec2 || prec > (unsigned int)(buf - oldbuf) + 1) {
		if (!maxlen) { return 0; }
		--maxlen;
		*buf = '.';
		++buf;
		if (g) {
			if (prec2) { prec = prec2; }
			prec -= (unsigned int)(buf - oldbuf - 1);
		} else {
			prec -= (unsigned int)(buf - oldbuf - 1);
			if (prec2) { prec = prec2; }
		}
		if (prec > maxlen) { return 0; }
		while (prec > 0) {
			char _digit;
			double fraction = d / tmp;
			_digit = (char)((int)fraction);
			*buf = (char)(_digit + '0');
			++buf;
			d -= _digit * tmp;
			tmp /= 10.0;
			--prec;
		}
	}
dtostr_fini:
	*buf = 0;
	return (int)(buf - oldbuf);
}


/** Convert a floating-point number to a string */
LIB_FUNC char* ecvt(const double x, int n, int* dp, int* sign) {
	static char buf[16] = { 0 };
	char tmp[32] = { 0 };
	register int i, j;
	if ((n - 1) > 15) { n = 15; }
	sprintf(tmp, "%.*e", n - 1, x);
	i = *sign = (tmp[0] == '-');
	for (j = 0; tmp[i] != 'e'; j += (tmp[i++] != '.')) { buf[j] = tmp[i]; }
	buf[j] = 0;
	*dp = atoi(tmp + i + 1) + 1;
	return buf;
}


/** Convert a floating-point number to a string */
LIB_FUNC char* fcvt(const double x, int n, int* dp, int* sign) {
	char tmp[1500] = { 0 };
	register int i, lz;
	if (n > 1400) { n = 1400; }
	sprintf(tmp, "%.*f", n, x);
	i = (tmp[0] == '-');
	if (tmp[i] == '0') { lz = (int)strspn((tmp + i + 2), "0"); }
	else { lz = (int)(-(int)strcspn((tmp + i), ".")); }
	if (n <= lz) {
		*sign = i;
		*dp = 1;
		if (n > 14) { n = 14; }
		static char fcvt_zeros[16] = "000000000000000";
		return (char*)(fcvt_zeros + 14 - n);
	}
	return ecvt(x, (n - lz), dp, sign);
}


/** Converts a number to a minimal length null-terminated ASCII string and stores the result in b */
LIB_FUNC char* gcvt(const double x, int n, char* b) {
	sprintf(b, "%.*g", n, x);
	return b;
}


/** Convert string to float */
LIB_FUNC float strtof(const char* s, const char** endptr) {
	register const char* p = s;
	while ((((*p) == 0x20) | ((8 < (*p)) & ((*p) < 0xE)))) { p++; }
	register float sign = 1.0F;
	switch (*p) {
		case '-': sign = -1.0F;
		case '+': ++p;
		default: break;
	}
	register float value = 0.0F;
	while ((unsigned int)(*p - '0') < 10u) { value = (float)(((int)value) * 10 + ((*p++) - '0')); }
	register float factor;
	if (*p == '.') {
		factor = 1.0F;
		++p;
		while ((unsigned int)(*p - '0') < 10u) {
			factor *= 0.1F;
			value += (((float)(*p++ - '0')) * factor);
		}
	}
	if ((*p | 32) == 'e') {
		register unsigned int expo = 0;
		factor = 10.0F;
		switch (*++p) {
			case '-': factor = 0.1F;
			case '+': ++p; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				value = 0.0F;
				p = s;
				if (endptr != NULL) { *endptr = p; }
				return (float)(value * sign);
		}
		while ((unsigned int)(*p - '0') < 10u) { expo = ((10 * expo) + (unsigned int)(*p++ - '0')); }
		while (0x1) {
			if (expo & 1) { value *= factor; }
			if ((expo >>= 1) == 0) { break; }
			factor *= factor;
		}
	}
	if (endptr != NULL) { *endptr = p; }
	return (float)(value * sign);
}
#define STRTOF(_string, endptr)   strtof((_string), (endptr))
#define __strtof_l(_string, endptr, locale)   strtof((_string), (endptr))
#define __strtof_internal(_string, endptr)   strtof((_string), (endptr))
#define STRTOF_L(_string, endptr, locale)   strtof((_string), (endptr))
#define strtof_l(_string, endptr, locale)   strtof((_string), (endptr))


/** Convert string to double */
LIB_FUNC double strtod(const char* s, const char** endptr) {
	register const char* p = s;
	register double sign = 1.0;
	while ((((*p) == 0x20) | ((8 < (*p)) & ((*p) < 0xE)))) { p++; }
	switch (*p) {
		case '-': sign = -1.0;
		case '+': ++p;
		default: break;
	}
	double value = 0.0;
	while ((unsigned int)(*p - '0') < 10U) { value = ((value * 10) + (*p++ - '0')); }
	register double factor;
	if (*p == '.') {
		factor = 1.0;
		++p;
		while ((unsigned int)(*p - '0') < 10U) {
			factor *= 0.1;
			value += ((*p++ - '0') * factor);
		}
	}
	if ((*p | 32) == 'e') {
		register unsigned int expo = 0;
		factor = 10.0;
		switch (*++p) {
			case '-': factor = 0.1;
			case '+': ++p; break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				break;
			default:
				value = 0.0;
				p = s;
				if (endptr != NULL) { *endptr = p; }
				return (double)(value * sign);
		}
		while ((unsigned int)(*p - '0') < 10U) { expo = ((10 * expo) + (unsigned int)(*p++ - '0')); }
		while (1) {
			if (expo & 1) { value *= factor; }
			if ((expo >>= 1) == 0) { break; }
			factor *= factor;
		}
	}
	if (endptr != NULL) { *endptr = p; }
	return (double)(value * sign);
}
#define STRTOD(_string, endptr)   strtod((_string), (endptr))
#define __strtod_l(_string, endptr, locale)   strtod((_string), (endptr))
#define STRTOD_L(_string, endptr, locale)   strtod((_string), (endptr))
#define strtod_l(_string, endptr, locale)   strtod((_string), (endptr))
#define strtod_internal(_string, endptr)   strtod((_string), (endptr))
/** Convert a string to a float */
#define atof(_string)   (double)strtod((_string), 0)
/** Convert a string to a float */
#define _atof(_string)   (double)strtod((_string), 0)
/** Convert a string to a double */
#define atod(_string)   strtod((_string), 0)
/** Convert a string to a double */
#define _atod(_string)   strtod((_string), 0)


LIB_FUNC long double strtox(const char* s, const char** endptr, const UNUSED int prec) {
	return (long double)strtod(s, endptr);
}
#define strtold(_string, endptr)   strtox((_string), (endptr), 0)
#define strtold_internal(_string, endptr)   strtox((_string), (endptr), 0)
#define STRTOLD(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtold_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOLD_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtold_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolQ(_string, endptr)   strtox((_string), (endptr), 0)
#define strtolq(_string, endptr)   strtox((_string), (endptr), 0)
#define STRTOLQ(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtolQ_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define __strtolq_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOLQ_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolQ_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtolq_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOX(_string, endptr)   strtox((_string), (endptr), 0)
#define __strtox_l(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define STRTOX_L(_string, endptr, locale)   strtox((_string), (endptr), 0)
#define strtox_l(_string, endptr, locale)   strtox((_string), (endptr), 0)


/** Convert string to long */
LIB_FUNC long strtol(const char* restrict nptr, const char** restrict endptr, const int _base) {
	const char* p = nptr;
	register long n = 0, nn;
	register int c, v, neg = 0, base = _base;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	if (base == 0) {  // Base
		if (*p != '0') { base = 10; }
		else {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else if (base == 16 && *p == '0') {
		if (p[1] == 'x' || p[1] == 'X') { p += 2; }
	} else if (base < 0 || 36 < base) {
		p = nptr;
		if (endptr) { *endptr = p; }
		return (neg ? (-n) : n);
	}
	register int ovfl = 0, ndig = 0;
	for (;; p++, ndig++) {  // Non-empty sequence of digits
		c = *p;
		v = base;
		if (('0' <= c) && (c <= '9')) { v = c - '0'; }
		else if (('a' <= c) && (c <= 'z')) { v = (c - 'a') + 10; }
		else if (('A' <= c) && (c <= 'Z')) { v = (c - 'A') + 10; }
		if (v >= base) { break; }
		nn = (n * base) + v;
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) {
		if (neg) { return LONG_MIN; }
		return LONG_MAX;
	}
	return (neg ? (-n) : n);
}


LIB_FUNC long strtol_l(const char* restrict nptr, const char** restrict endptr, int base, UNUSED locale_t _lang) {
	return strtol(nptr, endptr, base);
}


/** Convert string to long long */
LIB_FUNC long long strtoll(const char* restrict nptr, const char** restrict endptr, int base) {
	const char* p = nptr;
	register long long n = 0, nn, m;
	register int c, ovfl = 0, v, neg = 0, ndig = 0;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	if (base == 0) {  // Base
		base = 10;
		if (*p == '0') {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
		p += 2;
	} else if (base < 0 || 36 < base) {
		if (ndig == 0) { p = nptr; }
		if (endptr) { *endptr = p; }
		if (ovfl) {
			if (neg) { return VLONG_MIN; }
			return VLONG_MAX;
		} else if (neg) { return -n; }
		return n;
	}
	// Non-empty sequence of digits
	m = (VLONG_MAX / base);
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = (long long)((n * base) + v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) {
		if (neg) { return VLONG_MIN; }
		return VLONG_MAX;
	} else if (neg) { return -n; }
	return n;
}


LIB_FUNC long long strtoll_l(const char* restrict nptr, const char** restrict endptr, int base, UNUSED locale_t _lang) {
	return strtoll(nptr, endptr, base);
}


/** Convert a string to an unsigned long; Ignores locale; Assumes that the upper and lower case alphabets and digits are each contiguous */
LIB_FUNC unsigned long strtoul(const char* restrict nptr, const char** restrict endptr, const int _base) {
	const char* p = nptr;
	register unsigned long n = 0, nn, m;
	register int c, ovfl = 0, neg = 0, v, ndig = 0, base = _base;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	// Base
	if (base == 0) {
		if (*p != '0') { base = 10; }
		else {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') { base = 16; }
		}
	} else if (base < 2 || 36 < base) {
		if (ndig == 0) { p = nptr; }
		if (endptr) { *endptr = p; }
		if (ovfl) { return ULONG_MAX; }
		else if (neg) { return -n; }
		return n;
	}
	if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
		if (('0' <= p[2] && p[2] <= '9') || ('a' <= p[2] && p[2] <= 'f') || ('A' <= p[2] && p[2] <= 'F')) { p += 2; }
	}
	// Non-empty sequence of digits
	n = 0;
	m = (ULONG_MAX / (unsigned long)base);
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = (unsigned long)((n * (unsigned long)base) + (unsigned long)v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) { return ULONG_MAX; }
	else if (neg) { return -n; }
	return n;
}


LIB_FUNC unsigned long strtoul_l(const char* restrict nptr, const char** restrict endptr, int base, UNUSED locale_t _lang) {
	return strtoul(nptr, endptr, base);
}


/** Convert a string to a unsigned long long */
LIB_FUNC unsigned long long strtoull(const char* restrict nptr, const char** restrict endptr, int base) {
	const char* p = nptr;
	register unsigned long long n = 0, nn, m;
	register int c, ovfl = 0, v, neg = 0, ndig = 0;
	while (isspace(*p)) { ++p; }
	if (*p == '+' || *p == '-') { if (*p == '-') { neg = 1; } ++p; }  // Sign
	if (base == 0) {  // Base
		base = 10;
		if (*p == '0') {
			base = 8;
			if (p[1] == 'x' || p[1] == 'X') {
				p += 2;
				base = 16;
			}
		}
	} else {
		if ((base == 16 && *p == '0') && (p[1] == 'x' || p[1] == 'X')) {
			p += 2;
		} else if (base < 0 || 36 < base) {
			if (ndig == 0) { p = nptr; }
			if (endptr) { *endptr = p; }
			if (ovfl) { return UVLONG_MAX; }
			else if (neg) { return -n; }
			return n;
		}
	}
	// Non-empty sequence of digits
	m = UVLONG_MAX / (unsigned long long)base;
	for (;; p++, ndig++) {
		c = *p;
		v = base;
		if ('0' <= c && c <= '9') { v = (c - '0'); }
		else if ('a' <= c && c <= 'z') { v = (c - 'a' + 10); }
		else if ('A' <= c && c <= 'Z') { v = (c - 'A' + 10); }
		if (v >= base) { break; }
		else if (n > m) { ovfl = 1; }
		nn = ((n * (unsigned long long)base) + (unsigned long long)v);
		if (nn < n) { ovfl = 1; }
		n = nn;
	}
	if (ndig == 0) { p = nptr; }
	if (endptr) { *endptr = p; }
	if (ovfl) { return UVLONG_MAX; }
	else if (neg) { return -n; }
	return n;
}


LIB_FUNC unsigned long long strtoull_l(const char* restrict nptr, const char** restrict endptr, int base, UNUSED locale_t _lang) {
	return strtoull(nptr, endptr, base);
}


/** Convert a number string to `uintmax_t` */
LIB_FUNC uintmax_t strntoumax(const char* restrict nptr, const char** restrict endptr, int base, size_t n) {
	while (n && ((((unsigned char)*nptr) == 0x20u) | ((0x8u < ((unsigned char)*nptr)) & (((unsigned char)*nptr) < 0xEu)))) { ++nptr; --n; }
	register int minus = (*nptr == '-');
	if (n && (minus || *nptr == '+')) { ++nptr; --n; }  // Single optional + or -
	if (base == 0) {
		if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) { n -= 2; nptr += 2; base = 16; }  // Hex
		else if ((n >= 1) && (nptr[0] == '0')) { --n; ++nptr; base = 8; }  // Octal
		else { base = 10; }  // Decimal
	} else if (base == 16) {
		if (n >= 2 && nptr[0] == '0' && (nptr[1] == 'x' || nptr[1] == 'X')) { n -= 2; nptr += 2; }  // Hex
	} else if ((base == 8) && (n >= 1) && (nptr[0] == '0')) {  // Octal
		--n; ++nptr;
	}
	register int d;
	register uintmax_t v = 0;
	while (n && ((d = digitval(*nptr)) >= 0) && (d < base)) {
		v = (uintmax_t)(v * (uintmax_t)(base + d));
		--n;
		++nptr;
	}
	if (endptr) { *endptr = nptr; }
	return (uintmax_t)(minus ? (-v) : v);
}


/** Convert a number string to `intmax_t` */
LIB_FUNC intmax_t strntoimax(const char* restrict nptr, const char** restrict endptr, int base, size_t n) {
	return (intmax_t)strntoumax(nptr, endptr, base, n);
}


/** Like `strtol` but convert to `intmax_t` */
LIB_FUNC intmax_t strtoimax(const char* restrict nptr, const char** restrict endptr, const int base) {
	return (intmax_t)strtol(nptr, endptr, base);
}


/** Like `strtoul` but convert to `uintmax_t` */
LIB_FUNC uintmax_t strtoumax(const char* restrict nptr, const char** restrict endptr, const int base) {
	return (uintmax_t)strtoul(nptr, endptr, base);
}


/** Convert an integer to a string */
LIB_FUNC char* uintmaxtostr(const signed long _num, char b[]) {
	register signed long i = _num;
	char* p = b;
	if (i < 0) { *p++ = '-'; i *= (-1); }
	register unsigned long shifter = (unsigned long)i;
	do {  // Move to representation ending
		++p;
		shifter /= 10;
	} while (shifter);
	*p = '\0';
	do {  // Move back, inserting digits
		*--p = digits[i % 10];
		i /= 10;
	} while (i);
	return b;
}
#define _uintmaxtostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define _int10tostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define _inttostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define inttostr(bufend, intval)   uintmaxtostr((intval), (bufend))
#define int2str(bufend, intval)   uintmaxtostr((intval), (bufend))


LIB_FUNC unsigned int char2uint(const char* cnum) {
	return (unsigned int)strtol(cnum, (const char**)NULL, 10);
}


/** Convert a string into an integer of type intmax_t; Allow trailing spaces */
LIB_FUNC intmax_t atomax(const char* s, int base) {
	const char** restrict p;
	errno = 0;
	register const intmax_t r = strtoimax(s, p, base);
	if (errno != 0 || (size_t)p == (size_t)(s && base)) { abort(); }
	while (isspace((unsigned char)**p)) { p++; }
	if (**p) { abort(); }
	return r;
}


LIB_FUNC intmax_t atomax2(const char* s) {
	return atomax(s, 2);
}


LIB_FUNC intmax_t atomax8(const char* s) {
	return atomax(s, 8);
}


LIB_FUNC intmax_t atomax10(const char* s) {
	return atomax(s, 10);
}


/** Convert a string of digits to an integer, printing an error message on failure */
LIB_FUNC int number(const char* s) {
	const intmax_t n = atomax(s, 10);
	if (n < 0 || n > INT_MAX) { abort(); }
	return (int)n;
}


// BSEARCH FUNCTIONS

/** Searches the given key in the array pointed to by base (which is formed by nmemb elements, each of size bytes), and returns a void* pointer to a matching element, if found */
LIB_FUNC void* bsearch(const void* key, const void* base, const size_t nmemb, size_t size, int (*compar)(const void*, const void*)) {
	register long i, bot = 0, top, new;
	void* p;
	top = (long)(bot + (long)(nmemb - 1));
	while (bot <= top) {
		new = (long)((top + bot) / 2L);
		p = (char*)(&base + (((size_t)new) * size));
		i = (long)((int)((*compar)(key, p)));
		if (i == 0) { return p; }
		else if (i > 0) { bot = new + 1; }
		else { top = new - 1; }
	}
	return 0;
}
#define xbsearch(key, base, nmemb, size, func)   bsearch((key), (base), (nmemb), (size), (func))


LIB_FUNC Rune* _runebsearch(Rune c, Rune* t, int n, const int ne) {
	Rune* p;
	register int m;
	while (n > 1) {
		m = n / 2;
		p = (t + (m * ne));
		if (c >= p[0]) {
			t = p;
			n = n - m;
		} else { n = m; }
	}
	if (n && c >= t[0]) { return t; }
	return 0;
}


LIB_FUNC int pntz(size_t p[2]) {
	register int r = ntz(p[0] - 1);
	if (r != 0 || (r = (BITS_PER_SIZE_T + ntz(p[1]))) != BITS_PER_SIZE_T) { return r; }
	return 0;
}


LIB_FUNC void cycle(const size_t width, unsigned char* ar[], const int n) {
	if (n < 2) { return; }
	unsigned char tmp[256] = { 0 };
	ar[n] = tmp;
	register int i;
	register size_t l, len = width;
	while (len) {
		l = (sizeof(tmp) < len ? sizeof(tmp) : len);
		memcpy_no_output(ar[n], ar[0], l);
		for (i = 0; i < n; i++) { memcpy_no_output(ar[i], ar[i + 1], l); ar[i] += l; }
		len -= l;
	}
}


LIB_FUNC void shl(size_t p[2], int n) {
	if (n >= BITS_PER_SIZE_T) {
		n -= BITS_PER_SIZE_T;
		p[1] = p[0];
		p[0] = 0;
	}
	p[1] <<= n;
	p[1] |= p[0] >> (BITS_PER_SIZE_T - n);
	p[0] <<= n;
}


LIB_FUNC void shr(size_t p[2], int n) {
	if (n >= BITS_PER_SIZE_T) {
		n -= BITS_PER_SIZE_T;
		p[0] = p[1];
		p[1] = 0;
	}
	p[0] >>= (size_t)n;
	p[0] |= (size_t)(p[1] << (BITS_PER_SIZE_T - n));
	p[1] >>= (size_t)n;
}


LIB_FUNC void sift(unsigned char* _head, const size_t width, cmpfun cmp, int pshift, size_t lp[]) {
	unsigned char *rt, *lf;
	unsigned char* ar[(14 * SIZEOF_SIZE_T) + 1] = { 0 };
	register int i = 1;
	ar[0] = _head;
	while (pshift > 1) {
		rt = (_head - width);
		lf = rt - lp[pshift - 2];
		if ((*cmp)(ar[0], lf) >= 0 && (*cmp)(ar[0], rt) >= 0) { break; }
		else if ((*cmp)(lf, rt) >= 0) {
			ar[i++] = lf;
			_head = lf;
			pshift -= 1;
		} else {
			ar[i++] = rt;
			_head = rt;
			pshift -= 2;
		}
	}
	cycle(width, ar, i);
}


LIB_FUNC void trinkle(unsigned char* _head, const size_t width, cmpfun cmp, size_t pp[2], int pshift, int trusty, size_t lp[]) {
	unsigned char *stepson, *rt, *lf;
	size_t p[2] = { 0 };
	unsigned char* ar[14 * SIZEOF_SIZE_T + 1];
	register int i = 1, trail;
	p[0] = pp[0];
	p[1] = pp[1];
	ar[0] = _head;
	while (p[0] != 1 || p[1] != 0) {
		stepson = _head - lp[pshift];
		if ((*cmp)(stepson, ar[0]) <= 0) { break; }
		else if (!trusty && pshift > 1) {
			rt = (_head - width);
			lf = rt - lp[pshift - 2];
			if ((*cmp)(rt, stepson) >= 0 || (*cmp)(lf, stepson) >= 0) { break; }
		}
		ar[i++] = stepson;
		_head = stepson;
		trail = pntz(p);
		shr(p, trail);
		pshift += trail;
		trusty = 0;
	}
	if (!trusty) { cycle(width, ar, i); sift(_head, width, cmp, pshift, lp); }
}


LIB_FUNC void qsort(void* base, const size_t nel, const size_t width, cmpfun cmp) {
	size_t lp[12 * SIZEOF_SIZE_T] = { 0 };
	register size_t i, size = width * nel;
	unsigned char *_head, *high;
	size_t p[2] = {1, 0};
	register int pshift = 1, trail;
	if (!size) { return; }
	_head = base;
	high = ((_head + size) - width);
	// Precompute Leonardo numbers, scaled by element width
	for (lp[0] = lp[1] = width, i = 2; (lp[i] = (lp[i - 2] + lp[i - 1] + width)) < size; i++);
	while (_head < high) {
		if ((p[0] & 3) == 3) {
			sift(_head, width, cmp, pshift, lp);
			shr(p, 2);
			pshift += 2;
		} else {
			if (lp[pshift - 1] >= (size_t)(high - _head)) { trinkle(_head, width, cmp, p, pshift, 0, lp); }
			else { sift(_head, width, cmp, pshift, lp); }
			if (pshift == 1) { shl(p, 1); pshift = 0; }
			else { shl(p, pshift - 1); pshift = 1; }
		}
		p[0] |= 1;
		_head += width;
	}
	trinkle(_head, width, cmp, p, pshift, 0, lp);
	while (pshift != 1 || p[0] != 1 || p[1] != 0) {
		if (pshift <= 1) {
			trail = pntz(p);
			shr(p, trail);
			pshift += trail;
		} else {
			shl(p, 2);
			pshift -= 2;
			p[0] ^= 7;
			shr(p, 1);
			trinkle((_head - lp[pshift] - width), width, cmp, p, (pshift + 1), 1, lp);
			shl(p, 1);
			p[0] |= 1;
			trinkle((_head - width), width, cmp, p, pshift, 1, lp);
		}
		_head -= width;
	}
}


// ENVIRONMENT FUNCTIONS

/** Returns the PID of the current process */
LIB_FUNC pid_t getpid(void) {
	return (pid_t)__syscall0(SYS_getpid);
}


/** Returns the UID of the current process */
LIB_FUNC uid_t getuid(void) {
	return (uid_t)__syscall0(SYS_getuid);
}


/** Returns the process group ID of the process whose process ID is equal to `pid`, or if `pid` is equal to zero, getpgid() returns the process group ID of the calling process */
LIB_FUNC pid_t getpgid(const pid_t pid) {
	return (pid_t)__syscall1(SYS_getpgid, (long)pid);
}


/** Sets the SID of the current process */
LIB_FUNC pid_t setsid(void) {
	return (pid_t)__syscall0(SYS_setsid);
}


/** Determine if the str is in an environment string; Return 0 if the name is not valid */
LIB_FUNC size_t envvarnamelen(const char* str, const bool withequal) {
	if (str == NULL) { return 0; }
	register size_t l_name = strcspn(str, "=");
	if (l_name == 0) { return 0; }
	else if (withequal) { if (str[l_name] != '=') { return 0; } }
	else if (str[l_name] == '=') { return 0; }
	return l_name;
}
#define __envvarnamelen(str, withequal)   envvarnamelen((str), (withequal))


LIB_FUNC int clearenv(void) {
	__environ[0] = 0;
	return 0;
}


/** Returns an environment variable given by `name` */
LIB_FUNC const char* getenv(const char* restrict name) {
	register int i;
	register size_t l = strlen(name);
	if ((!__environ) || !(*name) || strchr(name, '=')) { return NULL; }
	for (i = 0; __environ[i] && (strncmp(name, __environ[i], l) || __environ[i][l] != '='); i++);
	if (__environ[i]) { return (__environ[i] + l + 1); }
	return NULL;
}


LIB_FUNC int unsetenv(const char* name) {
	if (!*name || (strchr(name, '='))) { errno = EINVAL; return -1; }
	register int i, j;
	register size_t l = strlen(name);
unsetenv_again:
	for (i = 0; __environ[i] && (memcmp(name, __environ[i], l) || __environ[i][l] != '='); i++);
	if (__environ[i]) {
		if (__env_map) {
			for (j = 0; __env_map[j] && __env_map[j] != __environ[i]; j++);
			free(__env_map[j]);
			for (; __env_map[j]; j++) { __env_map[j] = __env_map[j + 1]; }
		}
		for (; __environ[i]; i++) { __environ[i] = __environ[i + 1]; }
		goto unsetenv_again;
	}
	return 0;
}


LIB_FUNC int __putenv(char* s, const int a) {
	const char* z = (const char*)strchr(s, '=');
	if (!z) { return unsetenv(s); }
	else if (z == s) { return -1; }
	register int i = 0, j = 0;
	for (; __environ[i] && memcmp(s, __environ[i], (size_t)((size_t)(z - s) + 1)); i++);
	char** newmap = 0;
	if (a) {
		if (!__env_map) {
			__env_map = calloc(2, SIZEOF_POINTER);
			if (__env_map) { __env_map[0] = s; }
		} else {
			for (; __env_map[j] && __env_map[j] != __environ[i]; j++);
			if (!__env_map[j]) {
				newmap = realloc(__env_map, (size_t)(SIZEOF_POINTER * (size_t)(j + 2)));
				if (newmap) {
					__env_map = newmap;
					__env_map[j] = s;
					__env_map[j + 1] = NULL;
				}
			} else { free(__env_map[j]); }
		}
	}
	static char** oldenv;
	char** newenv = 0;
	if (!__environ[i]) {
		newenv = malloc((size_t)(SIZEOF_POINTER * (size_t)(i + 2)));
		if (!newenv) {
			if (a && __env_map) __env_map[j] = 0;
			return -1;
		}
		memcpy_no_output(newenv, __environ, (size_t)(SIZEOF_POINTER * (size_t)i));
		newenv[i] = s;
		newenv[i + 1] = 0;
		__environ = newenv;
		free(oldenv);
		oldenv = __environ;
	}
	__environ[i] = s;
	return 0;
}
#define putenv(_str)   ((int)__putenv(_str, 0))


LIB_FUNC int setenv(const char* var, const char* value, const int overwrite) {
	if (!var || !(*var) || strchr(var, '=')) { errno = EINVAL; return -1; }
	else if (!overwrite && getenv(var)) { return 0; }
	register size_t l1 = strlen(var), l2 = strlen(value);
	char* s;
	s = malloc(l1 + l2 + 2);
	if (s) {
		memcpy_no_output(s, var, l1);
		s[l1] = '=';
		memcpy_no_output((s + l1 + 1), value, l2);
		s[l1 + l2 + 1] = 0;
		if (!(__putenv(s, 1))) { return 0; }
	}
	free(s);
	return -1;
}


/* RANDOM (<sys/random.h>) */


#if (!(defined(_RANDOM_H) || defined(_RANDOM_H_) || defined(_SYS_RANDOM_H) || defined(_SYS_RANDOM_H_)))
#define RANDOM_H   (1)
#define _RANDOM_H   (1)
#define _RANDOM_H_   (1)
#define SYS_RANDOM_H   (1)
#define _SYS_RANDOM_H   (1)
#define _SYS_RANDOM_H_   (1)
#define RAND48_H   (1)
#define _RAND48_H_   (1)


/** Do not block; return EAGAIN instead */
#define GRND_NONBLOCK   1
/** Use the /dev/random pool instead of /dev/urandom */
#define GRND_RANDOM   2


typedef struct arc4_stream { uint8_t i, j; uint8_t s[256]; }   arc4_stream_t;


/** Data structure for communication with thread safe versions */
struct drand48_data {
	unsigned short __x[3];   // Current state
	unsigned short __old_x[3];   // Old state
	unsigned short __c;   // Additive const. in congruential formula
	unsigned short __init;   // Flag for initializing
	unsigned long long __a;   // Factor in congruential formula
};


static UNUSED int rand_n = 31;
static UNUSED int rand_i = 3;
static UNUSED int rand_j = 0;
static UNUSED pid_t arc4_stir_pid;
static UNUSED int arc4_count;
static UNUSED struct arc4_stream rs;
static UNUSED uint64_t seed = 7385;
static UNUSED unsigned short __seed48[8] = { 0, 0, 0, 0xe66d, 0xdeec, 5, 0xb };
static UNUSED smallint rs_initialized;
/** Global state for non-reentrant functions */
struct UNUSED drand48_data __libc_drand48_data;
static UNUSED uint32_t rand_init[32] = {
	0, 0x5851f42d, 0xc0b18ccf, 0xcbb5f646,
	0xc7033129, 0x30705b04, 0x20fd5db4, 0x9a8b7f78,
	0x502959d8, 0xab894868, 0x6c0356a7, 0x88cdb7ff,
	0xb477d43f, 0x70a3a52b, 0xa8e4baf1, 0xfd8341fc,
	0x8ae16fd9, 0x742d2f7a, 0x0d1f0796, 0x76035e09,
	0x40f7702c, 0x6fa72ca5, 0xaaa84157, 0x58a0df74,
	0xc74a0364, 0xae533cc4, 0x04185faf, 0x6de3b115,
	0xcab8628, 0xf043bfa4, 0x398150e9, 0x37521657
};
static UNUSED uint32_t* rand_x = (rand_init + 1);


#define lcg31(x)   ((1103515245 * (uint32_t)(x) + 12345) & 0x7fffffff)
#define lcg64(x)   (6364136223846793005ULL * (uint64_t)(x) + 1)


LIB_FUNC void __srandom(const unsigned int seed) {
	register uint64_t s = (seed + (unsigned int)getpid()) * (unsigned int)HP_TIMING();
	if (rand_n == 0) {
		rand_x[0] = (uint32_t)s;
		return;
	}
	rand_i = ((rand_n == 31 || rand_n == 7) ? 3 : 1);
	rand_j = 0;
	register int k;
	for (k = 0; k < rand_n; k++) {
		s = lcg64(s);
		rand_x[k] = (uint32_t)(s >> 32);
	}
	rand_x[0] |= (uint32_t)1;
}


LIB_FUNC void srandom(const unsigned int seed) {
	__lock(lock);
	__srandom(seed);
	__unlock(lock);
}


LIB_FUNC void loadstate(uint32_t* _state) {
	rand_x = (_state + 1);
	rand_n = (int)(rand_x[-1] >> 16);
	rand_i = (int)((rand_x[-1] >> 8) & 0xff);
	rand_j = (int)(rand_x[-1] & 0xff);
}


LIB_FUNC void* savestate(void) {
	rand_x[-1] = (uint32_t)((rand_n << 16) | (rand_i << 8) | rand_j);
	return (rand_x - 1);
}


LIB_FUNC char* initstate(const unsigned int seed, char* _state, const size_t size) {
	void* old;
	if (size < 8) { return 0; }
	__lock(lock);
	old = savestate();
	if (size < 32) { rand_n = 0; }
	else if (size < 64) { rand_n = 7; }
	else if (size < 128) { rand_n = 15; }
	else if (size < 256) { rand_n = 31; }
	else { rand_n = 63; }
	rand_x = (uint32_t*)_state + 1;
	__srandom(seed);
	savestate();
	__unlock(lock);
	return old;
}


LIB_FUNC char* setstate(char* _state) {
	void* old;
	__lock(lock);
	old = savestate();
	loadstate((uint32_t*)_state);
	__unlock(lock);
	return old;
}


LIB_FUNC unsigned int temper(unsigned int x) {
	x ^= (unsigned int)(x >> 11);
	x ^= (unsigned int)((x << 7) & 0x9D2C5680);
	x ^= (unsigned int)((x << 15) & 0xEFC60000);
	x ^= (unsigned int)(x >> 18);
	return x;
}


LIB_FUNC int lcong48_r(const unsigned short param[7], struct drand48_data* buffer) {
	memcpy_no_output(buffer->__x, &param[0], sizeof(buffer->__x));
	buffer->__a = ((uint64_t)param[5] << 32 | (uint32_t)param[4] << 16 | param[3]);
	buffer->__c = param[6];
	buffer->__init = 1;
	return 0;
}
#define __lcong48_r(param, buffer)   lcong48_r((param), (buffer))


LIB_FUNC void lcong48(const unsigned short param[7]) {
	(void)lcong48_r(param, &__libc_drand48_data);
}


LIB_FUNC uint64_t __rand48_step(unsigned short* xi, unsigned short* lc) {
	const uint64_t a = (uint64_t)(lc[0] | ((lc[1] + 0U) << 16) | ((lc[2] + 0ULL) << 32));
	const uint64_t x = a * (uint64_t)(xi[0] | ((xi[1] + 0U) << 16) | ((xi[2] + 0ULL) << 32)) + lc[3];
	xi[0] = (unsigned short)x;
	xi[1] = (unsigned short)(x >> 16);
	xi[2] = (unsigned short)(x >> 32);
	return (uint64_t)(x & 0xffffffffffffULL);
}


/** Returns a non-negative long integer uniformly distributed over the interval [0, 2^31] */
LIB_FUNC long nrand48(unsigned short s[3]) {
	return (long)(__rand48_step(s, (__seed48 + 3)) >> 17);
}


/** Returns a non-negative long integer uniformly distributed over the interval [0, 2^31] */
LIB_FUNC long lrand48(void) {
	return nrand48(__seed48);
}


LIB_FUNC unsigned short* seed48(unsigned short* s) {
	static unsigned short p[3] = { 0 };
	memcpy_no_output(p, __seed48, sizeof(p));
	memcpy_no_output(__seed48, s, sizeof(p));
	return p;
}


/** Returns a pseudo-random integral number */
LIB_FUNC long random(void) {
	rand_x[((rand_i + (int)getpid()) % 32)] += rand_x[((rand_j ^ (int)HP_TIMING()) % 32)];
	if (++rand_i == rand_n) { rand_i = 0; }
	if (++rand_j == rand_n) { rand_j = 0; }
	register long x = ((long)rand_x[((rand_j + (int)HP_TIMING()) % 32)]) - (long)HP_TIMING();
	register long t = ((16807 * (x % 127773)) - (2836 * (long)(x / 127773)));
	if (t < 0) { return ((long)t * -1L); }
	return (long)t;
}


/** Initialize random number generator */
LIB_FUNC void srand48(const long seed) {
	register const long tmppid = ((long)getpid() * (long)HP_TIMING());
	seed48((unsigned short [3]) { (unsigned short)HP_TIMING(), (unsigned short)(seed - tmppid), (unsigned short)(seed >> 16) });
}


/** Initialize random number generator */
LIB_FUNC void srand(const unsigned int s) {
	srand48((long)s);
}


/** Returns a pseudo-random integral number in the range between 0 and RAND_MAX */
LIB_FUNC int rand(void) {
	register const uint64_t tmppid = ((uint64_t)getpid() * (uint64_t)HP_TIMING());
	seed = (uint64_t)(6364136223846793005ULL * seed + tmppid);
	const int result = (((int)(seed >> 33)) + (int)tmppid);
	if (result < 0) { return (result * -1); }
	return result;
}
/** Returns a pseudo-random integral number in the range between 0 and 100 */
#define rand100()   ((int)(rand() % 100))


LIB_FUNC int rand_r(unsigned int* seed) {
	return (int)(temper(*seed = (*seed * 1103515245) + 12345) >> 1);
}


LIB_FUNC int __drand48_iterate(unsigned short xsubi[3], struct drand48_data* buffer) {
	if (PREDICT_UNLIKELY(!buffer->__init)) {
		buffer->__a = 0x5deece66dULL;
		buffer->__c = 0xb;
		buffer->__init = 1;
	}
	const uint64_t drand48_X = (uint64_t)xsubi[2] << 32 | (uint32_t)xsubi[1] << 16 | xsubi[0];
	const uint64_t result = (uint64_t)(drand48_X * buffer->__a + buffer->__c);
	xsubi[0] = (unsigned short)(result & 0xffff);
	xsubi[1] = (unsigned short)((result >> 16) & 0xffff);
	xsubi[2] = (unsigned short)((result >> 32) & 0xffff);
	return 0;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC int erand48_r(unsigned short xsubi[3], struct drand48_data* buffer, double* result) {
	if (__drand48_iterate(xsubi, buffer) < 0) { return -1; }
	union ieee754_double temp;
	temp.ieee.negative = 0;
	temp.ieee.exponent = IEEE754_DOUBLE_BIAS;
	temp.ieee.mantissa0 = ((unsigned short)(xsubi[2] << 4) | (unsigned short)(xsubi[1] >> 12));
	temp.ieee.mantissa1 = ((unsigned int)(((xsubi[1] & 0xfff) << 20) | (xsubi[0] << 4)));
	*result = temp.d - 1.0;
	return 0;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC double erand48(unsigned short xsubi[3]) {
	double result;
	(void)erand48_r(xsubi, &__libc_drand48_data, &result);
	return result;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC double drand48(void) {
	double result;
	(void)erand48_r(__libc_drand48_data.__x, &__libc_drand48_data, &result);
	return result;
}


/** Returns a non-negative double uniformly distributed over the interval [0.0, 1.0) */
LIB_FUNC int drand48_r(struct drand48_data* buffer, double* result) {
	return erand48_r(buffer->__x, buffer, result);
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
LIB_FUNC int jrand48_r(unsigned short xsubi[3], struct drand48_data* buffer, long* result) {
	if (__drand48_iterate(xsubi, buffer) < 0) { return -1; }
	*result = ((xsubi[2] << 16) | xsubi[1]) & 0xffffffffl;
	return 0;
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
LIB_FUNC long jrand48(unsigned short xsubi[3]) {
	long result;
	(void)jrand48_r(xsubi, &__libc_drand48_data, &result);
	return result;
}


/** Returns a signed long integer uniformly distributed over the interval [-2^31 , 2^31] */
#define mrand48()   (long)jrand48(__seed48)


LIB_FUNC void arc4_init(struct arc4_stream* as) {
	register int n;
	for (n = 0; n < 256; n++) { as->s[n] = (uint8_t)n; }
	as->i = 0;
	as->j = 0;
}


LIB_FUNC uint8_t arc4_getbyte(struct arc4_stream* as) {
	uint8_t si, sj;
	as->i = (uint8_t)(as->i + 1);
	si = as->s[as->i];
	as->j = (uint8_t)(as->j + si);
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (uint8_t)(as->s[(si + sj) & 0xff]);
}


LIB_FUNC void arc4_addrandom(struct arc4_stream* as, uchar* dat, const int datlen) {
	register int n;
	register uint8_t si;
	as->i--;
	for (n = 0; n < 256; n++) {
		as->i = (uint8_t)(as->i + 1);
		si = as->s[as->i];
		as->j = (uint8_t)(as->j + si + dat[n % datlen]);
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
	}
	as->j = as->i;
}


LIB_FUNC void arc4_stir(struct arc4_stream* as) {
	int n;
	unsigned char rnd[128] = { 0 };
	struct timeval tv;
#   ifndef __ARC4RANDOM_USES_NODEV__
	const int fd = open("/dev/urandom", O_RDONLY);
	if (fd != -1) { read(fd, rnd, sizeof(rnd)); close(fd); }
	else
#   endif
	if (gettimeofday(&tv, NULL) != (-1)) {
		rnd[0] = (unsigned char)((tv.tv_sec % 10000) * 3 + tv.tv_usec * 7 + (getpid() % 1000) * 13);
		for (n = 1; n < 127 ; n++) {
			if (rnd[n] == 0) { rnd[n] = (unsigned char)((rnd[n - 1] + n) ^ ((getpid() % 1000) * 17)); }
		}
	} else {
		rnd[0] = (unsigned char)((getpid() % 1000) * 19);
		for (n = 1; n < 127 ; n++) {
			if (rnd[n] == 0) { rnd[n] = (unsigned char)((rnd[n - 1] + n) ^ ((getpid() % 1000) * 23)); }
		}
	}
	arc4_stir_pid = getpid();
	arc4_addrandom(as, rnd, sizeof(rnd));
	for (n = 0; n < 256; n++) { (void)arc4_getbyte(as); }
	arc4_count = 1600000;
}


LIB_FUNC void arc4random_stir(void) {
	if (!rs_initialized) { arc4_init(&rs); rs_initialized = 1; }
	arc4_stir(&rs);
}
#define __arc4random_stir()   arc4random_stir()


LIB_FUNC uint8_t __arc4_getbyte(void) {
	if (--arc4_count == 0 || (!rs_initialized)) { arc4random_stir(); }
	return arc4_getbyte(&rs);
}


LIB_FUNC uint32_t arc4_getword(struct arc4_stream* as) {
	uint32_t val = (uint32_t)(arc4_getbyte(as) << 24);
	val |= (uint32_t)(arc4_getbyte(as) << 16);
	val |= (uint32_t)(arc4_getbyte(as) << 8);
	val |= (uint32_t)arc4_getbyte(as);
	return val;
}


LIB_FUNC void arc4random_addrandom(uchar* dat, int datlen) {
	if (!rs_initialized) { arc4random_stir(); }
	arc4_addrandom(&rs, dat, datlen);
}


/** Returns a single random 32-bit value */
LIB_FUNC uint32_t arc4random(void) {
	arc4_count -= 4;
	if (arc4_count <= 0 || (!rs_initialized) || arc4_stir_pid != getpid()) { arc4random_stir(); }
	return arc4_getword(&rs);
}
#define rk_random()   arc4random()


LIB_FUNC char* randname(char* template) {
	register int i;
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	register unsigned long r = (unsigned long)(((unsigned long)(ts.tv_nsec * 65537) ^ (unsigned long)((unsigned long)&ts >> 4)) + (unsigned long)template);
	for (i = 0; i < 6; i++, r >>= 5) { template[i] = (char)('A' + (r & 15) + (r & 16) * 2); }
	return template;
}
#define __randname(template)   randname((template))


#endif  // SYS_RANDOM_H


// MISCELLANEOUS STDLIB FUNCTIONS


/** Creates a pipe, a unidirectional data channel that can be used for interprocess communication */
LIB_FUNC int pipe(int fd[2]) {
#ifdef SYS_pipe
	return (int)__syscall1(SYS_pipe, (long)fd);
#else
	return (int)__syscall2(SYS_pipe2, fd, 0);
#endif
}


/** Creates a pipe, a unidirectional data channel that can be used for interprocess communication */
LIB_FUNC int pipe2(int fd[2], int flag) {
	if (!flag) { return pipe(fd); }
	int ret = (int)__syscall(SYS_pipe2, (long)&fd, flag);
	if (ret != (-ENOSYS)) { return (int)__syscall_ret((unsigned long)ret); }
	ret = pipe(fd);
	if (ret) { return ret; }
	if (flag & O_CLOEXEC) {
		__syscall(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
		__syscall(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
	}
	if (flag & O_NONBLOCK) {
		__syscall(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
		__syscall(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
	}
	return 0;
}


/** Creates a new process by duplicating the calling process */
LIB_FUNC pid_t fork(void) {
	pid_t ret;
	sigset_t set;
	__block_all_sigs(&set);
#ifdef SYS_fork
	ret = (pid_t)syscall(SYS_fork);
#else
	ret = (pid_t)syscall(SYS_clone, SIGCHLD, 0);
#endif
	if (!ret) {
		struct pthread* self = __pthread_self();
		self->tid = (pid_t)__syscall(SYS_gettid);
		self->robust_list.off = 0;
		self->robust_list.pending = 0;
		libc.threads_minus_1 = 0;
	}
	__restore_sigs(&set);
	return ret;
}


/** Create a child process and block parent */
LIB_FUNC pid_t vfork(void) {
#ifdef SYS_fork
	return (pid_t)syscall(SYS_fork);
#else
	return (pid_t)syscall(SYS_clone, SIGCHLD, 0);
#endif
}
#define __vfork()   vfork()


/** Open a master pseudo terminal and return its file descriptor */
LIB_FUNC int getpt(void) {
	char buf[sizeof(_PATH_PTY) + 2] = { 0 };
	const char *p, *q;
	char* s = mempcpy(buf, _PATH_PTY, (sizeof(_PATH_PTY) - 1));
	s[2] = '\0';
	register int fd;
	for (p = __libc_ptyname1; *p != '\0'; ++p) {
		s[0] = *p;
		for (q = __libc_ptyname2; *q != '\0'; ++q) {
			s[1] = *q;
			fd = open(buf, O_RDWR);
			if (fd != -1) { return fd; }
			else if (errno == ENOENT) { return -1; }
		}
	}
	__set_errno(ENOENT);
	return -1;
}
#define __getpt()   getpt()
#define _getpt()   getpt()


LIB_FUNC noreturn void error(const int exit_val, const int errno_val, const char* s) {
	if (s == NULL) { s = ""; }
	const char* separator;
	if (*s == '\0') { separator = ""; }
	else { separator = ": "; }
	char buf[NL_TEXTMAX] = { 0 };
	(void)strerror(errno_val);
	(void)fprintf(stderr, "%s%s%s\n", s, separator, buf);
	_Exit(exit_val);
}
#define exit_on_error(msg)   error(EXIT_FAILURE, errno, (msg))


/** Return the unique identifier of the current host */
LIB_FUNC long gethostid(void) {
	return 0;
}


LIB_FUNC int getdomainname(char* name, const size_t len) {
	struct utsname temp;
	uname(&temp);
	if (!len || strlen(temp.domainname) >= len) { errno = EINVAL; return -1; }
	strcpy(name, temp.domainname);
	return 0;
}


LIB_FUNC int setdomainname(const char* name, const size_t len) {
	return (int)syscall(SYS_setdomainname, (long)&name, len);
}


/** Return a string naming the current system in the character array utsname */
LIB_FUNC int uname(struct utsname* uts) {
	return (int)syscall(SYS_uname, (long)&uts);
}


/** Open a pseudoterminal device */
LIB_FUNC int posix_openpt(const int flags) {
	return open("/dev/ptmx", flags);
}


/** Changes the mode and owner of the slave pseudoterminal device corresponding to the master pseudoterminal referred to by fd */
LIB_FUNC int grantpt(const int fd) {
	return ioctl(fd, TIOCGRANTPT, 0);
}


LIB_FUNC int unlockpt(const int fd) {
	int unlock = 0;
	return ioctl(fd, TIOCSPTLCK, &unlock);
}


LIB_FUNC int ptsname_r(const int fd, char* buf, size_t len) {
	int pty, err;
	if (!buf) { len = 0; }
	if ((err = (int)syscall(SYS_ioctl, fd, TIOCGPTN, (long)&pty))) { return -err; }
	else if (snprintf(buf, len, "/dev/pts/%d", pty) >= (int)len) { return ERANGE; }
	return 0;
}
#define __ptsname_r(fd, buf, len)   ptsname_r((fd), (buf), (len))


LIB_FUNC char* ptsname(int fd) {
	static char buf[10 + (SIZEOF_INT * 3)] = { 0 };
	register int err = ptsname_r(fd, buf, sizeof(buf));
	if (err) { errno = err; return 0; }
	return buf;
}


/** Duplicate FD to FD2, closing the old FD2 and making FD2 be open the same file as FD; Return FD2 or -1 */
LIB_FUNC int dup2(const int fd, const int fd2) {
	if (fd < 0 || fd2 < 0) {
		__set_errno(EBADF);
		return -1;
	}
	if (fd == fd2) { return fd2; }
	__set_errno (ENOSYS);
	return -1;
}
#define __dup2(fd, fd2)   dup2((fd), (fd2))
#define sys_dup2(fd, fd2)   dup2((fd), (fd2))
#define __sys_dup2(fd, fd2)   dup2((fd), (fd2))


LIB_FUNC int login_tty(const int fd) {
	setsid();
	if (ioctl(fd, TIOCSCTTY, (char*)0)) { return -1; }
	dup2(fd, 0);
	dup2(fd, 1);
	dup2(fd, 2);
	if (fd > 2) { close(fd); }
	return 0;
}


LIB_FUNC int openpty(int* pm, int* ps, char* name, const struct termios* tio, const struct winsize* ws) {
	int m = open("/dev/ptmx", (int)(O_RDWR | O_NOCTTY));
	if (m < 0) { return -1; }
	int cs, s, n = 0;
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	char buf[20] = { 0 };
	if (ioctl(m, TIOCSPTLCK, &n) || ioctl(m, (int)TIOCGPTN, &n)) { goto openpty_fail; }
	if (!name) { name = buf; }
	snprintf(name, sizeof(buf), "/dev/pts/%d", n);
	if ((s = open(name, (int)(O_RDWR | O_NOCTTY))) < 0) { goto openpty_fail; }
	if (tio) { tcsetattr(s, TCSANOW, tio); }
	if (ws) { ioctl(s, TIOCSWINSZ, ws); }
	*pm = m;
	*ps = s;
	pthread_setcancelstate(cs, 0);
	return 0;
openpty_fail:
	close(m);
	pthread_setcancelstate(cs, 0);
	return -1;
}


LIB_FUNC int forkpty(int* pm, char* name, const struct termios* tio, const struct winsize* ws) {
	int m, s, ec = 0, p[2], cs;
	if (openpty(&m, &s, name, tio, ws) < 0) { return -1; }
	sigset_t set, oldset;
	sigfillset(&set);
	pthread_sigmask(SIG_BLOCK, &set, &oldset);
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	pid_t pid = -1;
	if (pipe2(p, O_CLOEXEC)) {
		close(s);
		if (pid > 0) { *pm = m; }
		else { close(m); }
		pthread_setcancelstate(cs, 0);
		pthread_sigmask(SIG_SETMASK, &oldset, 0);
		return pid;
	}
	pid = fork();
	if (!pid) {
		close(m);
		close(p[0]);
		if (login_tty(s)) { write(p[1], &errno, SIZEOF_ERRNO); _exit(127); }
		close(p[1]);
		pthread_setcancelstate(cs, 0);
		pthread_sigmask(SIG_SETMASK, &oldset, 0);
		return 0;
	}
	close(s);
	close(p[1]);
	if (read(p[0], &ec, SIZEOF_INT) > 0) {
		int status;
		waitpid(pid, &status, 0);
		pid = -1;
		errno = ec;
	}
	close(p[0]);
	if (pid > 0) { *pm = m; }
	else { close(m); }
	pthread_setcancelstate(cs, 0);
	pthread_sigmask(SIG_SETMASK, &oldset, 0);
	return pid;
}


LIB_FUNC char* getcwd(char* buf, size_t size) {
	char tmp[PATH_MAX] = { 0 };
	if (!buf) {
		buf = tmp;
		size = PATH_MAX;
	} else if (!size) {
		errno = EINVAL;
		return 0;
	}
	if (syscall(SYS_getcwd, buf, size) < 0) { return 0; }
	return (buf == tmp ? strdup(buf) : buf);
}


LIB_FUNC char* get_current_dir_name(void) {
	struct stat a, b;
	const char* res = getenv("PWD");
	if (res && *res && (!stat(res, &a)) && (!stat(".", &b)) && (a.st_dev == b.st_dev) && (a.st_ino == b.st_ino)) { return strdup(res); }
	return getcwd(0, 0);
}


/** Checks whether the calling process can access the file pathname */
LIB_FUNC int access(const char* filename, const int amode) {
#ifdef SYS_access
	return (int)syscall(SYS_access, (long)&filename, amode);
#else
	return (int)syscall(SYS_faccessat, AT_FDCWD, (long)&filename, amode, 0);
#endif
}


LIB_FUNC void procfdname(char* buf, unsigned int fd) {
	register unsigned int i, j;
	for (i = 0; (buf[i] = "/proc/self/fd/"[i]); i++);
	if (!fd) {
		buf[i] = '0';
		buf[i + 1] = 0;
		return;
	}
	for (j = fd; j; j /= 10, i++);
	buf[i] = 0;
	for (; fd; fd /= 10) { buf[--i] = (char)('0' + (fd % 10)); }
}
#define __procfdname(buf, fd)   procfdname((buf), (fd))


LIB_FUNC char* realpath(const char* restrict filename, char* restrict resolved) {
	if (!filename) { errno = EINVAL; return 0; }
	char buf[15 + (3 * SIZEOF_INT)] = { 0 };
	char tmp[PATH_MAX] = { 0 };
	int fd = (int)sys_open(filename, (O_PATH | O_NONBLOCK | O_CLOEXEC));
	if (fd < 0) { return 0; }
	procfdname(buf, (unsigned int)fd);
	ssize_t r = readlink(buf, tmp, (sizeof(tmp) - 1));
	if (r < 0) { syscall(SYS_close, fd); return 0; }
	tmp[r] = 0;
	struct stat _st1, _st2;
	fstat(fd, &_st1);
	r = stat(tmp, &_st2);
	if (r < 0 || (_st1.st_dev != _st2.st_dev) || (_st1.st_ino != _st2.st_ino)) {
		if (!r) { errno = ELOOP; }
		syscall(SYS_close, fd);
		return 0;
	}
	syscall(SYS_close, fd);
	return (resolved ? strcpy(resolved, tmp) : strdup(tmp));
}


/** Return true if we read an affirmative line from standard input; Since this function uses stdin, it is suggested that the caller not use STDIN_FILENO directly, and also that the line atexit(close_stdin) be added to main() */
LIB_FUNC bool yesno(void) {
	bool answer;
#   if (defined(ENABLE_NLS) && ENABLE_NLS)
	char* response = NULL;
	size_t response_size = 0;
	const ssize_t response_len = getline(&response, &response_size, stdin);
	if (response_len <= 0) { answer = false; }
	else {
		if (response[response_len - 1] == '\n') { response[response_len - 1] = '\0'; }
		answer = (0 < rpmatch(response));
	}
	free(response);
#   else
	int c = getchar();
	answer = (c == 'y' || c == 'Y');
	while (c != '\n' && c != EOF) { c = getchar(); }
#   endif
	return answer;
}


/** Executes the program pointed to by filename */
LIB_FUNC int execve(const char* path, char* argv[], char* envp[]) {
	return (int)syscall(SYS_execve, path, argv, envp);
}
#define _execve(path, argv, envp)   execve((path), (argv), (envp))
#define __execve(path, argv, envp)   execve((path), (argv), (envp))


/** Executes a program */
LIB_FUNC int execv(const char* path, char* argv[]) {
	return (int)syscall(SYS_execve, path, argv, __environ);
}
#define _execv(path, argv)   execv((path), (argv))
#define __execv(path, argv)   execv((path), (argv))


/** Executes a program */
LIB_FUNC int execvpe(const char* file, char* argv[], char* envp[]) {
	const char *p, *z, *path = getenv("PATH");
	size_t l, k;
	register int seen_eacces = 0;
	errno = ENOENT;
	if (!*file) { return -1; }
	else if (strchr(file, '/')) { return execve(file, argv, envp); }
	else if (!path) { path = "/usr/local/bin:/bin:/usr/bin"; }
	k = strnlen(file, NAME_MAX + 1);
	if (k > NAME_MAX) { errno = ENAMETOOLONG; return -1; }
	l = strnlen(path, PATH_MAX - 1) + 1;
	char b[l + k + 1];
	for (p = path; ; p = z) {
		z = strchr(p, ':');
		if (!z) { z = p + strlen(p); }
		if ((size_t)(z - p) >= l) {
			if (!*z++) { break; }
			continue;
		}
		memcpy_no_output(b, p, (size_t)(z - p));
		b[z - p] = '/';
		memcpy_no_output((b + (z - p) + (z > p)), file, (k + 1));
		execve(b, argv, envp);
		if (errno == EACCES) { seen_eacces = 1; }
		else if (errno != ENOENT) { return -1; }
		else if (!*z++) { break; }
	}
	if (seen_eacces) { errno = EACCES; }
	return -1;
}
#define _execvpe(file, argv, envp)   execvpe((file), (argv), (envp))
#define __execvpe(file, argv, envp)   execvpe((file), (argv), (envp))


/** Executes a program */
LIB_FUNC int execvp(const char* file, char* argv[]) {
	return __execvpe(file, argv, __environ);
}
#define _execvp(file, argv)   execvp((file), (argv))
#define __execvp(file, argv)   execvp((file), (argv))


/** Executes a program */
LIB_FUNC int execlp(const char* file, char* argv0, ...) {
	register int argc;
	va_list ap;
	va_start(ap, argv0);
	for (argc = 1; va_arg(ap, char*); ++argc);
	va_end(ap);
	char* argv[argc + 1];
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i;
	for (i = 1; i < argc; i++) { argv[i] = va_arg(ap, char*); }
	argv[i] = NULL;
	va_end(ap);
	return execvp(file, argv);
}
#define _execlp(file, argv0, ...)   execlp((file), (argv0), (__VA_ARGS__))
#define __execlp(file, argv0, ...)   execlp((file), (argv0), (__VA_ARGS__))


/** Executes a program */
LIB_FUNC int execle(const char* path, char* argv0, ...) {
	register int argc;
	va_list ap;
	va_start(ap, argv0);
	for (argc = 1; va_arg(ap, char*); ++argc);
	va_end(ap);
	char* argv[argc + 1];
	char** envp;
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i;
	for (i = 1; i <= argc; i++) { argv[i] = va_arg(ap, char*); }
	envp = va_arg(ap, char **);
	va_end(ap);
	return execve(path, argv, envp);
}
#define _execle(path, argv0, ...)   execle((path), (argv0), (__VA_ARGS__))
#define __execle(path, argv0, ...)   execle((path), (argv0), (__VA_ARGS__))


/** Executes a program */
LIB_FUNC int execl(const char* path, char* argv0, ...) {
	register int argc;
	va_list ap;
	va_start(ap, argv0);
	for (argc = 1; va_arg(ap, char*); ++argc);
	va_end(ap);
	char* argv[argc + 1];
	va_start(ap, argv0);
	argv[0] = (char*)argv0;
	register int i;
	for (i = 1; i < argc; i++) { argv[i] = va_arg(ap, char*); }
	argv[i] = NULL;
	va_end(ap);
	return execv(path, argv);
}
#define _execl(path, argv0, ...)   execl((path), (argv0), (__VA_ARGS__))
#define __execl(path, argv0, ...)   execl((path), (argv0), (__VA_ARGS__))


/** Execute a shell command */
LIB_FUNC int system(const char* command) {
	if ((!command) || command == NULL) { return -1; }
	register pid_t pid, cpid;
	const char* argp[4] = {"sh", "-c", command, NULL};
	switch (cpid = vfork()) {
		case -1:
			return -1;
		case 0:
			execv(PATH_BSHELL, __UNCONST(argp));
			_Exit(127);
		default: break;
	}
	int pstat;
	do {
		pid = waitpid(cpid, &pstat, 0);
	} while (pid == -1 && errno == EINTR);
	return (pid == -1 ? -1 : pstat);
}


/** Return a malloced string containing the canonical absolute name of the named file; The last file name component need not exist, and may be a symlink to a nonexistent file */
LIB_FUNC char* canonicalize_file_name(const char* name) {
	return realpath(name, NULL);
}


#if (defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE))
#   define mkstemp64   mkstemp
#   define mkostemp64   mkostemp
#   define tmpfile64   tmpfile
#   define fopen64   fopen
#   define freopen64   freopen
#   define fseeko64   fseeko
#   define ftello64   ftello
#   define fgetpos64   fgetpos
#   define fsetpos64   fsetpos
#elif (defined(_BSD_SOURCE))
#   define mkstemps64   mkstemps
#   define mkostemps64   mkostemps
#endif


/* TODO: Add stdlib functions
int getsubopt(char**, char* const*, char**);
char* mkdtemp(char*);
int mkstemp(char*);
void setkey(const char*);
*/


#endif  // STDLIB_H


/* PTRACE DEBUGGER SUPPORT INTERFACE */


#if (!(defined(_SYS_PTRACE_H) || defined(_SYS_PTRACE_H_)))
#define _SYS_PTRACE_H   (1)
#define _SYS_PTRACE_H_   (1)


#ifdef SPARC


/** Type of the REQUEST argument to `ptrace` */
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 11,
#   if IS_WORDSIZE_32
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 12,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 13,
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 14,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 15,
#   endif
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Write several bytes at a time */
	PTRACE_WRITEDATA = 17,
	/** Read several bytes at a time */
	PTRACE_READTEXT = 18,
	/** Write several bytes at a time */
	PTRACE_WRITETEXT = 19,
#   if WORDSIZE_IS_64
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 22,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 23,
#   endif
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
#   if WORDSIZE_IS_64
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 25,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 26,
#   endif
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208,
	PTRACE_PEEKSIGINFO = 0x4209
};


/** Flag for PTRACE_LISTEN */
#define PTRACE_SEIZE_DEVEL   0x80000000


/** Options set using PTRACE_SETOPTIONS */
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_EXITKILL = 0x100000,
	PTRACE_O_MASK = 0x1000ff
};


/** Wait extended result codes for the above trace options */
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRACE_EVENT_SECCOMP = 7
};


/** Arguments for PTRACE_PEEKSIGINFO */
struct __ptrace_peeksiginfo_args {
	uint64_t off;  // From which siginfo to start
	uint32_t flags;  // Flags for peeksiginfo
	int32_t nr;  // How many siginfos to take
};


/** Read signals from a shared (process wide) queue */
enum __ptrace_peeksiginfo_flags { PTRACE_PEEKSIGINFO_SHARED = 1 };


#elif defined(ITANIUM)


/** Type of the REQUEST argument to `ptrace` */
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Execute process until next taken branch */
	PTRACE_SINGLEBLOCK = 12,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 13,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 14,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Get all registers (pt_all_user_regs) in one shot */
	PTRACE_GETREGS = 18,
	/** Set all registers (pt_all_user_regs) in one shot */
	PTRACE_SETREGS = 19,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24
};


/** pt_all_user_regs is used for PTRACE_GETREGS/PTRACE_SETREGS */
struct pt_all_user_regs {
	unsigned long nat, cr_iip, cfm, cr_ipsr, pr;
	unsigned long gr[32];
	unsigned long br[8];
	unsigned long ar[128];
	struct ia64_fpreg fr[128];
};


/** Flag for PTRACE_LISTEN */
#define PTRACE_SEIZE_DEVEL   0x80000000


/** Options set using PTRACE_SETOPTIONS */
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};


/** Wait extended result codes for the above trace options */
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};


#elif defined(MICROBLAZE)


/** Type of the REQUEST argument to `ptrace` */
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process */
	PTRACE_SINGLESTEP = 9,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24
};


/** Flag for PTRACE_LISTEN */
#define PTRACE_SEIZE_DEVEL   0x80000000


/** Options set using PTRACE_SETOPTIONS */
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};


/** Wait extended result codes for the above trace options */
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};


#elif defined(POWERPC)


/** Type of the REQUEST argument to `ptrace` */
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208,
	PTRACE_PEEKSIGINFO = 0x4209
};


/** Flag for PTRACE_LISTEN */
#define PTRACE_SEIZE_DEVEL   0x80000000


/** Options set using PTRACE_SETOPTIONS */
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_EXITKILL = 0x100000,
	PTRACE_O_MASK = 0x1000ff
};


/** Wait extended result codes for the above trace options */
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRACE_EVENT_SECCOMP = 7
};


/** Arguments for PTRACE_PEEKSIGINFO */
struct __ptrace_peeksiginfo_args {
	uint64_t off;  // From which siginfo to start
	uint32_t flags;  // Flags for peeksiginfo
	int32_t nr;  // How many siginfos to take
};


/** Read signals from a shared (process wide) queue */
enum __ptrace_peeksiginfo_flags { PTRACE_PEEKSIGINFO_SHARED = 1 };


#else


/** Type of the REQUEST argument to `ptrace` */
enum __ptrace_request {
	PTRACE_TRACEME = 0,
	/** Return the word in the process's text space at address ADDR */
	PTRACE_PEEKTEXT = 1,
	/** Return the word in the process's data space at address ADDR */
	PTRACE_PEEKDATA = 2,
	/** Return the word in the process's user area at offset ADDR */
	PTRACE_PEEKUSER = 3,
	/** Write the word DATA into the process's text space at address ADDR */
	PTRACE_POKETEXT = 4,
	/** Write the word DATA into the process's data space at address ADDR */
	PTRACE_POKEDATA = 5,
	/** Write the word DATA into the process's user area at offset ADDR */
	PTRACE_POKEUSER = 6,
	/** Continue the process */
	PTRACE_CONT = 7,
	/** Kill the process */
	PTRACE_KILL = 8,
	/** Single step the process; This is not supported on all machines */
	PTRACE_SINGLESTEP = 9,
	/** Get all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_GETREGS = 12,
	/** Set all general purpose registers used by a processes; This is not supported on all machines */
	PTRACE_SETREGS = 13,
	/** Get all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPREGS = 14,
	/** Set all floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPREGS = 15,
	/** Attach to a process that is already running */
	PTRACE_ATTACH = 16,
	/** Detach from a process attached to with PTRACE_ATTACH */
	PTRACE_DETACH = 17,
	/** Get all extended floating point registers used by a processes; This is not supported on all machines */
	PTRACE_GETFPXREGS = 18,
	/** Set all extended floating point registers used by a processes; This is not supported on all machines */
	PTRACE_SETFPXREGS = 19,
	/** Continue and stop at the next (return from) syscall */
	PTRACE_SYSCALL = 24,
	/** Set ptrace filter options */
	PTRACE_SETOPTIONS = 0x4200,
	/** Get last ptrace message */
	PTRACE_GETEVENTMSG = 0x4201,
	/** Get siginfo for process */
	PTRACE_GETSIGINFO = 0x4202,
	/** Set new siginfo for process */
	PTRACE_SETSIGINFO = 0x4203,
	/** Get register content */
	PTRACE_GETREGSET = 0x4204,
	/** Set register content */
	PTRACE_SETREGSET = 0x4205,
	/** Like PTRACE_ATTACH, but do not force trace to trap and do not affect signal or group stop state */
	PTRACE_SEIZE = 0x4206,
	/** Trap seized trace */
	PTRACE_INTERRUPT = 0x4207,
	/** Wait for next group event */
	PTRACE_LISTEN = 0x4208
};


/** Flag for PTRACE_LISTEN */
#define PTRACE_SEIZE_DEVEL   0x80000000


/** Options set using PTRACE_SETOPTIONS */
enum __ptrace_setoptions {
	PTRACE_O_TRACESYSGOOD = 1,
	PTRACE_O_TRACEFORK = 2,
	PTRACE_O_TRACEVFORK = 4,
	PTRACE_O_TRACECLONE = 8,
	PTRACE_O_TRACEEXEC = 0x10,
	PTRACE_O_TRACEVFORKDONE = 0x20,
	PTRACE_O_TRACEEXIT = 0x40,
	PTRACE_O_TRACESECCOMP = 0x80,
	PTRACE_O_MASK = 0xff
};


/** Wait extended result codes for the above trace options */
enum __ptrace_eventcodes {
	PTRACE_EVENT_FORK = 1,
	PTRACE_EVENT_VFORK = 2,
	PTRACE_EVENT_CLONE = 3,
	PTRACE_EVENT_EXEC = 4,
	PTRACE_EVENT_VFORK_DONE = 5,
	PTRACE_EVENT_EXIT = 6,
	PTRAVE_EVENT_SECCOMP = 7
};


#endif


#define __NR___syscall_ptrace   __NR_ptrace
#define __syscall_ptrace(request, pid, addr, data)   syscall(SYS_ptrace, (request), (pid), (addr), (data))
#define syscall_ptrace(request, pid, addr, data)   syscall(SYS_ptrace, (request), (pid), (addr), (data))


/** Perform process tracing functions.  REQUEST is one of the values above, and determines the action to be taken; For all requests except PTRACE_TRACEME, PID specifies the process to be traced */
LIB_FUNC long ptrace(enum __ptrace_request request, ...) {
	va_list ap;
	void *addr, *data;
	va_start(ap, request);
	register pid_t pid = va_arg(ap, pid_t);
	addr = va_arg(ap, void*);
	data = va_arg(ap, void*);
	va_end(ap);
	long ret;
	if (request > 0 && request < 4) { data = &ret; }
	const long res = (long)syscall_ptrace(request, pid, addr, data);
	if (res >= 0 && request > 0 && request < 4) { __set_errno(0); return ret; }
	return res;
}


#endif  // SYS_PTRACE_H


/* SIGCONTEXT & SYSTEM V COMPLIANT CONTEXT SWITCHING SUPPORT */


#if (!(defined(_BITS_SIGCONTEXT_H) || defined(_SYS_UCONTEXT_H)))
#define _BITS_SIGCONTEXT_H   (1)
#define _SYS_UCONTEXT_H   (1)


#ifdef ARM


typedef int   greg_t;
/** Number of general registers */
#define NGREG   18
/** Container for all general registers */
typedef elf_gregset_t   gregset_t;
/** Number of each register is the `gregset_t` array */
enum {
	R0 = 0,
	R1 = 1,
	R2 = 2,
	R3 = 3,
	R4 = 4,
	R5 = 5,
	R6 = 6,
	R7 = 7,
	R8 = 8,
	R9 = 9,
	R10 = 10,
	R11 = 11,
	R12 = 12,
	R13 = 13,
	R14 = 14,
	R15 = 15
};
/** Structure to describe FPU registers */
typedef elf_fpregset_t   fpregset_t;
/** Context to describe whole processor state */
typedef struct sigcontext   mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
	unsigned long align8 uc_regspace[128];
} ucontext_t;


#elif defined(ALPHA)


/** Type for general register */
typedef long   greg_t;
/** Number of general registers */
#define NGREG   33
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Type for floating-point register */
typedef long   fpreg_t;
/** Number of general registers */
#define NFPREG   32
/** Container for all general registers */
typedef fpreg_t   fpregset_t[NFPREG];
/** A machine context is exactly a sigcontext */
typedef struct sigcontext   mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	unsigned long __uc_osf_sigmask;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
} ucontext_t;


#elif defined(X86_64)


#if IS_WORDSIZE_64

/** Type for general register */
typedef long   greg_t;
/** Number of general registers */
#define NGREG   23
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Number of each register in the `gregset_t` array */
enum {
	REG_R8 = 0,
	REG_R9,
	REG_R10,
	REG_R11,
	REG_R12,
	REG_R13,
	REG_R14,
	REG_R15,
	REG_RDI,
	REG_RSI,
	REG_RBP,
	REG_RBX,
	REG_RDX,
	REG_RAX,
	REG_RCX,
	REG_RSP,
	REG_RIP,
	REG_EFL,
	REG_CSGSFS,
	REG_ERR,
	REG_TRAPNO,
	REG_OLDMASK,
	REG_CR2
};
struct _libc_fpxreg {
	unsigned short significand[4];
	unsigned short exponent;
	unsigned short padding[3];
};
struct _libc_xmmreg { uint32_t element[4]; };
struct _libc_fpstate {
	uint16_t cwd, swd, ftw, fop;
	uint64_t rip, rdp;
	uint32_t mxcsr, mxcr_mask;
	struct _libc_fpxreg _st[8];
	struct _libc_xmmreg _xmm[16];
	uint32_t padding[24];
};
/** Structure to describe FPU registers */
typedef struct _libc_fpstate*   fpregset_t;
/** Context to describe whole processor state */
typedef struct __mcontext {
	gregset_t gregs;
	fpregset_t fpregs;
	unsigned long __reserved1[8];
} mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
	struct _libc_fpstate __fpregs_mem;
} ucontext_t;

#else  // WORDSIZE_IS_32

/** Type for general register */
typedef int   greg_t;
/** Number of general registers */
#define NGREG   19
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Number of each register is the `gregset_t` array */
enum {
	REG_GS = 0,
	REG_FS,
	REG_ES,
	REG_DS,
	REG_EDI,
	REG_ESI,
	REG_EBP,
	REG_ESP,
	REG_EBX,
	REG_EDX,
	REG_ECX,
	REG_EAX,
	REG_TRAPNO,
	REG_ERR,
	REG_EIP,
	REG_CS,
	REG_EFL,
	REG_UESP,
	REG_SS
};
/** Definitions taken from the kernel headers */
struct _libc_fpreg { unsigned short significand[4], exponent; };
struct _libc_fpstate {
	unsigned long cw, sw, tag, ipoff, cssel, dataoff, datasel;
	struct _libc_fpreg _st[8];
	unsigned long status;
};
/** Structure to describe FPU registers */
typedef struct _libc_fpstate*   fpregset_t;
/** Context to describe whole processor state */
typedef struct __mcontext {
	gregset_t gregs;
	fpregset_t fpregs;
	unsigned long oldmask, cr2;
} mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
	struct _libc_fpstate __fpregs_mem;
} ucontext_t;

#endif  // WORDSIZE


#elif defined(I386)


/** Type for general register */
typedef int   greg_t;
/** Number of general registers */
#define NGREG   19
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Number of each register is the `gregset_t` array */
enum {
	REG_GS = 0,
	REG_FS,
	REG_ES,
	REG_DS,
	REG_EDI,
	REG_ESI,
	REG_EBP,
	REG_ESP,
	REG_EBX,
	REG_EDX,
	REG_ECX,
	REG_EAX,
	REG_TRAPNO,
	REG_ERR,
	REG_EIP,
	REG_CS,
	REG_EFL,
	REG_UESP,
	REG_SS
};
/** Definitions taken from the kernel headers */
struct _libc_fpreg { unsigned short significand[4], exponent; };
struct _libc_fpstate {
	unsigned long cw, sw, tag, ipoff, cssel, dataoff, datasel;
	struct _libc_fpreg _st[8];
	unsigned long status;
};
/** Structure to describe FPU registers */
typedef struct _libc_fpstate*   fpregset_t;
/** Context to describe whole processor state */
typedef struct __mcontext {
	gregset_t gregs;
	fpregset_t fpregs;
	unsigned long oldmask, cr2;
} mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
	struct _libc_fpstate __fpregs_mem;
} ucontext_t;


#elif defined(MIPS)


/** Type for general register */
typedef unsigned long long   greg_t;
/** Number of general registers */
#define NGREG   32
/** Number of general registers */
#define NFPREG   32
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Container for all FPU registers */
typedef struct fpregset {
	union {
		double fp_dregs[NFPREG];
		struct {
			float _fp_fregs;
			unsigned int _fp_pad;
		} fp_fregs[NFPREG];
	} fp_r;
} fpregset_t;
#if (_MIPS_SIM == _ABIO32)
/** Context to describe whole processor state */
typedef struct mcontext {
	unsigned int regmask, status;
	greg_t pc;
	gregset_t gregs;
	fpregset_t fpregs;
	unsigned int fp_owned, fpc_csr, fpc_eir, used_math, dsp;
	greg_t mdhi, mdlo;
	unsigned long hi1, lo1, hi2, lo2, hi3, lo3;
} mcontext_t;
#else
/** Context to describe whole processor state */
typedef struct mcontext {
	gregset_t gregs;
	fpregset_t fpregs;
	greg_t mdhi, hi1, hi2, hi3, mdlo, lo1, lo2, lo3, pc;
	unsigned int fpc_csr, used_math, dsp, reserved;
} mcontext_t;
#endif
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
} ucontext_t;


#elif defined(BLACKFIN)


/** Type for general register */
typedef int   greg_t;
/** Number of general registers */
#define NGREG   47
/** Container for all general registers */
typedef greg_t   gregset_t[NGREG];
/** Number of each register is the `gregset_t` array */
enum {
	REG_R0 = 0,
	REG_R1 = 1,
	REG_R2 = 2,
	REG_R3 = 3,
	REG_R4 = 4,
	REG_R5 = 5,
	REG_R6 = 6,
	REG_R7 = 7,
	REG_P0 = 8,
	REG_P1 = 9,
	REG_P2 = 10,
	REG_P3 = 11,
	REG_P4 = 12,
	REG_P5 = 13,
	REG_USP = 14,
	REG_A0W = 15,
	REG_A1W = 16,
	REG_A0X = 17,
	REG_A1X = 18,
	REG_ASTAT = 19,
	REG_RETS = 20,
	REG_PC= 21,
	REG_RETX = 22,
	REG_FP = 23,
	REG_I0 = 24,
	REG_I1 = 25,
	REG_I2 = 26,
	REG_I3 = 27,
	REG_M0 = 28,
	REG_M1 = 29,
	REG_M2 = 30,
	REG_M3 = 31,
	REG_L0 = 32,
	REG_L1 = 33,
	REG_L2 = 34,
	REG_L3 = 35,
	REG_B_0 = 36,
	REG_B1 = 37,
	REG_B2 = 38,
	REG_B3 = 39,
	REG_LC0 = 40,
	REG_LC1 = 41,
	REG_LT0 = 42,
	REG_LT1 = 43,
	REG_LB0 = 44,
	REG_LB1 = 45,
	REG_SEQSTAT = 46
};
/** Context to describe whole processor state */
typedef struct mcontext { gregset_t gregs; }   mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
} ucontext_t;


#elif defined(MICROBLAZE)


typedef struct sigcontext   mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
	sigset_t uc_sigmask;
} ucontext_t;


#elif defined(POWERPC)


#if WORDSIZE_IS_32

/** Number of general registers */
#   define NGREG   48
/** Container for all general registers */
typedef unsigned long   gregset_t[NGREG];
/** Container for floating-point registers and status */
typedef struct _libc_fpstate {
	double fpregs[32];
	double fpscr;
	unsigned int _pad[2];
} fpregset_t;
/** Container for Altivec/VMX registers and status; Needs to be aligned on a 16-byte boundary */
typedef struct _libc_vrstate {
	unsigned int vrregs[32][4];
	unsigned int vrsave;
	unsigned int _pad[2];
	unsigned int vscr;
} vrregset_t;
/** Context to describe whole processor state */
typedef struct mcontext {
	gregset_t gregs;
	fpregset_t fpregs;
	vrregset_t align16 vrregs;
} mcontext_t;

#else

// For 64-bit kernels with Altivec support, a machine context is exactly a sigcontext
/** Number of general registers */
#   define NGREG   48  // Includes r0-r31, nip, msr, lr, etc.
#   define NFPREG   33  // Includes fp0-fp31 &fpscr
#   define NVRREG   34  // Includes v0-v31, vscr, & vrsave in split vectors
typedef unsigned long   gregset_t[NGREG];
typedef double   fpregset_t[NFPREG];
/** Container for Altivec/VMX Vector Status and Control Register; Only 32-bits but can only be copied to/from a 128-bit vector register; So we allocated a whole quadword speedup save/restore */
typedef struct _libc_vscr {
	unsigned int __pad[3];
	unsigned int vscr_word;
} vscr_t;
/** Container for Altivec/VMX registers and status; Must to be aligned on a 16-byte boundary */
typedef struct align16 _libc_vrstate {
	unsigned int vrregs[32][4];
	vscr_t vscr;
	unsigned int vrsave;
	unsigned int __pad[3];
} vrregset_t;
typedef struct __mcontext {
	unsigned long __unused[4];
	int signal, __pad0;
	unsigned long handler, oldmask;
	struct pt_regs* regs;
	gregset_t gp_regs;
	fpregset_t fp_regs;
	vrregset_t* v_regs;
	long vmx_reserve[NVRREG + NVRREG + 1];
} mcontext_t;

#endif

/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	stack_t uc_stack;
#   if WORDSIZE_IS_32
	int uc_pad[7];
	union uc_regs_ptr {
		struct pt_regs* regs;
		mcontext_t* uc_regs;
	} uc_mcontext;
	sigset_t uc_sigmask;
	char uc_reg_space[sizeof(mcontext_t) + 12];
#   else  // 64-bit
	sigset_t uc_sigmask;
	mcontext_t uc_mcontext;
#   endif
} ucontext_t;


#elif defined(SPARC)


#if IS_WORDSIZE_64

#define MC_TSTATE   0
#define MC_PC   1
#define MC_NPC   2
#define MC_Y   3
#define MC_G1   4
#define MC_G2   5
#define MC_G3   6
#define MC_G4   7
#define MC_G5   8
#define MC_G6   9
#define MC_G7   10
#define MC_O0   11
#define MC_O1   12
#define MC_O2   13
#define MC_O3   14
#define MC_O4   15
#define MC_O5   16
#define MC_O6   17
#define MC_O7   18
#define MC_NGREG   19
typedef unsigned long   mc_greg_t;
typedef mc_greg_t   mc_gregset_t[MC_NGREG];
#define MC_MAXFPQ   16
struct mc_fq {
	unsigned long* mcfq_addr;
	unsigned int mcfq_insn;
};
struct mc_fpu {
	union {
		unsigned int sregs[32];
		unsigned long dregs[32];
		long double qregs[16];
	} mcfpu_fregs;
	unsigned long mcfpu_fsr;
	unsigned long mcfpu_fprs;
	unsigned long mcfpu_gsr;
	struct mc_fq* mcfpu_fq;
	unsigned char mcfpu_qcnt;
	unsigned char mcfpu_qentsz;
	unsigned char mcfpu_enab;
};
typedef struct mc_fpu   mc_fpu_t;
typedef struct mcontext {
	mc_gregset_t mc_gregs;
	mc_greg_t mc_fp;
	mc_greg_t mc_i7;
	mc_fpu_t mc_fpregs;
} mcontext_t;
typedef struct attr_packed ucontext {
	struct ucontext* uc_link;
	unsigned long uc_flags;
	unsigned long __uc_sigmask;
	mcontext_t uc_mcontext;
	stack_t uc_stack;
	sigset_t uc_sigmask;
} ucontext_t;

#endif  // WORDISIZE

#define REG_PSR   (0)
#define REG_PC   (1)
#define REG_nPC   (2)
#define REG_Y   (3)
#define REG_G1   (4)
#define REG_G2   (5)
#define REG_G3   (6)
#define REG_G4   (7)
#define REG_G5   (8)
#define REG_G6   (9)
#define REG_G7   (10)
#define REG_O0   (11)
#define REG_O1   (12)
#define REG_O2   (13)
#define REG_O3   (14)
#define REG_O4   (15)
#define REG_O5   (16)
#define REG_O6   (17)
#define REG_O7   (18)

#if IS_WORDSIZE_64

#define REG_ASI   (19)
#define REG_FPRS   (20)
#define NGREG   21
typedef long   greg_t;

#else  // IS_WORDSIZE_32

#define NGREG   19
typedef int   greg_t;

#endif  // WORDSIZE

typedef greg_t  gregset_t[NGREG];
/** max windows in SPARC arch */
#define SPARC_MAXREGWINDOW   31
struct rwindow {
	greg_t rw_local[8];
	greg_t rw_in[8];
};
/** frame pointer */
#define rw_fp   rw_in[6]
/** return address */
#define rw_rtn  rw_in[7]
typedef struct gwindows {
	int wbcnt;
	int* spbuf[SPARC_MAXREGWINDOW];
	struct rwindow wbuf[SPARC_MAXREGWINDOW];
} gwindows_t;
/** max # of fpu queue entries currently supported */
#define MAXFPQ   16
/** struct fq defines the minimal format of a floating point instruction queue entry */
struct fpq {
	unsigned long* fpq_addr;
	unsigned long fpq_instr;
};
/** FPU inst/addr queue */
struct fq {
	union {
		double whole;
		struct fpq fpq;
	} FQu;
};
#define FPU_REGS_TYPE   unsigned
#define FPU_DREGS_TYPE   unsigned long long
#define V7_FPU_FSR_TYPE   unsigned
#define V9_FPU_FSR_TYPE   unsigned long long
#define V9_FPU_FPRS_TYPE   unsigned

#if IS_WORDSIZE_64

/** FPU floating point regs */
typedef struct fpu {
	union {
		unsigned fpu_regs[32];
		double fpu_dregs[16];
		long double fpu_qregs[16];
	} fpu_fr;
	struct fq* fpu_q;
	unsigned long fpu_fsr;
	unsigned char fpu_qcnt, fpu_q_entrysize, fpu_en;
} fpregset_t;

#else  // IS_WORDSIZE_32

/** FPU floating point regs */
typedef struct fpu {
	union {
		unsigned long long fpu_regs[32];
		double fpu_dregs[16];
	} fpu_fr;
	struct fq* fpu_q;
	unsigned fpu_fsr;
	unsigned char fpu_qcnt;
	unsigned char fpu_q_entrysize;
	unsigned char fpu_en;
} fpregset_t;
/** The following structure is for associating extra register state with the ucontext structure and is kept within the uc_mcontext filler area */
typedef struct {
	unsigned int xrs_id;
	void* xrs_ptr;
} xrs_t;
/** The string "xrs" */
#define XRS_ID   0x78727300
typedef struct mcontext {
	gregset_t gregs;
	gwindows_t* gwins;
	fpregset_t fpregs;
	xrs_t xrs;
	long filler[19];
} mcontext_t;
/** Userlevel context */
typedef struct attr_packed ucontext {
	unsigned long uc_flags;
	struct ucontext* uc_link;
	sigset_t uc_sigmask;
	stack_t uc_stack;
	mcontext_t uc_mcontext;
} ucontext_t;

#endif  // WORDSIZE


#endif  // ARCH


#ifdef X86_64


typedef struct _fpreg {
	unsigned short significand[4];
	unsigned short exponent;
} _fpreg_t;

typedef struct _fpxreg {
	unsigned short significand[4];
	unsigned short exponent;
	unsigned short padding[3];
} _fpxreg_t;

typedef struct _xmmreg { uint32_t element[4]; }   _xmmreg_t;

#if WORDSIZE_IS_32

/** FPU environment */
struct _fpstate {
	// Regular FPU environment
	uint32_t cw, sw, tag, ipoff, cssel, dataoff, datasel;
	struct _fpreg _st[8];
	unsigned short status, magic;
	// FXSR FPU environment
	uint32_t _fxsr_env[6];
	uint32_t mxcsr, reserved;
	struct _fpxreg _fxsr_st[8];
	struct _xmmreg _xmm[8];
	uint32_t padding[56];
};

struct sigcontext {
	unsigned short gs, __gsh, fs, __fsh;
	unsigned short es, __esh, ds, __dsh;
	unsigned long edi, esi, ebp, esp, ebx, edx, ecx, eax;
	unsigned long trapno, err, eip;
	unsigned short cs, __csh;
	unsigned long eflags, esp_at_signal;
	unsigned short ss, __ssh;
	struct _fpstate* fpstate;
	unsigned long oldmask, cr2;
};

#else  // WORDSIZE_IS_64

/** FPU environment matching the 64-bit FXSAVE layout */
struct _fpstate {
	uint16_t cwd, swd, ftw, fop;
	uint64_t rip, rdp;
	uint32_t mxcsr, mxcr_mask;
	struct _fpxreg _st[8];
	struct _xmmreg _xmm[16];
	uint32_t padding[24];
};

struct sigcontext {
	unsigned long r8, r9, r10, r11, r12, r13, r14, r15;
	unsigned long rdi, rsi, rbp, rbx, rdx, rax, rcx, rsp, rip;
	unsigned long eflags;
	unsigned short cs, gs, fs, __pad0;
	unsigned long err, trapno, oldmask, cr2;
	struct _fpstate* fpstate;
	unsigned long __reserved1[8];
};
#endif  // WORDSIZE

#define SIGCONTEXT   siginfo_t* _si, struct ucontext*
#define SIGCONTEXT_EXTRA_ARGS   _si,
#define GET_PC(ctx)   ((void*)(ctx)->uc_mcontext.gregs[REG_RIP])
#define GET_FRAME(ctx)   ((void*)(ctx)->uc_mcontext.gregs[REG_RBP])
#define GET_STACK(ctx)   ((void*)(ctx)->uc_mcontext.gregs[REG_RSP])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#elif defined(I386)


#define SIGCONTEXT   struct sigcontext
#define SIGCONTEXT_EXTRA_ARGS
#define GET_PC(ctx)   ((void*) ctx.eip)
#define GET_FRAME(ctx)   ((void*) ctx.ebp)
#define GET_STACK(ctx)   ((void*) ctx.esp_at_signal)
#define CALL_SIGHANDLER(handler, signo, ctx)   do { int __tmp1, __tmp2, __tmp3, __tmp4; asm volatile (
	"movlt %%esp, %%edi;" \
	"andlt $-16, %%esp;" \
	"sublt %8, %%esp;" \
	"movlt %%edi, %c8-4(%%esp);" \
	"movlt %1, 0(%%esp);" \
	"lealt4 (%%esp), %%edi;" \
	"cld;" \
	"reptmovsl;" \
	"callt *%0;" \
	"cld;" \
	"movlt %9, %%ecx;" \
	"sublt %%edi, %%esi;" \
	"lealt4 (%%esp,%%esi,1), %%edi;" \
	"lealt4 (%%esp), %%esi;" \
	"reptmovsl;" \
	"movlt %c8-4(%%esp), %%esp;" \
	: "=a"(__tmp1), "=d"(__tmp2), "=S"(__tmp3), "=c"(__tmp4) \
	: "0"(handler), "1"(signo), "2"(&ctx), "3"(sizeof(struct sigcontext) >> 2), "n"((sizeof(struct sigcontext) + 19) & (~15)), "i"(sizeof(struct sigcontext) >> 2) \
	: "cc", "edi"); \
} while (0x0)


#elif defined(SPARC)


struct sigcontext {
	struct {
		unsigned int psr, pc, npc, y;
		unsigned int u_regs[16];
	} si_regs;
	int si_mask;
};

#define SIGCONTEXT   struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS
#define GET_PC(__ctx)   ((void*)((__ctx)->si_regs.pc))
#define ADVANCE_STACK_FRAME(__next)   ((void*)(((unsigned*)(__next)) + 14))
#define GET_STACK(__ctx)   ((void*)(__ctx)->si_regs.u_regs[14])
#define GET_FRAME(__ctx)   ADVANCE_STACK_FRAME(GET_STACK(__ctx))
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#elif defined(ARM)


#define __ARMSIGCTX_H   (1)

union k_sigcontext {
	struct {
		unsigned long trap_no, error_code, oldmask;
		unsigned long arm_r0, arm_r1, arm_r2, arm_r3, arm_r4, arm_r5;
		unsigned long arm_r6, arm_r7, arm_r8, arm_r9, arm_r10;
		unsigned long arm_fp, arm_ip, arm_sp, arm_lr, arm_pc, arm_cpsr;
		unsigned long fault_address;
	} v21;
	struct {
		unsigned long magic;
		struct pt_regs reg;
		unsigned long trap_no, error_code, oldmask;
	} v20;
};

#define SIGCONTEXT_2_0_MAGIC   0x4B534154
#define SIGCONTEXT   int _a2, int _a3, int _a4, union k_sigcontext
#define sigcontext   SIGCONTEXT
#define SIGCONTEXT_EXTRA_ARGS _a2, _a3, _a4,
#define ADVANCE_STACK_FRAME(frm)   ((struct layout*)frm - 1)
#define GET_PC(ctx)   ((void*)ctx.v21.arm_pc)
#define GET_FRAME(ctx)   ADVANCE_STACK_FRAME((void*)ctx.v21.arm_fp)
#define GET_STACK(ctx)   ((void*)ctx.v21.arm_sp)
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#elif defined(MIPS)


#if (_MIPS_SIM == _ABIO32)

struct sigcontext {
	unsigned int sc_regmask, sc_status;
	unsigned long long sc_pc;
	unsigned long long sc_regs[32];
	unsigned long long sc_fpregs[32];
	unsigned int sc_ownedfp, sc_fpc_csr, sc_fpc_eir, sc_used_math, sc_dsp;
	unsigned long long sc_mdhi, sc_mdlo;
	unsigned long sc_hi1, sc_lo1, sc_hi2, sc_lo2, sc_hi3, sc_lo3;
};
#define SIGCONTEXT   unsigned long _code, struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS   _code,
#define GET_PC(ctx)   ((void*)ctx->sc_pc)
#define GET_FRAME(ctx)   ((void*)ctx->sc_regs[30])
#define GET_STACK(ctx)   ((void*)ctx->sc_regs[29])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))

#else

struct sigcontext {
	unsigned long long sc_regs[32];
	unsigned long long sc_fpregs[32];
	unsigned long long sc_mdhi;
	unsigned long long sc_hi1, sc_hi2, sc_hi3, sc_mdlo;
	unsigned long long sc_lo1, sc_lo2, sc_lo3, sc_pc;
	unsigned int sc_fpc_csr, sc_used_math, sc_dsp, sc_reserved;
};
#define SIGCONTEXT   unsigned long _code, ucontext_t*
#define SIGCONTEXT_EXTRA_ARGS   _code,
#define GET_PC(ctx)   ((void*)ctx->uc_mcontext.pc)
#define GET_FRAME(ctx)   ((void*)ctx->uc_mcontext.gregs[30])
#define GET_STACK(ctx)   ((void*)ctx->uc_mcontext.gregs[29])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))

#endif  // MIPS_SIM


#elif defined(ITANIUM)


typedef struct align16 ia64_fpreg {
	union { unsigned long bits[2]; } u;
} ia64_fpreg_t;

struct sigcontext {
	unsigned long sc_flags;  // see manifest constants below
	unsigned long sc_nat;  // bit i == 1 iff scratch reg gr[i] is a NaT
	stack_t sc_stack;  // previously active stack
	unsigned long sc_ip;  // instruction pointer
	unsigned long sc_cfm;  // current frame marker
	unsigned long sc_um;  // user mask bits
	unsigned long sc_ar_rsc;  // register stack configuration register
	unsigned long sc_ar_bsp;  // backing store pointer
	unsigned long sc_ar_rnat;  // RSE NaT collection register
	unsigned long sc_ar_ccv;  // compare & exchange compare value register
	unsigned long sc_ar_unat;  // ar.unat of interrupted context
	unsigned long sc_ar_fpsr;  // floating-point status register
	unsigned long sc_ar_pfs;  // previous function state
	unsigned long sc_ar_lc;  // loop count register
	unsigned long sc_pr;  // predicate registers
	unsigned long sc_br[8];  // branch registers
	unsigned long sc_gr[32];  // general registers (static partition)
	struct ia64_fpreg sc_fr[128];  // floating-point registers
	unsigned long sc_rbs_base;  // NULL or new base of sighandler's rbs
	unsigned long sc_loadrs;  // see description above
	unsigned long sc_ar25;  // cmp8xchg16 uses this
	unsigned long sc_ar26;  // rsvd for scratch use
	unsigned long sc_rsvd[12]; // reserved for future use
	unsigned long sc_mask;  // signal mask to restore after handler returns
};

// sc_flag bit definitions
#define IA64_SC_FLAG_ONSTACK_BIT   0  // Is handler running on signal stack?
#define IA64_SC_FLAG_IN_SYSCALL_BIT   1  // did signal interrupt a syscall?
#define IA64_SC_FLAG_FPH_VALID_BIT   2  // is state in f[32]-f[127] valid?
#define IA64_SC_FLAG_ONSTACK   (1 << IA64_SC_FLAG_ONSTACK_BIT)
#define IA64_SC_FLAG_IN_SYSCALL   (1 << IA64_SC_FLAG_IN_SYSCALL_BIT)
#define IA64_SC_FLAG_FPH_VALID   (1 << IA64_SC_FLAG_FPH_VALID_BIT)


#elif defined(XTENSA)


struct sigcontext {
	unsigned long sc_pc, sc_ps, sc_lbeg, sc_lend, sc_lcount, sc_sar, sc_acclo, sc_acchi;
	unsigned long sc_a[16];
	void* sc_xtregs;
};

#define SIGCONTEXT   unsigned long _info, ucontext_t*
#define SIGCONTEXT_EXTRA_ARGS   _info,
#define GET_PC(ctx)   ((void*)(ctx->uc_mcontext.sc_pc & 0x3fffffff))
#define GET_FRAME(ctx)   ((void*)ctx->uc_mcontext.sc_a[1])
#define GET_STACK(ctx)   ((void*)ctx->uc_mcontext.sc_a[1])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#elif defined(BLACKFIN)


#define SIGCONTEXT   int _code, struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS   _code,
#define GET_PC(ctx)   ((void*)(ctx)->sc_pc)
#define GET_FRAME(ctx)   ((void*)__builtin_frame_address(1))
#define GET_STACK(ctx)   ((void*)(ctx)->sc_usp)
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))


#elif defined(SH)


#define SIGCONTEXT   int _a2, int _a3, int _a4, struct sigcontext
#define SIGCONTEXT_EXTRA_ARGS   _a2, _a3, _a4,
#define GET_PC(ctx)   ((void*)ctx.sc_pc)
#define GET_FRAME(ctx)   ((void*)ctx.sc_regs[14])
#define GET_STACK(ctx)   ((void*)ctx.sc_regs[15])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#elif defined(POWERPC)


#define SIGCONTEXT   struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS
#define GET_PC(ctx)   ((void*)((ctx)->regs->nip))
#define GET_FRAME(ctx)   (*(void **)((ctx)->regs->gpr[1]))
#define GET_STACK(ctx)   ((void*)((ctx)->regs->gpr[1]))
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))


#elif defined(ALPHA)


#define SIGCONTEXT   int _code, struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS   _code,
#define GET_PC(ctx)   ((void*)(ctx)->sc_pc)
#define GET_FRAME(ctx)   ((void*)(ctx)->sc_regs[15])
#define GET_STACK(ctx)   ((void*)(ctx)->sc_regs[30])
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#else


#define SIGCONTEXT   struct sigcontext*
#define SIGCONTEXT_EXTRA_ARGS
#define GET_PC(ctx)   ((void*)0)
#define GET_FRAME(ctx)   ((void*)0)
#define GET_STACK(ctx)   ((void*)0)
#define CALL_SIGHANDLER(handler, signo, ctx)   (handler)((signo), SIGCONTEXT_EXTRA_ARGS(ctx))


#endif  // ARCH

#ifndef sigcontext_struct
#   define sigcontext_struct    sigcontext
#endif


#endif  // BITS_SIGCONTEXT_H


/* THREAD-LOCAL DATA HANDLING (<sys/tls.h> & <tls.h>) */


#if (!(defined(_TLS_H) || defined(SYS_TLS_H_) || defined(_SYS_TLS_H_)))
#define _TLS_H   (1)
#define SYS_TLS_H_   (1)
#define _SYS_TLS_H_   (1)
#define _KERNEL_TLS_H   (1)


/** Initial size for TLS inbuf, minimum prefix + linelength guaranteed to be accepted */
#define TLS_MIN_LINELENGTH   2053
/** Usually, the inbuf is enlarged as needed and then kept; if bigger than TLS_PERSIST_LINELENGTH, then shrink to TLS_LARGE_LINELENGTH immediately */
#define TLS_LARGE_LINELENGTH   8192
#define TLS_PERSIST_LINELENGTH   32768
/** Timeout to call non-blocking TLS operations again */
#define TLS_RETRY_EVENT_USEC   20000
/** Reconnect to lost server after n sec (initial value) */
#define TLS_RECONNECT_SEC   10
/** Backoff connection attempts */
#define TLS_RECONNECT_BACKOFF_FACTOR   (15 / 10)
#define TLS_RECONNECT_BACKOFF(x)   (x) = (x) * TLS_RECONNECT_BACKOFF_FACTOR
/** Abandon connection attempts after n seconds */
#define TLS_RECONNECT_GIVEUP   7200
/** Default algorithm for certificate fingerprints */
#define DEFAULT_FINGERPRINT_ALG   "sha-1"
/** Default X.509 certificate files */
#define DEFAULT_X509_CERTFILE   "/etc/openssl/default.crt"
/** Default X.509 key files */
#define DEFAULT_X509_KEYFILE   "/etc/openssl/default.key"
// Options for peer certificate verification
#define X509VERIFY_ALWAYS   0
#define X509VERIFY_IFPRESENT   1
#define X509VERIFY_NONE   2
// Attributes for self-generated keys/certificates
#define TLS_GENCERT_BITS   1024
#define TLS_GENCERT_SERIAL   1
#define TLS_GENCERT_DAYS   1825  // 5 years
// TLS connection states
#define ST_NONE   0
#define ST_TLS_EST   1
#define ST_TCP_EST   2
#define ST_CONNECTING   3
#define ST_ACCEPTING   4
#define ST_READING   5
#define ST_WRITING   6
#define ST_EOF   7
#define ST_CLOSING0   8
#define ST_CLOSING1   9
#define ST_CLOSING2   10
// Return values for TLS_examine_error()
/** No real problem, just ignore */
#define TLS_OK   0
/** Just retry, non-blocking operation not finished yet */
#define TLS_RETRY_READ   1
/** Just retry, non-blocking operation not finished yet */
#define TLS_RETRY_WRITE   2
/** Recoverable error condition, but try again */
#define TLS_TEMP_ERROR   4
/** Non-recoverable error condition, closed TLS and socket */
#define TLS_PERM_ERROR   8
/** Backlog for listen */
#define TLSBACKLOG   4
/** Close TLS connection after multiple 'soft' errors */
#define TLS_MAXERRORCOUNT   4
/** Maximum TLS keys allowed to store; the key is reserved process-wide; Note that tls_allocate() will return B_NO_MEMORY if you try to exceed this limit */
#define TLS_MAX_KEYS   (64)
#define TLS_SIZE   (TLS_MAX_KEYS * SIZEOF_POINTER)
#define SIZEOF_TLS   TLS_SIZE
#define BITS_PER_TLS   (TLS_SIZE * 8)
#define TYPESIZE_TLS   TLS_SIZE
#define mtx_plain   (0)
#define mtx_recursive   (1)
#define mtx_timed   (2)
#define mtx_valid_mask   (3)
#define _PDCLIB_mtx_valid_mask   mtx_valid_mask
#define thrd_success   0
#define thrd_timeout   1
#define thrd_busy   2
#define thrd_error   3
#define thrd_nomem   4
#define TLS_BASE_ADDRESS_SLOT   (0)
#define TLS_THREAD_ID_SLOT   (1)
#define TLS_ERRNO_SLOT   (2)
#define TLS_ON_EXIT_THREAD_SLOT   (3)
#define TLS_USER_THREAD_SLOT   (4)
#define TLS_DYNAMIC_THREAD_VECTOR   (5)
#define TLS_FIRST_FREE_SLOT   (6)


/** Datatype for the dtv */
typedef union attr_packed dtv {
	size_t counter;
	struct attr_packed _dtv_pointer_s {
		void* val;
		bool is_static;
	} pointer;
} dtv_t;


typedef struct tcbhead_s { dtv_t* dtv; void* private; }   tcbhead_t;


#if (defined(__HAVE_TLS_VARIANT_I) || defined(__HAVE_TLS_VARIANT_II))
#   if (defined(__HAVE_TLS_VARIANT_I) && defined(__HAVE_TLS_VARIANT_II))
#      error   "Only one TLS variant can be supported at a time."
#   endif
typedef struct tls_tcb {
#   ifdef __HAVE_TLS_VARIANT_I
	void** tcb_dtv;
	void* tcb_pthread;
#   else
	void* tcb_self;
	void** tcb_dtv;
	void* tcb_pthread;
#   endif
} tls_tcb_t;
#endif  // HAVE_TLS_VARIANT


typedef struct tls_module {
	struct tls_module* next;
	void* image;
	size_t len, size, align, offset;
} tls_module_t;


/* TODO: Add TLS functions
struct tls_tcb* _rtld_tls_allocate(void);
void _rtld_tls_free(struct tls_tcb *);
void _rtld_tls_static_setup(void);
char *init_global_TLS_CTX(void);
struct socketEvent *socksetup_tls(const int, const char *, const char *);
int check_peer_cert(int, X509_STORE_CTX *);
int accept_cert(const char* , struct tls_conn_settings *, char *, char *);
int deny_cert(struct tls_conn_settings *, char *, char *);
bool read_certfile(X509 **, const char *);
bool write_x509files(EVP_PKEY *, X509 *, const char *, const char *);
bool mk_x509_cert(X509 **, EVP_PKEY **, int, int, int);
bool x509_cert_add_subjectAltName(X509 *, X509V3_CTX *);
int tls_examine_error(const char *, const SSL *, struct tls_conn_settings *, const int);
bool get_fingerprint(const X509 *, char **, const char *);
bool get_commonname(X509 *, char **);
bool match_hostnames(X509 *, const char *, const char *);
bool match_fingerprint(const X509 *, const char *);
bool match_certfile(const X509 *, const char *);
bool parse_tls_destination(const char *, struct filed *, size_t);
void dispatch_socket_accept(int, short, void *);
void dispatch_tls_accept(int, short, void *);
void dispatch_tls_read(int, short, void *);
void dispatch_tls_send(int, short, void *);
void dispatch_tls_eof(int, short, void *);
void dispatch_SSL_connect(int, short, void *);
void dispatch_SSL_shutdown(int, short, void *);
void dispatch_force_tls_reconnect(int, short, void *);
bool tls_connect(struct tls_conn_settings *);
void tls_reconnect(int, short, void *);
bool tls_send(struct filed *, char *, size_t, struct buf_queue*);
void tls_split_messages(struct TLS_Incoming_Conn *);
void free_tls_conn(struct tls_conn_settings *);
void free_tls_sslptr(struct tls_conn_settings *);
void free_tls_send_msg(struct tls_send_msg *);
*/


#endif  // TLS_H


/* INTEL INTRINSICS */


#if ((!defined(X86_EXTENSIONS_SEEN)) && (defined(INTEL) || defined(X86) || defined(X86_64)))
#define X86_EXTENSIONS_SEEN   (1)


// GET GPU INFO


#ifdef AMD64
/** Return the name of the system's AMD GPU device (if detected and known) */
LIB_FUNC const char* amd_gpu(void) {
#ifdef __WinterPark__
	return "WinterPark";
#elif defined(__BeaverCreek__)
	return "BeaverCreek";
#elif defined(__Turks__)
	return "Turks";
#elif defined(__Caicos__)
	return "Caicos";
#elif defined(__Tahiti__)
	return "Tahiti";
#elif defined(__Pitcairn__)
	return "Pitcairn";
#elif defined(__Capeverde__)
	return "Capeverde";
#elif defined(__Cayman__)
	return "Cayman";
#elif defined(__Barts__)
	return "Barts";
#elif defined(__Cypress__)
	return "Cypress";
#elif defined(__Juniper__)
	return "Juniper";
#elif defined(__Redwood__)
	return "Redwood";
#elif defined(__Cedar__)
	return "Cedar";
#elif defined(__ATI_RV770__)
	return "ATI_RV770";
#elif defined(__ATI_RV730__)
	return "ATI_RV730";
#elif defined(__ATI_RV710__)
	return "ATI_RV710";
#elif defined(__Loveland__)
	return "Loveland";
#elif defined(__Hawaii__)
	return "Hawaii";
#else
	return "Unknown";
#endif
}
#endif


// GET CPU INFO


/** The rdtsc (Read Time-Stamp Counter) instruction is used to determine how many CPU ticks occurred since the processor was reset */
LIB_FUNC unsigned long long int rdtsc(void) {
	register unsigned long long int cpu_ticks;
	asm volatile ("rdtsc;" : "=A"(cpu_ticks));  // `=A` is `edx:eax`
	return cpu_ticks;
}


/** Return the vendor ID of the x86 CPU (Assumes little-endian) */
LIB_FUNC const char* get_vendor_id(void) {
	int ebx, edx, ecx;
	asm (
		"movl $0,%%eax;"
		"cpuid;"
		"movl %%ecx,%0;"
		"movl %%edx,%1;"
		"movl %%ebx,%2;"
		: "=r"(ebx), "=r"(edx), "=r"(ecx)  // Output C variable
		:  // No input variables
		: "ebx", "edx", "ecx"  // Clobbered Register
	);
	static char vendor[16] = { 0 };
	vendor[13] = '\0';
	vendor[12] = '\0';
	vendor[11] = (char)((ebx >> 24) & 0xFF);
	vendor[10] = (char)((ebx >> 16) & 0xFF);
	vendor[9] = (char)((ebx >> 8) & 0xFF);
	vendor[8] = (char)(ebx & 0xFF);
	vendor[7] = (char)((edx >> 24) & 0xFF);
	vendor[6] = (char)((edx >> 16) & 0xFF);
	vendor[5] = (char)((edx >> 8) & 0xFF);
	vendor[4] = (char)(edx & 0xFF);
	vendor[3] = (char)((ecx >> 24) & 0xFF);
	vendor[2] = (char)((ecx >> 16) & 0xFF);
	vendor[1] = (char)((ecx >> 8) & 0xFF);
	vendor[0] = (char)(ecx & 0xFF);
	return vendor;
}


/** Get the stepping value of the CPU */
LIB_FUNC signed int get_cpu_stepping(void) {
	register signed int stepping;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001111,%%eax;"
		"movl %%eax,%0;"
		: "=r"(stepping)  // Output C variable
	);
	return stepping;
}


#ifdef __BMI2__


/** Get the CPU Model */
LIB_FUNC signed int get_cpu_model(void) {
	register signed int model;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000011110000000011110000,%%eax;"
		"shrl $4,%%eax;"
		"xorb %%bl,%%bl;"
		"xchgb %%al,%%bl;"
		"shrl $8,%%eax;"
		"addb %%bl,%%al;"
		"movl %%eax,%0;"
		: "=r"(model)  // Output C variable
	);
	return model;
}


/** Get the list of instructions supported by the CPU */
LIB_FUNC unsigned long int get_cpu_features(void) {
	register unsigned long int features;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"rolq $64,%%rdx;"
		"movq %%rcx,%%rdx;"
		"movq %%rdx,%0;"
		: "=r"(features)  // Output C variable
	);
	return features;
}


/* BOOLEAN TESTS FOR FEATURES */


/** Test if the CPU supports `fpu` */
LIB_FUNC int is_fpu_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `vme` (Virtual 8086 Mode Extensions, such as VIF, VIP, and PIV) */
LIB_FUNC int is_vme_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%edx;"
		"sarl $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `de` (Debugging extensions (CR4 bit 3)) */
LIB_FUNC int is_de_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%edx;"
		"sarl $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pse` (Page Size Extension) */
LIB_FUNC int is_pse_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%edx;"
		"sarl $3,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `tsc` (Time Stamp Counter) */
LIB_FUNC int is_tsc_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%edx;"
		"sarl $4,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `msr` (Model-specific registers) */
LIB_FUNC int is_msr_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%edx;"
		"sarl $5,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pae` (Physical Address Extension) */
LIB_FUNC int is_pae_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000001000000,%%edx;"
		"sarl $6,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `mce` (Machine Check Exception) */
LIB_FUNC int is_mce_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%edx;"
		"sarl $7,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `cx8` (CMPXCHG8/compare-and-swap instruction) */
LIB_FUNC int is_cx8_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%edx;"
		"sarl $8,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `apic` (Onboard Advanced Programmable Interrupt Controller) */
LIB_FUNC int is_apic_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%edx;"
		"sarl $9,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sep` (SYSENTER and SYSEXIT Instructions) */
LIB_FUNC int is_sep_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000100000000000,%%edx;"
		"sarl $11,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `mtrr` (Memory Type Range Registers) */
LIB_FUNC int is_mtrr_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%edx;"
		"sarl $12,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pge` (Page Global Enable bit in CR4) */
LIB_FUNC int is_pge_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $13,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `mca` (Machine check architecture) */
LIB_FUNC int is_mca_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%edx;"
		"sarl $14,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `cmov` (Conditional move and FCMOV instructions) */
LIB_FUNC int is_cmov_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%edx;"
		"sarl $15,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pat` (Page Attribute Table) */
LIB_FUNC int is_pat_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000010000000000000000,%%edx;"
		"sarl $16,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pse-36` (36-bit page size extension) */
LIB_FUNC int is_pse36_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%edx;"
		"sarl $17,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `psn` (Processor Serial Number) */
LIB_FUNC int is_psn_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%edx;"
		"sarl $18,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `clfsh` (CLFLUSH instruction (SSE2)) */
LIB_FUNC int is_clfsh_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%edx;"
		"sarl $19,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `ds` (Debug store: save trace of executed jumps) */
LIB_FUNC int is_ds_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%edx;"
		"sarl $21,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `acpi` (Onboard thermal control MSRs for ACPI) */
LIB_FUNC int is_acpi_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%edx;"
		"sarl $22,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `mmx` (MMX Instructions) */
LIB_FUNC int is_mmx_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%edx;"
		"sarl $23,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `fxsr` (FXSAVE, FXRESTOR instructions, CR4 bit 9) */
LIB_FUNC int is_fxsr_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%edx;"
		"sarl $24,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sse` (SSE instructions) */
LIB_FUNC int is_sse_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%edx;"
		"sarl $25,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sse2` (SSE2 Instructions) */
LIB_FUNC int is_sse2_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%edx;"
		"sarl $26,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `ss` (CPU cache supports self-snoop) */
LIB_FUNC int is_ss_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%edx;"
		"sarl $27,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `htt` (Hyper-threading) */
LIB_FUNC int is_htt_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%edx;"
		"sarl $28,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `tm` (Thermal monitor automatically limits temperature) */
LIB_FUNC int is_tm_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%edx;"
		"sarl $29,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `ia64` (IA64 processor emulating x86) */
LIB_FUNC int is_ia64_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%edx;"
		"sarl $30,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pbe` (Pending Break Enable (PBE# pin) wakeup support) */
LIB_FUNC int is_pbe_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%edx;"
		"sarl $31,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sse3` (Prescott New Instructions-SSE3 (PNI)) */
LIB_FUNC int is_sse3_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pclmulqdq` (PCLMULQDQ support) */
LIB_FUNC int is_pclmulqdq_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%edx;"
		"sarl $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `dtes64` (64-bit debug store (edx bit 21)) */
LIB_FUNC int is_dtes64_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%edx;"
		"sarl $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `monitor` (MONITOR and MWAIT instructions (SSE3)) */
LIB_FUNC int is_monitor_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%edx;"
		"sarl $3,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `ds-cpl` (CPL qualified debug store) */
LIB_FUNC int is_dscpl_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%edx;"
		"sarl $4,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `vmx` (Virtual Machine eXtensions) */
LIB_FUNC int is_vmx_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%edx;"
		"sarl $5,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `smx` (Safer Mode Extensions (LaGrande)) */
LIB_FUNC int is_smx_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000001000000,%%edx;"
		"sarl $6,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `est` (Enhanced SpeedStep) */
LIB_FUNC int is_est_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%edx;"
		"sarl $7,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `tm2` (Thermal Monitor 2) */
LIB_FUNC int is_tm2_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%edx;"
		"sarl $8,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `ssse3` (Supplemental SSE3 Instructions) */
LIB_FUNC int is_ssse3_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%edx;"
		"sarl $9,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `cnxt-id` (L1 Context ID) */
LIB_FUNC int is_cnxtid_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000000010000000000,%%edx;"
		"sarl $10,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sdbg` (Silicon Debug interface) */
LIB_FUNC int is_sdbg_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $11,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `fma` (Fused multiply-add (FMA3)) */
LIB_FUNC int is_fma_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%edx;"
		"sarl $12,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `cx16` (CMPXCHG16B Instruction) */
LIB_FUNC int is_cx16_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000010000000000000,%%edx;"
		"sarl $13,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `xtpr` (Can disable sending task priority messages) */
LIB_FUNC int is_xtpr_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%edx;"
		"sarl $14,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pdcm` (Perfmon & debug capability) */
LIB_FUNC int is_pdcm_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%edx;"
		"sarl $15,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `pcid` (Process context identifiers (CR4 bit 17)) */
LIB_FUNC int is_pcid_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%edx;"
		"sarl $17,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `dca` (Direct cache access for DMA writes) */
LIB_FUNC int is_dca_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%edx;"
		"sarl $18,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sse41` (SSE4.1 Instructions) */
LIB_FUNC int is_sse41_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%edx;"
		"sarl $19,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `sse42` (SSE4.2 Instructions) */
LIB_FUNC int is_sse42_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000000100000000000000000000,%%edx;"
		"sarl $20,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `x2apic` (x2APIC support) */
LIB_FUNC int is_x2apic_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%edx;"
		"sarl $21,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `movbe` (MOVBE instruction (big-endian)) */
LIB_FUNC int is_movbe_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%edx;"
		"sarl $22,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `popcnt` (POPCNT Instruction) */
LIB_FUNC int is_popcnt_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%edx;"
		"sarl $23,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `tsc-deadline` (APIC supports one-shot operation using a TSC deadline value) */
LIB_FUNC int is_tscdeadline_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%edx;"
		"sarl $24,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `aes` (AES instruction set) */
LIB_FUNC int is_aes_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%edx;"
		"sarl $25,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `xsave` (XSAVE, XRESTOR, XSETBV, XGETBV)xx */
LIB_FUNC int is_xsave_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%edx;"
		"sarl $26,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the OS supports `xsave` (CPU cache supports self-snoop) */
LIB_FUNC int is_osxsave_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%edx;"
		"sarl $27,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `avx` (Advanced Vector Extensions) */
LIB_FUNC int is_avx_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%edx;"
		"sarl $28,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `f16c` (F16C (half-precision) FP support) */
LIB_FUNC int is_f16c_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%edx;"
		"sarl $29,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `rdrnd` (RDRAND (on-chip random number generator) support) */
LIB_FUNC int is_rdrnd_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%edx;"
		"roll $2,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the system is running in a hypervisor (always 0 on a real CPU, but also with some hypervisors) */
LIB_FUNC int is_hypervisor_aval(void) {
	register int truth;
	asm (
		"movl $0x1,%%eax;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%edx;"
		"roll $1,%%edx;"
		"movl %%edx,%0;"
		: "=r"(truth)  // Output C variable
	);
	return truth;
}


/** Test if the CPU supports `fsgsbase` */
LIB_FUNC int is_fsgsbase_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `IA32_TSC_ADJUST` */
LIB_FUNC int is_ia32_tsc_adjust_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%ebx;"
		"sarl $1,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `sgx` (Software Guard Extensions) */
LIB_FUNC int is_sgx_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000100,%%ebx;"
		"sarl $2,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `bmi1` (Bit Manipulation Instruction Set 1) */
LIB_FUNC int is_bmi1_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000001000,%%ebx;"
		"sarl $3,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `hle` (Bit Manipulation Instruction Set 1) */
LIB_FUNC int is_hle_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000010000,%%ebx;"
		"sarl $4,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx2` (Advanced Vector Extensions 2) */
LIB_FUNC int is_avx2_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000100000,%%ebx;"
		"sarl $5,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `smep` (Supervisor-Mode Execution Prevention) */
LIB_FUNC int is_smep_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000010000000,%%ebx;"
		"sarl $7,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `bmi2` (Bit Manipulation Instruction Set 2) */
LIB_FUNC int is_bmi2_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000100000000,%%ebx;"
		"sarl $8,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `erms` (Enhanced REP MOVSB/STOSB) */
LIB_FUNC int is_erms_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000001000000000,%%ebx;"
		"sarl $9,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `invpcid` (INVPCID Instruction) */
LIB_FUNC int is_invpcid_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000010000000000,%%ebx;"
		"sarl $10,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `rtm` (Transactional Synchronization Extensions) */
LIB_FUNC int is_rtm_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000100000000000,%%ebx;"
		"sarl $11,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `pqm` (Platform Quality of Service Monitoring) */
LIB_FUNC int is_pqm_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000001000000000000,%%ebx;"
		"sarl $12,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `mpx` (Intel Memory Protection Extensions) */
LIB_FUNC int is_mpx_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000100000000000000,%%ebx;"
		"sarl $14,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `pqe` (Platform Quality of Service Enforcement) */
LIB_FUNC int is_pqe_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000001000000000000000,%%ebx;"
		"sarl $15,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512f` (AVX-512) */
LIB_FUNC int is_avx512f_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000010000000000000000,%%ebx;"
		"sarl $16,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512dq` (AVX-512 Doubleword and Quadword Instructions) */
LIB_FUNC int is_avx512dq_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000100000000000000000,%%ebx;"
		"sarl $17,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `rdseed` (RDSEED Instruction) */
LIB_FUNC int is_rdseed_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000001000000000000000000,%%ebx;"
		"sarl $18,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `adx` (Intel Multi-Precision Add-Carry Instruction Extensions) */
LIB_FUNC int is_adx_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000010000000000000000000,%%ebx;"
		"sarl $19,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `smap` (Supervisor Mode Access Prevention) */
LIB_FUNC int is_smap_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000100000000000000000000,%%ebx;"
		"sarl $20,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512ifma` (AVX-512 Integer Fused Multiply-Add Instructions) */
LIB_FUNC int is_avx512ifma_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000001000000000000000000000,%%ebx;"
		"sarl $21,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `pcommit` (PCOMMIT Instruction) */
LIB_FUNC int is_pcommit_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000010000000000000000000000,%%ebx;"
		"sarl $22,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `clflushopt` (CLFLUSHOPT Instruction) */
LIB_FUNC int is_clflushopt_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000100000000000000000000000,%%ebx;"
		"sarl $23,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `clwb` (CLWB Instruction) */
LIB_FUNC int is_clwb_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000001000000000000000000000000,%%ebx;"
		"sarl $24,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports Intel Processor Trace */
LIB_FUNC int is_processor_trace_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000010000000000000000000000000,%%ebx;"
		"sarl $25,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512pf` (AVX-512 Prefetch Instructions) */
LIB_FUNC int is_avx512pf_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000100000000000000000000000000,%%ebx;"
		"sarl $26,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512er` (AVX-512 Exponential and Reciprocal Instructions) */
LIB_FUNC int is_avx512er_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00001000000000000000000000000000,%%ebx;"
		"sarl $27,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512cd` (AVX-512 Conflict Detection Instructions) */
LIB_FUNC int is_avx512cd_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00010000000000000000000000000000,%%ebx;"
		"sarl $28,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `sha` (Intel SHA extensions) */
LIB_FUNC int is_sha_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00100000000000000000000000000000,%%ebx;"
		"sarl $29,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512bw` (AVX-512 Byte and Word Instructions) */
LIB_FUNC int is_avx512bw_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b01000000000000000000000000000000,%%ebx;"
		"sarl $30,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512vl` (AVX-512 Vector Length Extensions) */
LIB_FUNC int is_avx512vl_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b10000000000000000000000000000000,%%ebx;"
		"sarl $31,%%ebx;"
		"movl %%ebx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `prefetchwt1` (PREFETCHWT1 Instruction) */
LIB_FUNC int is_prefetchwt1_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000001,%%ecx;"
		"movl %%ecx,%0;"
		: "=r"(truth)
	);
	return truth;
}


/** Test if the CPU supports `avx512vbmi` (AVX-512 Vector Bit Manipulation Instructions) */
LIB_FUNC int is_avx512vbmi_aval(void) {
	register int truth;
	asm (
		"movl $0x07,%%eax;"
		"movl $0x0,%%ecx;"
		"cpuid;"
		"andl $0b00000000000000000000000000000010,%%ecx;"
		"sarl $1,%%ecx;"
		"movl %%ecx,%0;"
		: "=r"(truth)
	);
	return truth;
}


#endif


/** Test if this library is using BMI2 */
LIB_FUNC int is_bmi2_lib(void) {
#ifdef __BMI2__
	return 1;
#else
	return 0;
#endif
}


/** Test if this library is using AVX */
LIB_FUNC int is_avx_lib(void) {
#ifdef __AVX__
	return 1;
#else
	return 0;
#endif
}


/** Test if this library is using AVX2 */
LIB_FUNC int is_avx2_lib(void) {
#ifdef __AVX2__
	return 1;
#else
	return 0;
#endif
}


/** Test if this library is using XOP */
LIB_FUNC int is_xop_lib(void) {
#ifdef __XOP__
	return 1;
#else
	return 0;
#endif
}


/* GENERAL FUNCTIONS */


/** Turn the number to zero in-place */
LIB_FUNC unsigned long long int in_place_zero(unsigned long long int num) {
	asm volatile (  // AT&T Style Assembly
		"xor %0,%0;"
		: "=r"(num)  // %0: Output to C variable
		: "r"(num)  // %1: Input C variable
		:  // Clobbered Register
	);
	return num;
}


/** XOR the two numbers */
LIB_FUNC unsigned long long int asm_xor_ull(unsigned long long int num1, unsigned long long int num2) {
	register unsigned long long int xor_num;
	asm (  // AT&T Style Assembly
		"mov %1,%%rax;"
		"xor %2,%%rax;"
		"mov %%rax,%0;"
		: "=r"(xor_num)  // %0: Output to C variable
		: "r"(num1), "r"(num2)  // %1 & %2: Input C variable
		:  // Clobbered Register
	);
	return xor_num;
}


#ifdef __BMI2__
/** Get a random number from the rdrand assembly instruction */
LIB_FUNC unsigned long int rdrnd(void) {
	if ((is_rdrnd_aval()) == 0) { return (unsigned long int)0; }
	register unsigned long int rand_num;
	asm volatile ("rdrand %0;" : "=r"(rand_num));
	return rand_num;
}
#endif


// TODO: Add Intel Intrinsics
// #if (CPU_MMX || CPU_SSE2 || defined(INTEL))
// #   include <immintrin.h>
// #endif


#if CPU_MMX  // __MMINTRIN_H <mmintrin.h>

// TODO: Add <mmintrin.h>

#endif


#if CPU_SSE2  // __XMMINTRIN_H <xmmintrin.h>


#define _MM_SHUFFLE(z, y, x, w)   (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))


LIB_FUNC unsigned int _mm_getcsr(void) {
	unsigned int retval;
	asm volatile ("stmxcsr %0;" : "=m"(retval));
	return retval;
}


LIB_FUNC void _mm_setcsr(unsigned int val) {
	asm volatile ("ldmxcsr %0;" : : "m"(val));
}


LIB_FUNC __m128 BUILD_SSE _mm_add_ss(__m128 __a, __m128 __b) {
	__a[0] += __b[0];
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_add_ps(__m128 __a, __m128 __b) {
	return __a + __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_sub_ss(__m128 __a, __m128 __b) {
	__a[0] -= __b[0];
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_sub_ps(__m128 __a, __m128 __b) {
	return __a - __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_mul_ss(__m128 __a, __m128 __b) {
	__a[0] *= __b[0];
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_mul_ps(__m128 __a, __m128 __b) {
	return __a * __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_div_ss(__m128 __a, __m128 __b) {
	__a[0] /= __b[0];
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_div_ps(__m128 __a, __m128 __b) {
	return __a / __b;
}


LIB_FUNC __m128 BUILD_SSE _mm_sqrt_ss(__m128 __a) {
	__m128 __c = __builtin_ia32_sqrtss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_sqrt_ps(__m128 __a) {
	return __builtin_ia32_sqrtps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_rcp_ss(__m128 __a) {
	__m128 __c = __builtin_ia32_rcpss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_rcp_ps(__m128 __a) {
	return __builtin_ia32_rcpps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_rsqrt_ss(__m128 __a) {
	__m128 __c = __builtin_ia32_rsqrtss(__a);
	return (__m128) { __c[0], __a[1], __a[2], __a[3] };
}


LIB_FUNC __m128 BUILD_SSE _mm_rsqrt_ps(__m128 __a) {
	return __builtin_ia32_rsqrtps(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_min_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_minss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_min_ps(__m128 __a, __m128 __b) {
	return __builtin_ia32_minps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_max_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_maxss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_max_ps(__m128 __a, __m128 __b) {
	return __builtin_ia32_maxps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_and_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a & (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_andnot_ps(__m128 __a, __m128 __b) {
	return (__m128)(~(__v4si)__a & (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_or_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a | (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_xor_ps(__m128 __a, __m128 __b) {
	return (__m128)((__v4si)__a ^ (__v4si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpeq_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpeqss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpeq_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpeqps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmplt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmplt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmple_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpless(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmple_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpleps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpgt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpltps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpge_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpleps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpneq_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpneqss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpneq_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpneqps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnlt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnlt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnle_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnless(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnle_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnleps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpngt_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnltps(__b, __a);
}


#   ifdef COMPILER_CLANG
LIB_FUNC __m128 BUILD_SSE _mm_cmpgt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpltss(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpge_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpless(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpngt_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpnltss(__b, __a), 4, 1, 2, 3);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpnge_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_shufflevector(__a, __builtin_ia32_cmpnless(__b, __a), 4, 1, 2, 3);
}
#   endif


LIB_FUNC __m128 BUILD_SSE _mm_cmpnge_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpnleps(__b, __a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpord_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpordss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpord_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpordps(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpunord_ss(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpunordss(__a, __b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cmpunord_ps(__m128 __a, __m128 __b) {
	return (__m128)__builtin_ia32_cmpunordps(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comieq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comieq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comilt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comilt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comile_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comile(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comigt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comigt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comige_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comige(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_comineq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_comineq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomieq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomieq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomilt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomilt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomile_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomile(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomigt_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomigt(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomige_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomige(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_ucomineq_ss(__m128 __a, __m128 __b) {
	return __builtin_ia32_ucomineq(__a, __b);
}


LIB_FUNC int BUILD_SSE _mm_cvtss_si32(__m128 __a) {
	return __builtin_ia32_cvtss2si(__a);
}


LIB_FUNC int BUILD_SSE _mm_cvt_ss2si(__m128 __a) {
	return _mm_cvtss_si32(__a);
}


#   ifdef ARCHX86_64
LIB_FUNC long long BUILD_SSE _mm_cvtss_si64(__m128 __a) {
	return __builtin_ia32_cvtss2si64(__a);
}
#   endif


LIB_FUNC __m64 BUILD_SSE _mm_cvtps_pi32(__m128 __a) {
	return (__m64)__builtin_ia32_cvtps2pi(__a);
}


LIB_FUNC __m64 BUILD_SSE _mm_cvt_ps2pi(__m128 __a) {
	return _mm_cvtps_pi32(__a);
}


LIB_FUNC int BUILD_SSE _mm_cvttss_si32(__m128 __a) {
	return (int)__a[0];
}


LIB_FUNC int BUILD_SSE _mm_cvtt_ss2si(__m128 __a) {
	return _mm_cvttss_si32(__a);
}


LIB_FUNC long long BUILD_SSE _mm_cvttss_si64(__m128 __a) {
	return (long long)__a[0];
}


LIB_FUNC __m64 BUILD_SSE _mm_cvttps_pi32(__m128 __a) {
	return (__m64)__builtin_ia32_cvttps2pi(__a);
}


LIB_FUNC __m64 BUILD_SSE _mm_cvtt_ps2pi(__m128 __a) {
	return _mm_cvttps_pi32(__a);
}


LIB_FUNC __m128 BUILD_SSE _mm_cvtsi32_ss(__m128 __a, int __b) {
	__a[0] = (float)__b;
	return __a;
}


LIB_FUNC __m128 BUILD_SSE _mm_cvt_si2ss(__m128 __a, int __b) {
	return _mm_cvtsi32_ss(__a, __b);
}


#   ifdef ARCHX86_64
LIB_FUNC __m128 BUILD_SSE _mm_cvtsi64_ss(__m128 __a, long long __b) {
	__a[0] = (float)__b;
	return __a;
}
#endif


LIB_FUNC __m128 BUILD_SSE _mm_cvtpi32_ps(__m128 __a, __m64 __b) {
	return __builtin_ia32_cvtpi2ps(__a, (__v2si)__b);
}


LIB_FUNC __m128 BUILD_SSE _mm_cvt_pi2ps(__m128 __a, __m64 __b) {
	return _mm_cvtpi32_ps(__a, __b);
}


LIB_FUNC float BUILD_SSE _mm_cvtss_f32(__m128 __a) {
	return __a[0];
}
#endif


#endif  // X86_EXTENSIONS_SEEN


/* POWERPC INTRINSICS */


#if ((!(defined(_PPU_INTRINSICS_H) || defined(POWERPC_INTRINSICS))) && (defined(POWERPC) || defined(POWERPC64)))
#define POWERPC_INTRINSICS   (1)
#define _PPU_INTRINSICS_H   (1)


/* SINGLE TOKEN VECTOR DATATYPES FOR THE POWERPC SIMD/VECTOR MULTI-MEDIA EXTENSION */


#if (!(defined(_VEC_TYPES_H) || defined(_VEC_TYPES_H_)))
#define _VEC_TYPES_H   (1)
#define _VEC_TYPES_H_   (1)


#define qword   ATTR_VECTOR unsigned char
#define vec_uchar16   ATTR_VECTOR unsigned char
#define vec_char16   ATTR_VECTOR signed char
#define vec_bchar16   ATTR_VECTOR bool char
#define vec_ushort8   ATTR_VECTOR unsigned short
#define vec_short8   ATTR_VECTOR signed short
#define vec_bshort8   ATTR_VECTOR bool short
// TODO: #define vec_pixel8   ATTR_VECTOR pixel
#define vec_uint4   ATTR_VECTOR unsigned int
#define vec_int4   ATTR_VECTOR signed int
#define vec_bint4   ATTR_VECTOR bool int
#define vec_float4   ATTR_VECTOR float
#define vec_ullong2   ATTR_VECTOR bool char
#define vec_llong2   ATTR_VECTOR bool short
#define vec_double2   ATTR_VECTOR bool int


#endif  // VEC_TYPES_H


/* SYNERGISTIC PROCESSING UNIT (SPU) DEFINITIONS */


#ifndef _SPU_INTRINSICS_H
#define _SPU_INTRINSICS_H   (1)


// SPU CHANNEL DEFINES

#define SPU_RdEventStat   0
#define SPU_WrEventMask   1
#define SPU_WrEventAck   2
#define SPU_RdSigNotify1   3
#define SPU_RdSigNotify2   4
#define SPU_WrDec   7
#define SPU_RdDec   8
#define SPU_RdEventMask   11
#define SPU_RdMachStat   13
#define SPU_WrSRR0   14
#define SPU_RdSRR0   15
#define SPU_WrOutMbox   28
#define SPU_RdInMbox   29
#define SPU_WrOutIntrMbox   30


// MFC CHANNEL DEFINES

#define MFC_WrMSSyncReq   9
#define MFC_RdTagMask   12
#define MFC_LSA   16
#define MFC_EAH   17
#define MFC_EAL   18
#define MFC_Size   19
#define MFC_TagID   20
#define MFC_Cmd   21
#define MFC_WrTagMask   22
#define MFC_WrTagUpdate   23
#define MFC_RdTagStat   24
#define MFC_RdListStallStat   25
#define MFC_WrListStallAck   26
#define MFC_RdAtomicStat   27


// BIT FLAG MNEMONICS FOR TEST SPECIAL VALUE

/** Negative denormalized number */
#define SPU_SV_NEG_DENORM   1
/** Positive denormalized number */
#define SPU_SV_POS_DENORM   2
/** Negative zero */
#define SPU_SV_NEG_ZERO   4
/** Positive zero */
#define SPU_SV_POS_ZERO   8
/** Negative infinity */
#define SPU_SV_NEG_INFINITY   0x10
/** Positive infinity */
#define SPU_SV_POS_INFINITY   0x20
/** Not a number */
#define SPU_SV_NAN   0x40


#endif  // SPU_INTRINSICS_H


LIB_FUNC int mulhw(a, b) {
	int result;
	asm ("mulhw %0, %1, %2;"  : "=r"(result) : "r"((int)(a)), "r"((int)(b)));
	return result;
}
#define __mulhw(a, b)   mulhw((a), (b))


LIB_FUNC unsigned int mulhwu(a, b) {
	unsigned int result;
	asm ("mulhwu %0, %1, %2;" : "=r"(result) : "r"((unsigned int)(a)), "r"((unsigned int)(b)));
	return result;
}
#define __mulhwu(a, b)   mulhwu((a), (b))


#ifdef POWERPC64

LIB_FUNC long long mulhd(a, b) {
	long long result;
	asm ("mulhd %0, %1, %2;" : "=r"(result) : "r"((long long)(a)), "r"((long long)(b)));
	return result;
}
#define __mulhd(a, b)   mulhd((a), (b))


LIB_FUNC unsigned long long mulhdu(a, b) {
	unsigned long long result;
	asm ("mulhdu %0, %1, %2;" : "=r"(result) : "r"((unsigned long long)(a)), "r"((unsigned long long)(b)));
	return result;
}
#define __mulhdu(a, b)   mulhdu((a), (b))

#endif


#ifndef
#   define __sync()   asm volatile ("sync;" : : : "memory")
#endif
#define __isync()   asm volatile ("isync;" : : : "memory")
#define __lwsync()   asm volatile ("lwsync;" : : : "memory")
#define __eieio()   asm volatile ("eieio;" : : : "memory")
#define __nop()   asm volatile ("ori 0, 0, 0;" : : : "memory")
#define __cctpl()   asm volatile ("or 1, 1, 1;" : : : "memory")
#define __cctpm()   asm volatile ("or 2, 2, 2;" : : : "memory")
#define __cctph()   asm volatile ("or 3, 3, 3;" : : : "memory")
#define __db8cyc()   asm volatile ("or 28, 28, 28;" : : : "memory")
#define __db10cyc()   asm volatile ("or 29, 29, 29;" : : : "memory")
#define __db12cyc()   asm volatile ("or 30, 30, 30;" : : : "memory")
#define __db16cyc()   asm volatile ("or 31, 31, 31;" : : : "memory")
#define __dcbf(base)   asm volatile ("dcbf %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbz(base)   asm volatile ("dcbz %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbst(base)   asm volatile ("dcbst %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbtst(base)   asm volatile ("dcbtst %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __dcbt(base)   asm volatile ("dcbt %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")
#define __icbi(base)   asm volatile ("icbi %y0;" : "=Z"(*(__V4SI*)(base)) : : "memory")


#endif  // POWERPC INTRINSICS


/* FLOAT-POINT ENVIRONMENT (<fenv.h>) */


#if (!(defined(FENV_H) || defined(_FENV_H) || defined(_FENV_H_) || defined(_FENV_LIBC_H) || defined(_FENV_LIBC_H_) || defined(FENV_PRIVATE_H) || defined(FENV_PRIVATE_H_) || defined(_FENV_PRIVATE_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fenv.h.html & http://www.cplusplus.com/reference/cfenv/
#define FENV_H   (1)
#define _FENV_H   (1)
#define _FENV_H_   (1)
#define _FENV_LIBC_H   (1)
#define _FENV_LIBC_H_   (1)
#define FENV_PRIVATE_H   (1)
#define FENV_PRIVATE_H_   (1)
#define _FENV_PRIVATE_H_   (1)
#define _LIBM_H   (1)
#define _LIBM_H_   (1)
#define __ZMATH_H   (1)
#define _ZMATH_H   (1)
#define _ZMATH_H_   (1)


// FLOAT-POINT UNIT CONTROL (<fpu_control.h>)


#if (!(defined(_FPU_CONTROL_H) || defined(_FPU_CONTROL_H_) || defined(FPU_CONTROL_H) || defined(FPU_CONTROL_H_)))
#define _FPU_CONTROL_H   (1)
#define _FPU_CONTROL_H_   (1)
#define FPU_CONTROL_H   (1)
#define FPU_CONTROL_H_   (1)


#if (defined(M68K) || defined(MIPS))
/** FPU Control Word Datatype */
typedef unsigned int __attribute__((__mode__(__SI__)))   fpu_control_t;
#elif defined(SPARC)
/** FPU Control Word Datatype */
typedef unsigned long   fpu_control_t;
#elif (defined(X86) || defined(X86_64) || defined(I386))
/** FPU Control Word Datatype */
typedef unsigned int __attribute__((__mode__(__HI__)))   fpu_control_t;
#else
/** FPU Control Word Datatype */
typedef unsigned int   fpu_control_t;
#endif
#define __fpu_control_t   fpu_control_t
/** Default control word set at startup */
extern UNUSED fpu_control_t fpu_control;
#define __fpu_control   fpu_control


#ifdef ALPHA


#define _FPU_MASK_IM   1
#define _FPU_MASK_DM   2
#define _FPU_MASK_ZM   4
#define _FPU_MASK_OM   8
#define _FPU_MASK_UM   0x10
#define _FPU_MASK_PM   0x20
#define _FPU_EXTENDED   0x300
#define _FPU_DOUBLE   0x200
#define _FPU_SINGLE   0
#define _FPU_RC_NEAREST   0
#define _FPU_RC_DOWN   0x400
#define _FPU_RC_UP   0x800
#define _FPU_RC_ZERO   0xC00
/** Reserved bits in cw */
#define _FPU_RESERVED   0xF0C0
#define _FPU_DEFAULT   0x137f
#define _FPU_IEEE   0x137f


#elif defined(ARM64)


// Macros for accessing the FPCR and FPSR
#define _FPU_GETCW(fpcr)   asm volatile ("mrs %0, fpcr;" : "=r"(fpcr))
#define _FPU_SETCW(fpcr)   asm volatile ("msr fpcr, %0;" : : "r"(fpcr))
#define _FPU_GETFPSR(fpsr)   asm volatile ("mrs %0, fpsr;" : "=r"(fpsr))
#define _FPU_SETFPSR(fpsr)   asm volatile ("msr fpsr, %0;" : : "r"(fpsr))
#define _FPU_RESERVED   0xfe0fe0ff
#define _FPU_FPSR_RESERVED  0x0fffffe0
#define _FPU_DEFAULT   0
#define _FPU_FPSR_DEFAULT   0
#define _FPU_FPCR_RM_MASK   0xc00000
#define _FPU_FPCR_MASK_IXE   0x1000
#define _FPU_FPCR_MASK_UFE   0x800
#define _FPU_FPCR_MASK_OFE   0x400
#define _FPU_FPCR_MASK_DZE   0x200
#define _FPU_FPCR_MASK_IOE   0x100
#define _FPU_FPCR_IEEE   (_FPU_DEFAULT  | _FPU_FPCR_MASK_IXE | _FPU_FPCR_MASK_UFE | _FPU_FPCR_MASK_OFE | _FPU_FPCR_MASK_DZE | _FPU_FPCR_MASK_IOE)
#define _FPU_FPSR_IEEE   0
typedef unsigned int   fpu_fpsr_t;


#elif defined(ARM)


#if (!(defined(_LIBC) && (!defined(_LIBC_TEST))) && CPU_SOFTFP)

#   define _FPU_RESERVED   0xffffffff
#   define _FPU_DEFAULT   0
#else
/** Invalid operation */
#   define _FPU_MASK_IM   0x100
/** Divide by zero */
#   define _FPU_MASK_ZM   0x200
/** Overflow */
#   define _FPU_MASK_OM   0x400
/** Underflow */
#   define _FPU_MASK_UM   0x800
/** Inexact */
#   define _FPU_MASK_PM   0x1000
/** NZCV flags */
#   define _FPU_MASK_NZCV   0xf0000000
/** Rounding mode */
#   define _FPU_MASK_RM   0xc00000
/** All exception flags */
#   define _FPU_MASK_EXCEPT   0x1f1f
#   define _FPU_RESERVED   0x86060
#   define _FPU_DEFAULT   0
/** Default + exceptions enabled */
#   define _FPU_IEEE   (_FPU_DEFAULT | 0x1f00)
/** Macros for accessing the hardware control word */
#   define _FPU_GETCW(cw)   asm volatile ("mrc p10, 7, %0, cr1, cr0, 0;" : "=r"(cw))
#   define _FPU_SETCW(cw)   asm volatile ("mcr p10, 7, %0, cr1, cr0, 0;" : : "r"(cw))

#endif  // SOFTFP


#elif defined(HPPA)


/** Inexact (I) */
#define _FPU_MASK_PM   1
/** Underflow (U) */
#define _FPU_MASK_UM   2
/** Overflow (O) */
#define _FPU_MASK_OM   4
/** Divide by zero (Z) */
#define _FPU_MASK_ZM   8
/** Invalid operation (V) */
#define _FPU_MASK_IM   0x10
/** Rounding mode mask */
#define _FPU_HPPA_MASK_RM   0x600
/** Interrupt mask */
#define _FPU_HPPA_MASK_INT   0x1f
#define _FPU_HPPA_SHIFT_FLAGS   27
/** There are no reserved bits in the PA fpsr (though some are undefined) */
#define _FPU_RESERVED   0
/** Default is: No traps enabled, no flags set, round to nearest */
#define _FPU_DEFAULT   0
/** Default + exceptions (FE_ALL_EXCEPT) enabled */
#define _FPU_IEEE   (_FPU_DEFAULT | _FPU_HPPA_MASK_INT)
/** Get the current status word */
#define _FPU_GETCW(cw)   ({ union { __extension__ unsigned long long __fpreg; unsigned int __halfreg[2]; } __fullfp; asm ("fstd %%fr0, 0(%1);" "fldd 0(%1), %%fr0;" : "=m"(__fullfp.__fpreg) : "r"(&__fullfp.__fpreg) : "%r0"); cw = __fullfp.__halfreg[0];
})
/** Get the current status word and set the control word */
#define _FPU_SETCW(cw)   ({ union { __extension__ unsigned long long __fpreg; unsigned int __halfreg[2]; } __fullfp; asm ("fstd %%fr0, 0(%1);" : "=m"(__fullfp.__fpreg) : "r"(&__fullfp.__fpreg) : "%r0"); __fullfp.__halfreg[0] = cw; asm ("fldd 0(%1), %%fr0;" : : "m"(__fullfp.__fpreg), "r"(&__fullfp.__fpreg) : "%r0" );
})


#elif defined(M68K)


#if (defined(COLDFIRE) && (!defined(__mcffpu__)))
#   define _FPU_RESERVED   0xffffffff
#   define _FPU_DEFAULT    0
#   define _FPU_GETCW(cw)   ((cw) = 0)
#   define _FPU_SETCW(cw)   ((void)(cw))
#else
#   define _FPU_MASK_BSUN   0x8000
#   define _FPU_MASK_SNAN   0x4000
#   define _FPU_MASK_OPERR   0x2000
#   define _FPU_MASK_OVFL   0x1000
#   define _FPU_MASK_UNFL   0x800
#   define _FPU_MASK_DZ   0x400
#   define _FPU_MASK_INEX1   0x200
#   define _FPU_MASK_INEX2   0x100
#   ifdef COLDFIRE
#      define _FPU_DOUBLE   0
#   else
#      define _FPU_EXTENDED   0
#      define _FPU_DOUBLE   0x80
#   endif
#   define _FPU_SINGLE   0x40
#   define _FPU_RC_NEAREST   0
#   define _FPU_RC_ZERO   0x10
#   define _FPU_RC_DOWN   0x20
#   define _FPU_RC_UP   0x30
#   ifdef COLDFIRE
/** Reserved bits in fpucr */
#      define _FPU_RESERVED   0xFFFF800F
#   else
/** Reserved bits in fpucr */
#      define _FPU_RESERVED   0xFFFF000F
#   endif
#   define _FPU_DEFAULT   0
#   define _FPU_IEEE   1
/** Macros for accessing the hardware control word */
#   define _FPU_GETCW(cw)   asm ("fmove%.l %!, %0;" : "=dm"(cw))
#   define _FPU_SETCW(cw)   asm volatile ("fmove%.l %0, %!;" : : "dm"(cw))
#endif


#elif defined(MIPS)


#ifdef __mips_soft_float
#   define _FPU_RESERVED   0xffffffff
#   define _FPU_DEFAULT   0
#else
/** Invalid operation */
#   define _FPU_MASK_V   0x800
/** Division by zero */
#   define _FPU_MASK_Z   0x400
/** Overflow */
#   define _FPU_MASK_O   0x200
/** Underflow */
#   define _FPU_MASK_U   0x100
/** Inexact operation */
#   define _FPU_MASK_I   0x80
/** Flush denormalized numbers to zero */
#   define _FPU_FLUSH_TZ   0x1000000
/** IEEE 754-2008 compliance control */
#   define _FPU_ABS2008   0x80000
#   define _FPU_NAN2008   0x40000
#   define _FPU_RC_NEAREST   0
#   define _FPU_RC_ZERO   1
#   define _FPU_RC_UP   2
#   define _FPU_RC_DOWN   3
/** Mask for rounding control */
#   define _FPU_RC_MASK   3
#   define _FPU_RESERVED   0xfe8c0000
#   ifdef __mips_nan2008
#      define _FPU_DEFAULT   0xC0000
#   else
#      define _FPU_DEFAULT   0
#   endif
#   ifdef __mips_nan2008
#      define _FPU_IEEE   0xC0F80
#   else
#      define _FPU_IEEE   0xF80
#   endif
#   ifdef __mips16
#      define _FPU_GETCW(cw)   do { (cw) = __mips_fpu_getcw(); } while (0x0)
#      define _FPU_SETCW(cw)   __mips_fpu_setcw(cw)
#   else
#      define _FPU_GETCW(cw)   asm volatile ("cfc1 %0, $31;" : "=r"(cw))
#      define _FPU_SETCW(cw)   asm volatile ("ctc1 %0, $31;" : : "r"(cw))
#   endif
#endif  // mips_soft_float


#elif defined(SUPERH)


#ifndef __SH_FPU_ANY__
#   define _FPU_RESERVED   0xffffffff
#   define _FPU_DEFAULT   0
#else
/** Invalid operation */
#   define _FPU_MASK_VM   0x800
/** Division by zero */
#   define _FPU_MASK_ZM   0x400
/** Overflow */
#   define _FPU_MASK_OM   0x200
/** Underflow */
#   define _FPU_MASK_UM   0x100
/** Inexact operation */
#   define _FPU_MASK_IM   0x80
#   define _FPU_RC_NEAREST   0
#   define _FPU_RC_ZERO   1
/** These bits are reserved */
#   define _FPU_RESERVED   0xffc00000
/** Default value */
#   define _FPU_DEFAULT   0x80000
/** Default + exceptions enabled */
#   define _FPU_IEEE   0x80f80
/** Macros for accessing the hardware control word */
#   define _FPU_GETCW(cw)   asm ("sts fpscr, %0;" : "=r"(cw))
#   define _FPU_SETCW(cw)   asm ("lds %0, fpscr;" : : "r"(cw))
#   define __set_fpscr(cw)   asm ("lds %0, fpscr;" : : "r"(cw))
#endif  // SH_FPU_ANY


#elif (defined(S390) || defined(S390X))


#define _FPU_RESERVED   0x0707FFFC
/** Default value */
#define _FPU_DEFAULT   0
#define _FPU_GETCW(cw)   asm volatile ("efpc %0, 0;" : "=d"(cw))
#define _FPU_SETCW(cw)   asm volatile ("sfpc %0, 0;" : : "d"(cw))


#elif defined(SPARC)


#define _FPU_MASK_IM   0x8000000
#define _FPU_MASK_OM   0x4000000
#define _FPU_MASK_UM   0x2000000
#define _FPU_MASK_ZM   0x1000000
#define _FPU_MASK_PM   0x800000
#define _FPU_EXTENDED   0
#define _FPU_DOUBLE   0x20000000
#define _FPU_80BIT   0x30000000
#define _FPU_SINGLE   0x10000000
#define _FPU_RC_DOWN   0xc0000000
#define _FPU_RC_UP   0x80000000
#define _FPU_RC_ZERO   0x40000000
#define _FPU_RC_NEAREST   0
/** Reserved bits in cw */
#define _FPU_RESERVED   0x30300000
#define _FPU_DEFAULT   0
#define _FPU_IEEE   0
#if WORDSIZE_IS_64
#   define _FPU_GETCW(cw)   asm volatile ("stx %%fsr, %0;" : "=m"(*&cw))
#   define _FPU_SETCW(cw)   asm volatile ("ldx %0, %%fsr;" : : "m"(*&cw))
#else
#   define _FPU_GETCW(cw)   asm volatile ("st %%fsr, %0;" : "=m"(*&cw))
#   define _FPU_SETCW(cw)   asm volatile ("ld %0, %%fsr;" : : "m"(*&cw))
#endif


#elif defined(POWERPC)


#ifdef _SOFT_FLOAT
#   define _FPU_RESERVED   0xffffffff
#   define _FPU_DEFAULT   0
#elif defined(__NO_FPRS__)  // e500
#   define _FPU_RC_NEAREST   0
#   define _FPU_RC_DOWN   3
#   define _FPU_RC_UP   2
#   define _FPU_RC_ZERO   1
/** Zero divide */
#   define _FPU_MASK_ZM   0x10
/** Overflow */
#   define _FPU_MASK_OM   4
/** Underflow */
#   define _FPU_MASK_UM   8
/** Inexact */
#   define _FPU_MASK_XM   0x40
/** Invalid operation */
#   define _FPU_MASK_IM   0x20
/** These bits are reserved and not changed */
#   define _FPU_RESERVED   0xc10080
#   define _FPU_DEFAULT   0x3c
#   define _FPU_IEEE   _FPU_DEFAULT
#   define _FPU_GETCW(cw)   asm volatile ("mfspefscr %0;" : "=r"(cw))
#   define _FPU_SETCW(cw)   asm volatile ("mtspefscr %0;" : : "r"(cw))
#else  // PowerPC 6xx floating-point
#   define _FPU_RC_NEAREST   0
#   define _FPU_RC_DOWN   3
#   define _FPU_RC_UP   2
#   define _FPU_RC_ZERO   1
#   define _FPU_MASK_NI   4
/** Zero divide */
#   define _FPU_MASK_ZM   0x10
/** Overflow */
#   define _FPU_MASK_OM   0x40
/** Underflow */
#   define _FPU_MASK_UM   0x20
/** Inexact */
#   define _FPU_MASK_XM   8
/** Invalid operation */
#   define _FPU_MASK_IM   0x80
#   define _FPU_RESERVED   0xffffff00
#   define _FPU_DEFAULT   0
#   define _FPU_IEEE   0xf0
/** Macros for accessing the hardware control word */
#   define _FPU_GETCW(cw)   ({ union { double __d; unsigned long long __ll; } __u; register double __fr; asm ("mffs %0;" : "=f"(__fr)); __u.__d = __fr; (cw) = (fpu_control_t) __u.__ll; (fpu_control_t) __u.__ll; })
#   define _FPU_SETCW(cw)   ({ union { double __d; unsigned long long __ll; } __u; register double __fr; __u.__ll = 0xfff80000LL << 32; __u.__ll |= (cw) & 0xffffffffLL; __fr = __u.__d; asm ("mtfsf 255, %0;" : : "f"(__fr)); })
#endif


#elif (defined(X86) || defined(X86_64) || defined(I386))


#define _FPU_MASK_IM   1
#define _FPU_MASK_DM   2
#define _FPU_MASK_ZM   4
#define _FPU_MASK_OM   8
#define _FPU_MASK_UM   0x10
#define _FPU_MASK_PM   0x20
#define _FPU_EXTENDED   0x300
#define _FPU_DOUBLE   0x200
#define _FPU_SINGLE   0
#define _FPU_RC_NEAREST  0
#define _FPU_RC_DOWN   0x400
#define _FPU_RC_UP   0x800
#define _FPU_RC_ZERO   0xC00
#define _FPU_RESERVED   0xF0C0
#define _FPU_DEFAULT   0x37f
#define _FPU_IEEE   0x37f
#define _FPU_GETCW(cw)   asm volatile ("fnstcw %0;" : "=m"(*&cw))
#define _FPU_SETCW(cw)   asm volatile ("fldcw %0;" : : "m"(*&cw))


#else
#   error   "Add FPU Control code for the target platform."
#endif


#if (defined(X86) || defined(X86_64))


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
#define FPFTZ   (0x8000)
#define FPINEX   (0x1000)
#define FPUNFL   (0x800)
#define FPOVFL   (0x400)
#define FPZDIV   (0x200)
#define FPDNRM   (0x100)
#define FPINVAL   (0x80)
#define FPDAZ   (0x40)
#define FPRNR   (0x0)
#define FPRZ   (0x6000)
#define FPRPINF   (0x4000)
#define FPRNINF   (0x2000)
#define FPRMASK   (0x6000)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPAINEX   (0x20)
#define FPAUNFL   (0x10)
#define FPAOVFL   (8)
#define FPAZDIV   (4)
#define FPADNRM   (2)
#define FPAINVAL   (1)


#elif defined(I386)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
#define FPINEX   (0x20)
#define FPUNFL   (0x12)
#define FPOVFL   (8)
#define FPZDIV   (4)
#define FPINVAL   (1)
#define FPRNR   (0)
#define FPRZ   (0xc00)
#define FPRPINF   (0x800)
#define FPRNINF   (0x400)
#define FPRMASK   (0xc00)
#define FPPEXT   (0x300)
#define FPPSGL   (0)
#define FPPDBL   (0x200)
#define FPPMASK   (0x300)
#define FPAINEX   FPINEX
#define FPAOVFL   FPOVFL
#define FPAUNFL   FPUNFL
#define FPAZDIV   FPZDIV
#define FPAINVAL   FPINVAL


#elif defined(ARM)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
#define FPINEX   (0x1000)
#define FPUNFL   (0x800)
#define FPOVFL   (0x400)
#define FPZDIV   (0x200)
#define FPINVAL   (0x100)
#define FPRNR   (0)
#define FPRZ   (0x400000)
#define FPRPINF   (0x800000)
#define FPRNINF   (0xc00000)
#define FPRMASK   (0xc00000)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPAINEX   (0x10)
#define FPAUNFL   (8)
#define FPAOVFL   (4)
#define FPAZDIV   (2)
#define FPAINVAL   (1)


#elif defined(MIPS)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
#define FPINEX   (0x80)
#define FPUNFL   (0x100)
#define FPOVFL   (0x200)
#define FPZDIV   (0x400)
#define FPINVAL   (0x800)
#define FPRNR   (0)
#define FPRZ   (1)
#define FPRPINF   (2)
#define FPRNINF   (3)
#define FPRMASK   (3)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPCOND   (0x800000)
#define FPAINEX   (4)
#define FPAOVFL   (0x10)
#define FPAUNFL   (8)
#define FPAZDIV   (0x20)
#define FPAINVAL   (0x40)


#elif defined(POWERPC64)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
/** Exception summary (sticky) */
#define FPSFX   (0x80000000)
/** Enabled exception summary */
#define FPSEX   (0x40000000)
/** Invalid operation exception summary */
#define FPSVX   (0x20000000)
/** Overflow exception OX (sticky) */
#define FPSOX   (0x10000000)
/** Underflow exception UX (sticky) */
#define FPSUX   (0x8000000)
/** Zero divide exception ZX (sticky) */
#define FPSZX   (0x4000000)
/** Inexact exception XX (sticky) */
#define FPSXX   (0x2000000)
/** Invalid operation exception for SNaN (sticky) */
#define FPSVXSNAN   (0x1000000)
/** Invalid operation exception for ∞-∞ (sticky) */
#define FPSVXISI   (0x800000)
/** Invalid operation exception for ∞/∞ (sticky) */
#define FPSVXIDI   (0x400000)
/** Invalid operation exception for 0/0 (sticky) */
#define FPSVXZDZ   (0x200000)
/** Invalid operation exception for ∞*0 (sticky) */
#define FPSVXIMZ   (0x100000)
/** Invalid operation exception for invalid compare (sticky) */
#define FPSVXVC   (0x80000)
/** Fraction rounded */
#define FPSFR   (0x40000)
/** Fraction inexact */
#define FPSFI   (0x20000)
/** Floating point result class */
#define FPSFPRF   (0x10000)
/** <, >, =, unordered */
#define FPSFPCC   (0xf000)
/** Enable exception for invalid integer convert (sticky) */
#define FPVXCVI   (0x100)
/** Invalid operation exception enable */
#define FPVE   (0x80)
/** Enable overflow exceptions */
#define FPOVFL   (0x40)
/** Enable underflow */
#define FPUNFL   (0x20)
/** Enable zero divide */
#define FPZDIV   (0x10)
/** Enable inexact exceptions */
#define FPINEX   (8)
/** Rounding mode */
#define FPRMASK   (3)
#define FPRNR   (0)
#define FPRZ   (1)
#define FPRPINF   (2)
#define FPRNINF   (3)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPINVAL   FPVE
#define FPAOVFL   FPSOX
#define FPAINEX   FPSXX
#define FPAUNFL   FPSUX
#define FPAZDIV   FPSZX
#define FPAINVAL   FPSVX


#elif defined(POWERPC)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   0
#define FPSFX   (0x80000000)
#define FPSEX   (0x40000000)
#define FPSVX   (0x20000000)
#define FPSOX   (0x10000000)
#define FPSUX   (0x8000000)
#define FPSZX   (0x4000000)
#define FPSXX   (0x2000000)
#define FPSVXSNAN   (0x1000000)
#define FPSVXISI   (0x800000)
#define FPSVXIDI   (0x400000)
#define FPSVXZDZ   (0x200000)
#define FPSVXIMZ   (0x100000)
#define FPSVXVC   (0x80000)
#define FPSFR   (0x40000)
#define FPSFI   (0x20000)
#define FPSFPRF   (0x10000)
#define FPSFPCC   (0xf000)
#define FPVXCVI   (0x100)
#define FPVE   (0x80)
#define FPOVFL   (0x40)
#define FPUNFL   (0x20)
#define FPZDIV   (0x10)
#define FPINEX   (8)
#define FPRMASK   (3)
#define FPRNR   (0)
#define FPRZ   (1)
#define FPRPINF   (2)
#define FPRNINF   (3)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPINVAL   FPVE
#define FPAOVFL   FPSOX
#define FPAINEX   FPSXX
#define FPAUNFL   FPSUX
#define FPAZDIV   FPSZX
#define FPAINVAL   FPSVX


#elif defined(SPARC)


#define JMPBUFSP   0
#define JMPBUFPC   1
#define JMPBUFDPC   (-8)
#define FPINEX   (0x800000)
#define FPOVFL   (0x4000000)
#define FPUNFL   (0x2000000)
#define FPZDIV   (0x1000000)
#define FPRNR   (0)
#define FPRZ   (0x40000000)
#define FPINVAL   (0x8000000)
#define FPRPINF   (0x80000000)
#define FPRNINF   (0xc0000000)
#define FPRMASK   (0xc0000000)
#define FPPEXT   0
#define FPPSGL   0
#define FPPDBL   0
#define FPPMASK   0
#define FPAINEX   (0x20)
#define FPAZDIV   (0x40)
#define FPAUNFL   (0x80)
#define FPAOVFL   (0x100)
#define FPAINVAL   (0x200)


#endif  // ARCH


#ifndef _FPU_RESERVED
/** These bits are reserved and not changed */
#   define _FPU_RESERVED   (0xFFFFFFFF)
#endif
#ifndef FPU_RESERVED
/** These bits are reserved and not changed */
#   define FPU_RESERVED   _FPU_RESERVED
#endif
#ifndef _FPU_DEFAULT
/** The fdlibm code requires no interrupts for exceptions */
#   define _FPU_DEFAULT   (0)
#endif
#ifndef FPU_DEFAULT
/** The fdlibm code requires no interrupts for exceptions */
#   define FPU_DEFAULT   _FPU_DEFAULT
#endif
#ifndef _FPU_GETCW
/** Get hardware control word */
#   define _FPU_GETCW(ctrlword)   ((ctrlword) = 0)
#endif
#ifndef FPU_GETCW
/** Get hardware control word */
#   define FPU_GETCW(ctrlword)   _FPU_GETCW((ctrlword))
#endif
#ifndef _FPU_SETCW
/** Set hardware control word */
#   define _FPU_SETCW(ctrlword)   ((void)(ctrlword))
#endif
#ifndef FPU_SETCW
/** Set hardware control word */
#   define FPU_SETCW(ctrlword)   _FPU_SETCW((ctrlword))
#endif


#endif  // FPU_CONTROL_H


#ifndef HIGH_HALF
#   if IS_BIG_ENDIAN
#      define HIGH_HALF   (0)
#      define LOW_HALF   (1)
#   else  // LITTLE_ENDIAN
#      define HIGH_HALF   (1)
#      define LOW_HALF   (0)
#   endif
#endif  // HIGH_HALF


// FLOATING-POINT ROUNDING MODE (<get-rounding-mode.h>)


#if (!(defined(_GET_ROUNDING_MODE_H) || defined(_GET_ROUNDING_MODE_H_) || defined(GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_H_)))
#define _GET_ROUNDING_MODE_H   (1)
#define _GET_ROUNDING_MODE_H_   (1)
#define GET_ROUNDING_MODE_H   (1)
#define GET_ROUNDING_MODE_H_   (1)


#if ((!defined(ALPHA_MATH_PRIVATE_H)) && defined(ALPHA))
#define ALPHA_MATH_PRIVATE_H   (1)
#define _ALPHA_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define FPCR_ROUND_MASK   (3UL << 58)
#define FPCR_ROUND_SHIFT   58
#define SWCR_MAP_MASK   (3UL << 12)
#define SWCR_ENABLE_SHIFT   16
#define SWCR_ENABLE_MASK   (FE_ALL_EXCEPT >> SWCR_ENABLE_SHIFT)
#define SWCR_STATUS_MASK   (FE_ALL_EXCEPT)
#define SWCR_ALL_MASK   (SWCR_ENABLE_MASK | SWCR_MAP_MASK | SWCR_STATUS_MASK)


#endif  // ALPHA_MATH_PRIVATE_H


#if ((!defined(ARM_MATH_PRIVATE_H)) && (defined(ARM) || defined(AARCH64)))
#define ARM_MATH_PRIVATE_H   (1)
#define _ARM_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define LDBL_CLASSIFY_COMPAT   (1)
#if (CPU_SOFTFP == 0)
#   define HAVE_RM_CTX   (1)
#endif


#if ((!defined(AARCH64_MATH_PRIVATE_H)) && defined(AARCH64))
#define AARCH64_MATH_PRIVATE_H   (1)
#define _AARCH64_MATH_PRIVATE_H_   (1)


/** Support for rounding mode context */
#define HAVE_RM_CTX   (1)


typedef struct fenv_struct {
	union {
		struct whole_fpscr { unsigned int __fpscr, __reserved0, __reserved1, __reserved2; };
		struct attr_packed fpscr {
			unsigned int __fpscr_cmp_n:1;
			unsigned int __fpscr_cmp_z:1;
			unsigned int __fpscr_cmp_c:1;
			unsigned int __fpscr_cmp_v:1;
			unsigned int __fpscr_do_not_modify_1:2;
			unsigned int __fpscr_default_nan_mode:1;
			unsigned int __fpscr_flush_to_zero:1;
			unsigned int __fpscr_rounding_mode:2;
			unsigned int __fpscr_stride:2;
			unsigned int __fpscr_do_not_modify_2:1;
			unsigned int __fpscr_len:3;
			unsigned int __fpscr_trap_enable_subnormal:1;
			unsigned int __fpscr_do_not_modfify_3:2;
			unsigned int __fpscr_trap_enable_inexact:1;
			unsigned int __fpscr_trap_enable_underflow:1;
			unsigned int __fpscr_trap_enable_overflow:1;
			unsigned int __fpscr_trap_enable_div_by_zero:1;
			unsigned int __fpscr_trap_enable_invalid:1;
			unsigned int __fpscr_fp_state_flag_subnormal:1;
			unsigned int __fpscr_do_not_modify_4:2;
			unsigned int __fpscr_fp_state_flag_inexact:1;
			unsigned int __fpscr_fp_state_flag_underflow:1;
			unsigned int __fpscr_fp_state_flag_overflow:1;
			unsigned int __fpscr_fp_state_flag_div_by_zero:1;
			unsigned int __fpscr_fp_state_flag_invalid:1;
		};
	};
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


LIB_FUNC void libc_feholdexcept_aarch64(fenv_t* envp) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR(fpsr);
	envp->__fpcr = fpcr;
	envp->__fpsr = fpsr;
	// Clear exception flags and set all exceptions to non-stop
	new_fpcr = fpcr & ~(FE_ALL_EXCEPT << FE_EXCEPT_SHIFT);
	new_fpsr = fpsr & (~FE_ALL_EXCEPT);
	if (PREDICT_UNLIKELY(new_fpcr != fpcr)) { _FPU_SETCW(new_fpcr); }
	if (new_fpsr != fpsr) { _FPU_SETFPSR(new_fpsr); }
}
#define libc_feholdexcept   libc_feholdexcept_aarch64
#define libc_feholdexceptf   libc_feholdexcept_aarch64
#define libc_feholdexceptl   libc_feholdexcept_aarch64


LIB_FUNC void libc_fesetround_aarch64(int round) {
	fpu_control_t fpcr;
	_FPU_GETCW(fpcr);
	// Check whether rounding modes are different
	round = (fpcr ^ round) & _FPU_FPCR_RM_MASK;
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#define libc_fesetround   libc_fesetround_aarch64
#define libc_fesetroundf   libc_fesetround_aarch64
#define libc_fesetroundl   libc_fesetround_aarch64


LIB_FUNC void libc_feholdexcept_setround_aarch64(fenv_t* envp, int round) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR (fpsr);
	envp->__fpcr = fpcr;
	envp->__fpsr = fpsr;
	// Clear exception flags, set all exceptions to non-stop, and set new rounding mode
	new_fpcr = fpcr & ~((FE_ALL_EXCEPT << FE_EXCEPT_SHIFT) | _FPU_FPCR_RM_MASK);
	new_fpcr |= round;
	new_fpsr = fpsr & (~FE_ALL_EXCEPT);
	if (PREDICT_UNLIKELY(new_fpcr != fpcr)) { _FPU_SETCW(new_fpcr); }
	if (new_fpsr != fpsr) { _FPU_SETFPSR(new_fpsr); }
}
#define libc_feholdexcept_setround   libc_feholdexcept_setround_aarch64
#define libc_feholdexcept_setroundf   libc_feholdexcept_setround_aarch64
#define libc_feholdexcept_setroundl   libc_feholdexcept_setround_aarch64


LIB_FUNC int libc_fetestexcept_aarch64(int ex) {
	fpu_fpsr_t fpsr;
	_FPU_GETFPSR(fpsr);
	return ((fpsr & ex) & FE_ALL_EXCEPT);
}
#define libc_fetestexcept   libc_fetestexcept_aarch64
#define libc_fetestexceptf   libc_fetestexcept_aarch64
#define libc_fetestexceptl   libc_fetestexcept_aarch64


LIB_FUNC void libc_fesetenv_aarch64(const fenv_t* envp) {
	fpu_control_t fpcr, new_fpcr;
	_FPU_GETCW(fpcr);
	new_fpcr = envp->__fpcr;
	if (PREDICT_UNLIKELY(fpcr != new_fpcr)) { _FPU_SETCW(new_fpcr); }
	_FPU_SETFPSR(envp->__fpsr);
}
#define libc_fesetenv   libc_fesetenv_aarch64
#define libc_fesetenvf   libc_fesetenv_aarch64
#define libc_fesetenvl   libc_fesetenv_aarch64
#define libc_feresetround_noex   libc_fesetenv_aarch64
#define libc_feresetround_noexf   libc_fesetenv_aarch64
#define libc_feresetround_noexl   libc_fesetenv_aarch64


LIB_FUNC int libc_feupdateenv_test_aarch64(const fenv_t* envp, int ex) {
	fpu_control_t fpcr, new_fpcr;
	fpu_fpsr_t fpsr, new_fpsr;
	int excepts;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR (fpsr);
	// Merge current exception flags with the saved fenv
	excepts = fpsr & FE_ALL_EXCEPT;
	new_fpcr = envp->__fpcr;
	new_fpsr = envp->__fpsr | excepts;
	if (PREDICT_UNLIKELY(fpcr != new_fpcr)) { _FPU_SETCW(new_fpcr); }
	if (fpsr != new_fpsr) { _FPU_SETFPSR(new_fpsr); }
	// Raise the exceptions if enabled in the new FP state
	if (PREDICT_UNLIKELY(excepts & (new_fpcr >> FE_EXCEPT_SHIFT))) { __feraiseexcept(excepts); }
	return excepts & ex;
}
#define libc_feupdateenv_test   libc_feupdateenv_test_aarch64
#define libc_feupdateenv_testf   libc_feupdateenv_test_aarch64
#define libc_feupdateenv_testl   libc_feupdateenv_test_aarch64


LIB_FUNC void libc_feupdateenv_aarch64(const fenv_t* envp) {
	libc_feupdateenv_test_aarch64(envp, 0);
}
#define libc_feupdateenv   libc_feupdateenv_aarch64
#define libc_feupdateenvf   libc_feupdateenv_aarch64
#define libc_feupdateenvl   libc_feupdateenv_aarch64


LIB_FUNC void libc_feholdsetround_aarch64(fenv_t* envp, int round) {
	fpu_control_t fpcr;
	fpu_fpsr_t fpsr;
	_FPU_GETCW(fpcr);
	_FPU_GETFPSR(fpsr);
	envp->__fpcr = fpcr;
	envp->__fpsr = fpsr;
	// Check whether rounding modes are different
	round = (fpcr ^ round) & _FPU_FPCR_RM_MASK;
	//Set new rounding mode if different
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#define libc_feholdsetround   libc_feholdsetround_aarch64
#define libc_feholdsetroundf   libc_feholdsetround_aarch64
#define libc_feholdsetroundl   libc_feholdsetround_aarch64


LIB_FUNC void libc_feresetround_aarch64(fenv_t* envp) {
	fpu_control_t fpcr;
	int round;
	_FPU_GETCW(fpcr);
	// Check whether rounding modes are different
	round = (envp->__fpcr ^ fpcr) & _FPU_FPCR_RM_MASK;
	// Restore the rounding mode if it was changed
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpcr ^ round); }
}
#define libc_feresetround   libc_feresetround_aarch64
#define libc_feresetroundf   libc_feresetround_aarch64
#define libc_feresetroundl   libc_feresetround_aarch64


#endif  // AARCH64_MATH_PRIVATE_H


#if (defined(ARM) && (defined(__VFP_FP__) || IS_NOT_SOFTFP))  // ARM


typedef unsigned short   fexcept_t;


typedef struct fenv_struct {
	union {
		struct whole_fpscr { unsigned int __fpscr, __reserved0, __reserved1, __reserved2; };
		struct attr_packed fpscr {
			unsigned int __fpscr_cmp_n:1;
			unsigned int __fpscr_cmp_z:1;
			unsigned int __fpscr_cmp_c:1;
			unsigned int __fpscr_cmp_v:1;
			unsigned int __fpscr_do_not_modify_1:2;
			unsigned int __fpscr_default_nan_mode:1;
			unsigned int __fpscr_flush_to_zero:1;
			unsigned int __fpscr_rounding_mode:2;
			unsigned int __fpscr_stride:2;
			unsigned int __fpscr_do_not_modify_2:1;
			unsigned int __fpscr_len:3;
			unsigned int __fpscr_trap_enable_subnormal:1;
			unsigned int __fpscr_do_not_modfify_3:2;
			unsigned int __fpscr_trap_enable_inexact:1;
			unsigned int __fpscr_trap_enable_underflow:1;
			unsigned int __fpscr_trap_enable_overflow:1;
			unsigned int __fpscr_trap_enable_div_by_zero:1;
			unsigned int __fpscr_trap_enable_invalid:1;
			unsigned int __fpscr_fp_state_flag_subnormal:1;
			unsigned int __fpscr_do_not_modify_4:2;
			unsigned int __fpscr_fp_state_flag_inexact:1;
			unsigned int __fpscr_fp_state_flag_underflow:1;
			unsigned int __fpscr_fp_state_flag_overflow:1;
			unsigned int __fpscr_fp_state_flag_div_by_zero:1;
			unsigned int __fpscr_fp_state_flag_invalid:1;
		};
	};
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#define FE_INEXACT   (0x10)
#define FE_UNDERFLOW   (8)
#define FE_OVERFLOW   (4)
#define FE_DIVBYZERO   (2)
#define FE_INVALID   (1)
#define FE_ALL_EXCEPT   (0x1F)
#define FE_TONEAREST   (0)
#define FE_UPWARD   (0x400000)
#define FE_DOWNWARD   (0x800000)
#define FE_TOWARDZERO   (0xC00000)
#define FE_ALL_RND   (FE_TONEAREST | FE_TOWARDZERO | FE_UPWARD | FE_DOWNWARD)


extern const UNUSED fenv_t _FE_DFL_ENV = { { 0, 0, 0, 0 } };
/** Pointer to default FP environment */
#define FE_DFL_ENV   (&_FE_DFL_ENV)
#define GET_FPSCR()   do { uint32_t _fpscr; asm volatile ("fmrx %0, fpscr;" : "=r"(_fpscr)); _fpscr; } while (0x0)
#define SET_FPSCR(_fpscr)   asm volatile ("fmxr fpscr, %0;" : : "r"(_fpscr))


LIB_FUNC int _fesetexceptflag(const fexcept_t* flagp, const int excepts) {
	register uint32_t fpscr = GET_FPSCR();
	excepts &= (FE_ALL_EXCEPT | 0x8000);
	fpscr = ((fpscr & (~excepts)) | (*flagp & excepts));
	SET_FPSCR( fpscr );
	return 0;
}


LIB_FUNC int _fegetexceptflag(fexcept_t* flagp, const int excepts) {
	register uint32_t fpscr = GET_FPSCR();
	*flagp = (fpscr & excepts);
	return 0;
}
#define fegetexceptflag(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#define fesetexceptflag(flagp, excepts)   _fesetexceptflag((flagp), (excepts))
#define fegetexcept(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#define fesetexcept(flagp, excepts)   _fesetexceptflag((flagp), (excepts))


LIB_FUNC int feclearexcept(const int excepts) {
	fexcept_t zero = 0;
	return _fesetexceptflag(&zero, excepts);
}


LIB_FUNC int feraiseexcept(const int excepts) {
	register int inexact_set = 0;
	if (excepts & FE_OVERFLOW) {
		required_add_float(0x1.0p127f, 0x1.0p127f);
		inexact_set = 1;
	}
	if (excepts & FE_UNDERFLOW) {
		required_multiply_float(0x1.0p-126f, 0x1.0p-126f);
		inexact_set = 1;
	}
	if (excepts & FE_INVALID) { required_add_float(INFINITY, (-INFINITY)); }
	if (excepts & FE_DIVBYZERO) { required_divide_float(1.0F, 0.0F); }
	if (0 != (excepts & FE_INEXACT) && 0 == inexact_set) { required_add_float(0x1.0p127f, 1.0F); }
	return 0;
}


LIB_FUNC int fetestexcept(const int excepts) {
	fexcept_t t = 0;
	_fegetexceptflag(&t, excepts);
	return t;
}


LIB_FUNC int fegetround(void) {
	register int32_t fpscr = GET_FPSCR();
	return (int)(fpscr & FE_ALL_RND);
}


LIB_FUNC int fesetround(const int round) {
	if ((round & FE_ALL_RND) != round) { return round; }
	register int32_t fpscr = GET_FPSCR();
	fpscr = ((fpscr & (~FE_ALL_RND)) | (round & FE_ALL_RND));
	SET_FPSCR(fpscr);
	return 0;
}


LIB_FUNC int fegetenv(fenv_t* envp) {
	envp->__fpscr = GET_FPSCR();
	envp->__reserved0 = 0;
	envp->__reserved1 = 0;
	envp->__reserved2 = 0;
	return 0;
}


LIB_FUNC int feholdexcept(fenv_t* envp) {
	register uint32_t fpscr = GET_FPSCR();
	envp->__fpscr = fpscr;
	envp->__reserved0 = 0;
	envp->__reserved1 = 0;
	envp->__reserved2 = 0;
	fpscr &= (~(FE_ALL_EXCEPT | (FE_ALL_EXCEPT << 8)));
	SET_FPSCR(fpscr);
	return 0;
}


LIB_FUNC int fesetenv(const fenv_t* envp) {
	SET_FPSCR(envp->__fpscr);
	return 0;
}


LIB_FUNC int feupdateenv(const fenv_t* envp) {
	register uint32_t oldenv = GET_FPSCR();
	SET_FPSCR(envp->__fpscr);
	register int inexact_set = 0;
	if (oldenv & FE_OVERFLOW) {
		required_add_float(0x1.0p127f, 0x1.0p127f);
		inexact_set = 1;
	}
	if (oldenv & FE_UNDERFLOW) {
		required_multiply_float(0x1.0p-126f, 0x1.0p-126f);
		inexact_set = 1;
	}
	if (oldenv & FE_INVALID) { required_add_float(INFINITY, (-INFINITY)); }
	if (oldenv & FE_DIVBYZERO) { required_divide_float(1.0F, 0.0F); }
	if (0 != (oldenv & FE_INEXACT) && 0 == inexact_set) { required_add_float(0x1.0p127f, 1.0F); }
	return 0;
}


#endif


LIB_FUNC void libc_feholdexcept_vfp(fenv_t* envp) {
	fpu_control_t fpscr;
	_FPU_GETCW(fpscr);
	envp->__cw = fpscr;
	// Clear exception flags and set all exceptions to non-stop
	fpscr &= (~_FPU_MASK_EXCEPT);
	_FPU_SETCW(fpscr);
}


LIB_FUNC void libc_fesetround_vfp(int round) {
	fpu_control_t fpscr;
	_FPU_GETCW(fpscr);
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY((fpscr & _FPU_MASK_RM) != round)) { _FPU_SETCW((fpscr & (~_FPU_MASK_RM)) | round); }
}


LIB_FUNC void libc_feholdexcept_setround_vfp(fenv_t* envp, int round) {
	fpu_control_t fpscr;
	_FPU_GETCW(fpscr);
	envp->__cw = fpscr;
	// Clear exception flags, set all exceptions to non-stop, and set new rounding mode
	fpscr &= ~(_FPU_MASK_EXCEPT | _FPU_MASK_RM);
	_FPU_SETCW(fpscr | round);
}


LIB_FUNC void libc_feholdsetround_vfp (fenv_t* envp, int round) {
	fpu_control_t fpscr;
	_FPU_GETCW(fpscr);
	envp->__cw = fpscr;
	// Set new rounding mode if different
	if (PREDICT_UNLIKELY((fpscr & _FPU_MASK_RM) != round)) {
		_FPU_SETCW((fpscr & ~_FPU_MASK_RM) | round);
	}
}


LIB_FUNC void libc_feresetround_vfp(fenv_t* envp) {
	fpu_control_t fpscr, round;
	_FPU_GETCW(fpscr);
	// Check whether rounding modes are different
	round = (envp->__cw ^ fpscr) & _FPU_MASK_RM;
	// Restore the rounding mode if it was changed
	if (PREDICT_UNLIKELY(round != 0)) { _FPU_SETCW(fpscr ^ round); }
}


LIB_FUNC int libc_fetestexcept_vfp(int ex) {
	fpu_control_t fpscr;
	_FPU_GETCW(fpscr);
	return ((fpscr & ex) & FE_ALL_EXCEPT);
}


LIB_FUNC void libc_fesetenv_vfp(const fenv_t* envp) {
	fpu_control_t fpscr, new_fpscr;
	_FPU_GETCW(fpscr);
	new_fpscr = envp->__cw;
	// Write new FPSCR if different (ignoring NZCV flags)
	if (PREDICT_UNLIKELY(((fpscr ^ new_fpscr) & (~_FPU_MASK_NZCV)) != 0))
	_FPU_SETCW(new_fpscr);
}


LIB_FUNC int libc_feupdateenv_test_vfp(const fenv_t* envp, int ex) {
	fpu_control_t fpscr, new_fpscr;
	int excepts;
	_FPU_GETCW(fpscr);
	// Merge current exception flags with the saved fenv
	excepts = fpscr & FE_ALL_EXCEPT;
	new_fpscr = envp->__cw | excepts;
	// Write new FPSCR if different (ignoring NZCV flags)
	if (PREDICT_UNLIKELY(((fpscr ^ new_fpscr) & ~_FPU_MASK_NZCV) != 0)) {
		_FPU_SETCW(new_fpscr);
	}
	// Raise the exceptions if enabled in the new FP state
	if (PREDICT_UNLIKELY(excepts & (new_fpscr >> FE_EXCEPT_SHIFT))) {
		__feraiseexcept(excepts);
	}
	return excepts & ex;
}


LIB_FUNC void libc_feupdateenv_vfp(const fenv_t* envp) {
	libc_feupdateenv_test_vfp(envp, 0);
}


#if IS_NOT_SOFTFP
#   define libc_feholdexcept   libc_feholdexcept_vfp
#   define libc_feholdexceptf   libc_feholdexcept_vfp
#   define libc_feholdexceptl   libc_feholdexcept_vfp
#   define libc_fesetround   libc_fesetround_vfp
#   define libc_fesetroundf   libc_fesetround_vfp
#   define libc_fesetroundl   libc_fesetround_vfp
#   define libc_feresetround   libc_feresetround_vfp
#   define libc_feresetroundf   libc_feresetround_vfp
#   define libc_feresetroundl   libc_feresetround_vfp
#   define libc_feresetround_noex   libc_fesetenv_vfp
#   define libc_feresetround_noexf   libc_fesetenv_vfp
#   define libc_feresetround_noexl   libc_fesetenv_vfp
#   define libc_feholdexcept_setround   libc_feholdexcept_setround_vfp
#   define libc_feholdexcept_setroundf   libc_feholdexcept_setround_vfp
#   define libc_feholdexcept_setroundl   libc_feholdexcept_setround_vfp
#   define libc_feholdsetround   libc_feholdsetround_vfp
#   define libc_feholdsetroundf   libc_feholdsetround_vfp
#   define libc_feholdsetroundl   libc_feholdsetround_vfp
#   define libc_fetestexcept   libc_fetestexcept_vfp
#   define libc_fetestexceptf   libc_fetestexcept_vfp
#   define libc_fetestexceptl   libc_fetestexcept_vfp
#   define libc_fesetenv   libc_fesetenv_vfp
#   define libc_fesetenvf   libc_fesetenv_vfp
#   define libc_fesetenvl   libc_fesetenv_vfp
#   define libc_feupdateenv   libc_feupdateenv_vfp
#   define libc_feupdateenvf   libc_feupdateenv_vfp
#   define libc_feupdateenvl   libc_feupdateenv_vfp
#   define libc_feupdateenv_test   libc_feupdateenv_test_vfp
#   define libc_feupdateenv_testf   libc_feupdateenv_test_vfp
#   define libc_feupdateenv_testl   libc_feupdateenv_test_vfp
#endif


#endif  // ARM_MATH_PRIVATE_H


#if ((!defined(ITANIUM_MATH_PRIVATE_H)) && defined(ITANIUM))
#define ITANIUM_MATH_PRIVATE_H   (1)
#define _ITANIUM_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


typedef unsigned long   fexcept_t;
typedef unsigned long   fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#define FE_INEXACT   0x20UL
#define FE_UNDERFLOW   0x10UL
#define FE_OVERFLOW   8UL
#define FE_DIVBYZERO   4UL
#define FE_UNNORMAL   2UL
#define FE_INVALID   1UL
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW | FE_DIVBYZERO | FE_UNNORMAL | FE_INVALID)
#define FE_TOWARDZERO   3
#define FE_UPWARD   2
#define FE_DOWNWARD   1
#define FE_TONEAREST   0
#define FE_DFL_ENV   ((const fenv_t*)0xC009804C0270033FUL)


#endif  // ITANIUM_MATH_PRIVATE_H


#if ((!defined(MICROBLAZE_MATH_PRIVATE_H)) && defined(MICROBLAZE))
#define MICROBLAZE_MATH_PRIVATE_H   (1)
#define _MICROBLAZE_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define LDBL_CLASSIFY_COMPAT   (1)
#define libc_fesetround(rnd)   __extension__ ({ 0; })
#define libc_fetestexcept(exc)   __extension__ ({ 0; })
#define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#define feraiseexcept(excepts)   __extension__ ({ 0; })
#define __feraiseexcept(excepts)   __extension__ ({ 0; })
#define feclearexcept(exc)   __extension__ ({ 0; })


#endif  // MICROBLAZE_MATH_PRIVATE_H


#if ((!defined(MIPS_MATH_PRIVATE_H)) && defined(MIPS))
#define MIPS_MATH_PRIVATE_H   (1)
#define _MIPS_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define ENABLE_MASK   (0xF80U)
#define CAUSE_MASK   (0x1F000U)
#define ENABLE_SHIFT   (5)
#define CAUSE_SHIFT   (10)
#define LDBL_CLASSIFY_COMPAT   (1)
/** Enable support for rounding mode context */
#define HAVE_RM_CTX   (1)


#ifndef __mips_nan2008
/** MIPS is not aligned to IEEE 754-2008 */
#   define HIGH_ORDER_BIT_IS_SET_FOR_SNAN
#endif


#ifdef __mips_hard_float


#define _FPU_MASK_ALL   (_FPU_MASK_V | _FPU_MASK_Z | _FPU_MASK_O |_FPU_MASK_U | _FPU_MASK_I | FE_ALL_EXCEPT)


LIB_FUNC void libc_feholdexcept_mips(fenv_t* envp) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Save the current state
	envp->__fp_control_register = cw;
	cw &= (~(_FPU_MASK_ALL));  // Clear all exception enable bits and flags
	_FPU_SETCW (cw);
}
#define libc_feholdexcept   libc_feholdexcept_mips
#define libc_feholdexceptf   libc_feholdexcept_mips
#define libc_feholdexceptl   libc_feholdexcept_mips


LIB_FUNC void libc_fesetround_mips (int round) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Get current state
	cw &= (~_FPU_RC_MASK);  // Set rounding bits
	cw |= round;
	_FPU_SETCW(cw);  // // Set new state
}
#define libc_fesetround   libc_fesetround_mips
#define libc_fesetroundf   libc_fesetround_mips
#define libc_fesetroundl   libc_fesetround_mips


LIB_FUNC void libc_feholdexcept_setround_mips(fenv_t *envp, const int round) {
	fpu_control_t cw;
	_FPU_GETCW(cw);  // Save the current state
	envp->__fp_control_register = cw;
	cw &= (~(_FPU_MASK_ALL));  // Clear all exception enable bits and flags
	cw &= (~_FPU_RC_MASK);  // Set rounding bits
	cw |= round;
	_FPU_SETCW(cw);  // Set new state
}
#define libc_feholdexcept_setround   libc_feholdexcept_setround_mips
#define libc_feholdexcept_setroundf   libc_feholdexcept_setround_mips
#define libc_feholdexcept_setroundl   libc_feholdexcept_setround_mips
#define libc_feholdsetround   libc_feholdexcept_setround_mips
#define libc_feholdsetroundf   libc_feholdexcept_setround_mips
#define libc_feholdsetroundl   libc_feholdexcept_setround_mips


LIB_FUNC void libc_fesetenv_mips(fenv_t* envp) {
	UNUSED fpu_control_t cw;
	_FPU_GETCW(cw);  // Read current state to flush fpu pipeline
	_FPU_SETCW(envp->__fp_control_register);
}
#define libc_fesetenv   libc_fesetenv_mips
#define libc_fesetenvf   libc_fesetenv_mips
#define libc_fesetenvl   libc_fesetenv_mips


LIB_FUNC int libc_feupdateenv_test_mips(fenv_t* envp, const int excepts) {
	int cw, temp;
	_FPU_GETCW(cw);  // Get current control word
	temp = cw & FE_ALL_EXCEPT;
	temp |= (envp->__fp_control_register | (temp << CAUSE_SHIFT));
	_FPU_SETCW(temp);  // Set new state
	return ((cw & excepts) & FE_ALL_EXCEPT);
}
#define libc_feupdateenv_test   libc_feupdateenv_test_mips
#define libc_feupdateenv_testf   libc_feupdateenv_test_mips
#define libc_feupdateenv_testl   libc_feupdateenv_test_mips


LIB_FUNC void libc_feupdateenv_mips(fenv_t* envp) {
	libc_feupdateenv_test_mips(envp, 0);
}
#define libc_feupdateenv   libc_feupdateenv_mips
#define libc_feupdateenvf   libc_feupdateenv_mips
#define libc_feupdateenvl   libc_feupdateenv_mips
#define libc_feresetround   libc_feupdateenv_mips
#define libc_feresetroundf   libc_feupdateenv_mips
#define libc_feresetroundl   libc_feupdateenv_mips


LIB_FUNC int libc_fetestexcept_mips(const int excepts) {
	int cw;
	_FPU_GETCW(cw);  // Get current control word
	return ((cw & excepts) & FE_ALL_EXCEPT);
}
#define libc_fetestexcept   libc_fetestexcept_mips
#define libc_fetestexceptf   libc_fetestexcept_mips
#define libc_fetestexceptl   libc_fetestexcept_mips


#endif  // mips_hard_float



#endif  // MIPS_MATH_PRIVATE_H


#if ((!defined(NIO2_MATH_PRIVATE_H)) && defined(NIOS2))
#define NIO2_MATH_PRIVATE_H   (1)
#define _NIO2_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define LDBL_CLASSIFY_COMPAT   (1)
#define libc_fesetround(rnd)   __extension__ ({ 0; })
#define libc_fetestexcept(exc)   __extension__ ({ 0; })
#define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#define feraiseexcept(excepts)   __extension__ ({ 0; })
#define __feraiseexcept(excepts)   __extension__ ({ 0; })
#define feclearexcept(exc)   __extension__ ({ 0; })


#endif  // NIO2_MATH_PRIVATE_H


#if ((!defined(PPC_MATH_PRIVATE_H)) && defined(POWERPC))
#define PPC_MATH_PRIVATE_H   (1)
#define _PPC_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define HAVE_RM_CTX   (1)
#define _FPU_MASK_ALL   (_FPU_MASK_ZM | _FPU_MASK_OM | _FPU_MASK_UM | _FPU_MASK_XM | _FPU_MASK_IM)
/** Mask everything but the rounding moded and non-IEEE arithmetic flags */
#define _FPU_MASK_ROUNDING   0xffffffff00000007LL
/** Mask restore rounding mode and exception enabled */
#define _FPU_MASK_EXCEPT_ROUND   0xffffffff1fffff00LL
/** Mask exception enable but fraction rounded/inexact and FP result/CC bits */
#define _FPU_MASK_FRAC_INEX_RET_CC   0x1ff80fff


typedef unsigned int   fenv_t;
typedef unsigned int   fexcept_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#define FE_INEXACT   (0x2000000)
#define FE_DIVBYZERO   (0x4000000)
#define FE_UNDERFLOW   (0x8000000)
#define FE_OVERFLOW   (0x10000000)
#define FE_INVALID   (0x20000000)
#define FE_ALL_EXCEPT   (0x3E000000)
#define FE_TONEAREST   (0)
#define FE_TOWARDZERO   (1)
#define FE_UPWARD   (2)
#define FE_DOWNWARD   (3)
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
/** The sticky bits in the FPSCR indicating exceptions have occurred */
#define FPSCR_STICKY_BITS   ((FE_ALL_EXCEPT | FE_ALL_INVALID) & (~FE_INVALID))


/** Default FPU environment object */
extern const UNUSED fenv_t   _FE_DFL_ENV;
typedef union fenv_union {
	fenv_t fenv;
	unsigned long long l;
} fenv_union_t;


/** Definitions of all the SPEFSCR bit numbers */
enum SPEFSCR_BITS {
	SPEFSCR_SOVH = 0x80000000,
	SPEFSCR_OVH = 0x40000000,
	SPEFSCR_FGH = 0x20000000,
	SPEFSCR_FXH = 0x10000000,
	SPEFSCR_FINVH = 0x8000000,
	SPEFSCR_FDBZH = 0x4000000,
	SPEFSCR_FUNFH = 0x2000000,
	SPEFSCR_FOVFH = 0x1000000,
	SPEFSCR_FINXS = 0x200000,
	SPEFSCR_FINVS = 0x100000,
	SPEFSCR_FDBZS = 0x80000,
	SPEFSCR_FUNFS = 0x40000,
	SPEFSCR_FOVFS = 0x20000,
	SPEFSCR_ALL_EXCEPT = 0x3e0000,
	SPEFSCR_MODE = 0x10000,
	SPEFSCR_SOV = 0x8000,
	SPEFSCR_OV = 0x4000,
	SPEFSCR_FG = 0x2000,
	SPEFSCR_FX = 0x1000,
	SPEFSCR_FINV = 0x800,
	SPEFSCR_FDBZ = 0x400,
	SPEFSCR_FUNF = 0x200,
	SPEFSCR_FOVF = 0x100,
	SPEFSCR_FINXE = 0x40,
	SPEFSCR_FINVE = 0x20,
	SPEFSCR_FDBZE = 0x10,
	SPEFSCR_FUNFE = 8,
	SPEFSCR_FOVFE = 4,
	SPEFSCR_ALL_EXCEPT_ENABLE = 0x7c,
	SPEFSCR_FRMC = 3
};


/** Definitions of all the FPSCR bit numbers */
enum FPSCR_BITS {
	FPSCR_FX = 0,  // Exception summary
	FPSCR_FEX,  // Enabled exception summary
	FPSCR_VX,  // Invalid operation summary
	FPSCR_OX,  // Overflow
	FPSCR_UX,  // Underflow
	FPSCR_ZX,  // Zero divide
	FPSCR_XX,  // Inexact
	FPSCR_VXSNAN,  // Invalid operation for sNaN
	FPSCR_VXISI,  // Invalid operation for Inf-Inf
	FPSCR_VXIDI,  // Invalid operation for Inf/Inf
	FPSCR_VXZDZ,  // Invalid operation for 0/0
	FPSCR_VXIMZ,  // Invalid operation for Inf*0
	FPSCR_VXVC,  // Invalid operation for invalid compare
	FPSCR_FR,  // Fraction rounded [fraction was incremented by round]
	FPSCR_FI,  // Fraction inexact
	FPSCR_FPRF_C,  // Result class descriptor
	FPSCR_FPRF_FL,  // Result less than (usually, less than 0)
	FPSCR_FPRF_FG,  // Result greater than
	FPSCR_FPRF_FE,  // Result equal to
	FPSCR_FPRF_FU,  // Result unordered
	FPSCR_20,  // Reserved
	FPSCR_VXSOFT,  // Invalid operation set by software
	FPSCR_VXSQRT,  // Invalid operation for square root
	FPSCR_VXCVI,  // Invalid operation for invalid integer convert
	FPSCR_VE,  // Invalid operation exception enable
	FPSCR_OE,  // Overflow exception enable
	FPSCR_UE,  // Underflow exception enable
	FPSCR_ZE,  // Zero divide exception enable
	FPSCR_XE,  // Inexact exception enable
#   ifdef _ARCH_PWR6
	FPSCR_29  // Reserved in ISA 2.05
#   else
	FPSCR_NI  // Non-IEEE mode (typically, no denormalised numbers)
#   endif  // _ARCH_PWR6
};


/** Pointer to default FPU environment */
#define FE_DFL_ENV   (&_FE_DFL_ENV)
#define FE_ALL_FLAGS   (0xFFF80300)
/** Alias for the FPU environment object */
#define __fe_dfl_env   FE_DFL_ENV


/** Set/clear a particular FPSCR bit (for instance, reset_fpscr_bit(FPSCR_VE); prevents INVALID exceptions from being raised) */
#define set_fpscr_bit(x)   asm volatile ("mtfsb1 %0;" : : "i"(x))
#define reset_fpscr_bit(x)   asm volatile ("mtfsb0 %0;" : : "i"(x))


LIB_FUNC void libc_feholdexcept_ppc(fenv_t* envp) {
	fenv_union_t old, new;
	old.fenv = *envp = fegetenv_register();
	new.l = old.l & _FPU_MASK_ROUNDING;
	if ((old.l & _FPU_MASK_ALL) != 0) { (void)__fe_mask_env(); }
	fesetenv_register(new.fenv);
}


LIB_FUNC void libc_fesetround_ppc(int r) {
	__fesetround_inline(r);
}


LIB_FUNC void libc_feholdexcept_setround_ppc(fenv_t* envp, int r) {
	fenv_union_t old, new;
	old.fenv = *envp = fegetenv_register();
	new.l = (old.l & _FPU_MASK_ROUNDING) | r;
	if ((old.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(new.fenv);
}


LIB_FUNC int libc_fetestexcept_ppc(int e) {
	fenv_union_t u;
	u.fenv = fegetenv_register();
	return u.l & e;
}


LIB_FUNC void libc_fesetenv_ppc(const fenv_t* envp) {
	fenv_union_t old, new;
	new.fenv = *envp;
	old.fenv = fegetenv_register();
	// If the old env has no enabled exceptions and the new env has any enabled exceptions, then unmask SIGFPE in the MSR FE0/FE1 bits. This will put the hardware into "precise mode" and may cause the FPU to run slower on some hardware
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	// If the old env had any enabled exceptions and the new env has no enabled exceptions, then mask SIGFPE in the MSR FE0/FE1 bits. This may allow the FPU to run faster because it always takes the default action and can not generate SIGFPE
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(*envp);
}


LIB_FUNC int libc_feupdateenv_test_ppc(fenv_t* envp, int ex) {
	fenv_union_t old, new;
	new.fenv = *envp;
	old.fenv = fegetenv_register();
	// Restore rounding mode and exception enable from *envp and merge exceptions. Leave fraction rounded/inexact and FP result/CC bits unchanged
	new.l = (old.l & _FPU_MASK_EXCEPT_ROUND) | (new.l & _FPU_MASK_FRAC_INEX_RET_CC);
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	fesetenv_register(new.fenv);
	return old.l & ex;
}


LIB_FUNC void libc_feupdateenv_ppc(fenv_t* e) {
	libc_feupdateenv_test_ppc(e, 0);
}


LIB_FUNC void libc_feholdsetround_ppc(fenv_t* e, int r) {
	fenv_union_t old, new;
	old.fenv = fegetenv_register();
	/** Clear current precision and set newer one */
	new.l = (old.l & (~3)) | r;
	*e = old.fenv;
	if ((old.l & _FPU_MASK_ALL) != 0)
	(void)__fe_mask_env();
	fesetenv_register(new.fenv);
}


LIB_FUNC void libc_feresetround_ppc(fenv_t* envp) {
	fenv_union_t old, new;
	new.fenv = *envp;
	old.fenv = fegetenv_register();
	new.l = (old.l & _FPU_MASK_EXCEPT_ROUND) | (new.l & _FPU_MASK_FRAC_INEX_RET_CC);
	if ((old.l & _FPU_MASK_ALL) == 0 && (new.l & _FPU_MASK_ALL) != 0) {
		(void)__fe_nomask_env_priv();
	}
	if ((old.l & _FPU_MASK_ALL) != 0 && (new.l & _FPU_MASK_ALL) == 0) {
		(void)__fe_mask_env();
	}
	// Atomically enable and raise (if appropriate) exceptions set in `new`
	fesetenv_register(new.fenv);
}
#define libc_feholdexceptf   libc_feholdexcept_ppc
#define libc_feholdexcept   libc_feholdexcept_ppc
#define libc_feholdexcept_setroundf   libc_feholdexcept_setround_ppc
#define libc_feholdexcept_setround   libc_feholdexcept_setround_ppc
#define libc_fetestexceptf   libc_fetestexcept_ppc
#define libc_fetestexcept   libc_fetestexcept_ppc
#define libc_fesetroundf   libc_fesetround_ppc
#define libc_fesetround   libc_fesetround_ppc
#define libc_fesetenvf   libc_fesetenv_ppc
#define libc_fesetenv   libc_fesetenv_ppc
#define libc_feupdateenv_testf   libc_feupdateenv_test_ppc
#define libc_feupdateenv_test   libc_feupdateenv_test_ppc
#define libc_feupdateenvf   libc_feupdateenv_ppc
#define libc_feupdateenv   libc_feupdateenv_ppc
#define libc_feholdsetroundf   libc_feholdsetround_ppc
#define libc_feholdsetround   libc_feholdsetround_ppc
#define libc_feresetroundf   libc_feresetround_ppc
#define libc_feresetround   libc_feresetround_ppc


#endif  // PPC_MATH_PRIVATE_H


#if ((!defined(S390_MATH_PRIVATE_H)) && defined(S390))
#define S390_MATH_PRIVATE_H   (1)
#define _S390_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


typedef unsigned int   fexcept_t;  // Size of fpc
typedef struct fenv_struct {
	fexcept_t fpc;
	void* ieee_instruction_pointer;  // Failing instruction for IEEE exceptions
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#define FE_INVALID   0x80
#define FE_DIVBYZERO   0x40
#define FE_OVERFLOW   0x20
#define FE_UNDERFLOW   0x10
#define FE_INEXACT   8
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
#define FE_TONEAREST   0
#define FE_DOWNWARD   3
#define FE_UPWARD   2
#define FE_TOWARDZERO   1
#define FE_DFL_ENV   ((const fenv_t*)(-1))
#define FPC_EXCEPTION_MASK   0xF8000000
#define FPC_FLAGS_MASK   0xF80000
#define FPC_DXC_MASK   0xFF00
#define FPC_RM_MASK   3
#define FPC_VALID_MASK   ((FPC_EXCEPTION_MASK | FPC_FLAGS_MASK | FPC_DXC_MASK | FPC_RM_MASK))
#define FPC_EXCEPTION_MASK_SHIFT   24
#define FPC_FLAGS_SHIFT   16
#define FPC_DXC_SHIFT   8
#define FPC_NOT_FPU_EXCEPTION   0x300


#endif  // S390_MATH_PRIVATE_H


#if ((!defined(SH_MATH_PRIVATE_H)) && defined(SUPERH))
#define SH_MATH_PRIVATE_H   (1)
#define _SH_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define LDBL_CLASSIFY_COMPAT   (1)


#endif  // SH_MATH_PRIVATE_H


#if ((!defined(SPARC_MATH_PRIVATE_H)) && defined(SPARC))
#define SPARC_MATH_PRIVATE_H   (1)
#define _SPARC_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


typedef unsigned long   fexcept_t;
typedef unsigned long   fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


/** Support for rounding mode context */
#define HAVE_RM_CTX   (1)
#define FE_INVALID   0x200
#define FE_OVERFLOW   0x100
#define FE_UNDERFLOW   0x80
#define FE_DIVBYZERO   0x40
#define FE_INEXACT   0x20
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
#define FE_TONEAREST   0
#define FE_TOWARDZERO   0x40000000
#define FE_UPWARD   0x80000000
#define FE_DOWNWARD   0xc0000000  // 3U << 30
#define __FE_ROUND_MASK   0xc0000000  // 3U << 30
#define FE_DFL_ENV   ((const fenv_t*)(-1))


LIB_FUNC void libc_feholdexcept(fenv_t* e) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*(e) = etmp;
	etmp = etmp & (~(0xf800000 | FE_ALL_EXCEPT));
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_fesetround(int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp = (etmp & (~__FE_ROUND_MASK)) | (r);
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_feholdexcept_setround(fenv_t* e, int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*(e) = etmp;
	etmp = etmp & (~(0xf800000 | FE_ALL_EXCEPT));
	etmp = (etmp & (~__FE_ROUND_MASK)) | (r);
	__fenv_ldfsr(etmp);
}


LIB_FUNC int libc_fetestexcept(int e) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	return etmp & (e) & FE_ALL_EXCEPT;
}


LIB_FUNC void libc_fesetenv(fenv_t* e) {
	__fenv_ldfsr(*e);
}


LIB_FUNC int libc_feupdateenv_test(fenv_t* e, int ex) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp &= FE_ALL_EXCEPT;
	__fenv_ldfsr(*e);
	__feraiseexcept(etmp);
	return etmp & ex;
}


LIB_FUNC void libc_feupdateenv(fenv_t* e) {
	libc_feupdateenv_test(e, 0);
}


LIB_FUNC void libc_feholdsetround(fenv_t* e, int r) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	*(e) = etmp;
	etmp = (etmp & (~__FE_ROUND_MASK)) | (r);
	__fenv_ldfsr(etmp);
}


LIB_FUNC void libc_feresetround(fenv_t* e) {
	fenv_t etmp;
	__fenv_stfsr(etmp);
	etmp = (etmp & (~__FE_ROUND_MASK)) | (*e & __FE_ROUND_MASK);
	__fenv_ldfsr(etmp);
}


#define libc_feholdexceptf   libc_feholdexcept
#define libc_fesetroundf   libc_fesetround
#define libc_feholdexcept_setroundf libc_feholdexcept_setround
#define libc_fetestexceptf   libc_fetestexcept
#define libc_fesetenvf   libc_fesetenv
#define libc_feupdateenv_testf   libc_feupdateenv_test
#define libc_feupdateenvf   libc_feupdateenv
#define libc_feholdsetroundf   libc_feholdsetround
#define libc_feresetroundf   libc_feresetround
#define libc_feholdexcept   libc_feholdexcept
#define libc_fesetround   libc_fesetround
#define libc_feholdexcept_setround   libc_feholdexcept_setround
#define libc_fetestexcept   libc_fetestexcept
#define libc_fesetenv   libc_fesetenv
#define libc_feupdateenv_test   libc_feupdateenv_test
#define libc_feupdateenv   libc_feupdateenv
#define libc_feholdsetround   libc_feholdsetround
#define libc_feresetround   libc_feresetround
#define libc_feholdexceptl   libc_feholdexcept
#define libc_fesetroundl   libc_fesetround
#define libc_feholdexcept_setroundl   libc_feholdexcept_setround
#define libc_fetestexceptl   libc_fetestexcept
#define libc_fesetenvl   libc_fesetenv
#define libc_feupdateenv_testl   libc_feupdateenv_test
#define libc_feupdateenvl   libc_feupdateenv
#define libc_feholdsetroundl   libc_feholdsetround
#define libc_feresetroundl   libc_feresetround


#endif  // SPARC_MATH_PRIVATE_H


#if ((!defined(TILE_MATH_PRIVATE_H)) && defined(TILE))
#define TILE_MATH_PRIVATE_H   (1)
#define _TILE_MATH_PRIVATE_H_   (1)
#define CPU_MATH_PRIVATE_H   (1)


#define libc_fesetround(rnd)   0
#define libc_fetestexcept(exc)   0
#define libc_feholdexcept_setround(env, exc)   __extension__ ({ (void)(env); 0; })
#define libc_feupdateenv_test(env, exc)   __extension__ ({ (void)(env); 0; })
#define feraiseexcept(excepts)   0
#define __feraiseexcept(excepts)   0
#define feclearexcept(exc)   0
#define fetestexcept(exc)   0
LIB_FUNC int fegetenv(UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __fegetenv(UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int fesetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __fesetenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int feupdateenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int __feupdateenv(const UNUSED fenv_t* __e) { return 0; }
LIB_FUNC int fegetround(void) { return FE_TONEAREST; }
LIB_FUNC int __fegetround(void) { return FE_TONEAREST; }
LIB_FUNC int fesetround(UNUSED int __d) { return 0; }
LIB_FUNC int __fesetround(UNUSED int __d) { return 0; }


#endif  // TILE_MATH_PRIVATE_H


#if ((!defined(X86_64_MATH_PRIVATE_H)) && (defined(X86) || defined(X86_64) || defined(I386)))
#define X86_64_MATH_PRIVATE_H   (1)
#define I386_MATH_PRIVATE_H   (1)
#define CPU_MATH_PRIVATE_H   (1)


#   define HAVE_RM_CTX   (1)
#   ifndef X86_64
#      define __mxcsr   __eip
#   endif
#   if (CPU_AVX || SSE2AVX)
#      define STMXCSR   "vstmxcsr"
#      define LDMXCSR   "vldmxcsr"
#   else
#      define STMXCSR   "stmxcsr"
#      define LDMXCSR   "ldmxcsr"
#   endif


typedef struct fenv_struct {
	unsigned short __control;  // A direct copy of the floaing point control word
	unsigned short __status;  // A direct copy of the floaing point status word
	unsigned int __mxcsr;  // A direct copy of the MXCSR
	char __reserved[8];  // Reserved for future expansion
} fenv_t;


typedef unsigned short   fexcept_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


#define FE_INEXACT   (0x20)
#define FE_UNDERFLOW   (0x10)
#define FE_OVERFLOW   (8)
#define FE_DIVBYZERO   (4)
#define FE_INVALID   (1)
#define FE_TONEAREST   (0)
#define FE_DOWNWARD   (0x400)
#define FE_UPWARD   (0x800)
#define FE_TOWARDZERO   (0xC00)
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)  // (0x3D)
#define FE_ALL_RND   (FE_TONEAREST | FE_TOWARDZERO | FE_UPWARD | FE_DOWNWARD)

extern const UNUSED fenv_t   _FE_DFL_ENV;
#define FE_DFL_ENV   (&_FE_DFL_ENV)
extern const UNUSED fenv_t   _FE_DFL_DISABLE_SSE_DENORMS_ENV;
#define FE_DFL_DISABLE_SSE_DENORMS_ENV   (&_FE_DFL_DISABLE_SSE_DENORMS_ENV)
#define DEFAULT_CONTROL   (0x37f)
#define DEFAULT_STATUS    (0)
#define DEFAULT_RESERVED   "\0\0\0\0\0\0\0"
#define DEFAULT_MXCSR   (0x1F80)
#define DEFAULT_MASK   (DEFAULT_MXCSR | 0x3F)
const UNUSED fenv_t _FE_DFL_ENV = { DEFAULT_CONTROL, DEFAULT_STATUS, DEFAULT_MXCSR, DEFAULT_RESERVED };
const UNUSED fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV = { DEFAULT_CONTROL, DEFAULT_STATUS, (DEFAULT_MXCSR | 0x8040), DEFAULT_RESERVED };
#define MXCSR_PLUS_FZ_DAZ   (DEFAULT_MXCSR | 0x8040)


typedef struct fpustate {
	unsigned short __control, __reserved1, __status, __reserved2;
	unsigned int __private3, __private4, __private5, __private6, __private7;
} __fpustate_t;


/** Raise given exceptions */
LIB_FUNC int __feraiseexcept(const int excepts) {
	if ((FE_INVALID & excepts) != 0) {
			float f = 0.0F;
			asm volatile ("divss %0, %0;" : : "x"(f));
			(void)&f;
	}
	if ((FE_DIVBYZERO & excepts) != 0) {
			float f = 1.0F, g = 0.0F;
			asm volatile ("divss %1, %0;" : : "x"(f), "x"(g));
			(void)&f;
	}
	if ((FE_OVERFLOW & excepts) != 0) {
			fenv_t temp;
			asm volatile ("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_OVERFLOW;
			asm volatile ("fldenv %0;" : : "m"(*&temp));
			asm volatile ("fwait;");
	}
	if ((FE_UNDERFLOW & excepts) != 0) {
			fenv_t temp;
			asm volatile ("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_UNDERFLOW;
			asm volatile ("fldenv %0;" : : "m"(*&temp));
			asm volatile ("fwait;");
	}
	if ((FE_INEXACT & excepts) != 0) {
			fenv_t temp;
			asm volatile ("fnstenv %0;" : "=m"(*&temp));
			temp.__status |= FE_INEXACT;
			asm volatile ("fldenv %0;" : : "m"(*&temp));
			asm volatile ("fwait;");
	}
	return 0;
}
#define feraiseexcept(excepts)   __feraiseexcept((excepts))


LIB_FUNC int _fesetexceptflag(const fexcept_t* flagp, const int excepts) {
	__fpustate_t currfpu;
	register unsigned int exceptMask = (excepts & FE_ALL_EXCEPT);
	register unsigned int andMask = (~exceptMask);  // Clear just the bits indicated
	register unsigned int orMask = (*flagp & exceptMask);  // Latch the specified bits
	unsigned int mxcsr = (unsigned int)_mm_getcsr();  // Read the MXCSR state
	asm volatile ("fnstenv %0;" : "=m"(currfpu));  // Read x87 state
	mxcsr = ((mxcsr & andMask) | orMask);  // Fix the MXCSR state
	register int fpstate = (int)((currfpu.__status & andMask) | orMask);  // Fix the x87 state
	currfpu.__status = (short unsigned int)fpstate;
	asm volatile ("ldmxcsr %0;" "fldenv %1;" : : "m"(mxcsr), "m"(currfpu));  // Store the state
	return 0;
}


LIB_FUNC int _fegetexceptflag(fexcept_t* flagp, const int excepts) {
	unsigned short tmp;
	asm volatile ("fnstsw %0;" : "=m"(tmp) : : "memory");
	fexcept_t fsw = tmp;  // Get the x87 status word
	register unsigned int mxcsr = (unsigned int)_mm_getcsr();  // Get the mxcsr
	fexcept_t result = (unsigned short)(mxcsr | fsw);
	*flagp = (result & (excepts & FE_ALL_EXCEPT));
	return 0;
}

#define fegetexceptflag(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#define fesetexceptflag(flagp, excepts)   _fesetexceptflag((flagp), (excepts))
#define fegetexcept(flagp, excepts)   _fegetexceptflag((flagp), (excepts))
#define fesetexcept(flagp, excepts)   _fesetexceptflag((flagp), (excepts))

LIB_FUNC int feclearexcept(const int excepts) {
	fexcept_t zero = 0;
	return fesetexceptflag(&zero, excepts);
}


LIB_FUNC int fetestexcept(const int excepts) {
	unsigned short tmp;
	asm volatile ("fnstsw %0;" : "=m"(tmp) : : "memory");
	fexcept_t fsw = tmp;  // Get the x87 status word
	register unsigned int mxcsr = _mm_getcsr();  // Get the mxcsr
	return (int)((mxcsr | fsw) & (excepts & FE_ALL_EXCEPT));
}


LIB_FUNC int fegetround(void) {
	unsigned short tmp;
	asm volatile ("fnstcw %0;" : "=m"(tmp) : : "memory");
	return (int)(tmp & FE_ALL_RND);
}


LIB_FUNC int fesetround(const int round) {
	if ((round & (~FE_ALL_RND))) { return 1; }
	else {
		unsigned short tmp;
		asm volatile ("fnstcw %0;" : "=m"(tmp) : : "memory");
		register unsigned short fcw = tmp;
		register unsigned int mxcsr = _mm_getcsr();
		fcw = (short unsigned int)((fcw & (short unsigned int)(~FE_ALL_RND)) | round);
		mxcsr = (unsigned int)((unsigned int)(mxcsr & (unsigned int)(~(FE_ALL_RND << 3))) | (unsigned int)(round << 3));
		_mm_setcsr(mxcsr);
		tmp = fcw;
		asm volatile ("fldcw %0;" : : "m"(tmp));
		return 0;
	}
}


LIB_FUNC int fegetenv(fenv_t* envp) {
	__fpustate_t currfpu;
	register unsigned int mxcsr = _mm_getcsr();
	asm volatile ("fnstenv %0;" : "=m"(currfpu) : : "memory");
	envp->__control = currfpu.__control;
	envp->__status = currfpu.__status;
	envp->__mxcsr = (unsigned int)mxcsr;
	envp->__reserved[0] = 0;
	envp->__reserved[1] = 0;
	asm volatile ("fldenv %0;" : : "m"(currfpu));
	return 0;
}


LIB_FUNC int feholdexcept(fenv_t* envp) {
	__fpustate_t currfpu;
	unsigned int mxcsr = _mm_getcsr();
	asm volatile ("fnstenv %0;" : "=m"(*&currfpu) : : "memory");
	envp->__control = currfpu.__control;
	envp->__status = currfpu.__status;
	envp->__mxcsr = mxcsr;
	envp->__reserved[0] = 0;
	envp->__reserved[1] = 0;
	currfpu.__control |= FE_ALL_EXCEPT;  // FPU shall handle all exceptions
	currfpu.__status &= (short unsigned int)(~FE_ALL_EXCEPT);
	mxcsr = (unsigned int)((mxcsr | (FE_ALL_EXCEPT << 7)) & (unsigned int)(~(FE_ALL_EXCEPT)));  // Left shifted because control mask is <<7 of the flags
	asm volatile ("ldmxcsr %0;" "fldenv %1;" : : "m"(*&mxcsr), "m"(*&currfpu));
	return 0;
}


LIB_FUNC int fesetenv(const fenv_t* envp) {
	__fpustate_t currfpu;
	asm volatile ("fnstenv %0;" : "=m"(currfpu));
	currfpu.__control = envp->__control;
	currfpu.__status = envp->__status;
	asm volatile ("ldmxcsr %0;" "fldenv %1;" : : "m"(envp->__mxcsr), "m"(currfpu));
	return 0;
}


LIB_FUNC int feupdateenv(const fenv_t* envp) {
	__fpustate_t currfpu;
	asm volatile ("fnstenv %0;" : "=m"(currfpu));
	currfpu.__control = envp->__control;
	currfpu.__status = envp->__status;
	asm volatile ("ldmxcsr %0; fldenv %1;" "fwait;" : : "m"(envp->__mxcsr), "m"(currfpu));
	return 0;
}


LIB_FUNC int __fegetfltrounds(void) {
	switch ((int)(fegetround())) {
		case FE_TONEAREST: return 1;
		case FE_TOWARDZERO: return 0;
		case FE_UPWARD: return 2;
		case FE_DOWNWARD: return 3;
		default: return -1;
	}
	UNREACHABLE
}
#define _fegetfltrounds()   __fegetfltrounds()
#define fegetfltrounds()   __fegetfltrounds()


LIB_FUNC void libc_feholdexcept_sse(fenv_t* e) {
	unsigned int mxcsr;
	asm (STMXCSR " %0;" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)((mxcsr | 0x1f80) & (unsigned int)(~0x3f));
	asm volatile (LDMXCSR " %0;" : : "m"(*&mxcsr));
}


/** Clobber all of the fp registers so that the TOS field is 0 */
LIB_FUNC void libc_feholdexcept_387(fenv_t* e) {
	asm volatile ("fnstenv %0;" "fnclex;" : "=m"(*e) : : "st", "st(1)", "st(2)", "st(3)", "st(4)", "st(5)", "st(6)", "st(7)");
}


LIB_FUNC void libc_fesetround_sse(int r) {
	unsigned int mxcsr;
	asm (STMXCSR " %0;" : "=m"(*&mxcsr));
	mxcsr = (unsigned int)((mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(r << 3));
	asm volatile (LDMXCSR " %0;" : : "m"(*&mxcsr));
}


LIB_FUNC void libc_fesetround_387(int r) {
	fpu_control_t cw;
	_FPU_GETCW(cw);
	cw = (fpu_control_t)((cw & (fpu_control_t)(~0xc00)) | (fpu_control_t)r);
	_FPU_SETCW(cw);
}


LIB_FUNC void libc_feholdexcept_setround_sse(fenv_t* e, int r) {
	unsigned int mxcsr;
	asm (STMXCSR " %0;" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)(((mxcsr | 0x1f80) & (unsigned int)(~0x603f)) | (unsigned int)(r << 3));
	asm volatile (LDMXCSR " %0;" : : "m"(*&mxcsr));
}


LIB_FUNC int libc_fetestexcept_sse(int e) {
	unsigned int mxcsr;
	asm volatile (STMXCSR " %0;" : "=m"(*&mxcsr));
	return (((int)mxcsr & e) & FE_ALL_EXCEPT);
}


LIB_FUNC int libc_fetestexcept_387(int ex) {
	fexcept_t temp;
	asm volatile ("fnstsw %0;" : "=a"(temp));
	return ((temp & ex) & FE_ALL_EXCEPT);
}


LIB_FUNC void libc_fesetenv_sse(fenv_t* e) {
	asm volatile (LDMXCSR " %0;" : : "m"(e->__mxcsr));
}


/** Clobber all fp registers so that the TOS value we saved earlier is compatible with the current state of the compiler */
LIB_FUNC void libc_fesetenv_387(fenv_t* e) {
	asm volatile ("fldenv %0;" : : "m"(*e) : "st", "st(1)", "st(2)", "st(3)", "st(4)", "st(5)", "st(6)", "st(7)");
}


LIB_FUNC int libc_feupdateenv_test_sse(fenv_t* e, int ex) {
	unsigned int mxcsr, old_mxcsr, cur_ex;
	asm volatile (STMXCSR " %0" : "=m"(*&mxcsr));
	cur_ex = mxcsr & FE_ALL_EXCEPT;
	// Merge current exceptions with the old environment
	old_mxcsr = e->__mxcsr;
	mxcsr = old_mxcsr | cur_ex;
	asm volatile (LDMXCSR " %0" : : "m"(*&mxcsr));
	// Raise SIGFPE for any new exceptions since the hold; Expect that the normal environment has all exceptions masked
	if (PREDICT_UNLIKELY(~(old_mxcsr >> 7) & cur_ex)) { __feraiseexcept((int)cur_ex); }
	// Test for exceptions raised since the hold
	return (int)((int)cur_ex & ex);
}


LIB_FUNC int libc_feupdateenv_test_387(fenv_t* e, int ex) {
	fexcept_t cur_ex;
	// Save current exceptions
	asm volatile ("fnstsw %0;" : "=a"(cur_ex));
	cur_ex &= FE_ALL_EXCEPT;
	libc_fesetenv_387(e);  // Reload original environment
	__feraiseexcept(cur_ex);  // Merge current exceptions
	return (cur_ex & ex);  // Test for exceptions raised since the hold
}


LIB_FUNC void libc_feupdateenv_sse(fenv_t* e) {
	libc_feupdateenv_test_sse(e, 0);
}


LIB_FUNC void libc_feupdateenv_387(fenv_t* e) {
	libc_feupdateenv_test_387(e, 0);
}


LIB_FUNC void libc_feholdsetround_sse(fenv_t* e, int r) {
	unsigned int mxcsr;
	asm (STMXCSR " %0" : "=m"(*&mxcsr));
	e->__mxcsr = mxcsr;
	mxcsr = (unsigned int)(mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(r << 3);
	asm volatile (LDMXCSR " %0" : : "m"(*&mxcsr));
}


LIB_FUNC void libc_feresetround_sse(fenv_t* e) {
	unsigned int mxcsr;
	asm (STMXCSR " %0" : "=m"(*&mxcsr));
	mxcsr = (unsigned int)(mxcsr & (unsigned int)(~0x6000)) | (unsigned int)(e->__mxcsr & 0x6000);
	asm volatile (LDMXCSR " %0" : : "m"(*&mxcsr));
}


#ifdef __SSE_MATH__
#   define libc_feholdexceptf   libc_feholdexcept_sse
#   define libc_fesetroundf   libc_fesetround_sse
#   define libc_feholdexcept_setroundf  libc_feholdexcept_setround_sse
#   define libc_fetestexceptf   libc_fetestexcept_sse
#   define libc_fesetenvf   libc_fesetenv_sse
#   define libc_feupdateenv_testf   libc_feupdateenv_test_sse
#   define libc_feupdateenvf   libc_feupdateenv_sse
#   define libc_feholdsetroundf   libc_feholdsetround_sse
#   define libc_feresetroundf   libc_feresetround_sse
#else
#   define libc_feholdexceptf   libc_feholdexcept_387
#   define libc_fesetroundf   libc_fesetround_387
#   define libc_feholdexcept_setroundf  libc_feholdexcept_setround_387
#   define libc_fetestexceptf   libc_fetestexcept_387
#   define libc_fesetenvf   libc_fesetenv_387
#   define libc_feupdateenv_testf   libc_feupdateenv_test_387
#   define libc_feupdateenvf   libc_feupdateenv_387
#   define libc_feholdsetroundf   libc_feholdsetround_387
#   define libc_feresetroundf   libc_feresetround_387
#endif


#ifdef __SSE2_MATH__
#   define libc_feholdexcept   libc_feholdexcept_sse
#   define libc_fesetround   libc_fesetround_sse
#   define libc_feholdexcept_setround libc_feholdexcept_setround_sse
#   define libc_fetestexcept   libc_fetestexcept_sse
#   define libc_fesetenv   libc_fesetenv_sse
#   define libc_feupdateenv_test   libc_feupdateenv_test_sse
#   define libc_feupdateenv   libc_feupdateenv_sse
#   define libc_feholdsetround   libc_feholdsetround_sse
#   define libc_feresetround   libc_feresetround_sse
#else
#   define libc_feholdexcept   libc_feholdexcept_387
#   define libc_fesetround   libc_fesetround_387
#   define libc_feholdexcept_setround libc_feholdexcept_setround_387
#   define libc_fetestexcept   libc_fetestexcept_387
#   define libc_fesetenv   libc_fesetenv_387
#   define libc_feupdateenv_test   libc_feupdateenv_test_387
#   define libc_feupdateenv   libc_feupdateenv_387
#   define libc_feholdsetround   libc_feholdsetround_387
#   define libc_feresetround   libc_feresetround_387
#endif


#define libc_feholdexceptl   libc_feholdexcept_387
#define libc_fesetroundl   libc_fesetround_387
#define libc_feholdexcept_setroundl libc_feholdexcept_setround_387
#define libc_fetestexceptl   libc_fetestexcept_387
#define libc_fesetenvl   libc_fesetenv_387
#define libc_feupdateenv_testl   libc_feupdateenv_test_387
#define libc_feupdateenvl   libc_feupdateenv_387
#define libc_feholdsetroundl   libc_feholdsetround_387
#define libc_feresetroundl   libc_feresetround_387


#ifndef __SSE2_MATH__
#   define libc_feholdexcept_setround_53bit   libc_feholdexcept_setround_387_53bit
#   define libc_feholdsetround_53bit   libc_feholdsetround_387_53bit
#endif


#ifdef X86_64


#if (CPU_AVX || CPU_SSE2AVX)
#   define MOVD   "vmovd"
#   define MOVQ   "vmovq"
#else
#   define MOVD   "movd"
#   define MOVQ   "movq"
#endif


/** Direct movement of float into integer register */
#define EXTRACT_WORDS64(i, d)   do { int64_t i_; asm (MOVQ " %1, %0" : "=rm"(i_) : "x"((double)(d))); (i) = i_; } while (0x0)
#define INSERT_WORDS64(d, i)   do { int64_t i_ = i; double d__; asm (MOVQ " %1, %0" : "=x"(d__) : "rm"(i_)); d = d__; } while (0x0)
/** Direct movement of float into integer register */
#define GET_FLOAT_WORD(i, d)   do { int i_; asm (MOVD " %1, %0" : "=rm"(i_) : "x"((float)(d))); (i) = i_; } while (0x0)
/** Direct movement of float into integer register */
#define GET_FLOAT_UWORD(i, d)   do { unsigned int i_; asm (MOVD " %1, %0" : "=rm"(i_) : "x"((float)(d))); (i) = i_; } while (0x0)
#define SET_FLOAT_WORD(f, i)   do { int i_ = i; float f__; asm (MOVD " %1, %0" : "=x"(f__) : "rm"(i_)); f = f__; } while (0x0)
#define SET_FLOAT_SWORD(f, i)   do { signed int i_ = i; float f__; asm (MOVD " %1, %0" : "=x"(f__) : "rm"(i_)); f = f__; } while (0x0)
#define SET_FLOAT_UWORD(f, i)   do { unsigned int i_ = i; float f__; asm (MOVD " %1, %0" : "=x"(f__) : "rm"(i_)); f = f__; } while (0x0)


#endif  // X86_64


#ifdef __SSE_MATH__
#   define libc_feholdexcept_setroundf_ctx   libc_feholdexcept_setround_sse_ctx
#   define libc_fesetenvf_ctx   libc_fesetenv_sse_ctx
#   define libc_feupdateenvf_ctx   libc_feupdateenv_sse_ctx
#   define libc_feholdsetroundf_ctx   libc_feholdsetround_sse_ctx
#   define libc_feresetroundf_ctx   libc_feresetround_sse_ctx
#else
#   define libc_feholdexcept_setroundf_ctx   libc_feholdexcept_setround_387_ctx
#   define libc_feupdateenvf_ctx   libc_feupdateenv_387_ctx
#   define libc_feholdsetroundf_ctx   libc_feholdsetround_387_ctx
#   define libc_feresetroundf_ctx   libc_feresetround_387_ctx
#endif


#ifdef __SSE2_MATH__
#   define libc_feholdexcept_setround_ctx   libc_feholdexcept_setround_sse_ctx
#   define libc_fesetenv_ctx   libc_fesetenv_sse_ctx
#   define libc_feupdateenv_ctx   libc_feupdateenv_sse_ctx
#   define libc_feholdsetround_ctx   libc_feholdsetround_sse_ctx
#   define libc_feresetround_ctx   libc_feresetround_sse_ctx
#else
#   define libc_feholdexcept_setround_ctx   libc_feholdexcept_setround_387_ctx
#   define libc_feupdateenv_ctx   libc_feupdateenv_387_ctx
#   define libc_feholdsetround_ctx   libc_feholdsetround_387_ctx
#   define libc_feresetround_ctx   libc_feresetround_387_ctx
#endif


#define libc_feholdexcept_setroundl_ctx   libc_feholdexcept_setround_387_ctx
#define libc_feupdateenvl_ctx   libc_feupdateenv_387_ctx
#define libc_feholdsetroundl_ctx   libc_feholdsetround_387_ctx
#define libc_feresetroundl_ctx   libc_feresetround_387_ctx


#ifndef __SSE2_MATH__
#   define libc_feholdsetround_53bit_ctx   libc_feholdsetround_387_53bit_ctx
#   define libc_feresetround_53bit_ctx   libc_feresetround_387_ctx
#endif


#endif  // X86_64_MATH_PRIVATE_H


#if (!(defined(CPU_MATH_PRIVATE_H) || defined(_CPU_MATH_PRIVATE_H_) || defined(GENERIC_MATH_PRIVATE_H) || defined(_GENERIC_MATH_PRIVATE_H_)))  // GENERIC FENV FUNCTIONS
#define CPU_MATH_PRIVATE_H   (1)
#define _CPU_MATH_PRIVATE_H_   (1)
#define GENERIC_MATH_PRIVATE_H   (1)
#define _GENERIC_MATH_PRIVATE_H_   (1)


#define FE_ALL_EXCEPT   (0)
typedef unsigned int   fexcept_t;
typedef struct { fexcept_t __excepts; }   fenv_t;
#define FE_DFL_ENV   ((const fenv_t*)(-1L))


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


/** Clear given exceptions in current floating-point environment */
LIB_FUNC int feclearexcept(const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Enable floating-point exceptions */
LIB_FUNC int feenableexcept(const int excepts) {
	if (excepts != 0) { return (-1); }  // Signal failure if any exception traps are to be enabled
	return 0;
}


/** Disable floating-point exceptions */
LIB_FUNC int fedisableexcept(const int excepts) {
	return (excepts != 0);  // All exception traps are disabled
}


/** Store current floating-point environment */
LIB_FUNC int fegetenv(const fenv_t* restrict envp) {
	return envp;
}


/** Get floating-point exceptions */
LIB_FUNC int fegetexcept(void) {
	return 0;  // All exception traps are disabled
}


/** Return current rounding direction */
LIB_FUNC int fegetround(void) {
#ifdef FE_TONEAREST
	return FE_TONEAREST;
#else
	return 0;
#endif
}


/** Store current floating-point environment and clear exceptions */
LIB_FUNC int feholdexcept(const fenv_t* restrict envp) {
	fegetenv(envp);
	fedisableexcept(FE_ALL_EXCEPT);
	feclearexcept(FE_ALL_EXCEPT);
	return 0;
}


/** Initialize the given floating-point environment */
LIB_FUNC int fesetenv(const fenv_t* restrict envp) {
#if (defined(FE_NOMASK_ENV) && (FE_ALL_EXCEPT != 0))
	if (envp == FE_NOMASK_ENV) { return 1; }
#endif
	return envp;  // Nothing to do
}


/** Set floating-point environment exception handling */
LIB_FUNC int fesetexcept(const fexcept_t* restrict flagp, const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Set rounding direction */
LIB_FUNC int fesetround(const int round) {
#ifdef FE_TONEAREST
	return ((round == FE_TONEAREST) ? 0 : 1);
#else
	return round;  // Unable to set the direction
#endif
}


/** Raise given exceptions */
LIB_FUNC int feraiseexcept(const int excepts) {
	return (excepts != 0);  // This always fails unless nothing needs to be done
}


/** Test exception in current environment */
LIB_FUNC int fetestexcept(const int excepts) {
	return excepts;
}


/** Initialize the given floating-point environment and raise exceptions */
LIB_FUNC int feupdateenv(const fenv_t* restrict envp) {
#if (defined(FE_NOMASK_ENV) && (FE_ALL_EXCEPT != 0))
	if (envp == FE_NOMASK_ENV) { return 1; }
#endif
	return envp;  // Nothing to do
}


#ifndef _SOFT_FLOAT  // E1-16/32X FPU


#define FE_INEXACT   0x100  // 1 << 8
#define FE_UNDERFLOW   0x200
#define FE_OVERFLOW   0x400
#define FE_DIVBYZERO   0x800
#define FE_INVALID   0x1000  // 1 << 12
#define FE_ALL_EXCEPT   (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
#define FE_TONEAREST   0
#define FE_TOWARDZERO   0x2000  // 1 << 13
#define FE_DOWNWARD   0x4000
#define FE_UPWARD   0x6000  // 3 << 13


typedef unsigned int   fexcept_t;
typedef struct fenv {
	unsigned int round_mode, trap_enabled, accrued_except, actual_except;
} fenv_t;


/** Rounding mode context; This allows functions to set/restore rounding mode only when the desired rounding mode is different from the current rounding mode */
typedef struct attr_packed rm_ctx {
	fenv_t env;
	bool updated_status;
} rm_ctx_t;


static const UNUSED fenv_t FE_DFL_ENV_OBJ = { 0, 0x1C00, 0, 0 };
#define FE_DFL_ENV   (&FE_DFL_ENV_OBJ)


/** Clear given exceptions in current floating-point environment */
LIB_FUNC int feclearexcept(const int excepts) {
	register int enabled_excepts, disabled_excepts;
	if (excepts & (~0x1F00)) { return -1; }  // Check that excepts is correctly set
	asm volatile ("mov %0, SR;" : "=l"(enabled_excepts) :);
	enabled_excepts &= 0x1F00;
	disabled_excepts = (~enabled_excepts);
	disabled_excepts &= 0x1F00;
	enabled_excepts &= excepts;
	disabled_excepts &= excepts;
	asm volatile (
		"andn G2, %0;" "andn G2, %1;" : /* No Output */
		: "l"(enabled_excepts), "l"((disabled_excepts >> 8))
	);  // Clear accrued exceptions
	return 0;
}


/** Enable floating-point exceptions */
LIB_FUNC int feenableexcept(const int excepts) {
	register int __retval, __pexcepts, __tmpexcepts = excepts;
	while (0x1) {
		asm volatile ("mov %0, SR;" : "=l"(__pexcepts));
		__pexcepts &= 0x1F00;
		if (__tmpexcepts & (~0x1F00)) {
			__retval = -1;
			fprintf(stderr, "Non valid exception");
			break;
		}
		asm volatile ("or SR, %0;" : /* No Output */ : "l"(__tmpexcepts));
		__retval = __pexcepts;
		break;
	}
	return __retval;
}


/** Disable floating-point exceptions */
LIB_FUNC int fedisableexcept(const int excepts) {
	register int __retval, __pexcepts, __tmpexcepts = excepts;
	while (0x1) {
		asm volatile ("mov %0, SR;" : "=l"(__pexcepts));
		__pexcepts &= 0x1F00;
		if (__tmpexcepts & (int)(~0x1F00)) {
			__retval = -1;
			fprintf(stderr, "Non valid exception");
			break;
		}
		asm volatile ("andn SR, %0;" : /* No Output */ : "l"(__tmpexcepts));
		__retval = __pexcepts;
		break;
	}
	return __retval;
}


/** Store current floating-point environment */
LIB_FUNC int fegetenv(fenv_t* restrict envp) {
	asm volatile (
		"mov %0, SR;" "mov %1, SR;" "mov %2, G2;" "mov %3, G2;"
		: "=l"(envp->round_mode), "=l"(envp->trap_enabled), "=l"(envp->accrued_except), "=l"(envp->actual_except) : );
	envp->round_mode &= 0x6000;
	envp->trap_enabled &= 0x1F00;
	envp->accrued_except &= 0x1F;
	envp->accrued_except <<= 8;
	envp->actual_except &= 0x1F00;
	return 0;
}


/** Get floating-point exceptions */
LIB_FUNC int _fegetexcept(void) {
	register unsigned int tmp;
	asm volatile ("mov %0, SR;" : "=l"(tmp));
	return (tmp & 0x1F00);
}


/** Return current rounding direction */
LIB_FUNC int fegetround(void) {
	register unsigned int tmp;
	asm volatile ("mov %0, SR;" : "=l"(tmp));
	return (tmp & 0x6000);  // 3 << 13
}


/** Store current floating-point environment and clear exceptions */
LIB_FUNC int feholdexcept(fenv_t* restrict envp) {
	fegetenv(envp);
	fedisableexcept(FE_ALL_EXCEPT);
	feclearexcept(FE_ALL_EXCEPT);
	return 0;
}


/** Initialize the given floating-point environment */
LIB_FUNC int fesetenv(fenv_t* restrict envp) {
	register unsigned long clearSR = 0x7f00;  // 127 << 8
	asm volatile (
		"andn SR, %0;" "or SR, %1;" "or SR, %2;" : /* No Output */
		: "l"(clearSR), "l"(envp->round_mode), "l"(envp->trap_enabled)
	);
	asm volatile (
		"andn G2, 0x1F1F;" "or G2, %0;" "or G2, %1;" : /* No Output */
		: "l"((envp->accrued_except >> 8)), "l"(envp->actual_except)
	);
	return 0;
}


/** Set rounding direction */
LIB_FUNC int fesetround(const int round) {
	register unsigned int tmp = 0x6000;  // 3 << 13
	while (0x1) {
		asm volatile ("andn SR, %0;" : /* No Output */ : "l"(tmp));
		tmp &= (unsigned int)round;
		if (tmp) {
			tmp = (unsigned int)(-1);
			break;
		}
		asm volatile ("or SR, %0;" : /* No Output */ : "l"(round));
		tmp = 0;
		break;
	}
	return (int)tmp;
}


/** Raise given exceptions */
LIB_FUNC int feraiseexcept(const int excepts) {
	asm volatile ("or G2, %0;" : /* No Output */ : "l"((excepts >> 8)));
	return 0;
}


/** Test exception in current environment */
LIB_FUNC int fetestexcept(const int excepts) {
	register unsigned int G2, G2en, G2dis, enabled_excepts, disabled_excepts;
	if (excepts & (~0x1F00)) { return -1; }
	asm volatile ("mov %0, SR;" : "=l"(enabled_excepts));
	enabled_excepts &= 0x1F00;
	disabled_excepts = (~enabled_excepts);
	disabled_excepts &= 0x1F00;
	asm volatile ("mov %0, G2;" : "=l"(G2));
	G2en = G2 & 0x1F00;
	G2dis = G2 & 0x1F;
	G2en &= enabled_excepts;
	G2dis &= (disabled_excepts >> 8);
	return (int)(G2en | (G2dis << 8));
}


/** Initialize the given floating-point environment and raise exceptions */
LIB_FUNC int feupdateenv(fenv_t* restrict envp) {
	register unsigned long clearSR = 0x7f00;  // 127 << 8
	asm volatile ("or SR, %1;" "or SR, %2;" : /* No Output */
		: "l"(clearSR), "l"(envp->round_mode), "l"(envp->accrued_except)
	);
	asm volatile ("or G2, %0;" "or G2, %1;" : /* No Output */
		: "l"((envp->accrued_except >> 8)), "l"(envp->actual_except)
	);
	return 0x0;
}


#endif  // SOFT_FLOAT


#define fegetexceptflag(flagp, excepts)   fegetexcept((flagp), (excepts))
#define fesetexceptflag(flagp, excepts)   fesetexcept((flagp), (excepts))
#define _fegetexcept(flagp, excepts)   fegetexcept((flagp), (excepts))
#define _fesetexcept(flagp, excepts)   fesetexcept((flagp), (excepts))


#endif  // CPU_MATH_PRIVATE_H


#if ((!(defined(ALPHA_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(ALPHA))
#define ALPHA_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	unsigned long fpcr;
	asm volatile ("excb;" "mf_fpcr %0;" : "=f"(fpcr));
	return (fpcr >> FPCR_ROUND_SHIFT) & 3;
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(_AARCH64_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(AARCH64))
#define _AARCH64_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fpcr;
	_FPU_GETCW(fpcr);
	return (int)(fpcr & _FPU_FPCR_RM_MASK);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(_ARM_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(ARM))
#define _ARM_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fpscr;
	if (!ARM_HAVE_VFP) { return FE_TONEAREST; }
	_FPU_GETCW(fpscr);
	return (int)(fpscr & _FPU_MASK_RM);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(_HPPA_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(HPPA))
#define _HPPA_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fc;
	_FPU_GETCW(fc);
	return (int)(fc & _FPU_HPPA_MASK_RM);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(IA64_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(ITANIUM))
#define IA64_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fenv_t fpsr;
	asm volatile ("mov.m %0=ar.fpsr;" : "=r"(fpsr));
	return (int)(fpsr >> 10) & 3);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(_POWERPC_NOFPU_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(POWERPC))
#define _POWERPC_NOFPU_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	return __sim_round_mode_thread;
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif ((!(defined(_S390_GET_ROUNDING_MODE_H) || defined(GET_ROUNDING_MODE_DEFINED))) && defined(S390))
#define _S390_GET_ROUNDING_MODE_H   (1)


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
	fpu_control_t fc;
	_FPU_GETCW(fc);
	return (int)(fc & FPC_RM_MASK);
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#elif (!defined(GET_ROUNDING_MODE_DEFINED))


/** Return the floating-point rounding mode */
LIB_FUNC int get_rounding_mode(void) {
#if (defined(_FPU_RC_DOWN) || defined(_FPU_RC_NEAREST) || defined(_FPU_RC_ZERO) || defined(_FPU_RC_UP))
	fpu_control_t fc;
#   ifdef _FPU_RC_DOWN
	const fpu_control_t mask = (0 | _FPU_RC_DOWN);
#   elif defined(_FPU_RC_NEAREST)
	const fpu_control_t mask = (0 | _FPU_RC_NEAREST);
#   elif defined(_FPU_RC_ZERO)
	const fpu_control_t mask = (0 | _FPU_RC_ZERO);
#   elif defined(_FPU_RC_UP)
	const fpu_control_t mask = (0 | _FPU_RC_UP);
#   endif
	_FPU_GETCW(fc);
	switch (fc & mask) {
#   ifdef _FPU_RC_DOWN
		case _FPU_RC_DOWN: return FE_DOWNWARD;
#   endif
#   if defined(_FPU_RC_NEAREST)
		case _FPU_RC_NEAREST: return FE_TONEAREST;
#   endif
#   if defined(_FPU_RC_ZERO)
		case _FPU_RC_ZERO: return FE_TOWARDZERO;
#   endif
#   if defined(_FPU_RC_UP)
		case _FPU_RC_UP: return FE_UPWARD;
#   endif
		default: abort();
	}
	UNREACHABLE
#else
	return FE_TONEAREST;
#endif
}
#   define GET_ROUNDING_MODE_DEFINED   (1)


#endif  // get_rounding_mode


#ifdef I386  // Math barriers

/** Safely load x, even if it was manipulated by non-float-point operations. This macro returns the value of x. This ensures compiler does not abuse its knowledge about x value and not optimize future operations.

@CODE{.c}
float x;
SET_FLOAT_WORD(x, 0x80000001);  // sets a bit pattern
y = math_opt_barrier(x);  // "compiler, do not cheat!"
y = y * y;  // compiler cannot optimize; must use real multiply instruction
@ENDCODE
*/
#   define math_opt_barrier(x)   __extension__ ({ typeof((x)) __x = ((x)); asm (";" : "=t"(__x) : "0"(__x)); __x; })
/** Force expression x to be evaluated; This macro returns no value */
#   define math_force_eval(x)   __extension__ ({ typeof((x)) __x = ((x)); if (sizeof(((x))) >= SIZEOF_DOUBLE) { asm volatile (";" : : "m"(__x)); } else { asm volatile (";" : : "f"(__x)); } })
#   define raise_flag(x)   __extension__ ({ typeof((x)) __x = ((x)); asm (";" : "=t"(__x) : "0"(__x)); __x *= __x; if (sizeof(((x))) >= SIZEOF_DOUBLE) { asm volatile (";" : : "m"(__x)); } else { asm volatile (";" : : "f"(__x)); } })

#elif defined(X86_64)

#   define math_opt_barrier(x)   __extension__ ({ typeof((x)) __x = ((x)); if (sizeof(((x))) <= SIZEOF_DOUBLE) { asm (";" : "=x"(__x) : "0"(__x)); } else { asm (";" : "=t"(__x) : "0"(__x)); } __x; })
/** Force expression x to be evaluated; This macro returns no value */
#   define math_force_eval(x)   __extension__ ({ typeof((x)) __x = ((x)); if (sizeof(((x))) >= SIZEOF_DOUBLE) { asm volatile (";" : : "x"(__x)); } else { asm volatile (";" : : "f"(__x)); } })
#   define raise_flag(val_x)   __extension__ ({ typeof((val_x)) __x = ((val_x)); if (sizeof(((val_x))) > SIZEOF_DOUBLE) { asm volatile (";" : : "m"(__x)); } else if (sizeof(((val_x))) == SIZEOF_DOUBLE) { asm volatile (";" : : "x"(__x)); } else { asm volatile (";" : : "f"(__x)); } })

#elif defined(ARCHAARCH64)

#   define math_opt_barrier(x)   __extension__ ({ typeof(x) __x = (x); asm (";" : "+w"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ typeof(x) __x = (x); asm volatile (";" : : "w"(__x)); })

#elif defined(ARCHALPHA)

#   define math_opt_barrier(x)   __extension__ ({ typeof(x) __x = (x); asm (";" : "+frm"(__x)); __x; })
#   define math_force_eval(x)   __extension__ ({ typeof(x) __x = (x); asm volatile (";" : : "frm"(__x)); })

#elif defined(ARCHM68K)

#   ifndef M68K_MATH_PRIVATE_H
#      define M68K_MATH_PRIVATE_H   (1)
#   endif
#   define math_opt_barrier(x)   __extension__ ({ typeof(x) __x; asm (";" : "=f"(__x) : "0"(x)); __x; })
#   define math_force_eval(x)   __extension__ ({ typeof(x) __x = (x); if (sizeof(x) <= SIZEOF_DOUBLE) { asm volatile (";" : : "m"(__x)); } else { asm volatile (";" : : "f"(__x)); } })

#endif  // Math barriers


#ifndef math_opt_barrier
#   define math_opt_barrier(x)   do { typeof(x) __x = ((x)); asm (";" : "+m"(__x)); __x; } while (0x0)
#endif


#ifndef math_force_eval
/** Force expression x to be evaluated; This macro returns no value */
#   define math_force_eval(x)   do { typeof(x) __x = ((x)); asm volatile (";" : : "m"(__x)); } while (0x0)
#endif


#ifndef raise_flag
#   define raise_flag(x)   do { typeof(x) __x = ((x)); asm (";" : "+m"(__x)); asm volatile (";" : : "m"(__x)); } while (0x0)
#endif


#ifndef FORCE_EVAL
#   define FORCE_EVAL(x)   math_force_eval((x))
#endif


// Define values for FE_* modes not defined for this architecture
#ifdef FE_DOWNWARD
#   define ORIG_FE_DOWNWARD   FE_DOWNWARD
#else
#   define ORIG_FE_DOWNWARD   (0)
#endif
#ifdef FE_TONEAREST
#   define ORIG_FE_TONEAREST   FE_TONEAREST
#else
#   define ORIG_FE_TONEAREST   (0)
#endif
#ifdef FE_TOWARDZERO
#   define ORIG_FE_TOWARDZERO   FE_TOWARDZERO
#else
#   define ORIG_FE_TOWARDZERO   (0)
#endif
#ifdef FE_UPWARD
#   define ORIG_FE_UPWARD   FE_UPWARD
#else
#   define ORIG_FE_UPWARD   (0)
#endif
#define FE_CONSTRUCT_DISTINCT_VALUE(X, Y, Z)   ((((X) & 1) | ((Y) & 2) | ((Z) & 4)) ^ 7)
#ifndef FE_DOWNWARD
#   define FE_DOWNWARD   FE_CONSTRUCT_DISTINCT_VALUE(ORIG_FE_TONEAREST, ORIG_FE_TOWARDZERO, ORIG_FE_UPWARD)
#endif
#ifndef FE_TONEAREST
#   define FE_TONEAREST   FE_CONSTRUCT_DISTINCT_VALUE(FE_DOWNWARD, ORIG_FE_TOWARDZERO, ORIG_FE_UPWARD)
#endif
#ifndef FE_TOWARDZERO
#   define FE_TOWARDZERO   FE_CONSTRUCT_DISTINCT_VALUE(FE_DOWNWARD, FE_TONEAREST, ORIG_FE_UPWARD)
#endif
#ifndef FE_UPWARD
#    define FE_UPWARD   FE_CONSTRUCT_DISTINCT_VALUE(FE_DOWNWARD, FE_TONEAREST, FE_TOWARDZERO)
#endif


#endif  // GET_ROUNDING_MODE_H


#ifndef FENV_ALIAS_MACROS
#define FENV_ALIAS_MACROS   (1)


LIB_FUNC void default_libc_feholdexcept(fenv_t* restrict e) {
	(void)feholdexcept(e);
}

#ifndef libc_feholdexcept
#   define libc_feholdexcept   default_libc_feholdexcept
#endif
#ifndef libc_feholdexceptf
#   define libc_feholdexceptf   default_libc_feholdexcept
#endif
#ifndef libc_feholdexceptl
#   define libc_feholdexceptl   default_libc_feholdexcept
#endif

LIB_FUNC void default_libc_fesetround(const int r) {
	(void)fesetround(r);
}

#ifndef libc_fesetround
#   define libc_fesetround   default_libc_fesetround
#endif
#ifndef libc_fesetroundf
#   define libc_fesetroundf   default_libc_fesetround
#endif
#ifndef libc_fesetroundl
#   define libc_fesetroundl   default_libc_fesetround
#endif

LIB_FUNC void default_libc_feholdexcept_setround(fenv_t* restrict e, const int r) {
	feholdexcept(e);
	fesetround(r);
}

#ifndef libc_feholdexcept_setround
#   define libc_feholdexcept_setround   default_libc_feholdexcept_setround
#endif
#ifndef libc_feholdexcept_setroundf
#   define libc_feholdexcept_setroundf   default_libc_feholdexcept_setround
#endif
#ifndef libc_feholdexcept_setroundl
#   define libc_feholdexcept_setroundl   default_libc_feholdexcept_setround
#endif

#ifndef libc_feholdsetround_53bit
#   define libc_feholdsetround_53bit   libc_feholdsetround
#endif

#ifndef libc_fetestexcept
#   define libc_fetestexcept   fetestexcept
#endif
#ifndef libc_fetestexceptf
#   define libc_fetestexceptf   fetestexcept
#endif
#ifndef libc_fetestexceptl
#   define libc_fetestexceptl   fetestexcept
#endif

LIB_FUNC void default_libc_fesetenv(fenv_t* e) {
	 (void)fesetenv(e);
}

#ifndef libc_fesetenv
#   define libc_fesetenv   default_libc_fesetenv
#endif
#ifndef libc_fesetenvf
#   define libc_fesetenvf   default_libc_fesetenv
#endif
#ifndef libc_fesetenvl
#   define libc_fesetenvl   default_libc_fesetenv
#endif

LIB_FUNC void default_libc_feupdateenv(fenv_t* restrict e) {
	(void)feupdateenv(e);
}

#ifndef libc_feupdateenv
#   define libc_feupdateenv   default_libc_feupdateenv
#endif
#ifndef libc_feupdateenvf
#   define libc_feupdateenvf   default_libc_feupdateenv
#endif
#ifndef libc_feupdateenvl
#   define libc_feupdateenvl   default_libc_feupdateenv
#endif

#ifndef libc_feresetround_53bit
#   define libc_feresetround_53bit   libc_feresetround
#endif

LIB_FUNC int default_libc_feupdateenv_test(fenv_t* restrict e, const int ex) {
	int ret = fetestexcept(ex);
	feupdateenv(e);
	return ret;
}

#ifndef libc_feupdateenv_test
#   define libc_feupdateenv_test   default_libc_feupdateenv_test
#endif
#ifndef libc_feupdateenv_testf
#   define libc_feupdateenv_testf   default_libc_feupdateenv_test
#endif
#ifndef libc_feupdateenv_testl
#   define libc_feupdateenv_testl   default_libc_feupdateenv_test
#endif

#ifndef libc_feholdsetround
#   define libc_feholdsetround   libc_feholdexcept_setround
#endif
#ifndef libc_feholdsetroundf
#   define libc_feholdsetroundf   libc_feholdexcept_setroundf
#endif
#ifndef libc_feholdsetroundl
#   define libc_feholdsetroundl   libc_feholdexcept_setroundl
#endif

#ifndef libc_feresetround
#   define libc_feresetround   libc_feupdateenv
#endif
#ifndef libc_feresetroundf
#   define libc_feresetroundf   libc_feupdateenvf
#endif
#ifndef libc_feresetroundl
#   define libc_feresetroundl   libc_feupdateenvl
#endif

#ifndef libc_feresetround_noex
#   define libc_feresetround_noex   libc_fesetenv
#endif
#ifndef libc_feresetround_noexf
#   define libc_feresetround_noexf   libc_fesetenvf
#endif
#ifndef libc_feresetround_noexl
#   define libc_feresetround_noexl   libc_fesetenvl
#endif

#ifndef HAVE_RM_CTX
#   define HAVE_RM_CTX   (0x0)
#endif


#endif  // FENV_ALIAS_MACROS


// MISCELLANEOUS FENV CODE


enum FP_EXCEPTIONS {
	INEXACT = FE_INEXACT,
	DIVBYZERO = FE_DIVBYZERO,
	UNDERFLOW = FE_UNDERFLOW,
	OVERFLOW = FE_OVERFLOW,
	INVALID = FE_INVALID
};


enum ROUNDING_DIRECTIONS {
	TONEAREST = FE_TONEAREST,
	TOWARDZERO = FE_TOWARDZERO,
	UPWARD = FE_UPWARD,
	DOWNWARD = FE_DOWNWARD
};


/** A union that permits conversions between a float and a 32-bit int */
typedef union ieee_float_shape_type {
	float value;
	uint32_t word;
} ieee_float_shape_type;


/** A union that permits conversions between a float and a 32-bit signed int */
typedef union ieee_float_shape_stype {
	float value;
	int32_t word;
} ieee_float_shape_stype;


/** A union that permits conversions between a float and various datatypes */
typedef union ieee_float_shape {
	float value;
	int32_t sword;
	uint32_t uword;
#if SUPPORTS_DECIMAL32
	decimal32 decword;
#endif
} ieee_float_shape;


typedef const union ufloat { long l; float f; }   ufloat;


#ifndef GET_FLOAT_WORD
/** Get a 32-bit int from a float */
#   define GET_FLOAT_WORD(i, d)   do { ieee_float_shape_type gf_u; gf_u.value = ((d)); ((i)) = gf_u.word; } while (0x0)
#endif


#ifndef GET_FLOAT_SIGNED_WORD
/** Get a 32-bit signed int from a float */
#   define GET_FLOAT_SIGNED_WORD(i, d)   do { ieee_float_shape_stype gf_s; gf_s.value = ((d)); ((i)) = gf_s.word; } while (0x0)
#endif


#ifndef SET_FLOAT_WORD
/** Set a float from a 32-bit int */
#   define SET_FLOAT_WORD(d, i)   do { ieee_float_shape_type sf_u; sf_u.word = (uint32_t)((i)); ((d)) = (float)sf_u.value; } while (0x0)
#endif


/** Math on arm is special:
 - For FPA, float words are always big-endian
 - For VFP, float words follow the memory system mode
 - For Maverick, float words are always little-endian
*/
#if ((!defined(__MAVERICK__)) && (IS_BIG_ENDIAN || (!defined(__VFP_FP__) && (defined(ARM) || defined(ARM_THUMB)))))

/** A union that permits conversions between a double and two 32-bit ints (or one 64-bit int) */
typedef union ieee_double_shape_type {
	double value;
	uint64_t dword;
	struct { uint32_t msw, lsw; } parts;
} ieee_double_shape_type;

/** A union that permits conversions between a double and two 32-bit signed ints (or one 64-bit int) */
typedef union ieee_double_shape_stype {
	double value;
	int64_t dword;
	struct { int32_t msw, lsw; } parts;
} ieee_double_shape_stype;

#else

/** A union that permits conversions between a double and two 32-bit ints (or one 64-bit int) */
typedef union ieee_double_shape_type {
	double value;
	uint64_t dword;
	struct { uint32_t lsw, msw; } parts;
} ieee_double_shape_type;

/** A union that permits conversions between a double and two 32-bit signed ints (or one 64-bit int) */
typedef union ieee_double_shape_stype {
	double value;
	int64_t dword;
	struct { int32_t lsw, msw; } parts;
} ieee_double_shape_stype;

#endif


typedef const union udouble { long l[2]; double d; }   udouble;


#ifndef EXTRACT_WORDS
/** Get two 32-bit ints from a double */
#   define EXTRACT_WORDS(ix0, ix1, d)   do { ieee_double_shape_type ew_u; ew_u.value = (double)((d)); ((ix0)) = ew_u.parts.msw; ((ix1)) = ew_u.parts.lsw; } while (0x0)
#endif
#ifndef EXTRACT_UWORDS
/** Get two 32-bit ints from a double */
#   define EXTRACT_UWORDS(ix0, ix1, d)   do { ieee_double_shape_type ew_uint; ew_uint.value = (double)((d)); ((ix0)) = (uint32_t)ew_uint.parts.msw; ((ix1)) = (uint32_t)ew_uint.parts.lsw; } while (0x0)
#endif
#ifndef EXTRACT_SIGNED_WORDS
/** Get two 32-bit signed ints from a double */
#   define EXTRACT_SIGNED_WORDS(ix0, ix1, d)   do { ieee_double_shape_stype ew_s; ew_s.value = (double)((d)); ((ix0)) = ew_s.parts.msw; ((ix1)) = ew_s.parts.lsw; } while (0x0)
#endif
#ifndef EXTRACT_SWORDS
/** Get two 32-bit ints from a double */
#   define EXTRACT_SWORDS(ix0, ix1, d)   EXTRACT_SIGNED_WORDS((ix0), (ix1), (d))
#endif


#ifndef GET_HIGH_WORD
/** Get the more significant 32-bit int from a double */
#   define GET_HIGH_WORD(i, d)   do { ieee_double_shape_type gh_u; gh_u.value = (double)((d)); ((i)) = gh_u.parts.msw; } while (0x0)
#endif


#ifndef GET_HIGH_SIGNED_WORD
/** Get the more significant 32-bit signed int from a double */
#   define GET_HIGH_SIGNED_WORD(i, d)   do { ieee_double_shape_stype gh_s; gh_s.value = (double)((d)); ((i)) = gh_s.parts.msw; } while (0x0)
#endif


#ifndef GET_HIGH_SWORD
/** Get the more significant 32-bit signed int from a double */
#   define GET_HIGH_SWORD(i, d)   GET_HIGH_SIGNED_WORD((i), (d))
#endif


/** Get the less significant 32-bit int from a double */
#define GET_LOW_WORD(i, d)   do { ieee_double_shape_type gl_u; gl_u.value = (double)((d)); ((i)) = gl_u.parts.lsw; } while (0x0)


/** Get the less significant 32-bit signed int from a double */
#define GET_LOW_SIGNED_WORD(i, d)   do { ieee_double_shape_stype gl_s; gl_s.value = (double)((d)); ((i)) = gl_s.parts.lsw; } while (0x0)


#ifndef GET_LOW_SWORD
/** Get the less significant 32-bit signed int from a double */
#   define GET_LOW_SWORD(i, d)   GET_LOW_SIGNED_WORD((i), (d))
#endif


/** Set a double from two 32-bit ints */
#define INSERT_WORDS(d, ix0, ix1)   do { ieee_double_shape_type iw_u; iw_u.parts.msw = ((ix0)); iw_u.parts.lsw = ((ix1)); ((d)) = iw_u.value; } while (0x0)


/** Set the more significant 32-bits of a double from an int */
#define SET_HIGH_WORD(d, v)   do { ieee_double_shape_type sh_u; sh_u.value = (double)((d)); sh_u.parts.msw = (uint32_t)((v)); ((d)) = sh_u.value; } while (0x0)


/** Set the less significant 32 bits of a double from an int */
#define SET_LOW_WORD(d, v)   do { ieee_double_shape_type sl_u; sl_u.value = (double)((d)); sl_u.parts.lsw = (uint32_t)((v)); ((d)) = sl_u.value; } while (0x0)


#if (LONG_DOUBLE_IS_X87_EXTENDED && IS_LITTLE_ENDIAN)
typedef union ldshape {
	long double f;
	struct {
		uint64_t m;
		uint16_t se;
	} i;
} ldshape_t;
#elif (LONG_DOUBLE_IS_BINARY128 && IS_LITTLE_ENDIAN)
typedef union ldshape {
	long double f;
	struct {
		uint64_t lo;
		uint32_t m;
		uint16_t top, se;
	} i;
	struct { uint64_t lo, hi; } i2;
} ldshape_t;
#elif (LONG_DOUBLE_IS_BINARY128 && IS_BIG_ENDIAN)
typedef union ldshape {
	long double f;
	struct {
		uint16_t se, top;
		uint32_t m;
		uint64_t lo;
	} i;
	struct { uint64_t hi, lo; } i2;
} ldshape_t;
#else
#   error   "Unsupported long double representation!"
#endif


#if IS_FLOAT_BIG_ENDIAN


/** A union that permits conversions between a long double and four 32-bit ints, two 64-bit ints, or one 128-bit int */
typedef union ieee854_long_double_shape_type {
	long double value;
#   if SUPPORTS_UINT128
	uint128_t qword;
#   endif
	struct { uint64_t msw, lsw; } parts64;
	struct { int64_t msw, lsw; } sparts64;
	struct { uint32_t w0, w1, w2, w3; } parts32;
} ieee854_long_double_shape_type;


/** A union that permits conversions between a long double and four 32-bit ints, two 64-bit ints, or one 128-bit int (all signed) */
typedef union ieee854_long_double_shape_stype {
	long double value;
#   if SUPPORTS_INT128
	int128_t qword;
#   endif
	struct { int64_t msw, lsw; } parts64;
	struct { int32_t w0, w1, w2, w3; } parts32;
} ieee854_long_double_shape_stype;


#elif IS_FLOAT_LITTLE_ENDIAN


/** A union that permits conversions between a long double and four 32-bit ints, two 64-bit ints, or one 128-bit int */
typedef union ieee854_long_double_shape_type {
	long double value;
#   if SUPPORTS_UINT128
	uint128_t qword;
#   endif
	struct { uint64_t lsw, msw; } parts64;
	struct { int64_t lsw, msw; } sparts64;
	struct { uint32_t w3, w2, w1, w0; } parts32;
} ieee854_long_double_shape_type;


/** A union that permits conversions between a long double and four 32-bit ints, two 64-bit ints, or one 128-bit int (all signed) */
typedef union ieee854_long_double_shape_stype {
	long double value;
#   if SUPPORTS_INT128
	int128_t qword;
#   endif
	struct { int64_t lsw, msw; } parts64;
	struct { int32_t w3, w2, w1, w0; } parts32;
} ieee854_long_double_shape_stype;


#else
#   error   "Unsupported system endian (ieee854_long_double_shape_type)"
#endif


#if SUPPORTS_INT128
/** Get a 128-bit int from a long double */
#   define GET_LDOUBLE_WORDS128(ix0, d)   do { ieee854_long_double_shape_type qw_u; qw_u.value = (long double)((d)); ((ix0)) = qw_u.qword; } while (0x0)
/** Set a long double from two 64 bit ints */
#   define SET_LDOUBLE_WORDS128(d, ix0)   do { ieee854_long_double_shape_type qw_u; qw_u.qword = (uint128_t)((ix0)); ((d)) = (long double)qw_u.value; } while (0x0)
#endif


/** Get two 64 bit ints from a long double */
#define GET_LDOUBLE_WORDS64(ix0, ix1, d)   do { ieee854_long_double_shape_type qw_u; qw_u.value = (long double)((d)); ((ix0)) = qw_u.parts64.msw; ((ix1)) = qw_u.parts64.lsw; } while (0x0)


/** Get two signed 64 bit ints from a long double */
#define GET_LDOUBLE_SWORDS64(ix0, ix1, d)   do { ieee854_long_double_shape_stype qw_s; qw_s.value = (long double)((d)); ((ix0)) = qw_s.parts64.msw; ((ix1)) = qw_s.parts64.lsw; } while (0x0)


/** Get the MSW (64-bit int) from a long double */
#define GET_LDOUBLE_WORDS64_MSW(ix0, d)   do { ieee854_long_double_shape_type qw_u; qw_u.value = (long double)((d)); ((ix0)) = qw_u.parts64.msw; } while (0x0)


/** Set a long double from two 64 bit ints */
#define SET_LDOUBLE_WORDS64(d, ix0, ix1)   do { ieee854_long_double_shape_type qw_u; qw_u.parts64.msw = (uint64_t)((ix0)); qw_u.parts64.lsw = (uint64_t)((ix1)); ((d)) = qw_u.value; } while (0x0)


/** Get the more significant 64 bits of a long double mantissa */
#define GET_LDOUBLE_MSW64(v, d)   do { ieee854_long_double_shape_type sh_u; sh_u.value = (long double)((d)); ((v)) = sh_u.parts64.msw; } while (0x0)


/** Get the more significant 64 bits (signed) of a long double mantissa */
#define GET_LDOUBLE_MSW64S(v, d)   do { ieee854_long_double_shape_type sh_s; sh_s.value = (long double)((d)); ((v)) = sh_s.sparts64.msw; } while (0x0)


/** Set the more significant 64 bits of a long double mantissa from an int */
#define SET_LDOUBLE_MSW64(d, v)   do { ieee854_long_double_shape_type sh_u; sh_u.value = (long double)((d)); sh_u.parts64.msw = (uint64_t)((v)); ((d)) = sh_u.value; } while (0x0)


/** Get the least significant 64 bits of a long double mantissa */
#define GET_LDOUBLE_LSW64(v, d)   do { ieee854_long_double_shape_type sh_u; sh_u.value = (long double)((d)); ((v)) = sh_u.parts64.lsw; } while (0x0)


/** Get the least significant 64 bits (signed) of a long double mantissa */
#define GET_LDOUBLE_LSW64S(v, d)   do { ieee854_long_double_shape_type sh_s; sh_s.value = (long double)((d)); ((v)) = sh_s.sparts64.lsw; } while (0x0)


// FLOAT & INTEGER CONVERSIONS


/** Convert a float to uint32_t */
#define FLT_TO_U32(x)   __extension__ ({ ieee_float_shape_type FLT_TO_U32_tmp; FLT_TO_U32_tmp.value = x; (uint32_t)FLT_TO_U32_tmp.word; })
/** Convert a float to uint32_t */
#define float2u32(x)   FLT_TO_U32((x))
/** Convert a uint32_t to float */
#define U32_TO_FLT(x)   __extension__ ({ ieee_float_shape_type U32_TO_FLT_tmp; U32_TO_FLT_tmp.word = x; (float)U32_TO_FLT_tmp.value; })
/** Convert a double to uint64_t */
#define DBL_TO_U64(x)   __extension__ ({ ieee_double_shape_type DBL_TO_U64_tmp; DBL_TO_U64_tmp.value = x; (uint64_t)DBL_TO_U64_tmp.dword; })
/** Convert a uint64_t to double */
#define U64_TO_DBL(x)   __extension__ ({ ieee_double_shape_type U64_TO_DBL_tmp; U64_TO_DBL_tmp.dword = x; (double)U64_TO_DBL_tmp.value; })
#define float32_to_float16(x)   (((((x) & 0x7fffffff) >> 13) - 0x1c000) | ((((x) & 0x80000000) >> 16)))


#endif  // FENV_H


/* IMPORTANT MATH CONSTANTS */


#if (!(defined(MATH_H_MATHDEF) || defined(_MATH_H_MATHDEF) || defined(_MATH_H_MATHDEF_) || defined(MATH_X_STATIC_CONSTANTS_SEEN)))
#define MATH_H_MATHDEF   (1)
#define _MATH_H_MATHDEF   (1)
#define _MATH_H_MATHDEF_   (1)
#define MATH_X_STATIC_CONSTANTS_SEEN   (1)


#define INFSTR   "Infinity"
#define NANSTR   "NaN"


static const UNUSED float ZEROF[2] = { 0.0F, (-0.0F) };
static const UNUSED double ZERO[2] = { 0.0, (-0.0) };
static const UNUSED long double ZEROL[2] = { 0.0L, (-0.0L) };
#if SUPPORTS_DECIMAL_FLOATS
__extension__ static const UNUSED decimal32 ZERODF[2] = { 0.0DF, (-0.0DF) };
__extension__ static const UNUSED decimal64 ZERODD[2] = { 0.0DD, (-0.0DD) };
#   ifdef SUPPORTS_DECIMAL128
__extension__ static const UNUSED decimal128 ZERODL[2] = { 0.0DL, (-0.0DL) };
#   endif
#endif
#ifdef OSHPUX
static const UNUSED float zerof = 0.0F;
static const UNUSED double zerod = 0.0;
static const UNUSED long double zerol = 0.0L;
#   if SUPPORTS_DECIMAL_FLOATS
__extension__ static const UNUSED decimal32 zerodf = 0.0DF;
__extension__ static const UNUSED decimal64 zerodd = 0.0DD;
#      ifdef SUPPORTS_DECIMAL128
__extension__ static const UNUSED decimal128 zerodl = 0.0DL;
#      endif
#   endif
#else
#   define zerof   0.0F
#   define zerod   0.0
#   define zerol   0.0L
#   if SUPPORTS_DECIMAL_FLOATS
#      define zerodf   (__extension__ (0.0DF))
#      define zerodd   (__extension__ (0.0DD))
#      ifdef SUPPORTS_DECIMAL128
#         define zerodl   (__extension__ (0.0DL))
#      endif
#   endif
#endif
// COMPLEX CONSTANTS
#ifndef COMPLEX_CONSTANTS_SEEN
#define COMPLEX_CONSTANTS_SEEN
#   if (defined(I_FLOAT) && defined(I_DOUBLE) && defined(I_LONG_DOUBLE))
#      define COMPLEX_ONE   (__extension__ (1.0 + 0.0 * I_DOUBLE))
#      define COMPLEX_ONEf   (__extension__ (1.0F + 0.0F * I_FLOAT))
#      define COMPLEX_ONEl   (__extension__ (1.0L + 0.0L * I_LONG_DOUBLE))
#      define COMPLEX_ZERO   (__extension__ (0.0 + 0.0 * I_DOUBLE))
#      define COMPLEX_ZEROf   (__extension__ (0.0F + 0.0F * I_FLOAT))
#      define COMPLEX_ZEROl   (__extension__ (0.0L + 0.0L * I_LONG_DOUBLE))
#   endif
#endif


static const UNUSED float TWO23[2] = {
	8.3886080000e+06F,  // 0x4B000000
	-8.3886080000e+06F,  // 0xCB000000
};


static const UNUSED double TWO52[2] = {
	4.50359962737049600000e+15,  // 0x43300000, 0x0
	-4.50359962737049600000e+15,  // 0xC3300000, 0x0
};


static const UNUSED long double TWO112[2] = {
	5.19229685853482762853049632922009600E+33L,  // 0x406F000000000000, 0
	-5.19229685853482762853049632922009600E+33L  // 0xC06F000000000000, 0
};


static const UNUSED double GAMMA_INTEGRAL[32] = {
	1.0,
	1.0,
	2.0,
	6.0,
	24.0,
	120.0,
	720.0,
	5040.0,
	40320.0,
	362880.0,
	3628800.0,
	39916800.0,
	479001600.0,
	6227020800.0,
	87178291200.0,
	1307674368000.0,
	20922789888000.0,
	355687428096000.0,
	6402373705728000.0,
	121645100408832000.0,
	2432902008176640000.0,
	51090942171709440000.0,
	1124000727777607680000.0
};


static const UNUSED double LANCZOS_DEN_COEFFS[16] = {
	0.0,
	39916800.0,
	120543840.0,
	150917976.0,
	105258076.0,
	45995730.0,
	13339535.0,
	2637558.0,
	357423.0,
	32670.0,
	1925.0,
	66.0,
	1.0
};


static const UNUSED double LANCZOS_NUM_COEFFS[16] = {
	23531376880.410759688572007674451636754734846804940,
	42919803642.649098768957899047001988850926355848959,
	35711959237.355668049440185451547166705960488635843,
	17921034426.037209699919755754458931112671403265390,
	6039542586.3520280050642916443072979210699388420708,
	1439720407.3117216736632230727949123939715485786772,
	248874557.86205415651146038641322942321632125127801,
	31426415.585400194380614231628318205362874684987640,
	2876370.6289353724412254090516208496135991145378768,
	186056.26539522349504029498971604569928220784236328,
	8071.6720023658162106380029022722506138218516325024,
	210.82427775157934587250973392071336271166969580291,
	2.5066282746310002701649081771338373386264310793408
};


#if BIG_ENDIAN
static const UNUSED ieee754_remainder_double _BIG = {{ 0x43380000, 0 }};  // 6755399441055744
static const UNUSED ieee754_remainder_double _T128 = {{ 0x47f00000, 0 }};  // 2^128
static const UNUSED ieee754_remainder_double _TM128 = {{ 0x37f00000, 0 }};  // 2^-128
static const UNUSED ieee754_remainder_double _ZERO = {{ 0, 0 }};  // 0.0
static const UNUSED ieee754_remainder_double _NZERO = {{ (int)0x80000000, 0 }};  // -0.0
#else  // LITTLE_ENDIAN
static const UNUSED ieee754_remainder_double _BIG = {{ 0, 0x43380000 }};  // 6755399441055744
static const UNUSED ieee754_remainder_double _T128 = {{ 0, 0x47f00000 }};  // 2^128
static const UNUSED ieee754_remainder_double _TM128 = {{ 0, 0x37f00000 }};  // 2^-128
static const UNUSED ieee754_remainder_double _ZERO = {{ 0, 0 }};  // 0.0
static const UNUSED ieee754_remainder_double _NZERO = {{ 0, (int)0x80000000 }};  // -0.0
#endif


static const UNUSED double BIGX = 7.09782712893383973096e+02;
static const UNUSED double SMALLX = -7.45133219101941108420e+02;
static const UNUSED double z_rooteps = 7.4505859692e-9;
static const UNUSED float  z_rooteps_f = (float)1.7263349182589107e-4;
static const UNUSED ufloat z_hugeval_f = { 0x7f800000 };
static const UNUSED ufloat z_infinity_f = { 0x7f800000 };
static const UNUSED ufloat z_notanum_f = { 0xffd00000 };
#ifdef IS_BIG_ENDIAN
static const UNUSED udouble z_hugeval = { .l = { 0x7ff00000L, 0L } };
static const UNUSED udouble z_infinity = { .l = { 0x7ff00000L, 0L } };
static const UNUSED udouble z_notanum = { .l = { 0xfff80000L, 0L } };
#else
static const UNUSED udouble z_hugeval = { .l = { 0L, 0x7ff00000L } };
static const UNUSED udouble z_infinity = { .l = { 0L, 0x7ff00000L } };
static const UNUSED udouble z_notanum = { .l = { 0L, 0xfff80000L } };
#endif


/** This variable is used by `gamma` and `lgamma` */
extern UNUSED int signgam;
/** The value returned by `ilogb` for 0 */
#define FP_ILOGB0   (-2147483647)
/** The value returned by `ilogb` for NaN */
#define FP_ILOGBNAN   (2147483647)
#define __PI   (3.14159265358979323846)
#define __SQRT_HALF   (0.70710678118654752440)
#define __PI_OVER_TWO   (1.57079632679489661923132)
#define TINYF   ((float)(1.0e-30F))
#define TINY   ((double)(1.0e-300))
#define TINYL   ((long double)(1.0e-4930L))
#define HUGEF   ((float)1.0e30F)
#define HUGE   ((double)1.0e300)
#define HUGEL   ((long double)1.0e4930L)
#define ONEF   (1.0F)
#define ONE   (1.0)
#define ONEL   (1.0L)
#if SUPPORTS_DECIMAL_FLOATS
#   define HUGEDF   (1.0e30DF)
#   define HUGEDD   (1.0e300DD)
#   define ONEDF   (1.0DF)
#   define ONEDD   (1.0DD)
#   ifdef SUPPORTS_DECIMAL128
#      define HUGEDL   (1.0e4930DL)
#      define ONEDL   (1.0DL)
#   endif
#endif
#define M_E   (2.7182818284590452354)  // e
#define M_LOG2E   (1.4426950408889634074)  // log_2 e
#define M_LOG10E   (0.43429448190325182765)  // log_10 e
#define M_LN2   (0.69314718055994530942)  // log_e 2
#define M_LN10F   ((float)2.30258509299404568402F)  // log_e 10
#define M_LN10   (2.30258509299404568402)  // log_e 10
#define M_PI   (3.14159265358979323846)  // pi
#define M_PI_2   (1.57079632679489661923)  // pi/2
#define M_PI_4   (0.78539816339744830962)  // pi/4
#define M_1_PI   (0.31830988618379067154)  // 1/pi
#define M_2_PI   (0.63661977236758134308)  // 2/pi
#define M_2_SQRTPI   (1.12837916709551257390)  // 2/sqrt(pi)
#define M_SQRT2   (1.41421356237309504880)  // sqrt(2)
/** 1/sqrt(2) */
#define M_SQRT1_2   (0.70710678118654752440)
/** 1/log(10) */
#define M_IVLN10F   ((float)0.43429448190325182765F)
/** 1/log(10) */
#define M_IVLN10   (0.43429448190325182765)
// The above constants are not adequate for `long double`; Provide enough digits for the 128-bit IEEE quad
#if SUPPORTS_LONG_DOUBLE
#   define M_El   (2.718281828459045235360287471352662498L)  // e
#   define M_LOG2El   (1.442695040888963407359924681001892137L)  // log_2 e
#   define M_LOG10El   (0.434294481903251827651128918916605082L)  // log_10 e
#   define M_LN2l   (0.693147180559945309417232121458176568L)  // log_e 2
#   define M_LN10l   (2.302585092994045684017991454684364208L)  // log_e 10
#   define M_PIl   (3.141592653589793238462643383279502884L)  // pi
#   define M_PI_2l   (1.570796326794896619231321691639751442L)  // pi/2
#   define M_PI_4l   (0.785398163397448309615660845819875721L)  // pi/4
#   define M_1_PIl   (0.318309886183790671537767526745028724L)  // 1/pi
#   define M_2_PIl   (0.636619772367581343075535053490057448L)  // 2/pi
#   define M_2_SQRTPIl   (1.128379167095512573896158903121545172L)  // 2/sqrt(pi)
#   define M_SQRT2l   (1.414213562373095048801688724209698079L)  // sqrt(2)
#   define M_SQRT1_2l   (0.707106781186547524400844362104849039L)  // 1/sqrt(2)
#endif
#define LOG10_E   (0.4342944819032518276511289189166050822943970058036665661144537831658646492088707747292249493384317483187061067447663037336416792871589639065692210646628122658521270865686703295933708696588266883311636077384905142844348666768646586085135561482)
#define LOG10_El   (0.4342944819032518276511289189166050822943970058036665661144537831658646492088707747292249493384317483187061067447663037336416792871589639065692210646628122658521270865686703295933708696588266883311636077384905142844348666768646586085135561482L)
#define LOG10_Ef   (0.4342944819032518276511289189166050822943970058036665661144537831658646492088707747292249493384317483187061067447663037336416792871589639065692210646628122658521270865686703295933708696588266883311636077384905142844348666768646586085135561482F)
#define LOG10_PI   (0.4971498726941338543512682882908988736516783243804424461340534999249471120895526746555473864642912223694285899923596439151287253374623084834360752165209902180283467621077569356859157072339384756636526629294044142052704231980047)
#define LOG10_PIl   (0.4971498726941338543512682882908988736516783243804424461340534999249471120895526746555473864642912223694285899923596439151287253374623084834360752165209902180283467621077569356859157072339384756636526629294044142052704231980047L)
#define LOG10_PIf   (0.4971498726941338543512682882908988736516783243804424461340534999249471120895526746555473864642912223694285899923596439151287253374623084834360752165209902180283467621077569356859157072339384756636526629294044142052704231980047F)
#define LOG_E   (1.0)
#define LOG_El   (1.0L)
#define LOG_Ef   (1.0F)
#define LOG_PI   (1.1447298858494001741434273513530587116472948129153115715136230714721377698848260797836232702754897077020098122286979891590482055279234565872790810788102868252763939142663459029024847733588699377892031196308247567940119160282172)
#define LOG_PIl   (1.1447298858494001741434273513530587116472948129153115715136230714721377698848260797836232702754897077020098122286979891590482055279234565872790810788102868252763939142663459029024847733588699377892031196308247567940119160282172L)
#define LOG_PIf   (1.1447298858494001741434273513530587116472948129153115715136230714721377698848260797836232702754897077020098122286979891590482055279234565872790810788102868252763939142663459029024847733588699377892031196308247567940119160282172F)
#ifndef PI
#   define PI   (3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652)
#endif
#ifndef PIl
#   define PIl   (3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652L)
#endif
#ifndef PIf
#   define PIf   (3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652F)
#endif
#ifndef PI2
#   define PI2   (6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359642961730265646132941876892191011644634507188162569622349005682054038770422111192892458979098607639288576219513318668922569512964675735663305)
#endif
#define PI2l   (6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359642961730265646132941876892191011644634507188162569622349005682054038770422111192892458979098607639288576219513318668922569512964675735663305L)
#define PI2f   (6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359642961730265646132941876892191011644634507188162569622349005682054038770422111192892458979098607639288576219513318668922569512964675735663305F)
#define PI4   (12.566370614359172953850573533118011536788677597500423283899778369231265625144835994512139301368468271928592346053129226588375378438202328926901437632513924469801136410807754084422238578491795819721527857715243902663733784513902592935147132661)
#define PI4l   (12.566370614359172953850573533118011536788677597500423283899778369231265625144835994512139301368468271928592346053129226588375378438202328926901437632513924469801136410807754084422238578491795819721527857715243902663733784513902592935147132661L)
#define PI4f   (12.566370614359172953850573533118011536788677597500423283899778369231265625144835994512139301368468271928592346053129226588375378438202328926901437632513924469801136410807754084422238578491795819721527857715243902663733784513902592935147132661F)
#define PI_4_3   (4.1887902047863909846168578443726705122628925325001410946332594564104218750482786648373797671228227573095307820177097421961251261460674429756338125441713081566003788036025846948074128594972652732405092859050813008879112615046341976450490442203)
#define PI_4_3l   (4.1887902047863909846168578443726705122628925325001410946332594564104218750482786648373797671228227573095307820177097421961251261460674429756338125441713081566003788036025846948074128594972652732405092859050813008879112615046341976450490442203L)
#define PI_4_3f   (4.1887902047863909846168578443726705122628925325001410946332594564104218750482786648373797671228227573095307820177097421961251261460674429756338125441713081566003788036025846948074128594972652732405092859050813008879112615046341976450490442203F)
#ifndef PI_SQUARED
#   define PI_SQUARED   (9.8696044010893586188344909998761511353136994072407906264133493762200448224192052430017734037185522318240259137740231440777723481220300467276106176779851976609903998562065756305715060412328403287808693527693421649396665715190445387352617794138)
#endif
#ifndef PI_SQUAREDl
#   define PI_SQUAREDl   (9.8696044010893586188344909998761511353136994072407906264133493762200448224192052430017734037185522318240259137740231440777723481220300467276106176779851976609903998562065756305715060412328403287808693527693421649396665715190445387352617794138L)
#endif
#ifndef PI_SQUAREDf
#   define PI_SQUAREDf   (9.8696044010893586188344909998761511353136994072407906264133493762200448224192052430017734037185522318240259137740231440777723481220300467276106176779851976609903998562065756305715060412328403287808693527693421649396665715190445387352617794138F)
#endif
#define PI_1_3   (1.0471975511965977461542144610931676280657231331250352736583148641026054687620696662093449417807056893273826955044274355490312815365168607439084531360428270391500947009006461737018532148743163183101273214762703252219778153761585494112622610550)
#define PI_1_3l   (1.0471975511965977461542144610931676280657231331250352736583148641026054687620696662093449417807056893273826955044274355490312815365168607439084531360428270391500947009006461737018532148743163183101273214762703252219778153761585494112622610550L)
#define PI_1_3f   (1.0471975511965977461542144610931676280657231331250352736583148641026054687620696662093449417807056893273826955044274355490312815365168607439084531360428270391500947009006461737018532148743163183101273214762703252219778153761585494112622610550F)
#define PI_2_3   (2.0943951023931954923084289221863352561314462662500705473166297282052109375241393324186898835614113786547653910088548710980625630730337214878169062720856540783001894018012923474037064297486326366202546429525406504439556307523170988225245221101)
#define PI_2_3l   (2.0943951023931954923084289221863352561314462662500705473166297282052109375241393324186898835614113786547653910088548710980625630730337214878169062720856540783001894018012923474037064297486326366202546429525406504439556307523170988225245221101L)
#define PI_2_3f   (2.0943951023931954923084289221863352561314462662500705473166297282052109375241393324186898835614113786547653910088548710980625630730337214878169062720856540783001894018012923474037064297486326366202546429525406504439556307523170988225245221101F)
#define PI_SQUARED_1_4   (2.4674011002723396547086227499690377838284248518101976566033373440550112056048013107504433509296380579560064784435057860194430870305075116819026544194962994152475999640516439076428765103082100821952173381923355412349166428797611346838154448534)
#define PI_SQUARED_1_4l   (2.4674011002723396547086227499690377838284248518101976566033373440550112056048013107504433509296380579560064784435057860194430870305075116819026544194962994152475999640516439076428765103082100821952173381923355412349166428797611346838154448534L)
#define PI_SQUARED_1_4f   (2.4674011002723396547086227499690377838284248518101976566033373440550112056048013107504433509296380579560064784435057860194430870305075116819026544194962994152475999640516439076428765103082100821952173381923355412349166428797611346838154448534F)
#ifndef SQRT_2
#   define SQRT_2   (1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605714701095599716059702745345968)
#endif
#define SQRT_2l   (1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605714701095599716059702745345968L)
#define SQRT_2f   (1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605714701095599716059702745345968F)
#ifndef SQRT_3
#   define SQRT_3   (1.73205080756887729352744634150587236694280525381038062805580697945193301690880003708114618675724857567562614141540670302)
#endif
#define SQRT_3l   (1.73205080756887729352744634150587236694280525381038062805580697945193301690880003708114618675724857567562614141540670302L)
#define SQRT_3f   (1.73205080756887729352744634150587236694280525381038062805580697945193301690880003708114618675724857567562614141540670302F)
#define SQRT_3_DIV_4   (0.43301270189221932338186158537646809173570131345259515701395174486298325422720000927028654668931214391890653535385167575)
#define SQRT_3_DIV_4l   (0.43301270189221932338186158537646809173570131345259515701395174486298325422720000927028654668931214391890653535385167575L)
#define SQRT_3_DIV_4f   (0.43301270189221932338186158537646809173570131345259515701395174486298325422720000927028654668931214391890653535385167575F)
#define SQRT_5   (2.23606797749978969640917366873127623544061835961153)
#define SQRT_6   (2.4494897427831780981972840747058913919659474806566701284326925672509603774573150265398594331046402348185946012266)
#define SQRT_7   (2.64575131106459059050161575363926042571025918308245)
#define SQRT_8   (2.8284271247461900976033774484193961571393437507538961463533594759814649569242140777007750686552831454700276924618)
#define SQRT_10   (3.1622776601683793319988935444327185337195551393252168268575048527925944386392382213442481083793002951873472841528)
#define SQRT_11   (3.31662479035539984911493273667068668392708854558935)
#define SQRT_12   (3.4641016151377545870548926830117447338856105076207612561116139589038660338176000741622923735144971513512522828308)
#define SQRT_13   (3.60555127546398929311922126747049594625129657384525)
#define SQRT_14   (3.7416573867739413855837487323165493017560198077787269463037454673200351563069390279768098951943795715009910887277)
#define SQRT_15   (3.8729833462074168851792653997823996108329217052915908265875737661134830919369790335192873768586735179163022068609)
#define SQRT_16   (4.000)
#define SQRT_17   (4.12310562561766054982140985597407702514719922537362)
#define SQRT_19   (4.35889894354067355223698198385961565913700392523244)
#define SQRT_20   (4.4721359549995793928183473374625524708812367192230514485417944908210418512756097988288288167575645499390163523015)
#define SQRT_21   (4.5825756949558400065880471937280084889844565767679719026072421239068684255477708866043615594934450326776009053975857408733118991707556019635738633623447553702817228244277981919405969049143449200907589407063891768364965598654748)
#define SQRT_22   (4.6904157598234295545656301135444662805882283534117371536057018910170246327532397214821155960615431353545958966615)
#define SQRT_23   (4.7958315233127195415974380641626939199967070419041293464853091144482572359074640824921914464369188606174745632457)
#define SQRT_24   (4.8989794855663561963945681494117827839318949613133402568653851345019207549146300530797188662092804696371892024532)
#define SQRT_E   (1.6487212707001281468486507878141635716537761007101480115750793116406610211942156086327765200563666430028666377563077970046711669752196091598409714524900597969294226590984039147199484646594892448968689053364184657208410666568598)
#define SQRT_El   (1.6487212707001281468486507878141635716537761007101480115750793116406610211942156086327765200563666430028666377563077970046711669752196091598409714524900597969294226590984039147199484646594892448968689053364184657208410666568598L)
#define SQRT_Ef   (1.6487212707001281468486507878141635716537761007101480115750793116406610211942156086327765200563666430028666377563077970046711669752196091598409714524900597969294226590984039147199484646594892448968689053364184657208410666568598F)
#define SQRT_PI   (1.7724538509055160272981674833411451827975494561223871282138077898529112845910321813749506567385446654162268236242825706662361528657244226025250937096027870684620376986531051228499251730289508262289320953792679628001746390153514797205167001901852340185854469744949126403139217755259062164054193325009063984076137334774751534336679897893658518364087954511651617387600590673934317913328098548462481849020546548521956132515616474675150427387610561079961271072)
#define SQRT_PIl   (1.7724538509055160272981674833411451827975494561223871282138077898529112845910321813749506567385446654162268236242825706662361528657244226025250937096027870684620376986531051228499251730289508262289320953792679628001746390153514797205167001901852340185854469744949126403139217755259062164054193325009063984076137334774751534336679897893658518364087954511651617387600590673934317913328098548462481849020546548521956132515616474675150427387610561079961271072L)
#define SQRT_PIf   (1.7724538509055160272981674833411451827975494561223871282138077898529112845910321813749506567385446654162268236242825706662361528657244226025250937096027870684620376986531051228499251730289508262289320953792679628001746390153514797205167001901852340185854469744949126403139217755259062164054193325009063984076137334774751534336679897893658518364087954511651617387600590673934317913328098548462481849020546548521956132515616474675150427387610561079961271072F)
#define TAN_E   (-0.45054953406980749571063417770127929443957091173203671001233561163230090199510257284268170870246704398432546310)
#define TAN_El   (-0.45054953406980749571063417770127929443957091173203671001233561163230090199510257284268170870246704398432546310L)
#define TAN_Ef   (-0.45054953406980749571063417770127929443957091173203671001233561163230090199510257284268170870246704398432546310F)
#define TAN_PI   (0.0)
#define TAN_PIl   (0.0L)
#define TAN_PIf   (0.0F)


#define ARTIN_CONSTANT   (0.37395581361920228805472805434641641)
#define ATOMIC_UNIT_OF_CHARGE   (1.602176565E-19)
#define ATOMIC_UNIT_OF_CURRENT   (0.00662361795)
#define ATOMIC_UNIT_OF_FORCE   (8.23872278E-8)
#define AVOGADRO_CONSTANT   (6.02214179E23)
#define BERNSTEINS_CONSTANT   (5.2917721092E-11)
#define BOHR_RADIUS   (0.28016949902386913303643649123067200)
#define BOLTZMANN_CONSTANT   (1.3806488E-23)
#define CHAMPERNOWNE_CONSTANT   (0.12345678910111213141516171819202122232425262728293031323334353637383940414243)
#define CHAMPERNOWNE_CONSTANTl   (0.12345678910111213141516171819202122232425262728293031323334353637383940414243L)
#define CHEBYSHEV_CONSTANT   (0.59017029950804811302266897027924429)
#define COMPTON_WAVELENGTH   (2.4263102389E-12)
#define DEG2RAD   (0.017453292519943295769236907684886)
#define DELIAN_CONSTANT   (1.25992104989487316476721060727822835)
#define DEUTERON_G_FACTOR   (0.8574382308)
#define DEUTERON_MASS   (3.34358348E-27)
#define DEUTERON_MOLAR_MASS   (0.00201355321271)
#define DOUBLE_FACTORIAL_CONSTANT   (3.05940740534257614453947549923327861)
#ifndef E
#define E   (2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447)
#endif
#define El   (2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447L)
#define Ef   (2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447F)
#define ELECTRON_G_FACTOR   (-2.00231930436)
#define ELECTRON_MASS   (0.000000000000000000000000000000910938291)
#define ELECTRON_VOLT   (0.0000000000000000001602176565)
#define ELECTRON_MUON_MASS_RATIO   (0.00483633166)
#define ELECTRON_NEUTRON_MAGNETIC_MOMENT_RATIO   (960.9205)
#define ERFC_CONTFRAC_CUTOFF   (30.0)
#define ERFC_CONTFRAC_TERMS   (50.0)
#define ERF_SERIES_CUTOFF   (1.5)
#define ERF_SERIES_TERMS   (25.0)
#define EULERS_CONSTANT   (0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495)
#define EULERS_CONSTANTl   (0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495L)
#define EXPONENTIAL_FACTORIAL_CONSTANT   (1.61111492580837673611111111111111111)
#define GOLDEN_ANGLE   (2.39996322972865332223155550663361385)
#define GOLDEN_RATIO   (1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374)
#define GOLDEN_RATIOl   (1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374L)
#define HYPERBOLIC_TANGENT_OF_1   (0.7615941559557648881194582826047935904127685972579365515968105001219532445766384834589475216736767144219027597015540775323683091147624854132970066696113211253965101376080877764393409926042066795531174758011305900662577831975245123799759179611)
#define HYPERBOLIC_TANGENT_OF_1l   (0.7615941559557648881194582826047935904127685972579365515968105001219532445766384834589475216736767144219027597015540775323683091147624854132970066696113211253965101376080877764393409926042066795531174758011305900662577831975245123799759179611L)
#define INVERSE_E   (0.3678794411714423215955237701614608674458111310317678345078368016974614957448998033571472743459196437466273252768439952082469757927901290086266535894940987830921943673773381150486389911251456163449877199786844759579397473025498924954532393662)
#define INVERSE_El   (0.3678794411714423215955237701614608674458111310317678345078368016974614957448998033571472743459196437466273252768439952082469757927901290086266535894940987830921943673773381150486389911251456163449877199786844759579397473025498924954532393662L)
#define INVERSE_PI   (0.3183098861837906715377675267450287240689192914809128974953346881177935952684530701802276055325061719121456854535159160737858236922291573057559348214633996784584799338748181551461554927938506153774347857924347953233867247804834472580236647602)
#define INVERSE_PIl   (0.3183098861837906715377675267450287240689192914809128974953346881177935952684530701802276055325061719121456854535159160737858236922291573057559348214633996784584799338748181551461554927938506153774347857924347953233867247804834472580236647602L)
#define I_SQUARED   (-1)
#define LANCZOS_G   (6.024680040776729583740234375)
#define LANCZOS_G_MINUS_HALF   (5.524680040776729583740234375)
#define LN_E   (1.0)
#define LN2   (0.693147180559945286227)
#define LN2f   (0.693147180559945286227F)
#define LN2l   (0.693147180559945286227L)
#define MURATA_CONSTANT   (2.82641999706759157554639174723695374)
#define NEG_ZERO   (-0.0)
#define OMEGA   (0.56714329040978387299996866221035555)
#define PARIS_CONSTANT   (1.09864196439415648573466891734359621)
#define RAD2DEG   (57.295779513082320876798154814105)
#define RIGHT_ANGLE_DEG   (90.0)
#define RIGHT_ANGLE_DEG_INT   (90)
#define RIGHT_ANGLE_RAD   (1.5707963267949)
#define SALEM_NUMBER   (1.17628081825991750654407033847403505)
#define TWIN_PRIMES_CONSTANT   (0.66016181584686957392781211001455577)
#define VARDI_CONSTANT   (1.26408473530530111307959958416466949)


/** Not-A-Number */
#define FP_NAN   (0)
/** Positive or negative infinity (overflow) */
#define FP_INFINITE   (1)
/** Value of zero */
#define FP_ZERO   (2)
/** Sub-normal value (underflow) */
#define FP_SUBNORMAL   (3)
/** Normal value (not an underflow, overflow, zero, INF, or NAN) */
#define FP_NORMAL   (4)


/** Bitmask for the math_errhandling macro; errno set by math function */
#define MATH_ERRNO   (1)
/** Bitmask for the math_errhandling macro; Exception raised by math function */
#define MATH_ERREXCEPT   (2)
#if FAST_MATH  // All functions support both errno and exception handling except in fast-math mode and inline-functions
#   define math_errhandling   (MATH_ERRNO | MATH_ERREXCEPT)
#endif

/** Support for various different standard error handling behaviors */
typedef enum _LIB_VERSION_TYPE {
	_IEEE_ = -1,  // IEEE754/IEEE854
	_SVID_,  // System V release 4
	_XOPEN_,  // Unix98
	_POSIX_,
	_ISOC_  // ISO C99
} _LIB_VERSION_TYPE;

/** This variable can be changed at run-time to any of the values above to affect floating point error handling behavior (it may also be necessary to change the hardware FPU exception settings) */
extern UNUSED _LIB_VERSION_TYPE _LIB_VERSION;
_LIB_VERSION_TYPE _LIB_VERSION = _POSIX_;


// Types of exceptions in the `type` field in `__exception`
#define DOMAIN   (1)
#define SING   (2)
#define OVERFLOW   (3)
#define UNDERFLOW   (4)
#define TLOSS   (5)
#define PLOSS   (6)


// QUATERNION CONSTANTS
#ifndef QUATERNION_CONSTANTS_SEEN
#   define QUATERNION_CONSTANTS_SEEN   (1)
#   define QUATERNION_ZERO   ({ 0.0, 0.0, 0.0, 0.0 })  // quaternion
#   define QUATERNION_ONE   ({ 1.0, 0.0, 0.0, 0.0 })
#   define QUATERNION_E   ({ 2.7182818284590452354, 0.0, 0.0, 0.0 })
#   define QUATERNION_PI   ({ 3.14159265358979323846, 0.0, 0.0, 0.0 })
#   define QUATERNION_PI2   ({ 1.57079632679489661923, 0.0, 0.0, 0.0 })
#   define QUATERNION_PI4   ({ 0.78539816339744830962, 0.0, 0.0, 0.0 })
#   define QUATERNION_INV_PI   ({ 0.31830988618379067154, 0.0, 0.0, 0.0 })
#   define QUATERNION_IDENT   ({ 1.0, 0.0, 0.0, 0.0 })
#   define QUATERNION_ZEROf   ({ 0.0F, 0.0F, 0.0F, 0.0F })  // quaternion_float
#   define QUATERNION_ONEf   ({ 1.0, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_Ef   ({ 2.7182818284590452354F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_PIf   ({ 3.14159265358979323846F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_PI2f   ({ 1.57079632679489661923F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_PI4f   ({ 0.78539816339744830962F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_INV_PIf   ({ 0.31830988618379067154F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_IDENTf   ({ 1.0F, 0.0F, 0.0F, 0.0F })
#   define QUATERNION_ZEROl   ({ 0.0L, 0.0L, 0.0L, 0.0L })  // quaternion_long_double
#   define QUATERNION_ONEl   ({ 1.0, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_El   ({ 2.7182818284590452354L, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_PIl   ({ 3.14159265358979323846L, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_PI2l   ({ 1.57079632679489661923L, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_PI4l   ({ 0.78539816339744830962L, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_INV_PIl   ({ 0.31830988618379067154L, 0.0L, 0.0L, 0.0L })
#   define QUATERNION_IDENTl   ({ 1.0L, 0.0L, 0.0L, 0.0L })
#endif


#endif  // MATH_H_MATHDEF


/* CHECKED SIZE_T COMPUTATIONS (<xsize.h>) */


#if (!(defined(_XSIZE_H) || defined(_XSIZE_H_)))
#define _XSIZE_H   (1)
#define _XSIZE_H_   (1)


/** Convert an arbitrary value >= 0 to type size_t */
#define xcast_size_t(_num)   ((_num) <= SIZE_MAX ? (size_t)(_num) : (size_t)SIZE_MAX)
/** Multiplication of a count with an element size, with overflow check; The count must be >= 0 and the element size must be > 0 */
#define xtimes(_num, _elem_size)   ((size_t)((_num) <= (SIZE_MAX / (_elem_size)) ? (size_t)(_num) * (_elem_size) : SIZE_MAX))
/** Maximum of two sizes, with overflow check */
#define xmax(size1, size2)   ((size_t)(((size_t)(size1) >= (size_t)(size2)) ? (size_t)(size1) : (size_t)(size2)))
/** Check for overflow */
#define size_overflow_p(size__)   ((size__) == SIZE_MAX)
/** Check for overflow */
#define size_overflow(size__)   size_overflow_p((size__))
/** Check against overflow */
#define size_in_bounds_p(size__)   ((size__) != SIZE_MAX)
/** Check against overflow */
#define size_in_bounds(size__)   size_in_bounds_p((size__))


/** Sum of two sizes, with overflow check */
LIB_FUNC size_t xsum(const size_t size1, const size_t size2) {
	register size_t sum = (size1 + size2);
	return (size_t)(sum >= size1 ? sum : SIZE_MAX);
}


/** Sum of three sizes, with overflow check */
LIB_FUNC size_t xsum3(const size_t size1, const size_t size2, const size_t size3) {
	return (size_t)xsum(xsum(size1, size2), size3);
}


/** Sum of four sizes, with overflow check */
LIB_FUNC size_t xsum4(const size_t size1, const size_t size2, const size_t size3, const size_t size4) {
	return (size_t)xsum(xsum(xsum(size1, size2), size3), size4);
}


#endif  // XSIZE_H


/* BIT-TWIDDLING, BYTESWAP, BITROTATE, & STRING MANIPULATIONS */


#if (!(defined(_BITS_BYTESWAP_H) || defined(BITS_BYTESWAP_H) || defined(_BITSTRING_H_) || defined(_SYS_BITSTRING_H_) || defined(_BITSTRING_H) || defined(_SYS_BITSTRING_H)))  // http://www.cplusplus.com/reference/cstring/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/string.h.html & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/strings.h.html
#define _STRING_H   (1)  // <string.h>
#define _STRING_H_   (1)
#define _STRINGS_H   (1)  // <strings.h>
#define _STRINGS_H_   (1)
#define _DIET_STRING_H_   (1)
#define _BITSTRING_H   (1)  // <bitstring.h>
#define _BITSTRING_H_   (1)
#define _SYS_BITSTRING_H   (1)  // <sys/bitstring.h>
#define _SYS_BITSTRING_H_   (1)
#define _BITROTATE_H   (1)  // <bitrotate.h>
#define _BITROTATE_H_   (1)
#define _GL_BITROTATE_H   (1)
#define _BITS_BYTESWAP_H   (1)  // <bits/byteswap.h>
#define _BITS_BYTESWAP_H_   (1)
#define BITS_BYTESWAP_H   (1)
#define BITS_BYTESWAP_H_   (1)
#define _OS_OSBYTEORDER_H   (1)
#define _OS_OSBYTEORDERI386_H   (1)
#define _OS__OSBYTEORDER_H   (1)
#define _OS__OSBYTEORDERI386_H   (1)
#define _OS_OSBYTEORDERMACHINE_H   (1)
#define _FSSH_BYTEORDER_H   (1)
#define BFS_ENDIAN_H   (1)
#define COMMON_UTIL_MEMCPY_H   (1)
#define _COMMON_UTIL_MEMCPY_H   (1)
#define _SYS_BITOPS_H_   (1)
#define _SYS_BITOPS_H   (1)
#define _BITOPS_H_   (1)
#define _BITOPS_H   (1)
#define __ASM_GENERIC_BITOPS_H   (1)
#define __ASM_GENERIC_BITOPS_H_   (1)
#define _ASM_GENERIC_BITOPS_H   (1)
#define _ASM_GENERIC_BITOPS_H_   (1)
#define _ASM_GENERIC_BITOPS_FFS_H_   (1)
#define _ASM_GENERIC_BITOPS___FFS_H_   (1)
#define _ASM_GENERIC_BITOPS_FFZ_H_   (1)
#define _ASM_GENERIC_BITOPS___FFZ_H_   (1)
#define _ASM_GENERIC_BITOPS_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN___FLS_H_   (1)
#define _ASM_GENERIC_BITOPS___FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_FLS_H_   (1)
#define _ASM_GENERIC_BITOPS_BUILTIN_FFS_H_   (1)
#define _ASM_GENERIC_BITOPS_COUNT_ZEROS_H_   (1)
#define _ASM_GENERIC_BITOPS_LE_H_   (1)


#ifndef Storeinc
#   define Storeinc(a, b, c)   (*a++ = ((b) << 16) | ((c) & 0xffff))
#endif
#define Sign_Extend(a, b)   if ((b) < 0) { a |= 0xffff0000; }
#define MEMCCPY_ALIGN   (SIZEOF_SIZE_T - 1)
#define MEMCCPY_ONES   ((size_t)(-1) / UCHAR_MAX)
#define HASZERO(x)   ((((x) - MEMCCPY_ONES) & (~(x))) & (MEMCCPY_ONES * ((UCHAR_MAX / 2) + 1)))
#define HASNTZERO(x)   (!((((x) - MEMCCPY_ONES) & (~(x))) & (MEMCCPY_ONES * ((UCHAR_MAX / 2) + 1))))
#define HASNOTZERO(x)   HASNTZERO((x))
#define HASNOZERO(x)   HASNTZERO((x))
#define BITOP(a, b, op)   ((a)[(size_t)(b) / (8 * sizeof(*(a)))] op (size_t)1 << ((size_t)(b) % (8 * sizeof(*(a)))))
/** Byte of the bitstring containing the bit */
#define _bit_byte(bit)   ((bit) >> 3)
/** Byte of the bitstring containing the bit */
#define bit_byte(bit)   _bit_byte((bit))
/** Mask for the bit within its byte */
#define _bit_mask(bit)   (1 << ((bit) & 7))
/** Mask for the bit within its byte */
#define bit_mask(bit)   _bit_mask((bit))
/** Bytes in a bitstring of nbits bits */
#define bitstr_size(nbits)   (((nbits) + 7) >> 3)
/** Allocate a bitstring */
#define bit_alloc(nbits)   (bitstr_t*)calloc((size_t)bitstr_size(nbits), SIZEOF_CHAR)
/** Allocate a bitstring on the stack */
#define bit_decl(name, nbits)   ((name)[bitstr_size(nbits)])
/** Is bit N of bitstring name set? */
#define bit_test(name, bit)   ((name)[_bit_byte(bit)] & (_bit_mask(bit)))
/** Set bit N of bitstring name */
#define bit_set(name, bit)   ((name)[_bit_byte(bit)] |= (_bit_mask(bit)))
/** Clear bit N of bitstring name */
#define bit_clear(name, bit)   ((name)[_bit_byte(bit)] &= (~_bit_mask(bit)))
/** Clear bits start ... stop in bitstring */
#define bit_nclear(name, start, stop)   do { bitstr_t* _name = name; register int _start = start, _stop = stop; while (_start <= _stop) { bit_clear(_name, _start); ++_start; } } while (0x0)
/** Set bits start ... stop in bitstring */
#define bit_nset(name, start, stop)   do { bitstr_t* _name = name; register int _start = start, _stop = stop; while (_start <= _stop) { bit_set(_name, _start); ++_start; } } while (0x0)
/** Find first bit clear in name */
#define bit_ffc(name, nbits, value)   do { bitstr_t* _name = name; register int _bit, _nbits = nbits, _value = -1; for (_bit = 0; _bit < _nbits; ++_bit) { if (!bit_test(_name, _bit)) { _value = _bit; break; } } *(value) = _value; } while (0x0)
/** Find first bit set in name */
#define bit_ffs(name, nbits, value)   do { bitstr_t* _name = name; register int _bit, _nbits = nbits, _value = -1; for (_bit = 0; _bit < _nbits; ++_bit) { if (bit_test(_name, _bit)) { _value = _bit; break; } } *(value) = _value; } while (0x0)


// BIT/BYTE SWAPPING

/** Swap the endianness of a byte */
#define byteswap8(x)   ((uint8_t)((x) << (uint8_t)4) | (uint8_t)((x) >> (uint8_t)4))
/** Swap the endianness of a byte */
#define __bswap_8(x)   byteswap8((uint8_t)(x))
/** Swap the endianness of a byte */
#define bswap_8(x)   byteswap8((uint8_t)(x))
/** Swap the endianness of a byte */
#define __swap8gen(x)   byteswap8((x))
/** Swap the endianness of a byte */
#define __swap8(x)   byteswap8((x))
/** Swap the order of all of the bytes in a 8-bit unit */
#define __bswap_constant_8(x)   byteswap8((x))
/** Swap the order of all of the bytes in a 8-bit unit */
#define __bswap_non_constant_8(x)   byteswap8((x))
#define __swab8(x)   byteswap8((x))
#define _OSSwapInt8(x)   byteswap8((x))

/** Swap the order of all of the bytes in a 16-bit unit */
LIB_FUNC uint16_t bswap16(const uint16_t __bsx) {
#ifdef ITANIUM
	uint16_t y, x = (uint16_t)__bsx;
	asm ("shl %0 = %1, 48;" "mux1 %0 = %0, @rev;" : "=r"(y) : "r"(x));
	return y;
#elif (defined(X86_64) || defined(X86) || defined(I386))
	uint16_t y, x = (uint16_t)__bsx;
	asm ("rorw $8, %w0;" : "=r"(y) : "0"(x) : "cc");
	return y;
#elif (defined(S390) && IS_WORDSIZE_64)
	uint16_t y, x = (uint16_t)__bsx;
	asm ("lrvh %0, %1;" : "=&d"(y) : "m"(x));
	return y;
#elif (defined(S390) && IS_WORDSIZE_32)
	uint16_t y, x = (uint16_t)__bsx;
	asm ("sr %0, %0;" "la 1, %1;" "icm %0, 2, 1(1);" "ic %0, 0(1);" : "=&d"(y) : "m"(x) : "1");
	return y;
#else
	return (uint16_t)((uint16_t)((__bsx >> 8) & 0xFFu) | (uint16_t)((__bsx & 0xFFu) << 8));
#endif
}
/** Swap the order of all of the bytes in a 16-bit unit */
#define byteswap16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define bswap_16(x)   ((uint16_t)((((x) >> 8) & 0xFFu) | (((x) & 0xFFu) << 8)))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap16gen(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_constant_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __bswap_non_constant_16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define B_SWAP_INT16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __swap_int16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define swap_int16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define __fssh_swap_int16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit */
#define FSSH_B_SWAP_INT16(x)   bswap16((x))
/** Swap the order of all of the bytes in a 16-bit unit (NetBSD) */
#define __nbcompat_bswap16(x)   ((((x) << 8) & 0xFF00) | (((x) >> 8) & 0xFF))
/** Swap the order of all of the bytes in a 16-bit unit (NetBSD) */
#define nbcompat_bswap16(x)   __nbcompat_bswap16((x))
#define __swab16(x)   bswap16((x))
#define _OSSwapInt16(x)   bswap16((x))
#define OSSwapInt16(x)   bswap16((x))
#define __DARWIN_OSSwapConstInt16(x)   ((uint16_t)((((uint16_t)(x) & 0xff00) >> 8) | (((uint16_t)(x) & 0xff) << 8)))
#define __DARWIN_OSSwapInt16(x)   __DARWIN_OSSwapConstInt16((x))
#define __swap16_multi(v, n)   do { register size_t __swap16_multi_n = (n); uint16_t* __swap16_multi_v = (v); while (__swap16_multi_n) { *__swap16_multi_v = swap16(*__swap16_multi_v); ++__swap16_multi_v; --__swap16_multi_n; } } while (0x0)
#define swap16_multi(v, n)   __swap16_multi((v), (n))

/** Swap the order of all of the bytes in a 32-bit unit */
LIB_FUNC uint32_t bswap32(const uint32_t __bsx) {
#   if (defined(I386) || defined(X86) || defined(X86_64))
	uint32_t x = __bsx;
	asm volatile ("bswap %0;" : "+r"(((uint32_t)(x))));
	return x;
#   else
	return ((uint32_t)(((__bsx) & 0xFF000000U) >> 0x18U) | (((__bsx) & 0xFF0000U) >> 8U) | (((__bsx) & 0xFF00U) << 8U) | (((__bsx) & 0xFFU) << 0x18U));
#   endif
}
/** Swap the order of all of the bytes in a 32-bit unit */
#define byteswap32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define bswap_32(x)   ((uint32_t)(((x) & 0xFF000000U) >> 0x18U) | (((x) & 0xFF0000U) >> 8U) | (((x) & 0xFF00U) << 8U) | (((x) & 0xFFU) << 0x18U))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap32gen(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_constant_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __bswap_non_constant_32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define B_SWAP_INT32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __swap_int32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define swap_int32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define __fssh_swap_int32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit */
#define FSSH_B_SWAP_INT32(x)   bswap32((x))
/** Swap the order of all of the bytes in a 32-bit unit (NetBSD) */
#define __nbcompat_bswap32(x)   ((((x) << 0x18) & 0xFF000000) | (((x) << 0x8) & 0xFF0000) | (((x) >> 0x8) & 0xFF00) | (((x) >> 0x18) & 0xFF))
/** Swap the order of all of the bytes in a 32-bit unit (NetBSD) */
#define nbcompat_bswap32(x)   __nbcompat_bswap32((x))
#define __swab32(x)   bswap32((x))
#define _OSSwapInt32(x)   bswap32(((uint32_t)(x)))
#define OSSwapInt32(x)   _OSSwapInt32((x))
#define __DARWIN_OSSwapConstInt32(x)   ((uint32_t)((((uint32_t)(x) & 0xff000000) >> 24) | (((uint32_t)(x) & 0xff0000) >> 8) | (((uint32_t)(x) & 0xff00) << 8) | (((uint32_t)(x) & 0xff) << 24)))
#define __DARWIN_OSSwapInt32(x)   __DARWIN_OSSwapConstInt32((x))

/** Swap the order of all of the bytes in a 64-bit unit */
LIB_FUNC uint64_t bswap64(const uint64_t __bsx) {
#   ifdef X86_64
	uint64_t x = __bsx;
	asm ("bswap %0;" : "+r"(x));
	return x;
#   elif (defined(I386) || defined(X86))
	uint64_t x = __bsx;
	asm ("bswap %%eax;" "bswap %%edx;" "xchgl %%eax, %%edx;" : "+A"(x));
	return x;
#   else
	return ((uint64_t)((((__bsx) & 0xff00000000000000ULL) >> 0x38) | (((__bsx) & 0xff000000000000ULL) >> 0x28) | (((__bsx) & 0xff0000000000ULL) >> 0x18) | (((__bsx) & 0xff00000000ULL) >> 8) | (((__bsx) & 0xff000000ULL) << 8) | (((__bsx) & 0xff0000ULL) << 0x18) | (((__bsx) & 0xff00ULL) << 0x28) | (((__bsx) & 0xffULL) << 0x38)));
#   endif
}
/** Swap the order of all of the bytes in a 64-bit unit */
#define byteswap64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define bswap_64(x)   ((uint64_t)((((x) & 0xff00000000000000ULL) >> 0x38) | (((x) & 0xff000000000000ULL) >> 0x28) | (((x) & 0xff0000000000ULL) >> 0x18) | (((x) & 0xff00000000ULL) >> 8) | (((x) & 0xff000000ULL) << 8) | (((x) & 0xff0000ULL) << 0x18) | (((x) & 0xff00ULL) << 0x28) | (((x) & 0xffULL) << 0x38)))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap64gen(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_constant_64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define B_SWAP_INT64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __swap_int64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define swap_int64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define FSSH_B_SWAP_INT64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __fssh_swap_int64(x)   bswap64((x))
/** Swap the order of all of the bytes in a 64-bit unit */
#define __bswap_non_constant_64(x)   do { union { unsigned long long __ll; unsigned int __l[2]; } __w, __r; __w.__ll = (x); __r.__l[0] = bswap32(__w.__l[1]); __r.__l[1] = bswap32(__w.__l[0]); __r.__ll; } while (0x0)
/** Swap the order of all of the bytes in a 64-bit unit (NetBSD) */
#define __nbcompat_bswap64(x)   (((uint64_t)bswap32((x)) << 0x20) | ((uint64_t)bswap32((x) >> 0x20)))
/** Swap the order of all of the bytes in a 64-bit unit (NetBSD) */
#define nbcompat_bswap64(x)   __nbcompat_bswap64((x))
#define __swab64(x)   bswap64((x))
#define _OSSwapInt64(x)   bswap64(((uint64_t)x))
#define OSSwapInt64(x)   _OSSwapInt64((x))
#define __DARWIN_OSSwapConstInt64(x)   ((uint64_t)((((uint64_t)(x) & 0xff00000000000000ULL) >> 56) | (((uint64_t)(x) & 0xff000000000000ULL) >> 40) | (((uint64_t)(x) & 0xff0000000000ULL) >> 24) | (((uint64_t)(x) & 0xff00000000ULL) >> 8) | (((uint64_t)(x) & 0xff000000ULL) << 8) | (((uint64_t)(x) & 0xff0000ULL) << 24) | (((uint64_t)(x) & 0xff00ULL) << 40) | (((uint64_t)(x) & 0xffULL) << 56)))
#define __DARWIN_OSSwapInt64(x)   __DARWIN_OSSwapConstInt64((x))


LIB_FUNC uint32_t byteswap_uint32_t(const uint32_t data_word, const char should_swap) {
	if (!should_swap) { return data_word; }
	union word_union {
		uint32_t full_word;
		unsigned char bytes[4];
	} old, neww;
	old.full_word = data_word;
	neww.bytes[0] = old.bytes[3];
	neww.bytes[1] = old.bytes[2];
	neww.bytes[2] = old.bytes[1];
	neww.bytes[3] = old.bytes[0];
	return neww.full_word;
}


LIB_FUNC float swap_float(const float x) {
	const uint32_t temp1 = (uint32_t)x;
	const uint32_t temp2 = (uint32_t)((temp1 >> 24) | ((temp1 >> 8) & 0xff00) | ((temp1 << 8) & 0xff0000) | (temp1 << 24));
	return (float)temp2;
}
#define swap_float_(x)   swap_float((x))
#define __swap_float(x)   swap_float((x))
#define _swap_float_(x)   swap_float((x))
#define _swap_float(x)   swap_float((x))
#define __fssh_swap_float(x)    swap_float((x))
#define FSSH_B_SWAP_FLOAT(x)    swap_float((x))
#define B_SWAP_FLOAT(x)    swap_float((x))


LIB_FUNC float byteswap_float(const float data_word, const char should_swap) {
	if (!should_swap) { return data_word; }
	union word_union {
		float full_word;
		unsigned char bytes[4];
	} old, neww;
	old.full_word = data_word;
	neww.bytes[0] = old.bytes[3];
	neww.bytes[1] = old.bytes[2];
	neww.bytes[2] = old.bytes[1];
	neww.bytes[3] = old.bytes[0];
	return neww.full_word;
}


LIB_FUNC double swap_double(const double x) {
	const uint64_t num = DBL_TO_U64(x);
	const double ret = U64_TO_DBL(bswap64(num));
	return ret;
}
#define swap_double_(x)   swap_double((x))
#define __swap_double(x)   swap_double((x))
#define _swap_double_(x)   swap_double((x))
#define _swap_double(x)   swap_double((x))
#define __fssh_swap_double(x)    swap_double((x))
#define FSSH_B_SWAP_DOUBLE(x)    swap_double((x))
#define B_SWAP_DOUBLE(x)    swap_double((x))


LIB_FUNC void swap_copy(short* dest, const short* restrict src, int c) {
	register unsigned short sh;
	while (c > 1) {
		sh = (unsigned short)*(src++);
		*(dest++) = (short)((sh << 8) | (sh >> 8));
		c -= 2;
	}
}


#if IS_LITTLE_ENDIAN  // Conversion interfaces
#   define htobe16(x)   bswap16((x))
#   define htole16(x)   (x)
#   define be16toh(x)   bswap16((x))
#   define le16toh(x)   (x)
#   define htobe32(x)   bswap32((x))
#   define htole32(x)   (x)
#   define be32toh(x)   bswap32((x))
#   define le32toh(x)   (x)
#   define htobe64(x)   bswap64((x))
#   define htole64(x)   (x)
#   define be64toh(x)   bswap64((x))
#   define le64toh(x)   (x)
#   define htons(x)   bswap16((x))
#   define ntohl(x)   bswap32((x))
#   define htonl(x)   bswap32((x))
#   define ntohll(x)   bswap64((x))
#   define htonll(x)   bswap64((x))
#   define NTOHL(x)   bswap32((x))
#   define NTOHS(x)   bswap16((x))
#   define NTOHLL(x)   bswap64((x))
#   define HTONL(x)   bswap32((x))
#   define HTONS(x)   bswap16((x))
#   define HTONLL(x)   bswap64((x))
#   define EndianS16_LtoN(x)   (x)
#   define EndianS16_NtoL(x)   (x)
#   define EndianU16_LtoN(x)   (x)
#   define EndianU16_NtoL(x)   (x)
#   define EndianS32_LtoN(x)   (x)
#   define EndianS32_NtoL(x)   (x)
#   define EndianU32_LtoN(x)   (x)
#   define EndianU32_NtoL(x)   (x)
#   define EndianS64_LtoN(x)   (x)
#   define EndianS64_NtoL(x)   (x)
#   define EndianU64_LtoN(x)   (x)
#   define EndianU64_NtoL(x)   (x)
#   define ntohq(x)   bswap64((x))
#   define htonq(x)   bswap64((x))
#   define B_HOST_TO_LENDIAN_DOUBLE(arg)   (double)(arg)
#   define B_HOST_TO_LENDIAN_FLOAT(arg)   (float)(arg)
#   define B_HOST_TO_LENDIAN_INT64(arg)   (uint64_t)(arg)
#   define B_HOST_TO_LENDIAN_INT32(arg)   (uint32_t)(arg)
#   define B_HOST_TO_LENDIAN_INT16(arg)   (uint16_t)(arg)
#   define B_LENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define B_LENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define B_LENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define B_LENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define B_LENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define B_HOST_TO_BENDIAN_DOUBLE(arg)   swap_double(arg)
#   define B_HOST_TO_BENDIAN_FLOAT(arg)   swap_float(arg)
#   define B_HOST_TO_BENDIAN_INT64(arg)   bswap64(arg)
#   define B_HOST_TO_BENDIAN_INT32(arg)   bswap32(arg)
#   define B_HOST_TO_BENDIAN_INT16(arg)   bswap16(arg)
#   define B_BENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define B_BENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define B_BENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define B_BENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define B_BENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#   define FSSH_B_HOST_TO_LENDIAN_DOUBLE(arg)   (double)(arg)
#   define FSSH_B_HOST_TO_LENDIAN_FLOAT(arg)   (float)(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT64(arg)   (uint64_t)(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT32(arg)   (uint32_t)(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT16(arg)   (uint16_t)(arg)
#   define FSSH_B_LENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define FSSH_B_LENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_DOUBLE(arg)   swap_double(arg)
#   define FSSH_B_HOST_TO_BENDIAN_FLOAT(arg)   swap_float(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT64(arg)   bswap64(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT32(arg)   bswap32(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT16(arg)   bswap16(arg)
#   define FSSH_B_BENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define FSSH_B_BENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#else  // BIG_ENDIAN
#   define htobe16(x)   (x)
#   define htole16(x)   bswap16((x))
#   define be16toh(x)   (x)
#   define le16toh(x)   bswap16((x))
#   define htobe32(x)   (x)
#   define htole32(x)   bswap32((x))
#   define be32toh(x)   (x)
#   define le32toh(x)   bswap32((x))
#   define htobe64(x)   (x)
#   define htole64(x)   bswap64((x))
#   define be64toh(x)   (x)
#   define le64toh(x)   bswap64((x))
#   define ntohl(x)   ((uint32_t)(x))
#   define htonl(x)   ((uint32_t)(x))
#   define htons(x)   ((uint16_t)(x))
#   define ntohll(x)   ((uint64_t)(x))
#   define htonll(x)   ((uint64_t)(x))
#   define NTOHL(x)   (x)
#   define NTOHS(x)   (x)
#   define NTOHLL(x)   (x)
#   define HTONL(x)   (x)
#   define HTONS(x)   (x)
#   define HTONLL(x)   (x)
#   define EndianS16_BtoN(x)   (x)
#   define EndianS16_NtoB(x)   (x)
#   define EndianU16_BtoN(x)   (x)
#   define EndianU16_NtoB(x)   (x)
#   define EndianS32_BtoN(x)   (x)
#   define EndianS32_NtoB(x)   (x)
#   define EndianU32_BtoN(x)   (x)
#   define EndianU32_NtoB(x)   (x)
#   define EndianS64_BtoN(x)   (x)
#   define EndianS64_NtoB(x)   (x)
#   define EndianU64_BtoN(x)   (x)
#   define EndianU64_NtoB(x)   (x)
#   define ntohq(x)   (x)
#   define htonq(x)   (x)
#   define B_HOST_TO_LENDIAN_DOUBLE(arg)   swap_double(arg)
#   define B_HOST_TO_LENDIAN_FLOAT(arg)   swap_float(arg)
#   define B_HOST_TO_LENDIAN_INT64(arg)   bswap64(arg)
#   define B_HOST_TO_LENDIAN_INT32(arg)   bswap32(arg)
#   define B_HOST_TO_LENDIAN_INT16(arg)   bswap16(arg)
#   define B_LENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define B_LENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define B_LENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define B_LENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define B_LENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#   define B_HOST_TO_BENDIAN_DOUBLE(arg)   (double)(arg)
#   define B_HOST_TO_BENDIAN_FLOAT(arg)   (float)(arg)
#   define B_HOST_TO_BENDIAN_INT64(arg)   (uint64_t)(arg)
#   define B_HOST_TO_BENDIAN_INT32(arg)   (uint32_t)(arg)
#   define B_HOST_TO_BENDIAN_INT16(arg)   (uint16_t)(arg)
#   define B_BENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define B_BENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define B_BENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define B_BENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define B_BENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_DOUBLE(arg)   (double)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_FLOAT(arg)   (float)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT64(arg)   (uint64_t)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT32(arg)   (uint32_t)(arg)
#   define FSSH_B_HOST_TO_BENDIAN_INT16(arg)   (uint16_t)(arg)
#   define FSSH_B_BENDIAN_TO_HOST_DOUBLE(arg)   (double)(arg)
#   define FSSH_B_BENDIAN_TO_HOST_FLOAT(arg)   (float)(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT64(arg)   (uint64_t)(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT32(arg)   (uint32_t)(arg)
#   define FSSH_B_BENDIAN_TO_HOST_INT16(arg)   (uint16_t)(arg)
#   define FSSH_B_HOST_TO_LENDIAN_DOUBLE(arg)   swap_double(arg)
#   define FSSH_B_HOST_TO_LENDIAN_FLOAT(arg)   swap_float(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT64(arg)   bswap64(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT32(arg)   bswap32(arg)
#   define FSSH_B_HOST_TO_LENDIAN_INT16(arg)   bswap16(arg)
#   define FSSH_B_LENDIAN_TO_HOST_DOUBLE(arg)   swap_double(arg)
#   define FSSH_B_LENDIAN_TO_HOST_FLOAT(arg)   swap_float(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT64(arg)   bswap64(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT32(arg)   bswap32(arg)
#   define FSSH_B_LENDIAN_TO_HOST_INT16(arg)   bswap16(arg)
#endif  // Conversion interfaces
#ifndef B_HOST_TO_BENDIAN_INT32
#   define B_HOST_TO_BENDIAN_INT32(x)   htonl((x))
#   define B_BENDIAN_TO_HOST_INT32(x)   ntohl((x))
#   define B_HOST_TO_BENDIAN_INT16(x)   htons((x))
#   define B_BENDIAN_TO_HOST_INT16(x)   ntohs((x))
#endif
#ifndef fssh_htonl
#   define fssh_htonl(x)   FSSH_B_HOST_TO_BENDIAN_INT32((x))
#   define fssh_ntohl(x)   FSSH_B_BENDIAN_TO_HOST_INT32((x))
#   define fssh_htons(x)   FSSH_B_HOST_TO_BENDIAN_INT16((x))
#   define fssh_ntohs(x)   FSSH_B_BENDIAN_TO_HOST_INT16((x))
#endif
#if ((defined(BFS_LITTLE_ENDIAN_ONLY) && B_HOST_IS_LENDIAN) || (defined(BFS_BIG_ENDIAN_ONLY) && B_HOST_IS_BENDIAN))
#   define BFS_NATIVE_ENDIAN
#   define BFS_ENDIAN_TO_HOST_INT16(value)   value
#   define BFS_ENDIAN_TO_HOST_INT32(value)   value
#   define BFS_ENDIAN_TO_HOST_INT64(value)   value
#   define HOST_ENDIAN_TO_BFS_INT16(value)   value
#   define HOST_ENDIAN_TO_BFS_INT32(value)   value
#   define HOST_ENDIAN_TO_BFS_INT64(value)   value
#elif (defined(BFS_LITTLE_ENDIAN_ONLY) && B_HOST_IS_BENDIAN) || (defined(BFS_BIG_ENDIAN_ONLY) && B_HOST_IS_LENDIAN)
#   define BFS_ENDIAN_TO_HOST_INT16(value)   bswap16((value))
#   define BFS_ENDIAN_TO_HOST_INT32(value)   bswap32((value))
#   define BFS_ENDIAN_TO_HOST_INT64(value)   bswap64((value))
#   define HOST_ENDIAN_TO_BFS_INT16(value)   bswap16((value))
#   define HOST_ENDIAN_TO_BFS_INT32(value)   bswap32((value))
#   define HOST_ENDIAN_TO_BFS_INT64(value)   bswap64((value))
#endif


/** Encode 16-bits of data in Big-Endian */
LIB_FUNC void be16enc(void* dest, const uint16_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)((u >> 8) & 0xff);
	p[1] = (unsigned char)(u & 0xff);
}


/** Encode 32-bits of data in Big-Endian */
LIB_FUNC void be32enc(void* dest, const uint32_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)((u >> 24) & 0xff);
	p[1] = (unsigned char)((u >> 16) & 0xff);
	p[2] = (unsigned char)((u >> 8) & 0xff);
	p[3] = (unsigned char)(u & 0xff);
}


/** Encode 64-bits of data in Big-Endian */
LIB_FUNC void be64enc(void* dest, const uint64_t u) {
	unsigned char* p = (unsigned char*)dest;
	be32enc(p, ((uint32_t)(u >> 32)));
	be32enc((p + 4), ((uint32_t)(u & 0xffffffff)));
}


/** Encode 16-bits of data in Little-Endian */
LIB_FUNC void le16enc(void* dest, const uint16_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)(u & 0xff);
	p[1] = (unsigned char)((u >> 8) & 0xff);
}


/** Encode 32-bits of data in Little-Endian */
LIB_FUNC void le32enc(void* dest, const uint32_t u) {
	unsigned char* p = (unsigned char*)dest;
	p[0] = (unsigned char)(u & 0xff);
	p[1] = (unsigned char)((u >> 8) & 0xff);
	p[2] = (unsigned char)((u >> 16) & 0xff);
	p[3] = (unsigned char)((u >> 24) & 0xff);
}


/** Encode 64-bits of data in Little-Endian */
LIB_FUNC void le64enc(void* dest, uint64_t u) {
	unsigned char* p = (unsigned char*)dest;
	le32enc(p, ((uint32_t)(u & 0xffffffff)));
	le32enc((p + 4), ((uint32_t)(u >> 32)));
}


/** Decode 16-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint16_t be16dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint16_t)((uint16_t)(p[0] << 8) | (uint16_t)p[1]);
}


/** Decode 32-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint32_t be32dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint32_t)((uint32_t)(p[0] << 24) | (uint32_t)(p[1] << 16) | (uint32_t)(p[2] << 8) | (uint32_t)p[3]);
}


/** Decode 64-bits of Big-Endian data to Little-Endian */
LIB_FUNC uint64_t be64dec(const void* dest) {
	unsigned char const* p = (unsigned char const*)dest;
	return (uint64_t)(((uint64_t)be32dec(p) << 32) | (uint64_t)be32dec(p + 4));
}


/** Decode 16-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint16_t le16dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint16_t)((uint16_t)(p[1] << 8) | (uint16_t)p[0]);
}


/** Decode 32-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint32_t le32dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint32_t)((uint32_t)(p[3] << 24) | (uint32_t)(p[2] << 16) | (uint32_t)(p[1] << 8) | (uint32_t)p[0]);
}


/** Decode 64-bits of Little-Endian data to Big-Endian */
LIB_FUNC uint64_t le64dec(const void* buf) {
	unsigned char const* p = (unsigned char const*)buf;
	return (uint64_t)(((uint64_t)le32dec(p + 4) << 32) | (uint64_t)le32dec(p));
}


#define HAVE_DECL_ENC16BE   1
#define HAVE_DECL_ENC32BE   1
#define HAVE_DECL_ENC64BE   1
#define HAVE_DECL_ENC16LE   1
#define HAVE_DECL_ENC32LE   1
#define HAVE_DECL_ENC64LE   1
#define HAVE_DECL_BE16DEC   1
#define HAVE_DECL_BE32DEC   1
#define HAVE_DECL_BE64DEC   1
#define HAVE_DECL_LE16DEC   1
#define HAVE_DECL_LE32DEC   1
#define HAVE_DECL_LE64DEC   1


// LOADING ENDIAN VALUES

/** Reads a 16-bit integer in big-endian order */
#define READ_UINT16(p)   ((((uint32_t)(p)[0]) << 8) | ((uint32_t)(p)[1]))


/** Reads a 16-bit integer in little-endian order */
#define LE_READ_UINT16(p)   ((((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[0]))


/** Reads a 24-bit integer in big-endian order */
#define READ_UINT24(p)   ((((uint32_t)(p)[0]) << 16) | (((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[2]))


/** Reads a 32-bit integer in big-endian order */
#define READ_UINT32(p)   ((((uint32_t)(p)[0]) << 24) | (((uint32_t)(p)[1]) << 16) | (((uint32_t)(p)[2]) << 8) | ((uint32_t)(p)[3]))


/** Reads a 32-bit integer in little-endian order */
#define LE_READ_UINT32(p)   ((((uint32_t)(p)[3]) << 24) | (((uint32_t)(p)[2]) << 16) | (((uint32_t)(p)[1]) << 8) | ((uint32_t)(p)[0]))


/** Reads a 64-bit integer in big-endian order */
#define READ_UINT64(p)   ((((uint64_t)(p)[0]) << 56) | (((uint64_t)(p)[1]) << 48) | (((uint64_t)(p)[2]) << 40) | (((uint64_t)(p)[3]) << 32) | (((uint64_t)(p)[4]) << 24) | (((uint64_t)(p)[5]) << 16) | (((uint64_t)(p)[6]) << 8) | ((uint64_t)(p)[7]))


/** Reads a 64-bit integer in little-endian order */
#define LE_READ_UINT64(p)   ((((uint64_t)(p)[7]) << 56) | (((uint64_t)(p)[6]) << 48) | (((uint64_t)(p)[5]) << 40) | (((uint64_t)(p)[4]) << 32) | (((uint64_t)(p)[3]) << 24) | (((uint64_t)(p)[2]) << 16) | (((uint64_t)(p)[1]) << 8) | ((uint64_t)(p)[0]))


LIB_FUNC uint32_t getle32(void* v) {
	unsigned char* p;
	p = v;
	return ((uint32_t)(p[3] << 24) | (uint32_t)(p[2] << 16) | (uint32_t)(p[1] << 8) | (uint32_t)p[0]);
}


LIB_FUNC uint16_t OSReadInt16(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint16_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt16(base, bytebyteOffset)   OSReadInt16((base), (bytebyteOffset))


LIB_FUNC uint32_t OSReadInt32(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint32_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt32(base, bytebyteOffset)   OSReadInt32((base), (bytebyteOffset))


LIB_FUNC uint64_t OSReadInt64(const volatile void* base, const uintptr_t byteOffset) {
	return (*(volatile uint64_t*)((uintptr_t)base + byteOffset));
}
#define _OSReadInt64(base, bytebyteOffset)   OSReadInt64((base), (bytebyteOffset))


// STORING ENDIAN VALUES

/** Writes a 16-bit integer in big-endian order */
#define WRITE_UINT16(p, i)   do { (p)[0] = ((i) >> 8) & 0xff; (p)[1] = (i) & 0xff; } while (0x0)


/** Writes a 16-bit integer in little-endian order */
#define LE_WRITE_UINT16(p, i)   do { (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)


/** Writes a 24-bit integer in big-endian order */
#define WRITE_UINT24(p, i)   do { (p)[0] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[2] = (i) & 0xff; } while (0x0)


/** Writes a 32-bit integer in big-endian order */
#define WRITE_UINT32(p, i)   do { (p)[0] = ((i) >> 24) & 0xff; (p)[1] = ((i) >> 16) & 0xff; (p)[2] = ((i) >> 8) & 0xff; (p)[3] = (i) & 0xff; } while (0x0)


/** Writes a 32-bit integer in little-endian order */
#define LE_WRITE_UINT32(p, i)   do { (p)[3] = ((i) >> 24) & 0xff; (p)[2] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)


/** Writes a 64-bit integer in big-endian order */
#define WRITE_UINT64(p, i)   do { (p)[0] = ((i) >> 56) & 0xff; (p)[1] = ((i) >> 48) & 0xff; (p)[2] = ((i) >> 40) & 0xff; (p)[3] = ((i) >> 32) & 0xff; (p)[4] = ((i) >> 24) & 0xff; (p)[5] = ((i) >> 16) & 0xff; (p)[6] = ((i) >> 8) & 0xff; (p)[7] = (i) & 0xff; } while (0x0)


/** Writes a 64-bit integer in little-endian order */
#define LE_WRITE_UINT64(p, i)   do { (p)[7] = ((i) >> 56) & 0xff; (p)[6] = ((i) >> 48) & 0xff; (p)[5] = ((i) >> 40) & 0xff; (p)[4] = ((i) >> 32) & 0xff; (p)[3] = ((i) >> 24) & 0xff; (p)[2] = ((i) >> 16) & 0xff; (p)[1] = ((i) >> 8) & 0xff; (p)[0] = (i) & 0xff; } while (0x0)


LIB_FUNC void putle32(void* v, const uint32_t i) {
	unsigned char* p;
	p = (unsigned char*)v;
	p[0] = (unsigned char)i;
	p[1] = (unsigned char)(i >> 8);
	p[2] = (unsigned char)(i >> 16);
	p[3] = (unsigned char)(i >> 24);
}


LIB_FUNC void OSWriteInt16(volatile void* base, const uintptr_t byteOffset, const uint16_t data) {
	(*(volatile uint16_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt16(base, bytebyteOffset, data)   OSWriteInt16((base), (bytebyteOffset), (data))


LIB_FUNC void _OSWriteInt32(volatile void* base, const uintptr_t byteOffset, const uint32_t data) {
	(*(volatile uint32_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt32(base, bytebyteOffset, data)   OSWriteInt32((base), (bytebyteOffset), (data))


LIB_FUNC void _OSWriteInt64(volatile void* base, const uintptr_t byteOffset, const uint64_t data) {
	(*(volatile uint64_t*)((uintptr_t)base + byteOffset) = data);
}
#define _OSWriteInt64(base, bytebyteOffset, data)   OSWriteInt64((base), (bytebyteOffset), (data))


// BYTE REVERSED LOADS

LIB_FUNC uint16_t OSReadSwapInt16(const volatile void* base, const uintptr_t byteOffset) {
	uint16_t data = *(volatile uint16_t*)((uintptr_t)base + byteOffset);
	return _OSSwapInt16(data);
}
#define _OSReadSwapInt16(base, bytebyteOffset)   OSReadSwapInt16((base), (bytebyteOffset))


LIB_FUNC uint32_t OSReadSwapInt32(const volatile void* base, const uintptr_t byteOffset) {
	uint32_t data = *(volatile uint32_t*)((uintptr_t)base + byteOffset);
	return _OSSwapInt32(data);
}
#define _OSReadSwapInt32(base, bytebyteOffset)   OSReadSwapInt32((base), (bytebyteOffset))


LIB_FUNC uint64_t OSReadSwapInt64(const volatile void* base, const uintptr_t byteOffset) {
	uint64_t data = *(volatile uint64_t*)((uintptr_t)base + byteOffset);
	return _OSSwapInt64(data);
}
#define _OSReadSwapInt64(base, bytebyteOffset)   OSReadSwapInt64((base), (bytebyteOffset))


// BYTE REVERSED STORES

LIB_FUNC void OSWriteSwapInt16(volatile void* base, const uintptr_t byteOffset, const uint16_t data) {
	(*(volatile uint16_t*)((uintptr_t)base + byteOffset) = _OSSwapInt16(data));
}
#define _OSWriteSwapInt16(base, bytebyteOffset, data)   OSWriteSwapInt16((base), (bytebyteOffset), (data))


LIB_FUNC void OSWriteSwapInt32(volatile void* base, const uintptr_t byteOffset, const uint32_t data) {
	(*(volatile uint32_t*)((uintptr_t)base + byteOffset) = _OSSwapInt32(data));
}
#define _OSWriteSwapInt32(base, bytebyteOffset, data)   OSWriteSwapInt32((base), (bytebyteOffset), (data))


LIB_FUNC void OSWriteSwapInt64(volatile void* base, const uintptr_t byteOffset, const uint64_t data) {
	(*(volatile uint64_t*)((uintptr_t)base + byteOffset) = _OSSwapInt64(data));
}
#define _OSWriteSwapInt64(base, bytebyteOffset, data)   OSWriteSwapInt64((base), (bytebyteOffset), (data))


#define OSReadBigInt(x, y)   OSReadBigInt32(x, y)
#define OSWriteBigInt(x, y, z)   OSWriteBigInt32(x, y, z)
#define OSSwapBigToHostInt(x)   OSSwapBigToHostInt32(x)
#define OSSwapHostToBigInt(x)   OSSwapHostToBigInt32(x)
#define OSReadLittleInt(x, y)   OSReadLittleInt32(x, y)
#define OSWriteLittleInt(x, y, z)   OSWriteLittleInt32(x, y, z)
#define OSSwapHostToLittleInt(x)   OSSwapHostToLittleInt32(x)
#define OSSwapLittleToHostInt(x)   OSSwapLittleToHostInt32(x)
#if IS_BIG_ENDIAN
#   define OSReadBigInt16(base, byteOffset)   _OSReadInt16(base, byteOffset)
#   define OSReadBigInt32(base, byteOffset)   _OSReadInt32(base, byteOffset)
#   define OSReadBigInt64(base, byteOffset)   _OSReadInt64(base, byteOffset)
#   define OSWriteBigInt16(base, byteOffset, data)   _OSWriteInt16(base, byteOffset, data)
#   define OSWriteBigInt32(base, byteOffset, data)   _OSWriteInt32(base, byteOffset, data)
#   define OSWriteBigInt64(base, byteOffset, data)   _OSWriteInt64(base, byteOffset, data)
#   define OSReadLittleInt16(base, byteOffset)   OSReadSwapInt16(base, byteOffset)
#   define OSReadLittleInt32(base, byteOffset)   OSReadSwapInt32(base, byteOffset)
#   define OSReadLittleInt64(base, byteOffset)   OSReadSwapInt64(base, byteOffset)
#   define OSWriteLittleInt16(base, byteOffset, data)   OSWriteSwapInt16(base, byteOffset, data)
#   define OSWriteLittleInt32(base, byteOffset, data)   OSWriteSwapInt32(base, byteOffset, data)
#   define OSWriteLittleInt64(base, byteOffset, data)   OSWriteSwapInt64(base, byteOffset, data)
#   define OSSwapHostToBigConstInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToBigConstInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToBigConstInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToBigInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToBigInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToBigInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToLittleConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapHostToLittleConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapHostToLittleConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapHostToLittleInt16(x)   OSSwapInt16(x)
#   define OSSwapHostToLittleInt32(x)   OSSwapInt32(x)
#   define OSSwapHostToLittleInt64(x)   OSSwapInt64(x)
#   define OSSwapBigToHostConstInt16(x)   ((uint16_t)(x))
#   define OSSwapBigToHostConstInt32(x)   ((uint32_t)(x))
#   define OSSwapBigToHostConstInt64(x)   ((uint64_t)(x))
#   define OSSwapBigToHostInt16(x)   ((uint16_t)(x))
#   define OSSwapBigToHostInt32(x)   ((uint32_t)(x))
#   define OSSwapBigToHostInt64(x)   ((uint64_t)(x))
#   define OSSwapLittleToHostConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapLittleToHostConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapLittleToHostConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapLittleToHostInt16(x)   OSSwapInt16(x)
#   define OSSwapLittleToHostInt32(x)   OSSwapInt32(x)
#   define OSSwapLittleToHostInt64(x)   OSSwapInt64(x)
#elif IS_LITTLE_ENDIAN
#   define OSReadBigInt16(base, byteOffset)   OSReadSwapInt16(base, byteOffset)
#   define OSReadBigInt32(base, byteOffset)   OSReadSwapInt32(base, byteOffset)
#   define OSReadBigInt64(base, byteOffset)   OSReadSwapInt64(base, byteOffset)
#   define OSWriteBigInt16(base, byteOffset, data)   OSWriteSwapInt16(base, byteOffset, data)
#   define OSWriteBigInt32(base, byteOffset, data)   OSWriteSwapInt32(base, byteOffset, data)
#   define OSWriteBigInt64(base, byteOffset, data)   OSWriteSwapInt64(base, byteOffset, data)
#   define OSReadLittleInt16(base, byteOffset)   _OSReadInt16(base, byteOffset)
#   define OSReadLittleInt32(base, byteOffset)   _OSReadInt32(base, byteOffset)
#   define OSReadLittleInt64(base, byteOffset)   _OSReadInt64(base, byteOffset)
#   define OSWriteLittleInt16(base, byteOffset, data)   _OSWriteInt16(base, byteOffset, data)
#   define OSWriteLittleInt32(base, byteOffset, data)   _OSWriteInt32(base, byteOffset, data)
#   define OSWriteLittleInt64(base, byteOffset, data)   _OSWriteInt64(base, byteOffset, data)
#   define OSSwapHostToBigConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapHostToBigConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapHostToBigConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapHostToBigInt16(x)   OSSwapInt16(x)
#   define OSSwapHostToBigInt32(x)   OSSwapInt32(x)
#   define OSSwapHostToBigInt64(x)   OSSwapInt64(x)
#   define OSSwapHostToLittleConstInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToLittleConstInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToLittleConstInt64(x)   ((uint64_t)(x))
#   define OSSwapHostToLittleInt16(x)   ((uint16_t)(x))
#   define OSSwapHostToLittleInt32(x)   ((uint32_t)(x))
#   define OSSwapHostToLittleInt64(x)   ((uint64_t)(x))
#   define OSSwapBigToHostConstInt16(x)   OSSwapConstInt16(x)
#   define OSSwapBigToHostConstInt32(x)   OSSwapConstInt32(x)
#   define OSSwapBigToHostConstInt64(x)   OSSwapConstInt64(x)
#   define OSSwapBigToHostInt16(x)   OSSwapInt16(x)
#   define OSSwapBigToHostInt32(x)   OSSwapInt32(x)
#   define OSSwapBigToHostInt64(x)   OSSwapInt64(x)
#   define OSSwapLittleToHostConstInt16(x)   ((uint16_t)(x))
#   define OSSwapLittleToHostConstInt32(x)   ((uint32_t)(x))
#   define OSSwapLittleToHostConstInt64(x)   ((uint64_t)(x))
#   define OSSwapLittleToHostInt16(x)   ((uint16_t)(x))
#   define OSSwapLittleToHostInt32(x)   ((uint32_t)(x))
#   define OSSwapLittleToHostInt64(x)   ((uint64_t)(x))
#else
#   error   "Unknown endianess!"
#endif


// WINDOWS MACROS

#define MAKEWORD(bLow, bHigh)   ((uint16_t)(((uint8_t)((DWORD_PTR)(bLow) & 0xff)) | (((uint16_t)((uint8_t)((DWORD_PTR)(bHigh) & 0xff))) << 8)))
#define MAKELONG(wLow, wHigh)   ((uint32_t)(((uint16_t)((DWORD_PTR)(wLow) & 0xffff)) | (((uint32_t)((uint16_t)((DWORD_PTR)(wHigh) & 0xffff))) << 16)))
#define LOWORD(l)   ((uint16_t)((DWORD_PTR)(l) & 0xffff))
#define HIWORD(l)   ((uint16_t)(((DWORD_PTR)(l) >> 16) & 0xffff))
#define LOBYTE(w)   ((uint8_t)((DWORD_PTR)(w) & 0xff))
#define HIBYTE(w)   ((uint8_t)(((DWORD_PTR)(w) >> 8) & 0xff))


// ROTATIONS

/** Given an unsigned 64-bit argument X, return the value corresponding to rotating the bits N steps to the left; N must be between 1 and 63 inclusive */
LIB_FUNC uint64_t rotl64(const uint64_t x, const int n) {
	return (((x << n) | (x >> (64 - n))) & (uint64_t)0xffffffffffffffff);
}


/** Given an unsigned 64-bit argument X, return the value corresponding to rotating the bits N steps to the right; N must be between 1 to 63 inclusive */
LIB_FUNC uint64_t rotr64(const uint64_t x, const int n) {
	return (((x >> n) | (x << (64 - n))) & (uint64_t)0xffffffffffffffff);
}


#define ROTL32(n, x)   (((x) << (n)) | ((x) >> ((-(n) & 31))))
#define ROTL64(n, x)   (((x) << (n)) | ((x) >> ((-(n)) & 63)))


/** Given an unsigned 32-bit argument X, return the value corresponding to rotating the bits N steps to the left; N must be between 1 and 31 inclusive */
LIB_FUNC uint32_t rotl32(const uint32_t x, const int n) {
	return (((x << n) | (x >> (32 - n))) & 0xffffffffU);
}


/** Given an unsigned 32-bit argument X, return the value corresponding to rotating the bits N steps to the right; N must be between 1 to 31 inclusive */
LIB_FUNC uint32_t rotr32(const uint32_t x, const int n) {
	return (((x >> n) | (x << (32 - n))) & 0xffffffffU);
}


/** Given an unsigned 16-bit argument X, return the value corresponding to rotating the bits N steps to the left; N must be between 1 to 15 inclusive, but on most relevant targets N can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC uint16_t rotl16(const uint16_t x, const int n) {
	return (uint16_t)(((x << n) | (x >> (16 - n))) & 0xffff);
}


/** Given an unsigned 16-bit argument X, return the value corresponding to rotating the bits N steps to the right; N must be in 1 to 15 inclusive, but on most relevant targets N can also be 0 and 16 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC uint16_t rotr16(const uint16_t x, const int n) {
	return (uint16_t)(((x >> n) | (x << (16 - n))) & 0xffff);
}


/** Given an unsigned 8-bit argument X, return the value corresponding to rotating the bits N steps to the left; N must be between 1 to 7 inclusive, but on most relevant targets N can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC uint8_t rotl8(const uint8_t x, const int n) {
	return (uint8_t)(((x << n) | (x >> (8 - n))) & 0xff);
}


/** Given an unsigned 8-bit argument X, return the value corresponding to rotating the bits N steps to the right; N must be in 1 to 7 inclusive, but on most relevant targets N can also be 0 and 8 because 'int' is at least 32 bits and the arguments must widen before shifting */
LIB_FUNC uint8_t rotr8(const uint8_t x, const int n) {
	return (uint8_t)(((x >> n) | (x << (8 - n))) & 0xff);
}


/** Given a size_t argument X, return the value corresponding to rotating the bits N steps to the left; N must be between 1 and (CHAR_BIT * sizeof(size_t) - 1) inclusive */
LIB_FUNC size_t rotl_sz(const size_t x, const int n) {
	return (size_t)(((x << n) | (x >> (BITS_PER_SIZE_T - n))) & SIZE_MAX);
}


/** Given a size_t argument X, return the value corresponding to rotating the bits N steps to the right; N must be between 1 to (CHAR_BIT * sizeof(size_t) - 1) inclusive */
LIB_FUNC size_t rotr_sz(const size_t x, const int n) {
	return (size_t)(((x >> n) | (x << (BITS_PER_SIZE_T - n))) & SIZE_MAX);
}


// BIT COUNTING

/** Return the number of bits used to represent the given number */
LIB_FUNC ullint bit_length(const ullint num) {
	register ullint len = 0, x = num;
	while (x != 0) {
		++len;
		x >>= 1;
	}
	return len;
}


#ifdef UINT128_SUPPORTED
/** Return the number of bits used to represent the given number */
LIB_FUNC uint128_t bit128_length(const uint128_t num) {
	register uint128_t len = 0, x = num;
	while (x != 0) {
		++len;
		x >>= 1;
	}
	return len;
}
#endif


/** Counts the number of `1` bits (32-bit) */
LIB_FUNC uint32_t popcount32(const uint32_t x) {
	register uint32_t y = (uint32_t)(x - ((x >> 1) & 0x55555555U));
	y = (y & 0x33333333U) + ((y >> 2) & 0x33333333U);
	y = (y + (y >> 4)) & 0x0f0f0f0fU;
	return (uint32_t)((y * 0x01010101U) >> 24);
}
#define popcnt32(x)   popcount32((x))
#define __popcnt32(x)   popcount32((x))
#if (SIZE_MAX < 0xffffffffffffffffULL)
/** Counts the number of `1` bits (64-bit) */
LIB_FUNC uint32_t popcount64(const uint64_t x) {
	return popcount32((uint32_t)(x >> 32)) + popcount32((uint32_t)(x & 0xffffffffULL));
}
#else
/** Counts the number of `1` bits (64-bit) */
LIB_FUNC uint32_t popcount64(const uint64_t x) {
	register uint64_t y = (uint32_t)(x - ((x >> 1) & (uint64_t)NUM_5ULL));
	y = (uint64_t)((y & (uint64_t)NUM_3ULL) + ((y >> 2) & (uint64_t)NUM_3ULL));
	y = (uint64_t)(((y + (y >> 4)) & (uint64_t)NUM_0fULL) * (uint64_t)0x0101010101010101ULL);
	return (uint32_t)(y >> 56);
}
#endif
#define popcnt64(x)   popcount64((x))
#define __popcnt64(x)   popcount64((x))
#if (UINT_MAX == 0xffffffffU)
/** Counts the number of `1` bits (32-bit) */
#   define popcount(x)   popcount32((x))
#endif
#if (ULONG_MAX == 0xffffffffU)
/** Counts the number of `1` bits (long) */
#   define popcountl(x)   popcount32((x))
#elif (ULONG_MAX == 0xffffffffffffffffULL)
/** Counts the number of `1` bits (long) */
#   define popcountl(x)   popcount64((x))
#endif
#if (ULLONG_MAX == 0xffffffffffffffffULL)
/** Counts the number of `1` bits (long long) */
#   define popcountll(x)   popcount64((x))
#endif


// MISCELLANEOUS BIT/BYTE OPERATIONS

/** Clear least significant bit */
LIB_FUNC ullint clearlsb(const ullint num) {
	return (ullint)(num & (num - 1));
}


LIB_FUNC void mi_vector_hash(const void* restrict key, size_t len, const uint32_t seed, uint32_t hashes[3]) {
	static const uint32_t mask[4] = { 0xff, 0xffff, 0xffffff, 0xffffffff };
	const uint32_t orig_len = (uint32_t)len;
	register uint32_t a = 0x9E3779B9, b = 0x9E3779B9, c = seed;
	const uint8_t* k;
	if ((uintptr_t)key & 3) {
		k = key;
		while (len >= 12) {
			a += le32dec(k);
			b += le32dec(k + 4);
			c += le32dec(k + 8);
			mix(a, b, c);
			k += 12;
			len -= 12;
		}
		c += orig_len;
		if (len > 8) {
			switch (len) {
				case 11: c += (uint32_t)k[10] << 24;
				case 10: c += (uint32_t)k[9] << 16;
				case 9: c += (uint32_t)k[8] << 8;
				default: break;
			}
			b += le32dec(k + 4);
			a += le32dec(k);
		} else if (len > 4) {
			switch (len) {
				case 8: b += (uint32_t)k[7] << 24;
				case 7: b += (uint32_t)k[6] << 16;
				case 6: b += (uint32_t)k[5] << 8;
				case 5: b += k[4];
				default: break;
			}
			a += le32dec(k);
		} else if (len) {
			switch (len) {
				case 4: a += (uint32_t)k[3] << 24;
				case 3: a += (uint32_t)k[2] << 16;
				case 2: a += (uint32_t)k[1] << 8;
				case 1: a += k[0];
				default: break;
			}
		}
	} else {
		const uint32_t* key32 = key;
		while (len >= 12) {
			a += le32toh(key32[0]);
			b += le32toh(key32[1]);
			c += le32toh(key32[2]);
			mix(a, b, c);
			key32 += 3;
			len -= 12;
		}
		c += orig_len;
		if (len > 8) {
			c += (le32toh(key32[2]) & mask[len - 9]) << 8;
			b += le32toh(key32[1]);
			a += le32toh(key32[0]);
		} else if (len > 4) {
			b += le32toh(key32[1]) & mask[len - 5];
			a += le32toh(key32[0]);
		} else if (len)
			a += le32toh(key32[0]) & mask[len - 1];
	}
	mix(a, b, c);
	hashes[0] = a;
	hashes[1] = b;
	hashes[2] = c;
}


#ifdef ARCHAVR
#   if IS_WORDSIZE_16
#      define COUNT_LEADING_ZEROS_0   16
#   elif IS_WORDSIZE_32
#      define COUNT_LEADING_ZEROS_0   32
#   elif IS_WORDSIZE_64
#      define COUNT_LEADING_ZEROS_0   64
#   endif
#elif defined(__alpha_cix__)
#   define COUNT_LEADING_ZEROS_0   64
#elif defined(ARCHARC)
#   define COUNT_LEADING_ZEROS_0   32
#elif WORDSIZE_IS_32
#   define COUNT_LEADING_ZEROS_0   32
#elif WORDSIZE_IS_64
#   define COUNT_LEADING_ZEROS_0   64
#else
#   define COUNT_LEADING_ZEROS_0   BITS_PER_LONG
#endif
#ifndef COUNT_TRAILING_ZEROS_0
#   define COUNT_TRAILING_ZEROS_0   (-1)
#endif


#ifndef nop
#   define nop()   asm volatile ("nop;")
#endif
#ifndef nop2
#   define nop2()   asm volatile ("nop;" "nop;")
#endif
#ifndef noop
#   define noop()   asm volatile ("nop;")
#endif
#ifndef Xyzzy
#   define Xyzzy   asm volatile ("nop;")
#endif
#ifndef xyzzy
#   define xyzzy   asm volatile ("nop;")
#endif
#ifndef XYZZY
#   define XYZZY   asm volatile ("nop;")
#endif
#ifndef xYzZY
#   define xYzZY   asm volatile ("nop;")
#endif


/** Find last (most-significant) set bit in a long word
@word: The word to search
Undefined if no set bit exists, so code should check against 0 first
Note: fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32
*/
LIB_FUNC unsigned long fls(const unsigned long word) {
	register int num = (BITS_PER_LONG - 1);
	register unsigned long _word = word;
#   if (BITS_PER_LONG == 64)
	if (!(_word & (~0UL << 32))) { num -= 32; _word <<= 32; }
#   endif
	if (!(_word & (~0UL << (BITS_PER_LONG - 16)))) { num -= 16; _word <<= 16; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 8)))) { num -= 8; _word <<= 8; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 4)))) { num -= 4; _word <<= 4; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 2)))) { num -= 2; _word <<= 2; }
	if (!(_word & (~0UL << (BITS_PER_LONG - 1)))) { num -= 1; }
	return (unsigned long)num;
}
#define __fls(x)   fls((x))


/** Find first bit set; Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC int ffs(const int mask) {
	register unsigned int r = (unsigned int)mask;
	register int bit = 0;
	if (!(r & 0xffff)) { bit += 16; r >>= 16; }
	if (!(r & 0xff)) { bit += 8; r >>= 8; }
	if (!(r & 0xf)) { bit += 4; r >>= 4; }
	const signed char t[16] = { -28, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1 };
	return (bit + t[(r & 0xf)]);
}
#define __ffs(mask)   ffs((mask))
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0 first */
#define ffz(x)   (ffs(~(int)(x)) - 1)
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0 first */
#define __ffz(x)   (ffs(~(int)(x)) - 1)


/** Find Last (most-significant) Bit Set */
LIB_FUNC int fls32(const uint32_t xint) {
	if (!xint) { return 0; }
	register int _v = 32;
	register uint32_t x = xint;
	if ((x & 0xFFFF0000U) == 0) {
		x <<= 16;
		_v -= 16;
	}
	if ((x & 0xFF000000U) == 0) {
		x <<= 8;
		_v -= 8;
	}
	if ((x & 0xF0000000U) == 0) {
		x <<= 4;
		_v -= 4;
	}
	if ((x & 0xC0000000U) == 0) {
		x <<= 2;
		_v -= 2;
	}
	if ((x & 0x80000000U) == 0) {
		x <<= 1;
		_v -= 1;
	}
	return _v;
}


/** Find Last (most-significant) Bit Set */
LIB_FUNC int fls64(const uint64_t xint) {
	if (!xint) { return 0; }
	register int _v = 64;
	register uint64_t x = xint;
	if ((x & 0xFFFFFFFF00000000ULL) == 0) {
		x <<= 32;
		_v -= 32;
	}
	if ((x & 0xFFFF000000000000ULL) == 0) {
		x <<= 16;
		_v -= 16;
	}
	if ((x & 0xFF00000000000000ULL) == 0) {
		x <<= 8;
		_v -= 8;
	}
	if ((x & 0xF000000000000000ULL) == 0) {
		x <<= 4;
		_v -= 4;
	}
	if ((x & 0xC000000000000000ULL) == 0) {
		x <<= 2;
		_v -= 2;
	}
	if ((x & 0x8000000000000000ULL) == 0) {
		x <<= 1;
		_v -= 1;
	}
	return _v;
}


/** Find Last (most-significant) Bit Set */
LIB_FUNC unsigned int fls_long(const unsigned long l) {
	if (BYTES_PER_LONG == 4) { return (unsigned int)fls(l); }
	return (unsigned int)fls64(l);
}


/** Count the number of zeros from the MSB back; Like __builtin_clz()
@x: The value

Count the number of leading zeros from the MSB going towards the LSB in @x.
If the MSB of @x is set, the result is 0.
If only the LSB of @x is set, then the result is BITS_PER_LONG-1.
If @x is 0 then the result is BITS_PER_LONG.
*/
LIB_FUNC int count_leading_zeros(const unsigned long x) {
	if (SIZEOF_LONG == 4) { return (int)(BITS_PER_LONG - (int)fls(x)); }
	return (int)(BITS_PER_LONG - (int)fls64(x));
}
#define clzl(x)   count_leading_zeros((x))
#define clzll(x)   count_leading_zeros((x))
#define clz_si2(x)   count_leading_zeros((x))
#define clz_qi2(x)   count_leading_zeros((x))
#define clz_hi2(x)   count_leading_zeros((x))
#define cntlzw(x)   count_leading_zeros((x))
#define __cntlzw(x)   count_leading_zeros((x))
#define clz_di2(x)   count_leading_zeros((x))
#define cntlzd(x)   count_leading_zeros((x))
#define __cntlzd(x)   count_leading_zeros((x))


/** Count leading redundant sign bits */
LIB_FUNC int clrsbqi2(const char x) {
	register char y = x;
	if (y < 0) { y = (char)(~y); }
	if (y == 0) { return (int)(BITS_PER_CHAR - 1); }
	return (int)(count_leading_zeros(((unsigned int)y << 8)) - 1);
}
#define __clrsbqi2(x)   clrsbqi2((x))


/** Find last (most-significant) set bit in a long word; Undefined if no set bit exists, so code should check against 0 first */
LIB_FUNC unsigned long flsl(const unsigned long word) {
	register unsigned long _word = word;
	return (unsigned long)(BITS_PER_LONG - 1 - clzl(_word));
}
#define __flsl(word)   flsl((word))


/** Count the number of zeros from the LSB forwards
@x: The value

Count the number of trailing zeros from the LSB going towards the MSB in @x.
If the LSB of @x is set, the result is 0.
If only the MSB of @x is set, then the result is BITS_PER_LONG-1.
If @x is 0 then the result is COUNT_TRAILING_ZEROS_0.
*/
LIB_FUNC int count_trailing_zeros(const unsigned long x) {
	if (SIZEOF_LONG == 4) { return (int)ffs((int)x); }
	else { return (int)((x != 0UL) ? (int)flsl(x) : COUNT_TRAILING_ZEROS_0); }
}


/** Count leading redundant sign bits */
LIB_FUNC int clrsbdi2(const long long x) {
	register long long y = x;
	if (y < 0LL) { y = (long long)(~y); }
	if (y == 0LL) { return (int)(BITS_PER_LONG_LONG - 1); }
	return (int)(clzll((unsigned long long)x) - 1);
}
#define __clrsbdi2(x)   clrsbdi2((x))


LIB_FUNC unsigned long ffs_long(const unsigned long word) {
	unsigned long res;
	asm ("rep;" "bsf %1, %0;" : "=r"(res) : "rm"(word));
	return res;
}


/** Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC int ffsl(const long i) {
	return (int)(i ? (a_ctz_l((unsigned long)i) + 1) : 0);
}
#define __ffsl(i)   ffsl((i))


#if (defined(X86) || defined(X86_64))
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
LIB_FUNC unsigned long ffzl(unsigned long word) {
	asm ("rep;" "bsf %1, %0;" : "=r"(word) : "r"(~(word)));
	return word;
}
#else
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
#   define ffzl(x)   (ffsl(~(long)(x)) - 1L)
#endif
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
#define __ffzl(x)   (ffsl(~(long)(x)) - 1L)


/** Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero */
LIB_FUNC int ffsll(const long long i) {
#if (SIZEOF_LONG == SIZEOF_LONG_LONG)
	return (int)(i ? (a_ctz_l((unsigned long)i) + 1) : 0);
#else
	register unsigned long long u = (unsigned long long)i;
	register unsigned long long upper = ((unsigned long long))(u >> 32);
	if (upper) { return (int)(32 + ffsl(upper)); }
	return (int)ffsl((u & 0xffffffff));
#endif
}
#define __ffsll(i)   ffsll((i))
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
#define ffzll(x)   (ffsll(~(long long)(x)) - 1LL)
/** Find first zero in word; Undefined if no zero exists, so code should check against ~0UL first */
#define __ffzll(x)   (ffsll(~(long long)(x)) - 1LL)


/** Find First Set */
LIB_FUNC int ffs32(const uint32_t xint) {
	if (!xint) { return 0; }
	register int _v = 1;
	register uint32_t x = xint;
	if ((x & 0xFFFFU) == 0) {
		x >>= 16;
		_v += 16;
	}
	if ((x & 0xFFU) == 0) {
		x >>= 8;
		_v += 8;
	}
	if ((x & 0xFU) == 0) {
		x >>= 4;
		_v += 4;
	}
	if ((x & 3U) == 0) {
		x >>= 2;
		_v += 2;
	}
	if ((x & 1U) == 0) {
		x >>= 1;
		_v += 1;
	}
	return _v;
}


/** Find First Set */
LIB_FUNC int ffs64(const uint64_t xint) {
	if (!xint) { return 0; }
	register int _v = 1;
	register uint64_t x = xint;
	if ((x & 0xFFFFFFFFULL) == 0) {
		x >>= 32;
		_v += 32;
	}
	if ((x & 0xFFFFULL) == 0) {
		x >>= 16;
		_v += 16;
	}
	if ((x & 0xFFULL) == 0) {
		x >>= 8;
		_v += 8;
	}
	if ((x & 0xFULL) == 0) {
		x >>= 4;
		_v += 4;
	}
	if ((x & 3ULL) == 0) {
		x >>= 2;
		_v += 2;
	}
	if ((x & 1ULL) == 0) {
		x >>= 1;
		_v += 1;
	}
	return _v;
}


LIB_FUNC int get_bitmask_order(const unsigned int count) {
	return (int)fls(count);
}


LIB_FUNC int get_count_order(const unsigned int count) {
	register int order = (int)(fls(count) - 1);
	if (count & (count - 1)) { ++order; }
	return order;
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight32(const unsigned long w) {
	register unsigned int res = (unsigned int)((w & 0x55555555) + ((w >> 1) & 0x55555555));
	res = (unsigned int)((res & 0x33333333) + ((res >> 2) & 0x33333333));
	res = (unsigned int)((res & 0xF0F0F0F) + ((res >> 4) & 0xF0F0F0F));
	res = (unsigned int)((res & 0xFF00FF) + ((res >> 8) & 0xFF00FF));
	return (unsigned long)((res & 0xFFFF) + ((res >> 16) & 0xFFFF));
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight64(const uint64_t w) {
#   if BITS_PER_LONG < 64
	return hweight32((unsigned int)(w >> 32)) + hweight32((unsigned int)w);
#   else
	uint64_t res = (uint64_t)((w & 0x5555555555555555U) + ((w >> 1) & 0x5555555555555555U));
	res = (uint64_t)((res & 0x3333333333333333U) + ((res >> 2) & 0x3333333333333333U));
	res = (uint64_t)((res & 0xF0F0F0F0F0F0F0FU) + ((res >> 4) & 0xF0F0F0F0F0F0F0FU));
	res = (uint64_t)((res & 0xFF00FF00FF00FFU) + ((res >> 8) & 0xFF00FF00FF00FFU));
	res = (uint64_t)((res & 0xFFFF0000FFFFU) + ((res >> 16) & 0xFFFF0000FFFFU));
	return (unsigned long)((res & 0xFFFFFFFFU) + ((res >> 32) & 0xFFFFFFFFU));
#   endif
}


/** Return the hamming weight (i.e. the number of bits set) of a N-bit word */
LIB_FUNC unsigned long hweight_long(const unsigned long w) {
	return (unsigned long)((BYTES_PER_LONG == 4) ? hweight32(w) : hweight64(w));
}


/** Integer logarithm, returns -1 on error; Inspired by the Linux version written by David Howells */
#define _ilog2_helper(_n, _x)   ((_n) & (1ULL << (_x))) ? _x :
#define _ilog2_const(_n)   (_ilog2_helper(_n, 63) _ilog2_helper(_n, 62) _ilog2_helper(_n, 61) _ilog2_helper(_n, 60) _ilog2_helper(_n, 59) _ilog2_helper(_n, 58) _ilog2_helper(_n, 57) _ilog2_helper(_n, 56) _ilog2_helper(_n, 55) _ilog2_helper(_n, 54) _ilog2_helper(_n, 53) _ilog2_helper(_n, 52) _ilog2_helper(_n, 51) _ilog2_helper(_n, 50) _ilog2_helper(_n, 49) _ilog2_helper(_n, 48) _ilog2_helper(_n, 47) _ilog2_helper(_n, 46) _ilog2_helper(_n, 45) _ilog2_helper(_n, 44) _ilog2_helper(_n, 43) _ilog2_helper(_n, 42) _ilog2_helper(_n, 41) _ilog2_helper(_n, 40) _ilog2_helper(_n, 39) _ilog2_helper(_n, 38) _ilog2_helper(_n, 37) _ilog2_helper(_n, 36) _ilog2_helper(_n, 35) _ilog2_helper(_n, 34) _ilog2_helper(_n, 33) _ilog2_helper(_n, 32) _ilog2_helper(_n, 31) _ilog2_helper(_n, 30) _ilog2_helper(_n, 29) _ilog2_helper(_n, 28) _ilog2_helper(_n, 27) _ilog2_helper(_n, 26) _ilog2_helper(_n, 25) _ilog2_helper(_n, 24) _ilog2_helper(_n, 23) _ilog2_helper(_n, 22) _ilog2_helper(_n, 21) _ilog2_helper(_n, 20) _ilog2_helper(_n, 19) _ilog2_helper(_n, 18) _ilog2_helper(_n, 17) _ilog2_helper(_n, 16) _ilog2_helper(_n, 15) _ilog2_helper(_n, 14) _ilog2_helper(_n, 13) _ilog2_helper(_n, 12) _ilog2_helper(_n, 11) _ilog2_helper(_n, 10) _ilog2_helper(_n, 9) _ilog2_helper(_n, 8) _ilog2_helper(_n, 7) _ilog2_helper(_n, 6) _ilog2_helper(_n, 5) _ilog2_helper(_n, 4) _ilog2_helper(_n, 3) _ilog2_helper(_n, 2) _ilog2_helper(_n, 1) _ilog2_helper(_n, 0) -1)
#define ilog2(_n)   (__builtin_constant_p(_n) ?  _ilog2_const(_n) : ((sizeof(_n) > 4 ? fls64(_n) : fls32(_n)) - 1))


LIB_FUNC void fast_divide32_prepare(const uint32_t _div, uint32_t* restrict _m, uint8_t* restrict _s1, uint8_t* restrict _s2) {
	register int _l = fls32(_div - 1);
	register uint64_t _mt = (uint64_t)(0x100000000ULL * ((1ULL << _l) - _div));
	*_m = (uint32_t)(_mt / _div + 1);
	*_s1 = (uint8_t)((_l > 1) ? 1 : _l);
	*_s2 = (uint8_t)((_l == 0) ? 0 : (_l - 1));
}


LIB_FUNC uint32_t fast_divide32(const uint32_t _v, UNUSED uint32_t _div, const uint32_t _m, const uint8_t _s1, const uint8_t _s2) {
	register uint32_t _t = (uint32_t)(((uint64_t)_v * _m) >> 32);
	return (uint32_t)((_t + ((_v - _t) >> _s1)) >> _s2);
}


LIB_FUNC uint32_t fast_remainder32(const uint32_t _v, const uint32_t _div, const uint32_t _m, const uint8_t s1, const uint8_t s2) {
	return (uint32_t)(_v - _div * fast_divide32(_v, _div, _m, s1, s2));
}


#define __BITMAP_BITS(__t)   (sizeof(__t) * NBBY)
#define __BITMAP_MASK(__t)   (__BITMAP_BITS(__t) - 1)
#define __BITMAP_BIT(__n, __v)    (1 << ((__n) & __BITMAP_MASK(*(__v)->_b)))
#define __BITMAP_SIZE(__t, __n)    (((__n) + (__BITMAP_BITS(__t) - 1)) / __BITMAP_BITS(__t))
#define __BITMAP_TYPE(__s, __t, __n)   struct __s { __t _b[__BITMAP_SIZE(__t, __n)]; }
#define __BITMAP_SHIFT(__t)   (ilog2(__BITMAP_BITS(__t)))
#define __BITMAP_WORD(__n, __v)   ((__n) >> __BITMAP_SHIFT(*(__v)->_b))
#define __BITMAP_SET(__n, __v)   ((__v)->_b[__BITMAP_WORD(__n, __v)] |= __BITMAP_BIT(__n, __v))
#define __BITMAP_CLR(__n, __v)   ((__v)->_b[__BITMAP_WORD(__n, __v)] &= ~__BITMAP_BIT(__n, __v))
#define __BITMAP_ISSET(__n, __v)   ((__v)->_b[__BITMAP_WORD(__n, __v)] & __BITMAP_BIT(__n, __v))
#define __BITMAP_ZERO(__v)   do { register size_t __i; for (__i = 0; __i < __arraycount(__v->_b); __i++) { (__v)->_b[__i] = 0; } } while (0x0)


LIB_FUNC unsigned long count_free(char* restrict map, const unsigned int numchars) {
	if (!map) { return 0; }
	register unsigned int i = 0;
	register unsigned long sum = 0;
	for (; i < numchars; i++) {
		sum += (unsigned long)(nibblemap[map[i] & 0xf] + nibblemap[(map[i] >> 4) & 0xf]);
	}
	return sum;
}


LIB_FUNC int constant_test_bit(const int nr, const volatile void* addr) {
	return ((1UL << (nr & 31)) & (((const volatile unsigned int*) addr)[nr >> 5])) != 0;
}


#if (defined(X86) || defined(X86_64))  // clear_bit() and set_bit()


/** Atomically set a bit in memory
@nr: the bit to set
@addr: the address to start counting from
*/
LIB_FUNC void set_bit(int nr, volatile void* addr) {
	asm volatile (";" "btsl %1, %0;" : "=m"((*(volatile long*)addr)) : "dIr"(nr) : "memory");
}


/** Set a bit in memory
@nr: the bit to set
@addr: the address to start counting from
*/
LIB_FUNC void __set_bit(int nr, volatile void* addr) {
	asm volatile ("btsl %1, %0;" : "=m"((*(volatile long*)addr)) : "dIr"(nr) : "memory");
}


/** Clears a bit in memory
@nr: Bit to clear
@addr: Address to start counting from
*/
LIB_FUNC void clear_bit(int nr, volatile void* addr) {
	asm volatile (";" "btrl %1, %0;" : "=m"((*(volatile long*)addr)) : "dIr"(nr));
}


LIB_FUNC void __clear_bit(int nr, volatile void* addr) {
	asm volatile ("btrl %1, %0;" : "=m"((*(volatile long*)addr)) : "dIr"(nr));
}


LIB_FUNC int variable_test_bit(int nr, volatile void* addr) {
	int oldbit;
	asm volatile ("btl %2,%1;" "sbbl %0, %0;" : "=r"(oldbit) : "m"((*(volatile long*)addr)), "dIr"(nr));
	return oldbit;
}


/** Toggle a bit in memory
@nr: the bit to change
@addr: the address to start counting from
*/
LIB_FUNC void __change_bit(long nr, volatile unsigned long* addr) {
	asm volatile ("btc %1, %0;" : "+m"(*(volatile long*)(addr)) : "Ir"(nr));
}


/** Atomically toggle a bit in memory
@nr: Bit to change
@addr: Address to start counting from
*/
LIB_FUNC void change_bit(long nr, volatile unsigned long* addr) {
	if ((__builtin_constant_p(nr))) {
		asm volatile(";" "xorb %1, %0;" : "+m"(*(volatile long*)((volatile long*)(addr) + ((nr) >> 3))) : "iq"((uint8_t)(1 << ((nr) & 7))));
	} else {
		asm volatile(";" "btc %1, %0;" : "+m"(*(volatile long*)(addr)) : "Ir"(nr));
	}
}


#else
#   error   "clear_bit() and set_bit() are not supported by the target platform!"
#endif


/** Clears a bit in memory
@nr: Bit to clear
@addr: Address to start counting from
*/
LIB_FUNC void clear_bit_unlock(int nr, volatile void* addr) {
	barrier();
	clear_bit((int)nr, addr);
}


#define test_bit(nr, addr)   (__builtin_constant_p(nr) ? constant_test_bit((nr), (addr)) : variable_test_bit((nr), (addr)))


/** Clear a bit and return its old value
@nr: Bit to clear
@addr: Address to count from
*/
LIB_FUNC int test_and_clear_bit(int nr, volatile unsigned long* addr) {
	clear_bit(nr, addr);
	return 1;
}


/** Set a bit and return its old value
@nr: Bit to set
@addr: Address to count from
*/
LIB_FUNC int test_and_set_bit(int nr, volatile unsigned long* addr) {
	set_bit(nr, addr);
	return 1;
}


/** Set a bit and return its old value for lock
@nr: Bit to set
@addr: Address to count from
*/
LIB_FUNC int test_and_set_bit_lock(long nr, volatile unsigned long* addr) {
	set_bit((int)nr, addr);
	return 1;
}


/** Set a bit and return its old value
@nr: Bit to set
@addr: Address to count from
*/
LIB_FUNC int __test_and_set_bit(long nr, volatile unsigned long* addr) {
	int oldbit;
	asm("bts %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long*)(addr)) : "Ir"(nr));
	return oldbit;
}


/** Clear a bit and return its old value
@nr: Bit to clear
@addr: Address to count from
*/
LIB_FUNC int __test_and_clear_bit(long nr, volatile unsigned long* addr) {
	int oldbit;
	asm volatile("btr %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long *)(addr)) : "Ir"(nr));
	return oldbit;
}


LIB_FUNC int __test_and_change_bit(long nr, volatile unsigned long* addr) {
	int oldbit;
	asm volatile("btc %2, %1;" "sbb %0, %0;" : "=r"(oldbit), "+m"(*(volatile long *)(addr)) : "Ir"(nr) : "memory");
	return oldbit;
}


/** Find the first zero bit in a bit string of `size` bits, starting the search at bit `offset` */
LIB_FUNC unsigned long find_next_zero_bit(const void* restrict addr, unsigned long size, unsigned long offset) {
	if (offset >= size) { return size; }
	const unsigned long* p = (((const unsigned long*)addr) + (offset >> 5));
	unsigned long result = offset & (~31UL);
	unsigned long tmp;
	size -= result;
	offset &= 31UL;
	if (offset) {
			tmp = *(p++);
			tmp |= ((~0UL) >> (32 - offset));
			if (size < 32) {
				tmp |= ((~0UL) << size);
				if (!(~tmp)) { return result + size; }
				return result + (unsigned long)ffz(tmp);
			}
			else if (~tmp) { return result + (unsigned long)ffz(tmp); }
			size -= 32;
			result += 32;
	}
	while (size & ~31UL) {
		if (~(tmp = *(p++))) { return result + (unsigned long)ffz(tmp); }
		result += 32;
		size -= 32;
	}
	if (!size) { return result; }
	tmp = *p;
	tmp |= ((~0UL) << size);
	if (!(~tmp)) { return result + size; }
	return result + (unsigned long)ffz(tmp);
}


LIB_FUNC int find_first_zero_bit(const void* restrict buf, unsigned int len) {
	return (int)find_next_zero_bit(buf, (unsigned long)len, 0);
}


#ifdef X86_64
LIB_FUNC long find_next_bit(const unsigned long* addr, long size, long offset) {
	const unsigned long* p = addr + (offset >> 6);
	register unsigned long set = 0, res = 0;
	register unsigned long bit = (unsigned long)((unsigned long)offset & 63);
	if (bit) {
		asm volatile ("bsfq %1, %0;" "cmoveq %2, %0;" : "=r"(set) : "r"((*p >> bit)), "r"(64L));
		if (set < (64 - bit)) { return ((long)set + offset); }
		set = 64 - bit;
		p++;
	}
	res = (unsigned long)find_next_bit(p, (size - 64 * (p - addr)), 0);
	return offset + (long)set + (long)res;
}
#elif defined(X86)
LIB_FUNC int find_next_bit(const unsigned long* addr, int size, int offset) {
	const unsigned long* p = (addr + (offset >> 5));
	register int set = 0, res = 0;
	register int bit = offset & 31;
	if (bit) {
		asm volatile ("bsfl %1, %0;" "jne 1f;" "movl $32, %0;" "1:" : "=r"(set) : "r"(*p >> bit));
		if (set < (32 - bit)) { return set + offset; }
		set = 32 - bit;
		p++;
	}
	res = find_next_bit(p, (size - 32 * (p - addr)), 0);
	return offset + set + res;
}
#else
#   error   "find_next_bit() is not supported by the target platform!"
#endif


#define find_first_bit(addr, size)   find_next_bit((addr), (size), 0)
#define for_each_bit(bit, addr, size)   for ((bit) = find_first_bit((addr), (size)); (bit) < (size); (bit) = find_next_bit((addr), (size), (bit) + 1))


#if LITTLE_ENDIAN


#   define BITOP_LE_SWIZZLE   0


LIB_FUNC unsigned long find_next_zero_bit_le(const void* restrict addr, unsigned long size, unsigned long offset) {
	return find_next_zero_bit(addr, size, offset);
}


#ifdef X86_64
LIB_FUNC unsigned long find_next_bit_le(const void* restrict addr, unsigned long size, unsigned long offset) {
	return (unsigned long)find_next_bit(addr, (long)size, (long)offset);
}
#elif defined(X86)
LIB_FUNC unsigned int find_next_bit_le(const void* restrict addr, unsigned int size, unsigned int offset) {
	return (unsigned int)find_next_bit(addr, (int)size, (int)offset);
}
#endif


LIB_FUNC unsigned long find_first_zero_bit_le(const void* restrict addr, unsigned long size) {
	return (unsigned long)find_first_zero_bit(addr, (unsigned int)size);
}


#elif BIG_ENDIAN


#   define BITOP_LE_SWIZZLE   ((BITS_PER_LONG - 1) & (~0x7))


LIB_FUNC unsigned long ext2_swab(const unsigned long y) {
#   if (BITS_PER_LONG == 64)
	return (unsigned long)bswap64((uint64_t)y);
#   elif (BITS_PER_LONG == 32)
	return (unsigned long)bswap32((uint32_t)y);
#   else
#      error   "BITS_PER_LONG is not defined!"
#   endif
}


#if ((!defined(find_next_bit_le)) || (!defined(find_next_zero_bit_le)))
LIB_FUNC unsigned long _find_next_bit_le(const unsigned long* restrict addr, unsigned long nbits, unsigned long start, unsigned long invert) {
	unsigned long tmp;
	if ((!nbits) || (start >= nbits)) { return nbits; }
	tmp = (addr[start / BITS_PER_LONG] ^ invert);
	/* Handle 1st word */
	tmp &= ext2_swab(BITMAP_FIRST_WORD_MASK(start));
	start = round_down(start, BITS_PER_LONG);
	while (!tmp) {
		start += BITS_PER_LONG;
		if (start >= nbits) { return nbits; }
		tmp = (addr[start / BITS_PER_LONG] ^ invert);
	}
	return (unsigned long)min((start + ffs(ext2_swab(tmp))), nbits);
}
#   define find_next_bit_le(addr, nbits, start, invert)   _find_next_bit_le((addr), (nbits), (start), (invert))
#endif


#ifndef find_next_zero_bit_le
LIB_FUNC unsigned long find_next_zero_bit_le(const void* restrict addr, unsigned long size, unsigned long offset) {
	return _find_next_bit_le(addr, size, offset, (~0UL));
}
#endif


#ifndef find_next_bit_le
LIB_FUNC unsigned long find_next_bit_le(const void* restrict addr, unsigned long size, unsigned long offset) {
	return _find_next_bit_le(addr, size, offset, 0UL);
}
#endif


#ifndef find_first_zero_bit_le
#   define find_first_zero_bit_le(addr, size)   find_next_zero_bit_le((addr), (size), 0)
#endif


#endif


LIB_FUNC int test_bit_le(int nr, void* addr) {
	return test_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC void set_bit_le(int nr, volatile void* addr) {
	set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC void clear_bit_le(int nr, volatile void* addr) {
	clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC void __set_bit_le(int nr, volatile void* addr) {
	__set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC void __clear_bit_le(int nr, volatile void* addr) {
	__clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int test_and_set_bit_le(int nr, volatile void* addr) {
	return test_and_set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int test_and_clear_bit_le(int nr, volatile void* addr) {
	return test_and_clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int __test_and_set_bit_le(int nr, volatile void* addr) {
	return __test_and_set_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


LIB_FUNC int __test_and_clear_bit_le(int nr, volatile void* addr) {
	return __test_and_clear_bit((nr ^ BITOP_LE_SWIZZLE), addr);
}


#define prefetch(addr, ...)   __builtin_prefetch((addr), __VA_ARGS__)


LIB_FUNC void xor_8regs_2(const unsigned long bytes, unsigned long* p1, unsigned long* p2) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	do {
		p1[0] ^= p2[0];
		p1[1] ^= p2[1];
		p1[2] ^= p2[2];
		p1[3] ^= p2[3];
		p1[4] ^= p2[4];
		p1[5] ^= p2[5];
		p1[6] ^= p2[6];
		p1[7] ^= p2[7];
		p1 += 8;
		p2 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_3(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0];
		p1[1] ^= p2[1] ^ p3[1];
		p1[2] ^= p2[2] ^ p3[2];
		p1[3] ^= p2[3] ^ p3[3];
		p1[4] ^= p2[4] ^ p3[4];
		p1[5] ^= p2[5] ^ p3[5];
		p1[6] ^= p2[6] ^ p3[6];
		p1[7] ^= p2[7] ^ p3[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_4(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3, unsigned long* p4) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0] ^ p4[0];
		p1[1] ^= p2[1] ^ p3[1] ^ p4[1];
		p1[2] ^= p2[2] ^ p3[2] ^ p4[2];
		p1[3] ^= p2[3] ^ p3[3] ^ p4[3];
		p1[4] ^= p2[4] ^ p3[4] ^ p4[4];
		p1[5] ^= p2[5] ^ p3[5] ^ p4[5];
		p1[6] ^= p2[6] ^ p3[6] ^ p4[6];
		p1[7] ^= p2[7] ^ p3[7] ^ p4[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_8regs_5(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3, unsigned long* p4, unsigned long* p5) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	do {
		p1[0] ^= p2[0] ^ p3[0] ^ p4[0] ^ p5[0];
		p1[1] ^= p2[1] ^ p3[1] ^ p4[1] ^ p5[1];
		p1[2] ^= p2[2] ^ p3[2] ^ p4[2] ^ p5[2];
		p1[3] ^= p2[3] ^ p3[3] ^ p4[3] ^ p5[3];
		p1[4] ^= p2[4] ^ p3[4] ^ p4[4] ^ p5[4];
		p1[5] ^= p2[5] ^ p3[5] ^ p4[5] ^ p5[5];
		p1[6] ^= p2[6] ^ p3[6] ^ p4[6] ^ p5[6];
		p1[7] ^= p2[7] ^ p3[7] ^ p4[7] ^ p5[7];
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
		p5 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_2(const unsigned long bytes, unsigned long* p1, unsigned long* p2) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	register unsigned long d0, d1, d2, d3, d4, d5, d6, d7;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_3(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	register unsigned long d0, d1, d2, d3, d4, d5, d6, d7;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_4(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3, unsigned long* p4) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	register unsigned long d0, d1, d2, d3, d4, d5, d6, d7;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		d0 ^= p4[0];
		d1 ^= p4[1];
		d2 ^= p4[2];
		d3 ^= p4[3];
		d4 ^= p4[4];
		d5 ^= p4[5];
		d6 ^= p4[6];
		d7 ^= p4[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
	} while (--lines > 0);
}


LIB_FUNC void xor_32regs_5(const unsigned long bytes, unsigned long* p1, unsigned long* p2, unsigned long* p3, unsigned long* p4, unsigned long* p5) {
	register long lines = (long)(bytes / SIZEOF_LONG / 8);
	register unsigned long d0, d1, d2, d3, d4, d5, d6, d7;
	do {
		d0 = p1[0];
		d1 = p1[1];
		d2 = p1[2];
		d3 = p1[3];
		d4 = p1[4];
		d5 = p1[5];
		d6 = p1[6];
		d7 = p1[7];
		d0 ^= p2[0];
		d1 ^= p2[1];
		d2 ^= p2[2];
		d3 ^= p2[3];
		d4 ^= p2[4];
		d5 ^= p2[5];
		d6 ^= p2[6];
		d7 ^= p2[7];
		d0 ^= p3[0];
		d1 ^= p3[1];
		d2 ^= p3[2];
		d3 ^= p3[3];
		d4 ^= p3[4];
		d5 ^= p3[5];
		d6 ^= p3[6];
		d7 ^= p3[7];
		d0 ^= p4[0];
		d1 ^= p4[1];
		d2 ^= p4[2];
		d3 ^= p4[3];
		d4 ^= p4[4];
		d5 ^= p4[5];
		d6 ^= p4[6];
		d7 ^= p4[7];
		d0 ^= p5[0];
		d1 ^= p5[1];
		d2 ^= p5[2];
		d3 ^= p5[3];
		d4 ^= p5[4];
		d5 ^= p5[5];
		d6 ^= p5[6];
		d7 ^= p5[7];
		p1[0] = d0;
		p1[1] = d1;
		p1[2] = d2;
		p1[3] = d3;
		p1[4] = d4;
		p1[5] = d5;
		p1[6] = d6;
		p1[7] = d7;
		p1 += 8;
		p2 += 8;
		p3 += 8;
		p4 += 8;
		p5 += 8;
	} while (--lines > 0);
}


// MEMORY & STRING MANIPULATIONS


#if IS_LITTLE_ENDIAN
/** Return first character */
#   define GFC(x)   ((x) & 0xff)
/** Move to next character */
#   define INCSTR(x)   do { (x) >>= 8; } while (0x0)
#else
/** Return first character */
#   define GFC(x)   (((x) >> (sizeof(x) * 8 - 8)) & 0xff)
/** Move to next character */
#   define INCSTR(x)   do { (x) <<= 8; } while (0x0)
#endif
#if IS_WORDSIZE_64
#   define MKW(x)   (x | x << 8 | x << 16 | x << 24 | x << 32 | x << 40 | x << 48 | x << 56)
#   define STRALIGN(x)   (((unsigned long)x & 7) ? 8 - ((unsigned long)x & 7) : 0)
#else
#   define MKW(x)   (x | x << 8 | x << 16 | x << 24)
#   define STRALIGN(x)   (((unsigned long)x & 3) ? 4 - ((unsigned long)x & 3) : 0)
#endif


/** Copy block of memory; Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination */
LIB_FUNC void* memcpy(void* restrict dest, const void* restrict src, const size_t n) {
	if (n != 0) {
		char* s1 = dest;
		const char* s2 = src;
		register size_t i = n;
		do { *s1++ = *s2++; } while (--i != 0);
	}
	return dest;
}
#define COPY(n)   (void)memcpy((void*)fp->_p, (void*)p, (size_t)(n))


/** Copy block of memory; Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination; No value is returned */
LIB_FUNC void memcpy_no_output(void* restrict dest, const void* restrict src, const size_t n) {
	if (n != 0) {
		char* s1 = dest;
		const char* s2 = src;
		register size_t i = n;
		do { *s1++ = *s2++; } while (--i != 0);
	}
}


/** Copy memory to memory until the specified number of bytes has been copied; return pointer to following byte */
LIB_FUNC void* mempcpy(void* restrict dest, const void* restrict src, const size_t len) {
	return (void*)((size_t*)memcpy(dest, src, len) + len);
}
#define __mempcpy(dest, src, len)   mempcpy((dest), (src), (len))
#define MEMPCPY(dest, src, len)   mempcpy((dest), (src), (len))


/** Return the length of a string */
LIB_FUNC size_t strlen(const char* restrict str) {
	register const char* s;
	for (s = str; *s; ++s);
	return (size_t)(s - str);
}
#define __strlen(_str)   strlen((_str))
#define _strlen(_str)   strlen((_str))
#define strlenx(_str)   strlen((_str))


/** Return the length of an unsigned string */
LIB_FUNC size_t ustrlen(const unsigned char* restrict str) {
	register const unsigned char* s;
	for (s = str; *s; ++s);
	return (size_t)(s - str);
}
#define __ustrlen(_str)   ustrlen((_str))
#define _ustrlen(_str)   ustrlen((_str))
#define ustrlenx(_str)   ustrlen((_str))


LIB_FUNC size_t strnlen(const char* restrict s, const size_t maxlen) {
	register const char* ss = s;
	register size_t len = maxlen;
	while ((len > 0) && *ss) { ++ss; --len; }
	return (size_t)(ss - s);
}


LIB_FUNC size_t ustrnlen(const unsigned char* restrict s, const size_t maxlen) {
	register const unsigned char* ss = s;
	register size_t len = maxlen;
	while ((len > 0) && *ss) { ++ss; --len; }
	return (size_t)(ss - s);
}


#ifndef INTTYPE_FUNCTIONS
#define INTTYPE_FUNCTIONS   (1)


/** Return the absolute value; Accepts and returns intmax_t */
#define imaxabs(num)   ((intmax_t)((((intmax_t)(num)) < (intmax_t)0) ? (-(num)) : (num)))
/** Return the absolute value; Accepts and returns intmax_t */
#define __imaxabs(num)   imaxabs((num))
/** Return the absolute value of a long */
#define labs(num)   (long)((num > 0L) ? num : (-(num)))
/** Return the absolute value of a long */
#define __labs(num)   labs((num))
/** Return the absolute value of a long long */
#define llabs(num)   (long long)((num > 0LL) ? num : (-(num)))
/** Return the absolute value of a long long */
#define __llabs(num)   llabs((num))


/** Return the `imaxdiv_t` representation of the value of NUMER over DENOM */
LIB_FUNC imaxdiv_t imaxdiv(const intmax_t __numer, const intmax_t __denom) {
	return (imaxdiv_t) { (__numer / __denom), (__numer % __denom) };
}
#define imaxdiv_r(__numer, __denom)   imaxdiv((__numer), (__denom))


LIB_FUNC short_div_t short_div(const short num, const short den) {
	return (short_div_t) { (short)(num / den), (short)(num % den) };
}
#define short_div_r(__numer, __denom)   short_div((__numer), (__denom))


LIB_FUNC div_t div(const int num, const int den) {
	return (div_t) { (int)(num / den), (int)(num % den) };
}
#define div_r(__numer, __denom)   div((__numer), (__denom))


LIB_FUNC ldiv_t ldiv(const long num, const long den) {
	return (ldiv_t) { (long)(num / den), (long)(num % den) };
}
#define ldiv_r(__numer, __denom)   ldiv((__numer), (__denom))


LIB_FUNC lldiv_t lldiv(const long long num, const long long den) {
	return (lldiv_t) { (long long)(num / den), (long long)(num % den) };
}
#define lldiv_r(__numer, __denom)   lldiv((__numer), (__denom))


LIB_FUNC div8_t div8(const int8_t num, const int8_t den) {
	return (div8_t) { (int8_t)(num / den), (int8_t)(num % den) };
}


LIB_FUNC div16_t div16(const int16_t num, const int16_t den) {
	return (div16_t) { (int16_t)(num / den), (int16_t)(num % den) };
}


LIB_FUNC div32_t div32(const int32_t num, const int32_t den) {
	return (div32_t) { (num / den), (num % den) };
}


LIB_FUNC div64_t div64(const int64_t num, const int64_t den) {
	return (div64_t) { (num / den), (num % den) };
}


#if SUPPORTS_INT128
LIB_FUNC div128_t div128(const int128_t num, const int128_t den) {
	return (div128_t) { (num / den), (num % den) };
}
#endif


/** Use a 16-bit integer as a fraction; The numerator & denominator are each 8-bits */
#define MAKEFRACTION16(num, den)   ((((num) & 0xFF) << 8) | ((den) & 0xFF))
#define MAKE_FRACTION16(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR16(x)   ((x) & 0xFF)
#define GET_NUMERATOR16(x)   (((x) >> 8) & 0xFF)
/** Use a 32-bit integer as a fraction; The numerator & denominator are each 16-bits */
#define MAKEFRACTION32(num, den)   ((((num) & 0xFFFF) << 16) | ((den) & 0xFFFF))
#define MAKE_FRACTION32(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR32(x)   ((x) & 0xFFFF)
#define GET_NUMERATOR32(x)   (((x) >> 16) & 0xFFFF)
/** Use a 64-bit integer as a fraction; The numerator & denominator are each 32-bits */
#define MAKEFRACTION64(num, den)   ((((num) & 0xFFFFFFFF) << 32) | ((den) & 0xFFFFFFFF))
#define MAKE_FRACTION64(num, den)   MAKEFRACTION((num), (den))
#define GET_DENOMINATOR64(x)   ((x) & 0xFFFFFFFF)
#define GET_NUMERATOR64(x)   (((x) >> 32) & 0xFFFFFFFF)


/** Convert from 'int' to 'double', then from 'double' to 'long double' */
LIB_FUNC void _Qp_itoq(long double* result, const int a) {
	*result = (double)a;
	return;
}


LIB_FUNC size_t three_way_max(const size_t x, const size_t y, const size_t z) {
	if (x >= y && x >= z) { return x; }
	else if (y >= z) { return y; }
	return z;
}


LIB_FUNC size_t three_way_min(const size_t x, const size_t y, const size_t z) {
	if (x <= y && x <= z) { return x; }
	else if (y <= z) { return y; }
	return z;
}


LIB_FUNC size_t four_way_max(const size_t x, const size_t y, const size_t z, const size_t w) {
	if (x >= y && x >= z) { return ((x >= w) ? x : w); }
	else if (y >= z && y >= w) { return y; }
	else if (z >= w) { return z; }
	return w;
}


LIB_FUNC size_t four_way_min(const size_t x, const size_t y, const size_t z, const size_t w) {
	if (x <= y && x <= z) { return ((x <= w) ? x : w); }
	else if (y <= z && y <= w) { return y; }
	else if (z <= w) { return z; }
	return w;
}


#endif  // INTTYPE_FUNCTIONS


/** Converts str to all uppercase */
LIB_FUNC char* strupr(char* str) {
	char* ret = str;
	while ((*str = (char)toupper(*str))) { ++str; }
	return ret;
}


/** Converts str to all lowercase */
LIB_FUNC char* strlwr(char* str) {
	char* ret = str;
	while ((*str = (char)tolower(*str))) { ++str; }
	return ret;
}


/** Compare two blocks of memory; Compares the first num bytes of the block of memory pointed by ptr1 to the first num bytes pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not */
LIB_FUNC int memcmp(const void* restrict ptr1, const void* restrict ptr2, const size_t _num) {
	const unsigned char *l = ptr1, *r = ptr2;
	register size_t num = _num;
	for (; num && (*l == *r); num--, l++, r++);
	return (int)(num ? (*l - *r) : 0);
}


LIB_FUNC int memcmp16(const unsigned short* ptr1, const unsigned short* ptr2, const size_t n) {
	register size_t i;
	for (i = 0; i < n; i++) {
		if (*ptr1 != *ptr2) { return *ptr1 - *ptr2; }
		++ptr1;
		++ptr2;
	}
	return 0;
}
#define __memcmp16(ptr1, ptr2, len)   memcmp16((ptr1), (ptr2), (len))


LIB_FUNC int consttime_memequal(const void* b1, const void* b2, size_t len) {
	const char *c1 = b1, *c2 = b2;
	register int res = 0;
	while (len--) { res |= *c1++ ^ *c2++; }
	return (int)(!res);
}


/** Copy block of memory; Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination */
LIB_FUNC void* memccpy(void* restrict dest, const void* restrict src, const int c, const size_t len) {
	register size_t n = len;
	char *q = dest, ch;
	const char* p = src;
	while (--n) {
		*q++ = ch = *p++;
		if (ch == (char)c) { return q; }
	}
	return NULL;
}


/** Copies the values of `len` bytes from the location pointed by `src` to the memory block pointed by `dst`; Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap */
LIB_FUNC NONNULL void* memmove(void* dst, const void* src, const size_t len) {
	const char* p = src;
	char* q = dst;
	register size_t n = len;
#   if (defined(I386) || defined(X86_64) || defined(X86))
	if (q < p) {
		asm volatile ("cld;" "rep;" "movsb;" : "+c"(n), "+S"(p), "+D"(q));
	} else {
		p += (n - 1);
		q += (n - 1);
		asm volatile ("std;" "rep;" "movsb;" "cld;" : "+c"(n), "+S"(p), "+D"(q));
	}
#   else
	if (q < p) { while (n--) { *q++ = *p++; } }
	else {
		p += n;
		q += n;
		while (--n) { *--q = *--p; }
	}
#   endif
	return dst;
}
#define COPYSTRING(dest, source, srclen)   ((void*)memmove((void*)(dest), (const void*)(source), (size_t)((size_t)(srclen) + 1)))
#define CONCATSTRING(dest, source, dstlen, srclen)   ((void*)memmove((void*)((dest) + (dstlen)), (const void*)(source), (size_t)((size_t)(srclen) + 1)))


LIB_FUNC int copystring(char* buf, const int maxlen, const char* s) {
	register int i;
	for (i = 0; i < 3 && i < maxlen; ++i) { buf[i] = s[i]; }
	if (i < maxlen) { buf[i] = 0; ++i; }
	return i;
}


/** Sets the first num bytes of the block of memory pointed by dst to the specified value (interpreted as an unsigned char) */
LIB_FUNC void* memset(void* restrict dst, const int c, const size_t len) {
	char* q = dst;
	register size_t n = len;
#   ifdef X86_64
	size_t nq = (len >> 3);
	asm volatile ("cld;" "rep;" "stosq;" "movl %3, %%ecx;" "rep;" "stosb;" : "+c"(nq), "+D"(q) : "a"((unsigned char)c * 0x101010101010101U), "r"((uint32_t)(n & 7)));
#   elif (defined(I386) || defined(X86))
	size_t nl = (len >> 2);
	asm volatile ("cld;" "rep;" "stosl;" "movl %3, %0;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x1010101U), "r"(n & 3));
#   else
	while (n--) { *q++ = c; }
#endif
	return dst;
}


/** Fill the selected memory area with zeros */
#define ZERO_FILL(x)   memset(&(x), 0, sizeof((x)))
/** Fill the selected memory area with zeros */
#define ZEROFILL(x)   ZERO_FILL((x))
/** Fill the selected memory area with zeros */
#define zero_fill(x)   ZERO_FILL((x))
#define memzero(s, n)   memset(s, 0, n)
/** Sets the first x bytes of the area starting at the specified address to zero */
#define bzero(addr, length)   memset((addr), 0, (length))
/** Sets the first x bytes of the area starting at the specified address to zero */
#define explicit_bzero(addr, length)   bzero((addr), (length))


/** Sets the first num bytes of the block of memory pointed by dst to the specified value (interpreted as an unsigned char); no value is returned */
LIB_FUNC void memset_no_output(void* restrict dst, const int c, const size_t len) {
	char* q = dst;
	register size_t n = len;
#   ifdef X86_64
	size_t nq = (len >> 3);
	asm volatile ("cld;" "rep;" "stosq;" "movl %3, %%ecx;" "rep;" "stosb;" : "+c"(nq), "+D"(q) : "a"((unsigned char)c * 0x101010101010101U), "r"((uint32_t)(n & 7)));
#   elif (defined(I386) || defined(X86))
	size_t nl = (len >> 2);
	asm volatile ("cld;" "rep;" "stosl;" "movl %3, %0;" "rep;" "stosb;" : "+c"(nl), "+D"(q) : "a"((unsigned char)c * 0x1010101U), "r"(n & 3));
#   else
	while (n--) { *q++ = c; }
#endif
}


LIB_FUNC NONNULL void* memset2(void* ap, const int c, const unsigned long len) {
	char* p = ap;
	register long m = (long)len;
	while (m > 0) { *p++ = (char)c; --m; }
	return ap;
}


/** Searches within the first num bytes of the block of memory pointed by ptr for the first occurrence of value (interpreted as an unsigned char), and returns a pointer to it */
LIB_FUNC const void* memchr(const void* src, const int x, const size_t len) {
	const unsigned char* s = src;
	register unsigned char c = (unsigned char)x;
	register size_t n = len;
	for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*s != c); s++, n--);
	if (n && (*s != c)) {
		const size_t* w;
		register size_t k = (((size_t)(-1) / UCHAR_MAX) * c);
		for (w = (const size_t*)s; (n >= SIZEOF_SIZE_T) && (!(HASZERO((*w ^ k)))); ++w, n -= SIZEOF_SIZE_T);
		for (s = (const void*)w; n && (*s != c); ++s, --n);
	}
	return (const void*)(n ? s : 0);
}


/** Searches within the first num bytes of the block of memory pointed by ptr for the first occurrence of value (interpreted as an unsigned char), and returns a pointer to it */
LIB_FUNC void* memchr_nonconst(void* src, const int x, const size_t len) {
	unsigned char* s = src;
	register unsigned char c = (unsigned char)x;
	register size_t n = len;
	for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*s != c); s++, n--);
	if (n && (*s != c)) {
		size_t* w;
		register size_t k = (((size_t)(-1) / UCHAR_MAX) * c);
		for (w = (size_t*)s; (n >= SIZEOF_SIZE_T) && (!(HASZERO((*w ^ k)))); ++w, n -= SIZEOF_SIZE_T);
		for (s = (void*)w; n && (*s != c); ++s, --n);
	}
	return (void*)(n ? s : 0);
}


/** Returns a pointer to the first occurrence of `CH` in the buffer `BUF` of len, or `BUF + LEN` if `CH` does not occur */
LIB_FUNC void* memscan(void* buf, const unsigned char ch, const size_t len) {
	void* x = memchr_nonconst(buf, ch, len);
	return (void*)(x ? x : ((size_t*)buf + len));
}


LIB_FUNC const void* rawmemchr(const void* s, const int c) {
	const unsigned char* m = s;
	const unsigned char ch = (unsigned char)c;
	while (*m != ch) { ++m; }
	return m;
}


LIB_FUNC const void* memrchr(const void* src, const int x, const size_t len) {
	const unsigned char* s = src;
	register const unsigned char c = (unsigned char)x;
	register size_t n = len;
	while (n--) { if (s[n] == c) { return (const void*)(s + n); } }
	return (const void*)0;
}
#define _memrchr(src, x, len)   memrchr((src), (x), (len))
#define __memrchr(src, x, len)   memrchr((src), (x), (len))


/** Emulate the VAX cmpc3 instruction (Compare Character 3) */
LIB_FUNC int bcmp(const void* b1, const void* b2, register size_t length) {
	const char *p1 = b1, *p2 = b2;
	if (b1 == 0 || b2 == 0) { return -1; }
	else if (length == 0) { return 0; }
	do { if (*p1++ != *p2++) { break; } } while (--length);
	return (int)(length != 0);
}


/** Copies n bytes from src to dest; Both areas are allowed to overlap */
LIB_FUNC void bcopy(const void* restrict src, void* dest, register size_t length) {
	const char* f = src;
	char* t = dest;
	while (length-- > 0) { *t++ = *f++; }
	return;
}


LIB_FUNC int timingsafe_bcmp(const void* b1, const void* b2, const size_t len) {
	const unsigned char *p1 = b1, *p2 = b2;
	register int ret = 0;
	register size_t n = len;
	for (; n > 0; n--) { ret |= ((*p1++) ^ (*p2++)); }
	return (ret != 0);
}


LIB_FUNC int timingsafe_memcmp(const void* b1, const void* b2, const size_t len) {
	const unsigned char *p1 = b1, *p2 = b2;
	register size_t i;
	register int res = 0, done = 0, lt, gt, cmp;
	for (i = 0; i < len; i++) {
		// lt is -1 if p1[i] < p2[i]; else 0
		lt = (int)((p1[i] - p2[i]) >> CHAR_BIT);
		// gt is -1 if p1[i] > p2[i]; else 0
		gt = (int)((p2[i] - p1[i]) >> CHAR_BIT);
		// cmp is 1 if p1[i] > p2[i]; -1 if p1[i] < p2[i]; else 0
		cmp = (int)(lt - gt);
		// set res = cmp if !done
		res |= (int)(cmp & (~done));
		// set done if p1[i] != p2[i]
		done |= (int)(lt | gt);
	}
	return (int)res;
}


LIB_FUNC const char* twobyte_memmem(const unsigned char* h, size_t k, const unsigned char* restrict n) {
	const uint16_t nw = (uint16_t)(n[0] << 8 | n[1]);
	register uint16_t hw = (uint16_t)(h[0] << 8 | h[1]);
	for (h++, k--; k; --k, (hw = (uint16_t)((hw << 8) | *++h))) { if (hw == nw) { return (const char*)((const char*)h - 1); } }
	return 0;
}


LIB_FUNC const char* threebyte_memmem(const unsigned char* h, size_t k, const unsigned char* restrict n) {
	const uint32_t nw = (uint32_t)((n[0] << 24) | (n[1] << 16) | (n[2] << 8));
	register uint32_t hw = (uint32_t)((h[0] << 24) | (h[1] << 16) | (h[2] << 8));
	for (h += 2, k -= 2; k; k--, hw = (uint32_t)((hw | *++h) << 8)) { if (hw == nw) { return (const char*)((const char*)h - 2); } }
	return 0;
}


LIB_FUNC const char* fourbyte_memmem(const unsigned char* h, size_t k, const unsigned char* restrict n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3]);
	register uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3]);
	for (h += 3, k -= 3; k; k--, hw = (uint32_t)(hw << 8 | *++h)) {
		if (hw == nw) { return (const char*)((const char*)h - 3); }
	}
	return 0;
}


LIB_FUNC const char* twoway_memmem(const unsigned char* h, const unsigned char* z, const unsigned char* n, size_t l) {
	size_t i, ip, jp, k, p, ms, p0, mem, mem0;
	size_t byteset[32 / SIZEOF_SIZE_T] = { 0 };
	size_t shift[256] = { 0 };
	for (i = 0; i < l; i++) {
		((byteset)[(size_t)(n[i]) / (8 * sizeof(*(byteset)))] |= (size_t)1 << ((size_t)(n[i]) % (8 * sizeof(*(byteset)))));
		shift[n[i]] = i + 1;
	}
	ip = (size_t)-1;
	jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] > n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	ms = ip;
	p0 = p;
	ip = (size_t)-1;
	jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] < n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip + 1 > ms + 1) { ms = ip; }
	else { p = p0; }
	if (memcmp(n, (n + p), (size_t)(ms + 1))) {
		mem0 = 0;
		p = MAX(ms, (l - ms - 1)) + 1;
	} else { mem0 = l - p; }
	mem = 0;
	for (;;) {  // Search loop
		if ((size_t)(z - h) < l) { return 0; }  // If remainder of haystack is shorter than needle, done
		else if (((byteset)[(size_t)(h[l - 1]) / (8 * sizeof(*(byteset)))] & (size_t)1 << ((size_t)(h[l - 1]) % (8 * sizeof(*(byteset)))))) {  // Check last byte first; advance by shift on mismatch
			k = l - shift[h[l - 1]];
			if (k) {
				if (mem0 && mem && k < p) { k = l - p; }
				h += k;
				mem = 0;
				continue;
			}
		} else {
			h += l;
			mem = 0;
			continue;
		}
		// Compare right half
		for (k = MAX((ms + 1), mem); k < l && n[k] == h[k]; k++);
		if (k < l) {
			h += k - ms;
			mem = 0;
			continue;
		}
		// Compare left half
		for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--);
		if (k <= mem) { return (const char*)h; }
		h += p;
		mem = mem0;
	}
}


LIB_FUNC const void* memmem(const void* h0, size_t k, const void* n0, size_t l) {
	const unsigned char *h = h0, *n = n0;
	if (!l) { return (const void*)h; }
	else if (k < l) { return 0; }
	h = memchr(h0, *n, k);
	if (!h || l==1) { return (const void*)h; }
	k -= (size_t)(h - (const unsigned char*)h0);
	if (l == 2) { return (const void*)twobyte_memmem(h, k, n); }
	else if (l == 3) { return (const void*)threebyte_memmem(h, k, n); }
	else if (l == 4) { return (const void*)fourbyte_memmem(h, k, n); }
	return (const void*)twoway_memmem(h, (h + k), n, l);
}


LIB_FUNC int cistrcmp(const char* restrict s1, const char* restrict s2) {
	register int c1, c2;
	while (*s1) {
		c1 = *(const unsigned char*)s1++;
		c2 = *(const unsigned char*)s2++;
		if (c1 == c2) { continue; }
		else if (c1 >= 'A' && c1 <= 'Z') { c1 -= ('A' - 'a'); }
		if (c2 >= 'A' && c2 <= 'Z') { c2 -= ('A' - 'a'); }
		if (c1 != c2) { return (int)(c1 - c2); }
	}
	return (int)(-(*s2));
}


/** Compare two strings; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC int strcmp(const char* restrict s1, const char* restrict s2) {
	register unsigned int c1, c2;
	for (;;) {
		c1 = (unsigned int)(*s1++);
		c2 = (unsigned int)(*s2++);
		if (c1 != c2) {
			if (c1 > c2) { return 1; }
			return -1;
		} else if (c1 == 0) { return 0; }
	}
	UNREACHABLE
}
#define equal(s1, s2)   (strcmp(s1, s2) == 0)
#define isstrequal(s1, s2)   (strcmp(s1, s2) == 0)
#define is_str_equal(s1, s2)   (strcmp(s1, s2) == 0)
#define is_same_str(s1, s2)   (strcmp(s1, s2) == 0)


/** Compare two unsigned strings; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC int ustrcmp(const unsigned char* restrict s1, const unsigned char* restrict s2) {
	register unsigned int c1, c2;
	for (;;) {
		c1 = (unsigned int)(*s1++);
		c2 = (unsigned int)(*s2++);
		if (c1 != c2) {
			if (c1 > c2) { return 1; }
			return -1;
		} else if (c1 == 0) { return 0; }
	}
	UNREACHABLE
}


/** Compare two strings case-insensitively; This function starts comparing the first character of each string; If they are equal to each other, it continues with the following pairs until the characters differ or until a terminating null-character is reached. */
LIB_FUNC int strcasecmp(const char* s1, const char* s2) {
	if ((s1 == NULL) || (s2 == NULL)) { return 0; }
	const unsigned char* us1 = (const unsigned char*)s1;
	const unsigned char* us2 = (const unsigned char*)s2;
	while (tolower(*us1) == tolower(*us2)) {
		++us2;
		if (*us1++ == '\0') { return 0; }
	}
	--us2;
	return (int)(tolower(*us1) - tolower((*us2)));
}
#define _stricmp(str1, str2)   strcasecmp((str1), (str2))  // Windows names string functions differently
#define stricmp(str1, str2)   strcasecmp((str1), (str2))  // Windows names string functions differently


LIB_FUNC int strcasecmp_l(const char* l, const char* r, UNUSED locale_t loc) {
	return strcasecmp(l, r);
}
#define __strcasecmp_l(l, r, loc)   strcasecmp_l((l), (r), (loc))


LIB_FUNC int strncasecmp(const char* s1, const char* s2, size_t n) {
	if ((s1 == NULL) || (s2 == NULL) || (n == 0)) { return 0; }
	if (n != 0) {
		const unsigned char* us1 = (const unsigned char*)s1;
		const unsigned char* us2 = (const unsigned char*)s2;
		do {
			if (tolower(*us1) != tolower(*us2)) {
				return (tolower(*us1) - tolower(*us2));
			} else if (*us1++ == '\0') { break; }
		} while (--n != 0);
	}
	return 0;
}
#define _strnicmp(str1, str2, length)   strncasecmp((str1), (str2), (length))  // Windows names string functions differently
#define strnicmp(str1, str2, length)   strncasecmp((str1), (str2), (length))  // Windows names string functions differently


LIB_FUNC int strncasecmp_l(const char* l, const char* r, size_t n, UNUSED locale_t loc) {
	return strncasecmp(l, r, n);
}
#define __strncasecmp_l(l, r, n, loc)   strncasecmp_l((l), (r), (n), (loc))


/** Compare strings according to LC_COLLATE category of current locale */
LIB_FUNC int strcoll(const char* s1, const char* s2, UNUSED locale_t _lang) {
	return strcmp(s1, s2);
}


LIB_FUNC int strncmp(const char* s1, const char* s2, const size_t len) {
	const unsigned char* c1 = (const unsigned char*)s1;
	const unsigned char* c2 = (const unsigned char*)s2;
	register unsigned char ch;
	register int d = 0;
	register size_t n = len;
	while (n--) {
		d = (int)(ch = *c1++) - ((int)*c2++);
		if (d || (!ch)) { break; }
	}
	return d;
}


/** Wrapper around strcmp for qsort and bsearch */
LIB_FUNC int pstrcmp(const void* s1, const void* s2) {
	return strcmp(*(const char *const*)s1, *(const char *const*)s2);
}


/** Normal */
#define S_N   0
/** Comparing integral part */
#define S_I   3
/** Comparing fractionnal parts */
#define S_F   6
/** idem but with leading Zeroes only */
#define S_Z   9
// Result types
/** CMP: return diff */
#define CMP   2
/** LEN: compare using len_diff/diff */
#define LEN   3


static const UNUSED uint8_t next_state[16] = {
	S_N, S_I, S_Z,  // S_N
	S_N, S_I, S_I,  // S_I
	S_N, S_F, S_F,  // S_F
	S_N, S_F, S_Z  // S_Z
};


static const UNUSED int8_t result_type[36] = {
	CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,  // S_N
	CMP, -1, -1, +1, LEN, LEN, +1, LEN, LEN,  // S_I
	CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,  // S_F
	CMP, +1, +1, -1, CMP, CMP, -1, CMP, CMP  // S_Z
};


/** Compare strings while treating digits characters numerically */
LIB_FUNC int strverscmp(const char* s1, const char* s2) {
	if (s1 == s2) { return 0; }
	const unsigned char* p1 = (const unsigned char*)s1;
	const unsigned char* p2 = (const unsigned char*)s2;
	unsigned char c1 = *p1++;
	unsigned char c2 = *p2++;
	int _state = (int)(S_N + ((c1 == '0') + (isdigit(c1) != 0)));
	register int diff;
	while ((diff = c1 - c2) == 0) {
		if (c1 == '\0') { return diff; }
		_state = next_state[_state];
		c1 = *p1++;
		c2 = *p2++;
		_state += (c1 == '0') + (isdigit(c1) != 0);
	}
	_state = result_type[_state * 3 + (((c2 == '0') + (isdigit(c2) != 0)))];
	switch (_state) {
		case CMP: return diff;
		case LEN:
			while (isdigit(*p1)) { ++p1; if (!(isdigit(*p2))) { return 1; } else { ++p2; } }
			return (isdigit(*p2) ? -1 : diff);
		default: return _state;
	}
}
#define __strverscmp(s1, s2)   strverscmp((s1), (s2))


/** Returns a pointer to the first occurrence of character in the C string str */
LIB_FUNC const char* strchr(const char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (const char*)(str - 1);
	}
	register char c1;
	while ((c1 = *str++)) { if (c1 == chr) { return (const char*)(str - 1); } }
	return (const char*)0;
}
/** Returns a pointer to the first occurrence of character in the C string str */
#define index(str, chr)   strchr((str), (chr))


/** Returns a pointer to the first occurrence of character in the C string str (non-constant output) */
LIB_FUNC char* strchr2(const char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (char*)(uintptr_t)(str - 1);
	}
	register char c1;
	while ((c1 = *str++)) { if (c1 == chr) { return (char*)(uintptr_t)(str - 1); } }
	return (char*)0;
}


/** Returns a pointer to the first occurrence of character in the C string str (non-constant) */
LIB_FUNC char* strchr_nc(char* restrict str, const int chr) {
	if (chr == 0) {
		while (*str++);
		return (char*)(str - 1);
	}
	register char c1;
	while ((c1 = *str++)) { if (c1 == chr) { return (char*)(str - 1); } }
	return (char*)0;
}


/** Returns a pointer to the last occurrence of character in the C string str */
LIB_FUNC const char* strrchr(const char* restrict str, const int chr) {
	if (chr == 0) { return (const char*)strchr(str, 0); }
	const char* r = 0;
	while ((str = strchr(str, chr))) { r = (const char*)(str++); }
	return (const char*)r;
}
/** Returns a pointer to the last occurrence of character in the C string str */
#define rindex(str, chr)   strrchr((str), (chr))


/** Return pointer to first occurrence of s2 in s1; Return 0 if none */
LIB_FUNC const char* strstr(const char* restrict s1, const char* restrict s2) {
	if (s2[0] == 0) { return s1; }
	register const int f = s2[0];
	register size_t n = strlen(s2);
	const char* p;
	for (p = (const char*)(strchr(s1, f)); p; p = (const char*)strchr((p + 1), f)) {
		if (strncmp(p, s2, n) == 0) { return p; }
	}
	return 0;
}


LIB_FUNC const char* twobyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint16_t nw = (uint16_t)((n[0] << 8) | n[1]);
	uint16_t hw = (uint16_t)((h[0] << 8) | h[1]);
	for (h++; *h && hw != nw; hw = (uint16_t)((hw << 8) | *++h));
	return (*h ? (const char*)h - 1 : 0);
}


LIB_FUNC const char* threebyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8);
	uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8);
	for (h += 2; *h && hw != nw; hw = (uint32_t)((hw | *++h) << 8));
	return (*h ? (const char*)h - 2 : 0);
}


LIB_FUNC const char* fourbyte_strstr(const unsigned char* h, const unsigned char* n) {
	const uint32_t nw = (uint32_t)(n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3]);
	uint32_t hw = (uint32_t)(h[0] << 24 | h[1] << 16 | h[2] << 8 | h[3]);
	for (h += 3; *h && hw != nw; hw = (uint32_t)((hw << 8) | *++h));
	return (*h ? (const char*)h - 3 : 0);
}


LIB_FUNC char* twoway_strstr(unsigned char* h, const unsigned char* n) {
	const unsigned char* z;
	size_t l, k, p, p0, mem0;
	size_t byteset[32 / SIZEOF_SIZE_T] = { 0 };
	size_t shift[256];
	for (l = 0; n[l] && h[l]; l++) {
		byteset[(size_t)(n[l]) / (8 * sizeof(*byteset))] |= (size_t)1 << ((size_t)(n[l]) % (8 * sizeof(*byteset)));
		shift[n[l]] = l + 1;
	}
	if (n[l]) { return 0; }
	size_t ip = (size_t)-1, jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] > n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	size_t ms = ip;
	p0 = p;
	ip = (size_t)-1;
	jp = 0;
	k = p = 1;
	while (jp + k < l) {
		if (n[ip + k] == n[jp + k]) {
			if (k == p) {
				jp += p;
				k = 1;
			} else { k++; }
		} else if (n[ip + k] < n[jp + k]) {
			jp += k;
			k = 1;
			p = jp - ip;
		} else {
			ip = jp++;
			k = p = 1;
		}
	}
	if (ip + 1 > ms + 1) { ms = ip; }
	else { p = p0; }
	if (memcmp(n, (n + p), (ms + 1))) {
		mem0 = 0;
		p = MAX(ms, (l - ms - 1)) + 1;
	} else { mem0 = l - p; }
	size_t mem = 0;
	z = h;
	LOOP_FOREVER {  // Search loop
		if ((size_t)(z - h) < l) {
			size_t grow = l | 63;
			const unsigned char* z2 = memchr(z, 0, grow);
			if (z2) {
				z = z2;
				if ((size_t)(z - h) < l) { return 0; }
			} else { z += grow; }
		}
		// Check last byte first; advance by shift on mismatch
		if (byteset[(size_t)(h[l - 1]) / (8 * sizeof(*byteset))] & (size_t)1 << ((size_t)(h[l - 1]) % (8 * sizeof(*byteset)))) {
			k = l - shift[h[l - 1]];
			if (k) {
				if (mem0 && mem && k < p) { k = l - p; }
				h += k;
				mem = 0;
				continue;
			}
		} else {
			h += l;
			mem = 0;
			continue;
		}
		// Compare right half
		for (k = MAX((ms + 1), mem); n[k] && n[k] == h[k]; k++);
		if (n[k]) {
			h += (k - ms);
			mem = 0;
			continue;
		}
		// Compare left half
		for (k = ms + 1; k > mem && n[k - 1] == h[k - 1]; k--);
		if (k <= mem) { return (char*)h; }
		h += p;
		mem = mem0;
	}
}


LIB_FUNC char* strcpy(char* restrict dest, const char* restrict src) {
	const unsigned char* s = (const unsigned char*)src;
	unsigned char* d = (unsigned char*)dest;
	while ((*d++ = *s++));
	return (char*)dest;
}
#define scopy(s1, s2)   ((void*)strcpy(s2, s1))
#define gnu_strcpy(d, s)   strcpy((d), (s))


LIB_FUNC void strcpy_no_output(char* restrict dest, const char* restrict src) {
	const unsigned char* s = (const unsigned char*)src;
	unsigned char* d = (unsigned char*)dest;
	while ((*d++ = *s++));
}
#define scopy_no_output(s1, s2)   strcpy_no_output(s2, s1)


LIB_FUNC uchar* ustrcpy(uchar* restrict dest, const uchar* restrict src) {
	uchar* d = (uchar*)dest;
	while ((*d++ = *src++));
	return (uchar*)dest;
}


/** Copies the first num characters of source to destination */
LIB_FUNC char* strncpy(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t i;
	char* os1 = dest;
	for (i = 0; i < len; i++) {
		if ((*dest++ = *src++) == 0) {
			while (++i < len) { *dest++ = 0; }
			return os1;
		}
	}
	return os1;
}


/** Copies the first num characters of source to destination */
LIB_FUNC void strncpy_no_output(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t i;
	for (i = 0; i < len; i++) {
		if ((*dest++ = *src++) == 0) { while (++i < len) { *dest++ = 0; } break; }
	}
}


LIB_FUNC char* strecpy(char* restrict to, char* e, const char* restrict from) {
	if (to >= e) { return to; }
	to = (char*)memccpy(to, from, '\0', (size_t)(e - to));
	if (to == nil) {
		to = (char*)(e - 1);
		*to = '\0';
	} else { --to; }
	return to;
}


LIB_FUNC size_t strlcpy(char* d, const char* s, const size_t len) {
	char* d0 = d;
	size_t* wd;
	const size_t* ws;
	register size_t n = len;
	if (!n--) { return (size_t)((size_t)(d - d0) + strlen(s)); }
	else if (((uintptr_t)s & (SIZEOF_SIZE_T - 1)) == ((uintptr_t)d & (SIZEOF_SIZE_T - 1))) {
		for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*d = *s); --n, ++s, ++d);
		if (n && *s) {
			wd = (void*)d;
			ws = (const void*)s;
			for (; n >= SIZEOF_SIZE_T && (!HASZERO(*ws)); n -= SIZEOF_SIZE_T, ws++, wd++) {
				*wd = *ws;
			}
			d = (void*)wd;
			s = (const void*)ws;
		}
	}
	for (; n && (*d = *s); --n, ++s, ++d);
	*d = 0;
	return (size_t)((size_t)(d - d0) + strlen(s));
}


LIB_FUNC char* stpcpy(char* restrict d, const char* restrict s) {
	size_t* wd;
	const size_t* ws;
	if (((uintptr_t)s % SIZEOF_SIZE_T) == ((uintptr_t)d % SIZEOF_SIZE_T)) {
		for (; ((uintptr_t)s % SIZEOF_SIZE_T); s++, d++) {
			if (!(*d = *s)) { return d; }
		}
		wd = (void*)d;
		ws = (const void*)s;
		for (; (!HASZERO(*ws)); *wd++ = *ws++);
		d = (void*)wd;
		s = (const void*)ws;
	}
	for (; (*d = *s); s++, d++);
	return d;
}
#define __stpcpy(d, s)   stpcpy((d), (s))


LIB_FUNC char* stpncpy(char* restrict d, const char* restrict s, size_t n) {
	size_t* wd;
	const size_t* ws;
	if (((uintptr_t)s & (SIZEOF_SIZE_T - 1)) == ((uintptr_t)d & (SIZEOF_SIZE_T - 1))) {
		for (; ((uintptr_t)s & (SIZEOF_SIZE_T - 1)) && n && (*d = *s); n--, s++, d++);
		if (!n || !*s) { return memset(d, 0, n); }
		wd = (void*)d;
		ws = (const void*)s;
		for (; n >= SIZEOF_SIZE_T && (!HASZERO(*ws)); n -= SIZEOF_SIZE_T, ws++, wd++) { *wd = *ws; }
		d = (void*)wd;
		s = (const void*)ws;
	}
	for (; n && (*d = *s); n--, s++, d++);
	return memset(d, 0, n);
}
#define __stpncpy(d, s, n)   stpncpy((d), (s), (n))


/** Appends a copy of the source string to the destination string. The terminating null character in destination is overwritten by the first character of source, and a null-character is included at the end of the new string formed by the concatenation of both in destination. */
LIB_FUNC char* strcat(char* restrict dest, const char* restrict src) {
	return strcpy((char*)(dest + (strlen(dest))), src);
}


LIB_FUNC char* strncat(char* restrict dest, const char* restrict src, const size_t len) {
	char* q = strchr_nc(dest, '\0');
	const char* p = src;
	register char ch;
	register size_t n = len;
	while (n--) {
		*q++ = ch = *p++;
		if (!ch) { return dest; }
	}
	*q = '\0';
	return dest;
}


LIB_FUNC size_t strlcat(char* restrict dest, const char* restrict src, const size_t len) {
	register size_t l = strnlen(dest, len);
	if (l == len) { return (l + strlen(src)); }
	return (l + strlcpy((dest + l), src, (len - l)));
}


LIB_FUNC const char* strchrnul(const char* s, const int x) {
	const size_t* w;
	size_t k;
	register unsigned char c = (unsigned char)x;
	if (!c) { return (const char*)(s + strlen(s)); }
	for (; (uintptr_t)s % SIZEOF_SIZE_T; s++) { if (!*s || *(const unsigned char*)s == c) { return (const char*)s; } }
	k = (size_t)((((size_t) - 1) / UCHAR_MAX) * c);
	for (w = (const void*)s; (!(HASZERO(*w))) && (!(HASZERO(*w ^ k))); ++w);
	for (s = (const void*)w; *s && *(const unsigned char*)s != c; ++s);
	return (const char*)s;
}
#define __strchrnul(s, c)   strchrnul((s), (c))


/** Span the string s1 skipping characters that are in s2 */
LIB_FUNC size_t strspn(const char* restrict s1, const char* restrict s2) {
	const char *p = s1, *spanp;
	register char c, sc;
strspn_cont:  // Skip any characters in s2, excluding the terminating \0
	c = *p++;
	for (spanp = s2; (sc = *spanp++) != 0;) {
		if (sc == c) { goto strspn_cont; }
	}
	return (size_t)(p - 1 - s1);
}


/** Scans str for the first occurrence of any of the characters that are part of reject, returning the number of characters of str read before this first occurrence */
LIB_FUNC size_t strcspn(const char* restrict str, const char* restrict reject) {
	register size_t l = 0;
	register int i;
	for (; *str; ++str) {
		for (i = 0; reject[i]; ++i) { if (*str == reject[i]) { return l; } }
		++l;
	}
	return l;
}


/** Find the first occurrence in s1 of a character in s2 */
LIB_FUNC NONNULL_IO const char* strpbrk(const char* restrict s1, const char* restrict s2) {
	s1 += strcspn(s1, s2);
	return (const char*)(*s1 ? s1 : 0);
}


LIB_FUNC char* strtok(char* restrict s, const char* restrict sep) {
	static char* p;
	if (!s && !(s = p)) { return NULL; }
	s += strspn(s, sep);
	if (!*s) { p = 0; return 0; }
	p = (s + strcspn(s, sep));
	if (*p) { *p++ = 0; }
	else { p = 0; }
	return s;
}


LIB_FUNC char* strtok_r(char* restrict s, const char* restrict sep, char** restrict p) {
	if (!s && !(s = *p)) { return (char*)NULL; }
	s += strspn(s, sep);
	if (!*s) { return *p = 0; }
	*p = (s + strcspn(s, sep));
	if (**p) { *(*p)++ = 0; }
	else { *p = 0; }
	return s;
}
#define _win_strtok_r(s, sep, p)   strtok_r((s), (sep), (p))
#define _strtok_r(s, sep, p)   strtok_r((s), (sep), (p))


/** Extract token from string */
LIB_FUNC char* strsep(char** str, const char* restrict sep) {
	char* s = *str, *end;
	if (!s) { return (char*)NULL; }
	end = (s + strcspn(s, sep));
	if (*end) { *end++ = 0; }
	else { end = 0; }
	*str = end;
	return s;
}


/** Transform src, storing the result in dest, such that strcmp() on transformed strings returns what strcoll() on the original untransformed strings would return */
LIB_FUNC size_t strxfrm(char* dest, const char* src, const size_t len) {
	if (len == 0) { return strlen(src); }
	return (size_t)strlcpy(dest, src, len);
}
#define strxfrm_l(dest, src, len, locale)   strxfrm((dest), (src), (len))


LIB_FUNC void swab(const char* restrict src, char* restrict dest, const ssize_t len) {
	register ssize_t n = len;
	for (; n > 1; n -= 2) {
		dest[0] = src[1];
		dest[1] = src[0];
		dest += 2;
		src += 2;
	}
	return;
}


/** Copy a string from "from" to "to", truncating the string if necessary; "To" is always NULL terminated, even if truncation is performed; "Size" is the size of "to" */
LIB_FUNC void scopyn(const char* restrict from, char* restrict to, register int size) {
	while (--size > 0) { if (((*to++) = (*from++)) == '\0') { return; } }
	*to = '\0';
}


/** Test if pfx is a prefix of string */
LIB_FUNC const char* prefix(const char* restrict _string, const char* restrict pfx) {
	while (*pfx) { if (((*pfx++) != (*_string++))) { return 0; } }
	return (const char*)_string;
}


/** Check for a valid number */
LIB_FUNC int is_number(const char* restrict str) {
	do { if ((*str - '0') > 9) { return 0; } } while (*++str != '\0');
	return 1;
}


// RUNE OPERATIONS


/** Convert a character to a Rune
* 00000-0007F => T1
* 00080-007FF => T2 Tx
* 00800-0FFFF => T3 Tx Tx
* 10000-10FFFF => T4 Tx Tx Tx
*/
LIB_FUNC int chartorune(Rune* rune, const char* restrict str) {
	int c[UTFmax];
	Rune l;
	c[0] = *(const unsigned char*)(str);
	if (c[0] < Tx) {
		*rune = c[0];
		return 1;
	}
	register int i;
	l = c[0];
	for (i = 1; i < UTFmax; i++) {
		c[i] = *(const unsigned char*)(str + i);
		c[i] ^= Tx;
		if (c[i] & Testx) {
			*rune = Bad;
			return 1;
		}
		l = (Rune)((l << Bitx) | c[i]);
		if (c[0] < T(i + 2)) {
			l &= RuneX(i + 1);
			if (i == 1) {
				if (c[0] < T(2) || l <= Rune1) {
					*rune = Bad;
					return 1;
				}
			} else if (l <= RuneX(i) || l > Runemax || (i == 2 && SurrogateMin <= l && l <= SurrogateMax)) {
				*rune = Bad;
				return 1;
			}
			*rune = l;
			return i + 1;
		}
	}
}


LIB_FUNC const char* utfrune(const char* restrict str, const long c) {
	register long c1;
	Rune r;
	register int n;
	if (c < Runesync) { return (const char*)strchr(str, (int)c); }  // Not part of UTF sequence
	for (;;) {
		c1 = *(const unsigned char*)str;
		if (c1 < Runeself) {  // One byte rune
			if (c1 == 0) { return 0; }
			else if (c1 == c) { return str; }
			++str;
			continue;
		}
		n = chartorune(&r, str);
		if (r == c) { return str; }
		str += n;
	}
	UNREACHABLE
}


/** Convert a Rune to a character
One character sequence
	00000-0007F => 00-7F
Two character sequence
	0080-07FF => T2 Tx
Three character sequence
	0800-FFFF => T3 Tx Tx
Four character sequence (21-bit value)
	10000-1FFFFF => T4 Tx Tx Tx
If the Rune is out of range or a surrogate half, convert it to the error rune
*/
LIB_FUNC int runetochar(char* str, const Rune* rune) {
	Rune c = *rune;
	if (c <= Rune1) {
		str[0] = (char)c;
		return 1;
	}
	register int i, j;
	for (i = 2; i < UTFmax + 1; i++) {
		if (i == 3) {
			if (c > Runemax) { c = Runeerror; }
			if (SurrogateMin <= c && c <= SurrogateMax) { c = Runeerror; }
		}
		if (c <= RuneX(i) || i == UTFmax ) {
			str[0] = (char)(T(i) |  (c >> (i - 1) * Bitx));
			for (j = 1; j < i; j++) {
				str[j] = (char)(Tx | ((c >> (i - j - 1) * Bitx) & Maskx));
			}
			return i;
		}
	}
	return UTFmax;
}


LIB_FUNC int runelen(const long c) {
	Rune _rune = (Rune)c;
	char str[10];
	return runetochar(str, &_rune);
}


LIB_FUNC int runenlen(const Rune* restrict r, int nrune) {
	register int nb = 0, i;
	Rune c;
	while (nrune--) {
		c = *r++;
		if (c <= Rune1) { nb++; }
		else {
			for (i = 2; i < UTFmax + 1; i++) {
				if (c <= RuneX(i) || i == UTFmax) {
					nb += i;
					break;
				}
			}
		}
	}
	return nb;
}


LIB_FUNC long runestrlen(const Rune* restrict str) {
	register long i = 0;
	while (*str++) { ++i; }
	return i;
}


LIB_FUNC const Rune* runestrchr(const Rune* restrict str, Rune c) {
	Rune c0 = c, c1;
	if (c == 0) {
		while (*str++);
		return (const Rune*)(str - 1);
	}
	while ((c1 = *str++)) { if (c1 == c0) { return (const Rune*)(str - 1); } }
	return 0;
}


LIB_FUNC int fullrune(const char* restrict str, const int n) {
	register int i;
	Rune c;
	if (n <= 0) { return 0; }
	c = *(const uchar*)str;
	if (c < Tx) { return 1; }
	for (i = 3; i < (int)(UTFmax + 1); i++) {
		if (c < T(i)) { return (int)(n >= i - 1); }
	}
	return (int)(n >= UTFmax);
}


// MACHINE INFO


/** Returns a true boolean value if irq are enabled for the CPU */
LIB_FUNC bool are_interrupts_enabled(void) {
	unsigned long flags;
	asm volatile ("pushf;" "pop %0;" : "=g"(flags));
	return (bool)(flags & 0x200);
}


// FILE DESCRIPTOR MACROS
#define DARWIN_FD_ZERO(p)   bzero((p), sizeof(*(p)))
#define __DARWIN_FD_ZERO(p)   bzero((p), sizeof(*(p)))
#define DARWIN_FD_COPY(f, t)   bcopy((f), (t), sizeof(*(f)))
#define __DARWIN_FD_COPY(f, t)   bcopy((f), (t), sizeof(*(f)))


#ifndef _FD_SET


#if (_FORTIFY_SOURCE > 0)
#   define __FD_ELT(d)   __extension__ ({ long __d = (d); (__builtin_constant_p(__d) ? (((0 <= __d) && (__d < FD_SETSIZE)) ? (__d / __NFDBITS) : __fdelt_chk(__d)) : __fdelt_chk(__d)); })
#else  // !(_FORTIFY_SOURCE > 0)
#   define __FD_ELT(d)   ((d) / __NFDBITS)
#endif  // (_FORTIFY_SOURCE > 0)
#define FD_ELT(d)   __FD_ELT((d))
#define __FDELT(d)   __FD_ELT((d))
#define FDELT(d)   __FD_ELT((d))
#define __FD_MASK(d)   ((__fd_mask)(1UL << ((d) % __NFDBITS)))
#define __FDMASK(d)   __FD_MASK((d))
#define FDMASK(d)   __FD_MASK((d))
#define FD_MASK(d)   __FD_MASK((d))
#ifdef __USE_XOPEN
#   define __FDS_BITS(set)   ((set)->fds_bits)
#   define FDS_BITS(set)   ((set)->fds_bits)
#   define __FDSBITS(set)   ((set)->fds_bits)
#   define FDSBITS(set)   ((set)->fds_bits)
#else
#   define __FDS_BITS(set)   ((set)->__fds_bits)
#   define FDS_BITS(set)   ((set)->__fds_bits)
#   define __FDSBITS(set)   ((set)->__fds_bits)
#   define FDSBITS(set)   ((set)->__fds_bits)
#endif
#define FDS_LONGS(nr)   (((nr) + FDS_BITPERLONG - 1) / FDS_BITPERLONG)
#define FDS_BYTES(nr)   (FDS_LONGS(nr) * SIZEOF_LONG)
// Access macros for `fd_set`
#ifdef I386  // __FD*
#   define __FD_SET(fd, fdsp)   do { asm volatile ("btsl %1, %0;" : "=m"(__FDS_BITS(fdsp)[__FDELT(fd)]) : "r"(((int)(fd)) % __NFDBITS) : "cc", "memory") } while (0x0)
#   define __FD_CLR(fd, fdsp)   do { asm volatile ("btrl %1, %0;" : "=m"(__FDS_BITS(fdsp)[__FDELT(fd)]) : "r"(((int)(fd)) % __NFDBITS) : "cc", "memory") } while (0x0)
#   define __FD_ISSET(fd, fdsp)   do { register char __result; asm volatile ("btl %1, %2;" "setcb %b0;" : "=q"(__result) : "r"(((int)(fd)) % __NFDBITS), "m"(__FDS_BITS(fdsp)[__FDELT(fd)]) : "cc"); __result; } while (0x0)
#else
#   define __FD_SET(d, s)   ((void)(__FDS_BITS(s)[__FD_ELT(d)] |= (__FD_MASK(d))))
#   define __FD_CLR(d, s)   ((void)(__FDS_BITS(s)[__FD_ELT(d)] &= (~(__FD_MASK(d)))))
#   define __FD_ISSET(d, s)   ((__FDS_BITS(s)[__FD_ELT(d)] & __FD_MASK(d)) != 0x0)
#endif  // __FD*
#define FD_SET(fd, fdsetp)   __FD_SET((fd), (fdsetp))
#define FD_CLR(fd, fdsetp)   __FD_CLR((fd), (fdsetp))
#define FD_ISSET(fd, fdsetp)   __FD_ISSET((fd), (fdsetp))
#define __DARWIN_FD_ISSET(fd, fdsetp)   __FD_ISSET((fd), (fdsetp))
#define __darwin_fd_isset(fd, fdsetp)   __FD_ISSET((fd), (fdsetp))
#ifdef X86_64  // __FD_ZERO
/** Small `memset` substitute */
#   define __FD_ZERO(fdsp)   do { int __d0, __d1; asm volatile ("cld;" "rep;" __FD_ZERO_STOS : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(fd_set) / sizeof(__fd_mask)), "1"(&__FDS_BITS (fdsp)[0]) : "memory"); } while (0x0)
#elif defined(I386)
/** Small `memset` substitute */
#   define __FD_ZERO(fdsp) do { int __d0, __d1; asm volatile ("cld;" "rep;" "stosl;" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(fd_set) / sizeof(__fd_mask)), "1"(&__FDS_BITS (fdsp)[0]) : "memory"); } while (0x0)
#else  // Not x86
/** Small `memset` substitute */
#   define __FD_ZERO(s)   do { unsigned int __i; fd_set *__arr = (s); for (__i = 0; __i < sizeof(fd_set) / sizeof(__fd_mask); ++__i) __FDS_BITS(__arr)[__i] = 0; } while (0x0)
#endif  // __FD_ZERO
#define FD_ZERO(fdsetp)   __FD_ZERO((fdsetp))
#define __DARWIN_FD_SET(n, p)   do { int __fd = (n); ((p)->fds_bits[(unsigned long)__fd/ BITS_PER_LONG] |= ((int32_t)(1 << ((unsigned long)__fd % BITS_PER_LONG)))); } while (0x0)
#define __DARWIN_FD_CLR(n, p)   do { int __fd = (n); ((p)->fds_bits[(unsigned long)__fd / BITS_PER_LONG] &= (~((int32_t)(1 << ((unsigned long)__fd % BITS_PER_LONG))))); } while (0x0)


#endif  // FD_SET


#endif  // BIT-TWIDDLING


/* WIDE-CHARACTER & EXTENDED-MULTIBYTE HANDLING (<wchar.h>) */


#if (!(defined(_WCHAR_H) || defined(_WCHAR_H_) || defined(_WCHAR2_H_) || defined(_LIBC_WCHAR_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/wchar.h.html & http://www.cplusplus.com/reference/cwchar/
#define WCHAR_H   (1)
#define _WCHAR_H   (1)
#define _WCHAR_H_   (1)
#define _WCHAR2_H   (1)
#define _WCHAR2_H_   (1)
#define _LIBC_WCHAR_H_   (1)


#define btowc(c)   ((wint_t)((((int)(c)) == EOF) ? WEOF : (wint_t)(c)))


LIB_FUNC size_t wcsnlen(const wchar_t* s, size_t maxlen) {
	const wchar_t* ptr;
	for (ptr = s; maxlen > 0 && *ptr != (wchar_t)0; ptr++, maxlen--);
	return (size_t)(ptr - s);
}


/** Return the length of a wchar_t string */
LIB_FUNC unsigned int strlenW(const wchar_t* restrict str) {
	const wchar_t* s = str;
	while (*s) { ++s; }
	return (unsigned int)(s - str);
}
#define wcstrlen(str)   strlenW((str))
#define _wcstrlen(str)   strlenW((str))
#define strlenw(str)   strlenW((str))
#define wstrlen(str)   strlenW((str))
#define Wstrlen(str)   strlenW((str))


/** Copy a wchar_t string */
LIB_FUNC wchar_t* strcpyW(wchar_t* restrict dst, const wchar_t* restrict src) {
	wchar_t* p = dst;
	while ((*p++ = *src++));
	return dst;
}
#define wccpy(dst, src)   strcpyW((dst), (src))
#define _wccpy(dst, src)   strcpyW((dst), (src))
#define strcpyw(dst, src)   strcpyW((dst), (src))
#define wstrcpy(dst, src)   strcpyW((dst), (src))
#define Wstrcpy(dst, src)   strcpyW((dst), (src))


LIB_FUNC wchar_t* strncpyW(wchar_t* restrict dest, const wchar_t* restrict src, const size_t n) {
	wchar_t* orig = dest;
	for (; dest < orig + n && (*dest = *src); ++src, ++dest);
	for (; dest < orig + n; ++dest) { *dest = 0; }
	return orig;
}
#define wcsncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define _wcsncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define strncpyw(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define wstrncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))
#define Wstrncpy(dst, src, n)   strncpyW((dst), (src), (size_t)(n))


LIB_FUNC int strcmpW(const wchar_t* restrict str1, const wchar_t* restrict str2) {
	while (*str1 && (*str1 == *str2)) { ++str1; ++str2; }
	return (int)(*str1 - *str2);
}
#define wcscmp(str1, str2)   strcmpW((str1), (str2))
#define _wcscmp(str1, str2)   strcmpW((str1), (str2))
#define strcmpw(str1, str2)   strcmpW((str1), (str2))
#define wstrcmp(str1, str2)   strcmpW((str1), (str2))
#define Wstrcmp(str1, str2)   strcmpW((str1), (str2))


LIB_FUNC int strncmpW(const wchar_t* restrict str1, const wchar_t* restrict str2, const int len) {
	if (len <= 0) { return 0; }
	register int maxlen = len;
	while ((--maxlen > 0) && *str1 && (*str1 == *str2)) { ++str1; ++str2; }
	return (int)(*str1 - *str2);
}
#define wcsncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define _wcsncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define strncmpw(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define wstrncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))
#define Wstrncmp(str1, str2, n)   strncmpW((str1), (str2), (int)(n))


LIB_FUNC wchar_t* strcatW(wchar_t* restrict dst, const wchar_t* restrict src) {
	return strcpyW(dst + strlenW(dst), src);
}
#define wccat(dst, src)   strcatW((dst), (src))
#define _wccat(dst, src)   strcatW((dst), (src))
#define wcscat(d, str)   strcatW((d), (str))
#define strcatw(dst, src)   strcatW((dst), (src))
#define wstrcat(dst, src)   strcatW((dst), (src))
#define Wstrcat(dst, src)   strcatW((dst), (src))


LIB_FUNC wchar_t* strchrW(const wchar_t* restrict str, const wchar_t ch) {
	do { if (*str == ch) { return (wchar_t*)(ULONG_PTR)str; } } while (*str++);
	return NULL;
}
#define wcschr(str, ch)   strchrW((str), (wchar_t)(ch))
#define _wcschr(str, ch)   strchrW((str), (wchar_t)(ch))
#define strchrw(str, ch)   strchrW((str), (wchar_t)(ch))
#define wstrchr(str, ch)   strchrW((str), (wchar_t)(ch))
#define Wstrchr(str, ch)   strchrW((str), (wchar_t)(ch))


LIB_FUNC wchar_t* strrchrW(const wchar_t* restrict str, const wchar_t ch) {
	wchar_t* ret = NULL;
	do { if (*str == ch) { ret = (wchar_t*)(ULONG_PTR)str; } } while (*str++);
	return ret;
}
#define wcsrchr(str, c)   strrchrW((str), (wchar_t)(c))
#define _wcsrchr(str, c)   strrchrW((str), (wchar_t)(c))
#define strrchrw(str, c)   strrchrW((str), (wchar_t)(c))
#define wstrrchr(str, c)   strrchrW((str), (wchar_t)(c))
#define Wstrrchr(str, c)   strrchrW((str), (wchar_t)(c))


LIB_FUNC wchar_t* strpbrkW(const wchar_t* restrict str, const wchar_t* restrict accept) {
	for (; *str; str++) { if (strchrW(accept, *str)) { return (wchar_t*)(ULONG_PTR)str; } }
	return NULL;
}
#define wcspbrk(str, accept)   strpbrkW((str), (accept))
#define _wcspbrk(str, accept)   strpbrkW((str), (accept))
#define strpbrkw(str, accept)   strpbrkW((str), (accept))
#define wstrpbrk(str, accept)   strpbrkW((str), (accept))
#define Wstrpbrk(str, accept)   strpbrkW((str), (accept))


LIB_FUNC size_t strspnW(const wchar_t* restrict str, const wchar_t* restrict accept) {
	const wchar_t* ptr = str;
	for (; *ptr; ptr++) { if (!(strchrW(accept, *ptr))) { break; } }
	return (size_t)(ptr - str);
}
#define wstrspn(str, accept)   strspnW((str), (accept))
#define Wstrspn(str, accept)   strspnW((str), (accept))
#define strspnw(str, accept)   strspnW((str), (accept))
#define wstrspn(str, accept)   strspnW((str), (accept))
#define Wstrspn(str, accept)   strspnW((str), (accept))


LIB_FUNC size_t strcspnW(const wchar_t* str, const wchar_t* reject) {
	const wchar_t* ptr = str;
	for (; *ptr; ptr++) { if (strchrW(reject, *ptr)) { break; } }
	return (size_t)(ptr - str);
}
#define strcspnw(d, str)   strcspnW((d), (str))
#define wstrcspn(d, str)   strcspnW((d), (str))
#define Wstrcspn(d, str)   strcspnW((d), (str))


LIB_FUNC wchar_t* strlwrW(wchar_t* restrict str) {
	wchar_t* ret = str;
	while ((*str = (wchar_t)tolowerW(*str))) { ++str; }
	return ret;
}
#define wcslwr(str)   strlwrW((str))
#define _wcslwr(str)   strlwrW((str))
#define strlwrw(str)   strlwrW((str))
#define wstrlwr(str)   strlwrW((str))
#define Wstrlwr(str)   strlwrW((str))


LIB_FUNC wchar_t* struprW(wchar_t* restrict str) {
	wchar_t* ret = str;
	while ((*str = (wchar_t)toupperW(*str))) { ++str; }
	return ret;
}
#define struprw(str)   struprW((str))
#define wcsupr(str)   struprW((str))
#define _wcsupr(str)   struprW((str))


LIB_FUNC const wchar_t* memchrW(const wchar_t* restrict ptr, const wchar_t ch, const size_t len) {
	const wchar_t* end = (const wchar_t*)(ptr + len);
	for (; ptr < end; ptr++) { if (*ptr == ch) { return (const wchar_t*)ptr; } }
	return NULL;
}
#define memchrw(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memwchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memWchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define wmemchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define Wmemchr(ptr, ch, len)   memchrW((ptr), (wchar_t)(ch), (size_t)(len))


LIB_FUNC wchar_t* memrchrW(wchar_t* ptr, const wchar_t ch, const size_t len) {
	wchar_t *end, *ret = NULL;
	for (end = (ptr + len); ptr < end; ptr++) { if (*ptr == ch) { ret = ptr; } }
	return (wchar_t*)ret;
}
#define memrchrw(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memwrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define memWrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define wmemrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))
#define Wmemrchr(ptr, ch, len)   memrchrW((ptr), (wchar_t)(ch), (size_t)(len))


LIB_FUNC wchar_t* wmemmove(wchar_t* restrict dest, const wchar_t* restrict src, const size_t len) {
	wchar_t* d0 = dest;
	register size_t _len = len;
	if ((size_t)(dest - src) < _len) { while (_len--) { dest[_len] = src[_len]; } }
	else { while (_len--) { *dest++ = *src++; } }
	return d0;
}
#define memmoveW(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define memmove_W(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define memmovew(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define wmemmove(dest, src, len)   wmemmove((dest), (src), (size_t)(len))
#define Wmemmove(dest, src, len)   wmemmove((dest), (src), (size_t)(len))


LIB_FUNC float wcstof(const wchar_t* restrict nptr, const wchar_t** restrict endptr) {
	return (float)strtof((const char*)(nptr), (const char**)(endptr));
}
#define _wcstof(nptr, endptr)   wcstof((nptr), (endptr))
#define strtofW(nptr, endptr)   wcstof((nptr), (endptr))
#define strtofw(nptr, endptr)   wcstof((nptr), (endptr))
#define wstrtof(nptr, endptr)   wcstof((nptr), (endptr))
#define Wstrtof(nptr, endptr)   wcstof((nptr), (endptr))


LIB_FUNC double wcstod(const wchar_t* restrict nptr, const wchar_t** restrict endptr) {
	return (double)strtod((const char*)(nptr), (const char**)(endptr));
}
#define _wcstod(nptr, endptr)   wcstod((nptr), (endptr))
#define strtodW(nptr, endptr)   wcstod((nptr), (endptr))
#define strtodw(nptr, endptr)   wcstod((nptr), (endptr))
#define wstrtod(nptr, endptr)   wcstod((nptr), (endptr))
#define Wstrtod(nptr, endptr)   wcstod((nptr), (endptr))


LIB_FUNC long wcstol(const wchar_t* restrict nptr, const wchar_t** endptr, const int base) {
	return (long)strtol((const char*)(nptr), (const char**)(endptr), base);
}
#define _wcstol(str, e, b)   wcstol((str), (e), (int)(b))
#define strtolW(str, e, b)   wcstol((str), (e), (int)(b))
#define strtolw(str, e, b)   wcstol((str), (e), (int)(b))
#define wstrtol(str, e, b)   wcstol((str), (e), (int)(b))
#define Wstrtol(str, e, b)   wcstol((str), (e), (int)(b))


LIB_FUNC unsigned long wcstoul(const wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (unsigned long)strtoul((const char*)(nptr), (const char**)(endptr), base);
}
#define _wcstoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define strtoulW(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define strtoulw(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define wstrtoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))
#define Wstrtoul(nptr, endptr, base)   wcstoul((nptr), (endptr), (int)(base))


/** Like `wcstol` but convert to `intmax_t` */
LIB_FUNC intmax_t wcstoimax(wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (intmax_t)wcstoll(nptr, endptr, base);
}


/** Like `wcstoul` but convert to `uintmax_t` */
LIB_FUNC uintmax_t wcstoumax(wchar_t* restrict nptr, const wchar_t** restrict endptr, const int base) {
	return (uintmax_t)wcstox(nptr, endptr, base, ULLONG_MAX);
}


LIB_FUNC long atolW(const wchar_t* restrict str) {
	return (long)wcstol(str, (const wchar_t**)0, 10);
}
#define atolw(str)   atolW((str))
#define __atolw(str)   atolW((str))
#define __atolW(str)   atolW((str))
#define wtol(str)   atolW((str))
#define _wtol(str)   atolW((str))


LIB_FUNC int atoiW(const wchar_t* restrict str) {
	return (int)wcstol(str, (const wchar_t**)0, 10);
}
#define atoiw(str)   atoiW((str))
#define __atoiw(str)   atoiW((str))
#define __atoiW(str)   atoiW((str))
#define wtoi(str)   atoiW((str))
#define _wtoi(str)   atoiW((str))


LIB_FUNC int wcwidth(const wchar_t wc) {
	if (wc < (wchar_t)0xffU) { return ((((wc + 1) & 0x7f) >= 0x21) ? 1 : (wc ? -1 : 0)); }
	else if ((wc & (wchar_t)0xfffeffffU) < (wchar_t)0xfffe) {
		if ((nonspacing_table[(unsigned int)(nonspacing_table[wc >> 8] * 32) + (unsigned int)((wc & 255) >> 3)] >> (wc & 7)) & 1) { return 0; }
		else if ((wide_table[(unsigned int)(wide_table[wc >> 8] * 32) + (unsigned int)((wc & 255) >> 3)] >> (wc & 7)) & 1) { return 2; }
		return 1;
	}
	if ((wc & (wchar_t)0xfffe) == (wchar_t)0xfffe) { return -1; }
	else if ((wc - (wchar_t)0x20000U) < (wchar_t)0x20000) { return 2; }
	else if (wc == (wchar_t)0xe0001 || ((wc - (wchar_t)0xe0020U) < (wchar_t)0x5f) || ((wc - (wchar_t)0xe0100) < (wchar_t)0xef)) { return 0; }
	return 1;
}


LIB_FUNC int wcswidth(const wchar_t* restrict wcs, const size_t len) {
	register int l = 0, k = 0;
	register size_t n = len;
	for (; n-- && *wcs && (k = (int)wcwidth(*wcs)) >= 0; l += k, ++wcs);
	return ((k < 0) ? k : l);
}


LIB_FUNC const wchar_t* wcswcs(const wchar_t* restrict ws1, const wchar_t* restrict ws2) {
	const char* s1 = (const char*)(ws1);
	const char* s2 = (const char*)(ws2);
	return (const wchar_t*)(strstr(s1, s2));
}


LIB_FUNC int wcsicmp(const wchar_t* restrict cs, const wchar_t* restrict ct) {
	while (towlower(*cs) == towlower(*ct)) {
		if (*cs == 0) { return 0; }
		++cs;
		++ct;
	}
	return (int)(towlower(*cs) - towlower(*ct));
}
#define _wcsicmp(str1, str2)   wcsicmp((str1), (str2))
#define strcmpiW(str1, str2)   wcsicmp((str1), (str2))
#define strcmpiw(str1, str2)   wcsicmp((str1), (str2))
#define wstrcmpi(str1, str2)   wcsicmp((str1), (str2))
#define Wstrcmpi(str1, str2)   wcsicmp((str1), (str2))


LIB_FUNC wchar_t* wcsstr(wchar_t* s, wchar_t* b) {
	wchar_t *x, *y, *c;
	x = (wchar_t*)s;
	while (*x) {
		if (*x == *b) {
			y = x;
			c = (wchar_t*)b;
			while (*y && *c && *y == *c) { ++c; ++y; }
			if (!*c) { return x; }
		}
		++x;
	}
	return NULL;
}
#define strstrW(d, str)   wcsstr((d), (str))
#define _strstrW(d, str)   wcsstr((d), (str))
#define strstrw(d, str)   wcsstr((d), (str))
#define _strstrw(d, str)   wcsstr((d), (str))
#define _wcsstr(d, str)   wcsstr((d), (str))
#define wstrstr(d, str)   wcsstr((d), (str))
#define Wstrstr(d, str)   wcsstr((d), (str))


LIB_FUNC size_t wcsspn(const wchar_t* str, const wchar_t* accept) {
	const wchar_t *s, *t;
	s = str;
	do {
		t = accept;
		while (*t) { if (*t == *s) { break; } ++t; }
		if (!*t) { break; }
		++s;
	} while (*s);
	return (size_t)(s - str);
}
#define _wcsspn(str, accept)   wcsspn((str), (accept))


LIB_FUNC size_t wcscspn(wchar_t* restrict str, wchar_t* restrict reject) {
	wchar_t *s, *t;
	s = (wchar_t*)str;
	while (*s) {
		t = (wchar_t*)reject;
		while (*t) { if (*t == *s) { break; } ++t; }
		if (*t) { break; }
		++s;
	}
	return (size_t)(s - str);
}
#define _wcscspn(d, str)   wcscspn((d), (str))


LIB_FUNC size_t wcsxfrm(wchar_t* restrict dst, const wchar_t* restrict src, const size_t len) {
	register size_t r = 0, _len = len;
	register int c;
	if (_len != 0) {
		while ((c = *src++) != 0) {
			++r;
			if (--_len == 0) { while (*src++ != 0) { ++r; } break; }
			*dst++ = c;
		}
		*dst = 0;
	}
	return r;
}


LIB_FUNC size_t wcrtomb(char* restrict s, wchar_t wc, UNUSED mbstate_t* restrict st) {
	if (!s) { return 1; }
	else if ((unsigned)wc < 0x80) {
		*s = (char)wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
		if ((!IS_CODEUNIT(wc))) {
			errno = EILSEQ;
			return (size_t)-1;
		}
		*s = (char)wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
		*s++ = (char)(0xc0 | (wc >> 6));
		*s = (char)(0x80 | (wc & 0x3f));
		return 2;
	} else if ((unsigned)wc < 0xd800 || (((unsigned)wc - 0xe000) < 0x2000)) {
		*s++ = (char)(0xe0 | (wc >> 12));
		*s++ = (char)(0x80 | ((wc >> 6) & 0x3f));
		*s = (char)(0x80 | (wc & 0x3f));
		return 3;
	} else if (((unsigned)wc - 0x10000) < 0x100000) {
		*s++ = (char)(0xf0 | (wc >> 18));
		*s++ = (char)(0x80 | ((wc >> 12) & 0x3f));
		*s++ = (char)(0x80 | ((wc >> 6) & 0x3f));
		*s = (char)(0x80 | (wc & 0x3f));
		return 4;
	}
	errno = EILSEQ;
	return (size_t)-1;
}


LIB_FUNC int wctomb(char* s, wchar_t wchar) {
	static mbstate_t mbs;
	register size_t rval;
	if (s == NULL) {
		memset_no_output(&mbs, 0, SIZEOF_MBSTATE_T);
		return 0;
	} else if ((rval = wcrtomb(s, wchar, &mbs)) == (size_t)-1) { return -1; }
	return ((int)rval);
}


/** Convert the wchar to a uppercase wide ASCII letter */
LIB_FUNC wchar_t towcase(const wchar_t wc, const int lower) {
	if (!iswalpha((wint_t)wc) || ((unsigned)wc - 0x600) <= (0xfff - 0x600) || ((unsigned)wc - 0x2e00) <= (0xa63f - 0x2e00) || ((unsigned)wc - 0xa800) <= (0xfeff - 0xa800)) { return wc; }
	if (lower && (((unsigned)wc - 0x10a0) < 0x2e)) {
		if (wc > 0x10c5 && wc != 0x10c7 && wc != 0x10cd) { return wc; }
		else { return (wc + 0x2d00 - 0x10a0); }
	} else if (!lower && (((unsigned)wc - 0x2d00) < 0x26)) {
		if (wc > 0x2d25 && wc != 0x2d27 && wc != 0x2d2d) { return wc; }
		else { return (wchar_t)(wc + 0x10a0 - 0x2d00); }
	}
	const int lmul = (2 * lower - 1);
	const int lmask = (lower - 1);
	register int i;
	for (i = 0; wchar_casemaps[i].len; i++) {
		int base = wchar_casemaps[i].upper + (lmask & wchar_casemaps[i].lower);
		if (((unsigned)wc - (unsigned)base) < wchar_casemaps[i].len) {
			if (wchar_casemaps[i].lower == 1) { return (wchar_t)(wc + lower - ((wc - wchar_casemaps[i].upper) & 1)); }
			return (wc + (lmul * wchar_casemaps[i].lower));
		}
	}
	for (i = 0; wchar_pairs[i][1 - lower]; i++) {
		if (wchar_pairs[i][1 - lower] == wc) { return wchar_pairs[i][lower]; }
	}
	if (((unsigned)wc - (unsigned)(0x10428 - (0x28 * lower))) < 0x28) { return (wc - 0x28 + (0x50 * lower)); }
	return wc;
}
#define _towcase(wc, lower)   towcase((wc), (int)(lower))
#define __towcase(wc, lower)   towcase((wc), (int)(lower))


/** Returns a value of type wctrans_t that corresponds to the character transformation by property */
LIB_FUNC wctrans_t wctrans(const char* restrict property) {
	if (!(strcmp(property, "toupper"))) { return (wctrans_t)1; }
	else if (!(strcmp(property, "tolower"))) { return (wctrans_t)2; }
	return (wctrans_t)0;
}
#define __wctrans(property)   wctrans((property))


/** Returns a value of type wctrans_t that corresponds to the character transformation by property */
LIB_FUNC wctrans_t wctrans_l(const char* restrict property, const UNUSED locale_t l) {
	return wctrans(property);
}
#define __wctrans_l(property, l)   wctrans_l((property), (l))


/** Applies a the transformation specified by `trans` to the wide character `wc` */
LIB_FUNC wint_t towctrans(const wint_t wc, const wctrans_t trans) {
	switch ((int)*trans) {
		case 1: return (wint_t)towupper(wc);
		case 2: return (wint_t)towlower(wc);
		default: return (wint_t)wc;
	}
	UNREACHABLE
}
#define _towctrans(wc, trans)   towctrans((wc), (trans))
#define __towctrans(wc, trans)   towctrans((wc), (trans))


/** Applies a the transformation specified by `trans` to the wide character `wc` */
LIB_FUNC wint_t towctrans_l(const wint_t wc, const wctrans_t trans, const UNUSED locale_t l) {
	return towctrans(wc, trans);
}
#define _towctrans_l(wc, trans, l)   towctrans_l((wc), (trans), (l))
#define __towctrans_l(wc, trans, l)   towctrans_l((wc), (trans), (l))


LIB_FUNC int mbsinit(const mbstate_t* restrict st) {
	return (!st || !*(const unsigned*)st);
}


LIB_FUNC size_t mbrtowc(wchar_t* restrict pwc, const char* s, const size_t len, UNUSED mbstate_t* ps) {
	if (s == NULL) { s = ""; pwc = NULL; }
	else if (len == 0 && pwc) { *pwc = 0; return 0; }
	if (pwc) { *pwc = *s; }
	return (*s != 0);
}


LIB_FUNC int mbtowc(wchar_t* restrict pwc, const char* s, const size_t n) {
	return (int)mbrtowc(pwc, s, n, NULL);
}


LIB_FUNC size_t mbsrtowcs(wchar_t* dst, const char** src, const size_t len, UNUSED mbstate_t* ps) {
	const char* s = *src;
	const char* s2 = (const char*)(memchr(s, 0, len));
	register size_t _len = len;
	if (s2 != NULL) { _len = (size_t)(s2 - s) + 1U; }
	if (dst) { dst = (wchar_t*)memcpy((char*)(dst), s, _len ); }
	*src = s + _len;
	return _len;
}


LIB_FUNC size_t mbstowcs(wchar_t* dst, const char* src, const size_t len) {
	return mbsrtowcs(dst, &src, len, NULL);
}


/** Format time as wide string */
LIB_FUNC size_t wcsftime(wchar_t* wcs, size_t maxsize, const wchar_t* format,  const struct tm* timptr) {
	return strftime((char*)(wcs), maxsize, (const char*)(format), timptr);
}


LIB_FUNC size_t wcsrtombs(char* dst, const wchar_t** src, const size_t len, UNUSED mbstate_t* ps) {
	const char* s = (const char*)(*src);
	register size_t _len = len;
	const char* s2 = (const char*)(memchr(s, 0, _len));
	if (s2 != NULL) { _len = (size_t)((s2 - s) + 1); }
	if (dst != NULL) { dst = (char*)memcpy(dst, s, _len); }
	*src = (const wchar_t*)(s + _len);
	return _len;
}


LIB_FUNC size_t wcstombs(char* dst, const wchar_t* src, const size_t len) {
	return wcsrtombs(dst, &src, len, NULL);
}


LIB_FUNC int wctob(const wint_t wc) {
	char buf[64];
	if (!(MB_CUR_MAX <= sizeof(buf))) { abort(); }
	else if ((wc > (wint_t)0) && wctomb(buf, (wchar_t)wc) == 1) { return (unsigned char) buf[0]; }
	return EOF;
}


LIB_FUNC long double wcstox_l(wchar_t* s, wchar_t** p, int prec) {
	wchar_t* t = s;
	unsigned char buf[64];
	FILE f = { 0 };
	f.flags = 0;
	f.rpos = f.rend = 0;
	f.buf = buf + 4;
	f.buf_size = (sizeof(buf) - 4);
	f.lock = -1;
	f.read = do_read_helper;
	while (iswspace(*t)) { t++; }
	f._cookie = (void*)t;
	shlim(&f, 0);
	long double y = __floatscan(&f, prec, 1);
	if (p) { const size_t cnt = (size_t)shcnt(&f); *p = (cnt ? t + cnt : (wchar_t*)s); }
	return y;
}


LIB_FUNC unsigned long long wcstox(wchar_t* s, const wchar_t** p, const int base, const unsigned long long lim) {
	wchar_t* t = s;
	unsigned char buf[64];
	FILE f = { 0 };
	f.flags = 0;
	f.rpos = f.rend = 0;
	f.buf = buf + 4;
	f.buf_size = (sizeof(buf) - 4);
	f.lock = -1;
	f.read = do_read_helper;
	while (iswspace(*t)) { t++; }
	f._cookie = (void*)t;
	shlim(&f, 0);
	const unsigned long long y = intscan(&f, (unsigned int)base, 1, lim);
	if (p) { const size_t cnt = (size_t)shcnt(&f); *p = (cnt ? t + cnt : (wchar_t*)s); }
	return y;
}


LIB_FUNC long double wcstold(wchar_t* restrict s, wchar_t** restrict p) {
	return (long double)wcstox_l(s, p, 2);
}


LIB_FUNC unsigned long long wcstoull(wchar_t* restrict s, const wchar_t** restrict p, const int base) {
	return (unsigned long long)wcstox(s, p, base, ULLONG_MAX);
}


LIB_FUNC long long wcstoll(wchar_t* restrict s, const wchar_t** restrict p, const int base) {
	return (long long)wcstox(s, p, base, (unsigned long long)LLONG_MIN);
}


LIB_FUNC int mblen(const char* s, const size_t len) {
	return mbtowc(0, s, len);
}


LIB_FUNC size_t mbrlen(const char* restrict s, const size_t len, mbstate_t* restrict st) {
	static unsigned internal;
	return mbrtowc(0, s, len, st ? st : (mbstate_t*)&internal);
}


LIB_FUNC wint_t getwc(FILE* stream) {
	return (wint_t)((stream)->rpos < (stream)->rend && *(stream)->rpos < 128 ? *(stream)->rpos++ : getc(stream));
}
#define fgetwc(stream)   getwc((stream))


LIB_FUNC wint_t getwchar(void) {
	return getwc(stdin);
}
#define getwchar_unlocked()   getwchar()
#define fgetwc_unlocked()   getwchar()


LIB_FUNC wchar_t* fgetws(wchar_t* ws, const int n, FILE* stream) {
	return (wchar_t*)(fgets((char*)(ws), n, stream));
}


/** Write wide character to stream */
LIB_FUNC wint_t __fputwc_unlock(const wchar_t wc, FILE* fp) {
	struct wchar_io_data* wcio;
	mbstate_t* st;
	size_t size;
	char buf[MB_LEN_MAX];
	struct __suio uio;
	struct __siov iov;
	iov.iov_base = buf;
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	_SET_ORIENTATION(fp, 1);
	wcio = WCIO_GET(fp);
	if (wcio == 0) { errno = ENOMEM; return WEOF; }
	wcio->wcio_ungetwc_inbuf = 0;
	st = &wcio->wcio_mbstate_out;
	size = wcrtomb(buf, wc, st);
	if (size == (size_t)-1) { fp->flags |= (unsigned int)__SERR; return WEOF; }
	iov.iov_len = size;
	uio.uio_resid = (int)size;
	if (__sfvwrite(fp, &uio)) { return WEOF; }
	return (wint_t)wc;
}


/** Write wide character to stream */
LIB_FUNC wint_t fputwc(wchar_t wc, FILE* stream) {
	return (wint_t)fputc((char)(wc), stream);
}
#define putwc(wc, stream)    fputwc((wc), (stream))


LIB_FUNC wint_t fputwc_lite(const wchar_t wc, FILE* stream) {
	return (wint_t)(fputc((char)(wc), stream));
}


LIB_FUNC int fputws(const wchar_t* str, FILE* stream) {
	return fputs((const char*)(str), stream );
}


LIB_FUNC wint_t putwchar(wchar_t wc) {
	return fputwc(wc, stdout);
}
#define putwchar_unlocked(wc)   putwchar((wc))
#define _IO_putwc_unlocked(wc)   putwchar((wc))
#define fputwc_unlocked(wc)   putwchar((wc))


LIB_FUNC wint_t ungetwc(wint_t wc, FILE* stream) {
	return (wint_t)ungetc((int)(wc), stream);
}


LIB_FUNC size_t wstring_read(FILE* f, unsigned char* buf, const size_t len) {
	wchar_t* src = f->_cookie;
	size_t k;
	const wchar_t* src2 = (const wchar_t*)&src;
	if (!src) { return 0; }
	k = wcsrtombs((void*)f->buf, &src2, f->buf_size, 0);
	if (k == (size_t)-1) { f->rpos = f->rend = 0; return 0; }
	f->rpos = f->buf;
	f->rend = f->buf + k;
	f->_cookie = (void*)src;
	if (!len || !k) { return 0; }
	*buf = *f->rpos++;
	return 1;
}


LIB_FUNC size_t wstring_read_helper(void* f, unsigned char* buf, const size_t len) {
	return wstring_read((FILE*)f, buf, len);
}


LIB_FUNC int in_set(const wchar_t* set, const int c) {
	const wchar_t* p = set;
	if (*p == '-') {
		if (c == '-') { return 1; }
		++p;
	} else if (*p == ']') {
		if (c == ']') { return 1; }
		++p;
	}
	register int j;
	for (; *p && *p != ']'; p++) {
		if (*p == '-' && p[1] && p[1] != ']') {
			for (j = p++[-1]; j < *p; j++) { if (c == j) { return 1; } }
		}
		if (c == *p) { return 1; }
	}
	return 0;
}


/** Reads data from the stream and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vfwscanf(FILE* restrict f, const wchar_t* restrict fmt, va_list ap) {
	const wchar_t* p;
	char* s;
	wchar_t* wcs;
	void* dest = NULL;
	off_t pos = 0, cnt;
	static const char size_pfx[8][4] = { "hh", "h", "", "l", "L", "ll" };
	char tmp[3 * SIZEOF_INT + 10];
	const wchar_t* set;
	size_t i, k;
	FLOCK(f);
	fwide(f, 1);
	int alloc, width, size, c, t, invert, matches = 0;
	for (p = fmt; *p; p++) {
		alloc = 0;
		if (iswspace(*p)) {
			while (iswspace(p[1])) { ++p; }
			while (iswspace((c = (int)getwc(f)))) { ++pos; }
			ungetwc((wint_t)c, f);
			continue;
		} else if (*p != '%' || p[1] == '%') {
			p += *p == '%';
			c = (int)getwc(f);
			if (c != *p) {
				ungetwc((wint_t)c, f);
				if (c < 0) { goto vfwscanf_general_fail; }
				goto match_fail;
			}
			++pos;
			continue;
		}
		++p;
		if (*p == '*') { dest = 0; p++; }
		else if (iswdigit(*p) && p[1]=='$') { dest = arg_n(ap, (unsigned int)(*p - '0')); p += 2; }
		else { dest = va_arg(ap, void*); }
		for (width = 0; iswdigit(*p); p++) { width = 10 * width + *p - '0'; }
		if (*p == 'm') {
			wcs = 0;
			s = 0;
			alloc = !!dest;
			p++;
		} else { alloc = 0; }
		size = SIZE_def;
		switch (*p++) {
			case 'h':
				if (*p == 'h') { ++p; size = SIZE_hh; }
				else { size = SIZE_h; }
				break;
			case 'l':
				if (*p == 'l') { ++p; size = SIZE_ll; }
				else { size = SIZE_l; }
				break;
			case 'j':
				size = SIZE_ll;
				break;
			case 'z':
			case 't':
				size = SIZE_l;
				break;
			case 'L':
				size = SIZE_L;
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 's':
			case 'c':
			case '[':
			case 'S':
			case 'C':
			case 'p':
			case 'n':
				--p;
				break;
			default: goto vfwscanf_general_fail;
		}
		t = *p;
		if ((t & 0x2f) == 3) { size = SIZE_l; t |= 32; }
		if (t != 'n') {
			if (t != '[' && (t | 32) != 'c') { while (iswspace((c = (int)getwc(f)))) { ++pos; } }
			else { c = (int)getwc(f); }
			if (c < 0) { goto vfwscanf_general_fail; }
			ungetwc((wint_t)c, f);
		}
		register int gotmatch = 0;
		switch (t) {
			case 'n':
				store_int(dest, size, (unsigned long long)pos);
				continue;
			case 's':
			case 'c':
			case '[':
				if (t == 'c') {
					if (width < 1) { width = 1; }
					invert = 1;
					set = L"";
				} else if (t == 's') {
					invert = 1;
					set = (const wchar_t[22]) { ' ', '\t', '\n', '\r', 11, 12, 0x85, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2008, 0x2009, 0x200a, 0x2028, 0x2029, 0x205f, 0x3000, 0 };
				} else {
					if (*++p == '^') { ++p; invert = 1; }
					else { invert = 0; }
					set = p;
					if (*p == ']') { ++p; }
					while (*p != ']') {
						if (!*p) { goto vfwscanf_general_fail; }
						p++;
					}
				}
				s = ((size == SIZE_def) ? dest : 0);
				wcs = ((size == SIZE_l) ? dest : 0);
				if (width < 1) { width = -1; }
				i = 0;
				if (alloc) {
					k = (size_t)((t == 'c') ? width + 1 : 31);
					if (size == SIZE_l) {
						wcs = malloc(k * SIZEOF_WCHAR_T);
						if (!wcs) { goto vfwscanf_general_fail; }
					} else {
						s = malloc(k);
						if (!s) { goto vfwscanf_general_fail; }
					}
				}
				while (width) {
					if ((c = (int)getwc(f)) < 0) { break; }
					else if (in_set(set, c) == invert) { break; }
					else if (wcs) {
						wcs[i++] = c;
						if (alloc && i == k) {
							k += (k + 1);
							wchar_t* tmp = realloc(wcs, k * SIZEOF_WCHAR_T);
							if (!tmp) { goto vfwscanf_general_fail; }
							wcs = tmp;
						}
					} else if (size != SIZE_l) {
						int l = wctomb(s ? s + i : tmp, c);
						if (l < 0) { goto vfwscanf_general_fail; }
						i += (size_t)l;
						if (alloc && i > k - 4) {
							k += (k + 1);
							char* tmp = realloc(s, k);
							if (!tmp) { goto vfwscanf_general_fail; }
							s = tmp;
						}
					}
					++pos;
					width -= (width > 0);
					gotmatch = 1;
				}
				if (width) {
					ungetwc((wint_t)c, f);
					if (t == 'c' || (!gotmatch)) { goto match_fail; }
				}
				if (alloc) {
					if (size == SIZE_l) { *(wchar_t**)dest = wcs; }
					else { *(char**)dest = s; }
				}
				if (t != 'c') {
					if (wcs) { wcs[i] = 0; }
					if (s) { s[i] = 0; }
				}
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'a':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'E':
			case 'F':
			case 'G':
			case 'X':
			case 'p':
				if (width < 1) { width = 0; }
				snprintf(tmp, sizeof(tmp), "%.*s%.0d%s%c%%lln", 1 + (!dest), "%*", width, size_pfx[size + 2], t);
				cnt = 0;
				if (fscanf(f, tmp, (dest ? dest : &cnt), &cnt) == -1) { goto vfwscanf_general_fail; }
				else if (!cnt) { goto match_fail; }
				pos += cnt;
				break;
			default: goto vfwscanf_general_fail;
		}
		if (dest) { ++matches; }
	}
	if (0) {
vfwscanf_general_fail:
		if (!matches) { --matches; }
match_fail:
		if (alloc) { free(s); free(wcs); }
	}
	FUNLOCK(f);
	return matches;
}
#define __isoc99_vfwscanf(f, fmt, ap)   vfwscanf((f), (fmt), (ap))
#define isoc99_vfwscanf(f, fmt, ap)   vfwscanf((f), (fmt), (ap))


/** Reads data from the stream and stores them according to the C wide string format into the locations pointed by the additional arguments */
LIB_FUNC int fwscanf(FILE* restrict f, const wchar_t* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	const int ret = vfwscanf(f, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_fwscanf(f, fmt, ...)   fwscanf((f), (fmt), (__VA_ARGS__))
#define isoc99_fwscanf(f, fmt, ...)   fwscanf((f), (fmt), (__VA_ARGS__))


/** Reads data from ws and stores them according to parameter format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vswscanf(wchar_t* restrict s, const wchar_t* restrict fmt, va_list ap) {
	unsigned char buf[256];
	FILE f = {
		.buf = buf,
		.buf_size = sizeof(buf),
		._cookie = (void*)s,
		.read = wstring_read_helper,
		.lock = -1
	};
	return vfwscanf(&f, fmt, ap);
}
#define __isoc99_vswscanf(s, fmt, ap)   vswscanf((s), (fmt), (ap))
#define isoc99_vswscanf(s, fmt, ap)   vswscanf((s), (fmt), (ap))


/** Reads data from the wide string `s` and stores them according to parameter format into the locations given by the additional arguments, as if wscanf was used, but reading from `s` instead of the standard input (stdin) */
LIB_FUNC int swscanf(wchar_t* restrict s, const wchar_t* restrict fmt, ...) {
	va_list ap;
	va_start(ap, fmt);
	const int ret = vswscanf(s, fmt, ap);
	va_end(ap);
	return ret;
}
#define __isoc99_swscanf(s, fmt, ...)   swscanf((s), (fmt), (__VA_ARGS__))
#define isoc99_swscanf(s, fmt, ...)   swscanf((s), (fmt), (__VA_ARGS__))


/** Reads data from the standard input (stdin) and stores them according to the C wide string format into the locations pointed by the elements in the variable argument list */
LIB_FUNC int vwscanf(const wchar_t* restrict fmt, va_list ap) {
	return vfwscanf(stdin, fmt, ap);
}
#define __isoc99_vwscanf(fmt, ap)   vwscanf((fmt), (ap))
#define isoc99_vwscanf(fmt, ap)   vwscanf((fmt), (ap))


/** Reads data from stdin and stores them according to the C wide string format into the locations pointed by the additional arguments */
LIB_FUNC int wscanf(const wchar_t* format, ... ) {
	va_list args;
	va_start(args, format);
	const int result = fwscanf(stdout, format, args );
	va_end (args);
	return result;
}
#define __isoc99_wscanf(fmt, ...)   vwscanf((fmt), (__VA_ARGS__))
#define isoc99_wscanf(fmt, ...)   vwscanf((fmt), (__VA_ARGS__))


/** Write some memory regions; Return zero on success, or EOF on error */
LIB_FUNC int __sfvwrite(FILE* fp, struct __suio* uio) {
	size_t len;
	struct __siov* iov;
	if ((len = (size_t)uio->uio_resid) == 0) { return 0; }
	else if (cantwrite(fp)) { errno = EBADF; return EOF; }
	int w, s, nlknown, nldist;
	char* nl;
	iov = uio->uio_iov;
	char* p = iov->iov_base;
	len = iov->iov_len;
	++iov;
#   define GETIOV(extra_work)   while (len == 0) { extra_work; p = iov->iov_base; len = iov->iov_len; iov++; }
	if (fp->flags & (unsigned int)__SNBF) {  // Unbuffered: write up to BUFSIZ bytes at a time
		do {
			GETIOV(;);
			w = (int)(*fp->write)(fp->_cookie, (unsigned char*)p, (size_t)MIN(len, (size_t)BUFSIZ));
			if (w <= 0) { goto __sfvwrite_err; }
			p += w;
			len -= (size_t)w;
		} while ((uio->uio_resid -= w) != 0);
	} else if ((fp->flags & (unsigned int)__SLBF) == 0) {  // Fully buffered
		do {
			GETIOV(;);
			if ((fp->flags & (unsigned int)(__SALC | __SSTR)) == (__SALC | __SSTR) && (size_t)fp->_w < len) {
				const size_t blen = (size_t)(fp->_p - fp->_bf._base);
				unsigned char* _base;
				int _size = fp->_bf._size;
				do { _size = (_size << 1) + 1; } while (_size < (int)(blen + len));
				_base = realloc(fp->_bf._base, (size_t)(_size + 1));
				if (_base == NULL) { goto __sfvwrite_err; }
				fp->_w += (int)(_size - fp->_bf._size);
				fp->_bf._base = _base;
				fp->_bf._size = _size;
				fp->_p = _base + blen;
			}
			w = fp->_w;
			if (fp->flags & (unsigned int)__SSTR) {
				if (len < (size_t)w) { w = (int)len; }
				COPY(w);
				fp->_w -= w;
				fp->_p += w;
				w = (int)len;
			} else if (fp->_p > fp->_bf._base && len > (size_t)w) {
				COPY(w);
				fp->_p += w;
				if (__sflush(fp)) { goto __sfvwrite_err; }
			} else if (len >= (size_t)(w = (int)fp->_bf._size)) {
				w = (int)(*fp->write)(fp->_cookie, (unsigned char*)p, (size_t)w);
				if (w <= 0) { goto __sfvwrite_err; }
			} else {
				w = (int)len;
				COPY(w);
				fp->_w -= w;
				fp->_p += w;
			}
			p += w;
			len -= (size_t)w;
		} while ((uio->uio_resid -= w) != 0);
	} else {  // Line buffered: like fully buffered, but check for newlines
		nlknown = 0;
		nldist = 0;
		do {
			GETIOV(nlknown = 0);
			if (!nlknown) {
				nl = memchr_nonconst((void*)p, '\n', len);
				nldist = (int)(nl ? (int)(nl + 1 - p) : (int)(len + 1));
				nlknown = 1;
			}
			s = (int)MIN((int)len, nldist);
			w = fp->_w + fp->_bf._size;
			if (fp->_p > fp->_bf._base && s > w) {
				COPY(w);
				fp->_p += w;
				if (__sflush(fp)) { goto __sfvwrite_err; }
			} else if (s >= (w = fp->_bf._size)) {
				w = (int)(*fp->write)(fp->_cookie, (unsigned char*)p, (size_t)w);
				if (w <= 0) { goto __sfvwrite_err; }
			} else {
				w = s;
				COPY(w);
				fp->_w -= w;
				fp->_p += w;
			}
			if ((nldist -= w) == 0) {
				if (__sflush(fp)) { goto __sfvwrite_err; }
				nlknown = 0;
			}
			p += w;
			len -= (size_t)w;
		} while ((uio->uio_resid -= w) != 0);
	}
	return 0;
__sfvwrite_err:
	fp->flags |= (unsigned int)__SERR;
	return EOF;
#   undef GETIOV
}


LIB_FUNC void pop_arg(union printf_arg* arg, int type, va_list* ap) {
	if ((unsigned)type > PRINTF_MAXSTATE) { return; }
	switch (type) {
		case PRINTF_PTR: arg->p = va_arg(*ap, void*); break;
		case PRINTF_INT: arg->i = (uintmax_t)va_arg(*ap, int); break;
		case PRINTF_UINT: arg->i = (uintmax_t)va_arg(*ap, unsigned int); break;
#ifndef LONG_IS_INT
		case PRINTF_LONG: arg->i = (uintmax_t)va_arg(*ap, long);
		case PRINTF_ULONG: arg->i = (uintmax_t)va_arg(*ap, unsigned long); break;
#endif
		case PRINTF_ULLONG: arg->i = (uintmax_t)va_arg(*ap, unsigned long long); break;
		case PRINTF_SHORT: arg->i = (unsigned short)va_arg(*ap, int); break;
		case PRINTF_USHORT: arg->i = (unsigned short)va_arg(*ap, int); break;
		case PRINTF_CHAR: arg->i = (unsigned char)va_arg(*ap, int); break;
		case PRINTF_UCHAR: arg->i = (unsigned char)va_arg(*ap, int); break;
#ifdef ODD_TYPES
		case PRINTF_LLONG: arg->i = (uintmax_t)va_arg(*ap, long long); break;
		case PRINTF_SIZET: arg->i = (uintmax_t)va_arg(*ap, size_t); break;
		case PRINTF_IMAX: arg->i = (uintmax_t)va_arg(*ap, intmax_t); break;
		case PRINTF_UMAX: arg->i = (uintmax_t)va_arg(*ap, uintmax_t); break;
		case PRINTF_PDIFF: arg->i = (uintmax_t)va_arg(*ap, ptrdiff_t); break;
		case PRINTF_UIPTR: arg->i = (uintptr_t)va_arg(*ap, void*); break;
#endif
		case PRINTF_DBL: arg->f = va_arg(*ap, double); break;
		case PRINTF_LDBL: arg->f = va_arg(*ap, long double); break;
		default: break;
	}
}


LIB_FUNC int wprintf_core(FILE* f, const wchar_t* fmt, va_list* ap, union printf_arg* nl_arg, int* nl_type) {
	const wchar_t *a, *z, *s = (const wchar_t*)fmt;
	unsigned int l10n = 0, litpct, _fl, st, ps;
	union printf_arg arg;
	int argpos, cnt = 0, l = 0, i, t, w, p;
	char* bs;
	char charfmt[16] = { 0 };
	wchar_t wc;
	LOOP_FOREVER {
		if (cnt >= 0) {
			if (l > INT_MAX - cnt) {
				if (!ferror(f)) { errno = EOVERFLOW; }
				cnt = -1;
			} else { cnt += l; }
		}
		if (!*s) { break; }
		for (a = s; *s && *s != '%'; s++);
		litpct = (unsigned int)wcsspn(s, L"%") / 2;
		z = s + litpct;
		s += 2 * litpct;
		l = (int)(z - a);
		if (f) { out_wchar(f, a, (size_t)l); }
		else if (l) { continue; }
		if (iswdigit(s[1]) && s[2] == '$') {
			l10n = 1;
			argpos = s[1] - '0';
			s += 3;
		} else { argpos = -1; s++; }
		// Read modifier flags
		for (_fl = 0; ((unsigned)*s - ' ' < 32) && (FLAGMASK & (1U << (*s - ' '))); s++) {
			_fl |= (unsigned int)(1U << (*s - ' '));
		}
		// Read field width
		if (*s == '*') {
			if (iswdigit(s[1]) && s[2] == '$') {
				l10n = 1;
				nl_type[s[1] - '0'] = PRINTF_INT;
				w = (int)nl_arg[s[1] - '0'].i;
				s += 3;
			} else if (!l10n) {
				w = f ? va_arg(*ap, int) : 0;
				s++;
			} else { return -1; }
			if (w < 0) { _fl |= (unsigned int)LEFT_ADJ; w = -w; }
		} else if ((w = getint((const char**)&s)) < 0) { return -1; }
		// Read precision
		if (*s == '.' && s[1] == '*') {
			if (isdigit(s[2]) && s[3] == '$') {
				nl_type[s[2] - '0'] = PRINTF_INT;
				p = (int)nl_arg[s[2] - '0'].i;
				s += 4;
			} else if (!l10n) {
				p = f ? va_arg(*ap, int) : 0;
				s += 2;
			} else { return -1; }
		} else if (*s == '.') {
			s++;
			p = getint((const char**)&s);
		} else { p = -1; }
		// Format specifier state machine
		st = 0;
		do {
			if (OOB(*s)) { return -1; }
			ps = st;
			st = printf_states[st]sub_ascii_a(*s++);
		} while (st - 1 < PRINTF_STOP);
		if (!st) { return -1; }
		/* Check validity of argument type (nl/normal) */
		if (st == PRINTF_NOARG) {
			if (argpos >= 0) { return -1; }
		} else {
			if (argpos >= 0) { nl_type[argpos] = (int)st; arg = nl_arg[argpos]; }
			else if (f) { pop_arg(&arg, (int)st, ap); }
			else { return 0; }
		}
		if (!f) { continue; }
		t = s[-1];
		if (ps && (t & 15) == 3) { t &= (~32); }
		UNUSED char wprintf_core_null[8] = { '(', 'n', 'u', 'l', 'l', ')', '\0' };
		switch (t) {
			case 'n':
				switch (ps) {
					case PRINTF_BARE: *(int*)arg.p = cnt; break;
					case PRINTF_LPRE: *(long*)arg.p = cnt; break;
					case PRINTF_LLPRE: *(long long*)arg.p = cnt; break;
					case PRINTF_HPRE: *(unsigned short*)arg.p = (unsigned short)cnt; break;
					case PRINTF_HHPRE: *(unsigned char*)arg.p = (unsigned char)cnt; break;
					case PRINTF_ZTPRE: *(size_t*)arg.p = (size_t)cnt; break;
					case PRINTF_JPRE: *(uintmax_t*)arg.p = (uintmax_t)cnt; break;
					default: break;
				}
				continue;
			case 'c':
				fputwc((wchar_t)btowc((int)arg.i), f);
				l = 1;
				continue;
			case 'C':
				fputwc((wchar_t)arg.i, f);
				l = 1;
				continue;
			case 'S':
				a = arg.p;
				z = wmemchr(a, 0, (size_t)p);
				if (z) { p = (int)(z - a); }
				if (w < p) { w = p; }
				if (!(_fl & LEFT_ADJ)) { fprintf(f, "%.*s", w - p, ""); }
				out_wchar(f, a, (size_t)p);
				if ((_fl & LEFT_ADJ)) { fprintf(f, "%.*s", w - p, ""); }
				l = w;
				continue;
			case 'm':
				arg.p = strerror(errno);
			case 's':
				if (!arg.p) { arg.p = wprintf_core_null; }
				bs = arg.p;
				if (p < 0) { p = INT_MAX; }
				for (i = l = 0; l < p && (i = mbtowc(&wc, bs, MB_LEN_MAX)) > 0; bs += i, l++);
				if (i < 0) { return -1; }
				p = l;
				if (w < p) { w = p; }
				if (!(_fl & LEFT_ADJ)) { fprintf(f, "%.*s", (w - p), ""); }
				bs = arg.p;
				while (l--) {
					i = mbtowc(&wc, bs, MB_LEN_MAX);
					bs += i;
					fputwc(wc, f);
				}
				if ((_fl & LEFT_ADJ)) { fprintf(f, "%.*s", (w - p), ""); }
				l = w;
				continue;
			default: break;
		}
		snprintf(charfmt, sizeof(charfmt), "%%%s%s%s%s%s*.*%c%c", "#" + !(_fl & ALT_FORM), "+" + !(_fl & MARK_POS), "-" + !(_fl & LEFT_ADJ), " " + !(_fl & PAD_POS), "0" + !(_fl & ZERO_PAD), sizeprefix[(t | 32) - 'a'], t);
		switch (t | 32) {
			case 'a':
			case 'e':
			case 'f':
			case 'g':
				l = fprintf(f, charfmt, w, p, arg.f);
				break;
			case 'd':
			case 'i':
			case 'o':
			case 'u':
			case 'x':
			case 'p':
				l = fprintf(f, charfmt, w, p, arg.i);
				break;
			default: break;
		}
	}
	if (f) { return cnt; }
	else if (!l10n) { return 0; }
	for (i = 1; i <= NL_ARGMAX && nl_type[i]; i++) { pop_arg((nl_arg + i), nl_type[i], ap); }
	for (; i <= NL_ARGMAX && (!nl_type[i]); i++);
	if (i <= NL_ARGMAX) { return -1; }
	return 1;
}


/** Writes the C wide string pointed by `fmt` to the stream, replacing any format specifier in the same way as printf does, but using the elements in the variable argument list identified by `ap` instead of additional function arguments */
LIB_FUNC int vfwprintf(FILE* restrict f, const wchar_t* restrict fmt, va_list ap) {
	va_list ap2;
	int nl_type[NL_ARGMAX] = { 0 };
	union printf_arg nl_arg[NL_ARGMAX];
	va_copy(ap2, ap);
	if (wprintf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) { va_end(ap2); return -1; }
	FLOCK(f);
	fwide(f, 1);
	const int olderr = (f->flags & (unsigned int)F_ERR);
	f->flags &= (unsigned int)(~F_ERR);
	int ret = wprintf_core(f, fmt, &ap2, nl_arg, nl_type);
	if (f->flags & (unsigned int)F_ERR) { ret = -1; }
	f->flags |= (unsigned int)olderr;
	FUNLOCK(f);
	va_end(ap2);
	return ret;
}
#define __vfwprintf(f, fmt, ap)   vfwprintf((f), (fmt), (ap))


/** Composes a string with the same text that would be printed if `fmt` was used on wprintf, but using the elements in the variable argument list identified by `ap` instead of additional function arguments and storing the resulting content as a C wide string in the buffer pointed by `s` (taking `n` as the maximum buffer capacity to fill, expressed in wide characters) */
LIB_FUNC int vswprintf(wchar_t* restrict s, const size_t n, const wchar_t* restrict fmt, va_list ap) {
	if (n == 0) { errno = EINVAL; return -1; }
	FILE f;
	unsigned char buf[256] = { 0 };
	struct cookie c = { s, (n - 1) };
	memset_no_output(&f, 0, SIZEOF_FILE);
	f.lbf = EOF;
	f.flags = (unsigned int)(__SWR | __SSTR | __SALC);
	f.write = &sw_write_helper;
	f.buf_size = sizeof(buf);
	f.buf = buf;
	f.lock = -1;
	f._cookie = &c;
	if (!n) { return -1; }
	else if (n > INT_MAX) { errno = EOVERFLOW; return -1; }
	const int r = vfwprintf(&f, fmt, ap);
	sw_write(&f, 0, 0);
	return (int)((size_t)r >= n ? -1 : r);
}
#define _IO_vswprintf(_string, maxlen, format, args)   vswprintf((_string), (maxlen), (format), (args))
#define _vswprintf(_string, maxlen, format, args)   vswprintf((_string), (maxlen), (format), (args))
#define __vswprintf(_string, maxlen, format, args)   vswprintf((_string), (maxlen), (format), (args))
#define vsprintfW(_string, maxlen, format, args)   vswprintf((_string), (maxlen), (format), (args))


/** Writes the C wide string pointed by `fmt` to the standard output (stdout), replacing any format specifier in the same way as printf does, but using the elements in the variable argument list instead of additional function arguments */
LIB_FUNC int vwprintf(const wchar_t* format, va_list arg) {
	return vfwprintf(stdout, format, arg);
}


/** Writes the C wide string pointed by `format` to the stream; If `format` includes format specifiers (subsequences beginning with %), the additional arguments following `format` are formatted and inserted in the resulting string replacing their respective specifiers */
LIB_FUNC int fwprintf(FILE* stream, const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vfwprintf(stream, format, args);
	va_end(args);
	return result;
}


/** Writes the C wide string pointed by format to the standard output (stdout), replacing any format specifier in the same way as printf does */
LIB_FUNC int wprintf(const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vwprintf(format, args);
	va_end(args);
	return result;
}


/** Composes a wide string with the same text that would be printed if format was used on wprintf, but instead of being printed, the content is stored as a C wide string in the buffer pointed by `s` */
LIB_FUNC int swprintf(wchar_t* s, const size_t len, const wchar_t* format, ...) {
	va_list args;
	va_start(args, format);
	int result = vswprintf(s, len, format, args);
	va_end(args);
	return result;
}


/* TODO: Add WCHAR functions
size_t mbsnrtowcs(wchar_t* restrict, const char** restrict, size_t, size_t, mbstate_t* restrict);
wchar_t* wcpcpy(wchar_t* restrict, const wchar_t* restrict);
wchar_t* wcpncpy(wchar_t* restrict, const wchar_t* restrict, size_t);
int wcscasecmp(const wchar_t*, const wchar_t*);
int wcscasecmp_l(const wchar_t*, const wchar_t*, locale_t);
int wcscoll(const wchar_t*, const wchar_t*);
int wcscoll_l(const wchar_t*, const wchar_t*, locale_t);
wchar_t* wcsdup(const wchar_t*);
wcslen(const wchar_t*);
int wcsncasecmp(const wchar_t*, const wchar_t*, size_t);
int wcsncasecmp_l(const wchar_t*, const wchar_t*, size_t, locale_t);
wchar_t* wcsncat(wchar_t* restrict, const wchar_t* restrict, size_t);
size_t wcsnrtombs(char* restrict, const wchar_t** restrict, size_t, size_t, mbstate_t* restrict);
wchar_t* wcstok(wchar_t* restrict, const wchar_t* restrict, wchar_t** restrict);
size_t wcsxfrm_l(wchar_t* restrict, const wchar_t* restrict, size_t, locale_t);
wchar_t* wmemset(wchar_t*, wchar_t, size_t);
*/


#endif  // WCHAR_H


/* MULTI-BYTE CHARACTER TYPE (MB-CTYPE) & CODESET CONVERSION FACILITY (<iconv.h>) */


#if (!(defined(MBCTYPE_H) || defined(MBCTYPE_H_) || defined(_MBCTYPE_H) || defined(_MBCTYPE_H_) || defined(_ICONV_H) || defined(_ICONV_H_) || defined(_GCONV_H) || defined(_GCONV_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/iconv.h.html
#define MBCTYPE_H   (1)
#define MBCTYPE_H_   (1)
#define _MBCTYPE_H   (1)
#define _MBCTYPE_H_   (1)
#define ICONV_H   (1)
#define _ICONV_H   (1)
#define _ICONV_H_   (1)
#define GCONV_H   (1)
#define _GCONV_H   (1)
#define _GCONV_H_   (1)
#define _UTF8_H   (1)
#define _UTF8_H_   (1)


#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
#   error   "The character set is not based on ISO-646"
#endif
#define TOTAL_KEYWORDS   345
#define MIN_WORD_LENGTH   2
#define MAX_WORD_LENGTH   45
#define MIN_HASH_VALUE   17
#define MAX_HASH_VALUE   926
#define UTF7_ENCODE_OPTIONAL_CHARS   1
/** Escape character used for JIS encoding */
#define MB_ESC_CHAR   0x1B
// Functions used to support SHIFT_JIS, EUC-JP, and JIS multibyte encodings
#define _isjis(c)   (((c) >= 0x21) && ((c) <= 0x7e))
#define isjis(c)   _isjis((c))
#define _issjis1(c)   ((((c) >= 0x81) && ((c) <= 0x9F)) || (((c) >= 0xE0) && ((c) <= 0xEF)))
#define issjis1(c)   _issjis1((c))
#define _issjis2(c)   ((((c) >= 0x40) && ((c) <= 0x7E)) || (((c) >= 0x80) && ((c) <= 0xFC)))
#define issjis2(c)   _issjis2((c))
#define _iseucjp1(c)   (((c) == 0x8E) || ((c) == 0x8F) || (((c) >= 0xA1) && ((c) <= 0xFE)))
#define iseucjp1(c)   _iseucjp1((c))
#define _iseucjp2(c)   (((c) >= 0xA1) && ((c) <= 0xFE))
#define iseucjp2(c)   _iseucjp2((c))
#define ic_from(x)   (((x)) & 0xffff)
#define ic_to(x)   (((x) >> 16) & 0xffff)
/** Return code if invalid */
#define RET_ILSEQ   -1
/** Return code if only a shift sequence of n bytes was read */
#define RET_TOOFEW(n)   (-2 - (n))
/** Return code if invalid */
#define RET_ILUNI   -1
/** Return code if output buffer is too small */
#define RET_TOOSMALL   -2
#define ISBADF(_h_)   (!(_h_) || (_h_) == (iconv_t)-1)
/** ISO 10646 value used to signal invalid value */
#define __UNKNOWN_10646_CHAR   ((wchar_t)0xfffd)
#define GCONVCACHE_MAGIC   0x20010324
#define GCONV_MODULES_CACHE   GCONV_DIR "/gconv-modules.cache"
#define mbrtowc_utf8   mbrtowc
#define wctomb_utf8   wctomb


enum charset {
	INVALID_CHARSET = 0,
	ISO_8859_1, UTF_8,
	UCS_2, UCS_4,
	UTF_16_BE, UTF_16_LE, UTF_16
};


/** Error codes for gconv functions */
typedef enum GCONV_ERR {
	__GCONV_OK = 0,
	__GCONV_NOCONV, __GCONV_NODB, __GCONV_NOMEM,
	__GCONV_EMPTY_INPUT, __GCONV_FULL_OUTPUT, __GCONV_ILLEGAL_INPUT,
	__GCONV_INCOMPLETE_INPUT, __GCONV_ILLEGAL_DESCRIPTOR, __GCONV_INTERNAL_ERROR
} gconv_err_t;


/** Flags the `__gconv_open` function can set */
typedef enum GCONV_FLAGS {
	__GCONV_IS_LAST = 1,
	__GCONV_IGNORE_ERRORS = 2,
	__GCONV_SWAP = 4,
	__GCONV_TRANSLIT = 8
} gconv_flags_t;


/** Conversion Flavors */
typedef enum BEOS_CONVERSION_FLAVORS {
	B_ISO1_CONVERSION,  // ISO 8859-x
	B_ISO2_CONVERSION,
	B_ISO3_CONVERSION,
	B_ISO4_CONVERSION,
	B_ISO5_CONVERSION,
	B_ISO6_CONVERSION,
	B_ISO7_CONVERSION,
	B_ISO8_CONVERSION,
	B_ISO9_CONVERSION,
	B_ISO10_CONVERSION,
	B_MAC_ROMAN_CONVERSION,  // Macintosh Roman
	B_SJIS_CONVERSION,  // Shift-JIS
	B_EUC_CONVERSION,  // EUC Packed Japanese
	B_JIS_CONVERSION,  // JIS X 0208-1990
	B_MS_WINDOWS_CONVERSION,  // Windows Latin-1 Codepage 1252
	B_UNICODE_CONVERSION,  // Unicode 2.0, UCS-2
	B_KOI8R_CONVERSION,  // KOI8-R
	B_MS_WINDOWS_1251_CONVERSION,  // Windows Cyrillic Codepage 1251
	B_MS_DOS_866_CONVERSION,  // MS-DOS Codepage 866
	B_MS_DOS_CONVERSION,  // MS-DOS Codepage 437
	B_EUC_KR_CONVERSION,  // EUC Korean
	B_ISO13_CONVERSION,
	B_ISO14_CONVERSION,
	B_ISO15_CONVERSION,
	B_BIG5_CONVERSION,  // Chinese Big5
	B_GBK_CONVERSION,  // Chinese GB18030
	B_UTF16_CONVERSION,  // Unicode UTF-16
	B_MS_WINDOWS_1250_CONVERSION  // Windows Central European Codepage
} beos_conversion_flavors_t;


/** CJK character set datatype */
typedef struct Summary16 {
	unsigned short indx;  // Index into big table */
	unsigned short used_entries;  // Bitmask of used entries */
} Summary16;


typedef struct attr_packed gconvcache_header {
	uint32_t magic;
	gidx_t string_offset, hash_offset, hash_size, module_offset, otherconv_offset;
} gconvcache_header_t;


typedef struct hash_entry { gidx_t string_offset, module_idx; }   hash_entry_t;


typedef struct module_entry {
	gidx_t canonname_offset, fromdir_offset, fromname_offset;
	gidx_t todir_offset, toname_offset, extra_offset;
} module_entry_t;


typedef struct extra_entry {
	gidx_t module_cnt;
	struct extra_entry_module {
		gidx_t outname_offset, dir_offset, name_offset;
	} module[1];
} extra_entry_t;


typedef struct attr_packed charseq { int length; char* data; }   CharSeq;


typedef struct convtable {
	int term[32];
	union {
		struct convtable* sub;
		struct charseq* out;
	} val[256];
} convtable_t;


typedef struct encoding_alias { int name; unsigned int encoding_index; }   encoding_alias_t;


typedef struct stringpool_t {
	char stringpool_str17[sizeof("L6")];
	char stringpool_str18[sizeof("CN")];
	char stringpool_str19[sizeof("L1")];
	char stringpool_str25[sizeof("SJIS")];
	char stringpool_str27[sizeof("L4")];
	char stringpool_str29[sizeof("L5")];
	char stringpool_str30[sizeof("R8")];
	char stringpool_str35[sizeof("L8")];
	char stringpool_str36[sizeof("866")];
	char stringpool_str45[sizeof("L2")];
	char stringpool_str51[sizeof("ISO-IR-6")];
	char stringpool_str54[sizeof("CP866")];
	char stringpool_str60[sizeof("MAC")];
	char stringpool_str64[sizeof("C99")];
	char stringpool_str65[sizeof("ISO-IR-166")];
	char stringpool_str67[sizeof("LATIN6")];
	char stringpool_str70[sizeof("CP154")];
	char stringpool_str71[sizeof("LATIN1")];
	char stringpool_str72[sizeof("ISO646-CN")];
	char stringpool_str78[sizeof("CYRILLIC")];
	char stringpool_str79[sizeof("ISO-IR-14")];
	char stringpool_str84[sizeof("CP1256")];
	char stringpool_str85[sizeof("IBM866")];
	char stringpool_str86[sizeof("HZ")];
	char stringpool_str87[sizeof("LATIN4")];
	char stringpool_str88[sizeof("CP1251")];
	char stringpool_str89[sizeof("ISO-IR-165")];
	char stringpool_str91[sizeof("LATIN5")];
	char stringpool_str92[sizeof("862")];
	char stringpool_str93[sizeof("ISO-IR-126")];
	char stringpool_str95[sizeof("ISO-IR-144")];
	char stringpool_str96[sizeof("CP819")];
	char stringpool_str101[sizeof("MS-CYRL")];
	char stringpool_str103[sizeof("LATIN8")];
	char stringpool_str104[sizeof("CP1254")];
	char stringpool_str105[sizeof("ISO-IR-58")];
	char stringpool_str106[sizeof("CP949")];
	char stringpool_str108[sizeof("CP1255")];
	char stringpool_str110[sizeof("CP862")];
	char stringpool_str111[sizeof("ISO-IR-148")];
	char stringpool_str112[sizeof("PT154")];
	char stringpool_str113[sizeof("LATIN-9")];
	char stringpool_str115[sizeof("ISO-IR-149")];
	char stringpool_str117[sizeof("ISO-IR-159")];
	char stringpool_str118[sizeof("L3")];
	char stringpool_str119[sizeof("ISO-IR-226")];
	char stringpool_str120[sizeof("CP1258")];
	char stringpool_str123[sizeof("LATIN2")];
	char stringpool_str124[sizeof("ISO8859-6")];
	char stringpool_str125[sizeof("ISO-IR-199")];
	char stringpool_str127[sizeof("IBM819")];
	char stringpool_str128[sizeof("ISO8859-1")];
	char stringpool_str130[sizeof("ISO-8859-6")];
	char stringpool_str131[sizeof("ISO_8859-6")];
	char stringpool_str132[sizeof("ISO8859-16")];
	char stringpool_str134[sizeof("ISO-8859-1")];
	char stringpool_str135[sizeof("ISO_8859-1")];
	char stringpool_str136[sizeof("ISO8859-11")];
	char stringpool_str138[sizeof("ISO-8859-16")];
	char stringpool_str139[sizeof("ISO_8859-16")];
	char stringpool_str140[sizeof("CP1252")];
	char stringpool_str141[sizeof("IBM862")];
	char stringpool_str142[sizeof("ISO-8859-11")];
	char stringpool_str143[sizeof("ISO_8859-11")];
	char stringpool_str144[sizeof("ISO8859-4")];
	char stringpool_str145[sizeof("MACCYRILLIC")];
	char stringpool_str146[sizeof("ISO_8859-16:2001")];
	char stringpool_str148[sizeof("ISO8859-5")];
	char stringpool_str149[sizeof("CP1361")];
	char stringpool_str150[sizeof("ISO-8859-4")];
	char stringpool_str151[sizeof("ISO_8859-4")];
	char stringpool_str152[sizeof("ISO8859-14")];
	char stringpool_str153[sizeof("ISO-IR-101")];
	char stringpool_str154[sizeof("ISO-8859-5")];
	char stringpool_str155[sizeof("ISO_8859-5")];
	char stringpool_str156[sizeof("ISO8859-15")];
	char stringpool_str157[sizeof("CP936")];
	char stringpool_str158[sizeof("ISO-8859-14")];
	char stringpool_str159[sizeof("ISO_8859-14")];
	char stringpool_str160[sizeof("ISO8859-8")];
	char stringpool_str161[sizeof("L7")];
	char stringpool_str162[sizeof("ISO-8859-15")];
	char stringpool_str163[sizeof("ISO_8859-15")];
	char stringpool_str164[sizeof("ISO8859-9")];
	char stringpool_str165[sizeof("VISCII")];
	char stringpool_str166[sizeof("ISO-8859-8")];
	char stringpool_str167[sizeof("ISO_8859-8")];
	char stringpool_str168[sizeof("RK1048")];
	char stringpool_str169[sizeof("TCVN")];
	char stringpool_str170[sizeof("ISO-8859-9")];
	char stringpool_str171[sizeof("ISO_8859-9")];
	char stringpool_str172[sizeof("ISO_8859-14:1998")];
	char stringpool_str174[sizeof("ISO_8859-15:1998")];
	char stringpool_str176[sizeof("EUCCN")];
	char stringpool_str177[sizeof("US")];
	char stringpool_str178[sizeof("PTCP154")];
	char stringpool_str180[sizeof("ISO8859-2")];
	char stringpool_str181[sizeof("MS936")];
	char stringpool_str182[sizeof("EUC-CN")];
	char stringpool_str183[sizeof("CHAR")];
	char stringpool_str184[sizeof("CSVISCII")];
	char stringpool_str186[sizeof("ISO-8859-2")];
	char stringpool_str187[sizeof("ISO_8859-2")];
	char stringpool_str189[sizeof("ISO-IR-109")];
	char stringpool_str191[sizeof("L10")];
	char stringpool_str192[sizeof("ASCII")];
	char stringpool_str195[sizeof("UHC")];
	char stringpool_str202[sizeof("ISO-IR-138")];
	char stringpool_str203[sizeof("KOI8-R")];
	char stringpool_str204[sizeof("850")];
	char stringpool_str210[sizeof("CSASCII")];
	char stringpool_str213[sizeof("CP932")];
	char stringpool_str214[sizeof("X0212")];
	char stringpool_str215[sizeof("UCS-4")];
	char stringpool_str216[sizeof("CSKOI8R")];
	char stringpool_str218[sizeof("CP874")];
	char stringpool_str221[sizeof("CSPTCP154")];
	char stringpool_str227[sizeof("MS-ANSI")];
	char stringpool_str228[sizeof("GB2312")];
	char stringpool_str231[sizeof("ISO646-US")];
	char stringpool_str233[sizeof("CSUCS4")];
	char stringpool_str234[sizeof("CP850")];
	char stringpool_str235[sizeof("ISO-IR-110")];
	char stringpool_str236[sizeof("CP950")];
	char stringpool_str241[sizeof("BIG5")];
	char stringpool_str242[sizeof("ISO-2022-CN")];
	char stringpool_str243[sizeof("LATIN10")];
	char stringpool_str244[sizeof("X0201")];
	char stringpool_str245[sizeof("ISO-CELTIC")];
	char stringpool_str246[sizeof("CYRILLIC-ASIAN")];
	char stringpool_str247[sizeof("BIG-5")];
	char stringpool_str248[sizeof("CSISO2022CN")];
	char stringpool_str249[sizeof("ISO-IR-179")];
	char stringpool_str251[sizeof("UCS-2")];
	char stringpool_str252[sizeof("CP1250")];
	char stringpool_str253[sizeof("KOI8-T")];
	char stringpool_str255[sizeof("ROMAN8")];
	char stringpool_str256[sizeof("ISO_8859-10:1992")];
	char stringpool_str257[sizeof("TIS620")];
	char stringpool_str258[sizeof("CSISOLATIN6")];
	char stringpool_str260[sizeof("CSBIG5")];
	char stringpool_str261[sizeof("MACINTOSH")];
	char stringpool_str262[sizeof("CSISOLATIN1")];
	char stringpool_str263[sizeof("TIS-620")];
	char stringpool_str265[sizeof("IBM850")];
	char stringpool_str266[sizeof("CN-BIG5")];
	char stringpool_str268[sizeof("MACROMAN")];
	char stringpool_str269[sizeof("LATIN3")];
	char stringpool_str271[sizeof("ISO-2022-CN-EXT")];
	char stringpool_str276[sizeof("X0208")];
	char stringpool_str277[sizeof("CSISOLATINCYRILLIC")];
	char stringpool_str278[sizeof("CSISOLATIN4")];
	char stringpool_str279[sizeof("GEORGIAN-PS")];
	char stringpool_str281[sizeof("ARMSCII-8")];
	char stringpool_str282[sizeof("CSISOLATIN5")];
	char stringpool_str283[sizeof("CN-GB-ISOIR165")];
	char stringpool_str286[sizeof("CP1253")];
	char stringpool_str291[sizeof("CSIBM866")];
	char stringpool_str293[sizeof("ELOT_928")];
	char stringpool_str294[sizeof("VISCII1.1-1")];
	char stringpool_str299[sizeof("ISO_646.IRV:1991")];
	char stringpool_str300[sizeof("ISO8859-10")];
	char stringpool_str303[sizeof("KSC_5601")];
	char stringpool_str306[sizeof("ISO-8859-10")];
	char stringpool_str307[sizeof("ISO_8859-10")];
	char stringpool_str310[sizeof("GB_1988-80")];
	char stringpool_str312[sizeof("JP")];
	char stringpool_str314[sizeof("CSISOLATIN2")];
	char stringpool_str317[sizeof("ISO-IR-100")];
	char stringpool_str318[sizeof("EUCKR")];
	char stringpool_str319[sizeof("GBK")];
	char stringpool_str322[sizeof("KZ-1048")];
	char stringpool_str324[sizeof("EUC-KR")];
	char stringpool_str326[sizeof("ISO8859-3")];
	char stringpool_str328[sizeof("UTF-16")];
	char stringpool_str330[sizeof("MACTHAI")];
	char stringpool_str332[sizeof("ISO-8859-3")];
	char stringpool_str333[sizeof("ISO_8859-3")];
	char stringpool_str334[sizeof("ISO8859-13")];
	char stringpool_str336[sizeof("CSKZ1048")];
	char stringpool_str340[sizeof("ISO-8859-13")];
	char stringpool_str341[sizeof("ISO_8859-13")];
	char stringpool_str343[sizeof("ISO-10646-UCS-4")];
	char stringpool_str345[sizeof("KS_C_5601-1989")];
	char stringpool_str346[sizeof("HP-ROMAN8")];
	char stringpool_str349[sizeof("CP1133")];
	char stringpool_str352[sizeof("CSISO14JISC6220RO")];
	char stringpool_str353[sizeof("TIS620-0")];
	char stringpool_str355[sizeof("LATIN7")];
	char stringpool_str356[sizeof("UTF-8")];
	char stringpool_str357[sizeof("ISO-IR-57")];
	char stringpool_str361[sizeof("ISO-10646-UCS-2")];
	char stringpool_str363[sizeof("ISO-IR-87")];
	char stringpool_str365[sizeof("ISO-IR-157")];
	char stringpool_str366[sizeof("ISO_8859-4:1988")];
	char stringpool_str368[sizeof("ISO_8859-5:1988")];
	char stringpool_str372[sizeof("CP1257")];
	char stringpool_str374[sizeof("ISO_8859-8:1988")];
	char stringpool_str375[sizeof("US-ASCII")];
	char stringpool_str377[sizeof("ISO-IR-203")];
	char stringpool_str378[sizeof("ISO_8859-9:1989")];
	char stringpool_str381[sizeof("ISO-IR-127")];
	char stringpool_str382[sizeof("UNICODE-1-1")];
	char stringpool_str384[sizeof("ISO-2022-KR")];
	char stringpool_str386[sizeof("MULELAO-1")];
	char stringpool_str387[sizeof("TIS620.2529-1")];
	char stringpool_str388[sizeof("CSUNICODE11")];
	char stringpool_str389[sizeof("ECMA-114")];
	char stringpool_str390[sizeof("CSISO2022KR")];
	char stringpool_str395[sizeof("TCVN5712-1")];
	char stringpool_str401[sizeof("MACICELAND")];
	char stringpool_str405[sizeof("ECMA-118")];
	char stringpool_str406[sizeof("CSHPROMAN8")];
	char stringpool_str408[sizeof("GEORGIAN-ACADEMY")];
	char stringpool_str409[sizeof("UCS-4-INTERNAL")];
	char stringpool_str411[sizeof("GB_2312-80")];
	char stringpool_str412[sizeof("ISO8859-7")];
	char stringpool_str413[sizeof("TCVN-5712")];
	char stringpool_str414[sizeof("ISO646-JP")];
	char stringpool_str415[sizeof("CSISOLATINGREEK")];
	char stringpool_str417[sizeof("CN-GB")];
	char stringpool_str418[sizeof("ISO-8859-7")];
	char stringpool_str419[sizeof("ISO_8859-7")];
	char stringpool_str420[sizeof("GB18030")];
	char stringpool_str421[sizeof("WINDOWS-1256")];
	char stringpool_str422[sizeof("CSISOLATINARABIC")];
	char stringpool_str423[sizeof("WINDOWS-1251")];
	char stringpool_str425[sizeof("CP367")];
	char stringpool_str426[sizeof("NEXTSTEP")];
	char stringpool_str427[sizeof("UCS-2-INTERNAL")];
	char stringpool_str431[sizeof("WINDOWS-1254")];
	char stringpool_str432[sizeof("CSMACINTOSH")];
	char stringpool_str433[sizeof("WINDOWS-1255")];
	char stringpool_str434[sizeof("CSGB2312")];
	char stringpool_str439[sizeof("WINDOWS-1258")];
	char stringpool_str441[sizeof("MACCROATIAN")];
	char stringpool_str449[sizeof("WINDOWS-1252")];
	char stringpool_str451[sizeof("CHINESE")];
	char stringpool_str452[sizeof("IBM-CP1133")];
	char stringpool_str454[sizeof("CSISO159JISX02121990")];
	char stringpool_str456[sizeof("IBM367")];
	char stringpool_str457[sizeof("ISO_8859-3:1988")];
	char stringpool_str458[sizeof("SHIFT-JIS")];
	char stringpool_str459[sizeof("SHIFT_JIS")];
	char stringpool_str460[sizeof("CSISOLATIN3")];
	char stringpool_str462[sizeof("MS-EE")];
	char stringpool_str465[sizeof("CSISO57GB1988")];
	char stringpool_str466[sizeof("MS-HEBR")];
	char stringpool_str469[sizeof("KS_C_5601-1987")];
	char stringpool_str470[sizeof("STRK1048-2002")];
	char stringpool_str471[sizeof("KOREAN")];
	char stringpool_str472[sizeof("WCHAR_T")];
	char stringpool_str474[sizeof("JIS_C6220-1969-RO")];
	char stringpool_str478[sizeof("CSPC850MULTILINGUAL")];
	char stringpool_str482[sizeof("ISO_8859-6:1987")];
	char stringpool_str483[sizeof("UTF-32")];
	char stringpool_str484[sizeof("ISO_8859-1:1987")];
	char stringpool_str485[sizeof("BIG5HKSCS")];
	char stringpool_str487[sizeof("JIS_C6226-1983")];
	char stringpool_str489[sizeof("CSISOLATINHEBREW")];
	char stringpool_str490[sizeof("UCS-4LE")];
	char stringpool_str491[sizeof("BIG5-HKSCS")];
	char stringpool_str492[sizeof("CSKSC56011987")];
	char stringpool_str493[sizeof("GREEK8")];
	char stringpool_str496[sizeof("ASMO-708")];
	char stringpool_str499[sizeof("WINDOWS-936")];
	char stringpool_str501[sizeof("CSEUCKR")];
	char stringpool_str503[sizeof("EUCTW")];
	char stringpool_str504[sizeof("CSUNICODE")];
	char stringpool_str505[sizeof("WINDOWS-1250")];
	char stringpool_str508[sizeof("UCS-2LE")];
	char stringpool_str509[sizeof("EUC-TW")];
	char stringpool_str510[sizeof("ISO_8859-2:1987")];
	char stringpool_str512[sizeof("HZ-GB-2312")];
	char stringpool_str514[sizeof("CSISO58GB231280")];
	char stringpool_str517[sizeof("CSPC862LATINHEBREW")];
	char stringpool_str518[sizeof("EUCJP")];
	char stringpool_str522[sizeof("WINDOWS-1253")];
	char stringpool_str524[sizeof("EUC-JP")];
	char stringpool_str526[sizeof("JIS0208")];
	char stringpool_str527[sizeof("ANSI_X3.4-1986")];
	char stringpool_str530[sizeof("UNICODE-1-1-UTF-7")];
	char stringpool_str533[sizeof("KOI8-U")];
	char stringpool_str534[sizeof("CSUNICODE11UTF7")];
	char stringpool_str539[sizeof("KOI8-RU")];
	char stringpool_str540[sizeof("ISO-2022-JP-1")];
	char stringpool_str541[sizeof("TIS620.2533-1")];
	char stringpool_str542[sizeof("CSSHIFTJIS")];
	char stringpool_str543[sizeof("ARABIC")];
	char stringpool_str545[sizeof("ANSI_X3.4-1968")];
	char stringpool_str558[sizeof("MS-TURK")];
	char stringpool_str560[sizeof("WINDOWS-874")];
	char stringpool_str565[sizeof("WINDOWS-1257")];
	char stringpool_str566[sizeof("ISO-2022-JP-2")];
	char stringpool_str568[sizeof("UNICODELITTLE")];
	char stringpool_str569[sizeof("UNICODEBIG")];
	char stringpool_str571[sizeof("CSISO2022JP2")];
	char stringpool_str575[sizeof("JIS_X0212")];
	char stringpool_str579[sizeof("MACTURKISH")];
	char stringpool_str583[sizeof("ISO_8859-7:2003")];
	char stringpool_str584[sizeof("ISO-2022-JP")];
	char stringpool_str587[sizeof("MACROMANIA")];
	char stringpool_str590[sizeof("CSISO2022JP")];
	char stringpool_str597[sizeof("MACARABIC")];
	char stringpool_str599[sizeof("GREEK")];
	char stringpool_str605[sizeof("JIS_X0201")];
	char stringpool_str608[sizeof("UTF-7")];
	char stringpool_str609[sizeof("CSISO87JISX0208")];
	char stringpool_str613[sizeof("UTF-16LE")];
	char stringpool_str623[sizeof("TIS620.2533-0")];
	char stringpool_str626[sizeof("ISO_8859-7:1987")];
	char stringpool_str634[sizeof("MS_KANJI")];
	char stringpool_str637[sizeof("JIS_X0208")];
	char stringpool_str638[sizeof("JISX0201-1976")];
	char stringpool_str646[sizeof("WINBALTRIM")];
	char stringpool_str647[sizeof("MS-GREEK")];
	char stringpool_str648[sizeof("JIS_X0212-1990")];
	char stringpool_str649[sizeof("UCS-4-SWAPPED")];
	char stringpool_str653[sizeof("MACGREEK")];
	char stringpool_str667[sizeof("UCS-2-SWAPPED")];
	char stringpool_str673[sizeof("UCS-4BE")];
	char stringpool_str686[sizeof("CSEUCTW")];
	char stringpool_str691[sizeof("UCS-2BE")];
	char stringpool_str698[sizeof("MACCENTRALEUROPE")];
	char stringpool_str700[sizeof("BIG5-HKSCS:2001")];
	char stringpool_str701[sizeof("TCVN5712-1:1993")];
	char stringpool_str702[sizeof("JAVA")];
	char stringpool_str708[sizeof("BIG5-HKSCS:2004")];
	char stringpool_str718[sizeof("BIG5-HKSCS:1999")];
	char stringpool_str720[sizeof("JIS_X0208-1990")];
	char stringpool_str737[sizeof("JIS_X0208-1983")];
	char stringpool_str738[sizeof("HEBREW")];
	char stringpool_str740[sizeof("UTF-32LE")];
	char stringpool_str742[sizeof("JIS_X0212.1990-0")];
	char stringpool_str749[sizeof("BIGFIVE")];
	char stringpool_str754[sizeof("MS-ARAB")];
	char stringpool_str755[sizeof("BIG-FIVE")];
	char stringpool_str796[sizeof("UTF-16BE")];
	char stringpool_str831[sizeof("MACUKRAINE")];
	char stringpool_str833[sizeof("EXTENDED_UNIX_CODE_PACKED_FORMAT_FOR_JAPANESE")];
	char stringpool_str843[sizeof("CSHALFWIDTHKATAKANA")];
	char stringpool_str883[sizeof("JOHAB")];
	char stringpool_str898[sizeof("CSEUCPKDFMTJAPANESE")];
	char stringpool_str923[sizeof("UTF-32BE")];
	char stringpool_str926[sizeof("MACHEBREW")];
} stringpool_t;


static const UNUSED struct stringpool_t stringpool_contents = {
	"L6",
	"CN",
	"L1",
	"SJIS",
	"L4",
	"L5",
	"R8",
	"L8",
	"866",
	"L2",
	"ISO-IR-6",
	"CP866",
	"MAC",
	"C99",
	"ISO-IR-166",
	"LATIN6",
	"CP154",
	"LATIN1",
	"ISO646-CN",
	"CYRILLIC",
	"ISO-IR-14",
	"CP1256",
	"IBM866",
	"HZ",
	"LATIN4",
	"CP1251",
	"ISO-IR-165",
	"LATIN5",
	"862",
	"ISO-IR-126",
	"ISO-IR-144",
	"CP819",
	"MS-CYRL",
	"LATIN8",
	"CP1254",
	"ISO-IR-58",
	"CP949",
	"CP1255",
	"CP862",
	"ISO-IR-148",
	"PT154",
	"LATIN-9",
	"ISO-IR-149",
	"ISO-IR-159",
	"L3",
	"ISO-IR-226",
	"CP1258",
	"LATIN2",
	"ISO8859-6",
	"ISO-IR-199",
	"IBM819",
	"ISO8859-1",
	"ISO-8859-6",
	"ISO_8859-6",
	"ISO8859-16",
	"ISO-8859-1",
	"ISO_8859-1",
	"ISO8859-11",
	"ISO-8859-16",
	"ISO_8859-16",
	"CP1252",
	"IBM862",
	"ISO-8859-11",
	"ISO_8859-11",
	"ISO8859-4",
	"MACCYRILLIC",
	"ISO_8859-16:2001",
	"ISO8859-5",
	"CP1361",
	"ISO-8859-4",
	"ISO_8859-4",
	"ISO8859-14",
	"ISO-IR-101",
	"ISO-8859-5",
	"ISO_8859-5",
	"ISO8859-15",
	"CP936",
	"ISO-8859-14",
	"ISO_8859-14",
	"ISO8859-8",
	"L7",
	"ISO-8859-15",
	"ISO_8859-15",
	"ISO8859-9",
	"VISCII",
	"ISO-8859-8",
	"ISO_8859-8",
	"RK1048",
	"TCVN",
	"ISO-8859-9",
	"ISO_8859-9",
	"ISO_8859-14:1998",
	"ISO_8859-15:1998",
	"EUCCN",
	"US",
	"PTCP154",
	"ISO8859-2",
	"MS936",
	"EUC-CN",
	"CHAR",
	"CSVISCII",
	"ISO-8859-2",
	"ISO_8859-2",
	"ISO-IR-109",
	"L10",
	"ASCII",
	"UHC",
	"ISO-IR-138",
	"KOI8-R",
	"850",
	"CSASCII",
	"CP932",
	"X0212",
	"UCS-4",
	"CSKOI8R",
	"CP874",
	"CSPTCP154",
	"MS-ANSI",
	"GB2312",
	"ISO646-US",
	"CSUCS4",
	"CP850",
	"ISO-IR-110",
	"CP950",
	"BIG5",
	"ISO-2022-CN",
	"LATIN10",
	"X0201",
	"ISO-CELTIC",
	"CYRILLIC-ASIAN",
	"BIG-5",
	"CSISO2022CN",
	"ISO-IR-179",
	"UCS-2",
	"CP1250",
	"KOI8-T",
	"ROMAN8",
	"ISO_8859-10:1992",
	"TIS620",
	"CSISOLATIN6",
	"CSBIG5",
	"MACINTOSH",
	"CSISOLATIN1",
	"TIS-620",
	"IBM850",
	"CN-BIG5",
	"MACROMAN",
	"LATIN3",
	"ISO-2022-CN-EXT",
	"X0208",
	"CSISOLATINCYRILLIC",
	"CSISOLATIN4",
	"GEORGIAN-PS",
	"ARMSCII-8",
	"CSISOLATIN5",
	"CN-GB-ISOIR165",
	"CP1253",
	"CSIBM866",
	"ELOT_928",
	"VISCII1.1-1",
	"ISO_646.IRV:1991",
	"ISO8859-10",
	"KSC_5601",
	"ISO-8859-10",
	"ISO_8859-10",
	"GB_1988-80",
	"JP",
	"CSISOLATIN2",
	"ISO-IR-100",
	"EUCKR",
	"GBK",
	"KZ-1048",
	"EUC-KR",
	"ISO8859-3",
	"UTF-16",
	"MACTHAI",
	"ISO-8859-3",
	"ISO_8859-3",
	"ISO8859-13",
	"CSKZ1048",
	"ISO-8859-13",
	"ISO_8859-13",
	"ISO-10646-UCS-4",
	"KS_C_5601-1989",
	"HP-ROMAN8",
	"CP1133",
	"CSISO14JISC6220RO",
	"TIS620-0",
	"LATIN7",
	"UTF-8",
	"ISO-IR-57",
	"ISO-10646-UCS-2",
	"ISO-IR-87",
	"ISO-IR-157",
	"ISO_8859-4:1988",
	"ISO_8859-5:1988",
	"CP1257",
	"ISO_8859-8:1988",
	"US-ASCII",
	"ISO-IR-203",
	"ISO_8859-9:1989",
	"ISO-IR-127",
	"UNICODE-1-1",
	"ISO-2022-KR",
	"MULELAO-1",
	"TIS620.2529-1",
	"CSUNICODE11",
	"ECMA-114",
	"CSISO2022KR",
	"TCVN5712-1",
	"MACICELAND",
	"ECMA-118",
	"CSHPROMAN8",
	"GEORGIAN-ACADEMY",
	"UCS-4-INTERNAL",
	"GB_2312-80",
	"ISO8859-7",
	"TCVN-5712",
	"ISO646-JP",
	"CSISOLATINGREEK",
	"CN-GB",
	"ISO-8859-7",
	"ISO_8859-7",
	"GB18030",
	"WINDOWS-1256",
	"CSISOLATINARABIC",
	"WINDOWS-1251",
	"CP367",
	"NEXTSTEP",
	"UCS-2-INTERNAL",
	"WINDOWS-1254",
	"CSMACINTOSH",
	"WINDOWS-1255",
	"CSGB2312",
	"WINDOWS-1258",
	"MACCROATIAN",
	"WINDOWS-1252",
	"CHINESE",
	"IBM-CP1133",
	"CSISO159JISX02121990",
	"IBM367",
	"ISO_8859-3:1988",
	"SHIFT-JIS",
	"SHIFT_JIS",
	"CSISOLATIN3",
	"MS-EE",
	"CSISO57GB1988",
	"MS-HEBR",
	"KS_C_5601-1987",
	"STRK1048-2002",
	"KOREAN",
	"WCHAR_T",
	"JIS_C6220-1969-RO",
	"CSPC850MULTILINGUAL",
	"ISO_8859-6:1987",
	"UTF-32",
	"ISO_8859-1:1987",
	"BIG5HKSCS",
	"JIS_C6226-1983",
	"CSISOLATINHEBREW",
	"UCS-4LE",
	"BIG5-HKSCS",
	"CSKSC56011987",
	"GREEK8",
	"ASMO-708",
	"WINDOWS-936",
	"CSEUCKR",
	"EUCTW",
	"CSUNICODE",
	"WINDOWS-1250",
	"UCS-2LE",
	"EUC-TW",
	"ISO_8859-2:1987",
	"HZ-GB-2312",
	"CSISO58GB231280",
	"CSPC862LATINHEBREW",
	"EUCJP",
	"WINDOWS-1253",
	"EUC-JP",
	"JIS0208",
	"ANSI_X3.4-1986",
	"UNICODE-1-1-UTF-7",
	"KOI8-U",
	"CSUNICODE11UTF7",
	"KOI8-RU",
	"ISO-2022-JP-1",
	"TIS620.2533-1",
	"CSSHIFTJIS",
	"ARABIC",
	"ANSI_X3.4-1968",
	"MS-TURK",
	"WINDOWS-874",
	"WINDOWS-1257",
	"ISO-2022-JP-2",
	"UNICODELITTLE",
	"UNICODEBIG",
	"CSISO2022JP2",
	"JIS_X0212",
	"MACTURKISH",
	"ISO_8859-7:2003",
	"ISO-2022-JP",
	"MACROMANIA",
	"CSISO2022JP",
	"MACARABIC",
	"GREEK",
	"JIS_X0201",
	"UTF-7",
	"CSISO87JISX0208",
	"UTF-16LE",
	"TIS620.2533-0",
	"ISO_8859-7:1987",
	"MS_KANJI",
	"JIS_X0208",
	"JISX0201-1976",
	"WINBALTRIM",
	"MS-GREEK",
	"JIS_X0212-1990",
	"UCS-4-SWAPPED",
	"MACGREEK",
	"UCS-2-SWAPPED",
	"UCS-4BE",
	"CSEUCTW",
	"UCS-2BE",
	"MACCENTRALEUROPE",
	"BIG5-HKSCS:2001",
	"TCVN5712-1:1993",
	"JAVA",
	"BIG5-HKSCS:2004",
	"BIG5-HKSCS:1999",
	"JIS_X0208-1990",
	"JIS_X0208-1983",
	"HEBREW",
	"UTF-32LE",
	"JIS_X0212.1990-0",
	"BIGFIVE",
	"MS-ARAB",
	"BIG-FIVE",
	"UTF-16BE",
	"MACUKRAINE",
	"EXTENDED_UNIX_CODE_PACKED_FORMAT_FOR_JAPANESE",
	"CSHALFWIDTHKATAKANA",
	"JOHAB",
	"CSEUCPKDFMTJAPANESE",
	"UTF-32BE",
	"MACHEBREW"
};
#define stringpool   ((const char*)&stringpool_contents)


#ifdef COMPILER_CLANG
#   pragma clang diagnostic push
#   pragma clang diagnostic ignored "-Woverlength-strings"
#elif defined(COMPILER_GNUC)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Woverlength-strings"
#endif


/** Definitions of charmaps: Each charmap consists of
1. Empty-string-terminated list of null-terminated aliases
2. Special type code or number of elided entries
3. Character table (size determined by field 2) */
static const UNUSED unsigned char charmaps[] = {
	"utf8\0char\0\0\310"
	"wchart\0\0\306"
	"ucs2\0ucs2be\0\0\304"
	"ucs2le\0\0\305"
	"utf16\0utf16be\0\0\302"
	"utf16le\0\0\301"
	"ucs4\0ucs4be\0utf32\0utf32be\0\0\300"
	"ucs4le\0utf32le\0\0\303"
	"ascii\0usascii\0iso646\0iso646us\0\0\307"
	"eucjp\0\0\320"
	"shiftjis\0sjis\0\0\321"
	"gb18030\0\0\330"
	"gbk\0\0\331"
	"gb2312\0\0\332"
	"big5\0bigfive\0cp950\0big5hkscs\0\0\340"
	"euckr\0ksc5601\0ksx1001\0cp949\0\0\350"
#   include "codepages.def"
};


#ifdef COMPILER_CLANG
#   pragma clang diagnostic pop
#elif defined(COMPILER_GNUC)
#   pragma GCC diagnostic pop
#endif


static const UNUSED unsigned short armscii_8_2uni[96] = {
	0xa0, 0xfffd, 0x587, 0x589, 0x29, 0x28, 0xbb, 0xab,
	0x2014, 0x2e, 0x55d, 0x2c, 0x2d, 0x58a, 0x2026, 0x55c,
	0x55b, 0x55e, 0x531, 0x561, 0x532, 0x562, 0x533, 0x563,
	0x534, 0x564, 0x535, 0x565, 0x536, 0x566, 0x537, 0x567,
	0x538, 0x568, 0x539, 0x569, 0x53a, 0x56a, 0x53b, 0x56b,
	0x53c, 0x56c, 0x53d, 0x56d, 0x53e, 0x56e, 0x53f, 0x56f,
	0x540, 0x570, 0x541, 0x571, 0x542, 0x572, 0x543, 0x573,
	0x544, 0x574, 0x545, 0x575, 0x546, 0x576, 0x547, 0x577,
	0x548, 0x578, 0x549, 0x579, 0x54a, 0x57a, 0x54b, 0x57b,
	0x54c, 0x57c, 0x54d, 0x57d, 0x54e, 0x57e, 0x54f, 0x57f,
	0x550, 0x580, 0x551, 0x581, 0x552, 0x582, 0x553, 0x583,
	0x554, 0x584, 0x555, 0x585, 0x556, 0x586, 0x55a, 0xfffd
};


static const UNUSED unsigned char armscii_8_page00[8] = {
	0xa5, 0xa4, 0x2a, 0x2b, 0xab, 0xac, 0xa9, 0x2f
};


static const UNUSED unsigned char armscii_8_page00_1[32] = {
	0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 0xa0-0xa7
	0x0, 0x0, 0x0, 0xa7, 0x0, 0x0, 0x0, 0x0,  // 0xa8-0xaf
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  // 0xb0-0xb7
	0x0, 0x0, 0x0, 0xa6, 0x0, 0x0, 0x0, 0x0  // 0xb8-0xbf
};


static const UNUSED unsigned char armscii_8_page05[96] = {
	0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,  // 0x30-0x37
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce,  // 0x38-0x3f
	0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,  // 0x40-0x47
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,  // 0x48-0x4f
	0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0,  // 0x50-0x57
	0, 0, 0xfe, 0xb0, 0xaf, 0xaa, 0xb1, 0,  // 0x58-0x5f
	0, 0xb3, 0xb5, 0xb7, 0xb9, 0xbb, 0xbd, 0xbf,  // 0x60-0x67
	0xc1, 0xc3, 0xc5, 0xc7, 0xc9, 0xcb, 0xcd, 0xcf,  // 0x68-0x6f
	0xd1, 0xd3, 0xd5, 0xd7, 0xd9, 0xdb, 0xdd, 0xdf,  // 0x70-0x77
	0xe1, 0xe3, 0xe5, 0xe7, 0xe9, 0xeb, 0xed, 0xef,  // 0x78-0x7f
	0xf1, 0xf3, 0xf5, 0xf7, 0xf9, 0xfb, 0xfd, 0xa2,  // 0x80-0x87
	0, 0xa3, 0xad, 0, 0, 0, 0, 0  // 0x88-0x8f
};


static const UNUSED unsigned char armscii_8_page20[24] = {
	0, 0, 0, 0, 0xa8, 0, 0, 0,  // 0x10-0x17
	0, 0, 0, 0, 0, 0, 0, 0,  // 0x18-0x1f
	0, 0, 0, 0, 0, 0, 0xae, 0  // 0x20-0x27
};


#include "atarist.h"


static const UNUSED unsigned short big5[13973] = {
#include "big5.def"
};


#include "cjk_variants.h"
#include "cns11643_1.h"
#include "cns11643_2.h"
#include "cns11643_3.h"
#include "cns11643_4a.h"
#include "cns11643_4b.h"
#include "cns11643_5.h"
#include "cns11643_6.h"
#include "cns11643_7.h"
#include "cns11643_15.h"
#include "cns11643_inv.h"


static const UNUSED unsigned short gb18030[23940] = {
#include "gb18030.def"
};


static const UNUSED unsigned short hkscs[] = {
#include "hkscs.def"
};


static const UNUSED unsigned short jis0208[7896] = {
#include "jis0208.def"
};


static const UNUSED unsigned short ksc[8742] = {
#include "ksc.def"
};


static const UNUSED unsigned short legacy_chars[] = {
#include "legacychars.def"
};


#include "nextstep.h"


/** Converts a value in the range 0..63 to a base64 encoded char */
LIB_FUNC unsigned char base64(const unsigned int i) {
	if (i < 26) { return (unsigned char)(i + 'A'); }
	else if (i < 52) { return (unsigned char)(i - 26 + 'a'); }
	else if (i < 62) { return (unsigned char)(i - 52 + '0'); }
	else if (i == 62) { return (unsigned char)'+'; }
	else if (i == 63) { return (unsigned char)'/'; }
	abort();
	UNREACHABLE
}


LIB_FUNC unsigned int utf8_seqlen(const long codepoint) {
	if (codepoint < 0x80) { return 1; }
	else if (codepoint < 0x800) { return 2; }
	else if (codepoint < 0x10000) { return 3; }
	else if (codepoint < 0x200000) { return 4; }
	else if (codepoint < 0x4000000) { return 5; }
	return 6;
}


/** Does not NUL-terminate the buffer */
LIB_FUNC int fill_utf8(long codepoint, char* restrict str) {
	const int nbytes = (int)utf8_seqlen(codepoint);
	register int b = nbytes;
	while (b > 1) {
		--b;
		str[b] = (char)(0x80 | (codepoint & 0x3f));
		codepoint >>= 6;
	}
	switch (nbytes) {
		case 1: str[0] = (char)(codepoint & 0x7f); break;
		case 2: str[0] = (char)(0xc0 | (codepoint & 0x1f)); break;
		case 3: str[0] = (char)(0xe0 | (codepoint & 0xf)); break;
		case 4: str[0] = (char)(0xf0 | (codepoint & 7)); break;
		case 5: str[0] = (char)(0xf8 | (codepoint & 3)); break;
		case 6: str[0] = (char)(0xfc | (codepoint & 1)); break;
		default: break;
	}
	return nbytes;
}


LIB_FUNC unsigned int get_16(const unsigned char* restrict s, int e) {
	e &= 1;
	return (unsigned int)(s[e] << 8 | s[1 - e]);
}


LIB_FUNC void put_16(unsigned char* s, const unsigned int c, int e) {
	e &= 1;
	s[e] = (unsigned char)(c >> 8);
	s[1 - e] = (unsigned char)c;
}


LIB_FUNC unsigned int get_32(const unsigned char* restrict s, int e) {
	e &= 3;
	return (unsigned int)(((unsigned int)(s[e] + 0U) << 24) | (unsigned int)(s[e ^ 1] << 16) | (unsigned int)(s[e ^ 2] << 8) | (unsigned int)s[e ^ 3]);
}


LIB_FUNC void put_32(unsigned char* s, const unsigned int c, int e) {
	e &= 3;
	s[e ^ 0] = (unsigned char)(c >> 24);
	s[e ^ 1] = (unsigned char)(c >> 16);
	s[e ^ 2] = (unsigned char)(c >> 8);
	s[e ^ 3] = (unsigned char)c;
}


LIB_FUNC int fuzzycmp(const unsigned char* restrict a, const unsigned char* restrict b) {
	for (; *a && *b; a++, b++) {
		while (*a && ((*a | 32U) - 'a') > 26 && (unsigned int)(*a - '0') > 10U) { ++a; }
		if ((*a | 32U) != *b) { return 1; }
	}
	return (int)(*a != *b);
}


LIB_FUNC int armscii_8_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	unsigned char c = *s;
	if (c < 0xa0) { *pwc = (ucs4_t)c; return 1; }
	else {
		register unsigned short wc = armscii_8_2uni[c - 0xa0];
		if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 1; }
	}
	return RET_ILSEQ;
}


LIB_FUNC int armscii_8_wctomb(unsigned char* r, ucs4_t wc) {
	register unsigned char c = 0;
	if (wc < 0x28) { *r = (unsigned char)wc; return 1; }
	else if (wc >= 0x28 && wc < 0x30) { c = (unsigned char)armscii_8_page00[wc - 0x28]; }
	else if (wc >= 0x30 && wc < 0xa0) { c = (unsigned char)wc; }
	else if (wc >= 0xa0 && wc < 0xc0) { c = (unsigned char)armscii_8_page00_1[wc - 0xa0]; }
	else if (wc >= 0x530 && wc < 0x590) { c = (unsigned char)armscii_8_page05[wc - 0x530]; }
	else if (wc >= 0x2010 && wc < 0x2028) { c = (unsigned char)armscii_8_page20[wc - 0x2010]; }
	if (c != 0) { *r = c; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int atarist_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	unsigned char c = *s;
	if (c < 0x80) { *pwc = (ucs4_t)c; }
	else { *pwc = (ucs4_t)atarist_2uni[c - 0x80]; }
	return 1;
}


LIB_FUNC int atarist_wctomb(unsigned char* restrict r, const ucs4_t wc) {
	register unsigned char c = 0;
	if (wc < 0x80) { *r = (unsigned char)wc; return 1; }
	else if (wc >= 0xa0 && wc < 0x100) { c = (unsigned char)atarist_page00[wc - 0xa0]; }
	else if (wc >= 0x130 && wc < 0x198) { c = (unsigned char)atarist_page01[wc - 0x130]; }
	else if (wc >= 0x390 && wc < 0x3c8) { c = (unsigned char)atarist_page03[wc - 0x390]; }
	else if (wc >= 0x5d0 && wc < 0x5f0) { c = (unsigned char)atarist_page05[wc - 0x5d0]; }
	else if (wc == 0x2020) { c = 0xbb; }
	else if (wc == 0x207f) { c = 0xfc; }
	else if (wc == 0x2122) { c = 0xbf; }
	else if (wc >= 0x2208 && wc < 0x2268) { c = (unsigned char)atarist_page22[wc - 0x2208]; }
	else if (wc >= 0x2310 && wc < 0x2328) { c = (unsigned char)atarist_page23[wc - 0x2310]; }
	if (c != 0) { *r = c; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int ascii_mbtowc(ucs4_t* restrict pwc, const unsigned char* restrict s) {
	register unsigned char c = *s;
	if (c < 0x80) { *pwc = (ucs4_t)c; return 1; }
	return RET_ILSEQ;
}


LIB_FUNC int ascii_wctomb(unsigned char* r, const ucs4_t wc) {
	if (wc < 0x80) { *r = (unsigned char)wc; return 1; }
	return RET_ILUNI;
}


LIB_FUNC int cns11643_1_mbtowc(ucs4_t* restrict pwc, const unsigned char* s, const int n) {
	register const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x27) || (c1 == 0x42) || (c1 >= 0x44 && c1 <= 0x7d)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				register unsigned short wc = 0xfffd;
				if (i < 3102) {
					if (i < 500) { wc = cns11643_1_2uni_page21[i]; }
					else if (i == 571) { wc = 0x4ea0; }
					else if (i == 578) { wc = 0x51ab; }
					else if (i == 583) { wc = 0x52f9; }
				} else if (i < 3290) {
					if (i < 3136) { wc = (unsigned short)cns11643_1_2uni_page42[i - 3102]; }
				} else if (i < 8691) { wc = (unsigned short)cns11643_1_2uni_page44[i - 3290]; }
				if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_2_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x72)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				unsigned short wc = 0xfffd;
				if (i < 7650) { wc = (unsigned short)cns11643_2_2uni_page21[i]; }
				if (wc != 0xfffd) { *pwc = (ucs4_t)wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_3_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x62) || (c1 >= 0x64 && c1 <= 0x67)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6298) {
					if (i < 6148) {
						swc = cns11643_3_2uni_page21[i];
						wc = cns11643_3_2uni_upages[swc >> 8] | (swc & 0xff);
					}
				} else {
					if (i < 6590) {
						swc = cns11643_3_2uni_page64[i - 6298];
						wc = cns11643_3_2uni_upages[swc >> 8] | (swc & 0xff);
					}
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_4_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x6e)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 2914) {
					swc = cns11643_4a_2uni_page21[i];
					wc = cns11643_4a_2uni_upages[swc >> 8] | (swc & 0xff);
				} else if (i < 7298) {
					swc = cns11643_4b_2uni_page40[i - 2914];
					wc = cns11643_4b_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_5_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x7c)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 8603) {
					swc = cns11643_5_2uni_page21[i],
					wc = cns11643_5_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_6_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x64)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6388) {
					swc = cns11643_6_2uni_page21[i];
					wc = cns11643_6_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_7_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x66)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 6539) {
					swc = cns11643_7_2uni_page21[i];
					wc = cns11643_7_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_15_mbtowc(ucs4_t* pwc, const unsigned char* s, int n) {
	const unsigned char c1 = s[0];
	if ((c1 >= 0x21 && c1 <= 0x6d)) {
		if (n >= 2) {
			const unsigned char c2 = s[1];
			if (c2 >= 0x21 && c2 < 0x7f) {
				register unsigned int i = (unsigned int)(94 * (c1 - 0x21) + (c2 - 0x21));
				ucs4_t wc = 0xfffd;
				register unsigned short swc;
				if (i < 7169) {
					swc = cns11643_15_2uni_page21[i];
					wc = cns11643_15_2uni_upages[swc >> 8] | (swc & 0xff);
				}
				if (wc != 0xfffd) { *pwc = wc; return 2; }
			}
			return RET_ILSEQ;
		}
		return RET_TOOFEW(0);
	}
	return RET_ILSEQ;
}


LIB_FUNC int cns11643_inv_wctomb(unsigned char* r, ucs4_t wc, const int n) {
	if (n >= 2) {
		const Summary16* summary = NULL;
		if (wc < 0x100) { summary = &cns11643_inv_uni2indx_page00[(wc >> 4)]; }
		else if (wc >= 0x200 && wc < 0x3d0) { summary = &cns11643_inv_uni2indx_page02[(wc >> 4) - 0x20]; }
		else if (wc >= 0x2000 && wc < 0x22c0)  { summary = &cns11643_inv_uni2indx_page20[(wc >> 4) - 0x200]; }
		else if (wc >= 0x2400 && wc < 0x2650) { summary = &cns11643_inv_uni2indx_page24[(wc >> 4) - 0x240]; }
		else if (wc >= 0x3000 && wc < 0x9fb0) { summary = &cns11643_inv_uni2indx_page30[(wc >> 4) - 0x300]; }
		else if (wc >= 0xfa00 && wc < 0xfa30) { summary = &cns11643_inv_uni2indx_pagefa[(wc >> 4) - 0xfa0]; }
		else if (wc >= 0xfe00 && wc < 0xfff0) { summary = &cns11643_inv_uni2indx_pagefe[(wc >> 4) - 0xfe0]; }
		else if (wc >= 0x20000 && wc < 0x2a6e0) { summary = &cns11643_inv_uni2indx_page200[(wc >> 4) - 0x2000]; }
		else if (wc >= 0x2f800 && wc < 0x2fa20) { summary = &cns11643_inv_uni2indx_page2f8[(wc >> 4) - 0x2f80]; }
		if (summary) {
			register unsigned short used_entries = summary->used_entries;
			register unsigned int i = wc & 0xf;
			if (used_entries & (unsigned short)(1 << i)) {
				used_entries &= (unsigned short)((1 << i) - 1);
				used_entries = (unsigned short)((used_entries & 0x5555) + ((used_entries & 0xaaaa) >> 1));
				used_entries = (unsigned short)((used_entries & 0x3333) + ((used_entries & 0xcccc) >> 2));
				used_entries = (unsigned short)((used_entries & 0xf0f) + ((used_entries & 0xf0f0) >> 4));
				used_entries = (unsigned short)((used_entries & 0xff) + (used_entries >> 8));
				used_entries = (unsigned short)(used_entries + (unsigned short)summary->indx);
				r[0] = (unsigned char)cns11643_inv_2charset[3 * used_entries];
				r[1] = (unsigned char)cns11643_inv_2charset[3 * used_entries + 1];
				r[2] = (unsigned char)cns11643_inv_2charset[3 * used_entries + 2];
				return 3;
			}
		}
		return RET_ILUNI;
	}
	return RET_TOOSMALL;
}
/** Returns the plane number (1,...,7,15) in r[0], the two bytes in r[1], r[2] */
#define cns11643_wctomb(r, wc, n)   cns11643_inv_wctomb((r), (wc), (n))


LIB_FUNC int java_mbtowc(ucs4_t* pwc, const unsigned char* s, const int n) {
	unsigned char c = s[0];
	if (c != '\\') {
		*pwc = c;
		return 1;
	} else if (n < 2) { return RET_TOOFEW(0); }
	else if (s[1] != 'u') { *pwc = '\\'; return 1; }
	register int i;
	ucs4_t wc;
	for (i = 2; i < 6; i++) {
		if (n <= i) { return RET_TOOFEW(0); }
		c = s[i];
		if (c >= '0' && c <= '9') { c = (unsigned char)(c - '0'); }
		else if (c >= 'A' && c <= 'Z') { c = (unsigned char)(c - ('A' - 10)); }
		else if (c >= 'a' && c <= 'z') { c = (unsigned char)(c - ('a' - 10)); }
		else { *pwc = '\\'; return 1; }
		wc = 0;
		wc |= (ucs4_t)c << (4 * (5 - i));
	}
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		*pwc = wc;
		return 6;
	} else if (wc >= 0xdc00) { *pwc = '\\'; return 1; }
	else if (n < 7) { return RET_TOOFEW(0); }
	else if (s[6] != '\\') { *pwc = '\\'; return 1; }
	if (n < 8) { return RET_TOOFEW(0); }
	if (s[7] != 'u') { *pwc = '\\'; return 1; }
	ucs4_t wc2;
	for (i = 8; i < 12; i++) {
		if (n <= i) { return RET_TOOFEW(0); }
		c = s[i];
		if (c >= '0' && c <= '9') { c = (unsigned char)(c - '0'); }
		else if (c >= 'A' && c <= 'Z') { c = (unsigned char)(c - ('A' - 10)); }
		else if (c >= 'a' && c <= 'z') { c = (unsigned char)(c - ('a' - 10)); }
		else { *pwc = '\\'; return 1; }
		wc2 = 0;
		wc2 |= (ucs4_t)((ucs4_t)c << (4 * (11 - i)));
	}
	if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { *pwc = '\\'; return 1; }
	*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
	return 12;
}


LIB_FUNC int java_wctomb(unsigned char* r, ucs4_t wc, const int n) {
	if (wc < 0x80) {
		*r = (unsigned char)wc;
		return 1;
	} else if (wc < 0x10000) {
		if (n >= 6) {
			register unsigned int i;
			r[0] = '\\';
			r[1] = 'u';
			i = (unsigned int)((wc >> 12) & 0xf);
			r[2] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)((wc >> 8) & 0xf);
			r[3] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)((wc >> 4) & 0xf);
			r[4] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (unsigned int)(wc & 0xf);
			r[5] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			return 6;
		} else { return RET_TOOSMALL; }
	} else if (wc < 0x110000) {
		if (n >= 12) {
			ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
			ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
			register unsigned int i;
			r[0] = '\\';
			r[1] = 'u';
			i = (wc1 >> 12) & 0xf;
			r[2] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc1 >> 8) & 0xf;
			r[3] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc1 >> 4) & 0xf;
			r[4] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = wc1 & 0xf;
			r[5] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			r[6] = '\\';
			r[7] = 'u';
			i = (wc2 >> 12) & 0xf;
			r[8] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc2 >> 8) & 0xf;
			r[9] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = (wc2 >> 4) & 0xf;
			r[10] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			i = wc2 & 0xf;
			r[11] = (unsigned char)(i < 10 ? '0' + i : 'a' - 10 + i);
			return 12;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


LIB_FUNC int nextstep_mbtowc(ucs4_t* pwc, const unsigned char* s) {
	unsigned char c = *s;
	if (c < 0x80) {
		*pwc = (ucs4_t)c;
		return 1;
	} else {
		unsigned short wc = nextstep_2uni[c - 0x80];
		if (wc != 0xfffd) {
			*pwc = (ucs4_t)wc;
			return 1;
		}
	}
	return RET_ILSEQ;
}


LIB_FUNC int nextstep_wctomb(unsigned char* r, ucs4_t wc) {
	unsigned char c = 0;
	if (wc < 0x80) {
		*r = (unsigned char)wc;
		return 1;
	} else if (wc >= 0xa0 && wc < 0x100) { c = nextstep_page00[wc - 0xa0]; }
	else if (wc >= 0x130 && wc < 0x198) { c = nextstep_page01[wc - 0x130]; }
	else if (wc >= 0x2c0 && wc < 0x2e0) { c = nextstep_page02[wc - 0x2c0]; }
	else if (wc >= 0x2010 && wc < 0x2048) { c = nextstep_page20[wc - 0x2010]; }
	else if (wc >= 0xfb00 && wc < 0xfb08) { c = nextstep_pagefb[wc - 0xfb00]; }
	if (c != 0) {
		*r = c;
		return 1;
	}
	return RET_ILUNI;
}


/** UTF-16BE (RFC 2781) */
LIB_FUNC int utf16be_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 2) {
		ucs4_t wc = (ucs4_t)((s[0] << 8) + s[1]);
		if (wc >= 0xd800 && wc < 0xdc00) {
			if (n >= 4) {
				ucs4_t wc2 = (ucs4_t)((s[2] << 8) + s[3]);
				if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { return RET_ILSEQ; }
				*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
				return 4;
			}
		} else if (wc >= 0xdc00 && wc < 0xe000) { return RET_ILSEQ; }
		else { *pwc = wc; return 2; }
	}
	return RET_TOOFEW(0);
}


/** UTF-16BE (RFC 2781) */
LIB_FUNC int utf16be_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		if (wc < 0x10000) {
			if (n >= 2) {
				r[0] = (unsigned char)(wc >> 8);
				r[1] = (unsigned char)wc;
				return 2;
			} else { return RET_TOOSMALL; }
		} else if (wc < 0x110000) {
			if (n >= 4) {
				ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
				ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
				r[0] = (unsigned char)(wc1 >> 8);
				r[1] = (unsigned char)wc1;
				r[2] = (unsigned char)(wc2 >> 8);
				r[3] = (unsigned char)wc2;
				return 4;
			} else { return RET_TOOSMALL; }
		}
	}
	return RET_ILUNI;
}


/** UTF-16LE (RFC 2781) */
LIB_FUNC int utf16le_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 2) {
		ucs4_t wc = (ucs4_t)(s[0] + (s[1] << 8));
		if (wc >= 0xd800 && wc < 0xdc00) {
			if (n >= 4) {
				ucs4_t wc2 = (ucs4_t)(s[2] + (s[3] << 8));
				if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) { return RET_ILSEQ; }
				*pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);
				return 4;
			}
		} else if (wc >= 0xdc00 && wc < 0xe000) { return RET_ILSEQ; }
		else { *pwc = wc; return 2; }
	}
	return RET_TOOFEW(0);
}


/** UTF-16LE (RFC 2781) */
LIB_FUNC int utf16le_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (!(wc >= 0xd800 && wc < 0xe000)) {
		if (wc < 0x10000) {
			if (n >= 2) {
				r[0] = (unsigned char)wc;
				r[1] = (unsigned char)(wc >> 8);
				return 2;
			} else { return RET_TOOSMALL; }
		} else if (wc < 0x110000) {
			if (n >= 4) {
				ucs4_t wc1 = (ucs4_t)(0xd800 + ((wc - 0x10000) >> 10));
				ucs4_t wc2 = (ucs4_t)(0xdc00 + ((wc - 0x10000) & 0x3ff));
				r[0] = (unsigned char)wc1;
				r[1] = (unsigned char)(wc1 >> 8);
				r[2] = (unsigned char)wc2;
				r[3] = (unsigned char)(wc2 >> 8);
				return 4;
			} else { return RET_TOOSMALL; }
		}
	}
	return RET_ILUNI;
}


/** UTF-32BE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32be_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 4) {
		ucs4_t wc = (ucs4_t)((s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3]);
		if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
			*pwc = wc;
			return 4;
		} else { return RET_ILSEQ; }
	}
	return RET_TOOFEW(0);
}


/** UTF-32BE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32be_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
		if (n >= 4) {
			r[0] = 0;
			r[1] = (unsigned char)(wc >> 16);
			r[2] = (unsigned char)(wc >> 8);
			r[3] = (unsigned char)wc;
			return 4;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


/** UTF-32LE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32le_mbtowc(ucs4_t* pwc, const unsigned char* s, const size_t n) {
	if (n >= 4) {
		ucs4_t wc = (ucs4_t)(s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24));
		if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
			*pwc = wc;
			return 4;
		} else { return RET_ILSEQ; }
	}
	return RET_TOOFEW(0);
}


/** UTF-32LE (Unicode 3.1 Standard Annex #19) */
LIB_FUNC int utf32le_wctomb(unsigned char* r, ucs4_t wc, const size_t n) {
	if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {
		if (n >= 4) {
			r[0] = (unsigned char)wc;
			r[1] = (unsigned char)(wc >> 8);
			r[2] = (unsigned char)(wc >> 16);
			r[3] = 0;
			return 4;
		} else { return RET_TOOSMALL; }
	}
	return RET_ILUNI;
}


/* TODO: Add ICONV functions
size_t  iconv(iconv_t, char** restrict, size_t* restrict, char** restrict, size_t* restrict);
int iconv_close(iconv_t);
iconv_t iconv_open(const char*, const char*);
*/


#endif  // MBCTYPE_H & ICONV_H


/* UNSIGNED/UNICODE CHARACTERS (<uchar.h>) */


#if (!(defined(_UCHAR_H) || defined(_UCHAR_H_) || defined(_LIBC_UCHAR_H_)))  // http://www.cplusplus.com/reference/cuchar/
#define _UCHAR_H   (1)
#define _UCHAR_H_   (1)
#define _LIBC_UCHAR_H   (1)
#define _LIBC_UCHAR_H_   (1)


/** The 32-bit character c32 is translated to its multibyte equivalent and stored in the array pointed by pmb; The function returns the length in bytes of the equivalent multibyte sequence pointed by pmb */
LIB_FUNC size_t c32rtomb(char* restrict pmb, char32_t c32, mbstate_t* restrict ps) {
	return wcrtomb(pmb, (wchar_t)c32, ps);
}
#define _c32rtomb(pmb, c32, ps)   c32rtomb((pmb), (c32), (ps))
#define __c32rtomb(pmb, c32, ps)   c32rtomb((pmb), (c32), (ps))


/** The multibyte character pointed by pmb is converted to a 16-bit character and stored at the location pointed by pc16; The function returns the length in bytes of the multibyte character (up to len) */
LIB_FUNC size_t mbrtoc16(char16_t* restrict pc16, const char* restrict pmb, const size_t len, mbstate_t* restrict ps) {
	static unsigned internal_state;
	if (!ps) { ps = (void*)&internal_state; }
	unsigned* pending = (unsigned*)ps;
	if (!pmb) { return mbrtoc16(0, "", 1, ps); }
	else if ((int)*pending > 0) {
		if (pc16) { *pc16 = (char16_t)*pending; }
		*pending = 0;
		return (size_t)-3;
	}
	wchar_t wc;
	register const size_t ret = mbrtowc(&wc, pmb, len, ps);
	if (ret <= 4) {
		if (wc >= 0x10000) {
			*pending = (unsigned)((wc & 0x3ff) + 0xdc00);
			wc = (0xd7c0 + (wc >> 10));
		}
		if (pc16) { *pc16 = (char16_t)wc; }
	}
	return ret;
}


/** The multibyte character pointed by pmb is converted to a 32-bit character and stored at the location pointed by pc32; The function returns the length in bytes of the multibyte character (up to len) */
LIB_FUNC size_t mbrtoc32(char32_t* restrict pc32, const char* restrict pmb, const size_t len, mbstate_t* restrict ps) {
	static unsigned internal_state;
	if (!ps) { ps = (void*)&internal_state; }
	if (!pmb) { return mbrtoc32(0, "", 1, ps); }
	wchar_t wc;
	register const size_t ret = mbrtowc(&wc, pmb, len, ps);
	if (ret <= 4 && pc32) { *pc32 = (char32_t)wc; }
	return ret;
}


#endif  // UCHAR_H


/* CONVERSION FROM & TO VISCII (<viscii.h>); RFC1456 */


#if (!(defined(_VISCII_H) || defined(_VISCII_H_)))
#define _VISCII_H   (1)
#define _VISCII_H_   (1)


#define CHARSET_NAME   "VISCII//"
/** All 256 character are defined */
#define HAS_HOLES   0
typedef struct gap { uint16_t start, end; int32_t idx; }   gap_t;


#define FROM_LOOP   from_gap
#define TO_LOOP   to_gap
#define MIN_NEEDED_FROM   1
#define MIN_NEEDED_TO   4
#define ONE_DIRECTION   0
// Define the conversion function from the 8bit charset to UCS4
#define MIN_NEEDED_INPUT   MIN_NEEDED_FROM
#define MIN_NEEDED_OUTPUT   MIN_NEEDED_TO
#define LOOPFCT   FROM_LOOP
#define BODY   do { uint32_t ch = to_ucs4[*inptr]; if (HAS_HOLES && UNLIKELY(ch == L'0') && NONNUL(*inptr)) { STANDARD_FROM_LOOP_ERR_HANDLER(1); } else { put32(outptr, ch); outptr += 4; } ++inptr; } while (0x0)
#define LOOP_NEED_FLAGS
#define ONEBYTE_BODY   do { uint32_t ch = to_ucs4[c]; if (HAS_HOLES && UNLIKELY(ch == L'0') && NONNUL(c)) { return WEOF; } else { return ch; } } while (0x0)


static const UNUSED unsigned short viscii_2uni_1[32] = {
	// 0x0
	0x0, 0x1, 0x1eb2, 0x3, 0x4, 0x1eb4, 0x1eaa, 0x7,
	0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
	// 0x10
	0x10, 0x11, 0x12, 0x13, 0x1ef6, 0x15, 0x16, 0x17,
	0x18, 0x1ef8, 0x1a, 0x1b, 0x1c, 0x1d, 0x1ef4, 0x1f,
};


static const UNUSED unsigned short viscii_2uni_2[128] = {
	// 0x80
	0x1ea0, 0x1eae, 0x1eb0, 0x1eb6, 0x1ea4, 0x1ea6, 0x1ea8, 0x1eac,
	0x1ebc, 0x1eb8, 0x1ebe, 0x1ec0, 0x1ec2, 0x1ec4, 0x1ec6, 0x1ed0,
	// 0x90
	0x1ed2, 0x1ed4, 0x1ed6, 0x1ed8, 0x1ee2, 0x1eda, 0x1edc, 0x1ede,
	0x1eca, 0x1ece, 0x1ecc, 0x1ec8, 0x1ee6, 0x168, 0x1ee4, 0x1ef2,
	// 0xa0
	0xd5, 0x1eaf, 0x1eb1, 0x1eb7, 0x1ea5, 0x1ea7, 0x1ea9, 0x1ead,
	0x1ebd, 0x1eb9, 0x1ebf, 0x1ec1, 0x1ec3, 0x1ec5, 0x1ec7, 0x1ed1,
	// 0xb0
	0x1ed3, 0x1ed5, 0x1ed7, 0x1ee0, 0x1a0, 0x1ed9, 0x1edd, 0x1edf,
	0x1ecb, 0x1ef0, 0x1ee8, 0x1eea, 0x1eec, 0x1a1, 0x1edb, 0x1af,
	// 0xc0
	0xc0, 0xc1, 0xc2, 0xc3, 0x1ea2, 0x102, 0x1eb3, 0x1eb5,
	0xc8, 0xc9, 0xca, 0x1eba, 0xcc, 0xcd, 0x0128, 0x1ef3,
	// 0xd0
	0x110, 0x1ee9, 0xd2, 0xd3, 0xd4, 0x1ea1, 0x1ef7, 0x1eeb,
	0x1eed, 0xd9, 0xda, 0x1ef9, 0x1ef5, 0xdd, 0x1ee1, 0x1b0,
	// 0xe0
	0xe0, 0xe1, 0xe2, 0xe3, 0x1ea3, 0x103, 0x1eef, 0x1eab,
	0xe8, 0xe9, 0xea, 0x1ebb, 0xec, 0xed, 0x129, 0x1ec9,
	// 0xf0
	0x111, 0x1ef1, 0xf2, 0xf3, 0xf4, 0xf5, 0x1ecf, 0x1ecd,
	0x1ee5, 0xf9, 0xfa, 0x169, 0x1ee7, 0xfd, 0x1ee3, 0x1eee,
};


static const UNUSED unsigned char viscii_page00[248] = {
	0xc0, 0xc1, 0xc2, 0xc3, 0x0, 0x0, 0x0, 0x0, // 0xc0-0xc7
	0xc8, 0xc9, 0xca, 0x0, 0xcc, 0xcd, 0x0, 0x0, // 0xc8-0xcf
	0x0, 0x0, 0xd2, 0xd3, 0xd4, 0xa0, 0x0, 0x0, // 0xd0-0xd7
	0x0, 0xd9, 0xda, 0x0, 0x0, 0xdd, 0x0, 0x0, // 0xd8-0xdf
	0xe0, 0xe1, 0xe2, 0xe3, 0x0, 0x0, 0x0, 0x0, // 0xe0-0xe7
	0xe8, 0xe9, 0xea, 0x0, 0xec, 0xed, 0x0, 0x0, // 0xe8-0xef
	0x0, 0x0, 0xf2, 0xf3, 0xf4, 0xf5, 0x0, 0x0, // 0xf0-0xf7
	0x0, 0xf9, 0xfa, 0x0, 0x0, 0xfd, 0x0, 0x0, // 0xf8-0xff
	// 0x100
	0x0, 0x0, 0xc5, 0xe5, 0x0, 0x0, 0x0, 0x0, // 0x0-0x7
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x8-0xf
	0xd0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x10-0x17
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x18-0x1f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x20-0x27
	0xce, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x28-0x2f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x30-0x37
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x38-0x3f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x40-0x47
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x48-0x4f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x50-0x57
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x58-0x5f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x60-0x67
	0x9d, 0xfb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x68-0x6f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x70-0x77
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x78-0x7f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x80-0x87
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x88-0x8f
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x90-0x97
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0x98-0x9f
	0xb4, 0xbd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0xa0-0xa7
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbf, // 0xa8-0xaf
	0xdf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0xb0-0xb7
};


static const UNUSED unsigned char viscii_page1e[96] = {
	0x80, 0xd5, 0xc4, 0xe4, 0x84, 0xa4, 0x85, 0xa5, // 0xa0-0xa7
	0x86, 0xa6, 0x6, 0xe7, 0x87, 0xa7, 0x81, 0xa1, // 0xa8-0xaf
	0x82, 0xa2, 0x2, 0xc6, 0x5, 0xc7, 0x83, 0xa3, // 0xb0-0xb7
	0x89, 0xa9, 0xcb, 0xeb, 0x88, 0xa8, 0x8a, 0xaa, // 0xb8-0xbf
	0x8b, 0xab, 0x8c, 0xac, 0x8d, 0xad, 0x8e, 0xae, // 0xc0-0xc7
	0x9b, 0xef, 0x98, 0xb8, 0x9a, 0xf7, 0x99, 0xf6, // 0xc8-0xcf
	0x8f, 0xaf, 0x90, 0xb0, 0x91, 0xb1, 0x92, 0xb2, // 0xd0-0xd7
	0x93, 0xb5, 0x95, 0xbe, 0x96, 0xb6, 0x97, 0xb7, // 0xd8-0xdf
	0xb3, 0xde, 0x94, 0xfe, 0x9e, 0xf8, 0x9c, 0xfc, // 0xe0-0xe7
	0xba, 0xd1, 0xbb, 0xd7, 0xbc, 0xd8, 0xff, 0xe6, // 0xe8-0xef
	0xb9, 0xf1, 0x9f, 0xcf, 0x1e, 0xdc, 0x14, 0xd6, // 0xf0-0xf7
	0x19, 0xdb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // 0xf8-0xff
};


#endif  // VISCII_H


/* VISUALLY ENCODE CHARACTERS (<vis.h> & <bsd/vis.h>) */


#if (!(defined(_VIS_H) || defined(_VIS_H_) || defined(_LIBC_VIS_H_) || defined(_BSD_VIS_H_) || defined(_COMPAT_VIS_H_)))
#define _VIS_H   (1)
#define _VIS_H_   (1)
#define _BSD_VIS_H_   (1)
#define _LIBC_VIS_H_   (1)
#define _COMPAT_VIS_H_   (1)


/** Use octal format */
#define VIS_OCTAL   1
/** Use [nrft0..] where appropiate */
#define VIS_CSTYLE   2
/** Also encode space */
#define VIS_SP   4
/** Also encode tab */
#define VIS_TAB   8
/** Also encode newline */
#define VIS_NL   0x10
/** Also encode white-space */
#define VIS_WHITE   (VIS_SP | VIS_TAB | VIS_NL)
/** Only encode "unsafe" characters */
#define VIS_SAFE   0x20
/** Inhibit printing '\' */
#define VIS_NOSLASH   0x40
/** HTTP-style escape % hex hex */
#define VIS_HTTP1808   0x80
/** HTTP-style escape % hex hex */
#define VIS_HTTPSTYLE   0x80
/** Mime-style escape = HEX HEX */
#define VIS_MIMESTYLE   0x100
/** HTTP-style &#num; or &string; */
#define VIS_HTTP1866   0x200
/** Do not decode '\' */
#define VIS_NOESCAPE   0x400
/** For unvis */
#define _VIS_END   0x800
/** Encode glob(3) magic characters */
#define VIS_GLOB   0x1000
/** Encode shell special characters [not glob] */
#define VIS_SHELL   0x2000
/** Encode magic characters, white-space, and shell special characters */
#define VIS_META   (VIS_WHITE | VIS_GLOB | VIS_SHELL)
/** Encode using the C locale */
#define VIS_NOLOCALE   0x4000
#define VIS_DQ   0x8000
#define VIS_ALL   INT_MAX
// unvis return codes
/** Character valid */
#define UNVIS_VALID   1
/** Character valid, push back passed char */
#define UNVIS_VALIDPUSH   2
/** Valid sequence, no character produced */
#define UNVIS_NOCHAR   3
/** Unrecognized escape sequence */
#define UNVIS_SYNBAD   -1
/** Decoder in unknown state (unrecoverable) */
#define UNVIS_ERROR   -2
/** No more characters (unvis flag) */
#define UNVIS_END   _VIS_END
// Decode driven by state machine
/** Have not seen escape char */
#define S_GROUND   0
/** Start decoding special sequence */
#define S_START   1
/** Metachar started (M) */
#define S_META   2
/** Metachar more, regular char (-) */
#define S_META1   3
/** Control char started (^) */
#define S_CTRL   4
/** Octal digit 2 */
#define S_OCTAL2   5
/** Octal digit 3 */
#define S_OCTAL3   6


/** Test if the character is visible */
#define ISVISIBLE(c, flag)   (((c) != '\0' || (flag & VIS_ALL) == 0) && (((uint32_t)(c) <= UCHAR_MAX && isascii((c)) && (((c) != '*' && (c) != '?' && (c) != '[' && (c) != '#') || (flag & VIS_GLOB) == 0) && isgraph((c))) || ((flag & VIS_SP) == 0 && (c) == ' ') || ((flag & VIS_TAB) == 0 && (c) == 't') || ((flag & VIS_NL) == 0 && (c) == 'n') || ((flag & VIS_SAFE) && ((c) == 'b' || ((int)(c) == 0x303037) || (c) == 'r' || isgraph((c))))))  // '007' = 0x303037
/** Test if the character is visible */
#define isvisible(c, flag)   ISVISIBLE((c), (flag))


/** Decode characters previously encoded by vis */
LIB_FUNC int unvis(char* cp, const char c, int* astate, const int flag) {
	if (flag & UNVIS_END) {
		if (*astate == S_OCTAL2 || *astate == S_OCTAL3) {
			*astate = S_GROUND;
			return (UNVIS_VALID);
		}
		return (*astate == S_GROUND ? UNVIS_NOCHAR : UNVIS_SYNBAD);
	}
	switch (*astate) {
		case S_GROUND:
			*cp = 0;
			if (c == '\\') {
				*astate = S_START;
				return 0;
			}
			*cp = c;
			return UNVIS_VALID;
		case S_START:
			switch (c) {
				case '-':
					*cp = 0;
					*astate = S_GROUND;
					return 0;
				case '\\':
				case '"':
					*cp = c;
					*astate = S_GROUND;
					return UNVIS_VALID;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
					*cp = (char)(c - '0');
					*astate = S_OCTAL2;
					return 0;
				case 'M':
					*cp = (char)0200;
					*astate = S_META;
					return 0;
				case '^':
					*astate = S_CTRL;
					return 0;
				case 'n':
					*cp = '\n';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'r':
					*cp = '\r';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'b':
					*cp = '\b';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'a':
					*cp = '\007';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'v':
					*cp = '\v';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 't':
					*cp = '\t';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'f':
					*cp = '\f';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 's':
					*cp = ' ';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case 'E':
					*cp = '\033';
					*astate = S_GROUND;
					return UNVIS_VALID;
				case '\n':
					*astate = S_GROUND;
					return UNVIS_NOCHAR;
				case '$':
					*astate = S_GROUND;
					return UNVIS_NOCHAR;
				default:
					return 0;
			}
			*astate = S_GROUND;
			return UNVIS_SYNBAD;
		case S_META:
			if (c == '-') { *astate = S_META1; }
			else if (c == '^') { *astate = S_CTRL; }
			else {
				*astate = S_GROUND;
				return UNVIS_SYNBAD;
			}
			return 0;
		case S_META1:
			*astate = S_GROUND;
			*cp |= c;
			return UNVIS_VALID;
		case S_CTRL:
			if (c == '?') { *cp |= 0177; }
			else { *cp = (char)((char)(*cp) | ((char)(c & 037))); }
			*astate = S_GROUND;
			return UNVIS_VALID;
		case S_OCTAL2:  // Second possible octal digit
			if (isoctal(c)) {
				*cp = (char)((*cp << 3) + (c - '0'));
				*astate = S_OCTAL3;
				return 0;
			}
			*astate = S_GROUND;
			return UNVIS_VALIDPUSH;
		case S_OCTAL3:  // Third possible octal digit
			*astate = S_GROUND;
			if (isoctal(c)) {
				*cp = (char)((*cp << 3) + (c - '0'));
				return UNVIS_VALID;
			}
			return UNVIS_VALIDPUSH;
		default:  // Decoder in unknown state - (probably uninitialized)
			*astate = S_GROUND;
			return UNVIS_SYNBAD;
	}
	UNREACHABLE
}
#define __unvis50(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define __unvis13(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define unvis50(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))
#define unvis13(cp, c, astate, flag)   unvis((cp), (c), (astate), (flag))


/** Decode src into dest; Number of chars decoded into dest is returned, -1 on error; dest is null terminated */
LIB_FUNC int strunvis(char* dest, const char* src) {
	char c;
	char* start = dest;
	int vis_state = 0;
	while ((c = *src++)) { strunvis_again:
		switch (unvis(dest, c, &vis_state, 0)) {
			case UNVIS_VALID:
				++dest;
				break;
			case UNVIS_VALIDPUSH:
				++dest;
				goto strunvis_again;
			case 0:
			case UNVIS_NOCHAR:
				break;
			default:
				*dest = '\0';
				return -1;
		}
	}
	if (unvis(dest, c, &vis_state, UNVIS_END) == UNVIS_VALID) { ++dest; }
	*dest = '\0';
	return (int)(dest - start);
}


LIB_FUNC ssize_t strnunvis(char* dest, const char* src, const size_t sz) {
	char c, p;
	char* start = dest, *end = (dest + sz - 1);
	int vis_state = 0;
	if (sz > 0) { *end = '\0'; }
	while ((c = *src++)) { strnunvis_again:
		switch (unvis(&p, c, &vis_state, 0)) {
			case UNVIS_VALID:
				if (dest < end) { *dest = p; }
				++dest;
				break;
			case UNVIS_VALIDPUSH:
				if (dest < end) { *dest = p; }
				++dest;
				goto strnunvis_again;
			case 0:
			case UNVIS_NOCHAR:
				break;
			default:
				if (dest <= end) { *dest = '\0'; }
				return -1;
		}
	}
	if (unvis(&p, c, &vis_state, UNVIS_END) == UNVIS_VALID) {
		if (dest < end) { *dest = p; }
		++dest;
	}
	if (dest <= end) { *dest = '\0'; }
	return (ssize_t)(dest - start);
}


/** Visually encode characters */
LIB_FUNC char* vis(char* dest, int c, const int flag, const int nextc) {
	if (isvisible(c, flag)) {
		if ((c == '"' && (flag & VIS_DQ) != 0) || (c == '\\' && (flag & VIS_NOSLASH) == 0)) {
			*dest++ = '\\';
		}
		*dest++ = (char)c;
		*dest = '\0';
		return dest;
	}
	else if (flag & VIS_CSTYLE) {
		switch (c) {
			case '\n':
				*dest++ = '\\';
				*dest++ = 'n';
				*dest = '\0';
				return dest;
			case '\r':
				*dest++ = '\\';
				*dest++ = 'r';
				*dest = '\0';
				return dest;
			case '\b':
				*dest++ = '\\';
				*dest++ = 'b';
				*dest = '\0';
				return dest;
			case '\a':
				*dest++ = '\\';
				*dest++ = 'a';
				*dest = '\0';
				return dest;
			case '\v':
				*dest++ = '\\';
				*dest++ = 'v';
				*dest = '\0';
				return dest;
			case '\t':
				*dest++ = '\\';
				*dest++ = 't';
				*dest = '\0';
				return dest;
			case '\f':
				*dest++ = '\\';
				*dest++ = 'f';
				*dest = '\0';
				return dest;
			case ' ':
				*dest++ = '\\';
				*dest++ = 's';
				*dest = '\0';
				return dest;
			case '\0':
				*dest++ = '\\';
				*dest++ = '0';
				if (isoctal(nextc)) {
					*dest++ = '0';
					*dest++ = '0';
				}
				*dest = '\0';
				return dest;
			default:
				*dest = '\0';
				return dest;
		}
	}
	else if (((c & 0177) == ' ') || (flag & VIS_OCTAL) || ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {
		*dest++ = '\\';
		*dest++ = (char)(((char)c >> 6 & 7) + '0');
		*dest++ = (char)(((char)c >> 3 & 7) + '0');
		*dest++ = (char)(((char)c & 7) + '0');
		*dest = '\0';
		return dest;
	}
	else if ((flag & VIS_NOSLASH) == 0) { *dest++ = '\\'; }
	if (c & 0200) {
		c &= (char)0177;
		*dest++ = 'M';
	}
	if (iscntrl((uchar)c)) {
		*dest++ = '^';
		if (c == 0177) { *dest++ = '?'; }
		else { *dest++ = (char)(c + '@'); }
	} else {
		*dest++ = '-';
		*dest++ = (char)c;
	}
	*dest = '\0';
	return dest;
}


/** Visually encode characters from src into dest */
LIB_FUNC int strvis(char* dest, const char* src, const int flag) {
	char c;
	char* start;
	for (start = dest; (c = *src);) { dest = vis(dest, c, flag, *++src); }
	*dest = '\0';
	return (int)(dest - start);
}


/** Visually encode characters from src into dst; Strnvis will write no more than (siz - 1) bytes (and will NULL terminate); The number of bytes needed to fully encode the string is returned */
LIB_FUNC int strnvis(char* dst, const char* src, const size_t siz, const int flag) {
	char *start, *end;
	char tbuf[5] = { 0 };
	register int c, i = 0;
	for (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {
		if (isvisible(c, flag)) {
			if ((c == '"' && (flag & VIS_DQ) != 0) || (c == '\\' && (flag & VIS_NOSLASH) == 0)) {  // Need space for the extra '\\'
				if (dst + 1 >= end) { i = 2; break; }
				*dst++ = '\\';
			}
			i = 1;
			*dst++ = (char)c;
			++src;
		} else {
			i = (int)(vis(tbuf, c, flag, *++src) - tbuf);
			if (dst + i <= end) { memcpy_no_output(dst, tbuf, (size_t)i); dst += i; }
			else { --src; break; }
		}
	}
	if (siz > 0) { *dst = '\0'; }
	if (dst + i > end) {  // Adjust return value for truncation
		while ((c = *src)) { dst += vis(tbuf, c, flag, *++src) - tbuf; }
	}
	return (int)(dst - start);
}


/** Visually encode characters from src into dst */
LIB_FUNC int stravis(char** outp, const char* src, const int flag) {
	char* buf = reallocarray(NULL, 4, (strlen(src) + 1));
	if (buf == NULL) { return -1; }
	const int len = strvis(buf, src, flag);
	const int serrno = errno;
	*outp = realloc(buf, (size_t)(len + 1));
	if (*outp == NULL) { *outp = buf; errno = serrno; }
	return len;
}


/** Visually encode characters from src into dst; Strvisx encodes exactly len bytes from src into dst; This is useful for encoding a block of data */
LIB_FUNC int strvisx(char* dst, const char* src, const size_t len, const int flag) {
	char c;
	char* start;
	register size_t n = len;
	for (start = dst; n > 1; --n) {
		c = *src;
		dst = vis(dst, c, flag, *++src);
	}
	if (n) { dst = vis(dst, *src, flag, '\0'); }
	*dst = '\0';
	return (int)(dst - start);
}


/* TODO: Add vis.h functions
char *nvis(char *, size_t, int, int, int);
char *svis(char *, int, int, int, const char *);
char *snvis(char *, size_t, int, int, int, const char *);
int strsvis(char *, const char *, int, const char *);
int strsnvis(char *, size_t, const char *, int, const char *);
int strnvisx(char *, size_t, const char *, size_t, int);
int strenvisx(char *, size_t, const char *, size_t, int, int *);
int strsvisx(char *, const char *, size_t, int, const char *);
int strsnvisx(char *, size_t, const char *, size_t, int, const char *);
int strsenvisx(char *, size_t, const char *, size_t , int, const char *, int *);
int strunvisx(char *, const char *, int);
int strnunvisx(char *, size_t, const char *, int);
*/


#endif  // VIS_H


/* HIGH PRECISION, LOW OVERHEAD TIMING FUNCTIONS (<hp-timing.h>) */


#if (!(defined(_HP_TIMING_H) || defined(_HP_TIMING_H_)))
#define _HP_TIMING_H   (1)
#define _HP_TIMING_H_   (1)


/** Compute the difference between START and END, storing into DIFF */
#define HP_TIMING_DIFF(Diff, Start, End)   ((Diff) = (End) - (Start))
/** Accumulate ADD into SUM.  No attempt is made to be thread-safe */
#define HP_TIMING_ACCUM_NT(Sum, Diff)   ((Sum) += (Diff))
/** Write a decimal representation of the timing value into the given string */
#define HP_TIMING_PRINT(Dest, Len, Val)   do { char __buf[20] = { 0 }; char* __dest = (Dest); size_t __len = (Len); char* __cp = _itoa((Val), (__buf + sizeof(__buf)), 10, 0); size_t __cp_len = MIN((__buf + sizeof(__buf) - __cp), __len); memcpy_no_output(__dest, __cp, __cp_len); memcpy_no_output(__dest + __cp_len, " cycles", MIN(__len - __cp_len, 7)); __dest[__len - 1] = '\0'; } while (0x0)


#ifdef ALPHA


/** Test for availability */
#define HP_TIMING_AVAIL   (0)
#define HP_SMALL_TIMING_AVAIL   (1)
/** This macro is non-zero if the functionality is not implemented using function calls but instead uses some inlined code which might simply consist of a few assembler instructions */
#define HP_TIMING_INLINE   (1)
/** The "rpcc" instruction returns a 32-bit counting half and a 32-bit "virtual cycle counter displacement"; Subtracting the two gives us a virtual cycle count */
#define HP_TIMING_NOW(VAR)   do { unsigned long x_; asm volatile ("rpcc %0;" : "=r"(x_)); (VAR) = (int)(x_) - (int)(x_ >> 32); } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned long x_;
	asm volatile ("rpcc %0;" : "=r"(x_));
	return (hp_timing_t)((int)(x_) - (int)(x_ >> 32));
}


#elif defined(X86_64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { unsigned int _hi, _lo; asm volatile ("rdtsc;" : "=a"(_lo), "=d"(_hi)); (Var) = ((unsigned long long)_hi << 32) | _lo; } while (0x0)  // The "=A" constraint used in 32-bit mode does not work in 64-bit mode
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned int _hi, _lo;
	asm volatile ("rdtsc;" : "=a"(_lo), "=d"(_hi));
	return (hp_timing_t)(((unsigned long long)_hi << 32) | (unsigned long long)_lo);
}


#elif (defined(I386) || defined(I686) || defined(X86))


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
/** Use the `rdtsc` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `cpuid` right before the `rdtsc` instruction */
#define HP_TIMING_NOW(Var)   asm volatile ("rdtsc;" : "=A"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtsc_val;
	asm volatile ("rdtsc;" : "=A"(rdtsc_val));
	return (hp_timing_t)rdtsc_val;
}
#define rdtscl(low)   asm volatile ("lfence;" "rdtsc;" : "=a"(low) : : "ecx", "edx")


#elif defined(ITANIUM)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { unsigned long __itc; do { asm volatile ("mov %0 = ar.itc;" : "=r"(__itc) : : "memory"); } while (UNLIKELY((long)__itc == -1)); Var = __itc; } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t __itc;
	do {
		asm volatile ("mov %0 = ar.itc;" : "=r"(__itc) : : "memory");
	} while (UNLIKELY((long)__itc == -1));
	return (hp_timing_t)__itc;
}


#elif defined(SPARC64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   asm volatile ("rd %%tick, %0;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtick;
	asm volatile ("rd %%tick, %0;" : "=r"(rdtick));
	return (hp_timing_t)rdtick;
}


#elif defined(POWERPC64)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)

/** Use the `mftb` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `lwsync` right before the `mftb` instruction */
#ifdef _ARCH_PWR4
#   define HP_TIMING_NOW(Var)   asm volatile ("mfspr %0, 268;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t mfspr_val;
	asm volatile ("mfspr %0, 268;" : "=r"(mfspr_val));
	return (hp_timing_t)mfspr_val;
}
#else
#   define HP_TIMING_NOW(Var)   asm volatile ("mftb %0;" : "=r"(Var))
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t mftb_val;
	asm volatile ("mftb %0;" : "=r"(mftb_val));
	return (hp_timing_t)mftb_val;
}
#endif


#elif defined(POWERPC)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
/** Use the `mftb` instruction; Note that the value might not be 100% accurate since there might be some more instructions running in this moment; This could be changed by using a barrier like `lwsync` right before the `mftb` instruction */
#define HP_TIMING_NOW(Var)   do { unsigned int hi, lo, tmp; asm volatile ("1: mfspr %0, 269;" "mfspr %1, 268;" "mfspr %2, 269;" "cmpw %0, %2;" "bne 1b;" : "=&r"(hi), "=&r"(lo), "=&r"(tmp) : : "cr0"); Var = ((hp_timing_t)hi << 32) | lo; } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	unsigned int hi, lo, tmp;
	asm volatile ("1: mfspr %0, 269;" "mfspr %1, 268;" "mfspr %2, 269;" "cmpw %0, %2;" "bne 1b;" : "=&r"(hi), "=&r"(lo), "=&r"(tmp) : : "cr0");
	return (hp_timing_t)(((hp_timing_t)hi << 32) | (hp_timing_t)lo);
}


#elif defined(SPARC)


#define HP_TIMING_AVAIL   (1)
#define HP_SMALL_TIMING_AVAIL   (1)
#define HP_TIMING_INLINE   (1)
#define HP_TIMING_NOW(Var)   do { asm volatile ("rd %%tick, %L0;" "srlx %L0, 32, %H0;" : "=r"(Var)) } while (0x0)
LIB_FUNC hp_timing_t HP_TIMING(void) {
	hp_timing_t rdtick;
	asm volatile ("rd %%tick, %L0;" "srlx %L0, 32, %H0;" : "=r"(rdtick))
	return (hp_timing_t)rdtick;
}


#else


// Provide dummy definitions
#define HP_TIMING_AVAIL   (0)
#define HP_SMALL_TIMING_AVAIL   (0)
#define HP_TIMING_INLINE   (0)
#define HP_TIMING_NOW(var)
#define HP_TIMING(var)   (hp_timing_t)(1)
#define HP_TIMING_NONAVAIL   (1)


#endif  // ARCH


#endif  // HP_TIMING_H


/* TIME (<time.h> & <sys/time.h>) */


#if (!(defined(_TIME_H) || defined(_TIME_H_) || defined(_SYS_TIME_H) || defined(_SYS_TIME_H_) || defined(_BITS_TIME_H) || defined(_BITS_TIME_H_) || defined(_BIONIC_TIME_H) || defined(_SYS_TIMEX_H) || defined(_SYS_TIMEX_H_)))  // http://www.cplusplus.com/reference/ctime/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html & http://pubs.opengroup.org/onlinepubs/000095399/basedefs/sys/timeb.h.html
#define _TIME_H   (1)
#define _TIME_H_   (1)
#define _SYS_TIME_H   (1)
#define _SYS_TIME_H_   (1)
#define _SYS_TIMEB_H   (1)  // <sys/timeb.h>
#define _SYS_TIMEB_H_   (1)
#define TIME_TYPES_H   (1)
#define TIME_TYPES_H_   (1)
#define _BITS_TIME_H   (1)
#define _BITS_TIME_H_   (1)
#define _BIONIC_TIME_H   (1)
#define _SYS_TIMEX_H   (1)
#define _SYS_TIMEX_H_   (1)
#define _XT_TIME_H   (1)
#define _COMPAT_SYS_TIME_TYPES_H_   (1)


#define TM_ZONE   tm_zone
/** Identifier for the system-wide monotonic clock */
#define CLOCK_MONOTONIC   1
#define CLOCK_PROCESS_CPUTIME_ID   2
#define CLOCK_THREAD_CPUTIME_ID   3
#define CLOCK_MONOTONIC_RAW   4
#define CLOCK_REALTIME_COARSE   5
#define CLOCK_MONOTONIC_COARSE   6
#define CLOCK_BOOTTIME   7
#define CLOCK_REALTIME_ALARM   8
#define CLOCK_BOOTTIME_ALARM   9
#define CLOCK_SGI_CYCLE   10
#define CLOCK_TAI   11
#define ADJ_OFFSET   1
#define ADJ_FREQUENCY   2
#define ADJ_MAXERROR   4
#define ADJ_ESTERROR   8
#define ADJ_STATUS   0x10
#define ADJ_TIMECONST   0x20
#define ADJ_TAI   0x80
#define ADJ_SETOFFSET   0x100
#define ADJ_MICRO   0x1000
#define ADJ_NANO   0x2000
#define ADJ_TICK   0x4000
#define ADJ_OFFSET_SINGLESHOT   0x8001
#define ADJ_OFFSET_SS_READ   0xa001
#define MOD_OFFSET   ADJ_OFFSET
#define MOD_FREQUENCY   ADJ_FREQUENCY
#define MOD_MAXERROR   ADJ_MAXERROR
#define MOD_ESTERROR   ADJ_ESTERROR
#define MOD_STATUS   ADJ_STATUS
#define MOD_TIMECONST   ADJ_TIMECONST
#define MOD_CLKB   ADJ_TICK
#define MOD_CLKA   ADJ_OFFSET_SINGLESHOT
#define MOD_TAI   ADJ_TAI
#define MOD_MICRO   ADJ_MICRO
#define MOD_NANO   ADJ_NANO
#define STA_PLL   1
#define STA_PPSFREQ   2
#define STA_PPSTIME   4
#define STA_FLL   8
#define STA_INS   0x10
#define STA_DEL   0x20
#define STA_UNSYNC  0x40
#define STA_FREQHOLD   0x80
#define STA_PPSSIGNAL   0x100
#define STA_PPSJITTER   0x200
#define STA_PPSWANDER   0x400
#define STA_PPSERROR   0x800
#define STA_CLOCKERR   0x1000
#define STA_NANO   0x2000
#define STA_MODE   0x4000
#define STA_CLK   0x8000
#define STA_RONLY   (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
#define TIME_OK   0
#define TIME_INS   1
#define TIME_DEL   2
#define TIME_OOP   3
#define TIME_WAIT   4
#define TIME_ERROR   5
#define TIME_BAD   TIME_ERROR
#define MAXTC   6
#define XT_TIME_LOCAL_TZ   1
#define XT_TIME_CONTIGUOUS   2
#define XT_TIME_ALL_MONTHDAYS   0xFFFFFFFE
#define XT_TIME_ALL_WEEKDAYS   0xFE
#define XT_TIME_MIN_DAYTIME   0
#define XT_TIME_MAX_DAYTIME   86399
#define XT_TIME_ALL_FLAGS   (XT_TIME_LOCAL_TZ | XT_TIME_CONTIGUOUS)
#ifdef X86_64


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
/** Extend change to start of growsdown vma (mprotect only) */
#define PROT_GROWSDOWN   0x1000000
/** Extend change to start of growsup vma (mprotect only) */
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_32BIT   0x40
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define MAP_HUGE_SHIFT   26
#define MAP_HUGE_MASK   0x3f
/** No further special treatment */
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
/** Lock all currently mapped pages */
#define MCL_CURRENT   1
/** Lock all additions to address space */
#define MCL_FUTURE   2
/** Lock all pages that are faulted in */
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
/** Explicity exclude from the core dump, overrides the coredump filter bits */
#define MADV_DONTDUMP   16
/** Clear the MADV_DONTDUMP flag */
#define MADV_DODUMP   17
/** Poison a page for testing */
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif (defined(X86) || defined(I386))


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
/** Pages can be read */
#define PROT_READ   1
/** Pages can be written */
#define PROT_WRITE   2
/** Pages can be executed */
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
/** Share changes */
#define MAP_SHARED   1
/** Changes are private */
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_32BIT   0x40
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x0100
#define MAP_DENYWRITE   0x0800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif defined(SUPERH)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_32BIT   0x40
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   4
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif defined(POWERPC)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_SAO   0x10
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_NORESERVE   0x40
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x80
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   0x2000
#define MCL_FUTURE   0x4000
#define MCL_ONFAULT   0x8000
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif defined(MIPS)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x800
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_NORESERVE   0x400
#define MAP_GROWSDOWN   0x1000
#define MAP_DENYWRITE   0x2000
#define MAP_EXECUTABLE   0x4000
#define MAP_LOCKED   0x8000
#define MAP_POPULATE   0x10000
#define MAP_NONBLOCK   0x20000
#define MAP_STACK   0x40000
#define MAP_HUGETLB   0x80000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100


#elif defined(MICROBLAZE)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif defined(ARM64)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#elif defined(ARM)


#define MAP_FAILED   ((void*)-1)
#define PROT_NONE   0
#define PROT_READ   1
#define PROT_WRITE   2
#define PROT_EXEC   4
#define PROT_GROWSDOWN   0x1000000
#define PROT_GROWSUP   0x2000000
#define MAP_SHARED   1
#define MAP_PRIVATE   2
#define MAP_FIXED   0x10
#define MAP_TYPE   0xf
#define MAP_FILE   0
#define MAP_ANON   0x20
#define MAP_ANONYMOUS   MAP_ANON
#define MAP_NORESERVE   0x4000
#define MAP_GROWSDOWN   0x100
#define MAP_DENYWRITE   0x800
#define MAP_EXECUTABLE   0x1000
#define MAP_LOCKED   0x2000
#define MAP_POPULATE   0x8000
#define MAP_NONBLOCK   0x10000
#define MAP_STACK   0x20000
#define MAP_HUGETLB   0x40000
#define POSIX_MADV_NORMAL   0
#define POSIX_MADV_RANDOM   1
#define POSIX_MADV_SEQUENTIAL   2
#define POSIX_MADV_WILLNEED   3
#define POSIX_MADV_DONTNEED   0
#define MS_ASYNC   1
#define MS_INVALIDATE   2
#define MS_SYNC   4
#define MCL_CURRENT   1
#define MCL_FUTURE   2
#define MCL_ONFAULT   4
#define MADV_NORMAL   0
#define MADV_RANDOM   1
#define MADV_SEQUENTIAL   2
#define MADV_WILLNEED   3
#define MADV_DONTNEED   4
#define MADV_REMOVE   9
#define MADV_DONTFORK   10
#define MADV_DOFORK   11
#define MADV_MERGEABLE   12
#define MADV_UNMERGEABLE   13
#define MADV_HUGEPAGE   14
#define MADV_NOHUGEPAGE   15
#define MADV_DONTDUMP   16
#define MADV_DODUMP   17
#define MADV_HWPOISON   100
#define MADV_SOFT_OFFLINE   101


#endif  // ARCH
#ifndef MAP_FILE
#   define MAP_FILE   0
#endif
#ifndef MAP_FAILED
#   define MAP_FAILED   ((void*)-1)
#endif
/** Flag indicating time is absolute; For functions taking timer objects, this refers to the clock associated with the timer */
#define TIMER_ABSTIME   (1)
#define timerisset(tvp)   ((tvp)->tv_sec || (tvp)->tv_usec)
#define timerclear(tvp)   ((tvp)->tv_sec = (tvp)->tv_usec = 0)
#ifndef timercmp
#   define timercmp(tvp, uvp, cmp)   (((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))
#endif
#ifndef timeradd
#   define timeradd(tvp, uvp, vvp)   do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0x0)
#endif
#ifndef timersub
#   define timersub(tvp, uvp, vvp)   do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0x0)
#endif
#define BAD_MACH_TIMESPEC(t)   ((t)->tv_nsec < 0 || (t)->tv_nsec >= (long)NSEC_PER_SEC)
/** t1 <=> t2, also (t1 - t2) in nsec with max of +- 1 sec */
#define CMP_MACH_TIMESPEC(t1, t2)   ((t1)->tv_sec > (t2)->tv_sec ? (long)(NSEC_PER_SEC) : ((t1)->tv_sec < (t2)->tv_sec ? (long) -NSEC_PER_SEC : (t1)->tv_nsec - (t2)->tv_nsec))
#define ADD_MACH_TIMESPEC(t1, t2)   do { if (((t1)->tv_nsec += (t2)->tv_nsec) >= (long) NSEC_PER_SEC) { (t1)->tv_nsec -= (long) NSEC_PER_SEC; (t1)->tv_sec += 1; } (t1)->tv_sec += (t2)->tv_sec; } while (0x0)
#define SUB_MACH_TIMESPEC(t1, t2)   do { if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0) { (t1)->tv_nsec += (long) NSEC_PER_SEC; (t1)->tv_sec -= 1; } (t1)->tv_sec -= (t2)->tv_sec; } while (0x0)
/** Macro for converting from `struct timeval` to `struct timespec` */
#define TIMEVAL_TO_TIMESPEC(tv, ts)   { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }
/** Macro for converting from `struct timespec` to `struct timeval` */
#define TIMESPEC_TO_TIMEVAL(tv, ts)   { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }
/** Nonzero if YEAR is a leap year (every 4 years, except every 100 that is not divisible by 400) */
#define __isleap(year)   ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
/** Nonzero if YEAR is a leap year (every 4 years, except every 100 that is not divisible by 400) */
#define isleap(year)   __isleap((year))
/** Minimum finite time value; This assumes no padding */
static const UNUSED time_t time_t_min = MINVAL(time_t, TYPE_BIT(time_t));
/** Maximum finite time value; This assumes no padding */
static const UNUSED time_t time_t_max = MAXVAL(time_t, TYPE_BIT(time_t));


/** Values for the first argument to `getitimer` and `setitimer` */
enum __itimer_which {
	ITIMER_REAL = 0,  // Timers run in real time
	ITIMER_VIRTUAL = 1,  // Timers run only when the process is executing
	ITIMER_PROF = 2  // Timers run when the process is executing and when the system is executing on behalf of the process
};
typedef int   itimer_which_t;
#define __itimer_which_t   itimer_which_t
typedef struct itimerspec { struct timespec it_interval, it_value; }   itimerspec_t;
typedef struct ntptimeval { struct timeval time; long maxerror, esterror; }   ntptimeval_t;
typedef struct timeval50 { long tv_sec, tv_usec; }   timeval50_t;
typedef struct itimerval50 { struct timeval50 it_interval; struct timeval50 it_value; }   itimerval50_t;
typedef struct attr_packed timespec50 { int32_t tv_sec; long tv_nsec; }   timespec50_t;
typedef struct itimerspec50 { struct timespec50 it_interval; struct timespec50 it_value; }   itimerspec50_t;


/** Structure returned by the `ftime` function; Current time */
typedef struct attr_packed timeb {
	time_t time;  // The seconds portion of the current time
	unsigned short millitm;  // The milliseconds portion of the current time
	short timezone;  // The local timezone in minutes west of Greenwich
	short dstflag;  // TRUE if Daylight Savings Time is in effect
} timeb_t;


typedef struct attr_packed xt_time_info {
	uint32_t date_start, date_stop, daytime_start, daytime_stop, monthdays_match;
	uint8_t weekdays_match, flags;
} xt_time_info_t;


#ifndef _BIONIC_STRFTIME_TZ_DECLARED
#   define _BIONIC_STRFTIME_TZ_DECLARED   (1)
typedef struct strftime_locale {
	const char* mon[12];
	const char* month[12];
	const char* standalone_month[12];
	const char* wday[7];
	const char* weekday[7];
	const char* X_fmt;
	const char* x_fmt;
	const char* c_fmt;
	const char* am;
	const char* pm;
	const char* date_fmt;
} strftime_locale_t;
#endif  // BIONIC_STRFTIME_TZ_DECLARED


typedef struct attr_packed timex {
	unsigned modes;
	long offset, freq, maxerror, esterror;
	int status;
	long constant, precision, tolerance;
	struct timeval time;
	long tick, ppsfreq, jitter;
	int shift;
	long stabil, jitcnt, calcnt, errcnt, stbcnt;
	int tai;
	int __padding[11];
} timex_t;


struct bintime {
	time_t sec;
	uint64_t frac;
};


// TIME-RELATED VARIABLES
static UNUSED char* __tzname[2] = { 0, 0 };
static UNUSED int __daylight = 0, getdate_err = 0;
static UNUSED long __timezone = 0, dst_off = 0;
static UNUSED int r0[5], r1[5];
static UNUSED char std_name[TZNAME_MAX + 1];
static UNUSED char dst_name[TZNAME_MAX + 1];
static UNUSED char __gmt[4] = "GMT";
static UNUSED char old_tz_buf[32];
static UNUSED size_t old_tz_size = sizeof(old_tz_buf), map_size;
static UNUSED char* old_tz = old_tz_buf;
static UNUSED int rule0[5], rule1[5];
static volatile UNUSED int tm_lock[2];
static UNUSED unsigned char *time_index, *abbrevs, *abbrevs_end, *types;
static const UNUSED unsigned char *zi, *trans;


#ifndef _OS_OSBASE_H
#define _OS_OSBASE_H   (1)
#define OS_OSBASE_H   (1)


LIB_FUNC uint64_t* OSAbsoluteTimePtr(AbsoluteTime* abstime) { return ((uint64_t*)abstime); }
#define __OSAbsoluteTimePtr(abstime)   OSAbsoluteTimePtr((abstime))
#define AbsoluteTime_to_scalar(x)   (*(uint64_t*)(x))
#define CMP_ABSOLUTETIME(t1, t2)   ((AbsoluteTime_to_scalar(t1) > AbsoluteTime_to_scalar(t2)) ? (int)1 : ((AbsoluteTime_to_scalar(t1) < AbsoluteTime_to_scalar(t2)) ? ((int)-1) : 0))
#define ADD_ABSOLUTETIME(t1, t2)   (AbsoluteTime_to_scalar(t1) += AbsoluteTime_to_scalar(t2))
#define SUB_ABSOLUTETIME(t1, t2)   (AbsoluteTime_to_scalar(t1) -= AbsoluteTime_to_scalar(t2))
#define ADD_ABSOLUTETIME_TICKS(t1, ticks)   (AbsoluteTime_to_scalar(t1) += (int32_t)(ticks))


#endif  // OS_OSBASE_H


#define difftime(t1, t0)   (double)((time_t)(t1) - (time_t)(t0))


LIB_FUNC int is_leap(const int x) {
	register int y = x;
	if (y > (INT_MAX - 1900)) { y -= 2000; }
	y += 1900;
	return (!(y % 4) && ((y % 100) || !(y % 400)));
}


LIB_FUNC int week_num(const struct tm* _tm) {
	register int val = (_tm->tm_yday + 7 - (_tm->tm_wday + 6) % 7) / 7;
	// If 1 Jan is just 1-3 days past Monday, the previous week is also in this year
	if (((_tm->tm_wday + 371) - _tm->tm_yday - 2) % 7 <= 2) { ++val; }
	if (!val) {
		val = 52;
		// If 31 December of prev year a Thursday, or Friday of a leap year, then the prev year has 53 weeks
		register int dec31 = ((_tm->tm_wday + 7) - _tm->tm_yday - 1) % 7;
		if (dec31 == 4 || (dec31 == 5 && is_leap((_tm->tm_year % 400) - 1))) { ++val; }
	} else if (val == 53) {
		// If 1 January is not a Thursday, and not a Wednesday of a leap year, then this year has only 52 weeks
		register int jan1 = (int)((_tm->tm_wday + 371 - _tm->tm_yday) % 7);
		if (jan1 != 4 && (jan1 != 3 || (!is_leap(_tm->tm_year)))) { val = 1; }
	}
	return val;
}


/** Return the number of days in a month */
LIB_FUNC int days_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2: return (28 + _is_leap);
		case 4:
		case 6:
		case 9:
		case 11:
			return 30;
		default: return 31;
	}
	UNREACHABLE
}
#define __days_in_month(_month, _is_leap)   days_in_month((_month), (_is_leap))
#define __month_to_days(_month, _is_leap)   days_in_month((_month), (_is_leap))
#define month_to_days(_month, _is_leap)   days_in_month((_month), (_is_leap))


/** Return the number of hours in a month */
LIB_FUNC int hours_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 696; }
			else { return 672; }
		case 4:
		case 6:
		case 9:
		case 11:
			return 720;
		default: return 744;
	}
	UNREACHABLE
}
#define __hours_in_month(_month, _is_leap)   hours_in_month((_month), (_is_leap))
#define __month_to_hours(_month, _is_leap)   hours_in_month((_month), (_is_leap))
#define month_to_hours(_month, _is_leap)   hours_in_month((_month), (_is_leap))


/** Return the number of minutes in a month */
LIB_FUNC int minutes_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 41760; }
			else { return 40320; }
		case 4:
		case 6:
		case 9:
		case 11: return 43200;
		default: return 44640;
	}
	UNREACHABLE
}
#define __minutes_in_month(_month, _is_leap)   minutes_in_month((_month), (_is_leap))
#define __month_to_minutes(_month, _is_leap)   minutes_in_month((_month), (_is_leap))
#define month_to_minutes(_month, _is_leap)   minutes_in_month((_month), (_is_leap))


/** Return the number of seconds in a month */
LIB_FUNC int secs_in_month(const int _month, const int _is_leap) {
	if (_month > 12 || _month < 1) { return 0; }
	switch (_month) {
		case 2:
			if (_is_leap) { return 2505600; }
			else { return 2419200; }
		case 4:
		case 6:
		case 9:
		case 11: return 2592000;
		default: return 2678400;
	}
	UNREACHABLE
}
#define __secs_in_month(_month, _is_leap)   secs_in_month((_month), (_is_leap))
#define __month_to_secs(_month, _is_leap)   secs_in_month((_month), (_is_leap))
#define month_to_secs(_month, _is_leap)   secs_in_month((_month), (_is_leap))


LIB_FUNC int secs_to_tm(long long t, struct tm* _tm) {
	int wday, yday, leap;
	// Reject time_t values whose year would overflow int
	if (t < (INT_MIN * 31622400LL) || t > (INT_MAX * 31622400LL)) { return -1; }
	register const long long secs = t - LEAPOCH;
	register long long days = secs / 86400;
	register int remsecs = (int)(secs % 86400);
	if (remsecs < 0) {
		remsecs += 86400;
		--days;
	}
	wday = (int)((3 + days) % 7);
	if (wday < 0) { wday += 7; }
	register int qc_cycles = (int)(days / DAYS_PER_400Y);
	register int remdays = (int)(days % DAYS_PER_400Y);
	if (remdays < 0) {
		remdays += DAYS_PER_400Y;
		--qc_cycles;
	}
	register int c_cycles = (int)(remdays / DAYS_PER_100Y);
	if (c_cycles == 4) { c_cycles--; }
	remdays -= (c_cycles * DAYS_PER_100Y);
	register int q_cycles = (int)(remdays / DAYS_PER_4Y);
	if (q_cycles == 25) { --q_cycles; }
	remdays -= (q_cycles * DAYS_PER_4Y);
	register int remyears = (int)(remdays / 365);
	if (remyears == 0x4) { --remyears; }
	remdays -= (remyears * 365);
	leap = (!remyears && (q_cycles || !c_cycles));
	yday = remdays + 59 + leap;
	if (yday >= (365 + leap)) { yday -= (365 + leap); }
	long long years = remyears + 4 * q_cycles + 100 * c_cycles + 400LL * qc_cycles;
	int months;
	for (months = 0; days_per_month[months] <= remdays; months++) { remdays -= days_per_month[months]; }
	if (((years + 100) > INT_MAX) || ((years + 100) < INT_MIN)) { return -1; }
	_tm->tm_year = (int)(years + 100);
	_tm->tm_mon = months + 2;
	if (_tm->tm_mon >= 12) { _tm->tm_mon -= 12; _tm->tm_year++; }
	_tm->tm_mday = remdays + 1;
	_tm->tm_wday = wday;
	_tm->tm_yday = yday;
	_tm->tm_hour = remsecs / 3600;
	_tm->tm_min = (remsecs / 60) % 60;
	_tm->tm_sec = remsecs % 60;
	return 0;
}
#define __secs_to_tm(t, _tm)   secs_to_tm((t), (_tm))


LIB_FUNC long long year_to_secs(const long long year, int* _is_leap) {
	if ((year - 2LL) <= 136) {
		int y = (int)year;
		int leaps = (y - 68) >> 2;
		if (!((y - 68) & 3)) {
			leaps--;
			if (_is_leap) { *_is_leap = 1; }
		} else if (_is_leap) { *_is_leap = 0; }
		return 31536000 * (y - 70) + 86400 * leaps;
	}
	int centuries, leaps, rem;
	if (!_is_leap) { _is_leap = &(int) { 0 }; }
	register int cycles = (int)((year - 100) / 400);
	rem = (int)((year - 100) % 400);
	if (rem < 0) { --cycles; rem += 400; }
	if (!rem) {
		*_is_leap = 1;
		centuries = 0;
		leaps = 0;
	} else {
		if (rem >= 200) {
			if (rem >= 300) { centuries = 3; rem -= 300; }
			else { centuries = 2; rem -= 200; }
		} else {
			if (rem >= 100) { centuries = 1; rem -= 100; }
			else { centuries = 0; }
		}
		if (!rem) {
			*_is_leap = 0;
			leaps = 0;
		} else {
			leaps = (int)(rem / 4);
			rem %= 4;
			*_is_leap = (!rem);
		}
	}
	leaps += (97 * cycles + 24 * centuries - *_is_leap);
	return ((year - 100) * 31536000LL + leaps * 86400LL + 946684800 + 86400);
}
#define __year_to_secs(year, _is_leap)   year_to_secs((year), (_is_leap))


LIB_FUNC long long tm_to_secs(const struct tm* _tm) {
	register long long year = _tm->tm_year;
	register int month = _tm->tm_mon;
	if (month >= 12 || month < 0) {
		register int adj = month / 12;
		month %= 12;
		if (month < 0) { adj--; month += 12; }
		year += adj;
	}
	int _is_leap;
	register long long t = __year_to_secs(year, &_is_leap);
	t += __month_to_secs(month, _is_leap);
	t += 86400LL * (_tm->tm_mday - 1);
	t += 3600LL * _tm->tm_hour;
	t += 60LL * _tm->tm_min;
	t += _tm->tm_sec;
	return t;
}
#define __tm_to_secs(_tm)   tm_to_secs((_tm))


LIB_FUNC const char* tm_to_tzname(const struct tm* _tm) {
	const void* p = _tm->__tm_zone;
	LOCK(tm_lock);
	do_tzset();
	if (p != __gmt && p != __tzname[0] && p != __tzname[1] && (!zi || (uintptr_t)p - (uintptr_t)abbrevs >= (uintptr_t)(abbrevs_end - abbrevs))) { p = ""; }
	UNLOCK(tm_lock);
	return p;
}
#define __tm_to_tzname(_tm)   tm_to_tzname((_tm))


/** Convert a POSIX DST rule plus year to seconds since epoch */
LIB_FUNC long long rule_to_secs(const int* rule, const int year) {
	int is_leap, x, m, n, d;
	register long long t = year_to_secs(year, &is_leap);
	if (rule[0]!='M') {
		x = rule[1];
		if (rule[0] == 'J' && (x < 60 || !(is_leap))) { x--; }
		t += 86400 * x;
	} else {
		m = rule[1];
		n = rule[2];
		d = rule[3];
		t += month_to_secs((m - 1), is_leap);
		const int wday = (int)((t + 4 * 86400) % (7 * 86400)) / 86400;
		register int days = (int)(d - wday);
		if (days < 0) { days += 7; }
		if (n == 5 && days + 28 >= days_in_month(m, is_leap)) { n = 4; }
		t += 86400 * (days + 7 * (n - 1));
	}
	t += rule[4];
	return t;
}


LIB_FUNC int getoff(const char** p) {
	register int neg = 0;
	if (**p == '-') { ++*p; neg = 1; }
	else if (**p == '+') { ++*p; }
	int off = 3600 * getint(p);
	if (**p == ':') {
		++*p;
		off += 60 * getint(p);
		if (**p == ':') {
			++*p;
			off += getint(p);
		}
	}
	return (neg ? (-off) : off);
}


LIB_FUNC void getrule(const char** p, int rule[5]) {
	int r = rule[0] = **p;
	if (r != 'M') {
		if (r == 'J') { ++*p; }
		else { rule[0] = 0; }
		rule[1] = getint(p);
	} else {
		++*p; rule[1] = getint(p);
		++*p; rule[2] = getint(p);
		++*p; rule[3] = getint(p);
	}
	if (**p == '/') { ++*p; rule[4] = getoff(p); }
	else { rule[4] = 7200; }
}


LIB_FUNC void getname(char* d, const char** p) {
	register int i;
	if (**p == '<') {
		++*p;
		for (i = 0; **p != '>' && i < TZNAME_MAX; i++) { d[i] = (*p)[i]; }
		++*p;
	} else {
		for (i = 0; ((unsigned int)(((*p)[i] | 32) - 'a') < 26U) && i < TZNAME_MAX; i++) { d[i] = (*p)[i]; }
	}
	*p += i;
	d[i] = 0;
}


LIB_FUNC int adjtimex(struct timex* tx) {
	return (int)__syscall1(SYS_adjtimex, (long)tx);
}


LIB_FUNC int clock_adjtime(const clockid_t clock_id, struct timex* utx) {
	return (int)syscall(SYS_clock_adjtime, clock_id, utx);
}


LIB_FUNC int clock_settime(const clockid_t clk, const struct timespec* ts) {
	return (int)syscall(SYS_clock_settime, clk, ts);
}


LIB_FUNC int settimeofday(const struct timeval* tv, const UNUSED struct timezone_struct* tz) {
	return (int)syscall(SYS_settimeofday, tv, 0);
}


LIB_FUNC int getitimer(int which, struct itimerval* old) {
	return (int)syscall(SYS_getitimer, which, old);
}


LIB_FUNC int setitimer(int which, const struct itimerval* restrict new, struct itimerval* restrict old) {
	return (int)syscall(SYS_setitimer, which, new, old);
}


LIB_FUNC int nanosleep(const struct timespec* req, struct timespec* rem) {
	return (int)syscall(SYS_nanosleep, req, rem);
}
#define _nanosleep(req, rem)   nanosleep((req), (rem))
#define __nanosleep(req, rem)   nanosleep((req), (rem))
#define __libc_nanosleep(req, rem)   nanosleep((req), (rem))
#define libc_nanosleep(req, rem)   nanosleep((req), (rem))


LIB_FUNC int clock_nanosleep(const clockid_t clk, const int flags, const struct timespec* req, struct timespec* rem) {
	return -(int)(syscall(SYS_clock_nanosleep, clk, flags, (long)&req, (long)&rem));
}


LIB_FUNC int clock_getres(const clockid_t clk, struct timespec* ts) {
	return (int)syscall(SYS_clock_getres, clk, (long)&ts);
}


LIB_FUNC int timer_getoverrun(const timer_t t) {
	timer_t tmp_t = t;
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		tmp_t = (void*)((uintptr_t)(td->timer_id & INT_MAX));
	}
	return (int)syscall(SYS_timer_getoverrun, tmp_t);
}


LIB_FUNC int ntp_gettime(struct ntptimeval* ntv) {
	struct timex tntx;
	tntx.modes = 0;
	const int result = adjtimex(&tntx);
	ntv->time = tntx.time;
	ntv->maxerror = tntx.maxerror;
	ntv->esterror = tntx.esterror;
	return result;
}


LIB_FUNC int clock_gettime(const clockid_t clk, struct timespec* ts) {
	register int r = (int)__syscall2(SYS_clock_gettime, (long)clk, (long)ts);
	if (r == -ENOSYS) {
		if (clk == CLOCK_REALTIME) {
			__syscall2(SYS_gettimeofday, (long)ts, 0);
			ts->tv_nsec = (int)ts->tv_nsec * 1000;
			return 0;
		}
		r = -EINVAL;
	}
	return r;
}
#define __clock_gettime(clock_id, tp)   clock_gettime((clock_id), (tp))


LIB_FUNC int gettimeofday(struct timeval* restrict tv, UNUSED void* restrict tz) {
	if (!tv) { return 0; }
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	tv->tv_sec = ts.tv_sec;
	tv->tv_usec = (int)ts.tv_nsec / 1000;
	return 0;
}


#ifndef GETTIME
#   define GETTIME(low, high)   { struct timeval tval; gettimeofday(&tval, NULL); const uint64_t usecs = (uint64_t)tval.tv_usec + (uint64_t)tval.tv_usec * 1000000; low = usecs & 0xffffffff; high = usecs >> 32; }
#endif


LIB_FUNC int clock_getcpuclockid(const pid_t pid, clockid_t* clk) {
	struct timespec ts;
	clockid_t _id = (clockid_t)(((unsigned int)((-pid) - 1) * 8U) + 2);
	register int ret = (int)__syscall(SYS_clock_getres, _id, (long)&ts);
	if (ret) { return -ret; }
	*clk = _id;
	return 0;
}


LIB_FUNC int timer_gettime(timer_t t, struct itimerspec* val) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		t = (timer_t)(uintptr_t)(td->timer_id & INT_MAX);
	}
	return (int)syscall(SYS_timer_gettime, t, (long)&val);
}


LIB_FUNC int timer_settime(timer_t t, const int flags, const struct itimerspec* restrict val, struct itimerspec* restrict old) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		t = (void*)(uintptr_t)(td->timer_id & INT_MAX);
	}
	return (int)syscall(SYS_timer_settime, t, flags, (long)&val, (long)&old);
}


LIB_FUNC int timer_delete(const timer_t t) {
	if ((intptr_t)t < 0) {
		struct pthread* td = (void*)((uintptr_t)t << 1);
		a_store(&td->timer_id, (int)(td->timer_id | INT_MIN));
		__wake(&td->timer_id, 1, 1);
		return 0;
	}
	return (int)__syscall(SYS_timer_delete, (long)&t);
}


/** Like `mktime`, but for TP represents Universal Time, not local time */
LIB_FUNC time_t timegm(struct tm* _tm) {
	struct tm new;
	long long t = tm_to_secs(_tm);
	if (secs_to_tm(t, &new) < 0) {
		errno = EOVERFLOW;
		return -1;
	}
	*_tm = new;
	_tm->tm_isdst = 0;
	_tm->__tm_gmtoff = 0;
	_tm->__tm_zone = __gmt;
	return t;
}


LIB_FUNC void timeval50_to_timeval(const struct timeval50* ts50, struct timeval* ts) {
	ts->tv_sec = ts50->tv_sec; ts->tv_usec = (suseconds_t)ts50->tv_usec;
}


LIB_FUNC void timeval_to_timeval50(const struct timeval* ts, struct timeval50* ts50) {
	ts50->tv_sec = (long)ts->tv_sec; ts50->tv_usec = ts->tv_usec;
}


LIB_FUNC void timespec50_to_timespec(const struct timespec50* ts50, struct timespec* ts) {
	ts->tv_sec = ts50->tv_sec;
	ts->tv_nsec = ts50->tv_nsec;
}


LIB_FUNC void timespec_to_timespec50(const struct timespec* ts, struct timespec50* ts50) {
	ts50->tv_sec = (int32_t)ts->tv_sec;
	ts50->tv_nsec = ts->tv_nsec;
}


LIB_FUNC void itimerval50_to_itimerval(const struct itimerval50* ts50, struct itimerval* ts) {
	timeval50_to_timeval(&ts50->it_interval, &ts->it_interval);
	timeval50_to_timeval(&ts50->it_value, &ts->it_value);
}


LIB_FUNC void itimerval_to_itimerval50(const struct itimerval* ts, struct itimerval50* ts50) {
	timeval_to_timeval50(&ts->it_interval, &ts50->it_interval);
	timeval_to_timeval50(&ts->it_value, &ts50->it_value);
}


LIB_FUNC void itimerspec50_to_itimerspec(const struct itimerspec50* ts50, struct itimerspec* ts) {
	timespec50_to_timespec(&ts50->it_interval, &ts->it_interval);
	timespec50_to_timespec(&ts50->it_value, &ts->it_value);
}


LIB_FUNC void itimerspec_to_itimerspec50(const struct itimerspec* ts, struct itimerspec50* ts50) {
	timespec_to_timespec50(&ts->it_interval, &ts50->it_interval);
	timespec_to_timespec50(&ts->it_value, &ts50->it_value);
}


LIB_FUNC int realtime_gettime(struct timespec* tp) {
	struct timeval tv;
	const int retval = gettimeofday(&tv, NULL);
	if (retval == 0) { TIMEVAL_TO_TIMESPEC(&tv, tp); }
	return retval;
}


LIB_FUNC clock_t clock(void) {
	struct timespec ts;
	if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts)) { return -1; }
	else if (ts.tv_sec > (LONG_MAX / 1000000) || (ts.tv_nsec / 1000) > (LONG_MAX - (1000000 * ts.tv_sec))) { return -1; }
	return ((ts.tv_sec * 1000000) + (ts.tv_nsec / 1000));
}


LIB_FUNC time_t time(time_t* t) {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	if (t) { *t = ts.tv_sec; }
	return ts.tv_sec;
}
#define sys_time(x)   time((x))


/** Return date and time */
LIB_FUNC int ftime(struct timeb* tp) {
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &ts);
	tp->time = ts.tv_sec;
	tp->millitm = (unsigned short)(ts.tv_nsec / 1000000);
	tp->timezone = tp->dstflag = 0;
	return 0;
}


LIB_FUNC const unsigned char* __map_file(const char* restrict pathname, size_t* size) {
	struct stat st;
	const unsigned char* map = MAP_FAILED;
	int fd = (int)__sys_open(pathname, (O_RDONLY | O_CLOEXEC | O_NONBLOCK));
	if (fd < 0) { return 0; }
	else if (!(__syscall(SYS_fstat, fd, (long)&st))) {
		map = mmap(0, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, 0);
		*size = (size_t)st.st_size;
	}
	__syscall(SYS_close, fd);
	return (const unsigned char*)(map == MAP_FAILED ? 0 : map);
}


/** Determine the time zone in effect for a given time in seconds since the epoch; It can be given in local or universal time */
LIB_FUNC void secs_to_zone(long long t, int local, int* isdst, long* offset, long* oppoff, const char** zonename) {
	LOCK(lock);
	do_tzset();
	if (zi) {
		size_t alt, i = (size_t)scan_trans(t, local, &alt);
		if (i != (size_t)-1) {
			*isdst = types[6 * i + 4];
			*offset = (int32_t)zi_read32(types + 6 * i);
			*zonename = (const char*)abbrevs + types[6 * i + 5];
			if (oppoff) { *oppoff = (int32_t)zi_read32(types + 6 * alt); }
			UNLOCK(lock);
			return;
		}
	}
	if (!(__daylight)) {
		*isdst = 0;
		*offset = -__timezone;
		if (oppoff) { *oppoff = -dst_off; }
		*zonename = __tzname[0];
		UNLOCK(lock);
		return;
	}
	long long y = (long long)(t / 31556952 + 70);
	while (year_to_secs(y, 0) > t) { --y; }
	while (year_to_secs((y + 1), 0) < t) { ++y; }
	long long t0 = rule_to_secs(r0, (int)y);
	long long t1 = rule_to_secs(r1, (int)y);
	if (t0 < t1) {
		if (!local) {
			t0 += __timezone;
			t1 += dst_off;
		}
		if (t >= t0 && t < t1) {
			*isdst = 1;
			*offset = -dst_off;
			if (oppoff) { *oppoff = -__timezone; }
			*zonename = __tzname[1];
			UNLOCK(lock);
			return;
		}
		*isdst = 0;
		*offset = -__timezone;
		if (oppoff) { *oppoff = -dst_off; }
		*zonename = __tzname[0];
		UNLOCK(lock);
		return;
	} else {
		if (!local) {
			t1 += __timezone;
			t0 += dst_off;
		}
		if (t >= t1 && t < t0) {
			*isdst = 0;
			*offset = -__timezone;
			if (oppoff) { *oppoff = -dst_off; }
			*zonename = __tzname[0];
			UNLOCK(lock);
			return;
		}
		*isdst = 1;
		*offset = -dst_off;
		if (oppoff) { *oppoff = -__timezone; }
		*zonename = __tzname[1];
		UNLOCK(lock);
		return;
	}
	UNREACHABLE
}
#define __secs_to_zone(t, local, isdst, offset, oppoff, zonename)   secs_to_zone((t), (local), (isdst), (offset), (oppoff), (zonename))


LIB_FUNC struct tm* gmtime(const time_t* t) {
	static struct tm _tm;
	return gmtime_r(t, &_tm);
}


LIB_FUNC struct tm* gmtime_r(const time_t* restrict t, struct tm* restrict _tm) {
	if (secs_to_tm(*t, _tm) < 0) {
		errno = EOVERFLOW;
		return 0;
	}
	_tm->tm_isdst = 0;
	_tm->__tm_gmtoff = 0;
	_tm->__tm_zone = __gmt;
	return _tm;
}
#define __gmtime_r(t, _tm)   gmtime_r((t), (_tm))


LIB_FUNC uint32_t zi_read32(const unsigned char* z) {
	return (uint32_t)((unsigned)z[0] << 24 | (unsigned)z[1] << 16 | (unsigned)z[2] << 8 | (unsigned)z[3]);
}


LIB_FUNC size_t zi_dotprod(const unsigned char* z, const unsigned char* v, size_t n) {
	register size_t y;
	register uint32_t x;
	for (y = 0; n; n--, z += 4, v++) {
		x = zi_read32(z);
		y += (x * (*v));
	}
	return y;
}


LIB_FUNC time_t mktime(struct tm* _tm) {
	struct tm new;
	long opp;
	long long t = tm_to_secs(_tm);
	__secs_to_zone(t, 1, &new.tm_isdst, &new.__tm_gmtoff, &opp, &new.__tm_zone);
	if (_tm->tm_isdst>=0 && new.tm_isdst!=_tm->tm_isdst) { t -= (long long)(opp - new.__tm_gmtoff); }
	t -= new.__tm_gmtoff;
	if ((time_t)t != t) { errno = EOVERFLOW; return -1; }
	secs_to_zone(t, 0, &new.tm_isdst, &new.__tm_gmtoff, &opp, &new.__tm_zone);
	if (secs_to_tm(t + new.__tm_gmtoff, &new) < 0) { errno = EOVERFLOW; return -1; }
	*_tm = new;
	return t;
}


LIB_FUNC void do_tzset(void) {
	char buf[NAME_MAX + 25], *pathname = buf + 24;
	const char *try, *s, *p;
	const unsigned char* map = 0;
	size_t i;
	static const char search[64] = "/usr/share/zoneinfo/\0/share/zoneinfo/\0/etc/zoneinfo/\0";
	s = getenv("TZ");
	if (!s) { s = "/etc/localtime"; }
	else if (!*s) { s = __gmt; }
	if (old_tz && (!strcmp(s, old_tz))) { return; }
	else if (zi) { munmap_const((const void*)zi, map_size); }
	i = strlen(s);
	if (i > PATH_MAX + 1) { s = __gmt, i = 3; }
	if (i >= old_tz_size) {
		old_tz_size *= 2;
		if (i >= old_tz_size) { old_tz_size = i + 1; }
		if (old_tz_size > PATH_MAX + 2) { old_tz_size = PATH_MAX + 2; }
		old_tz = malloc(old_tz_size);
	}
	if (old_tz) { memcpy_no_output(old_tz, s, (i + 1)); }
	// Non-suid can use an absolute tzfile pathname or a relative pathame beginning with "."; in secure mode, only the standard path will be searched
	if (*s == ':' || ((p = strchr(s, '/')) && !(memchr(s, ',', (size_t)(p - s))))) {
		if (*s == ':') { s++; }
		if (*s == '/' || *s == '.') {
			if (!libc.secure || !(strcmp(s, "/etc/localtime"))) {
				map = __map_file(s, &map_size);
			}
		} else {
			size_t l = strlen(s);
			if (l <= NAME_MAX && !(strchr(s, '.'))) {
				memcpy_no_output(pathname, s, (l + 1));
				pathname[l] = 0;
				for (try = search; !(map) && *try; try += l + 1) {
					l = strlen(try);
					memcpy_no_output((pathname - l), try, l);
					map = __map_file((pathname - l), &map_size);
				}
			}
		}
		if (!map) { s = __gmt; }
	}
	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
		munmap_const((const void*)map, map_size);
		map = 0;
		s = __gmt;
	}
	zi = map;
	if (map) {
		int scale = 2;
		if (SIZEOF_TIME_T > 4 && map[4] == '2') {
			size_t skip = zi_dotprod((zi + 20), VEC(1, 1, 8, 5, 6, 1), 6);
			trans = zi + skip + 88;
			++scale;
		} else { trans = zi + 44; }
		types = (unsigned char*)(((uintptr_t)trans + (zi_read32(trans - 12) << scale)) + zi_read32(trans - 12));
		abbrevs = (types + 6 * zi_read32(trans - 8));
		abbrevs_end = (abbrevs + zi_read32(trans - 4));
		if (zi[map_size - 1] == '\n') {
			for (s = (const char*)zi + map_size - 2; *s != '\n'; --s);
			++s;
		} else {
			const unsigned char* p;
			__tzname[0] = __tzname[1] = 0;
			__daylight = 0;
			__timezone = dst_off = 0;
			for (i = 0; i < 5; i++) { rule0[i] = rule1[i] = 0; }
			for (p = types; p < abbrevs; p += 6) {
				if (!p[4] && !(__tzname[0])) {
					__tzname[0] = (char*)abbrevs + p[5];
					__timezone = -zi_read32(p);
				}
				if (p[4] && !(__tzname[1])) {
					__tzname[1] = (char*)abbrevs + p[5];
					dst_off = -zi_read32(p);
					__daylight = 1;
				}
			}
			if (!__tzname[0]) { __tzname[0] = __tzname[1]; }
			if (!__tzname[0]) { __tzname[0] = (char*)__gmt; }
			if (!__daylight) {
				__tzname[1] = __tzname[0];
				dst_off = __timezone;
			}
			return;
		}
	}
	if (!s) { s = __gmt; }
	getname(std_name, &s);
	__tzname[0] = std_name;
	__timezone = getoff(&s);
	getname(dst_name, &s);
	__tzname[1] = dst_name;
	if (dst_name[0]) {
		__daylight = 1;
		if (*s == '+' || *s == '-' || (unsigned int)(*s - '0') < 10U) { dst_off = getoff(&s); }
		else { dst_off = __timezone - 3600; }
	} else {
		__daylight = 0;
		dst_off = 0;
	}
	if (*s == ',') { s++, getrule(&s, rule0); }
	if (*s == ',') { s++, getrule(&s, rule1); }
}


/** Search zoneinfo rules to find the one that applies to the given time, and determine alternate opposite-DST-status rule that may be needed */
LIB_FUNC size_t scan_trans(long long t, int local, size_t* alt) {
	int scale = (int)(3 - (trans == zi + 44));
	uint64_t x;
	int off = 0;
	size_t a = 0, n = (size_t)((time_index - trans) >> scale), m;
	if (!n) {
		if (alt) { *alt = 0; }
		return 0;
	}
	while (n > 1) {  // Binary search for 'most-recent rule before t'
		m = (a + n) >> 1;
		x = zi_read32(trans + (m << scale));
		if (scale == 3) { x = (x << 32 | zi_read32(trans + (m << scale) + 4)); }
		else { x = (uint64_t)((int32_t)x); }
		if (local) { off = (int)zi_read32(types + 6 * time_index[m - 1]); }
		if ((int64_t)(t - off) < (int64_t)x) {
			n /= 2;
		} else {
			a = m;
			n -= (n / 2);
		}
	}
	n = (size_t)((time_index - trans) >> scale);
	if (a == (n - 1)) { return (size_t)-1; }
	else if (a == 0) {
		x = zi_read32(trans + (a << scale));
		if (scale == 3) { x = (x << 32 | zi_read32(trans + (a << scale) + 4)); }
		else { x = (uint64_t)((int32_t)x); }
		if (local) { off = (int32_t)zi_read32(types + 6 * time_index[a - 1]); }
		if (t - off < (int64_t)x) {
			for (a = 0; a < (size_t)((abbrevs - types) / 6); a++) {
				if (types[6 * a + 4] != types[4]) { break; }
			}
			if (a == (size_t)((abbrevs - types) / 6)) { a = 0; }
			if (types[6 * a + 4]) {
				*alt = a;
				return 0;
			} else {
				*alt = 0;
				return a;
			}
			UNREACHABLE
		}
	}
	if (alt) {  // Try to find a neighboring opposite-DST-status rule
		if (a && types[6 * time_index[a - 1] + 4] != types[6 * time_index[a] + 4]) { *alt = time_index[a - 1]; }
		else if (a + 1 < n && types[6 * time_index[a + 1] + 4] != types[6 * time_index[a] + 4]) { *alt = time_index[a + 1]; }
		else { *alt = time_index[a]; }
	}
	return time_index[a];
}


LIB_FUNC void tzset(void) {
	LOCK(tm_lock);
	do_tzset();
	UNLOCK(tm_lock);
}
#define __tzset()   tzset()


LIB_FUNC size_t strftime_l(char* restrict s, size_t n, const char* restrict f, const struct tm* restrict _tm, locale_t loc) {
	size_t l, k;
	char buf[100];
	const char* p;
	const char* t;
	int plus;
	unsigned long width;
	for (l = 0; l < n; f++) {
		if (!(*f)) {
			s[l] = 0;
			return l;
		} else if (*f != '%') {
			s[l++] = *f;
			continue;
		}
		f++;
		if ((plus = (*f == '+'))) { f++; }
		width = strtoul(f, &p, 10);
		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
			if (!width && p != f) { width = 1; }
		} else {
			width = 0;
		}
		f = p;
		if (*f == 'E' || *f == 'O') { f++; }
		t = strftime_fmt_1(&buf, &k, *f, _tm, loc);
		if (!t) { break; }
		if (width) {
			for (; *t == '+' || *t == '-' || (*t == '0' && t[1]); t++, k--);
			width--;
			if (plus && _tm->tm_year >= 8100) { s[l++] = '+'; }
			else if (_tm->tm_year < -1900) { s[l++] = '-'; }
			else { width++; }
			for (; width > k && l < n; width--) { s[l++] = '0'; }
		}
		if (k > n - l) { k = n - l; }
		memcpy_no_output((s + l), t, k);
		l += k;
	}
	if (n) {
		if (l == n) { l = n - 1; }
		s[l] = 0;
	}
	return 0;
}
#define __strftime_l(s, n, f, _tm, loc)   strftime_l((s), (n), (f), (_tm), (loc))


LIB_FUNC size_t strftime(char* restrict s, size_t n, const char* restrict f, const struct tm* restrict _tm) {
	return __strftime_l(s, n, f, _tm, CURRENT_LOCALE);
}


LIB_FUNC const char* strftime_fmt_1(char (*s)[100], size_t* l, int f, const struct tm* _tm, locale_t loc) {
	nl_item item;
	long long val;
	const char* frmt = "-";
	int width = 2;
	switch (f) {
		case 'a':
			if (_tm->tm_wday > 6) { goto strftime_fmt_1_strftime_string; }
			item = ABDAY_1 + _tm->tm_wday;
			goto strftime_fmt_1_nl_strcat;
		case 'A':
			if (_tm->tm_wday > 6) { goto strftime_fmt_1_strftime_string; }
			item = DAY_1 + _tm->tm_wday;
			goto strftime_fmt_1_nl_strcat;
		case 'h':
		case 'b':
			if (_tm->tm_mon > 11) { goto strftime_fmt_1_strftime_string; }
			item = ABMON_1 + _tm->tm_mon;
			goto strftime_fmt_1_nl_strcat;
		case 'B':
			if (_tm->tm_mon > 11) { goto strftime_fmt_1_strftime_string; }
			item = MON_1 + _tm->tm_mon;
			goto strftime_fmt_1_nl_strcat;
		case 'c':
			item = D_T_FMT;
			goto strftime_fmt_1_nl_strftime;
		case 'C':
			val = (1900LL + _tm->tm_year) / 100;
			goto strftime_fmt_1_number;
		case 'd':
			val = _tm->tm_mday;
			goto strftime_fmt_1_number;
		case 'D':
			frmt = "%m/%d/%y";
			goto strftime_fmt_1_recu_strftime;
		case 'e':
			*l = (size_t)snprintf(*s, sizeof(*s), "%2d", _tm->tm_mday);
			return *s;
		case 'F':
			frmt = "%Y-%m-%d";
			goto strftime_fmt_1_recu_strftime;
		case 'g':
		case 'G':
			val = _tm->tm_year + 1900LL;
			if (_tm->tm_yday < 3 && week_num(_tm) != 1) { val--; }
			else if (_tm->tm_yday > 360 && week_num(_tm) == 1) { val++; }
			if (f == 'g') { val %= 100; }
			else { width = 4; }
			goto strftime_fmt_1_number;
		case 'H':
			val = _tm->tm_hour;
			goto strftime_fmt_1_number;
		case 'I':
			val = _tm->tm_hour;
			if (!val) { val = 12; }
			else if (val > 12) { val -= 12; }
			goto strftime_fmt_1_number;
		case 'j':
			val = _tm->tm_yday + 1;
			width = 3;
			goto strftime_fmt_1_number;
		case 'm':
			val = _tm->tm_mon + 1;
			goto strftime_fmt_1_number;
		case 'M':
			val = _tm->tm_min;
			goto strftime_fmt_1_number;
		case 'n':
			*l = 1;
			return "\n";
		case 'p':
			item = (_tm->tm_hour >= 12 ? PM_STR : AM_STR);
			goto strftime_fmt_1_nl_strcat;
		case 'r':
			item = T_FMT_AMPM;
			goto strftime_fmt_1_nl_strftime;
		case 'R':
			frmt = "%H:%M";
			goto strftime_fmt_1_recu_strftime;
		case 's':
			val = (__tm_to_secs(_tm) - _tm->__tm_gmtoff);
			width = 1;
			goto strftime_fmt_1_number;
		case 'S':
			val = _tm->tm_sec;
			goto strftime_fmt_1_number;
		case 't':
			*l = 1;
			return "\t";
		case 'T':
			frmt = "%H:%M:%S";
			goto strftime_fmt_1_recu_strftime;
		case 'u':
			val = (_tm->tm_wday ? _tm->tm_wday : 7);
			width = 1;
			goto strftime_fmt_1_number;
		case 'U':
			val = (_tm->tm_yday + 7 - _tm->tm_wday) / 7;
			goto strftime_fmt_1_number;
		case 'W':
			val = (_tm->tm_yday + 7 - (_tm->tm_wday + 6) % 7) / 7;
			goto strftime_fmt_1_number;
		case 'V':
			val = week_num(_tm);
			goto strftime_fmt_1_number;
		case 'w':
			val = _tm->tm_wday;
			width = 1;
			goto strftime_fmt_1_number;
		case 'x':
			item = D_FMT;
			goto strftime_fmt_1_nl_strftime;
		case 'X':
			item = T_FMT;
			goto strftime_fmt_1_nl_strftime;
		case 'y':
			val = _tm->tm_year % 100;
			goto strftime_fmt_1_number;
		case 'Y':
			val = _tm->tm_year + 1900LL;
			if (val >= 10000) {
				*l = (size_t)snprintf(*s, sizeof(*s), "+%lld", val);
				return *s;
			}
			width = 4;
			goto strftime_fmt_1_number;
		case 'z':
			if (_tm->tm_isdst < 0) {
				*l = 0;
				return "";
			}
			*l = (size_t)snprintf(*s, sizeof(*s), "%+.2d%.2d", ((_tm->__tm_gmtoff) / 3600), (abs(_tm->__tm_gmtoff % 3600) / 60));
			return *s;
		case 'Z':
			if (_tm->tm_isdst < 0) {
				*l = 0;
				return "";
			}
			frmt = __tm_to_tzname(_tm);
			goto strftime_fmt_1_strftime_string;
		case '%':
			*l = 1;
			return "%";
		default:
			return 0;
	}
strftime_fmt_1_number:
	*l = (size_t)snprintf(*s, sizeof(*s), "%0*lld", width, val);
	return *s;
strftime_fmt_1_nl_strcat:
	frmt = __nl_langinfo_l(item, loc);
strftime_fmt_1_strftime_string:
	*l = strlen(frmt);
	return frmt;
strftime_fmt_1_nl_strftime:
	frmt = __nl_langinfo_l(item, loc);
strftime_fmt_1_recu_strftime:
	*l = __strftime_l(*s, sizeof(*s), frmt, _tm, loc);
	if (!*l) { return 0; }
	return *s;
}
#define __strftime_fmt_1(s, l, f, _tm, loc)   strftime_fmt_1((s), (l), (f), (_tm), (loc))


LIB_FUNC int stime(const time_t* when) {
	struct timeval tv;
	if (when == NULL) { __set_errno(EINVAL); return -1; }
	tv.tv_sec = *when;
	tv.tv_usec = 0;
	return settimeofday(&tv, (struct timezone_struct*)0);
}


LIB_FUNC struct tm* localtime_r(const time_t* restrict t, struct tm* restrict _tm) {
	if (*t < INT_MIN * 31622400LL || *t > INT_MAX * 31622400LL) {
		errno = EOVERFLOW;
		return 0;
	}
	__secs_to_zone(*t, 0, &_tm->tm_isdst, &_tm->__tm_gmtoff, 0, &_tm->__tm_zone);
	if (__secs_to_tm((long long)*t + _tm->__tm_gmtoff, _tm) < 0) {
		errno = EOVERFLOW;
		return 0;
	}
	return _tm;
}
#define __localtime_r(t, _tm)   localtime_r((t), (_tm))


LIB_FUNC struct tm* localtime(const time_t* t) {
	static struct tm _tm;
	return localtime_r(t, &_tm);
}


LIB_FUNC char* __asctime(const struct tm* restrict _tm, char* restrict buf) {
	if (snprintf(buf, 26, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n", __nl_langinfo(ABDAY_1 + _tm->tm_wday), __nl_langinfo(ABMON_1 + _tm->tm_mon), _tm->tm_mday, _tm->tm_hour, _tm->tm_min, _tm->tm_sec, 1900 + _tm->tm_year) >= 26) { a_crash(); }
	return buf;
}


LIB_FUNC char* asctime_r(const struct tm* restrict _tm, char* restrict buf) {
	return __asctime(_tm, buf);
}


LIB_FUNC char* asctime(const struct tm* _tm) {
	static char buf[26];
	return __asctime(_tm, buf);
}


LIB_FUNC char* ctime_r(const time_t* t, char* buf) {
	struct tm _tm;
	localtime_r(t, &_tm);
	return __asctime(&_tm, buf);
}


LIB_FUNC char* ctime(const time_t* t) {
	static char buf[26];
	return __asctime(localtime(t), buf);
}


/** There is no other implemented value than TIME_UTC; all other values are considered erroneous */
LIB_FUNC int timespec_get(struct timespec* ts, const int base) {
	if (base != TIME_UTC) { return 0; }
	register int ret = __clock_gettime(CLOCK_REALTIME, ts);
	return ((ret < 0) ? 0 : base);
}


#define OFFSETOF_TM_YDAY   28
LIB_FUNC const char* strptime(const char* restrict s, const char* f, struct tm* restrict _tm) {
	int i, w, neg, adj, min, range, *dest, _dummy;
	const char* ex;
	size_t len;
	int want_century = 0, century = 0;
	while (*f) {
		if (*f != '%') {
			if (isspace(*f)) { for (; *s && isspace(*s); s++); }
			else if (*s != *f) { return 0; }
			else { ++s; }
			++f;
			continue;
		}
		++f;
		if (*f == '+') { ++f; }
		if (isdigit(*f)) { w = (int)strtoul(f, (void*)&f, 10); }
		else { w = -1; }
		adj = 0;
		switch (*f++) {
			case 'a':
			case 'A':
				dest = &_tm->tm_wday;
				min = ABDAY_1;
				range = 7;
				goto strptime_symbolic_range;
			case 'b':
			case 'B':
			case 'h':
				dest = &_tm->tm_mon;
				min = ABMON_1;
				range = 12;
				goto strptime_symbolic_range;
			case 'c':
				s = strptime(s, nl_langinfo(D_T_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'C':
				dest = &century;
				if (w < 0) { w = 2; }
				want_century |= 2;
				goto strptime_numeric_digits;
			case 'd':
			case 'e':
				dest = &_tm->tm_mday;
				min = 1;
				range = 31;
				goto strptime_numeric_range;
			case 'D':
				s = strptime(s, "%m/%d/%y", _tm);
				if (!s) { return 0; }
				break;
			case 'H':
				dest = &_tm->tm_hour;
				min = 0;
				range = 24;
				goto strptime_numeric_range;
			case 'I':
				dest = &_tm->tm_hour;
				min = 1;
				range = 12;
				goto strptime_numeric_range;
			case 'j':
				dest = &_tm->tm_yday;
				min = 1;
				range = 366;
				goto strptime_numeric_range;
			case 'm':
				dest = &_tm->tm_mon;
				min = 1;
				range = 12;
				adj = 1;
				goto strptime_numeric_range;
			case 'M':
				dest = &_tm->tm_min;
				min = 0;
				range = 60;
				goto strptime_numeric_range;
			case 'n':
			case 't':
				for (; *s && isspace(*s); s++);
				break;
			case 'p':
				ex = nl_langinfo(AM_STR);
				len = strlen(ex);
				if (!(strncasecmp(s, ex, len))) {
					_tm->tm_hour %= 12;
					break;
				}
				ex = nl_langinfo(PM_STR);
				len = strlen(ex);
				if (!(strncasecmp(s, ex, len))) {
					_tm->tm_hour %= 12;
					_tm->tm_hour += 12;
					break;
				}
				return 0;
			case 'r':
				s = strptime(s, nl_langinfo(T_FMT_AMPM), _tm);
				if (!s) { return 0; }
				break;
			case 'R':
				s = strptime(s, "%H:%M", _tm);
				if (!s) { return 0; }
				break;
			case 'S':
				dest = &_tm->tm_sec;
				min = 0;
				range = 61;
				goto strptime_numeric_range;
			case 'T':
				s = strptime(s, "%H:%M:%S", _tm);
				if (!s) { return 0; }
				break;
			case 'U':
			case 'W':
				dest = &_dummy;
				min = 0;
				range = 54;
				goto strptime_numeric_range;
			case 'w':
				dest = &_tm->tm_wday;
				min = 0;
				range = 7;
				goto strptime_numeric_range;
			case 'x':
				s = strptime(s, nl_langinfo(D_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'X':
				s = strptime(s, nl_langinfo(T_FMT), _tm);
				if (!s) { return 0; }
				break;
			case 'y':
				dest = &_tm->tm_year;
				w = 2;
				want_century |= 1;
				goto strptime_numeric_digits;
			case 'Y':
				dest = &_tm->tm_year;
				if (w < 0) { w = 4; }
				adj = 1900;
				want_century = 0;
				goto strptime_numeric_digits;
			case '%':
				if (*s++ != '%') { return 0; }
				break;
			default:
				return 0;
			strptime_numeric_range:
				if (!isdigit(*s)) { return 0; }
				*dest = 0;
				for (i = 1; i <= (min + range) && isdigit(*s); i *= 10) {
					*dest = ((*dest * 10) + (*s++ - '0'));
				}
				if ((*dest - min) >= range) { return 0; }
				*dest -= adj;
				switch ((char*)dest - (char*)_tm) {
					case OFFSETOF_TM_YDAY: break;
					default: goto strptime_update;
				}
				goto strptime_update;
			strptime_numeric_digits:
				neg = 0;
				if (*s == '+') { s++; }
				else if (*s == '-') { neg = 1; s++; }
				if (!isdigit(*s)) { return 0; }
				for (*dest = i = 0; i < w && isdigit(*s); i++) { *dest = *dest * 10 + *s++ - '0'; }
				if (neg) { *dest = -*dest; }
				*dest -= adj;
				goto strptime_update;
			strptime_symbolic_range:
				for (i = 2 * range - 1; i >= 0; i--) {
					ex = nl_langinfo(min + i);
					len = strlen(ex);
					if (strncasecmp(s, ex, len)) { continue; }
					s += len;
					*dest = i % range;
					break;
				}
				if (i < 0) { return 0; }
				goto strptime_update;
			strptime_update:
				;
		}
	}
	if (want_century) {
		if (want_century & 2) { _tm->tm_year += (century * 100 - 1900); }
		else if (_tm->tm_year <= 68) { _tm->tm_year += 100; }
	}
	return (const char*)s;
}


LIB_FUNC struct tm* getdate(const char* s) {
	static struct tm tmbuf;
	struct tm* ret = 0;
	const char* datemsk = getenv("DATEMSK");
	FILE* f = 0;
	char fmt[100] = { 0 };
	const char* p;
	int cs;
	pthread_setcancelstate(PTHREAD_CANCEL_DEFERRED, &cs);
	if (!datemsk) {
		getdate_err = 1;
		goto getdate_out;
	}
	f = fopen(datemsk, "rbe");
	if (!f) {
		if (errno == ENOMEM) { getdate_err = 6; }
		else { getdate_err = 2; }
		goto getdate_out;
	}
	while (fgets(fmt, sizeof(fmt), f)) {
		p = strptime(s, fmt, &tmbuf);
		if (p && !(*p)) {
			ret = &tmbuf;
			goto getdate_out;
		}
	}
	getdate_err = 7;
getdate_out:
	if (f) { fclose(f); }
	pthread_setcancelstate(cs, 0);
	return ret;
}


LIB_FUNC int utimensat(int fd, const char* path, const struct timespec times[2], int flags) {
	int r = (int)syscall(SYS_utimensat, fd, path, times, flags);
#   ifdef SYS_futimesat
	if (r != (-ENOSYS) || flags) { return (int)__syscall_ret((unsigned long)r); }
	struct timeval* tv = 0, tmp[2];
	if (times) {
		int i;
		tv = tmp;
		for (i = 0; i < 2; i++) {
			if (times[i].tv_nsec >= (long)1000000000ULL) {
				if (times[i].tv_nsec == UTIME_NOW && times[1 - i].tv_nsec == UTIME_NOW) {
					tv = 0;
					break;
				}
				if (times[i].tv_nsec == UTIME_OMIT) {
					return (int)__syscall_ret((long)(ENOSYS));
				}
				return (int)__syscall_ret((long)(EINVAL));
			}
			tmp[i].tv_sec = times[i].tv_sec;
			tmp[i].tv_usec = times[i].tv_nsec / 1000;
		}
	}
	r = (int)syscall(SYS_futimesat, fd, path, tv);
	if (r != (-ENOSYS) || fd != AT_FDCWD) { return (int)__syscall_ret((unsigned long)r); }
	r = (int)syscall(SYS_utimes, path, tv);
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


LIB_FUNC int lutimes(const char* filename, const struct timeval tv[2]) {
	struct timespec times[2];
	times[0].tv_sec = tv[0].tv_sec;
	times[0].tv_nsec = tv[0].tv_usec * 1000;
	times[1].tv_sec = tv[1].tv_sec;
	times[1].tv_nsec = tv[1].tv_usec * 1000;
	return utimensat(AT_FDCWD, filename, times, AT_SYMLINK_NOFOLLOW);
}


LIB_FUNC int futimens(int fd, const struct timespec times[2]) {
	return utimensat(fd, 0, times, 0);
}


LIB_FUNC int futimes(int fd, const struct timeval tv[2]) {
	struct timespec times[2];
	if (!tv) { return futimens(fd, 0); }
	times[0].tv_sec = tv[0].tv_sec;
	times[0].tv_nsec = tv[0].tv_usec * 1000;
	times[1].tv_sec = tv[1].tv_sec;
	times[1].tv_nsec = tv[1].tv_usec * 1000;
	return futimens(fd, times);
}


LIB_FUNC int futimesat(int dirfd, const char* pathname, const struct timeval times[2]) {
	struct timespec ts[2];
	if (times) {
		int i;
		for (i = 0; i < 2; i++) {
			if (times[i].tv_usec >= (long)1000000ULL) {
				return (int)__syscall_ret((long)(EINVAL));
			}
			ts[i].tv_sec = times[i].tv_sec;
			ts[i].tv_nsec = times[i].tv_usec * 1000;
		}
	}
	return utimensat(dirfd, pathname, times ? ts : 0, 0);
}
#define __futimesat(dirfd, pathname, times)   futimesat((dirfd), (pathname), (times))


LIB_FUNC int utimes(const char* path, const struct timeval times[2]) {
	return futimesat(AT_FDCWD, path, times);
}


LIB_FUNC void bintime_addx(struct bintime* bt, uint64_t x) {
	uint64_t u = bt->frac;
	bt->frac += x;
	if (u > bt->frac) { bt->sec++; }
}


LIB_FUNC void bintime_add(struct bintime* bt, const struct bintime* bt2) {
	uint64_t u = bt->frac;
	bt->frac += bt2->frac;
	if (u > bt->frac) { bt->sec++; }
	bt->sec += bt2->sec;
}


LIB_FUNC void bintime_sub(struct bintime* bt, const struct bintime* bt2) {
	uint64_t u = bt->frac;
	bt->frac -= bt2->frac;
	if (u < bt->frac) { bt->sec--; }
	bt->sec -= bt2->sec;
}


#define bintimecmp(bta, btb, cmp)   (((bta)->sec == (btb)->sec) ? ((bta)->frac cmp (btb)->frac) : ((bta)->sec cmp (btb)->sec))


LIB_FUNC void bintime2timespec(const struct bintime* bt, struct timespec* ts) {
	ts->tv_sec = bt->sec;
	ts->tv_nsec = (long)(((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}


LIB_FUNC void timespec2bintime(const struct timespec* ts, struct bintime* bt) {
	bt->sec = ts->tv_sec;
	bt->frac = (uint64_t)ts->tv_nsec * (uint64_t)18446744073ULL;
}


LIB_FUNC void bintime2timeval(const struct bintime* bt, struct timeval* tv) {
	tv->tv_sec = bt->sec;
	tv->tv_usec = (suseconds_t)(((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}


LIB_FUNC void timeval2bintime(const struct timeval* tv, struct bintime* bt) {
	bt->sec = tv->tv_sec;
	bt->frac = (uint64_t)tv->tv_usec * (uint64_t)18446744073709ULL;
}


LIB_FUNC struct bintime ms2bintime(const uint64_t ms) {
	struct bintime bt;
	bt.sec = (time_t)(ms / 1000U);
	bt.frac = (((ms % 1000U) >> 32) / 1000U) >> 32;
	return bt;
}


LIB_FUNC struct bintime us2bintime(const uint64_t us) {
	struct bintime bt;
	bt.sec = (time_t)(us / 1000000U);
	bt.frac = (((us % 1000000U) >> 32) / 1000000U) >> 32;
	return bt;
}


LIB_FUNC struct bintime ns2bintime(const uint64_t ns) {
	struct bintime bt;
	bt.sec = (time_t)(ns / 1000000000U);
	bt.frac = (((ns % 1000000000U) >> 32) / 1000000000U) >> 32;
	return bt;
}


#ifdef OSPOSIX
/**
	Return the current time in microseconds since the epoch
	@returns current microseconds since the epoch
*/
LIB_FUNC ulint time_microseconds(void) {
	struct timeval now;
	gettimeofday(&now, NULL);
	return (ulint)((1000000UL * (ulint)now.tv_sec) + (ulint)now.tv_usec);
}
#endif


/**
	Return the current time in seconds since the epoch
	@returns current seconds since the epoch
*/
LIB_FUNC ulint time_seconds(void) {
	time_t timer;
	return (ulint)time(&timer);
}


/* TODO: Add time functions
// Another name for `mktime`
extern time_t timelocal (struct tm *__tp) __THROW;
// Return the number of days in YEAR
extern int dysize (int __year) __THROW  __attribute__((__const__));
extern int getdate_r (const char* restrict __string, struct tm* restrict __resbufp);
*/


#endif  // TIME_H


/* FILE ACCESS AND MODIFICATION TIMES (<sys/times.h>) */


#if (!(defined(SYS_TIMES_H) || defined(_SYS_TIMES_H) || defined(SYS_TIMES_H_) || defined(_SYS_TIMES_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_times.h.html
#define SYS_TIMES_H   (1)
#define _SYS_TIMES_H   (1)
#define SYS_TIMES_H_   (1)
#define _SYS_TIMES_H_   (1)


typedef struct tms {
	clock_t tms_utime;  // User CPU time
	clock_t tms_stime;  // System CPU time
	clock_t tms_cutime;  // User CPU time of terminated child processes
	clock_t tms_cstime;  // System CPU time of terminated child processes
} tms_t;


LIB_FUNC clock_t times(struct tms* _tms) {
	return (clock_t)__syscall(SYS_times, (long)&_tms);
}


#endif  // SYS_TIMES_H


/* ACCESS AND MODIFICATION TIME (<utime.h>) */


#if (!(defined(_UTIME_H) || defined(_UTIME_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/utime.h.html
#define UTIME_H   (1)
#define _UTIME_H   (1)
#define _UTIME_H_   (1)


/** Structure describing file times */
typedef struct utimbuf {
	time_t actime;  // Access time
	time_t modtime;  // Modification time
} utimbuf_t;


/** Set the access and modification times of FILE to those given in *FILE_TIMES; If FILE_TIMES is NULL, set them to the current time */
LIB_FUNC int utime(const char* path, const struct utimbuf* times) {
	return utimensat(AT_FDCWD, path, times ? ((struct timespec [2]) { { .tv_sec = times->actime }, { .tv_sec = times->modtime } }) : 0, 0);
}


/** Change a file's modification time to now */
LIB_FUNC int touch_file(const char* fname) {
	if (utime(fname, NULL) != 0) { return -1; }
	return 0;
}


#endif  // UTIME_H


/* STATFS & STATVFS (<sys/statfs.h> & <sys/statvfs.h>) */


#if (!(defined(SYS_STATVFS_H) || defined(SYS_STATVFS_H_) || defined(_SYS_STATVFS_H_) || defined(_SYS_STATFS_H) || defined(_SYS_STATFS_H_)))
#define SYS_STATVFS_H   (1)
#define SYS_STATVFS_H_   (1)
#define _SYS_STATVFS_H_   (1)
#define _SYS_STATFS_H   (1)
#define _SYS_STATFS_H_   (1)


#define _STATFS_F_NAMELEN
#define _STATFS_F_FRSIZE


/** Structure and datatype used as a statvfs/fstatvfs function parameter */
typedef struct statvfs {
	unsigned long f_bsize;  // File system block size
	unsigned long f_frsize;  // Fundamental file system block size
	fsblkcnt_t f_blocks;  // Blocks on FS in units of f_frsize
	fsblkcnt_t f_bfree;  // Free blocks
	fsblkcnt_t f_bavail;  // Blocks available to non-root
	fsfilcnt_t f_files;  // Total inodes
	fsfilcnt_t f_ffree;  // Free inodes
	fsfilcnt_t f_favail;  // Free inodes for non-root
	unsigned long f_fsid;  // Filesystem ID
	unsigned long f_flag;  // Bit mask of values
	unsigned long f_namemax;  // Max file name length
} statvfs_t;


// Defined bits for f_flag field value
/** Read-only file system */
#define ST_RDONLY   (1)
/** Does not honor setuid/setgid */
#define ST_NOSUID   (2)


/* TODO: Add statvfs functions
int fstatvfs(int, struct statvfs*);
int statvfs(const char* restrict, struct statvfs* restrict);
*/


#endif  // SYS_STATVFS_H


/* DIRECTORY OPERATIONS (<sys/dir.h> & <dirent.h>) */


#if (!(defined(_DIRENT_H) || defined(_DIRENT_H_) || defined(_SYS_DIR_H) || defined(_SYS_DIR_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/dirent.h.html
#define _DIRENT_H   (1)
#define _DIRENT_H_   (1)
#define _SYS_DIR_H   (1)
#define _SYS_DIR_H_   (1)


#define _DIRENT_HAVE_D_RECLEN
#define _DIRENT_HAVE_D_OFF
#define _DIRENT_HAVE_D_TYPE

typedef struct attr_packed dirent {
#ifndef __USE_FILE_OFFSET64
	ino_t d_ino;
	off_t d_off;
#else
	ino64_t d_ino;
	off64_t d_off;
#endif
	unsigned short d_reclen;
	unsigned char d_type;
	char d_name[256];
} dirent_t;

#ifdef __USE_LARGEFILE64
typedef struct dirent64 {
	ino64_t d_ino;
	off64_t d_off;
	unsigned short d_reclen;
	unsigned char d_type;
	char d_name[256];
} dirent64_t;
#endif
/** Backwards compatibility */
#define d_fileno   d_ino

#ifdef _DIRENT_HAVE_D_NAMLEN
/** Returns the length of DP->d_name, not including its terminating null character */
#   define _D_EXACT_NAMLEN(d)   ((d)->d_namlen)
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#   define _D_ALLOC_NAMLEN(d)   (_D_EXACT_NAMLEN(d) + 1)
#else
/** Returns the length of DP->d_name, not including its terminating null character */
#   define _D_EXACT_NAMLEN(d)   (strlen((d)->d_name))
#   ifdef _DIRENT_HAVE_D_RECLEN
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#      define _D_ALLOC_NAMLEN(d)   (((char*)(d) + (d)->d_reclen) - &(d)->d_name[0])
#   else
/** Returns a size at least (_D_EXACT_NAMLEN (DP) + 1) */
#      define _D_ALLOC_NAMLEN(d)   (sizeof(d)->d_name > 1 ? sizeof(d)->d_name : (_D_EXACT_NAMLEN(d) + 1))
#   endif
#endif
#define _GENERIC_DIRSIZ(dp)   (((unsigned long)&((struct dirent*)0)->d_name + (dp)->d_namlen + 4) & (~3))


// FILE TYPES FOR `d_type`
#define DT_UNKNOWN   0
#define DT_FIFO   1
#define DT_CHR   2
#define DT_DIR   4
#define DT_BLK   6
#define DT_REG   8
#define DT_LNK   10
#define DT_SOCK   12
#define DT_WHT   14
/** Convert between stat structure types and directory types */
#define IFTODT(mode)   (((mode) & 0170000) >> 12)
#define DTTOIF(dirtype)   ((dirtype) << 12)


LIB_FUNC int alphasort(const struct dirent** restrict a, const struct dirent** restrict b) {
	return strcmp((*a)->d_name, (*b)->d_name);
}


// TODO: Add scandir()


#endif  // DIRENT_H


/* TIMER FILE DESCRIPTOR (<sys/timerfd.h>) */


#if (!(defined(_SYS_TIMERFD_H) || defined(_SYS_TIMERFD_H_)))
#define _SYS_TIMERFD_H   (1)
#define _SYS_TIMERFD_H_   (1)


#ifdef ALPHA  // Bits to be set in the FLAGS parameter of `timerfd_create`
#   define TFD_CLOEXEC   010000000
#   define TFD_NONBLOCK   04
#elif defined(MIPS)
#   define TFD_CLOEXEC   02000000
#   define TFD_NONBLOCK   0200
#elif defined(SPARC)
#   define TFD_CLOEXEC   0x400000
#   define TFD_NONBLOCK   0x4000
#else
#   define TFD_CLOEXEC   02000000
#   define TFD_NONBLOCK   04000
#endif  // Bits to be set in the FLAGS parameter of `timerfd_create`
/** Bits to be set in the FLAGS parameter of `timerfd_settime` */
#define TFD_TIMER_ABSTIME   1


/** Return file descriptor for new interval timer source */
LIB_FUNC int timerfd_create(int clockid, int flags) {
	return (int)syscall(SYS_timerfd_create, clockid, flags);
}


/** Set next expiration time of interval timer source UFD to UTMR; If FLAGS has the TFD_TIMER_ABSTIME flag set the timeout value is absolute; Optionally return the old expiration time in OTMR */
LIB_FUNC int timerfd_settime(int fd, int flags, const struct itimerspec* new, struct itimerspec* old) {
	return (int)syscall(SYS_timerfd_settime, fd, flags, new, old);
}


/** Return the next expiration time of UFD */
LIB_FUNC int timerfd_gettime(int fd, struct itimerspec* cur) {
	return (int)syscall(SYS_timerfd_gettime, fd, cur);
}


#endif  // SYS_TIMERFD_H


/* EVENT FILE DESCRIPTOR (<sys/eventfd.h>) */


#if (!(defined(SYS_EVENTFD_H) || defined(_SYS_EVENTFD_H) || defined(_SYS_EVENTFD_H_)))
#define SYS_EVENTFD_H   (1)
#define _SYS_EVENTFD_H   (1)
#define _SYS_EVENTFD_H_   (1)


#define EFD_SEMAPHORE   1
#define EFD_CLOEXEC   O_CLOEXEC
#define EFD_NONBLOCK   O_NONBLOCK


/** Type for event counter */
typedef uint64_t   eventfd_t;


/** Return file descriptor for generic event channel; Set initial value to COUNT */
LIB_FUNC int eventfd(const unsigned int count, const int flags) {
	int r = (int)__syscall(SYS_eventfd2, count, flags);
#   ifdef SYS_eventfd
	if (r == -ENOSYS && !flags) { r = (int)__syscall(SYS_eventfd, count); }
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


/** Read event counter and possibly wait for events */
LIB_FUNC int eventfd_read(const int fd, eventfd_t* value) {
	return ((sizeof(*value) == read(fd, value, sizeof(*value))) ? 0 : -1);
}


/** Increment event counter */
LIB_FUNC int eventfd_write(const int fd, eventfd_t value) {
	return ((sizeof(value) == write(fd, &value, sizeof(value))) ? 0 : -1);
}


#endif  // SYS_EVENTFD_H


/* MOUNT FILESYSTEMS (<mount.h>) */


#if (!(defined(_SYS_MOUNT_H) || defined(_SYS_MOUNT_H_)))
#define _SYS_MOUNT_H   (1)
#define _SYS_MOUNT_H_   (1)


#define BLKROSET   _IO(0x12, 93)
#define BLKROGET   _IO(0x12, 94)
#define BLKRRPART   _IO(0x12, 95)
#define BLKGETSIZE   _IO(0x12, 96)
#define BLKFLSBUF   _IO(0x12, 97)
#define BLKRASET   _IO(0x12, 98)
#define BLKRAGET   _IO(0x12, 99)
#define BLKFRASET   _IO(0x12, 100)
#define BLKFRAGET   _IO(0x12, 101)
#define BLKSECTSET   _IO(0x12, 102)
#define BLKSECTGET   _IO(0x12, 103)
#define BLKSSZGET   _IO(0x12, 104)
#define BLKBSZGET   _IOR(0x12, 112, size_t)
#define BLKBSZSET   _IOW(0x12, 113, size_t)
#define BLKGETSIZE64   _IOR(0x12, 114, size_t)
#define MS_RDONLY   1
#define MS_NOSUID   2
#define MS_NODEV   4
#define MS_NOEXEC   8
#define MS_SYNCHRONOUS   16
#define MS_REMOUNT   32
#define MS_MANDLOCK   64
#define MS_DIRSYNC   128
#define MS_NOATIME   1024
#define MS_NODIRATIME   2048
#define MS_BIND   4096
#define MS_MOVE   8192
#define MS_REC   16384
#define MS_SILENT   32768
#define MS_POSIXACL   0x10000
#define MS_UNBINDABLE   0x20000
#define MS_PRIVATE   0x40000
#define MS_SLAVE   0x80000
#define MS_SHARED   0x100000
#define MS_RELATIME   0x200000
#define MS_KERNMOUNT   0x400000
#define MS_I_VERSION   0x800000
#define MS_STRICTATIME   0x1000000
#define MS_LAZYTIME   0x2000000
#define MS_NOSEC   0x10000000
#define MS_BORN   0x20000000
#define MS_ACTIVE   0x40000000
#define MS_NOUSER   0x80000000
#define MS_RMT_MASK   (MS_RDONLY | MS_SYNCHRONOUS | MS_MANDLOCK | MS_I_VERSION | MS_LAZYTIME)
#define MS_MGC_VAL   0xc0ed0000
#define MS_MGC_MSK   0xffff0000
#define MNT_FORCE   1
#define MNT_DETACH   2
#define MNT_EXPIRE   4
#define UMOUNT_NOFOLLOW   8


LIB_FUNC int mount(const char* special, const char* dir, const char* fstype, const unsigned long flags, const void* data) {
	return (int)syscall(SYS_mount, special, dir, fstype, flags, data);
}


LIB_FUNC int umount(const char* special) {
	return (int)syscall(SYS_umount2, special, 0);
}


LIB_FUNC int umount2(const char* special, const int flags) {
	return (int)syscall(SYS_umount2, special, flags);
}


#endif  // SYS_MOUNT_H


/* MEMORY ALLOCATION SIZE CHECKING (<xalloc-oversized.h>) */


#if (!(defined(XALLOC_OVERSIZED_H) || defined(XALLOC_OVERSIZED_H_) || defined(_XALLOC_OVERSIZED_H_)))
#define XALLOC_OVERSIZED_H   (1)
#define XALLOC_OVERSIZED_H_   (1)
#define _XALLOC_OVERSIZED_H_   (1)


#if ((defined(HAVE_CALLOC_GNU) || IS_GLIBC) && (!defined(HAVE_GNU_CALLOC)))
#   define HAVE_GNU_CALLOC   (1)
#else
#   define HAVE_GNU_CALLOC   (0)
#endif
/** Return 1 if an array of N objects, each of size S, cannot exist due to size arithmetic overflow; S must be positive and N must be nonnegative */
#define xalloc_oversized(n, s)   ((size_t)(((SIZEOF_PTRDIFF_T <= SIZEOF_SIZE_T) ? -1 : -2)) / (s) < (n))


#endif  // XALLOC_OVERSIZED_H


/* MEMORY MANAGEMENT (<sys/mman.h>) */


#if (!(defined(_SYS_MMAN_H) || defined(_SYS_MMAN_H_) || defined(_MALLOC_H) || defined(_MALLOC_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_mman.h.html
#define SYS_MMAN_H   (1)
#define _SYS_MMAN_H   (1)
#define _SYS_MMAN_H_   (1)
#define MALLOC_H   (1)
#define _MALLOC_H   (1)
#define _MALLOC_H_   (1)
#define _MM_MALLOC_H_INCLUDED   (1)
#define _LIBC_SYS_MMAN_H_   (1)
#define _PAGEALIGN_ALLOC_H   (1)
#define _PAGEALIGN_ALLOC_H_   (1)


#define MREMAP_MAYMOVE   (1)
#define MREMAP_FIXED   (2)
#define MLOCK_ONFAULT   (1)
#define MMAP_OFF_MASK   (((long long)(-0x2000ULL) << (BITS_PER_LONG - 1)) | (SYSCALL_MMAP2_UNIT - 1))
#define __MALLOC_P(args)   args __THROW
/** This macro will be used for functions which might use C++ callback functions */
#define __MALLOC_PMT(args)   args
/** Return the number of bytes that need to be added to X to make it aligned to an ALIGN boundary; ALIGN must be a power of 2 */
#define M_ALIGN(x, align)   (-(size_t)(x) & ((align) - 1))
/** Return the number of bytes that need to be subtracted from X to make it aligned to an ALIGN boundary; ALIGN must be a power of 2 */
#define M_ALIGN_SUB(x, align)   ((size_t)(x) & ((align) - 1))
/** real_size is the size we actually have to allocate, allowing for overhead and alignment */
#define REAL_SIZE(sz)   ((sz) < sizeof(struct freelist_entry) - SIZEOF_SIZE_T ? sizeof(struct freelist_entry) : ((sz) + SIZEOF_SIZE_T + M_ALIGN((sz), SIZEOF_SIZE_T)))
#ifdef XSTORMY  // MALLOC_LIMIT
register void* stack_pointer asm ("r15;");
#   define MALLOC_LIMIT    stack_pointer
#else
#   define MALLOC_LIMIT   __builtin_frame_address(0)
#endif  // MALLOC_LIMIT
#ifndef MALLOC_ALIGNMENT
/** MALLOC_ALIGNMENT is the minimum alignment for malloced chunks; It must be a power of two at least 2*(sizeof(size_t)) */
#   define MALLOC_ALIGNMENT   (2 * SIZEOF_SIZE_T)
#endif
/** The corresponding bit mask value */
#define MALLOC_ALIGN_MASK   (MALLOC_ALIGNMENT - 1)
#ifndef DEFAULT_TRIM_THRESHOLD
/** Maximum amount of unused top-most memory to keep before releasing via malloc_trim in free() */
#   define DEFAULT_TRIM_THRESHOLD   (131072)
#endif
#ifndef DEFAULT_TOP_PAD
/** Amount of extra `padding` space to allocate or retain whenever sbrk is called */
#   define DEFAULT_TOP_PAD   (0)
#endif
#ifndef DEFAULT_MMAP_THRESHOLD
/** Request size threshold for using mmap() to service a request; Requests of at least this size that cannot be allocated using already-existing space will be serviced via mmap */
#   define DEFAULT_MMAP_THRESHOLD   (131072)
#endif
#ifndef DEFAULT_MMAP_MAX
#   ifdef HAVE_MMAP
/** Maximum number of requests to simultaneously service using mmap */
#      define DEFAULT_MMAP_MAX   (1024)
#   else
/** Maximum number of requests to simultaneously service using mmap */
#      define DEFAULT_MMAP_MAX   (0)
#   endif
#endif
/** Conversion from malloc headers to user pointers, and back */
#define chunk2mem(p)   ((void*)((char*)(p) + (2 * SIZEOF_SIZE_T)))
#define mem2chunk(mem)   ((mchunkptr)((char*)(mem) - (2 * SIZEOF_SIZE_T)))
/** The smallest possible chunk */
#define MIN_CHUNK_SIZE   (sizeof(struct malloc_chunk))
/** The smallest size we can malloc is an aligned minimal chunk */
#define MINSIZE   ((unsigned long)((unsigned long)(MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) & (unsigned long)(~MALLOC_ALIGN_MASK)))
/** Check if m has acceptable alignment */
#define aligned_OK(m)   (((unsigned long)((m)) & (MALLOC_ALIGN_MASK)) == 0)
/** Check if a request is so large that it would wrap around zero when padded and aligned; The bound is made low enough so that adding MINSIZE will also not wrap around zero */
#define REQUEST_OUT_OF_RANGE(req)   ((unsigned long)(req) >= (unsigned long)((-2) * MINSIZE))
/** Pad request bytes into a usable size -- internal version */
#define request2size(req)   ((((req) + SIZEOF_SIZE_T + MALLOC_ALIGN_MASK) < MINSIZE) ? MINSIZE : (((req) + SIZEOF_SIZE_T + MALLOC_ALIGN_MASK) & (~MALLOC_ALIGN_MASK)))
#define checked_request2size(req, sz)   if (REQUEST_OUT_OF_RANGE(req)) { __set_errno(ENOMEM); return 0x0; } (sz) = request2size(req);
/** Size field is ORed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE   1
/** Extract inuse bit of previous chunk */
#define prev_inuse(p)   ((p)->size & PREV_INUSE)
/** size field is ORed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED   2
/** Check for mmapped chunk */
#define chunk_is_mmapped(p)   ((p)->size & IS_MMAPPED)
/** Bits to mask off when extracting size */
#define SIZE_BITS   (PREV_INUSE | IS_MMAPPED)
/** Get size, ignoring use bits */
#define chunksize(p)   ((p)->size & (~(SIZE_BITS)))
/** Ptr to next physical malloc_chunk */
#define next_chunk(p)   ((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))
/** Ptr to previous physical malloc_chunk */
#define prev_chunk(p)   ((mchunkptr)(((char*)(p)) - ((p)->prev_size)))
/** Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)   ((mchunkptr)(((char*)(p)) + (s)))
/** Extract p's inuse bit */
#define inuse(p)   ((((mchunkptr)(((char*)(p))+((p)->size & (~PREV_INUSE))))->size) & PREV_INUSE)
/** Set chunk as being inuse without otherwise disturbing */
#define set_inuse(p)   (((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))->size |= PREV_INUSE)
/** Clear chunk as being inuse without otherwise disturbing */
#define clear_inuse(p)   (((mchunkptr)(((char*)(p)) + ((p)->size & (~PREV_INUSE))))->size &= (~(PREV_INUSE)))
/** Check inuse bits in known places */
#define inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)
/** Set inuse bits in known places */
#define set_inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)
/** Clear inuse bits in known places */
#define clear_inuse_bit_at_offset(p, s)   (((mchunkptr)(((char*)(p)) + (s)))->size &= (~(PREV_INUSE)))
/** Set size at head, without disturbing its use bit */
#define set_head_size(p, s)   ((p)->size = (((p)->size & PREV_INUSE) | (s)))
/** Set size/use field */
#define set_head(p, s)   ((p)->size = (s))
/** Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)   (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))
#define SQRT_SIZE_MAX   ((size_t)1 << ((SIZEOF_SIZE_T * CHAR_BIT) >> 1))
#define MUL_NO_OVERFLOW   ((size_t)1 << (SIZEOF_SIZE_T * 4))
#define BLOCK_START(b)   ((void*)((uintptr_t)((void*)(b)) - (uintptr_t)SIZEOF_ALLOC_T))
#define BLOCK_RET(b)   ((void*)((uintptr_t)((void*)(b)) + (uintptr_t)SIZEOF_ALLOC_T))


// FREE FUNCTIONS


LIB_FUNC void _alloc_libc_free(void* ptr) {
	if (ptr) { munmap(BLOCK_START(ptr), ((size_t)((alloc_t*)BLOCK_START(ptr))->size)); }
}


LIB_FUNC void free(void* ptr) {
	if (PREDICT_UNLIKELY(ptr == NULL)) { return; }
	ptr = (void*)((uintptr_t)ptr - (uintptr_t)SIZEOF_SIZE_T);
	munmap(ptr, (*(size_t*)ptr + SIZEOF_SIZE_T));
}
#define __libc_free(ptr)   free((ptr))
#define _libc_free(ptr)   free((ptr))
#define libc_free(ptr)   free((ptr))
#define rk_xfree(addr)   free((addr))
#define mm_free(ptr)   free(((void*)(ptr)))
#define _mm_free(ptr)   free(((void*)(ptr)))
#define mem_free(ptr, bsize)   free(((void*)(ptr)))
#define free_r(ptr, addr)   free((addr))
#define _free_r(ptr, addr)   free((addr))
#define ckfree(addr)   free((void*)(addr))
#define xfree(x)   do { if ((x) != NULL) { free((void*)(x)); (x) = NULL; } } while (0x0)
#define FREEPTR(x)   xfree((x))
#define FREE_AND_CLEAR(x)   xfree((x))
#define MEMSET_FREE_AND_CLEAR(x)   do { if ((x)) { memset((x), 0, strlen(x)); free((x)); (x) = NULL; } } while (0x0)


/** Clear memory block */
LIB_FUNC void _cfree(void* p, UNUSED size_t num, UNUSED size_t size) {
	free(p);
}
#define cfree(ptr)   free(((void*)(ptr)))
#define cfree_r(ptr, mem)   cfree((mem))
#define _cfree_r(ptr, mem)   cfree((mem))


LIB_FUNC void cpuset_free(cpu_set_t* set) {
	free(set);
}
#define __cpuset_free(set)   cpuset_free((set))


LIB_FUNC void freelocale(locale_t _locale) {
	_DIAGASSERT(_locale != LC_GLOBAL_LOCALE);
	_DIAGASSERT(_locale != LC_C_LOCALE);
	_DIAGASSERT(_locale != (locale_t)NULL);
	free(_locale);
}
#define _freelocale(l)   freelocale((l))


LIB_FUNC int munmap(void* start, const size_t len) {
	__vm_wait();
	return (int)syscall(SYS_munmap, (long)&start, len);
}
#define __munmap(start, len)   munmap((start), (len))
#define free_mem(start, len)   munmap((start), (len))


LIB_FUNC int munmap_const(const void* start, const size_t len) {
	__vm_wait();
	return (int)syscall(SYS_munmap, (long)&start, len);
}


// MEMORY ALLOCATION FUNCTIONS


LIB_FUNC uintptr_t __brk(const uintptr_t newbrk) {
	return (uintptr_t)__syscall(SYS_brk, (long)newbrk);
}
#define brk(newbrk)   __brk((newbrk))
#define _brk(newbrk)   __brk((newbrk))


/** This function returns true if the interval [old, new] intersects the 'len'-sized interval below &libc.auxv (interpreted as the main-thread stack) or below &b (the current stack); It is used to defend against buggy brk implementations that can cross the stack */
LIB_FUNC  int traverses_stack_p(const uintptr_t old, const uintptr_t new) {
	uintptr_t b = (uintptr_t)libc.auxv;
	register uintptr_t a = (b > (uintptr_t)0x800000 ? (b - (uintptr_t)0x800000) : 0);
	if ((new > a) && old < b) { return 1; }
	else {
		b = (uintptr_t)&b;
		a = (b > (uintptr_t)0x800000 ? (b - (uintptr_t)0x800000) : 0);
		if (new > a && old < b) { return 1; }
		return 0;
	}
	UNREACHABLE
}


#ifdef OSOPENBSD
/** Provides 64-bit offset padding */
LIB_FUNC void* mquery(void* addr, size_t len, int prot, int flags, int fd, off_t offset) {
	 return (void*)(__syscall(SYS_mquery, addr, len, prot, flags, fd, 0, offset));
}
#   define MQUERY(a, sz)   mquery((a), (size_t)(sz), (PROT_READ | PROT_WRITE), (MAP_ANON | MAP_PRIVATE | MAP_FIXED), -1, (off_t)0)
#endif


LIB_FUNC void* mmap(void* start, size_t len, int prot, int flags, int fd, off_t off) {
	if (off & (off_t)(((-0x2000UL) << (BITS_PER_LONG - 1)) | (SYSCALL_MMAP2_UNIT - 1))) {
		errno = EINVAL;
		return MAP_FAILED;
	} else if (PREDICT_UNLIKELY(len >= PTRDIFF_MAX)) {
		errno = ENOMEM;
		return MAP_FAILED;
	} else if (PREDICT_UNLIKELY(flags & MAP_FIXED)) { __vm_wait(); }
#   ifdef SYS_mmap2
	long mmap_ptr = (long)syscall(SYS_mmap2, start, len, prot, flags, fd, (off_t)(off / SYSCALL_MMAP2_UNIT));
#   else
	long mmap_ptr = (long)syscall(SYS_mmap, start, len, prot, flags, fd, off);
#   endif
	return (void*)mmap_ptr;
}
#define mmap64(start, len, prot, flags, fd, off)   mmap((start), (len), (prot), (flags), (fd), (off))
#define __mmap(start, len, prot, flags, fd, off)   mmap((start), (len), (prot), (flags), (fd), (off))
#define MMAPA(a, sz)   mmap((a), (size_t)(sz), (PROT_READ | PROT_WRITE), (MAP_ANON | MAP_PRIVATE), -1, (off_t)0)
#define HAVE_MMAP   (1)


/** Expand the heap in-place if brk can be used, or otherwise via mmap, using an exponential lower bound on growth by mmap to make fragmentation asymptotically irrelevant */
LIB_FUNC void* expand_heap(size_t* pn) {
	static uintptr_t brk;
	static unsigned mmap_step;
	size_t n = *pn;
	if (n > ((SIZE_MAX >> 1) - PAGE_SIZE)) {
		errno = ENOMEM;
		return 0;
	}
	n += (-n & (PAGE_SIZE - 1));
	if (!brk) {
		brk = (uintptr_t)__syscall(SYS_brk, 0);
		brk += ((-brk) & (PAGE_SIZE - 1));
	}
	if (n < (SIZE_MAX - brk) && (!traverses_stack_p(brk, (brk + n))) && __syscall(SYS_brk, (long)(brk + n)) == (brk + n)) {
		*pn = n;
		brk += (uintptr_t)n;
		return (void*)(brk - n);
	}
	const size_t min = (size_t)(PAGE_SIZE << (mmap_step >> 1));
	if (n < min) { n = min; }
	void* area = mmap(0, n, (PROT_READ | PROT_WRITE), (MAP_PRIVATE | MAP_ANONYMOUS), -1, 0);
	if (area == MAP_FAILED) { return 0; }
	*pn = n;
	++mmap_step;
	return area;
}
#define __expand_heap(pn)   expand_heap((pn))


LIB_FUNC int mprotect(void* addr, const size_t len, const int prot) {
	size_t start = (size_t)addr & (size_t)(-PAGE_SIZE);
	const size_t end = (size_t)((char*)addr + len + PAGE_SIZE - 1) & (size_t)(-PAGE_SIZE);
	return (int)syscall(SYS_mprotect, start, (end - start), prot);
}
#define __mprotect(addr, len, prot)   mprotect((addr), (len), (prot))


LIB_FUNC int msync(void* start, size_t len, int flags) {
	return (int)syscall(SYS_msync, (long)&start, (long)len, flags);
}


LIB_FUNC int posix_madvise(void* addr, const size_t len, const int advice) {
	if (advice == MADV_DONTNEED) { return 0; }
	return (int)(-(__syscall(SYS_madvise, (long)&addr, (long)len, advice)));
}
#define HAVE_POSIX_MADVISE   (1)


LIB_FUNC int mlock(const void* addr, const size_t len) {
	return (int)syscall(SYS_mlock, addr, len);
}


LIB_FUNC int munlock(const void* addr, const size_t len) {
	return (int)syscall(SYS_munlock, addr, len);
}


LIB_FUNC int mlockall(const int flags) {
	return (int)syscall(SYS_mlockall, flags);
}


LIB_FUNC int munlockall(void) {
	return (int)syscall(SYS_munlockall);
}


LIB_FUNC void* mremap(void* old_addr, size_t old_len, size_t new_len, int flags, ...) {
	va_list ap;
	void* new_addr = 0;
	if (new_len >= PTRDIFF_MAX) {
		errno = ENOMEM;
		return MAP_FAILED;
	} else if (flags & MREMAP_FIXED) {
		__vm_wait();
		va_start(ap, flags);
		new_addr = va_arg(ap, void*);
		va_end(ap);
	}
	return (void*)((uintptr_t)syscall(SYS_mremap, (long)&old_addr, (long)old_len, (long)new_len, flags, (long)&new_addr));
}
#define __mremap(old_addr, old_len, new_len, flags, ...)   mremap((old_addr), (old_len), (new_len), (flags), (__VA_ARGS__))


LIB_FUNC int remap_file_pages(void* addr, const size_t size, int prot, size_t pgoff, int flags) {
	return (int)syscall(SYS_remap_file_pages, addr, size, prot, pgoff, flags);
}


LIB_FUNC int madvise(void* addr, const size_t len, const int advice) {
	return (int)syscall(SYS_madvise, addr, len, advice);
}
#define __madvise(addr, len, advice)   madvise((addr), (len), (advice))


LIB_FUNC int mincore(void* addr, size_t len, unsigned char* vec) {
	return (int)syscall(SYS_mincore, addr, len, vec);
}


LIB_FUNC size_t malloc_usable_size(void* p) {
	return (p ? ((((struct chunk*)((char*)(p) - (2 * SIZEOF_SIZE_T)))->csize & (size_t)(-2)) - (2 * SIZEOF_SIZE_T)) : 0);
}


LIB_FUNC char* shm_mapname(const char* name, char* buf) {
	const char* p;
	while (*name == '/') { name++; }
	if (*(p = strchrnul(name, '/')) || p == name || (p - name <= 2 && name[0] == '.' && p[-1] == '.')) {
		errno = EINVAL;
		return 0;
	} else if ((p - name) > NAME_MAX) {
		errno = ENAMETOOLONG;
		return 0;
	}
	memcpy_no_output(buf, "/dev/shm/", 9);
	memcpy_no_output((buf + 9), name, (size_t)(p - name + 1));
	return buf;
}
#define __shm_mapname(name, buf)   shm_mapname((name), (buf))


LIB_FUNC int shm_open(const char* name, int flag, mode_t mode) {
	char buf[NAME_MAX + 10];
	if (!(name = shm_mapname(name, buf))) { return -1; }
	int cs;
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	register int fd = open(name, (flag | O_NOFOLLOW | O_CLOEXEC | O_NONBLOCK), mode);
	pthread_setcancelstate(cs, 0);
	return fd;
}


LIB_FUNC int shm_unlink(const char* name) {
	char buf[NAME_MAX + 10];
	if (!(name = shm_mapname(name, buf))) { return -1; }
	return unlink(name);
}


LIB_FUNC void* memalign(const size_t align, const size_t sz) {
	unsigned char* mem;
	if ((align & -align) != align) {
		errno = EINVAL;
		return NULL;
	} else if (sz > (SIZE_MAX - align)) {
		errno = ENOMEM;
		return NULL;
	} else if (align <= (4 * SIZEOF_SIZE_T)) {
		if (!(mem = malloc(sz))) { return NULL; }
		return mem;
	} else if (!(mem = malloc(sz + align - 1))) { return NULL; }
	unsigned char* new;
	new = (void*)(((size_t)mem + align - 1) & (size_t)(-align));
	if (new == mem) { return mem; }
	register const size_t header = ((size_t*)mem)[-1];
	if (!(header & 7)) {
		((size_t*)new)[-2] = ((size_t*)mem)[-2] + (unsigned long)(new - mem);
		((size_t*)new)[-1] = ((size_t*)mem)[-1] - (unsigned long)(new - mem);
		return new;
	}
	unsigned char* end;
	end = mem + (header & (size_t)(-8));
	register const size_t footer = ((size_t*)end)[-2];
	((size_t*)mem)[-1] = ((header & 7) | (unsigned long)(new - mem));
	((size_t*)new)[-2] = ((footer & 7) | (unsigned long)(new - mem));
	((size_t*)new)[-1] = ((header & 7) | (unsigned long)(end - new));
	((size_t*)end)[-2] = ((footer & 7) | (unsigned long)(end - new));
	free(mem);
	mem = NULL;
	return new;
}
#define __memalign(align, sz)   memalign((align), (sz))
#define _memalign(align, sz)   memalign((align), (sz))
#define HAVE_MEMALIGN   (1)


LIB_FUNC int posix_memalign(void** res, const size_t align, const size_t len) {
	if (align < SIZEOF_VOID_P) { return EINVAL; }
	void* mem = (void*)memalign(align, len);
	if (PREDICT_UNLIKELY(!mem)) { return EAGAIN; }
	*res = mem;
	return 0;
}
#define HAVE_POSIX_MEMALIGN   (1)


LIB_FUNC void* aligned_alloc(const size_t align, const size_t data_size) {
	return memalign(align, data_size);
}


LIB_FUNC void* pvalloc(const size_t data_size) {
	return memalign(128, (data_size - ((size_t)(data_size) & 127)));
}
#define _palloc(data_size)   palloc((data_size))
#define HAVE_PVALLOC   (1)


LIB_FUNC void* valloc(const size_t data_size) {
	return (void*)memalign(128, data_size);
}
#define _valloc(data_size)   valloc((data_size))
#define HAVE_VALLOC   (1)


LIB_FUNC void* zalloc(const size_t size) {
	void* ptr;
	ptr = malloc(size);
	if (ptr) { memset_no_output(ptr, 0, size); }
	return ptr;
}


LIB_FUNC  void* malloc(const size_t len) {
	register size_t n = len;
	static char *cur, *end;
	static volatile int lock[2];
	register size_t align = 1;
	if (!n) { ++n; }
	while (align < n && align < 16) { align += align; }
	LOCK(lock);
	size_t pad = -(uintptr_t)cur & (align - 1);
	if (n <= ((SIZE_MAX >> 1) + align)) { n += pad; }
	if (n > (size_t)(end - cur)) {
		size_t m = n;
		char* new = __expand_heap(&m);
		if (!new) {
			UNLOCK(lock);
			return 0;
		} else if (new != end) {
			cur = new;
			n -= pad;
			pad = 0;
		}
		end = new + m;
	}
	void* p;
	p = cur + pad;
	cur += n;
	UNLOCK(lock);
	return p;
}
#define __simple_malloc(n)   malloc((n))
#define __malloc0(n)   malloc((n))
#define malloc0(n)   malloc((n))
#define __malloc(n)   malloc((n))


/** Like malloc, but returns an error when out of space */
LIB_FUNC void* ckmalloc(const size_t nbytes) {
	void* p = malloc(nbytes);
	if (p == NULL) { exit_on_error("Out of space"); }
	return p;
}


struct stack_block {
	struct stack_block* prev;
	char space[MINSIZE];
};


struct attr_packed stackmark {
	struct stack_block* stackp;
	char* stacknxt;
	int stacknleft;
	struct stackmark* marknext;
};


UNUSED struct stack_block stackbase;
UNUSED struct stack_block* stackp = &stackbase;
UNUSED struct stackmark* markp;
UNUSED char* stacknxt = stackbase.space;
UNUSED int stacknleft = (int)MINSIZE;
UNUSED int sstrnleft;
UNUSED int herefd = -1;
#define stackblock()   stacknxt
#define stackblocksize()   stacknleft
/** Most machines require the value returned from malloc to be aligned in some way; The following macro will get this right on many machines */
#define SHELL_SIZE   (SIZEOF_DOUBLE - 1)
#define SHELL_ALIGN(nbytes)   (((nbytes) + SHELL_SIZE) & (~SHELL_SIZE))


LIB_FUNC void* stalloc(int nbytes) {
	char* p;
	nbytes = SHELL_ALIGN(nbytes);
	if (nbytes > stacknleft) {
		int blocksize;
		struct stack_block* sp;
		blocksize = nbytes;
		if (blocksize < (int)MINSIZE) { blocksize = (int)MINSIZE; }
		sp = ckmalloc((size_t)(sizeof(struct stack_block) - (unsigned long)MINSIZE + (unsigned long)blocksize));
		sp->prev = stackp;
		stacknxt = sp->space;
		stacknleft = blocksize;
		stackp = sp;
	}
	p = stacknxt;
	stacknxt += nbytes;
	stacknleft -= nbytes;
	return p;
}
#define grabstackstr(p)   stalloc(stackblocksize() - sstrnleft)


LIB_FUNC void stunalloc(void* p) {
	if (p == NULL) { abort(); }
	stacknleft += ((int)(stacknxt - (char*)p));
	stacknxt = p;
}


LIB_FUNC void setstackmark(struct stackmark* mark) {
	mark->stackp = stackp;
	mark->stacknxt = stacknxt;
	mark->stacknleft = stacknleft;
	mark->marknext = markp;
	markp = mark;
}


LIB_FUNC void popstackmark(struct stackmark* mark) {
	struct stack_block* sp;
	markp = mark->marknext;
	while (stackp != mark->stackp) {
		sp = stackp;
		stackp = sp->prev;
		ckfree(sp);
	}
	stacknxt = mark->stacknxt;
	stacknleft = mark->stacknleft;
}


/** Make a copy of a string in safe storage */
LIB_FUNC char* savestr(const char *s) {
	char* p = ckmalloc((strlen(s) + 1));
	scopy_no_output(s, p);
	return p;
}


LIB_FUNC char* strdup(const char* s) {
	register const size_t l = strlen(s);
	char* d = malloc((size_t)(l + 1));
	if (!d) { return NULL; }
	return (char*)memcpy((void*)d, (const void*)s, (size_t)(l + 1));
}
#define __strdup(s)   strdup((s))


/** Return a malloc copy of at most the specified number of bytes of a string */
LIB_FUNC char* strndup(const char* s, const size_t n) {
	register const size_t len = strnlen(s, n);
	char* new = (char*)malloc(len + 1);
	if (new == NULL) { return NULL; }
	new[len] = '\0';
	return (char*)memcpy(new, s, len);
}
#define __strndup(s, l)   strndup((s), (l))


LIB_FUNC char* sstrdup(const char* p) {
	register const size_t len = strlen(p) + 1;
	return memcpy(stalloc((int)len), p, len);
}
#define __sstrdup(ptr)   sstrdup((ptr))


LIB_FUNC void* calloc(const size_t num_members, const size_t elem_size) {
	register const size_t sz = (num_members * elem_size);
	void* result;
	result = malloc(sz);
	if (PREDICT_LIKELY(result != NULL)) { memset_no_output(result, 0, sz); }
	return result;
}
#define mem_alloc(bsize)   calloc((size_t)1, (bsize))


LIB_FUNC void* mm_malloc(const size_t data_size, register size_t alignment) {
	if (alignment == 1) { return calloc((size_t)1, data_size); }
	else if (alignment == 2 || (SIZEOF_VOID_P == 8 && alignment == 4)) { alignment = SIZEOF_VOID_P; }
	void* ptr;
	if (posix_memalign(&ptr, alignment, data_size) == 0) { return ptr; }
	else { return NULL; }
}
#define _mm_malloc(data_size, alignment)   mm_malloc((data_size), (alignment))


LIB_FUNC char* icatalloc(char* const old, const char* const new) {
	char* result;
	register int oldsize;
	const int newsize = (int)((new == NULL) ? 0 : strlen(new));
	if (old == NULL) { oldsize = 0; }
	else if (newsize == 0) { return old; }
	else { oldsize = (int)strlen(old); }
	if ((result = realloc(old, (size_t)(oldsize + newsize + 1))) != NULL) { if (new != NULL) { (void) strcpy((result + oldsize), new); } }
	return result;
}


LIB_FUNC char* icpyalloc(const char* const _string) {
	return icatalloc(NULL, _string);
}


/** Allocate an N-byte block of memory from the heap; If N is zero, allocate a 1-byte block */
LIB_FUNC void* rpl_malloc(const size_t n) {
	if (n == 0) { return (void*)malloc(1); }
	return (void*)malloc(n);
}


/** Copy a UTF-8 string */
LIB_FUNC attr_malloc attr_alloc_size((2)) uint8_t* u8_cpy_alloc(const uint8_t* s, size_t n) {
	uint8_t* dest;
	dest = (uint8_t*)malloc((size_t)(n > 0 ? n : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n);
		uint8_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


/** Copy a UTF-16 string */
LIB_FUNC attr_malloc attr_alloc_size((2)) uint16_t* u16_cpy_alloc(const uint16_t* s, size_t n) {
	uint16_t* dest;
	dest = (uint16_t*)malloc((size_t)(n > 0 ? n * 2 : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n * 2);
		uint16_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


/** Copy a UTF-32 string */
LIB_FUNC attr_malloc attr_alloc_size((2)) uint32_t* u32_cpy_alloc(const uint32_t* s, size_t n) {
	uint32_t* dest;
	dest = (uint32_t*)malloc((size_t)(n > 0 ? n * 4 : 1));
	if (dest != NULL) {  // memcpy((char*)dest, (const char*)s, n * 4);
		uint32_t* destptr = dest;
		for (; n > 0; n--) { *destptr++ = *s++; }
	}
	return dest;
}


// REALLOC

LIB_FUNC void* realloc(void* ptr, const size_t len) {
	void* newmem;
	newmem = malloc(len);
	if (newmem) { memcpy_no_output(newmem, ptr, len); }
	free(ptr);
	ptr = NULL;
	return newmem;
}
#define HAVE_REALLOC_POSIX   1
#define NEED_REALLOC_GNU   0
#define SYSTEM_MALLOC_GLIBC_COMPATIBLE   0
#undef GNULIB_REALLOC_GNU


/** Like realloc, but returns an error when out of space */
LIB_FUNC void* ckrealloc(void* p, const int nbytes) {
	p = realloc(p, (size_t)nbytes);
	if (p == NULL) { error(EXIT_FAILURE, errno, "Out of space"); }
	return p;
}


LIB_FUNC void* rk_realloc(void* ptr, const size_t size) {
	if (ptr == NULL) { return (void*)malloc(size); }
	return (void*)realloc(ptr, size);
}


/** Like realloc but never fails */
LIB_FUNC void* erealloc(void* ptr, const size_t sz) {
	void* tmp = realloc(ptr, sz);
	if (tmp == NULL && sz != 0) { errx(1, "realloc %lu failed", (unsigned long)sz); }
	return tmp;
}


LIB_FUNC void* reallocarray(void* optr, const size_t nmemb, const size_t size) {
	if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) && nmemb > 0 && (SIZE_MAX / nmemb) < size) { errno = ENOMEM; return NULL; }
	return realloc(optr, (size * nmemb));
}


LIB_FUNC void* reallocf(void* ptr, const size_t size) {
	void* nptr;
	nptr = realloc(ptr, size);
	if (!nptr && ptr && size != 0) { free(ptr); }
	return nptr;
}


LIB_FUNC int reallocarr(void* ptr, const size_t number, const size_t size) {
	void *optr, *nptr;
	int saved_errno = errno;
	memcpy_no_output(&optr, ptr, sizeof(ptr));
	if (number == 0 || size == 0) {
		free(optr);
		nptr = NULL;
		memcpy_no_output(ptr, &nptr, sizeof(ptr));
		errno = saved_errno;
		return 0;
	}
	if (PREDICT_UNLIKELY((number | size) >= SQRT_SIZE_MAX && number > (SIZE_MAX / size))) {
		errno = saved_errno;
		return EOVERFLOW;
	}
	nptr = realloc(optr, number * size);
	int result;
	if (PREDICT_UNLIKELY(nptr == NULL)) { result = errno; }
	else { result = 0; memcpy_no_output(ptr, &nptr, sizeof(ptr)); }
	errno = saved_errno;
	return result;
}


/** Change the size of an allocated block of memory P to N bytes, with error checking; If N is zero, change it to 1; If P is NULL, use malloc */
LIB_FUNC void* rpl_realloc(void* p, const size_t len) {
	void* result;
	if (p == NULL) { result = malloc(len); }
	else { result = realloc(p, len); }
	return result;
}


/* MEMORY ALLOCATION WITH EXPENSIVE EMPTY ALLOCATIONS (<eealloc.h>) */


#if (!(defined(EEALLOC_H) || defined(_EEALLOC_H) || defined(_EEALLOC_H_)))
#define EEALLOC_H   (1)
#define _EEALLOC_H   (1)
#define _EEALLOC_H_   (1)


LIB_FUNC attr_malloc attr_alloc_size(1) void* eemalloc(const size_t n) {
	if (n == 0) { return malloc(1); }  // If n is zero, allocate a 1-byte block
	return malloc(n);
}


LIB_FUNC attr_alloc_size(2) void* eerealloc(void* p, const size_t n) {
	if (n == 0) { return realloc(p, 1); }  // If n is zero, allocate or keep a 1-byte block
	return realloc(p, n);
}


LIB_FUNC attr_malloc attr_alloc_size(1) void* eenmalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	return eemalloc((size_t)(n * s));
}


/* TODO: Create eealloc variants
eezalloc (size_t n) - like eemalloc followed by memset 0
eecalloc (size_t n, size_t s) - like eemalloc (n * s) followed by memset 0
eenrealloc (void *p, size_t n, size_t s) - like eerealloc (p, n * s)
emalloc
ecalloc
estrdup
*/


#endif  // EEALLOC_H


/* SAFE AUTOMATIC MEMORY ALLOCATION (<alloca.h> & <malloca.h>) */


#if (!(defined(_ALLOCA_H) || defined(_ALLOCA_H_) || defined(_MALLOCA_H) || defined(_MALLOCA_H_)))
#define ALLOCA_H   (1)
#define _ALLOCA_H   (1)
#define _ALLOCA_H_   (1)
#define MALLOCA_H   (1)
#define _MALLOCA_H   (1)
#define _MALLOCA_H_   (1)
#define _GL_ALLOCATOR_H   (1)
#define _GL_USE_STDLIB_ALLOC   (1)


/** An object describing a memory allocator family */
typedef struct allocator {
	void* (*allocate)(size_t);
	void* (*reallocate)(void*, size_t);
	void (*free)(void*);
	void (*die)(size_t);
} allocator_t;


#define MAGIC_NUMBER   0x1415fb4a
#define MAGIC_SIZE   SIZEOF_INT
/** Make the hash table large, so that during lookups the probability of empty hash buckets is high */
#define HASH_TABLE_SIZE   257
#define __MAX_ALLOCA_CUTOFF   65536
#define MAX_ALLOCA_CUTOFF   __MAX_ALLOCA_CUTOFF
static UNUSED void* mmalloca_results[HASH_TABLE_SIZE];
/** This is how the header info would look like without any alignment considerations */
struct attr_packed preliminary_header { void* next; int magic; };
#define SIZEOF_PRELIMINARY_HEADER   (SIZEOF_INT + SIZEOF_POINTER)
/** The header's size must be a multiple of sa_alignment_max */
#define HEADER_SIZE   (((SIZEOF_PRELIMINARY_HEADER + sa_alignment_max - 1) / sa_alignment_max) * sa_alignment_max)
union header {
	void* next;
	char* deep;
	struct magic_header {
		char room[HEADER_SIZE - MAGIC_SIZE];
		int word;
	} magic;
};
UNUSED union header* last_alloca_header = NULL;


/** safe_alloca(N) is equivalent to alloca(N) when it is safe to call alloca(N); otherwise it returns NULL; It either returns N bytes of memory allocated on the stack, that lasts until the function returns, or NULL; The use of safe_alloca should be avoided inside arguments of function calls and in inline functions */
#if HAVE_ALLOCA  // safe_alloca & malloca
/** The OS usually guarantees only one guard page at the bottom of the stack, and a page size can be as small as 4096 bytes */
#   define safe_alloca(N)   ((N) < 4032 ? (alloca(N)) : NULL)
/** malloca(N) is a safe variant of alloca(N); It allocates N bytes of memory allocated on the stack, that must be freed using freea() before the function returns; Upon failure, it returns NULL */
#   define malloca(N)   ((N) < 4032 - sa_increment ? (void*)((char*)alloca((N) + sa_increment) + sa_increment) : mmalloca(N))
#else
#   define safe_alloca(N)   ((void)(N), NULL)
#   define malloca(N)   mmalloca(N)
#endif
/** nmalloca(N,S) is an overflow-safe variant of malloca(N * S); It allocates an array of N objects, each with S bytes of memory, on the stack; S must be positive and N must be nonnegative; The array must be freed using freea() before the function returns */
#define nmalloca(n, s)   ((n) > (size_t)(SIZEOF_PTRDIFF_T <= SIZEOF_SIZE_T ? -1 : -2) / (s) ? NULL : malloca((n) * (s)))


/** An allocator using the stdlib functions and a null DIE function */
static const UNUSED struct allocator stdlib_allocator = { malloc, realloc, free, NULL };


LIB_FUNC int find_stack_direction(int* addr, const int depth) {
	int _dummy = 0;
	if (!addr) { addr = &_dummy; }
	*addr = (addr < &_dummy ? 1 : ((addr == &_dummy) ? 0 : -1));
	return (int)((depth ? find_stack_direction(addr, (depth - 1)) : 0) + _dummy);
}


/** Allocate automatically reclaimed memory */
LIB_FUNC void* alloca(const size_t size) {
	auto char probe;
	register char* depth = ADDRESS_FUNCTION(probe);
#   if IS_STACK_DIRECTION_UKNOWN
	if (STACK_DIR == 0) { STACK_DIR = find_stack_direction(NULL, ((size & 1) + 20)); }
#   endif
	// Reclaim garbage
	register union header* hp = last_alloca_header;
	for (; hp != NULL;) {
		if ((STACK_DIR > 0 && hp->deep > depth) || (STACK_DIR < 0 && hp->deep < depth)) {
			register union header* np = hp->next;
			free(hp);
			hp = np;
		} else { break; }
	}
	last_alloca_header = hp;
	if (size == 0) { return NULL; }  // No allocation required
	// Allocate combined header + user data storage
	union header* new;
	const size_t combined_size = (sizeof(union header) + size);
	if (combined_size < sizeof(union header)) { memory_full(); }
	new = malloc(combined_size);
	if (!new) { memory_full(); }
	new->next = last_alloca_header;
	new->deep = depth;
	last_alloca_header = new;
	return (void*)(new + 1);
}
#define strdupa(x)   strcpy(alloca(strlen((x)) + 1), (x))


LIB_FUNC void* mmalloca(const size_t n) {
	register size_t nplus = (size_t)(n + HEADER_SIZE);
	if (nplus >= n) {
		void* p = malloc(nplus);
		if (p != NULL) {
			union header* h = p;
			p = h + 1;
			// Put a magic number into the indicator word
			h->magic.word = MAGIC_NUMBER;
			// Enter p into the hash table
			size_t slot = (size_t)((uintptr_t)p % HASH_TABLE_SIZE);
			h->next = mmalloca_results[slot];
			mmalloca_results[slot] = p;
			return p;
		}
	}
	return NULL;  // Out of memory
}


/** Free a block of memory allocated through malloca() */
LIB_FUNC void freea(void* p) {
	if ((p != NULL) && (((int*) p)[-1] == MAGIC_NUMBER)) {
		size_t slot = (size_t)((uintptr_t)p % HASH_TABLE_SIZE);
		void** chain = &mmalloca_results[slot];
		for (; *chain != NULL;) {
			union header* h = p;
			if (*chain == p) {
				union header* p_begin = h - 1;
				*chain = p_begin->next;
				free(p_begin);
				return;
			}
			h = *chain;
			chain = &h[-1].next;
		} UNREACHABLE
	} else { return; }
}


#endif  // ALLOCA_H


/* MALLOC WITH OUT-OF-MEMORY CHECKING (<xmalloc.h>, <xmalloca.h>, & <xalloc.h>) */


#if (!(defined(_XMALLOC_H) || defined(_XMALLOC_H_) || defined(XALLOC_H) || defined(XALLOC_H_)))
#define XMALLOC_H   (1)
#define _XMALLOC_H   (1)
#define _XMALLOC_H_   (1)
#define XALLOC_H   (1)
#define XALLOC_H_   (1)
#define _XALLOC_H_   (1)
#define XMALLOCA_H   (1)
#define _XMALLOCA_H   (1)
#define _XMALLOCA_H_   (1)


/** Allocate an object of type T dynamically, with error checking */
#define XMALLOC(t)   ((t*)xmalloc(sizeof(t)))
/** Allocate memory for N elements of type T, with error checking */
#define XNMALLOC(n, t)   ((t*)(sizeof(t) == 1 ? xmalloc(n) : xnmalloc(n, sizeof(t))))
/** Allocate an object of type T dynamically, with error checking, and zero it */
#define XZALLOC(t)   ((t*)xzalloc(sizeof(t)))
/** Allocate memory for N elements of type T, with error checking, and zero it */
#define XCALLOC(n, t)   ((t*)(sizeof(t) == 1 ? xzalloc(n) : xcalloc(n, sizeof(t))))
/** xmalloca(N) is a checking safe variant of alloca(N); It allocates N bytes of memory allocated on the stack, that must be freed using freea() before the function returns; Upon failure, it exits with an error message */
#define xmalloca(N)   ((N) < (4032 - sa_increment) ? (void*)((char*)alloca((N) + sa_increment) + sa_increment) : xmmalloca(N))
/** xnmalloca(N,S) is an overflow-safe variant of xmalloca(N * S); It allocates an array of N objects, each with S bytes of memory, on the stack; S must be positive and N must be nonnegative; The array must be freed using freea() before the function returns; Upon failure, it exits with an error message */
#define xnmalloca(n, s)   xmalloca(xalloc_oversized((n), (s)) ? (size_t)(-1) : (n) * (s))


LIB_FUNC void* fixup_null_alloc(const size_t n) {
	void* p;
	p = 0;
	if (n == 0) { p = malloc((size_t)1); }
	if (p == 0) { error(EXIT_FAILURE, 0, "memory exhausted"); }
	return p;
}


LIB_FUNC noreturn void xalloc_die(void) {
	error(exit_failure, 0, "Memory exhausted");
	fflush(NULL);  // Flush all streams
	ABORT;
	UNREACHABLE
}


/** Allocate zeroed memory for N elements of S bytes, with error checking; S must be nonzero */
LIB_FUNC attr_malloc attr_alloc_size(1) void* xcalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	void* p;
	if (xalloc_oversized(n, s) || (!(p = calloc(n, s)) && n != 0)) { xalloc_die(); }
	if (p == 0) { p = fixup_null_alloc(n); }
	return p;
}


/** Allocate N bytes of memory dynamically, with error checking */
LIB_FUNC attr_malloc attr_alloc_size(1) void* xmalloc(const size_t n) {
	if (n == 0) { return NULL; }
	void* p = malloc(n);
	if (!p && n != 0) { xalloc_die(); }
	return p;
}


/** Change the size of an allocated block of memory P to N bytes, with error checking; If P is NULL, run xmalloc */
LIB_FUNC attr_malloc attr_alloc_size(2) void* xrealloc(void* p, const size_t n) {
	if (p == 0) { return xmalloc(n); }
	else if (!n && p) { free(p); return NULL; }
	p = realloc(p, n);
	if (!p && n) { xalloc_die(); }
	return p;
}


LIB_FUNC void* xmmalloca(const size_t n) {
	if (n == 0) { return NULL; }
	void* p;
	p = mmalloca(n);
	if (p == NULL) { xalloc_die(); }
	return p;
}


/** Clone an object P of size S, with error checking; There is no need for xnmemdup(P, N, S), since xmemdup(P, N * S) works without any need for an arithmetic overflow check */
LIB_FUNC attr_alloc_size(2) void* xmemdup(void const* p, const size_t s) {
	if (s == 0) { return NULL; }
	return memcpy(xmalloc(s), p, s);
}


/** Return a newly allocated copy of STRING */
LIB_FUNC attr_malloc char* xstrdup(const char* _string) {
	return xmemdup(_string, strlen(_string) + 1);
}


/** Allocate an array of N objects, each with S bytes of memory, dynamically, with error checking; S must be nonzero */
LIB_FUNC attr_malloc attr_alloc_size(1) void* xnmalloc(const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	else if (xalloc_oversized(n, s)) { xalloc_die(); }
	return xmalloc(n * s);
}


/** Change the size of an allocated block of memory P to an array of N objects each of S bytes, with error checking; S must be nonzero */
LIB_FUNC attr_alloc_size(2) void* xnrealloc(void* p, const size_t n, const size_t s) {
	if (n == 0 || s == 0) { return NULL; }
	else if (xalloc_oversized(n, s)) { xalloc_die(); }
	return xrealloc(p, (n * s));
}


/** If P is null, allocate a block of at least *PN such objects; otherwise, reallocate P so that it contains more than *PN objects each of S bytes; S must be nonzero; Set *PN to the new number of objects, and return the pointer to the new block; *PN is never set to zero, and the returned pointer is never null */
LIB_FUNC void* x2nrealloc(void* p, size_t* pn, const size_t s) {
	size_t n = *pn;
	if (!p) {
		if (!n) {
			enum { DEFAULT_MXFAST = ((64 * SIZEOF_SIZE_T) >> 2) };
			n = DEFAULT_MXFAST / s;
			n += !n;
		}
	} else {
		if ((((size_t)-1) / 3 * 2 / s) <= n) { xalloc_die(); }
		n += ((n >> 1) + 1);
	}
	*pn = n;
	return xrealloc(p, (n * s));
}


/** Return a pointer to a new buffer of N bytes; This is like xmalloc, except it returns char * */
LIB_FUNC attr_malloc attr_alloc_size(1) char* xcharalloc(const size_t n) {
	if (n == 0) { return NULL; }
	return XNMALLOC(n, char);
}


/** If P is null, allocate a block of at least *PN bytes; otherwise, reallocate P so that it contains more than *PN bytes; *PN must be nonzero unless P is null; Set *PN to the new block's size, and return the pointer to the new block; *PN is never set to zero, and the returned pointer is never null */
LIB_FUNC void* x2realloc(void* p, size_t* pn) {
	return x2nrealloc(p, pn, 1);
}


/** Allocate S bytes of zeroed memory dynamically, with error checking; There is no need for xnzalloc (N, S), since it would be equivalent to xcalloc (N, S) */
LIB_FUNC attr_malloc attr_alloc_size(1) void* xzalloc(const size_t s) {
	if (s == 0) { return NULL; }
	return memset(xmalloc(s), 0, s);
}


// Scalar allocators
#define XALLOCA(T)   ((T*)alloca(sizeof(T)))
#define XNEW(T)   ((T*)xmalloc(sizeof(T)))
#define XCNEW(T)   ((T*)xcalloc(1, sizeof(T)))
#define XDUP(T, P)   ((T*)xmemdup((P), sizeof(T), sizeof(T)))
#define XDELETE(P)   free((void*)(P))
// Array allocators
#define XALLOCAVEC(T, N)   ((T*)alloca((sizeof(T) * (N))))
#define XNEWVEC(T, N)   ((T*)xmalloc((sizeof(T) * (N))))
#define XCNEWVEC(T, N)   ((T*)xcalloc((N), sizeof(T)))
#define XDUPVEC(T, P, N)   ((T*)xmemdup((P), (sizeof(T) * (N)), (sizeof(T) * (N))))
#define XRESIZEVEC(T, P, N)   ((T*)xrealloc((void*)(P), (sizeof(T) * (N))))
#define XDELETEVEC(P)   free((void*)(P))
// Allocators for variable-sized structures and raw buffers
#define XALLOCAVAR(T, S)   ((T*)alloca((S)))
#define XNEWVAR(T, S)   ((T*)xmalloc((S)))
#define XCNEWVAR(T, S)   ((T*)xcalloc(1, (S)))
#define XDUPVAR(T, P, S1, S2)   ((T*)xmemdup((P), (S1), (S2)))
#define XRESIZEVAR(T, P, S)   ((T*)xrealloc((P), (S)))
// Type-safe obstack allocator
#define XOBNEW(O, T)   ((T*)obstack_alloc((O), sizeof(T)))
#define XOBNEWVEC(O, T, N)   ((T*)obstack_alloc((O), (sizeof(T) * (N))))
#define XOBNEWVAR(O, T, S)   ((T*)obstack_alloc((O), (S)))
#define XOBFINISH(O, T)   ((T)obstack_finish((O)))


#endif  // XMALLOC_H


// MEMORY ALLOCATION ALIGNED TO SYSTEM PAGE BOUNDARIES (<pagealign_alloc.h>)


/** The list of currently allocated memory regions */
static UNUSED memnode_t* memnode_table = NULL;


LIB_FUNC void new_memnode(void* aligned_ptr, const info_t info) {
	memnode_t* new_node = XMALLOC(memnode_t);
	new_node->aligned_ptr = aligned_ptr;
	new_node->info = info;
	new_node->next = memnode_table;
	memnode_table = new_node;
}


/** Dispose of the memnode containing a map for the ALIGNED_PTR in question and return the content of the node's INFO field */
LIB_FUNC info_t get_memnode(void* aligned_ptr) {
	memnode_t* c;
	memnode_t** p_next = &memnode_table;
	for (c = *p_next; c != NULL; p_next = &c->next, c = c->next) {
		if (c->aligned_ptr == aligned_ptr) { break; }
	}
	if (c == NULL) { abort(); }  // Attempt to free untracked memory; A wrong pointer was passed to pagealign_free()
	// Remove this entry from the list, save the return value, and free it
	*p_next = c->next;
	const info_t ret = c->info;
	free(c);
	return ret;
}


/** Allocate a block of memory of SIZE bytes, aligned on a system page boundary; If SIZE is not a multiple of the system page size, it will be rounded up to the next multiple; Return a pointer to the start of the memory block; Upon allocation failure, return NULL and set errno */
LIB_FUNC attr_malloc attr_alloc_size(1) void* pagealign_alloc(const size_t size) {
	void* ret = mmap(NULL, size, (PROT_READ | PROT_WRITE), (MAP_ANONYMOUS | MAP_PRIVATE), -1, 0);
	if (ret == MAP_FAILED) { return NULL; }
	new_memnode(ret, size);
	return ret;
}


/** Like pagealign_alloc, except it exits the program if the allocation fails */
LIB_FUNC attr_malloc attr_alloc_size(1) void* pagealign_xalloc(const size_t size) {
	void* ret = pagealign_alloc(size);
	if (ret == NULL) { xalloc_die(); }
	return ret;
}


/** Free a memory block; PTR must be a non-NULL pointer returned by pagealign_alloc or pagealign_xalloc */
LIB_FUNC void pagealign_free(void* aligned_ptr) {
#   if HAVE_MMAP
	if (munmap(aligned_ptr, get_memnode(aligned_ptr)) < 0) { error(EXIT_FAILURE, errno, "Failed to unmap memory"); }
#   elif HAVE_POSIX_MEMALIGN
	free(aligned_ptr);
#   else
	free(get_memnode(aligned_ptr));
#   endif
}


/* TODO: Add sys/mman.h functions
int posix_mem_offset(const void* restrict, size_t, off_t* restrict, size_t* restrict, int* restrict);
int posix_typed_mem_get_info(int, struct posix_typed_mem_info *);
int posix_typed_mem_open(const char*, int, int);
*/


#endif  // SYS_MMAN_H


/* EVENTPOLL (<sys/epoll.h>) */


#if ((!(defined(_SYS_EPOLL_H) || defined(_SYS_EPOLL_H_))) && defined(OSLINUX))
#define _SYS_EPOLL_H   (1)
#define _SYS_EPOLL_H_   (1)


#ifndef __EPOLL_PACKED
#   define __EPOLL_PACKED
#endif


enum EPOLL_EVENTS {
	EPOLLIN = 1,
	EPOLLPRI = 2,
	EPOLLOUT = 4,
	EPOLLERR = 8,
	EPOLLHUP = 0x10,
	EPOLLRDNORM = 0x40,
	EPOLLRDBAND = 0x80,
	EPOLLWRNORM = 0x100,
	EPOLLWRBAND = 0x200,
	EPOLLMSG = 0x400,
	EPOLLRDHUP = 0x2000,
	EPOLLONESHOT = 0x40000000
};
#define EPOLLET   0x80000000


// Valid opcodes ("op" parameter) to issue to epoll_ctl()
/** Add a file descriptor to the interface */
#define EPOLL_CTL_ADD   1
/** Remove a file descriptor from the interface */
#define EPOLL_CTL_DEL   2
/** Change file descriptor epoll_event structure */
#define EPOLL_CTL_MOD   3


typedef union epoll_data {
	void* ptr;
	int fd;
	uint32_t _u32;
	uint64_t _u64;
} epoll_data_t;


typedef struct attr_packed epoll_event {
	uint32_t events;  // Epoll events
	epoll_data_t data;  // User data variable
} epoll_event_t;


/** Same as epoll_create but with a FLAGS parameter; The unused SIZE parameter has been dropped */
LIB_FUNC int epoll_create1(const int flags) {
	int r = (int)__syscall(SYS_epoll_create1, flags);
#   ifdef SYS_epoll_create
	if (r == (-ENOSYS) && (!flags)) { r = (int)__syscall(SYS_epoll_create, 1); }
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


/** Creates an epoll instance; Returns an fd for the new instance */
LIB_FUNC int epoll_create(const UNUSED int size) {
	return epoll_create1(0);
}


/** Manipulate an epoll instance "epfd". Returns 0 in case of success, -1 in case of error (the "errno" variable will contain the specific error code) */
LIB_FUNC int epoll_ctl(int fd, int op, int fd2, struct epoll_event* ev) {
	return (int)syscall(SYS_epoll_ctl, fd, op, fd2, (long)&ev);
}


/** Same as epoll_wait, but the thread's signal mask is temporarily and atomically replaced with the one provided as parameter */
LIB_FUNC int epoll_pwait(int fd, struct epoll_event* ev, int cnt, int to, const sigset_t* sigs) {
	int r = (int)syscall(SYS_epoll_pwait, fd, (long)&ev, cnt, to, (long)&sigs, (_NSIG / 8));
#   ifdef SYS_epoll_wait
	if (r == (-ENOSYS) && (!sigs)) { r = (int)syscall(SYS_epoll_wait, fd, (long)&ev, cnt, to); }
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


/** Wait for events on an epoll instance "epfd"; Returns the number of triggered events returned in "events" buffer, or -1 in case of error (the "errno" variable will contain the specific error code) */
LIB_FUNC int epoll_wait(int fd, struct epoll_event* ev, int cnt, int to) {
	return (int)epoll_pwait(fd, ev, cnt, to, 0);
}


#endif  // SYS_EPOLL_H


/* POLL (<poll.h>) */


#if ((!(defined(_POLL_H) || defined(_POLL_H_) || defined(_SYS_POLL_H) || defined(_SYS_POLL_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/poll.h.html
#define _POLL_H   (1)
#define _POLL_H_   (1)
#define _SYS_POLL_H   (1)
#define _SYS_POLL_H_   (1)
#define __ASM_GENERIC_POLL_H   (1)


#ifndef INFTIM
#   define INFTIM   (-1)
#endif
#if ((!defined(MSG_PEEK)) && defined(OSBEOS))
/** BeOS does not have MSG_PEEK */
#   define MSG_PEEK   0
#elif (!defined(MSG_PEEK))
/** BeOS does not have MSG_PEEK */
#   define MSG_PEEK   2
#endif
// Event types that can be polled; These bits may be set in `events` to indicate the interesting event types; they will appear in `revents` to indicate the status of the file descriptor
/** There is data to read */
#define POLLIN   1
/** There is urgent data to read */
#define POLLPRI   2
/** Writing now will not block */
#define POLLOUT   4
// These values are defined in XPG4.2 and later
/** Normal data may be read */
#define POLLRDNORM   POLLIN
/** Priority data may be read */
#define POLLRDBAND   POLLPRI
/** Writing now will not block */
#define POLLWRNORM   POLLOUT
/** Priority data may be written */
#define POLLWRBAND   POLLOUT
// Errors
/** Error condition */
#define POLLERR   010
/** Hung up */
#define POLLHUP   020
/** Invalid polling request */
#define POLLNVAL   040
#define POLLREMOVE   0x1000
#define POLLRDHUP   0x2000
#define POLLFREE   0x4000
#define LIBC_CANCEL_ASYNC(val)   (0)
#define CANCEL_ASYNC(val)   (0)
#define LIBC_CANCEL_RESET(val)   ((void)(val))
#define CANCEL_RESET(val)   ((void)(val))


/** An unsigned integer type used for the number of file descriptors */
typedef unsigned int   nfds_t;


typedef struct pollfd {
	int fd;  // File descriptor
	short events;  // Events to look for
	short revents;  // Events returned
} pollfd_t;


LIB_FUNC int poll(struct pollfd* p, const nfds_t nfds, const int timeout) {
	fd_set rd, wr, except;
	struct timeval tv;
	FD_ZERO(&rd);
	FD_ZERO(&wr);
	FD_ZERO(&except);
	register nfds_t i;
	int highfd = -1;
	for (i = 0; i < nfds; i++) {
		if (p[i].fd < 0) { continue; }
		else if (p[i].fd >= FD_SETSIZE) { errno = EINVAL; return -1; }
		else if (p[i].fd > highfd) { highfd = p[i].fd; }
		if (p[i].events & (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI)) { FD_SET(p[i].fd, &rd); }
		if (p[i].events & (POLLOUT | POLLWRNORM | POLLWRBAND)) { FD_SET(p[i].fd, &wr); }
		FD_SET(p[i].fd, &except);
	}
	tv.tv_sec = timeout / 1000;
	tv.tv_usec = (timeout % 1000) * 1000;
	int rval = select((highfd + 1), &rd, &wr, &except, (timeout == -1 ? NULL : &tv));
	if (rval <= 0) { return rval; }
	rval = 0;
	for (i = 0; i < nfds; i++) {
		p[i].revents = 0;
		if (FD_ISSET(p[i].fd, &rd)) { p[i].revents |= (POLLIN | POLLRDNORM | POLLRDBAND | POLLPRI); }
		if (FD_ISSET(p[i].fd, &wr)) { p[i].revents |= (POLLOUT | POLLWRNORM | POLLWRBAND); }
		if (FD_ISSET(p[i].fd, &except)) { p[i].revents |= POLLERR; }
		if (p[i].revents != 0) { rval++; }
	}
	return rval;
}
#define __poll(p, nfds, timeout)   poll((p), (nfds), (timeout))


LIB_FUNC int ppoll(struct pollfd* fds, nfds_t nfds, const struct timespec* timeout, const sigset_t* sigmask) {
	struct timespec tval;
	if (timeout != NULL) { tval = *timeout; timeout = &tval; }
	register int result;
	if (SINGLE_THREAD_P) { result = (int)syscall(SYS_ppoll, 5, (long)&fds, (long)nfds, (long)&timeout, (long)&sigmask, (_NSIG / 8)); }
	else {
		int oldtype = LIBC_CANCEL_ASYNC();
		result = (int)syscall(SYS_ppoll, 5, (long)&fds, (long)nfds, (long)&timeout, (long)&sigmask, (_NSIG / 8));
		LIBC_CANCEL_RESET(oldtype);
	}
	return result;
}


LIB_FUNC int __poll_chk(struct pollfd* fds, nfds_t nfds, int timeout, size_t fdslen) {
	if (fdslen / sizeof(*fds) < nfds) { __chk_fail("poll() failed in __poll_chk()!"); }
	return poll(fds, nfds, timeout);
}


LIB_FUNC int __ppoll_chk(struct pollfd* fds, nfds_t nfds, const struct timespec* timeout, const sigset_t* ss, size_t fdslen) {
	if (fdslen / sizeof(*fds) < nfds) { __chk_fail("ppoll() failed in __ppoll_chk()!"); }
	return ppoll(fds, nfds, timeout, ss);
}


LIB_FUNC void zero_fd_set(const unsigned long nr, unsigned long* fdset) {
	memset_no_output(fdset, 0, FDS_BYTES(nr));
}


#endif  // POLL_H


/* REBOOT */


#if ((!(defined(SYS_REBOOT_H) || defined(_SYS_REBOOT_H) || defined(_SYS_REBOOT_H_))) && (defined(OSLINUX)))
#define SYS_REBOOT_H   (1)
#define _SYS_REBOOT_H   (1)
#define _SYS_REBOOT_H_   (1)


#define RB_AUTOBOOT   (0x1234567)
#define RB_HALT_SYSTEM   (0xcdef0123)
#define RB_ENABLE_CAD   (0x89abcdef)
#define RB_DISABLE_CAD   (0)
#define RB_POWER_OFF   (0x4321fedc)
#define RB_SW_SUSPEND   (0xd000fce2)
#define RB_KEXEC   (0x45584543)


LIB_FUNC int reboot(const int type) {
	return (int)syscall(SYS_reboot, 0xfee1dead, 672274793, type);
}


#endif  // SYS_REBOOT_H


/* SWAP */


#if ((!(defined(SYS_SWAP_H) || defined(_SYS_SWAP_H) || defined(_SYS_SWAP_H_))) && defined(OSLINUX))
#define SYS_SWAP_H   (1)
#define _SYS_SWAP_H   (1)
#define _SYS_SWAP_H_   (1)


#define SWAP_FLAG_PREFER   (0x8000)
#define SWAP_FLAG_PRIO_MASK   (0x7fff)
#define SWAP_FLAG_PRIO_SHIFT   (0)
#define SWAP_FLAG_DISCARD   (0x10000)


LIB_FUNC int swapon(const char* restrict path, const int flags) {
	return (int)syscall(SYS_swapon, path, flags);
}


LIB_FUNC int swapoff(const char* restrict path) {
	return (int)syscall(SYS_swapoff, path);
}


#endif  // SYS_SWAP_H


/* FANOTIFY (<sys/fanotify.h>) */


#if ((!(defined(_SYS_FANOTIFY_H) || defined(_SYS_FANOTIFY_H_))) && defined(OSLINUX))
#define SYS_FANOTIFY_H   (1)
#define _SYS_FANOTIFY_H   (1)
#define _SYS_FANOTIFY_H_   (1)


typedef struct fanotify_event_metadata {
	unsigned event_len;
	unsigned char vers, reserved;
	unsigned short metadata_len;
#   ifdef __GNUC__
	unsigned long long align8 mask;
#   else
	unsigned long long mask;
#   endif
	int fd, pid;
} fanotify_event_metadata_t;


typedef struct fanotify_response {
	int fd;
	unsigned response;
} fanotify_response_t;


#define FAN_ACCESS   1
#define FAN_MODIFY   2
#define FAN_CLOSE_WRITE   8
#define FAN_CLOSE_NOWRITE   0x10
#define FAN_OPEN   0x20
#define FAN_Q_OVERFLOW   0x4000
#define FAN_OPEN_PERM   0x10000
#define FAN_ACCESS_PERM   0x20000
#define FAN_ONDIR   0x40000000
#define FAN_EVENT_ON_CHILD   0x8000000
#define FAN_CLOSE   (FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE)
#define FAN_CLOEXEC   1
#define FAN_NONBLOCK   2
#define FAN_CLASS_NOTIF   0
#define FAN_CLASS_CONTENT   4
#define FAN_CLASS_PRE_CONTENT   8
#define FAN_ALL_CLASS_BITS   (FAN_CLASS_NOTIF | FAN_CLASS_CONTENT | FAN_CLASS_PRE_CONTENT)
#define FAN_UNLIMITED_QUEUE   0x10
#define FAN_UNLIMITED_MARKS   0x20
#define FAN_ALL_INIT_FLAGS   (FAN_CLOEXEC | FAN_NONBLOCK | FAN_ALL_CLASS_BITS | FAN_UNLIMITED_QUEUE | FAN_UNLIMITED_MARKS)
#define FAN_MARK_ADD   1
#define FAN_MARK_REMOVE   2
#define FAN_MARK_DONT_FOLLOW   4
#define FAN_MARK_ONLYDIR   8
#define FAN_MARK_MOUNT   0x10
#define FAN_MARK_IGNORED_MASK   0x20
#define FAN_MARK_IGNORED_SURV_MODIFY   0x40
#define FAN_MARK_FLUSH   0x80
#define FAN_ALL_MARK_FLAGS   (FAN_MARK_ADD | FAN_MARK_REMOVE | FAN_MARK_DONT_FOLLOW | FAN_MARK_ONLYDIR | FAN_MARK_MOUNT | FAN_MARK_IGNORED_MASK | FAN_MARK_IGNORED_SURV_MODIFY | FAN_MARK_FLUSH)
#define FAN_ALL_EVENTS   (FAN_ACCESS | FAN_MODIFY | FAN_CLOSE | FAN_OPEN)
#define FAN_ALL_PERM_EVENTS   (FAN_OPEN_PERM | FAN_ACCESS_PERM)
#define FAN_ALL_OUTGOING_EVENTS   (FAN_ALL_EVENTS | FAN_ALL_PERM_EVENTS | FAN_Q_OVERFLOW)
#define FANOTIFY_METADATA_VERSION   3
#define FAN_ALLOW   1
#define FAN_DENY   2
#define FAN_NOFD   -1
#define FAN_EVENT_METADATA_LEN   (sizeof(struct fanotify_event_metadata))
#define FAN_EVENT_NEXT(meta, len)   ((len) -= (meta)->event_len, (struct fanotify_event_metadata*)(((char*)(meta)) + (meta)->event_len))
#define FAN_EVENT_OK(meta, len)   ((long)(len) >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len >= (long)FAN_EVENT_METADATA_LEN && (long)(meta)->event_len <= (long)(len))


/** Create and initialize fanotify group */
LIB_FUNC int fanotify_init(const unsigned flags, const unsigned event_f_flags) {
	return (int)syscall(SYS_fanotify_init, flags, event_f_flags);
}


/** Add, remove, or modify an fanotify mark on a filesystem object */
LIB_FUNC int fanotify_mark(const int fanotify_fd, const unsigned flags, const unsigned long long mask, const int dfd, const char* restrict pathname) {
	return (int)syscall(SYS_fanotify_mark, fanotify_fd, flags, __SYSCALL_LL_E(mask), dfd, pathname);
}


#endif  // SYS_FANOTIFY_H


/* INOTIFY (<sys/inotify.h>) */


#if ((!(defined(_SYS_INOTIFY_H) || defined(_SYS_INOTIFY_H_))) && defined(OSLINUX))
#define SYS_INOTIFY_H   (1)
#define _SYS_INOTIFY_H   (1)
#define _SYS_INOTIFY_H_   (1)


/** Structure describing an inotify event */
typedef struct inotify_event {
	int wd;  // Watch descriptor
	uint32_t mask;  // Watch mask
	uint32_t cookie;  // Cookie to synchronize two events
	uint32_t len;  // Length (including NULs) of name
	char name __flexarr;  // Name
} inotify_event_t;


// Supported events suitable for MASK parameter of INOTIFY_ADD_WATCH
/** File was accessed */
#define IN_ACCESS   1
/** File was modified */
#define IN_MODIFY   2
/** Metadata changed */
#define IN_ATTRIB   4
/** Writtable file was closed */
#define IN_CLOSE_WRITE   8
/** Unwrittable file closed */
#define IN_CLOSE_NOWRITE   0x10
/** Close */
#define IN_CLOSE   (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
/** File was opened */
#define IN_OPEN   0x20
/** File was moved from X */
#define IN_MOVED_FROM   0x40
/** File was moved to Y */
#define IN_MOVED_TO   0x80
/** Moves */
#define IN_MOVE   (IN_MOVED_FROM | IN_MOVED_TO)
/** Subfile was created */
#define IN_CREATE   0x100
/** Subfile was deleted */
#define IN_DELETE   0x200
/** Self was deleted */
#define IN_DELETE_SELF   0x400
/** Self was moved */
#define IN_MOVE_SELF   0x800
// Events sent by the kernel
/** Backing fs was unmounted */
#define IN_UNMOUNT   0x2000
/** Event queued overflowed */
#define IN_Q_OVERFLOW   0x4000
/** File was ignored */
#define IN_IGNORED   0x8000
// Helper events
/** Close */
#define IN_CLOSE   (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)
/** Moves */
#define IN_MOVE   (IN_MOVED_FROM | IN_MOVED_TO)
// Special flags
/** Only watch the path if it is a directory */
#define IN_ONLYDIR   0x1000000
/** Do not follow a sym link */
#define IN_DONT_FOLLOW   0x2000000
/** Exclude events on unlinked objects */
#define IN_EXCL_UNLINK   0x4000000
/** Add to the mask of an already existing watch */
#define IN_MASK_ADD   0x20000000
/** Event occurred against dir */
#define IN_ISDIR   0x40000000
/** Only send event once */
#define IN_ONESHOT   0x80000000
// All events which a program can wait on
#define IN_ALL_EVENTS   (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_CREATE | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF)


/** Create and initialize inotify instance */
LIB_FUNC int inotify_init1(const int flags) {
	int r = (int)__syscall(SYS_inotify_init1, flags);
#   ifdef SYS_inotify_init
	if (r == -ENOSYS && !flags) { r = (int)__syscall(SYS_inotify_init); }
#   endif
	return (int)__syscall_ret((unsigned long)r);
}


/** Create and initialize inotify instance */
LIB_FUNC int inotify_init(void) {
	return inotify_init1(0);
}


/** Add watch of object NAME to inotify instance FD; Notify about events specified by MASK */
LIB_FUNC int inotify_add_watch(const int fd, const char* pathname, const uint32_t mask) {
	return (int)syscall(SYS_inotify_add_watch, fd, pathname, mask);
}


/** Remove the watch specified by WD from the inotify instance FD */
LIB_FUNC int inotify_rm_watch(const int fd, const int wd) {
	return (int)syscall(SYS_inotify_rm_watch, fd, wd);
}


#endif  // SYS_INOTIFY_H


/* SEND FILE (<sys/sendfile.h>) */


#if ((!(defined(_SYS_SENDFILE_H) || defined(_SYS_SENDFILE_H_))) && defined(OSLINUX))
#define SYS_SENDFILE_H   (1)
#define _SYS_SENDFILE_H   (1)
#define _SYS_SENDFILE_H_   (1)


LIB_FUNC ssize_t sendfile(int out_fd, int in_fd, off_t* ofs, size_t count) {
	return (ssize_t)syscall(SYS_sendfile, out_fd, in_fd, ofs, count);
}
#define sendfile64(out_fd, in_fd, ofs, count)   sendfile((out_fd), (in_fd), (ofs), (count))


#endif  // SYS_SENDFILE_H


/* SOCKETS (<sys/socket.h>) */


#if (!(defined(_SYS_SOCKET_H) || defined(_SYS_SOCKET_H_) || defined(__BITS_SOCKET_H) || defined(_BITS_SOCKET_H) || defined(_BITS_SOCKET_H_) || defined(_HURD_HURDSOCKET_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html
#define SYS_SOCKET_H   (1)
#define _SYS_SOCKET_H   (1)
#define _SYS_SOCKET_H_   (1)
#define BITS_SOCKET_H   (1)
#define _BITS_SOCKET_H   (1)
#define _BITS_SOCKET_H_   (1)
#define __BITS_SOCKET_H   (1)
#define __BITS_SOCKET_H_   (1)
#define _HURD_HURDSOCKET_H   (1)  // <hurdsocket.h>


#define SHUT_RD   0
#define SHUT_WR   1
#define SHUT_RDWR   2
#ifndef SOCK_STREAM
#   define SOCK_STREAM   1
#   define SOCK_DGRAM   2
#endif
#define SOCK_RAW   3
#define SOCK_RDM   4
#define SOCK_SEQPACKET   5
#define SOCK_DCCP   6
#define SOCK_PACKET   10
#ifndef SOCK_CLOEXEC
#   define SOCK_CLOEXEC   02000000
#   define SOCK_NONBLOCK   04000
#endif
#define PF_UNSPEC   0
#define PF_LOCAL   1
#define PF_UNIX   PF_LOCAL
#define PF_FILE   PF_LOCAL
#define PF_INET   2
#define PF_AX25   3
#define PF_IPX   4
#define PF_APPLETALK   5
#define PF_NETROM   6
#define PF_BRIDGE   7
#define PF_ATMPVC   8
#define PF_X25   9
#define PF_INET6   10
#define PF_ROSE   11
#define PF_DECnet   12
#define PF_NETBEUI   13
#define PF_SECURITY   14
#define PF_KEY   15
#define PF_NETLINK   16
#define PF_ROUTE   PF_NETLINK
#define PF_PACKET   17
#define PF_ASH   18
#define PF_ECONET   19
#define PF_ATMSVC   20
#define PF_RDS   21
#define PF_SNA   22
#define PF_IRDA   23
#define PF_PPPOX   24
#define PF_WANPIPE   25
#define PF_LLC   26
#define PF_IB   27
#define PF_MPLS   28
#define PF_CAN   29
#define PF_TIPC   30
#define PF_BLUETOOTH   31
#define PF_IUCV   32
#define PF_RXRPC   33
#define PF_ISDN   34
#define PF_PHONET   35
#define PF_IEEE802154   36
#define PF_CAIF   37
#define PF_ALG   38
#define PF_NFC   39
#define PF_VSOCK   40
#define PF_MAX   41
#define AF_UNSPEC   PF_UNSPEC
#define AF_LOCAL   PF_LOCAL
#define AF_UNIX   AF_LOCAL
#define AF_FILE   AF_LOCAL
#define AF_INET   PF_INET
#define AF_AX25   PF_AX25
#define AF_IPX   PF_IPX
#define AF_APPLETALK   PF_APPLETALK
#define AF_NETROM   PF_NETROM
#define AF_BRIDGE   PF_BRIDGE
#define AF_ATMPVC   PF_ATMPVC
#define AF_X25   PF_X25
#define AF_INET6   PF_INET6
#define AF_ROSE   PF_ROSE
#define AF_DECnet   PF_DECnet
#define AF_NETBEUI   PF_NETBEUI
#define AF_SECURITY   PF_SECURITY
#define AF_KEY   PF_KEY
#define AF_NETLINK   PF_NETLINK
#define AF_ROUTE   PF_ROUTE
#define AF_PACKET   PF_PACKET
#define AF_ASH   PF_ASH
#define AF_ECONET   PF_ECONET
#define AF_ATMSVC   PF_ATMSVC
#define AF_RDS   PF_RDS
#define AF_SNA   PF_SNA
#define AF_IRDA   PF_IRDA
#define AF_PPPOX   PF_PPPOX
#define AF_WANPIPE   PF_WANPIPE
#define AF_LLC   PF_LLC
#define AF_IB   PF_IB
#define AF_MPLS   PF_MPLS
#define AF_CAN   PF_CAN
#define AF_TIPC   PF_TIPC
#define AF_BLUETOOTH   PF_BLUETOOTH
#define AF_IUCV   PF_IUCV
#define AF_RXRPC   PF_RXRPC
#define AF_ISDN   PF_ISDN
#define AF_PHONET   PF_PHONET
#define AF_IEEE802154   PF_IEEE802154
#define AF_CAIF   PF_CAIF
#define AF_ALG   PF_ALG
#define AF_NFC   PF_NFC
#define AF_VSOCK   PF_VSOCK
#define AF_MAX   PF_MAX
#ifndef SO_DEBUG
#   define SO_DEBUG   1
#   define SO_REUSEADDR   2
#   define SO_TYPE   3
#   define SO_ERROR   4
#   define SO_DONTROUTE   5
#   define SO_BROADCAST   6
#   define SO_SNDBUF   7
#   define SO_RCVBUF   8
#   define SO_KEEPALIVE   9
#   define SO_OOBINLINE   10
#   define SO_NO_CHECK   11
#   define SO_PRIORITY   12
#   define SO_LINGER   13
#   define SO_BSDCOMPAT   14
#   define SO_REUSEPORT   15
#   define SO_PASSCRED   16
#   define SO_PEERCRED   17
#   define SO_RCVLOWAT   18
#   define SO_SNDLOWAT   19
#   define SO_RCVTIMEO   20
#   define SO_SNDTIMEO   21
#   define SO_ACCEPTCONN   30
#   define SO_SNDBUFFORCE   32
#   define SO_RCVBUFFORCE   33
#   define SO_PROTOCOL   38
#   define SO_DOMAIN   39
#endif
#define SO_SECURITY_AUTHENTICATION   22
#define SO_SECURITY_ENCRYPTION_TRANSPORT   23
#define SO_SECURITY_ENCRYPTION_NETWORK   24
#define SO_BINDTODEVICE   25
#define SO_ATTACH_FILTER   26
#define SO_DETACH_FILTER   27
#define SO_GET_FILTER   SO_ATTACH_FILTER
#define SO_PEERNAME   28
#define SO_TIMESTAMP   29
#define SCM_TIMESTAMP   SO_TIMESTAMP
#define SO_PEERSEC   31
#define SO_PASSSEC   34
#define SO_TIMESTAMPNS   35
#define SCM_TIMESTAMPNS   SO_TIMESTAMPNS
#define SO_MARK   36
#define SO_TIMESTAMPING   37
#define SCM_TIMESTAMPING   SO_TIMESTAMPING
#define SO_RXQ_OVFL   40
#define SO_WIFI_STATUS   41
#define SCM_WIFI_STATUS   SO_WIFI_STATUS
#define SO_PEEK_OFF   42
#define SO_NOFCS   43
#define SO_LOCK_FILTER   44
#define SO_SELECT_ERR_QUEUE   45
#define SO_BUSY_POLL   46
#define SO_MAX_PACING_RATE   47
#define SO_BPF_EXTENSIONS   48
#define SO_INCOMING_CPU   49
#define SO_ATTACH_BPF   50
#define SO_DETACH_BPF   SO_DETACH_FILTER
#ifndef SOL_SOCKET
#   define SOL_SOCKET   1
#endif
#define SOL_IP   0
#define SOL_IPV6   41
#define SOL_ICMPV6   58
#define SOL_RAW   255
#define SOL_DECNET   261
#define SOL_X25   262
#define SOL_PACKET   263
#define SOL_ATM   264
#define SOL_AAL   265
#define SOL_IRDA   266
/** Maximum queue length specifiable by listen(2) */
#define SOMAXCONN   128
#define MSG_OOB   1
#define MSG_DONTROUTE   4
#define MSG_CTRUNC   8
#define MSG_PROXY   0x10
#define MSG_TRUNC   0x20
#define MSG_DONTWAIT   0x40
#define MSG_EOR   0x80
#define MSG_WAITALL   0x100
#define MSG_FIN   0x200
#define MSG_SYN   0x400
#define MSG_CONFIRM   0x800
#define MSG_RST   0x1000
#define MSG_ERRQUEUE   0x2000
#define MSG_NOSIGNAL   0x4000
#define MSG_MORE   0x8000
#define MSG_WAITFORONE   0x10000
#define MSG_FASTOPEN   0x20000000
#define MSG_CMSG_CLOEXEC   0x40000000
#define SCM_RIGHTS   1
#define SCM_CREDENTIALS   2
#define NET_RT_DUMP   1
#define NET_RT_FLAGS   2
#define NET_RT_OOIFLIST   3
#define NET_RT_OIFLIST   4
#define NET_RT_IFLIST   5
#define NET_RT_MAXID   6


typedef struct ucred {
	pid_t pid;
	uid_t uid;
	gid_t gid;
} ucred_t;


typedef struct linger { int l_onoff, l_linger; }   linger_t;


typedef struct attr_packed sockaddr {
	uint8_t sa_len;
	sa_family_t sa_family;
	char sa_data[14];
} sockaddr_t;


typedef struct attr_packed sockaddr_storage {
	sa_family_t ss_family;
	unsigned long __ss_align;
	char __ss_padding[126 * SIZEOF_LONG];
} sockaddr_storage_t;


#ifdef ARM64


typedef struct msghdr {
	void* msg_name;
	socklen_t msg_namelen;
	struct iovec* msg_iov;
#   if IS_BIG_ENDIAN
	int __pad1, msg_iovlen;
#   else
	int msg_iovlen, __pad1;
#   endif
	void* msg_control;
#   if IS_BIG_ENDIAN
	int __pad2;
	socklen_t msg_controllen;
#   else
	socklen_t msg_controllen;
	int __pad2;
#   endif
	int msg_flags;
} msghdr_t;


typedef struct cmsghdr {
#   if IS_BIG_ENDIAN
	int __pad1;
	socklen_t cmsg_len;
#   else
	socklen_t cmsg_len;
	int __pad1;
#   endif
	int cmsg_level, cmsg_type;
} cmsghdr_t;


#elif (defined(X86_64) || defined(X86) || defined(I386))


typedef struct attr_packed msghdr {
	void* msg_name;
	socklen_t msg_namelen;
	struct iovec* msg_iov;
	int msg_iovlen, __pad1;
	void* msg_control;
	socklen_t msg_controllen, __pad2;
	int msg_flags;
} msghdr_t;


typedef struct cmsghdr {
	socklen_t cmsg_len;
	int __pad1, cmsg_level, cmsg_type;
} cmsghdr_t;


#elif defined(MIPS)


typedef struct msghdr {
	void* msg_name;
	socklen_t msg_namelen;
	struct iovec* msg_iov;
	int msg_iovlen;
	void* msg_control;
	socklen_t msg_controllen;
	int msg_flags;
} msghdr_t;


typedef struct cmsghdr {
	socklen_t cmsg_len;
	int cmsg_level, cmsg_type;
} cmsghdr_t;


#define SOCK_STREAM   2
#define SOCK_DGRAM   1
#define SOL_SOCKET   65535
#define SO_DEBUG   1
#define SO_REUSEADDR   0x4
#define SO_KEEPALIVE   0x8
#define SO_DONTROUTE   0x10
#define SO_BROADCAST   0x20
#define SO_LINGER   0x80
#define SO_OOBINLINE   0x100
#define SO_REUSEPORT   0x200
#define SO_SNDBUF   0x1001
#define SO_RCVBUF   0x1002
#define SO_SNDLOWAT   0x1003
#define SO_RCVLOWAT   0x1004
#define SO_RCVTIMEO   0x1006
#define SO_SNDTIMEO   0x1005
#define SO_ERROR   0x1007
#define SO_TYPE   0x1008
#define SO_ACCEPTCONN   0x1009
#define SO_PROTOCOL   0x1028
#define SO_DOMAIN   0x1029
#define SO_NO_CHECK   11
#define SO_PRIORITY   12
#define SO_BSDCOMPAT   14
#define SO_PASSCRED   17
#define SO_PEERCRED   18
#define SO_SNDBUFFORCE   31
#define SO_RCVBUFFORCE   33
#define SOCK_NONBLOCK   0200
#define SOCK_CLOEXEC   02000000


#elif defined(POWERPC)


typedef struct msghdr {
	void* msg_name;
	socklen_t msg_namelen;
	struct iovec* msg_iov;
	int msg_iovlen;
	void* msg_control;
	socklen_t msg_controllen;
	int msg_flags;
} msghdr_t;


typedef struct cmsghdr {
	socklen_t cmsg_len;
	int cmsg_level, cmsg_type;
} cmsghdr_t;


#define SO_DEBUG   1
#define SO_REUSEADDR   2
#define SO_TYPE   3
#define SO_ERROR   4
#define SO_DONTROUTE   5
#define SO_BROADCAST   6
#define SO_SNDBUF   7
#define SO_RCVBUF   8
#define SO_KEEPALIVE   9
#define SO_OOBINLINE   10
#define SO_NO_CHECK   11
#define SO_PRIORITY   12
#define SO_LINGER   13
#define SO_BSDCOMPAT   14
#define SO_REUSEPORT   15
#define SO_RCVLOWAT   16
#define SO_SNDLOWAT   17
#define SO_RCVTIMEO   18
#define SO_SNDTIMEO   19
#define SO_PASSCRED   20
#define SO_PEERCRED   21
#define SO_ACCEPTCONN   30
#define SO_SNDBUFFORCE   32
#define SO_RCVBUFFORCE   33
#define SO_PROTOCOL   38
#define SO_DOMAIN   39


#else


typedef struct msghdr {
	void* msg_name;
	socklen_t msg_namelen;
	struct iovec* msg_iov;
	int msg_iovlen;
	void* msg_control;
	socklen_t msg_controllen;
	int msg_flags;
} msghdr_t;


typedef struct cmsghdr {
	socklen_t cmsg_len;
	int cmsg_level, cmsg_type;
} cmsghdr_t;


#endif  // ARCH


typedef struct mmsghdr {
	struct msghdr msg_hdr;
	unsigned int msg_len;
} mmsghdr_t;


#define CMSG_ALIGN(len)   (((len) + SIZEOF_SIZE_T - 1) & (size_t)(~(SIZEOF_SIZE_T - 1)))
#define CMSG_SPACE(len)   (CMSG_ALIGN(len) + CMSG_ALIGN(sizeof(struct cmsghdr)))
#define CMSG_LEN(len)   (CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
#define __CMSG_LEN(cmsg)   (((cmsg)->cmsg_len + SIZEOF_LONG - 1) & (~(long)(SIZEOF_LONG - 1)))
#define CMSG_NEXT(cmsg)   ((unsigned char*)(cmsg) + __CMSG_LEN(cmsg))
#define __CMSG_NEXT(cmsg)   CMSG_NEXT((cmsg))
#define MHDR_END(mhdr)   ((unsigned char*)(mhdr)->msg_control + (mhdr)->msg_controllen)
#define __MHDR_END(cmsg)   MHDR_END((cmsg))
#define CMSG_DATA(cmsg)   ((unsigned char*)(((struct cmsghdr*)(cmsg)) + 1))
#define __CMSG_DATA(cmsg)   CMSG_DATA((cmsg))
#define CMSG_NXTHDR(mhdr, cmsg)   ((cmsg)->cmsg_len < sizeof(struct cmsghdr) ? (struct cmsghdr*)0 : (__CMSG_NEXT(cmsg) + sizeof(struct cmsghdr) >= __MHDR_END(mhdr) ? (struct cmsghdr*)0 : ((struct cmsghdr*)__CMSG_NEXT(cmsg))))
#define CMSG_FIRSTHDR(mhdr)   ((size_t)(mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? (struct cmsghdr*)(mhdr)->msg_control : (struct cmsghdr*)0)
/** Returns a duplicate of ADDR->sun_path with LEN limitation; This should to be used whenever reading a unix socket address, to cope with sun_path possibly not including a trailing \0.  */
#define _hurd_sun_path_dupa(addr, len)   strndupa((addr)->sun_path, (len) - offsetof(struct sockaddr_un, sun_path))


LIB_FUNC ssize_t sendmsg(int fd, const struct msghdr* msg, int flags) {
#   if (LONG_MAX > INT_MAX)
	struct msghdr h;
	struct cmsghdr chbuf[(1024 / sizeof(struct cmsghdr)) + 1], *c;
	if (msg) {
		h = *msg;
		h.__pad1 = 0;
		h.__pad2 = 0;
		msg = &h;
		if (h.msg_controllen) {
			if (h.msg_controllen > 1024) {
				errno = ENOMEM;
				return -1;
			}
			memcpy_no_output(chbuf, h.msg_control, h.msg_controllen);
			h.msg_control = chbuf;
			for (c = CMSG_FIRSTHDR(&h); c; c = CMSG_NXTHDR(&h, c)) { c->__pad1 = 0; }
		}
	}
#   endif
	return (ssize_t)syscall(SYS_sendmsg, fd, (long)&msg, flags, 0, 0, 0);
}


LIB_FUNC int sendmmsg(int fd, struct mmsghdr* msgvec, unsigned int vlen, unsigned int flags) {
#   if (LONG_MAX > INT_MAX)
	if (vlen > IOV_MAX) { vlen = IOV_MAX; }
	else if (!vlen) { return 0; }
	register int i;
	for (i = 0; i < (int)vlen; i++) {
		register ssize_t r = sendmsg(fd, &msgvec[i].msg_hdr, (int)flags);
		if (r < 0) { return (i ? i : -1); }
		msgvec[i].msg_len = (unsigned int)r;
	}
	return (i ? i : -1);
#   else
	return (int)syscall(SYS_sendmmsg, fd, (long)&msgvec, vlen, flags);
#   endif
}


LIB_FUNC int recvmmsg(int fd, struct mmsghdr* msgvec, unsigned int vlen, unsigned int flags, struct timespec* timeout) {
#   if (LONG_MAX > INT_MAX)
	struct mmsghdr* mh = msgvec;
	register unsigned int i;
	for (i = vlen; i; i--, mh++) {
		mh->msg_hdr.__pad1 = 0;
		mh->msg_hdr.__pad2 = 0;
	}
#   endif
	return (int)syscall(SYS_recvmmsg, fd, (long)&msgvec, vlen, flags, (long)&timeout);
}


LIB_FUNC ssize_t recvmsg(int fd, struct msghdr* msg, int flags) {
#   if (LONG_MAX > INT_MAX)
	struct msghdr h, *orig = msg;
	if (msg) {
		h = *msg;
		h.__pad1 = 0;
		h.__pad2 = 0;
		msg = &h;
	}
#   endif
	ssize_t r = (ssize_t)syscall(SYS_recvmsg, fd, (long)&msg, flags, 0, 0, 0);
#   if (LONG_MAX > INT_MAX)
	if (orig) { *orig = h; }
#   endif
	return r;
}


LIB_FUNC int socket(const int domain, const int type, const int protocol) {
	int s = (int)syscall(SYS_socket, domain, type, protocol, 0, 0, 0);
	if (s < 0 && (errno == EINVAL || errno == EPROTONOSUPPORT) && (type & (SOCK_CLOEXEC|SOCK_NONBLOCK))) {
		s = (int)syscall(SYS_socket, domain, (long)(type & (~(SOCK_CLOEXEC | SOCK_NONBLOCK))), protocol, 0, 0, 0);
		if (s < 0) { return s; }
		else if (type & SOCK_CLOEXEC) { syscall(SYS_fcntl, s, F_SETFD, FD_CLOEXEC); }
		if (type & SOCK_NONBLOCK) { syscall(SYS_fcntl, s, F_SETFL, O_NONBLOCK); }
	}
	return s;
}


LIB_FUNC int socketpair(int domain, int type, int protocol, int fd[2]) {
	int r = (int)syscall(SYS_socketpair, domain, type, protocol, fd, 0, 0);
	if (r < 0 && (errno == EINVAL || errno == EPROTONOSUPPORT) && (type & (SOCK_CLOEXEC | SOCK_NONBLOCK))) {
		r = (int)syscall(SYS_socketpair, domain, (type & (~(SOCK_CLOEXEC | SOCK_NONBLOCK))), protocol, fd, 0, 0);
		if (r < 0) { return r; }
		else if (type & SOCK_CLOEXEC) {
			__syscall(SYS_fcntl, fd[0], F_SETFD, FD_CLOEXEC);
			__syscall(SYS_fcntl, fd[1], F_SETFD, FD_CLOEXEC);
		}
		if (type & SOCK_NONBLOCK) {
			__syscall(SYS_fcntl, fd[0], F_SETFL, O_NONBLOCK);
			__syscall(SYS_fcntl, fd[1], F_SETFL, O_NONBLOCK);
		}
	}
	return r;
}


LIB_FUNC int shutdown(int fd, int how) {
	return (int)syscall(SYS_shutdown, fd, how, 0, 0, 0, 0);
}


LIB_FUNC int bind(int fd, const struct sockaddr* addr, socklen_t len) {
	return (int)syscall(SYS_bind, fd, (long)&addr, len, 0, 0, 0);
}


LIB_FUNC int connect(int fd, const struct sockaddr* addr, socklen_t len) {
	return (int)syscall(SYS_connect, fd, (long)&addr, (long)len, 0, 0, 0);
}


LIB_FUNC int listen(int fd, int backlog) {
	return (int)syscall(SYS_listen, fd, backlog, 0, 0, 0, 0);
}


LIB_FUNC int accept(int fd, struct sockaddr* restrict addr, socklen_t* restrict len) {
	return (int)syscall(SYS_accept, fd, (long)&addr, (long)&len, 0, 0, 0);
}


LIB_FUNC int accept4(int fd, struct sockaddr* restrict addr, socklen_t* restrict len, int flg) {
	if (!flg) { return accept(fd, addr, len); }
	register int ret = (int)syscall(SYS_accept4, fd, (long)&addr, (long)&len, flg, 0, 0);
	if (ret >= 0 || (errno != ENOSYS && errno != EINVAL)) { return ret; }
	ret = (int)accept(fd, addr, len);
	if (ret < 0) { return ret; }
	if (flg & SOCK_CLOEXEC) { __syscall(SYS_fcntl, ret, F_SETFD, FD_CLOEXEC); }
	else if (flg & SOCK_NONBLOCK) { __syscall(SYS_fcntl, ret, F_SETFL, O_NONBLOCK); }
	return ret;
}


LIB_FUNC int getsockname(int fd, struct sockaddr* restrict addr, socklen_t* restrict len) {
	return (int)syscall(SYS_getsockname, fd, (long)&addr, (long)&len, 0, 0, 0);
}
#define roken_getsockname(fd, addr, len)   getsockname((fd) , (addr), (len))


LIB_FUNC int getpeername(int fd, struct sockaddr* restrict addr, socklen_t* restrict len) {
	return (int)syscall(SYS_getpeername, fd, (long)&addr, (long)&len, 0, 0, 0);
}


LIB_FUNC int getsockopt(int fd, int level, int optname, void* restrict optval, socklen_t* restrict optlen) {
	return (int)syscall(SYS_getsockopt, fd, level, optname, (long)&optval, (long)&optlen, 0);
}


LIB_FUNC ssize_t sendto(int fd, const void* buf, size_t len, int flags, const struct sockaddr* addr, socklen_t alen) {
	return (ssize_t)syscall(SYS_sendto, fd, (long)&buf, len, flags, (long)&addr, alen);
}


LIB_FUNC ssize_t send(int fd, const void* buf, size_t len, int flags) {
	return (ssize_t)sendto(fd, buf, len, flags, 0, 0);
}


LIB_FUNC ssize_t recvfrom(int fd, void* restrict buf, size_t len, int flags, struct sockaddr* restrict addr, socklen_t* restrict alen) {
	return (ssize_t)syscall(SYS_recvfrom, fd, (long)&buf, len, flags, (long)&addr, (long)&alen);
}
#define _recvfrom(fd, buf, len, flags, addr, alen)   recvfrom((fd), (buf), (len), (flags), (addr), (alen))
#define __recvfrom(fd, buf, len, flags, addr, alen)   recvfrom((fd), (buf), (len), (flags), (addr), (alen))


LIB_FUNC ssize_t recv(int fd, void* buf, size_t len, int flags) {
	return (ssize_t)recvfrom(fd, buf, len, flags, 0, 0);
}
#define _recv(fd, buf, len, flags)   recv((fd), (buf), (len), (flags))
#define __recv(fd, buf, len, flags)   recv((fd), (buf), (len), (flags))


LIB_FUNC int setsockopt(int fd, int level, int optname, const void* optval, socklen_t optlen) {
	return (int)syscall(SYS_setsockopt, fd, level, optname, (long)&optval, optlen, 0);
}


LIB_FUNC int sockatmark(const int s) {
	int ret;
	if (ioctl(s, SIOCATMARK, &ret) < 0) { return -1; }
	return ret;
}


#endif  // SYS_SOCKET_H


/* NETWORK INTERFACE TYPES */


#if (!(defined(NET_IF_TYPES_H) || defined(_NET_IF_TYPES_H) || defined(_NET_IF_TYPES_H_)))
/** Interface types for parsing media address headers; This list is derived from the SNMP list of ifTypes, currently documented in RFC1573; The list of assignments is maintained at http://www.iana.org/assignments/smi-numbers */
#define NET_IF_TYPES_H   (1)
#define _NET_IF_TYPES_H   (1)
#define _NET_IF_TYPES_H_   (1)


/** None of the following */
#define IFT_OTHER   1
/** Old-style arpanet imp */
#define IFT_1822   2
/** HDH arpanet imp */
#define IFT_HDH1822   3
/** x25 to imp */
#define IFT_X25DDN   4
/** PDN X25 interface (RFC877) */
#define IFT_X25   5
/** Ethernet CSMACD */
#define IFT_ETHER   6
/** CMSA CD */
#define IFT_ISO88023   7
/** Token Bus */
#define IFT_ISO88024   8
/** Token Ring */
#define IFT_ISO88025   9
/** MAN */
#define IFT_ISO88026   0xa
#define IFT_STARLAN   0xb
/** Proteon 10MBit ring */
#define IFT_P10   0xc
/** Proteon 80MBit ring */
#define IFT_P80   0xd
/** Hyperchannel */
#define IFT_HY   0xe
#define IFT_FDDI   0xf
#define IFT_LAPB   0x10
#define IFT_SDLC   0x11
#define IFT_T1   0x12
/** E1 - European T1 */
#define IFT_CEPT   0x13
#define IFT_ISDNBASIC   0x14
#define IFT_ISDNPRIMARY   0x15
/** Proprietary PTP serial */
#define IFT_PTPSERIAL   0x16
/** RFC 1331 */
#define IFT_PPP   0x17
/** Loopback */
#define IFT_LOOP   0x18
/** ISO over IP */
#define IFT_EON   0x19
/** Obsolete 3MB experimental ethernet */
#define IFT_XETHER   0x1a
/** XNS over IP */
#define IFT_NSIP   0x1b
/** IP over generic TTY */
#define IFT_SLIP   0x1c
/** Ultra Technologies */
#define IFT_ULTRA   0x1d
/** Generic T3 */
#define IFT_DS3   0x1e
/** SMDS */
#define IFT_SIP   0x1f
/** Frame Relay DTE only */
#define IFT_FRELAY   0x20
#define IFT_RS232   0x21
/** parallel-port */
#define IFT_PARA   0x22
#define IFT_ARCNET   0x23
#define IFT_ARCNETPLUS  0x24
/** ATM cells */
#define IFT_ATM   0x25
#define IFT_MIOX25   0x26
/** SONET or SDH */
#define IFT_SONET   0x27
#define IFT_X25PLE  0x28
#define IFT_ISO88022LLC   0x29
#define IFT_LOCALTALK   0x2a
#define IFT_SMDSDXI   0x2b
/** Frame Relay DCE */
#define IFT_FRELAYDCE   0x2c
#define IFT_V35   0x2d
#define IFT_HSSI   0x2e
#define IFT_HIPPI   0x2f
/** Generic Modem */
#define IFT_MODEM   0x30
/** AAL5 over ATM */
#define IFT_AAL5   0x31
#define IFT_SONETPATH   0x32
#define IFT_SONETVT   0x33
/** SMDS InterCarrier Interface */
#define IFT_SMDSICIP   0x34
/** Proprietary Virtual/internal */
#define IFT_PROPVIRTUAL 0x35
/** Proprietary Multiplexing */
#define IFT_PROPMUX   0x36
#define IFT_GIF   0x37
#define IFT_FAITH   0x38
#define IFT_STF   0x39
/** Layer 2 Virtual LAN using 802.1Q */
#define IFT_L2VLAN   0x87
/** IEEE802.3ad Link Aggregate */
#define IFT_IEEE8023ADLAG   0x88
/** IEEE1394 High Performance SerialBus */
#define IFT_IEEE1394   0x90
/** Transparent bridge interface */
#define IFT_BRIDGE   0xd1
/** Encapsulation */
#define IFT_ENC   0xf4
/** Packet filter logging */
#define IFT_PFLOG   0xf5
/** Packet filter state syncing */
#define IFT_PFSYNC   0xf6
/** Common Address Redundancy Protocol */
#define IFT_CARP   0xf8
/** Packet tap pseudo interface */
#define IFT_PKTAP   0xfe
/** Packet Data over Cellular */
#define IFT_CELLULAR   0xff
/** Deprecated; use IFT_CELLULAR */
#define IFT_PDP   IFT_CELLULAR


#endif  // NET_IF_TYPES_H


/* SOCKETS LOCAL INTERFACES (<net/if.h>) */


#if (!(defined(NET_IF_H) || defined(_NET_IF_H) || defined(_NET_IF_H_) || defined(NETLINK_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/net_if.h.html
#define NET_IF_H   (1)
#define _NET_IF_H   (1)
#define _NET_IF_H_   (1)
#define NETLINK_H   (1)
#define _NETLINK_H   (1)
#define _NETLINK_H_   (1)


#define IFADDRS_HASH_SIZE   64
#define IF_NAMESIZE   16
#define IFHWADDRLEN   6
#define IFNAMSIZ   IF_NAMESIZE
#define IFF_UP   1
#define IFF_BROADCAST   2
#define IFF_DEBUG   4
#define IFF_LOOPBACK   8
#define IFF_POINTOPOINT   0x10
#define IFF_NOTRAILERS   0x20
#define IFF_RUNNING   0x40
#define IFF_NOARP   0x80
#define IFF_PROMISC   0x100
#define IFF_ALLMULTI   0x200
#define IFF_MASTER   0x400
#define IFF_SLAVE   0x800
#define IFF_MULTICAST   0x1000
#define IFF_PORTSEL   0x2000
#define IFF_AUTOMEDIA   0x4000
#define IFF_DYNAMIC   0x8000
#define IFF_LOWER_UP   0x10000
#define IFF_DORMANT   0x20000
#define IFF_ECHO   0x40000
#define IFF_VOLATILE   (IFF_LOOPBACK | IFF_POINTOPOINT | IFF_BROADCAST | IFF_ECHO|IFF_MASTER | IFF_SLAVE | IFF_RUNNING | IFF_LOWER_UP | IFF_DORMANT)
#define NETLINK_ROUTE   0
#define NLM_F_REQUEST   1
#define NLM_F_MULTI   2
#define NLM_F_ACK   4
#define NLM_F_ROOT   0x100
#define NLM_F_MATCH   0x200
#define NLM_F_ATOMIC   0x400
#define NLM_F_DUMP   (NLM_F_ROOT | NLM_F_MATCH)
#define NLMSG_NOOP   1
#define NLMSG_ERROR   2
#define NLMSG_DONE   3
#define NLMSG_OVERRUN   4
#define IFLA_ADDRESS   1
#define IFLA_BROADCAST   2
#define IFLA_IFNAME   3
#define IFLA_STATS   7
#define IFA_ADDRESS   1
#define IFA_LOCAL   2
#define IFA_LABEL   3
#define IFA_BROADCAST   4
#define RTM_NEWLINK   16
#define RTM_GETLINK   18
#define RTM_GETADDR   22


typedef struct nlmsghdr {
	uint32_t nlmsg_len;
	uint16_t nlmsg_type, nlmsg_flags;
	uint32_t nlmsg_seq, nlmsg_pid;
} nlmsghdr_t;


typedef struct rtattr { unsigned short rta_len, rta_type; }   rtattr_t;
typedef struct rtgenmsg { unsigned char rtgen_family; }   rtgenmsg_t;


typedef struct ifinfomsg {
	unsigned char ifi_family, __ifi_pad;
	unsigned short ifi_type;
	int ifi_index;
	unsigned int ifi_flags, ifi_change;
} ifinfomsg_t;


typedef struct ifaddrmsg {
	uint8_t ifa_family, ifa_prefixlen, ifa_flags, ifa_scope;
	uint32_t ifa_index;
} ifaddrmsg_t;


typedef struct attr_packed ifnamemap {
	unsigned int hash_next, index;
	unsigned char namelen;
	char name[IFNAMSIZ];
} ifnamemap_t;


typedef struct attr_packed ifnameindexctx {
	unsigned int num, allocated, str_bytes;
	struct ifnamemap* list;
	unsigned int hash[IFADDRS_HASH_SIZE];
} ifnameindexctx_t;


typedef struct attr_packed if_nameindex {
	unsigned int if_index;
	char* if_name;
} if_nameindex_t;


typedef struct attr_packed ifmap {
	unsigned long mem_start, mem_end;
	unsigned short base_addr;
	unsigned char irq, dma, port;
} ifmap_t;


typedef struct ifreq {
	union ifr_ifrn_union { char ifrn_name[IFNAMSIZ]; } ifr_ifrn;
	union attr_packed ifr_ifru_union {
		struct sockaddr ifru_addr, ifru_dstaddr, ifru_broadaddr, ifru_netmask, ifru_hwaddr;
		short ifru_flags;
		int ifru_ivalue, ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[IFNAMSIZ], ifru_newname[IFNAMSIZ];
		void* ifru_data;
	} ifr_ifru;
} ifreq_t;
#define ifr_name   ifr_ifrn.ifrn_name
#define ifr_hwaddr   ifr_ifru.ifru_hwaddr
#define ifr_addr   ifr_ifru.ifru_addr
#define ifr_dstaddr   ifr_ifru.ifru_dstaddr
#define ifr_broadaddr   ifr_ifru.ifru_broadaddr
#define ifr_netmask   ifr_ifru.ifru_netmask
#define ifr_flags   ifr_ifru.ifru_flags
#define ifr_metric   ifr_ifru.ifru_ivalue
#define ifr_mtu   ifr_ifru.ifru_mtu
#define ifr_map   ifr_ifru.ifru_map
#define ifr_slave   ifr_ifru.ifru_slave
#define ifr_data   ifr_ifru.ifru_data
#define ifr_ifindex   ifr_ifru.ifru_ivalue
#define ifr_bandwidth   ifr_ifru.ifru_ivalue
#define ifr_qlen   ifr_ifru.ifru_ivalue
#define ifr_newname   ifr_ifru.ifru_newname
#define _IOT_ifreq   _IOT(_IOTS(char), IFNAMSIZ, _IOTS(char), 16, 0, 0)
#define _IOT_ifreq_short   _IOT(_IOTS(char), IFNAMSIZ, _IOTS(short), 1, 0, 0)
#define _IOT_ifreq_int   _IOT(_IOTS(char), IFNAMSIZ, _IOTS(int), 1, 0, 0)


typedef struct attr_packed ifconf {
	int ifc_len;
	union {
		void* ifcu_buf;
		struct ifreq* ifcu_req;
	} ifc_ifcu;
} ifconf_t;
#define ifc_buf   ifc_ifcu.ifcu_buf
#define ifc_req   ifc_ifcu.ifcu_req
#define _IOT_ifconf   _IOT(_IOTS(struct ifconf),1, 0, 0, 0, 0)


#define NETLINK_ALIGN(len)   ((uint32_t)((len) + 3) & (uint32_t)(~3))
#define NLMSG_DATA(nlh)   ((void*)((char*)(nlh) + sizeof(struct nlmsghdr)))
#define NLMSG_DATALEN(nlh)   ((nlh)->nlmsg_len - sizeof(struct nlmsghdr))
#define NLMSG_DATAEND(nlh)   ((char*)(nlh) + (nlh)->nlmsg_len)
#define NLMSG_NEXT(nlh)   (struct nlmsghdr*)((char*)(nlh) + NETLINK_ALIGN((nlh)->nlmsg_len))
#define NLMSG_OK(nlh, end)   ((size_t)((char*)(end) - (char*)(nlh)) >= sizeof(struct nlmsghdr))
#define RTA_DATA(rta)   ((void*)((char*)(rta) + sizeof(struct rtattr)))
#define RTA_DATALEN(rta)   ((rta)->rta_len - sizeof(struct rtattr))
#define RTA_DATAEND(rta)   ((char*)(rta) + (rta)->rta_len)
#define RTA_NEXT(rta)   (struct rtattr*)((char*)(rta) + NETLINK_ALIGN((rta)->rta_len))
#define RTA_OK(nlh, end)   ((size_t)((char*)(end) - (char*)(rta)) >= sizeof(struct rtattr))
#define NLMSG_RTA(nlh, len)   ((void*)((char*)(nlh) + sizeof(struct nlmsghdr) + NETLINK_ALIGN(len)))
#define NLMSG_RTAOK(rta, nlh)   RTA_OK(rta, NLMSG_DATAEND(nlh))


LIB_FUNC void if_freenameindex(struct if_nameindex* idx) {
	free(idx);
}


LIB_FUNC unsigned int if_nametoindex(const char* name) {
	struct ifreq ifr;
	int fd;
	if ((fd = socket(AF_UNIX, (SOCK_DGRAM | SOCK_CLOEXEC), 0)) < 0) { return 0; }
	strncpy_no_output(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	const int r = ioctl(fd, SIOCGIFINDEX, &ifr);
	__syscall(SYS_close, fd);
	return (unsigned int)(r < 0 ? 0 : ifr.ifr_ifindex);
}


LIB_FUNC char* if_indextoname(const unsigned int index, char* name) {
	struct ifreq ifr;
	int fd;
	if ((fd = socket(AF_UNIX, (SOCK_DGRAM | SOCK_CLOEXEC), 0)) < 0) { return 0; }
	ifr.ifr_ifindex = (int)index;
	const int r = ioctl(fd, SIOCGIFNAME, &ifr);
	__syscall(SYS_close, fd);
	return (r < 0 ? 0 : strncpy(name, ifr.ifr_name, IF_NAMESIZE));
}


LIB_FUNC int __netlink_enumerate(int fd, unsigned int seq, int type, int af, int (*cb)(void* _ctx, struct nlmsghdr* h), void* _ctx) {
	struct nlmsghdr* h;
	union {
		uint8_t buf[8192];
		struct attr_packed {
			struct nlmsghdr nlh;
			struct rtgenmsg g;
		} req;
		struct nlmsghdr reply;
	} u;
	int r, ret;
	memset_no_output(&u.req, 0, sizeof(u.req));
	u.req.nlh.nlmsg_len = sizeof(u.req);
	u.req.nlh.nlmsg_type = (uint16_t)type;
	u.req.nlh.nlmsg_flags = (NLM_F_DUMP | NLM_F_REQUEST);
	u.req.nlh.nlmsg_seq = seq;
	u.req.g.rtgen_family = (unsigned char)af;
	r = (int)send(fd, &u.req, sizeof(u.req), 0);
	if (r < 0) { return r; }
	while (1) {
		r = (int)recv(fd, u.buf, sizeof(u.buf), MSG_DONTWAIT);
		if (r <= 0) { return -1; }
		for (h = &u.reply; NLMSG_OK(h, (void*)&u.buf[r]); h = NLMSG_NEXT(h)) {
			if (h->nlmsg_type == NLMSG_DONE) { return 0; }
			else if (h->nlmsg_type == NLMSG_ERROR) { return -1; }
			ret = cb(_ctx, h);
			if (ret) { return ret; }
		}
	}
}
#define netlink_enumerate(fd, seq, type, af, cb, _ctx)   __netlink_enumerate((fd), (seq), (type), (af), (cb), (_ctx))


LIB_FUNC int __rtnetlink_enumerate(int link_af, int addr_af, int (*cb)(void* _ctx, struct nlmsghdr* h), void* _ctx) {
	int fd, r;
	fd = socket(PF_NETLINK, (SOCK_RAW | SOCK_CLOEXEC), NETLINK_ROUTE);
	if (fd < 0) { return -1; }
	r = __netlink_enumerate(fd, 1, RTM_GETLINK, link_af, cb, _ctx);
	if (!r) { r = __netlink_enumerate(fd, 2, RTM_GETADDR, addr_af, cb, _ctx); }
	__syscall(SYS_close, fd);
	return r;
}
#define rtnetlink_enumerate(link_af, addr_af, cb, _ctx)   __rtnetlink_enumerate((link_af), (addr_af), (cb), (_ctx))


LIB_FUNC int netlink_msg_to_nameindex(void* pctx, struct nlmsghdr* h) {
	struct ifnameindexctx* _ctx = pctx;
	struct ifnamemap* map;
	struct rtattr* rta;
	unsigned int i;
	int index, type, namelen, bucket;
	if (h->nlmsg_type == RTM_NEWLINK) {
		struct ifinfomsg* ifi = NLMSG_DATA(h);
		index = ifi->ifi_index;
		type = IFLA_IFNAME;
		rta = NLMSG_RTA(h, sizeof(*ifi));
	} else {
		struct ifaddrmsg* ifa = NLMSG_DATA(h);
		index = (int)ifa->ifa_index;
		type = IFA_LABEL;
		rta = NLMSG_RTA(h, sizeof(*ifa));
	}
	for (; NLMSG_RTAOK(rta, h); rta = RTA_NEXT(rta)) {
		if (rta->rta_type != type) { continue; }
		namelen = (int)(RTA_DATALEN(rta) - 1);
		if (namelen > IFNAMSIZ) { return 0; }
		bucket = index % IFADDRS_HASH_SIZE;
		i = _ctx->hash[bucket];
		while (i) {
			map = &_ctx->list[i - 1];
			if ((int)map->index == index && map->namelen == namelen && memcmp(map->name, RTA_DATA(rta), (size_t)namelen) == 0) { return 0; }
			i = map->hash_next;
		}
		if (_ctx->num >= _ctx->allocated) {
			const size_t a = (size_t)(_ctx->allocated ? (_ctx->allocated * 2 + 1) : 8);
			if (a > SIZE_MAX / sizeof(*map)) { return -1; }
			map = realloc(_ctx->list, a * sizeof(*map));
			if (!map) { return -1; }
			_ctx->list = map;
			_ctx->allocated = (unsigned int)a;
		}
		map = &_ctx->list[_ctx->num];
		map->index = (unsigned int)index;
		map->namelen = (unsigned char)namelen;
		memcpy_no_output(map->name, RTA_DATA(rta), (size_t)namelen);
		_ctx->str_bytes += (unsigned int)(namelen + 1);
		_ctx->num++;
		map->hash_next = _ctx->hash[bucket];
		_ctx->hash[bucket] = _ctx->num;
		return 0;
	}
	return 0;
}


LIB_FUNC struct if_nameindex* if_nameindex(void) {
	struct ifnameindexctx _ctx, *ctx2 = &_ctx;
	struct if_nameindex *ifs = 0, *d;
	struct ifnamemap* s;
	char* p;
	int i, cs;
	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
	memset_no_output(ctx2, 0, sizeof(*ctx2));
	if (__rtnetlink_enumerate(AF_UNSPEC, AF_INET, netlink_msg_to_nameindex, ctx2) < 0) {
		pthread_setcancelstate(cs, 0);
		free(ctx2->list);
		errno = ENOBUFS;
		return ifs;
	}
	ifs = malloc(sizeof(struct if_nameindex[ctx2->num + 1]) + ctx2->str_bytes);
	if (!ifs) {
		pthread_setcancelstate(cs, 0);
		free(ctx2->list);
		errno = ENOBUFS;
		return ifs;
	}
	p = (char*)(ifs + ctx2->num + 1);
	for (i = (int)ctx2->num, d = ifs, s = ctx2->list; i; i--, s++, d++) {
		d->if_index = s->index;
		d->if_name = p;
		memcpy_no_output(p, s->name, s->namelen);
		p += s->namelen;
		*p++ = 0;
	}
	d->if_index = 0;
	d->if_name = 0;
	pthread_setcancelstate(cs, 0);
	free(ctx2->list);
	errno = ENOBUFS;
	return ifs;
}


#endif  // NET_IF_H


/* VECTOR I/O OPERATIONS (<sys/uio.h>) */


#if ((!(defined(_SYS_UIO_H) || defined(_SYS_UIO_H_))) && defined(OSLINUX))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_uio.h.html
#define SYS_UIO_H   (1)
#define _SYS_UIO_H   (1)
#define _SYS_UIO_H_   (1)


#define UIO_MAXIOV   (1024)


LIB_FUNC ssize_t readv(int fd, const struct iovec* iov, const int count) {
	return (ssize_t)syscall(SYS_readv, fd, (long)&iov, count);
}
#define _readv(fd, iov, count)   readv((fd), (iov), (count))
#define __readv(fd, iov, count)   readv((fd), (iov), (count))


LIB_FUNC ssize_t preadv(int fd, const struct iovec* iov, const int count, const off_t ofs) {
	return (ssize_t)syscall(SYS_preadv, fd, (long)&iov, count, (long)(ofs), (long)(ofs >> 32));
}


LIB_FUNC ssize_t process_vm_readv(pid_t pid, const struct iovec* lvec, unsigned long liovcnt, const struct iovec* rvec, unsigned long riovcnt, unsigned long flags) {
	return (ssize_t)syscall(SYS_process_vm_readv, pid, (long)&lvec, liovcnt, (long)&rvec, riovcnt, flags);
}


LIB_FUNC ssize_t writev(int fd, const struct iovec* iov, const int count) {
	return (ssize_t)syscall(SYS_writev, fd, (long)&iov, count);
}


LIB_FUNC ssize_t pwritev(int fd, const struct iovec* iov, const int count, const off_t ofs) {
	return (ssize_t)syscall(SYS_pwritev, fd, (long)&iov, count, (long)(ofs), (long)(ofs >> 32));
}


LIB_FUNC ssize_t process_vm_writev(pid_t pid, const struct iovec* lvec, unsigned long liovcnt, const struct iovec* rvec, unsigned long riovcnt, unsigned long flags) {
	return (ssize_t)syscall(SYS_process_vm_writev, pid, (long)&lvec, liovcnt, (long)&rvec, riovcnt, flags);
}


#ifdef _LARGEFILE64_SOURCE
#   define preadv64(fd, iov, count, ofs)   preadv((fd), (iov), (count), (ofs))
#   define pwritev64(fd, iov, count, ofs)   pwritev((fd), (iov), (count), (ofs))
#endif


#endif  // SYS_UIO_H


/* STRINGLIST (<bsd/stringlist.h>) */


#if (!(defined(_STRINGLIST_H) || defined(_STRINGLIST_H_)))
#define _STRINGLIST_H   (1)
#define _STRINGLIST_H_   (1)


#define _SL_CHUNKSIZE   20


/** Simple string list */
typedef struct _stringlist {
	char** sl_str;
	size_t sl_max, sl_cur;
} StringList;


/** Initialize a string list */
LIB_FUNC StringList* sl_init(void) {
	StringList* sl;
	sl = malloc(sizeof(StringList));
	if (sl == NULL) { err(1, "Invalid/NULL stringlist"); }
	sl->sl_cur = 0;
	sl->sl_max = _SL_CHUNKSIZE;
	sl->sl_str = malloc(sl->sl_max * SIZEOF_POINTER);
	if (sl->sl_str == NULL) { err(1, "Invalid/NULL stringlist"); }
	return sl;
}


/** Add an item to the string list */
LIB_FUNC int sl_add(StringList* sl, char* name) {
	if (sl->sl_cur == sl->sl_max - 1) {
		char** _string;
		sl->sl_max += _SL_CHUNKSIZE;
		_string = realloc(sl->sl_str, (size_t)(sl->sl_max * SIZEOF_POINTER));
		if (_string == NULL) { return -1; }
		sl->sl_str = _string;
	}
	sl->sl_str[sl->sl_cur++] = name;
	return 0;
}


/** Free a stringlist */
LIB_FUNC void sl_free(StringList* sl, const int all) {
	if (sl == NULL) { return; }
	else if (sl->sl_str) {
		register size_t i;
		if (all) { for (i = 0; i < sl->sl_cur; i++) { free(sl->sl_str[i]); } }
		free(sl->sl_str);
	}
	free(sl);
}


/** Find a name in the string list */
LIB_FUNC char* sl_find(StringList* sl, char* restrict name) {
	register size_t i;
	for (i = 0; i < sl->sl_cur; i++) {
		if (strcmp(sl->sl_str[i], name) == 0) { return sl->sl_str[i]; }
	}
	return NULL;
}


#endif  // STRINGLIST_H


/* GETOPT (<getopt.h>) */


#if (!(defined(GETOPT_H) || defined(_GETOPT_H) || defined(_GETOPT_H_) || defined(_GETOPT)))
#define GETOPT_H   (1)
#define _GETOPT_H   (1)
#define _GETOPT_H_   (1)
#define _GETOPT   (1)
#define _OPTRESET   (1)


#define no_argument   (0)
#define required_argument   (1)
#define optional_argument   (2)
#define BADCH   (int)'?'
#define BADARG   (int)':'
#define EMSG   (char*)NULL


typedef struct attr_packed option {
	const char* name;  // Name of long option
	int has_arg;
	int* flag;  // If not NULL, set *flag to val when option found
	int val;  // If flag not NULL, value to set *flag to; else return value
} option_t;


// getopt variables
/** Callers store zero here to inhibit the error message `getopt` prints for unrecognized options */
static UNUSED int opterr = 1;
/** Index into parent argv vector; On entry to `getopt`, zero means this is the first call */
static UNUSED int optind = 1;
/** Character checked for validity; Set to an option character which was unrecognized */
extern UNUSED int optopt;
/** Reset getopt */
extern UNUSED int optreset;
/** Argument associated with getopt option; For communication from `getopt` to the caller */
extern UNUSED char* optarg;


/** Parse argc/argv argument vector */
static int getopt(const int nargc, char* const nargv[], const char* ostr) {
	static char* getopt_place = EMSG;  // option letter processing
	char* oli;  // option letter list index
	if (optreset || *getopt_place == 0) {  // update scanning pointer
		optreset = 0;
		getopt_place = nargv[optind];
		if (optind >= nargc || *getopt_place++ != '-') {  // Argument is absent or is not an option
			getopt_place = EMSG;
			return -1;
		}
		optopt = *getopt_place++;
		if (optopt == '-' && *getopt_place == 0) {  // "--" => end of options
			++optind;
			getopt_place = EMSG;
			return -1;
		} else if (PREDICT_UNLIKELY(optopt == 0)) {  // Solitary '-'
			getopt_place = EMSG;
			if (strchr(ostr, '-') == (char*)NULL) { return -1; }
			optopt = '-';
		}
	} else { optopt = *getopt_place++; }  // See if option letter is one the caller wanted...
	if (optopt == ':' || (oli = strchr2(ostr, optopt)) == (char*)NULL) {
		if (*getopt_place == 0) { ++optind; }
		if (opterr && *ostr != ':') { (void)fprintf(stderr, "Illegal option -- %c\n", optopt); }
		return BADCH;
	}
	// Does this option need an argument?
	if (oli[1] != ':') {  // Does not need argument
		optarg = (char*)NULL;
		if (*getopt_place == 0) { ++optind; }
	} else {  // Option-argument is either the rest of this argument or the entire next argument */
		if (*getopt_place) { optarg = getopt_place; }
		else if (nargc > ++optind) { optarg = nargv[optind]; }
		else {  // Option-argument absent
#         ifdef __DARWIN_UNIX03
			++optind;  // Put optind past the last argument
			optarg = (char*)NULL;
#         endif  // __DARWIN_UNIX03
			getopt_place = EMSG;
			if (*ostr == ':') { return BADARG; }
			else if (PREDICT_LIKELY(opterr)) { (void)fprintf(stderr, "Option requires an argument -- %c\n", optopt); }
			return BADCH;
		}
		getopt_place = EMSG;
		++optind;
	}
	return optopt;  // Return option letter
}


/** Parse argc/argv argument vector with long options */
static int __getopt_long(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx, int longonly) {
	if (optind >= argc || !argv[optind] || argv[optind][0] != '-') { return -1; }
	else if (PREDICT_LIKELY((longonly && argv[optind][1]) || ((argv[optind][1] == '-') && argv[optind][2]))) {
		register int i;
		for (i = 0x0; longopts[i].name; i++) {
			const char* name = longopts[i].name;
			char* opt = (argv[optind] + 2);
			while (*name && *name++ == *opt++);
			if (*name || (*opt && *opt != '=')) { continue; }
			else if (*opt == '=') {
				if (!longopts[i].has_arg) { continue; }
				optarg = opt+1;
			} else {
				if (longopts[i].has_arg == required_argument) {
					if (!(optarg = argv[++optind])) { return ':'; }
				} else { optarg = (char*)NULL; }
			}
			optind++;
			if (idx) { *idx = i; }
			if (longopts[i].flag) {
				*longopts[i].flag = longopts[i].val;
				return 0;
			}
			return longopts[i].val;
		}
		if (argv[optind][1] == '-') { optind++; return '?'; }
	}
	return getopt(argc, argv, optstring);
}


/** Parse argc/argv argument vector with long options */
LIB_FUNC int getopt_long(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx) {
	return __getopt_long(argc, argv, optstring, longopts, idx, 0);
}


/** Parse argc/argv argument vector with long options */
LIB_FUNC int getopt_long_only(const int argc, char* const argv[], const char* optstring, const struct option* longopts, int* idx) {
	return __getopt_long(argc, argv, optstring, longopts, idx, 1);
}


#endif  // GETOPT_H


/* SOFTWARE FLOATING-POINT EMULATION (<soft-fp.h> & <softfloat-macros.h>) */


#if (!(defined(SOFT_FP_H_) || defined(SOFT_FP_H_) || defined(SOFTFLOAT_H) || defined(_SOFTFLOAT_H_)))
#define SOFT_FP_H   (1)
#define SOFT_FP_H_   (1)
#define SOFT_FP_OP_COMMON_H   (1)
#define SOFTFLOAT_H   (1)
#define _SOFTFLOAT_H_   (1)


#if defined(ARCHPOWERPC32)


/** Equivalent to fegetenv, but returns an unsigned int instead of taking a pointer */
LIB_FUNC unsigned int fegetenv_register(void) {
	unsigned int fscr;
	asm volatile ("mfspefscr %0;" : "=r"(fscr));
	return fscr;
}


/** Equivalent to fesetenv, but takes an unsigned int instead of a pointer */
LIB_FUNC void fesetenv_register(unsigned int fscr) {
	asm volatile ("mtspefscr %0;" : : "r"(fscr));
}


#elif defined(POWERPC)


/** Equivalent to fegetenv, but returns a fenv_t instead of taking a pointer */
#define fegetenv_register()   __extension__ ({ fenv_t env; asm volatile ("mffs %0" : "=f"(env)); env; })
/** Equivalent to fesetenv, but takes a fenv_t instead of a pointer */
#define fesetenv_register(env)   do { double d = (env); if (GLRO(dl_hwcap) & PPC_FEATURE_HAS_DFP) { asm volatile (".machine push; " ".machine "power6"; " "mtfsf 0xff,%0,1,0; " ".machine pop" : : "f"(d)); } else { asm volatile ("mtfsf 0xff,%0" : : "f"(d)); } } while (0x0)
/** Sets the rounding mode to 'round to nearest', sets the processor into IEEE mode, and prevents exceptions from being raised for inexact results */
#define relax_fenv_state()   do { if (GLRO(dl_hwcap) & PPC_FEATURE_HAS_DFP) { asm (".machine push; .machine "power6"; " "mtfsfi 7,0,1; .machine pop"); } asm ("mtfsfi 7,0"); } while (0x0)


LIB_FUNC int __fesetround_inline (int round) {
	if ((unsigned int) round < 2) {
		asm volatile ("mtfsb0 30;");
		if ((unsigned int) round == 0) { asm volatile ("mtfsb0 31;"); }
		else { asm volatile ("mtfsb1 31;"); } }
	else {
		asm volatile ("mtfsb1 30;");
		if ((unsigned int)round == 2) { asm volatile ("mtfsb0 31;"); }
		else { asm volatile ("mtfsb1 31;"); }
	}
	return 0;
}


LIB_FUNC int fenv_reg_to_exceptions(unsigned long long l) {
	register int result = 0;
	if (l & (1 << (31 - FPSCR_XE))) { result |= FE_INEXACT; }
	if (l & (1 << (31 - FPSCR_ZE))) { result |= FE_DIVBYZERO; }
	if (l & (1 << (31 - FPSCR_UE))) { result |= FE_UNDERFLOW; }
	if (l & (1 << (31 - FPSCR_OE))) { result |= FE_OVERFLOW; }
	if (l & (1 << (31 - FPSCR_VE))) { result |= FE_INVALID; }
	return result;
}


#ifdef _ARCH_PWR6
/** Not supported in ISA 2.05; Provided for source compat only */
#   define FPSCR_NI   (29)
#endif

#define f_wash(x)   __extension__ ({ double d; asm volatile ("fmul %0, %1, %2;" : "=f"(d) : "f"(x), "f"((float)1.0F)); d; })
#define f_washf(x)   __extension__ ({ float f; asm volatile ("fmuls %0, %1, %2;" : "=f"(f) : "f"(x), "f"((float)1.0F)); f; })


#endif  // POWERPC32


#ifdef ALPHA  // SOFTWARE FLOATING-POINT


#define _FP_W_TYPE_SIZE   64
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)  do { R##_s = Y##_s;   _FP_FRAC_COPY_##wc(R, X);  R##_c = FP_CLS_NAN; } while (0x0)
#define FP_RND_NEAREST   FE_TONEAREST
#define FP_RND_ZERO   FE_TOWARDZERO
#define FP_RND_PINF   FE_UPWARD
#define FP_RND_MINF   FE_DOWNWARD
#define FP_ROUNDMODE   _round
#define FP_EX_INVALID   FE_INVALID
#define FP_EX_OVERFLOW   FE_OVERFLOW
#define FP_EX_UNDERFLOW   FE_UNDERFLOW
#define FP_EX_DIVZERO   FE_DIVBYZERO
#define FP_EX_INEXACT   FE_INEXACT
#define _FP_TININESS_AFTER_ROUNDING   1
#define FP_INIT_ROUNDMODE   do { if (PREDICT_UNLIKELY(_round == 4)) { unsigned long t; asm volatile ("excb;" "mf_fpcr %0;" : "=f"(t)); _round = (t >> FPCR_ROUND_SHIFT) & 3; } } while (0x0)
#define FP_HANDLE_EXCEPTIONS   do { if (PREDICT_UNLIKELY(_fex)) { __feraiseexcept(_fex); } } while (0x0)
#define FP_TRAPPING_EXCEPTIONS   ((__ieee_get_fp_control () & SWCR_ENABLE_MASK) << SWCR_ENABLE_SHIFT)


#elif defined(ARM64)


#define _FP_W_TYPE_SIZE   64
#define _FP_W_TYPE   unsigned long long
#define _FP_WS_TYPE   signed long long
#define _FP_I_TYPE   long long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) | _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs) { R##_s = _FP_NANSIGN_##fs; _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_DECL_EX   fpu_control_t _fcw
#define FP_ROUNDMODE   (_fcw & _FPU_FPCR_RM_MASK)
#define FP_RND_NEAREST   FE_TONEAREST
#define FP_RND_ZERO   FE_TOWARDZERO
#define FP_RND_PINF   FE_UPWARD
#define FP_RND_MINF   FE_DOWNWARD
#define FP_EX_INVALID   FE_INVALID
#define FP_EX_OVERFLOW   FE_OVERFLOW
#define FP_EX_UNDERFLOW   FE_UNDERFLOW
#define FP_EX_DIVZERO   FE_DIVBYZERO
#define FP_EX_INEXACT   FE_INEXACT
#define _FP_TININESS_AFTER_ROUNDING   0
#define FP_INIT_ROUNDMODE   do { _FPU_GETCW (_fcw); } while (0x0)
#define FP_HANDLE_EXCEPTIONS   do { const float fp_max = __FLT_MAX__; const float fp_min = __FLT_MIN__, const float fp_1e32 = 1.0e32F, fp_zero = 0.0F, fp_one = 1.0F; unsigned fpsr; if (_fex & FP_EX_INVALID) { asm volatile ("fdivts0, %s0, %s0;" : : "w"(fp_zero) : "s0"); asm volatile ("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_DIVZERO) { asm volatile ("fdivts0, %s0, %s1;" : : "w"(fp_one), "w"(fp_zero) : "s0"); asm volatile ("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_OVERFLOW) { asm volatile ("faddts0, %s0, %s1;" : : "w"(fp_max), "w"(fp_1e32) : "s0"); asm volatile ("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_UNDERFLOW) { asm volatile ("fmults0, %s0, %s0;" : : "w"(fp_min) : "s0"); asm volatile ("mrst%0, fpsr;" : "=r"(fpsr)); } if (_fex & FP_EX_INEXACT) { asm volatile ("fsubts0, %s0, %s1;" : : "w"(fp_max), "w"(fp_one) : "s0"); asm volatile ("mrst%0, fpsr;" : "=r"(fpsr)); } } while (0x0)
#define FP_TRAPPING_EXCEPTIONS   ((_fcw >> FE_EXCEPT_SHIFT) & FE_ALL_EXCEPT)


#elif defined(ARM)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   _FP_QNANBIT_S
#define _FP_NANFRAC_D   _FP_QNANBIT_D, 0
#define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0, 0, 0
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)  do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#elif defined(COLDFIRE)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s;  _FP_FRAC_COPY_##wc(R, Y);  } else { R##_s = X##_s;  _FP_FRAC_COPY_##wc(R, X); }  R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#elif defined(M68K)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#elif defined(MICROBLAZE)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#elif defined(MIPS64)


#define _FP_W_TYPE_SIZE   64
#define _FP_W_TYPE   unsigned long long
#define _FP_WS_TYPE   signed long long
#define _FP_I_TYPE   long long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_imm(_FP_WFRACBITS_S, R, X, Y)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#ifdef __mips_nan2008
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#else
#   define _FP_NANFRAC_S   (_FP_QNANBIT_S - 1)
#   define _FP_NANFRAC_D   (_FP_QNANBIT_D - 1)
#   define _FP_NANFRAC_Q   (_FP_QNANBIT_Q - 1), -1
#endif
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#ifdef __mips_nan2008
#   define _FP_QNANNEGATEDP   0
#else
#   define _FP_QNANNEGATEDP   1
#endif
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) | _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs) { R##_s = _FP_NANSIGN_##fs; _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_DECL_EX   fpu_control_t _fcw
#define FP_ROUNDMODE   (_fcw & 0x3)
#define FP_RND_NEAREST   FE_TONEAREST
#define FP_RND_ZERO   FE_TOWARDZERO
#define FP_RND_PINF   FE_UPWARD
#define FP_RND_MINF   FE_DOWNWARD
#define FP_EX_INVALID   FE_INVALID
#define FP_EX_OVERFLOW   FE_OVERFLOW
#define FP_EX_UNDERFLOW   FE_UNDERFLOW
#define FP_EX_DIVZERO   FE_DIVBYZERO
#define FP_EX_INEXACT   FE_INEXACT
#define _FP_TININESS_AFTER_ROUNDING   1
#ifdef __mips_hard_float
#   define FP_INIT_ROUNDMODE   do { _FPU_GETCW (_fcw); } while (0x0)
#   define FP_HANDLE_EXCEPTIONS   __extension__ ({ if (PREDICT_UNLIKELY(_fex)) { _FPU_SETCW (_fcw | _fex | (_fex << 10)); } })
#   define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 5) & 0x7c)
#else
#   define FP_INIT_ROUNDMODE   _fcw = FP_RND_NEAREST
#endif


#elif defined(MIPS32)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#ifdef __mips_nan2008
#   define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#   define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#   define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#else
#   define _FP_NANFRAC_S   (_FP_QNANBIT_S - 1)
#   define _FP_NANFRAC_D   (_FP_QNANBIT_D - 1), -1
#   define _FP_NANFRAC_Q   (_FP_QNANBIT_Q - 1), -1, -1, -1
#endif
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#ifdef __mips_nan2008
#   define _FP_QNANNEGATEDP   0
#else
#   define _FP_QNANNEGATEDP   1
#endif
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) | _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs) { R##_s = _FP_NANSIGN_##fs; _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define FP_EX_INVALID   (1 << 4)
#define FP_EX_DIVZERO   (1 << 3)
#define FP_EX_OVERFLOW   (1 << 2)
#define FP_EX_UNDERFLOW   (1 << 1)
#define FP_EX_INEXACT   (1 << 0)
#define _FP_TININESS_AFTER_ROUNDING   1


#elif defined(NIOS2)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#elif defined(POWERPC)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); }  R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING 0
#if (defined(__NO_FPRS__) && (!defined(_SOFT_FLOAT)))
#   define FP_EX_INEXACT   SPEFSCR_FINXS
#   define FP_EX_INVALID   SPEFSCR_FINVS
#   define FP_EX_DIVZERO   SPEFSCR_FDBZS
#   define FP_EX_UNDERFLOW   SPEFSCR_FUNFS
#   define FP_EX_OVERFLOW   SPEFSCR_FOVFS
#   define _FP_DECL_EX   int UNUSED _spefscr, UNUSED _ftrapex = 0
#   define FP_INIT_ROUNDMODE   do  { int _r; INTERNAL_SYSCALL_DECL(_err); _spefscr = fegetenv_register (); _r = INTERNAL_SYSCALL (prctl, _err, 2, PR_GET_FPEXC, &_ftrapex); if (INTERNAL_SYSCALL_ERROR_P(_r, _err)) { _ftrapex = 0; } } while (0x0)
#   define FP_INIT_EXCEPTIONS
#   define FP_HANDLE_EXCEPTIONS   __feraiseexcept_soft(_fex)
#   define FP_ROUNDMODE   (_spefscr & 0x3)
#   define FP_TRAPPING_EXCEPTIONS   (_ftrapex & PR_FP_EXC_UND ? FP_EX_UNDERFLOW : 0)
#else
#   define FP_EX_INVALID   (1 << (31 - 2))
#   define FP_EX_OVERFLOW   (1 << (31 - 3))
#   define FP_EX_UNDERFLOW   (1 << (31 - 4))
#   define FP_EX_DIVZERO   (1 << (31 - 5))
#   define FP_EX_INEXACT   (1 << (31 - 6))
#   define FP_HANDLE_EXCEPTIONS   __simulate_exceptions(_fex)
#   define FP_ROUNDMODE   __sim_round_mode_thread
#   define FP_TRAPPING_EXCEPTIONS   ((~__sim_disabled_exceptions_thread) & 0x3e000000)
#endif


#elif defined(SPARC64)


#define _FP_W_TYPE_SIZE   64
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
/** Helper macros for _FP_MUL_MEAT_2_120_240_double */
#define _FP_MUL_MEAT_SET_FE_TZ   do { static fpu_control_t _fetz = _FPU_RC_DOWN; _FPU_SETCW(_fetz); } while (0x0)
#ifndef _FP_MUL_MEAT_RESET_FE
#   define _FP_MUL_MEAT_RESET_FE   _FPU_SETCW(_fcw)
#endif
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_120_240_double(_FP_WFRACBITS_Q, R, X, Y, _FP_MUL_MEAT_SET_FE_TZ, _FP_MUL_MEAT_RESET_FE)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1)
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)) { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } else { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } R##_c = FP_CLS_NAN; } while (0x0)
#ifndef FP_ROUNDMODE
/** Obtain the current rounding mode */
#   define FP_ROUNDMODE   ((_fcw >> 30) & 0x3)
#endif
#define FP_EX_INVALID   (1 << 4)
#define FP_EX_OVERFLOW   (1 << 3)
#define FP_EX_UNDERFLOW   (1 << 2)
#define FP_EX_DIVZERO   (1 << 1)
#define FP_EX_INEXACT   (1 << 0)
#define _FP_TININESS_AFTER_ROUNDING   0
#define _FP_DECL_EX   fpu_control_t UNUSED _fcw = (FP_RND_NEAREST << 30)
#define FP_INIT_ROUNDMODE   do { _FPU_GETCW(_fcw); } while (0x0)
#define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 23) & 0x1f)
#define FP_INHIBIT_RESULTS   ((_fcw >> 23) & _fex)
#define FP_HANDLE_EXCEPTIONS   do { if (!_fex) { asm volatile ("fzero %%f62;" "faddd %%f62, %%f62, %%f62;" : : : "f62"); } else { __Qp_handle_exceptions (_fex); } } while (0x0)
#define QP_HANDLE_EXCEPTIONS(_a)   do { if ((_fcw >> 23) & _fex) { _a; } else { _fcw = (_fcw & ~0x1fL) | (_fex << 5) | _fex; _FPU_SETCW(_fcw); } } while (0x0)
#define QP_NO_EXCEPTIONS   asm ("fzero %%f62;" "faddd %%f62, %%f62, %%f62;" : : : "f62")
#define QP_CLOBBER   "memory", "f52", "f54", "f56", "f58", "f60", "f62"
#define QP_CLOBBER_CC   QP_CLOBBER , "cc"


#elif defined(SPARC)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_udiv(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define __FP_FRAC_ADD_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)   asm ("addcc %r7, %8, %2;" "addxcc %r5, %6, %1;" "addx %r3, %4, %0;" : "=r"((USItype)(r2)), "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc")
#define __FP_FRAC_SUB_3(r2, r1, r0, x2, x1, x0, y2, y1, y0)   asm ("subcc %r7, %8, %2;" "subxcc %r5, %6, %1;" "subx %r3, %4, %0;" : "=r"((USItype)(r2)), "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc")
#define __FP_FRAC_ADD_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0)   do { register USItype _t1 asm ("g1"), _t2 asm ("g2"); asm volatile ("addcc %r8, %9, %1;" "addxcc %r6, %7, %0;" "addxcc %r4, %5, %%g2;" "addx %r2, %3, %%g1;" : "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x3)), "rI"((USItype)(y3)), "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc", "g1", "g2"); asm volatile ("" : "=r"(_t1), "=r"(_t2)); r3 = _t1; r2 = _t2; } while (0x0)
#define __FP_FRAC_SUB_4(r3, r2, r1, r0, x3, x2, x1, x0, y3, y2, y1, y0)   do { register USItype _t1 asm ("g1"), _t2 asm ("g2"); asm volatile ("subcc %r8, %9, %1;" "subxcc %r6, %7, %0;" "subxcc %r4, %5, %%g2;" "subx %r2, %3, %%g1;" : "=&r"((USItype)(r1)), "=&r"((USItype)(r0)) : "%rJ"((USItype)(x3)), "rI"((USItype)(y3)), "%rJ"((USItype)(x2)), "rI"((USItype)(y2)), "%rJ"((USItype)(x1)), "rI"((USItype)(y1)), "%rJ"((USItype)(x0)), "rI"((USItype)(y0)) : "cc", "g1", "g2"); asm volatile ("" : "=r"(_t1), "=r"(_t2)); r3 = _t1; r2 = _t2; } while (0x0)
#define __FP_FRAC_DEC_3(x2, x1, x0, y2, y1, y0) __FP_FRAC_SUB_3(x2, x1, x0, x2, x1, x0, y2, y1, y0)
#define __FP_FRAC_DEC_4(x3, x2, x1, x0, y3, y2, y1, y0) __FP_FRAC_SUB_4(x3, x2, x1, x0, x3, x2, x1, x0, y3, y2, y1, y0)
#define __FP_FRAC_ADDI_4(x3, x2, x1, x0, i)   asm ("addcc %3, %4, %3;" "addxcc %2, %%g0, %2;" "addxcc %1, %%g0, %1;" "addx %0, %%g0, %0;" : "=&r"((USItype)(x3)), "=&r"((USItype)(x2)), "=&r"((USItype)(x1)), "=&r"((USItype)(x0)) : "rI"((USItype)(i)), "0"((USItype)(x3)), "1"((USItype)(x2)), "2"((USItype)(x1)), "3"((USItype)(x0)) : "cc")
#ifndef FP_ROUNDMODE
#   define FP_ROUNDMODE   ((_fcw >> 30) & 3)
#endif
#define FP_EX_INVALID   (0x10)  // 1 << 4
#define FP_EX_OVERFLOW   (8)
#define FP_EX_UNDERFLOW   (4)
#define FP_EX_DIVZERO   (2)
#define FP_EX_INEXACT   (1)
#define _FP_TININESS_AFTER_ROUNDING   0
#define _FP_DECL_EX fpu_control_t UNUSED _fcw = (FP_RND_NEAREST << 30)
#define FP_INIT_ROUNDMODE   do { _FPU_GETCW(_fcw); } while (0x0)
#define FP_TRAPPING_EXCEPTIONS   ((_fcw >> 23) & 0x1f)
#define FP_INHIBIT_RESULTS   ((_fcw >> 23) & _fex)
#define FP_HANDLE_EXCEPTIONS   do { if (!_fex) { extern unsigned long long ___Q_zero; asm volatile ("ldd [%0], %%f30;" "faddd %%f30, %%f30, %%f30;" : : "r"(&___Q_zero) : "f30"); } else { ___Q_simulate_exceptions (_fex); } } while (0x0)


#elif defined(SUPERH)


#define _FP_W_TYPE_SIZE   32
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#define _FP_NANFRAC_S   ((_FP_QNANBIT_S << 1) - 1)
#define _FP_NANFRAC_D   ((_FP_QNANBIT_D << 1) - 1), -1
#define _FP_NANFRAC_Q   ((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
#define _FP_NANSIGN_S   0
#define _FP_NANSIGN_D   0
#define _FP_NANSIGN_Q   0
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define FP_EX_INVALID   (1 << 6)
#define FP_EX_DIVZERO   (1 << 5)
#define FP_EX_OVERFLOW   (1 << 4)
#define FP_EX_UNDERFLOW   (1 << 3)
#define FP_EX_INEXACT   (1 << 2)
#define _FP_TININESS_AFTER_ROUNDING   1


#elif defined(TILE)


#define _FP_W_TYPE_SIZE   __WORDSIZE
#define _FP_W_TYPE   unsigned long
#define _FP_WS_TYPE   signed long
#define _FP_I_TYPE   long
#if (_FP_W_TYPE_SIZE == 64)
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S, R, X, Y)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_imm(_FP_WFRACBITS_S, R, X, Y)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_2_wide_3mul(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_imm(S, R, X, Y, _FP_DIV_HELP_imm)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_1_udiv_norm(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_2_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   _FP_QNANBIT_S
#   define _FP_NANFRAC_D   _FP_QNANBIT_D
#   define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0
#else  // _FP_W_TYPE_SIZE == 32
#   define _FP_MUL_MEAT_S(R, X, Y)   _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_D(R, X, Y)   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_Q(R, X, Y)   _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_S(R, X, Y)   _FP_MUL_MEAT_DW_1_wide(_FP_WFRACBITS_S, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_D(R, X, Y)   _FP_MUL_MEAT_DW_2_wide(_FP_WFRACBITS_D, R, X, Y, umul_ppmm)
#   define _FP_MUL_MEAT_DW_Q(R, X, Y)   _FP_MUL_MEAT_DW_4_wide(_FP_WFRACBITS_Q, R, X, Y, umul_ppmm)
#   define _FP_DIV_MEAT_S(R, X, Y)   _FP_DIV_MEAT_1_loop(S, R, X, Y)
#   define _FP_DIV_MEAT_D(R, X, Y)   _FP_DIV_MEAT_2_udiv(D, R, X, Y)
#   define _FP_DIV_MEAT_Q(R, X, Y)   _FP_DIV_MEAT_4_udiv(Q, R, X, Y)
#   define _FP_NANFRAC_S   _FP_QNANBIT_S
#   define _FP_NANFRAC_D   _FP_QNANBIT_D, 0
#   define _FP_NANFRAC_Q   _FP_QNANBIT_Q, 0, 0, 0
#endif
#define _FP_NANSIGN_S   1
#define _FP_NANSIGN_D   1
#define _FP_NANSIGN_Q   1
#define _FP_KEEPNANFRACP   1
#define _FP_QNANNEGATEDP   0
#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)   do { if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs) && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs)) { R##_s = Y##_s; _FP_FRAC_COPY_##wc(R, Y); } else { R##_s = X##_s; _FP_FRAC_COPY_##wc(R, X); } R##_c = FP_CLS_NAN; } while (0x0)
#define _FP_TININESS_AFTER_ROUNDING   0


#endif  // SOFTWARE FLOATING-POINT


#ifndef _FP_W_TYPE_SIZE
/** Size in bits of _FP_W_TYPE */
#   define _FP_W_TYPE_SIZE   W_TYPE_SIZE
#endif
#ifndef _FP_W_TYPE
/** An unsigned type, default type for operations (typically a "word"); On a 32-bit machine UWtype should usually be USItype; On a 64-bit machine, UWtype should typically be UDItype */
#   define _FP_W_TYPE   UWtype
#endif
#ifndef _FP_WS_TYPE
#   define _FP_WS_TYPE   Wtype
#endif
#ifndef _FP_I_TYPE
#   define _FP_I_TYPE   long long
#endif


#if (defined(__VFP_FP__) || defined(__ARMEB__) || defined(SUPERH) || defined(SUPERH64))
#   define FLOAT64_DEMANGLE(a)   (a)
#   define FLOAT64_MANGLE(a)   (a)
#else
#   define FLOAT64_DEMANGLE(a)   (((a) << 32) | ((a) >> 32))
#   define FLOAT64_MANGLE(a)   FLOAT64_DEMANGLE(a)
#endif
#define FP_CLS_NORMAL   0
#define FP_CLS_ZERO   1
#define FP_CLS_INF   2
#define FP_CLS_NAN   3
#define _FP_CLS_COMBINE(x, y)   (((x) << 2) | (y))
#ifndef CMPtype
#   define CMPtype   int
#endif
#define SI_BITS   (CHAR_BIT * (int)sizeof(SItype))
#define DI_BITS   (CHAR_BIT * (int)sizeof(DItype))
#define _FP_WORKBITS   3
#define _FP_WORK_LSB   ((_FP_W_TYPE)8)
#define _FP_WORK_ROUND   ((_FP_W_TYPE)4)
#define _FP_WORK_GUARD   ((_FP_W_TYPE)2)
#define _FP_WORK_STICKY   ((_FP_W_TYPE)1)
#ifndef FP_RND_NEAREST
#   define FP_RND_NEAREST   0
#   define FP_RND_ZERO   1
#   define FP_RND_PINF   2
#   define FP_RND_MINF   3
#endif
#ifndef FP_ROUNDMODE
#   define FP_ROUNDMODE   FP_RND_NEAREST
#endif
#ifndef FP_EX_INVALID
#   define FP_EX_INVALID   0
#endif
#ifndef FP_EX_OVERFLOW
#   define FP_EX_OVERFLOW   0
#endif
#ifndef FP_EX_UNDERFLOW
#   define FP_EX_UNDERFLOW   0
#endif
#ifndef FP_EX_DIVZERO
#   define FP_EX_DIVZERO   0
#endif
#ifndef FP_EX_INEXACT
#   define FP_EX_INEXACT   0
#endif
#ifndef FP_EX_DENORM
#   define FP_EX_DENORM   0
#endif
#ifndef FP_EX_INVALID_SNAN
#   define FP_EX_INVALID_SNAN   0
#endif
#ifndef FP_EX_INVALID_IMZ
#   define FP_EX_INVALID_IMZ   0
#endif
#ifndef FP_EX_INVALID_IMZ_FMA
#   define FP_EX_INVALID_IMZ_FMA   0
#endif
#ifndef FP_EX_INVALID_ISI
#   define FP_EX_INVALID_ISI   0
#endif
#ifndef FP_EX_INVALID_ZDZ
#   define FP_EX_INVALID_ZDZ   0
#endif
#ifndef FP_EX_INVALID_IDI
#   define FP_EX_INVALID_IDI   0
#endif
#ifndef FP_EX_INVALID_SQRT
#   define FP_EX_INVALID_SQRT   0
#endif
#ifndef FP_EX_INVALID_CVI
#   define FP_EX_INVALID_CVI   0
#endif
#ifndef FP_EX_INVALID_VC
#   define FP_EX_INVALID_VC   0
#endif
static const UNUSED UQItype __clz_tab[256];
#ifndef _FP_STRUCT_LAYOUT
/** _FP_STRUCT_LAYOUT may be defined as an attribute to determine the struct layout variant used for structures where bit-fields are used to access specific parts of binary floating-point numbers */
#   define _FP_STRUCT_LAYOUT
#endif
#ifdef _FP_DECL_EX
#   define FP_DECL_EX   int _fex = 0; _FP_DECL_EX
#else
#   define FP_DECL_EX   int _fex = 0
#endif
#ifndef FP_INIT_ROUNDMODE
/** Initialize any machine-specific state used in FP_ROUNDMODE, FP_TRAPPING_EXCEPTIONS or FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_ROUNDMODE   do {} while (0x0)
#endif
#ifndef FP_INIT_TRAPPING_EXCEPTIONS
/** Initialize any machine-specific state used in FP_TRAPPING_EXCEPTIONS or FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_TRAPPING_EXCEPTIONS   FP_INIT_ROUNDMODE
#endif
#ifndef FP_INIT_EXCEPTIONS
/** Initialize any machine-specific state used in FP_HANDLE_EXCEPTIONS */
#   define FP_INIT_EXCEPTIONS   FP_INIT_TRAPPING_EXCEPTIONS
#endif
#ifndef FP_HANDLE_EXCEPTIONS
#   define FP_HANDLE_EXCEPTIONS   do {} while (0x0)
#endif
#ifndef FP_DENORM_ZERO
/** Flush subnormal inputs to zero with the same sign */
#   define FP_DENORM_ZERO   0
#endif
#ifndef FP_INHIBIT_RESULTS
#   define FP_INHIBIT_RESULTS   0
#endif
#define FP_SET_EXCEPTION(ex)  _fex |= (ex)
#define FP_CUR_EXCEPTIONS   (_fex)
#ifndef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#endif
#ifdef FP_NO_EXCEPTIONS
#   undef FP_SET_EXCEPTION
#   define FP_SET_EXCEPTION(ex)   do {} while (0x0)
#   undef FP_CUR_EXCEPTIONS
#   define FP_CUR_EXCEPTIONS   0
#   undef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#   undef FP_ROUNDMODE
#   define FP_ROUNDMODE   FP_RND_ZERO
#   undef _FP_TININESS_AFTER_ROUNDING
#   define _FP_TININESS_AFTER_ROUNDING   0
#endif
#ifdef FP_NO_EXACT_UNDERFLOW
#   undef FP_TRAPPING_EXCEPTIONS
#   define FP_TRAPPING_EXCEPTIONS   0
#endif


#ifdef _TMS320C6X
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   do { UDItype __ll; asm ("addu .l1 %1, %2, %0;" : "=a"(__ll) : "a"(al), "a"(bl)); (sl) = (USItype)__ll; (sh) = ((USItype)(__ll >> 32)) + (ah) + (bh); } while (0x0)
#   ifdef _TMS320C6400_PLUS
#      define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
#      define umul_ppmm(w1, w0, u, v)   do { UDItype __x = (UDItype) (USItype) (u) * (USItype) (v); (w1) = (USItype) (__x >> 32); (w0) = (USItype) (__x); } while (0x0)
#   endif
#   define UMUL_TIME   (4)
#   define UDIV_TIME   (40)
#endif


#if (defined(ARCHALPHA) && IS_WORDSIZE_64)
#   if (IS_NOT_CPLUSPLUS || AT_LEAST_GCC_5)
#      define umul_ppmm(ph, pl, m0, m1)   do { UDItype __m0 = (m0), __m1 = (m1); (ph) = __builtin_alpha_umulh(__m0, __m1); (pl) = __m0 * __m1; } while (0x0)
#      define UMUL_TIME   (46)
#   endif
#   ifndef LONGLONG_STANDALONE
#      define udiv_qrnnd(q, r, n1, n0, d)   do { UDItype __r; (q) = __udiv_qrnnd(&__r, (n1), (n0), (d)); (r) = __r; } while (0x0)
#      define UDIV_TIME    (220)
#   endif  // LONGLONG_STANDALONE
#endif  // ALPHA


#if (defined(ARCHARC) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add.f %1, %4, %5ntadc %0, %2, %3" : "=r"((USItype) (sh)), "=&r"((USItype)(sl)) : "%r"((USItype) (ah)), "rIJ"((USItype)(bh)), "%r"((USItype) (al)), "rIJ"((USItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub.f %1, %4, %5ntsbc %0, %2, %3" : "=r"((USItype) (sh)), "=&r"((USItype) (sl)) : "r"((USItype)(ah)), "rIJ"((USItype)(bh)), "r"((USItype) (al)), "rIJ"((USItype) (bl)))
#   define __umulsidi3(u, v)   ((UDItype)(USItype)u*(USItype)v)
#   if (defined(__ARC_NORM__) && (!defined(count_leading_zeros)))
#      define count_leading_zeros2(count, x)  do { SItype c_; asm ("norm.ft%0, %1ntmov.mit%0,-1;" : "=r"(c_) : "r"(x) : "cc"); (count) = c_ + 1; } while (0x0)
#   endif
#endif  // ARC


#if (defined(ARCHARM) && (defined(ARM_THUMB2) || (!defined(ARM_THUMB1))) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("adds %1, %4, %5ntadc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%r"((USItype)(ah)), "rI"((USItype)(bh)), "%r"((USItype)(al)), "rI"((USItype) (bl)) __CLOBBER_CC)
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("subs %1, %4, %5ntsbc %0, %2, %3" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "r"((USItype)(ah)), "rI"((USItype)(bh)), "r"((USItype)(al)), "rI"((USItype) (bl)) __CLOBBER_CC)
#   if (defined(__ARM_ARCH_2__) || defined(__ARM_ARCH_2A__) || defined(__ARM_ARCH_3__))
#      define umul_ppmm(xh, xl, a, b)   do { register USItype __t0, __t1, __t2; asm ("%@ Inlined umul_ppmm;" "mov %2, %5, lsr #16;" "mov %0, %6, lsr #16;" "bic %3, %5, %2, lsl #16;" "bic %4, %6, %0, lsl #16;" "mul %1, %3, %4;" "mul %4, %2, %4;" "mul %3, %0, %3;" "mul %0, %2, %0;" "adds %3, %4, %3;" "addcs %0, %0, #65536;" "adds %1, %1, %3, lsl #16;" "adc %0, %0, %3, lsr #16;" : "=&r"((USItype)(xh)), "=r"((USItype)(xl)), "=&r"(__t0), "=&r"(__t1), "=r"(__t2) : "r"((USItype)(a)), "r"((USItype)(b)) __CLOBBER_CC ); } while (0x0)
#      define UMUL_TIME   20
#   else
#      define umul_ppmm(xh, xl, a, b)   do { register UDItype __t0 = (UDItype)(USItype)(a) * (USItype)(b); (xl) = (USItype)__t0; (xh) = (USItype)(__t0 >> 32); } while (0x0)
#      define UMUL_TIME   3
#   endif
#   define UDIV_TIME   100
#endif


#ifdef ARCHCRIS
#   if (__CRIS_arch_version >= 10)
#      define __umulsidi3(u, v)   ((UDItype)(USItype)(u) * (UDItype)(USItype)(v))
#   endif
#   define umul_ppmm(w1, w0, u, v)   do { UDItype __x = __umulsidi3(u, v); (w0) = (USItype)(__x); (w1) = (USItype)(__x >> 32); } while (0x0)
#endif


#if (defined(ARCHHPPA) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add %4, %5, %1ntaddc %2, %3, %0;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%rM"((USItype)(ah)), "rM"((USItype)(bh)), "%rM"((USItype)(al)), "rM"((USItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub %4, %5, %1ntsubb %2, %3, %0;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "rM"((USItype)(ah)), "rM"((USItype)(bh)), "rM"((USItype)(al)), "rM"((USItype)(bl)))
#   ifdef _PA_RISC1_1
#      define umul_ppmm(w1, w0, u, v)   do { union { UDItype __f; struct { USItype __w1, __w0;} __w1w0; } __t; asm ("xmpyu %1, %2, %0;" : "=x"(__t.__f) : "x"((USItype)(u)), "x"((USItype)(v))); (w1) = __t.__w1w0.__w1; (w0) = __t.__w1w0.__w0; } while (0x0)
#      define UMUL_TIME   (8)
#   else
#      define UMUL_TIME   (30)
#   endif
#   define UDIV_TIME   (40)
#   define count_leading_zeros_hppa(count, x)   do { USItype __tmp; asm ("ldi 1, %0n" "extru,= %1,15,16, %%r0;" "extru,tr %1,15,16, %1;" "ldo 16(%0), %0;" "extru,= %1,23,8, %%r0;" "extru,tr %1,23,8, %1;" "ldo 8(%0), %0;" "extru,= %1,27,4, %%r0;" "extru,tr %1,27,4, %1;" "ldo 4(%0), %0;" "extru,= %1,29,2, %%r0;" "extru,tr %1,29,2, %1;" "ldo 2(%0), %0;" "extru %1,30,1, %1;" "sub %0, %1, %0;" : "=r"(count), "=r"(__tmp) : "1"(x)); } while (0x0)
#endif


#if (defined(ARCHI960) && IS_WORDSIZE_32)
#   define umul_ppmm(w1, w0, u, v)   __extension__ ({ union { UDItype __ll; struct { USItype __l, __h;} __i; } __xx; asm ("emul %2, %1, %0;" : "=d"(__xx.__ll) : "%dI"((USItype)(u)), "dI"((USItype)(v))); (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})
#   define __umulsidi3(u, v)   __extension__ ({ UDItype __w; asm ("emul %2, %1, %0;" : "=d"(__w) : "%dI"((USItype)(u)), "dI"((USItype)(v))); __w; })
#endif


#if ((defined (__i370__) || defined(ARCHS390) || defined(__mvs__)) && IS_WORDSIZE_32)
#   ifndef __zarch__
#      define smul_ppmm(xh, xl, m0, m1)   do { union { DItype __ll; struct { USItype __h, __l;} __i; } __x; asm ("lr %N0, %1ntmr %0, %2;" : "=&r"(__x.__ll) : "r"(m0), "r"(m1)); (xh) = __x.__i.__h; (xl) = __x.__i.__l; } while (0x0)
/** sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator, denominator); Like udiv_qrnnd but the numbers are signed; The quotient is rounded towards 0 */
#      define sdiv_qrnnd(q, r, n1, n0, d)   do { union { DItype __ll; struct { USItype __h, __l;} __i; } __x; __x.__i.__h = n1; __x.__i.__l = n0; asm ("dr %0, %2;" : "=r"(__x.__ll) : "0"(__x.__ll), "r"(d)); (q) = __x.__i.__l; (r) = __x.__i.__h; } while (0x0)
#   else
#      define smul_ppmm(xh, xl, m0, m1)   do { register SItype __r0 asm ("0"); register SItype __r1 asm ("1") = (m0); asm ("mrt%%r0, %3;" : "=r"(__r0), "=r"(__r1) : "r"(__r1),  "r"(m1)); (xh) = __r0; (xl) = __r1; } while (0x0)
#      define sdiv_qrnnd(q, r, n1, n0, d)   do { register SItype __r0 asm ("0") = (n1); register SItype __r1 asm ("1") = (n0); asm ("drt%%r0, %4;" : "=r"(__r0), "=r"(__r1) : "r"(__r0), "r"(__r1), "r"(d)); (q) = __r1; (r) = __r0; } while (0x0)
#   endif
#endif


#if (defined(ARCHITANIUM) && IS_WORDSIZE_64)
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   do { UWtype __x; __x = (al) - (bl); if ((al) < (bl)) { (sh) = (ah) - (bh) - 1; } else { (sh) = (ah) - (bh); } (sl) = __x; } while (0x0)
#   define umul_ppmm(ph, pl, m0, m1)   asm ("xma.hu %0 = %2, %3, f0ntxma.l %1 = %2, %3, f0;" : "=&f"(ph), "=f"(pl) : "f"(m0), "f"(m1))
#define UMUL_TIME   (14)
#endif


#if (defined(__M32R__) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("cmp %0, %0ntaddx %1, %5ntaddx %0, %3;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "0"((USItype)(ah)), "r"((USItype)(bh)), "1"((USItype)(al)), "r"((USItype)(bl)) : "cbit")
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("cmp %0, %0ntsubx %1, %5ntsubx %0, %3;" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "0"((USItype)(ah)), "r"((USItype)(bh)), "1"((USItype)(al)), "r"((USItype)(bl)) : "cbit")
#endif


#if (defined(ARCHMIPS) && IS_WORDSIZE_32)
#   define umul_ppmm(w1, w0, u, v)   do { UDItype __x = (UDItype) (USItype) (u) * (USItype) (v); (w1) = (USItype)(__x >> 32); (w0) = (USItype)(__x); } while (0x0)
#   define UMUL_TIME   (10)
#   define UDIV_TIME   (100)
#endif


#if (defined(ARCHSUPERH) && defined(__SHMEDIA__) && __SHMEDIA__ && IS_WORDSIZE_32)
#   define __umulsidi3(u, v)   ((UDItype)(USItype)u*(USItype)v)
#endif


#if (defined(ARCHVAX) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("addl2 %5, %1ntadwc %3, %0;" : "=g"((USItype)(sh)), "=&g"((USItype)(sl)) : "%0"((USItype)(ah)), "g"((USItype)(bh)), "%1"((USItype)(al)), "g"((USItype) (bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("subl2 %5, %1ntsbwc %3, %0;" : "=g"((USItype)(sh)), "=&g"((USItype)(sl)) : "0"((USItype)(ah)), "g"((USItype)(bh)), "1"((USItype)(al)), "g"((USItype)(bl)))
#   define umul_ppmm(xh, xl, m0, m1)   do { union { UDItype __ll; struct { USItype __l, __h;} __i; } __xx; USItype __m0 = (m0), __m1 = (m1); asm ("emul %1, %2,$0, %0;" : "=r"(__xx.__ll) : "g"(__m0), "g"(__m1)); (xh) = __xx.__i.__h; (xl) = __xx.__i.__l; (xh) += ((((SItype) __m0 >> 31) & __m1) + (((SItype) __m1 >> 31) & __m0)); } while (0x0)
#   define sdiv_qrnnd(q, r, n1, n0, d)   do { union { DItype __ll; struct { SItype __l, __h;} __i; } __xx; __xx.__i.__h = n1; __xx.__i.__l = n0; asm ("ediv %3, %2, %0, %1;" : "=g"(q), "=g"(r) : "g"(__xx.__ll), "g"(d)); } while (0x0)
#endif


#if ((defined (I386) || defined(I486)) && IS_WORDSIZE_32)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add{l} {%5, %1|%1, %5}ntadc{l} {%3, %0|%0, %3};" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "%0"((USItype)(ah)), "g"((USItype)(bh)), "%1"((USItype)(al)), "g"((USItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub{l} {%5, %1|%1, %5}ntsbb{l} {%3, %0|%0, %3};" : "=r"((USItype)(sh)), "=&r"((USItype)(sl)) : "0"((USItype)(ah)), "g"((USItype)(bh)), "1"((USItype)(al)), "g"((USItype)(bl)))
#   define umul_ppmm(w1, w0, u, v)   asm ("mul{l} %3;" : "=a"((USItype)(w0)), "=d"((USItype)(w1)) : "%0"((USItype)(u)), "rm"((USItype)(v)))
#   define udiv_qrnnd(q, r, n1, n0, dv)   asm ("div{l} %4;" : "=a"((USItype)(q)), "=d"((USItype)(r)) : "0"((USItype)(n0)), "1"((USItype)(n1)), "rm"((USItype)(dv)))
#   define UMUL_TIME   (40)
#   define UDIV_TIME   (40)
#endif


#if (defined(X86_64) && IS_WORDSIZE_64)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add{q} {%5, %1|%1, %5}ntadc{q} {%3, %0|%0, %3};" : "=r"((UDItype)(sh)), "=&r"((UDItype)(sl)) : "%0"((UDItype)(ah)), "rme"((UDItype)(bh)), "%1"((UDItype)(al)), "rme"((UDItype)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub{q} {%5, %1|%1, %5}ntsbb{q} {%3, %0|%0, %3};" : "=r"((UDItype)(sh)), "=&r"((UDItype)(sl)) : "0"((UDItype)(ah)), "rme"((UDItype)(bh)), "1"((UDItype)(al)), "rme"((UDItype)(bl)))
#   define umul_ppmm(w1, w0, u, v)   asm ("mul{q} %3;" : "=a"((UDItype)(w0)), "=d"((UDItype)(w1)) : "%0"((UDItype)(u)), "rm"((UDItype)(v)))
#   define udiv_qrnnd(q, r, n1, n0, dv)  asm ("div{q} %4;" : "=a"((UDItype)(q)), "=d"((UDItype)(r)) : "0"((UDItype)(n0)), "1"((UDItype)(n1)), "rm"((UDItype)(dv)))
#   define UMUL_TIME   (40)
#   define UDIV_TIME   (40)
#endif


#if (defined(ARCHXSTORMY) && (!defined(count_leading_zeros)))
#   define count_leading_zeros2(count, x)   do { UHItype size; for ((count) = 0, size = W_TYPE_SIZE; size; size -= 16) { UHItype c; c = __clzhi2((x) >> (size - 16)); (count) += c; if (c != 16) { break; } } } while (0x0)
#endif


#if (defined(ARCHXTENSA) && IS_WORDSIZE_32)
#   define umul_ppmm(w1, w0, u, v)   do { DWunion __w; __w.ll = __builtin_umulsidi3(u, v); w1 = __w.s.high; w0 = __w.s.low; } while (0x0)
#   define __umulsidi3(u, v)    __builtin_umulsidi3(u, v)
#endif


#if (defined(ARCHZ8000) && IS_WORDSIZE_16)
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   asm ("add %H1, %H5ntadc %H0, %H3;" : "=r"((unsigned int)(sh)), "=&r"((unsigned int)(sl)) : "%0"((unsigned int)(ah)), "r"((unsigned int)(bh)), "%1"((unsigned int)(al)), "rQR"((unsigned int)(bl)))
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   asm ("sub %H1, %H5ntsbc %H0, %H3;" : "=r"((unsigned int)(sh)), "=&r"((unsigned int)(sl)) : "0"((unsigned int)(ah)), "r"((unsigned int)(bh)), "1"((unsigned int)(al)), "rQR"((unsigned int)(bl)))
#   define umul_ppmm(xh, xl, m0, m1)   do { union {long __ll; struct {unsigned int __h, __l;} __i; } __xx; unsigned int __m0 = (m0), __m1 = (m1); asm ("mult %S0, %H3;" : "=r"(__xx.__i.__h), "=r"(__xx.__i.__l) : "%1"(__m0), "rQR"(__m1)); (xh) = __xx.__i.__h; (xl) = __xx.__i.__l; (xh) += ((((signed int) __m0 >> 15) & __m1) + (((signed int) __m1 >> 15) & __m0)); } while (0x0)
#endif


#ifndef add_ssaaaa
/** add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1, high_addend_2, low_addend_2) adds two UWtype integers, composed by HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2, respectively; The result is placed in HIGH_SUM and LOW_SUM; Overflow (i.e. carry out) is not stored anywhere, and is lost */
#   define add_ssaaaa(sh, sl, ah, al, bh, bl)   do { UWtype __x = (al) + (bl); (sh) = (ah) + (bh) + (__x < (al)); (sl) = __x; } while (0x0)
#endif
#ifndef sub_ddmmss
/** sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend, high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers, composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and LOW_SUBTRAHEND_2 respectively; The result is placed in HIGH_DIFFERENCE and LOW_DIFFERENCE; Overflow (i.e. carry out) is not stored anywhere, and is lost */
#   define sub_ddmmss(sh, sl, ah, al, bh, bl)   do { UWtype = (al) - (bl); (sh) = (ah) - (bh) - (__x > (al)); (sl) = __x; } while (0x0)
#endif
#if ((!defined(umul_ppmm)) && defined(smul_ppmm))
#   define umul_ppmm(w1, w0, u, v)   do { UWtype __w1; UWtype __xm0 = (u), __xm1 = (v); smul_ppmm (__w1, w0, __xm0, __xm1); (w1) = __w1 + (-(__xm0 >> (W_TYPE_SIZE - 1)) & __xm1) + (-(__xm1 >> (W_TYPE_SIZE - 1)) & __xm0); } while (0x0)
#endif
#ifndef umul_ppmm
/** umul_ppmm(high_prod, low_prod, multiplier, multiplicand) multiplies two UWtype integers MULTIPLIER and MULTIPLICAND, and generates a two UWtype word product in HIGH_PROD and LOW_PROD */
#   define umul_ppmm(w1, w0, u, v)   do { UWtype __x0, __x1, __x2, __x3; UHWtype __ul, __vl, __uh, __vh; __ul = __ll_lowpart (u); __uh = __ll_highpart (u); __vl = __ll_lowpart (v); __vh = __ll_highpart (v); __x0 = (UWtype) __ul * __vl; __x1 = (UWtype) __ul * __vh; __x2 = (UWtype) __uh * __vl; __x3 = (UWtype) __uh * __vh; __x1 += __ll_highpart (__x0); __x1 += __x2; if (__x1 < __x2) { __x3 += __ll_B; } (w1) = __x3 + __ll_highpart (__x1); (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0); } while (0x0)
#endif
#ifndef __umulsidi3
/** __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a UDWtype product; This is just a variant of umul_ppmm */
#   define __umulsidi3(u, v)   __extension__ ({ DWunion __w; umul_ppmm(__w.s.high, __w.s.low, u, v); __w.ll; })
#endif
#if (!defined(udiv_qrnnd) && defined(sdiv_qrnnd))
#   define udiv_qrnnd(q, r, nh, nl, d)   do { extern UWtype __udiv_w_sdiv (UWtype*, UWtype, UWtype, UWtype); UWtype __r; (q) = __udiv_w_sdiv (&__r, nh, nl, d); (r) = __r; } while (0x0)
#endif
#ifndef __udiv_qrnnd_c
/** udiv_qrnnd(quotient, remainder, high_numerator, low_numerator, denominator) divides a UDWtype, composed by the UWtype integers HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient in QUOTIENT and the remainder in REMAINDER; HIGH_NUMERATOR must be less than DENOMINATOR for correct operation; If, in addition, the most significant bit of DENOMINATOR must be 1, then the pre-processor symbol UDIV_NEEDS_NORMALIZATION is defined to 1 */
#   define __udiv_qrnnd_c(q, r, n1, n0, d)   do { UWtype __d1, __d0, __q1, __q0; UWtype __r1, __r0, __m; __d1 = __ll_highpart(d); __d0 = __ll_lowpart (d); __r1 = (n1) % __d1; __q1 = (n1) / __d1; __m = (UWtype) __q1 * __d0; __r1 = __r1 * __ll_B | __ll_highpart (n0); if (__r1 < __m) { __q1--, __r1 += (d); if (__r1 >= (d) && (__r1 < __m)) { __q1--, __r1 += (d); } } __r1 -= __m; __r0 = __r1 % __d1; __q0 = __r1 / __d1; __m = (UWtype) __q0 * __d0; __r0 = __r0 * __ll_B | __ll_lowpart (n0); if (__r0 < __m) { __q0--, __r0 += (d); if (__r0 >= (d) && (__r0 < __m)) { __q0--, __r0 += (d); } } __r0 -= __m; (q) = (UWtype) __q1 * __ll_B | __q0; (r) = __r0; } while (0x0)
#endif
#ifndef udiv_qrnnd
#   define UDIV_NEEDS_NORMALIZATION   1
#   define udiv_qrnnd   __udiv_qrnnd_c
#endif
#ifndef count_leading_zeros2
#   define count_leading_zeros2(count, x)  do { UWtype __xr = (x); UWtype __a; if (W_TYPE_SIZE <= 32) { __a = __xr < ((UWtype)1 << 2 * __BITS4) ? (__xr < ((UWtype)1 << __BITS4) ? 0 : __BITS4): (__xr < ((UWtype)1 << 3 * __BITS4) ?  2*__BITS4 : 3 * __BITS4); } else { for (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8) if (((__xr >> __a) & 0xff) != 0) { break; } } (count) = W_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a); } while (0x0)
#endif
#ifndef count_trailing_zeros
/** Define count_trailing_zeros using count_leading_zeros */
#   define count_trailing_zeros(count, x)   do { UWtype __ctz_x = (x); UWtype __ctz_c; count_leading_zeros2(__ctz_c, (__ctz_x & -__ctz_x)); (count) = W_TYPE_SIZE - 1 - __ctz_c; } while (0x0)
#endif
#ifndef UDIV_NEEDS_NORMALIZATION
#   define UDIV_NEEDS_NORMALIZATION   0
#endif


LIB_FUNC unsigned long udivmodsi4(unsigned long num, unsigned long den, const int modwanted) {
	register unsigned long bit = 1, res = 0;
	while (den < num && bit && (!(den & (1L << 31)))) {
		den <<= 1;
		bit <<= 1;
	}
	while (bit) {
		if (num >= den) {
			num -= den;
			res |= bit;
		}
		bit >>= 1;
		den >>= 1;
	}
	if (modwanted) { return num; }
	return res;
}
#define __udivsi3(a, b)   udivmodsi4((a), (b), (0))
#define __umodsi3(a, b)   udivmodsi4((a), (b), (1))


LIB_FUNC long __divsi3(long a, long b) {
	register int neg = 0;
	register long res;
	if (a < 0) {
		a = -a;
		neg = (!neg);
	}
	if (b < 0) {
		b = -b;
		neg = (!neg);
	}
	res = (long)udivmodsi4((unsigned long)a, (unsigned long)b, 0);
	if (neg) { res = (-res); }
	return res;
}


LIB_FUNC long __modsi3(long a, long b) {
	register int neg = 0;
	register long res;
	if (a < 0) {
		a = -a;
		neg = 1;
	}
	if (b < 0) { b = -b; }
	res = (long)udivmodsi4((unsigned long)a, (unsigned long)b, 1);
	if (neg) { res = -res; }
	return res;
}


LIB_FUNC uint32_t mulhi(const uint32_t a, const uint32_t b) {
	return (uint32_t)(((uint64_t)a * (uint64_t)b) >> 32);
}


LIB_FUNC SFtype __floatunsisf(USItype u) {
	SItype s = (SItype)u;
	if (s < 0) {
		return (SFtype)2.0 * (SFtype)((SItype)((u & 1) | (u >> 1)));
	} else { return (SFtype)s; }
}


LIB_FUNC DFtype __floatunsidf(USItype u) {
	SItype s = (SItype)u;
	DFtype r = (DFtype)s;
	if (s < 0) {
		r += (DFtype)2.0 * (DFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}


#if SUPPORTS_XFTYPE
LIB_FUNC XFtype __floatunsixf(USItype u) {
	SItype s = (SItype)u;
	XFtype r = (XFtype)s;
	if (s < 0) {
		r += (XFtype)2.0 * (XFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}
#endif


#if SUPPORTS_TFTYPE
LIB_FUNC TFtype __floatunsitf(USItype u) {
	SItype s = (SItype)u;
	TFtype r = (TFtype)s;
	if (s < 0) {
		r += (TFtype)2.0 * (TFtype)((USItype)1 << (sizeof(USItype) * CHARBITS - 1));
	}
	return r;
}
#endif


/** Shifts `a` right by the number of bits given in `count`; If any nonzero bits are shifted off, they are jammed into the least significant bit of the result by setting the least significant bit to 1; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 32, the result will be either 0 or 1, depending on whether `a` is zero or nonzero; The result is stored in the location pointed to by `zPtr` */
LIB_FUNC void shift32RightJamming(const uint32_t a, const int16_t count, uint32_t* zPtr) {
	uint32_t z;
	if (count == 0) { z = a; }
	else if (count < 32 ) { z = (a >> count) | ((a << ((-count) & 31)) != 0); }
	else { z = (a != 0); }
	*zPtr = z;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` right by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 64, the result will be 0; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shift64Right(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr ) {
	uint32_t z0, z1;
	const int8_t negCount = (-count) & 31;
	if (count == 0) {
		z1 = a1;
		z0 = a0;
	} else if (count < 32) {
		z1 = (a0 << negCount) | (a1 >> count);
		z0 = a0 >> count;
	} else {
		z1 = (count < 64) ? (a0 >> (count & 31)) : 0;
		z0 = 0;
	}
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` right by the number of bits given in `count`; If any nonzero bits are shifted off, they are jammed into the least significant bit of the result by setting the least significant bit to 1; The value of `count` can be arbitrarily large; in particular, if `count` is greater than 64, the result will be either 0 or 1, depending on whether the concatenation of `a0` and `a1` is zero or nonzero; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shift64RightJamming(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr ) {
	uint32_t z0, z1;
	const int8_t negCount = (-count) & 31;
	if (count == 0) {
		z1 = a1;
		z0 = a0;
	} else if (count < 32) {
		z1 = (a0 << negCount) | (a1 >> count) | ((a1 << negCount) != 0);
		z0 = a0 >> count;
	} else {
		if (count == 32) {
			z1 = a0 | (a1 != 0);
		} else if (count < 64) {
			z1 = (a0 >> (count & 31)) | (((a0 << negCount) | a1) != 0);
		} else {
			z1 = ((a0 | a1) != 0);
		}
		z0 = 0;
	}
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 96-bit value formed by concatenating `a0`, `a1`, and `a2` right by 32 _plus_ the number of bits given in `count` */
LIB_FUNC void shift64ExtraRightJamming(const uint32_t a0, const uint32_t a1, uint32_t a2, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	uint32_t z0, z1, z2;
	const int8_t negCount = (int8_t)((-count) & 31);
	if (count == 0) {
		z2 = a2;
		z1 = a1;
		z0 = a0;
	} else {
		if (count < 32) {
			z2 = a1 << negCount;
			z1 = (a0 << negCount) | (a1 >> count);
			z0 = a0 >> count;
		} else {
			if (count == 32) {
				z2 = a1;
				z1 = a0;
			} else {
				a2 |= a1;
				if (count < 64) {
					z2 = a0 << negCount;
					z1 = a0 >> (count & 31);
				} else {
					z2 = (count == 64) ? a0 : (a0 != 0);
					z1 = 0;
				}
			}
			z0 = 0;
		}
		z2 |= (a2 != 0);
	}
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Shifts the 64-bit value formed by concatenating `a0` and `a1` left by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` must be less than 32; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void shortShift64Left(const uint32_t a0, const uint32_t a1, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	*z1Ptr = a1 << count;
	*z0Ptr = (count == 0) ? a0 : (a0 << count) | (a1 >> ((-count) & 31));
}


/** Shifts the 96-bit value formed by concatenating `a0`, `a1`, and `a2` left by the number of bits given in `count`; Any bits shifted off are lost; The value of `count` must be less than 32; The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void shortShift96Left(const uint32_t a0, const uint32_t a1, const uint32_t a2, const int16_t count, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	uint32_t z0, z1, z2;
	register int8_t negCount;
	z2 = a2 << count;
	z1 = a1 << count;
	z0 = a0 << count;
	if (0 < count) {
		negCount = ((-count) & 31);
		z1 |= a2 >> negCount;
		z0 |= a1 >> negCount;
	}
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Adds the 64-bit value formed by concatenating `a0` and `a1` to the 64-bit value formed by concatenating `b0` and `b1`; Addition is modulo 2^64, so any carry out is lost; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void add64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	uint32_t z1;
	z1 = a1 + b1;
	*z1Ptr = z1;
	*z0Ptr = a0 + b0 + (z1 < a1);
}


/** Adds the 96-bit value formed by concatenating `a0`, `a1`, and `a2` to the 96-bit value formed by concatenating `b0`, `b1`, and `b2`; Addition is modulo 2^96, so any carry out is lost; The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void add96(const uint32_t a0, const uint32_t a1, const uint32_t a2, const uint32_t b0, const uint32_t b1, const uint32_t b2, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	uint32_t z0, z1, z2;
	uint8_t carry0, carry1;
	z2 = a2 + b2;
	carry1 = (z2 < a2);
	z1 = a1 + b1;
	carry0 = (z1 < a1);
	z0 = a0 + b0;
	z1 = (uint32_t)(z1 + (uint32_t)carry1);
	z0 += (uint32_t)(z1 < (uint32_t)carry1);
	z0 = (uint32_t)(z0 + (uint32_t)carry0);
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Subtracts the 64-bit value formed by concatenating `b0` and `b1` from the 64-bit value formed by concatenating `a0` and `a1`; Subtraction is modulo 2^64, so any borrow out (carry out) is lost; The result is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void sub64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	*z1Ptr = a1 - b1;
	*z0Ptr = (a0 - b0 - (a1 < b1));
}


/** Subtracts the 96-bit value formed by concatenating `b0`, `b1`, and `b2` from the 96-bit value formed by concatenating `a0`, `a1`, and `a2`; Subtraction is modulo 2^96, so any borrow out (carry out) is lost.  The result is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void sub96(const uint32_t a0, const uint32_t a1, const uint32_t a2, const uint32_t b0, const uint32_t b1, const uint32_t b2, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr) {
	register uint32_t z0, z1, z2;
	register uint8_t borrow0, borrow1;
	z2 = a2 - b2;
	borrow1 = (a2 < b2);
	z1 = a1 - b1;
	borrow0 = (a1 < b1);
	z0 = a0 - b0;
	z0 -= (uint32_t)(z1 < (uint32_t)borrow1);
	z1 -= (uint32_t)borrow1;
	z0 -= (uint32_t)borrow0;
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Multiplies `a` by `b` to obtain a 64-bit product; The product is broken into two 32-bit pieces which are stored at the locations pointed to by `z0Ptr` and `z1Ptr` */
LIB_FUNC void mul32To64(const uint32_t a, const uint32_t b, uint32_t* z0Ptr, uint32_t* z1Ptr) {
	register uint16_t aHigh, aLow, bHigh, bLow;
	register uint32_t z0, zMiddleA, zMiddleB, z1;
	aLow = (uint16_t)a;
	aHigh = (uint16_t)(a >> 16);
	bLow = (uint16_t)b;
	bHigh = (uint16_t)(b >> 16);
	z1 = ((uint32_t)aLow) * bLow;
	zMiddleA = ((uint32_t)aLow) * bHigh;
	zMiddleB = ((uint32_t)aHigh) * bLow;
	z0 = ((uint32_t)aHigh) * bHigh;
	zMiddleA += zMiddleB;
	z0 += (((uint32_t)(zMiddleA < zMiddleB)) << 16) + (zMiddleA >> 16);
	zMiddleA <<= 16;
	z1 += zMiddleA;
	z0 += (z1 < (uint32_t)zMiddleA);
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Multiplies the 64-bit value formed by concatenating `a0` and `a1` by `b` to obtain a 96-bit product; The product is broken into three 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, and `z2Ptr` */
LIB_FUNC void mul64By32To96(const uint32_t a0, const uint32_t a1, const uint32_t b, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr ) {
	uint32_t z0, z1, z2, more1;
	mul32To64(a1, b, &z1, &z2);
	mul32To64(a0, b, &z0, &more1);
	add64(z0, more1, 0, z1, &z0, &z1);
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Multiplies the 64-bit value formed by concatenating `a0` and `a1` to the 64-bit value formed by concatenating `b0` and `b1` to obtain a 128-bit product; The product is broken into four 32-bit pieces which are stored at the locations pointed to by `z0Ptr`, `z1Ptr`, `z2Ptr`, and `z3Ptr` */
LIB_FUNC void mul64To128(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1, uint32_t* z0Ptr, uint32_t* z1Ptr, uint32_t* z2Ptr, uint32_t* z3Ptr) {
	uint32_t z0, z1, z2, z3;
	uint32_t more1, more2;
	mul32To64(a1, b1, &z2, &z3);
	mul32To64(a1, b0, &z1, &more2);
	add64(z1, more2, 0, z2, &z1, &z2);
	mul32To64(a0, b0, &z0, &more1);
	add64(z0, more1, 0, z1, &z0, &z1);
	mul32To64(a0, b1, &more1, &more2);
	add64(more1, more2, 0, z2, &more1, &z2);
	add64(z0, z1, 0, more1, &z0, &z1);
	*z3Ptr = z3;
	*z2Ptr = z2;
	*z1Ptr = z1;
	*z0Ptr = z0;
}


/** Returns an approximation to the 32-bit integer quotient obtained by dividing `b` into the 64-bit value formed by concatenating `a0` and `a1`; The divisor `b` must be at least 2^31.  If q is the exact quotient truncated toward zero, the approximation returned lies between q and q + 2 inclusive; If the exact quotient q is larger than 32 bits, the maximum positive 32-bit unsigned integer is returned */
LIB_FUNC uint32_t estimateDiv64To32(const uint32_t a0, const uint32_t a1, const uint32_t b) {
	register uint32_t b0, b1, z;
	uint32_t rem0, rem1, term0, term1;
	if (b <= a0) { return 0xFFFFFFFF; }
	b0 = b >> 16;
	z = (b0 << 16 <= a0) ? 0xFFFF0000 : (a0 / b0) << 16;
	mul32To64(b, z, &term0, &term1);
	sub64(a0, a1, term0, term1, &rem0, &rem1);
	while (((int32_t) rem0) < 0) {
		z -= 0x10000;
		b1 = b << 16;
		add64(rem0, rem1, b0, b1, &rem0, &rem1);
	}
	rem0 = (rem0 << 16) | (rem1 >> 16);
	z |= (b0 << 16 <= rem0) ? 0xFFFF : (rem0 / b0);
	return z;
}


#ifndef SOFTFLOAT_FOR_GCC
static const UNUSED int16_t sqrtOddAdjustments[16] = {
	0x4, 0x22, 0x5D, 0xB1, 0x11D, 0x19F, 0x236, 0x2E0,
	0x39C, 0x468, 0x545, 0x631, 0x72B, 0x832, 0x946, 0xA67
};
static const UNUSED int16_t sqrtEvenAdjustments[16] = {
	0xA2D, 0x8AF, 0x75A, 0x629, 0x51A, 0x429, 0x356, 0x29E,
	0x200, 0x179, 0x109, 0xAF, 0x68, 0x34, 0x12, 0x2
};
/** Returns an approximation to the square root of the 32-bit significand given by `a`; Considered as an integer, `a` must be at least 2^31; If bit 0 of `aExp` (the least significant bit) is 1, the integer returned approximates 2^31*sqrt(`a`/2^31), where `a` is considered an integer; If bit 0 of `aExp` is 0, the integer returned approximates 2^31*sqrt(`a`/2^30); In either case, the approximation returned lies strictly within +/-2 of the exact value */
LIB_FUNC int32_t estimateSqrt32(const int16_t aExp, const uint32_t a) {
	register int8_t index = (a >> 27) & 15;
	register int32_t z, x = (int32_t)a;
	if (aExp & 1) {
		z = (int32_t)((0x4000 + (a >> 17)) - (uint32_t)sqrtOddAdjustments[index]);
		z = (int32_t)((int32_t)((a / (uint32_t)z) << 14) + (int32_t)(z << 15));
		x >>= 1;
	} else {
		z = (int32_t)((int32_t)(0x8000 + (int32_t)(a >> 17)) - (int32_t)sqrtEvenAdjustments[index]);
		z = (int32_t)((a / (uint32_t)z) + (uint32_t)z);
		z = ((0x20000 <= z) ? (int32_t)0xFFFF8000 : (int32_t)(z << 15));
		if ((uint32_t)z <= a) { return (int32_t)(a >> 1); }
	}
	return (int32_t)((((int32_t)estimateDiv64To32((uint32_t)x, 0, (uint32_t)z)) >> 1) + (int32_t)(z >> 1));
}
#endif


static const UNUSED int8_t countLeadingZerosHigh[256] = {
	8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/** Returns the number of leading 0 bits before the most-significant 1 bit of `a`; If `a` is zero, 32 is returned */
LIB_FUNC int8_t countLeadingZeros32(const uint32_t a) {
	register int8_t shiftCount = 0;
	register uint32_t x = a;
	if (x < 0x10000) {
		shiftCount = (int8_t)(shiftCount + (int8_t)16);
		x <<= 16;
	}
	if (x < 0x1000000) {
		shiftCount = (int8_t)(shiftCount + (int8_t)8);
		x <<= 8;
	}
	shiftCount = (int8_t)(shiftCount + ((int8_t)countLeadingZerosHigh[x >> 24]));
	return shiftCount;
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC bool eq64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 == b0) && (a1 == b1));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is less than or equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC bool le64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 < b0) || ((a0 == b0) && (a1 <= b1)));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is less
than the 64-bit value formed by concatenating `b0` and `b1` Otherwise, returns 0 */
LIB_FUNC bool lt64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 < b0) || ((a0 == b0) && (a1 < b1)));
}


/** Returns 1 if the 64-bit value formed by concatenating `a0` and `a1` is not equal to the 64-bit value formed by concatenating `b0` and `b1`; Otherwise, returns 0 */
LIB_FUNC bool ne64(const uint32_t a0, const uint32_t a1, const uint32_t b0, const uint32_t b1) {
	return (bool)((a0 != b0) || (a1 != b1));
}


#endif  // SOFT_FP_H


/* ABI COMPATIBILITY FOR LGAMMA FUNCTIONS */


#if (!(defined(LGAMMA_COMPAT_H) || defined(_LGAMMA_COMPAT_H_)))
#define LGAMMA_COMPAT_H   (1)
#define _LGAMMA_COMPAT_H_   (1)


/** Whether to build this version at all */
#define BUILD_LGAMMA   (1)
/** If there is a compatibility version, gamma (not an ISO C function, so never a problem for it to set signgam) points directly to it rather than having separate versions */
#define GAMMA_ALIAS   (1)


#ifndef USE_AS_COMPAT
#   define USE_AS_COMPAT   0
#endif
/** The name to use for this version */
#if USE_AS_COMPAT
#   define LGFUNC(FUNC)   FUNC ## _compat
#else
#   define LGFUNC(FUNC)   FUNC
#endif


/** Call the underlying lgamma_r function */
#define CALL_LGAMMA(TYPE, FUNC, ARG)   __extension__ ({ TYPE lgamma_tmp; int local_signgam; if (USE_AS_COMPAT) { lgamma_tmp = FUNC ((ARG), &local_signgam); if (_LIB_VERSION != _ISOC_) { signgam = __signgam = local_signgam; } } else { lgamma_tmp = FUNC ((ARG), &__signgam); } lgamma_tmp; })


#if (defined(ARCHITANIUM) && (!(defined(IA64_LGAMMA_COMPAT_H) || defined(_IA64_LGAMMA_COMPAT_H_))))  // Itanium
#define IA64_LGAMMA_COMPAT_H   (1)
#define _IA64_LGAMMA_COMPAT_H_   (1)


#undef LGFUNC
#if USE_AS_COMPAT
#   define LGFUNC(FUNC)   __ ## FUNC ## _compat
#else
#   define LGFUNC(FUNC)   __ieee754_ ## FUNC
#endif


#undef CALL_LGAMMA
#define CALL_LGAMMA(TYPE, FUNC, ARG)   __extension__ ({ TYPE lgamma_tmp; extern int __signgam, signgam; lgamma_tmp = FUNC ((ARG), &__signgam, sizeof(__signgam)); if (USE_AS_COMPAT) { signgam = __signgam; } lgamma_tmp; })


#endif  // IA64_LGAMMA_COMPAT_H


#endif  // LGAMMA_COMPAT_H


/* MATH FUNCTIONS (<math.h>) */


#if (!(defined(_MATH_H) || defined(_MATH_H_) || defined(_MATH_INLINE_H) || defined(_MATH_INLINE_H_) || defined(_MATH_PRIVATE_H_) || defined(__F_MATH_H__)))  // http://www.cplusplus.com/reference/cmath/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html
#define _MATH_H   (1)
#define _MATH_H_   (1)
#define math__INCLUDED   (1)
#define vmsmath_INCLUDED   (1)
#define __MATH   (1)
#define _MATH_INLINE_H   (1)
#define _MATH_INLINE_H_   (1)
#define MATH_INLINE_H   (1)
#define MATH_PRIVATE_H   (1)
#define _MATH_PRIVATE_H_   (1)
#define _F_MATH_H_   (1)
#define __F_MATH_H__   (1)
#define MATH_X_MACROS_FUNCTIONS_SEEN   (1)


#if (INT_MAX > 50000)
#   define OVERFLOW_INT   (50000)
#else
#   define OVERFLOW_INT   (30000)
#endif


#if ((!defined(COLDFIRE_MATH_PRIVATE_H)) && defined(COLDFIRE))
#define COLDFIRE_MATH_PRIVATE_H   (1)


#   define LDBL_CLASSIFY_COMPAT   (1)


#endif


#if ((!defined(HPPA_MATH_PRIVATE_H)) && defined(HPPA))
#define HPPA_MATH_PRIVATE_H   (1)

/** One of the few architectures where the meaning of the quiet/signaling bit is inverse to IEEE 754-2008 (as well as common practice for IEEE 754-1985) */
#   define HIGH_ORDER_BIT_IS_SET_FOR_SNAN   (1)


#endif


#if (FLT_EVAL_METHOD == 0)
/** math_narrow_eval reduces its floating-point argument to the range and precision of its semantic type */
#   define math_narrow_eval(x)   (x)
#else
#   if (FLT_EVAL_METHOD == 1)
#      define excess_precision(type)   __builtin_types_compatible_p(type, float)
#   else
#      define excess_precision(type)   (__builtin_types_compatible_p(type, float) || __builtin_types_compatible_p(type, double))
#   endif
/** math_narrow_eval reduces its floating-point argument to the range and precision of its semantic type */
#   define math_narrow_eval(x)   __extension__ ({ typeof(x) math_narrow_eval_tmp = (x); if (excess_precision(typeof(math_narrow_eval_tmp))) { asm (";" : "+m"(math_narrow_eval_tmp)); } math_narrow_eval_tmp; })
#endif


#if (!(defined(FIX_INT_FP_CONVERT_ZERO_H) || defined(FIX_INT_FP_CONVERT_ZERO)))
#define FIX_INT_FP_CONVERT_ZERO_H   1

/** Define this macro to 1 to work around conversions of integer 0 to floating point returning -0 instead of the correct +0 in some rounding modes */
#   define FIX_INT_FP_CONVERT_ZERO   0

#endif


#define fabs_tg(x)   _Generic ((x), const float: fabsf((x)), float: fabsf((x)), const double: fabs((x)), double: fabs((x)), const long double: fabsl((x)), long double: fabsl((x)), default: 0)
#define min_of_type(type)   _Generic ((type), const float: FLT_MIN, float: FLT_MIN, const double: DBL_MIN, double: DBL_MIN, const long double: LDBL_MIN, long double: LDBL_MIN, default: 0)
/** If X (which is not a NaN) is subnormal, force an underflow exception */
#define math_check_force_underflow(x)   do { typeof(x) force_underflow_tmp = (x); if ((fabs_tg(force_underflow_tmp)) < min_of_type(force_underflow_tmp)) { typeof(force_underflow_tmp) force_underflow_tmp2 = (force_underflow_tmp * force_underflow_tmp); math_force_eval(force_underflow_tmp2); } } while (0x0)
#define math_check_force_underflow_nonneg(x)   do { typeof(x) force_underflow_tmp = (x); if (force_underflow_tmp < min_of_type(force_underflow_tmp)) { typeof(force_underflow_tmp) force_underflow_tmp2 = force_underflow_tmp * force_underflow_tmp; math_force_eval(force_underflow_tmp2); } } while (0x0)
#define math_check_force_underflow_complex(x)   do { typeof(x) force_underflow_complex_tmp = (x); math_check_force_underflow(__real__ force_underflow_complex_tmp); math_check_force_underflow(__imag__ force_underflow_complex_tmp); } while (0x0)


LIB_FUNC uint8_t saturateadd8(const uint8_t a, const uint8_t b) {
	return (uint8_t)((a > (uint8_t)0xFF - b) ? (uint8_t)0xFF : (a + b));
}


LIB_FUNC uint16_t saturateadd16(const uint16_t a, const uint16_t b) {
	return (uint16_t)((a > (uint16_t)0xFFFF - b) ? (uint16_t)0xFFFF : (a + b));
}


LIB_FUNC uint32_t saturateadd32(const uint32_t a, const uint32_t b) {
	return (uint32_t)((a > (uint32_t)0xFFFFFFFF - b) ? (uint32_t)0xFFFFFFFF : (a + b));
}


LIB_FUNC uint64_t saturateadd64(const uint64_t a, const uint64_t b) {
	return (uint64_t)((a > (uint64_t)0xFFFFFFFFFFFFFFFF - b) ? (uint64_t)0xFFFFFFFFFFFFFFFF : (a + b));
}


/** ConstructSignificand parses the tagp argument of nanf, nan, or nanl and returns a 64-bit number that should be placed into the significand of the NaN being returned. If tagp does not consist of a recognized numeral, zero is returned. */
LIB_FUNC uint64_t ConstructSignificand(const char* tagp) {
	if (tagp == (char*)NULL) { return (uint64_t)0; }
	else if (*tagp == 0x30) {  // Determine the numeral base from the leading characters
		++tagp;  // Consume the zero.
		if (*tagp == 0x78 || *tagp == 0x58) {  // Hexadecimal
			++tagp;  // Consume the x
			char c;
			uint64_t significand = 0x0;
			while ((c = (*tagp++))) {
				if (0x30 <= c && c <= 0x39) { significand = ((uint64_t)(significand << 4) | (uint64_t)(c - 0x30)); }
				else if (0x61 <= c && c <= 0x66) { significand = ((uint64_t)(significand << 4) | (uint64_t)(c - 0x6B)); }
				else if (0x41 <= c && c <= 0x46) { significand = ((uint64_t)(significand << 4) | (uint64_t)(c - 0x4B)); }
				else { return (uint64_t)0; }
			}
			return significand;
		} else {  // Octal
			char c;
			uint64_t significand = 0;
			while ((c = (*tagp++))) {
				if (0x30 <= c && c <= 0x37) { significand = ((uint64_t)(significand << 3) | (uint64_t)(c - 0x30)); }
				else { return (uint64_t)0; }
			}
			return significand;
		}
	} else {  // Decimal
		char c;
		uint64_t significand = 0;
		while ((c = (*tagp++))) {
			if (0x30 <= c && c <= 0x39) { significand = ((uint64_t)(significand * 10) + (uint64_t)(c - 0x30)); }
			else { return (uint64_t)0; }
		}
		return significand;
	}
}


LIB_FUNC MATHX_FUNC_ATTR int matherr(struct exception* restrict __exc) {
	if (__exc->arg1 != __exc->arg1) { return 0; }
	return 0;
}
#define __matherr(__exc)   matherr((__exc))


#if (defined(X86_64) || defined(I386))
static const UNUSED int flt_rounds_map[4] = {
	1,  // Round to nearest
	3,  // Round to zero
	2,  // Round to negative infinity
	0  // Round to positive infinity
};
LIB_FUNC int __flt_rounds(void) {
	int x;
	// Assume that the x87 and the SSE unit agree on the rounding mode
	asm ("fnstcw %0;" : "=m"(x));
	return (int)(flt_rounds_map[(x >> 10) & 3]);
}
#else
#   define __flt_rounds()   FLT_ROUNDS
#endif


// ABS

/** Absolute value - strip the negative sign and return the number */
LIB_FUNC int abs_int(const int num) {
	return ((num >= 0) ? num : -num);
}


// AVERAGES

/** Return the mean (average) of a set of numbers */
LIB_FUNC double mean(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double average = (double)va_arg(varargs, int);
	register int i;
	for (i = 1; i < count; ++i) { average += (double)va_arg(varargs, int); }
	va_end(varargs);
	return (double)(average / (double)count);
}


/** Return the mean (average) of a set of numbers */
LIB_FUNC float meanf(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register float average = (float)va_arg(varargs, int);
	register int i;
	for (i = 1; i < count; ++i) { average += (float)va_arg(varargs, int); }
	va_end(varargs);
	return (float)(average / (float)count);
}


/** Return the mean (average) of a set of numbers */
LIB_FUNC long double meanl(const long long int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register long double average = (long double)va_arg(varargs, sllint);
	register sllint i;
	for (i = (sllint)1; i < count; ++i) { average += (long double)va_arg(varargs, sllint); }
	va_end(varargs);
	return (long double)(average / (long double)count);
}


/** Return the mean (average) of a set of numbers */
LIB_FUNC double longmean(const slint count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double average = (double)va_arg(varargs, slint);
	register slint i;
	for (i = (slint)1; i < count; ++i) { average += (double)va_arg(varargs, slint); }
	va_end(varargs);
	return (double)(average / (double)count);
}


/** Return the largest (maximum) float */
LIB_FUNC float maxf(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double num, ans = va_arg(varargs, double);
	register int i;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, double);
		ans = (ans > num ? ans : num);
	}
	va_end(varargs);
	return (float)ans;
}


/** Return the smallest (minimum) float */
LIB_FUNC float minf(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double num, ans = va_arg(varargs, double);
	register int i;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, double);
		ans = (ans < num ? ans : num);
	}
	va_end(varargs);
	return (float)ans;
}


/** Return the largest (maximum) double */
LIB_FUNC double maxd(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double num, ans = va_arg(varargs, double);
	register int i;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, double);
		ans = (ans > num ? ans : num);
	}
	va_end(varargs);
	return ans;
}


/** Return the smallest (minimum) double */
LIB_FUNC double mind(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register double num, ans = va_arg(varargs, double);
	register int i;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, double);
		ans = (ans < num ? ans : num);
	}
	va_end(varargs);
	return ans;
}


#ifndef OSWINDOWS
/** Return the largest (maximum) number */
LIB_FUNC int maxva(const int count, ...) {
	va_list varargs;
	va_start(varargs, count);
	register int ans = va_arg(varargs, int);
	register int i, num;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, int);
		ans = (ans > num ? ans : num);
	}
	va_end(varargs);
	return ans;
}


/** Return the smallest (minimum) number */
LIB_FUNC int minva(const int count, ...) {
	// Return the smallest (minimum) number
	va_list varargs;
	va_start(varargs, count);
	register int ans = va_arg(varargs, int);
	register int i, num;
	for (i = 1; i < count; ++i) {
		num = va_arg(varargs, int);
		ans = (ans < num ? ans : num);
	}
	va_end(varargs);
	return ans;
}
#endif


// FABS

/** Returns the absolute value of x */
LIB_FUNC float fabsf(const float x) {
#   if (defined(POWERPC) || defined(POWERPC64))
	float r;
	asm ("fabs %0, %1;" : "=d"(r) : "d"(x));
	return (float)r;
#   elif (defined(ARCHX86_64) || defined(ARCHX86))
	float r = x;
	asm ("fld %0;" "fabs;" "fstp %1;" : "=m"(r) : "m"(x));
	return r;
#   else
	return __builtin_fabsf(x);
#   endif
}
#define __fabsf(x)   fabsf((x))


/** Returns the absolute value of x */
LIB_FUNC double fabs(const double x) {
#   if (defined(POWERPC) || defined(POWERPC64))
	double r;
	asm ("fabs %0, %1;" : "=d"(r) : "d"(x));
	return r;
#   elif (defined(ARCHX86_64) || defined(ARCHX86))
	double r = x;
	asm ("fldl %0;" "fabs;" "fstpl %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	double num = x;
	ieee_double_shape_type x_u;
	x_u.value = num;
	SET_HIGH_WORD(num, (uint32_t)(x_u.parts.msw & 0x7fffffff));
	return num;
#   endif
}
#define __fabs(x)   fabs((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns the absolute value of x */
LIB_FUNC long double fabsl(const long double x) {
	long double num = x;
	ieee854_long_double_shape_type x_u;
	x_u.value = num;
	SET_LDOUBLE_MSW64(num, (uint64_t)(x_u.parts64.msw & 0x7fffffffffffffffULL));
	return (long double)num;
}
#endif


// FCHS

/** Returns value of x with the sign toggled */
LIB_FUNC float fchsf(const float x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	float r = x;
	asm ("fld %0;" "fchs;" "fstp %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	return (x * -1.0F);
#   endif
}
#define __fchsf(x)   fchsf((x))


/** Returns value of x with the sign toggled */
LIB_FUNC double fchs(const double x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	double r = x;
	asm ("fldl %0;" "fchs;" "fstpl %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	return (x * -1.0);
#   endif
}
#define __fchs(x)   fchs((x))


/** Returns value of x with the sign toggled */
LIB_FUNC long double fchsl(const long double x) {
	return (x * -1.0L);
}
#define __fchsl(x)   fchsl((x))


// FUSED MULTIPLY-ADD (FMA)

/** Fused Multiply-Add */
LIB_FUNC float fmaf(const float x, const float y, const float z) {
	return (float)((float)(x * y) + z);
}


/** Fused Multiply-Add */
LIB_FUNC double fma(const double x, const double y, const double z) {
	return (double)((double)(x * y) + z);
}


#if SUPPORTS_LONG_DOUBLE
/** Fused Multiply-Add */
LIB_FUNC long double fmal(const long double x, const long double y, const long double z) {
	return (long double)((long double)(x * y) + z);
}
#endif


// SIGNBIT

/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
LIB_FUNC int signbitf(const float x) {
	ieee_float_shape_type signbitf_xf_u;
	signbitf_xf_u.value = x;
	return (int)((signbitf_xf_u.word & 0x80000000U));
}
/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
#define __signbitf(x)   (int)__signbitf((float)(x))


/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
LIB_FUNC int signbit(const double x) {
	ieee_double_shape_type signbit_xh_u;
	signbit_xh_u.value = x;
	return (int)(signbit_xh_u.parts.msw & 0x80000000U);
}
/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
#define __signbit(x)   (int)__signbit((double)(x))


#if SUPPORTS_LONG_DOUBLE
/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
LIB_FUNC int signbitl(const long double x) {
	ieee854_long_double_shape_stype signbitl_xh_s;
	signbitl_xh_s.value = x;
	return (int)(((int64_t)signbitl_xh_s.parts64.msw) < (int64_t)0);
}
/** Return a non-zero value (true) if the sign of x is negative, and zero (false) otherwise; This can be also applied to infinites, NaNs and zeroes (if zero is unsigned, it is considered positive) */
#   define __signbitl(x)   (int)__signbitl((long double)(x))
/** Return a nonzero value if the sign of `X` is negative */
#   define SIGNBIT(x)   _Generic ((x), const float: signbitf((x)), float: signbitf((x)), const double: signbit((x)), double: signbit((x)), const long double: signbitl((x)), long double: signbitl((x)), default: 0)


#else

/** Return a nonzero value if the sign of `X` is negative */
#   define SIGNBIT(x)   _Generic ((x), const float: signbitf((x)), float: signbitf((x)), const double: signbit((x)), double: signbit((x)), default: 0)

#endif


// COPYSIGN

/** Returns a value with the magnitude of x and with the sign bit of y */
LIB_FUNC float copysignf(float x, const float y) {
	ieee_float_shape_type xf, yf;
	xf.value = x;
	yf.value = y;
	SET_FLOAT_WORD(x, (int)((uint32_t)(xf.word & 0x7fffffff) | (uint32_t)(yf.word & (uint32_t)0x80000000)));
	return x;
}
#define __copysignf(x, y)   copysignf((x), (y))


/** Returns a value with the magnitude of x and with the sign bit of y */
LIB_FUNC double copysign(double x, const double y) {
	ieee_double_shape_type x_u, y_u;
	x_u.value = x;
	y_u.value = y;
	SET_HIGH_WORD(x, (int)((uint32_t)(x_u.parts.msw & 0x7fffffff) | (uint32_t)(y_u.parts.msw & (uint32_t)0x80000000)));
	return x;
}
#define __copysign(x, y)   copysign((x), (y))


#if SUPPORTS_LONG_DOUBLE
/** Returns a value with the magnitude of x and with the sign bit of y */
LIB_FUNC long double copysignl(long double x, const long double y) {
	ieee854_long_double_shape_type xh_u, yh_u;
	xh_u.value = x;
	yh_u.value = y;
	register uint64_t hx = xh_u.parts64.msw;
	register uint64_t hy = yh_u.parts64.msw;
	SET_LDOUBLE_MSW64(x, (uint64_t)((uint64_t)(hx & (uint64_t)0x7fffffffffffffffULL) | (uint64_t)(hy & (uint64_t)0x8000000000000000ULL)));
	return x;
}
#   define __copysignl(x, y)   copysignl((x), (y))
#endif


// FPCLASSIFY

/** Returns a value of one of the classification macro constants, depending on the value of x */
LIB_FUNC MATHX_FUNC_ATTR int __fpclassifyf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t wx = xf_u.word;
	wx &= 0x7FFFFFFF;
	if (wx == 0x0) { return FP_ZERO; }
	else if (wx < 0x800000) { return FP_SUBNORMAL; }
	else if (wx >= 0x7F800000) { return ((wx > 0x7F800000) ? FP_NAN : FP_INFINITE); }
	else { return FP_NORMAL; }
}


/** Returns a value of one of the classification macro constants, depending on the value of x */
LIB_FUNC MATHX_FUNC_ATTR int __fpclassify(const double x) {
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	register uint32_t hx = xw_u.parts.msw;
	register uint32_t lx = xw_u.parts.lsw;
	lx |= (uint32_t)(hx & 0xfffff);
	hx &= 0x7ff00000;
	if ((hx | lx) == 0x0) { return FP_ZERO; }
	else if (hx == 0x0) { return FP_SUBNORMAL; }
	else if (hx == 0x7ff00000) { return ((lx != 0x0) ? FP_NAN : FP_INFINITE); }
	else { return FP_NORMAL; }
}


#if SUPPORTS_LONG_DOUBLE
/** Returns a value of one of the classification macro constants, depending on the value of x */
LIB_FUNC MATHX_FUNC_ATTR int __fpclassifyl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t hx = xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	lx |= (hx & 0xffffffffffffULL);
	hx &= 0x7fff000000000000ULL;
	if ((hx | lx) == 0) { return FP_ZERO; }
	else if (hx == 0) { return FP_SUBNORMAL; }
	else if (hx == 0x7fff000000000000ULL) { return ((lx != 0) ? FP_NAN : FP_INFINITE); }
	else { return FP_NORMAL; }
}
#endif


// FINITE & ISFINITE

/** Return 1 if x is finite, else 0 */
#define finitef(x)   __extension__ ({ ieee_float_shape_stype __finitef_xf_s; __finitef_xf_s.value = (x); (int)((uint32_t)((__finitef_xf_s.word & 0x7fffffff) - 0x7f800000) >> 31); })
/** Return 1 if x is finite, else 0 */
#define __finitef(x)   (int)finitef((float)(x))
#ifndef FINITEF
#   define FINITEF(x)   finitef((x))
#endif


/** Return 1 if x is finite, else 0 */
#define finite(x)   __extension__ ({ ieee_double_shape_stype __finite_xh_s; __finite_xh_s.value = (x); (int)((uint32_t)((__finite_xh_s.parts.msw & 0x7fffffff) - 0x7ff00000) >> 31); })
/** Return 1 if x is finite, else 0 */
#define __finite(x)   (int)finite((double)(x))
#ifndef FINITE
#   define FINITE(x)   finite((x))
#endif


#if SUPPORTS_LONG_DOUBLE
/** Return 1 if x is finite, else 0 */
#   define finitel(x)   __extension__ ({ ieee854_long_double_shape_type __finitel_x_u; __finitel_x_u.value = (x); (int)((uint64_t)((__finitel_x_u.parts64.msw & 0x7fffffffffffffffULL) - 0x7fff000000000000ULL) >> 63); })
/** Return 1 if x is finite, else 0 */
#   define __finitel(x)   (int)finitel((long double)(x))
/** Return a nonzero value if `X` is not +-Inf or NaN */
#   define ISFINITE(x)   _Generic ((x), const float: finitef((x)), float: finitef((x)), const double: finite((x)), double: finite((x)), const long double: finitel((x)), long double: finitel((x)), default: 0)

#else

/** Return a nonzero value if `X` is not +-Inf or NaN */
#   define ISFINITE(x)   _Generic ((x), const float: finitef((x)), float: finitef((x)), const double: finite((x)), double: finite((x)), default: 0)
#endif
#ifndef FINITEL
#   define FINITEL(x)   finitel((x))
#endif


/** Returns 1 is x is finite, else 0 */
LIB_FUNC int isfinitef(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;  // Finite numbers have at least one zero bit in exponent
	return (int)((xf_u.word | 0x807fffff) != 0xffffffff);  // All other numbers will result in 0xffffffff after OR
}
#define isnotfinitef(x)   (!isfinitef((x)))
#define is_not_finitef(x)   (!isfinitef((x)))


/** Returns 1 is x is finite, else 0 */
LIB_FUNC int isfinite(const double x) {
	ieee_double_shape_type xh_u;
	xh_u.value = x;  // Finite numbers have at least one zero bit in exponent
	return (int)((xh_u.parts.msw | (uint32_t)0x800fffff) != 0xffffffff);  // All other numbers will result in 0xffffffff after OR
}
#define isfinited(x)   isfinite((x))
#define isnotfinite(x)   (!isfinite((x)))
#define is_not_finite(x)   (!isfinite((x)))
#define is_not_finited(x)   (!isfinite((x)))


#if SUPPORTS_LONG_DOUBLE
/** Returns 1 is x is finite, else 0 */
LIB_FUNC int isfinitel(const long double x) {
	ieee854_long_double_shape_type xh_u;
	xh_u.value = x;
	register uint64_t hx = xh_u.parts64.msw;
	return (int)((uint64_t)((hx & 0x7fffffffffffffffULL) - 0x7fff000000000000ULL) >> 63);
}
#   define isnotfinitel(x)   (!isfinitel((x)))
#   define is_not_finitel(x)   (!isfinitel((x)))
#endif


// ISINF

/** Returns 1 if x is inf, -1 if x is -inf, else 0 */
LIB_FUNC int __isinff(const float x) {
	ieee_float_shape_stype xf_s;
	xf_s.value = x;
	register int32_t t = ((xf_s.word & (int32_t)0x7fffffff) ^ (int32_t)0x7f800000);
	return (int)(~((t | (-t)) >> 31) & (xf_s.word >> 30));
}
#define isinff(x)   __isinff((x))


/** Returns 1 if x is inf, -1 if x is -inf, else 0 */
LIB_FUNC int __isinf(const double x) {
	ieee_double_shape_stype xw_s;
	xw_s.value = x;
	register int32_t lx = (xw_s.parts.lsw | ((xw_s.parts.msw & (int32_t)0x7fffffff) ^ (int32_t)0x7ff00000));
	return (int)(~((lx | (-lx)) >> 31) & (xw_s.parts.msw >> 30));
}
#define isinfd(x)   __isinf((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns 1 if x is inf, -1 if x is -inf, else 0 */
LIB_FUNC int __isinfl(const long double x) {
	ieee854_long_double_shape_stype xw_s;
	xw_s.value = x;
	register int64_t lx = xw_s.parts64.lsw;
	lx |= (int64_t)((xw_s.parts64.msw & (int64_t)0x7fffffffffffffffLL) ^ (int64_t)0x7fff000000000000LL);
	return (int)(~((lx | (-lx)) >> 63) & (xw_s.parts64.msw >> 62));
}
#   define isinfl(x)   __isinfl((x))
#endif


/** Returns 1 if x is infinite, else 0 */
LIB_FUNC int __isinf_nsf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	return (int)(((int32_t)xf_u.word & 0x7fffffff) == 0x7f800000);
}


/** Returns 1 if x is infinite, else 0 */
LIB_FUNC int __isinf_ns(const double x) {
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	return (int)(!((int32_t)xw_u.parts.lsw | (((int32_t)xw_u.parts.msw & 0x7fffffff) ^ 0x7ff00000)));
}
#define isinf_nsd(x)   __isinf_ns((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns 1 if x is infinite, else 0 */
LIB_FUNC int __isinf_nsl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	return (int)(!((int64_t)xw_u.parts64.lsw | (int64_t)((xw_u.parts64.msw & 0x7fffffffffffffffULL) ^ 0x7fff000000000000ULL)));
}
#   define isinf_nsl(x)   __isinf_nsl((x))
#endif


// ISNAN & NAN

/** Returns 1 is x is nan, else 0 */
LIB_FUNC int __isnanf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	if ((uint32_t)(xf_u.word & 0x7fffffffU) > 0x7f800000U) { return 1; }
	return 0;
}
#define rpl_isnanf(x)   __isnanf((x))
#define isnanf(x)   __isnanf((x))


/** Returns 1 is x is nan, else 0 */
LIB_FUNC int __isnan(const double x) {
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	if ((xw_u.parts.msw & 0x7fffffffU) > 0x7ff00000U) { return 1; }
	return 0;
}
#define isnand(x)   __isnan((x))
#define rpl_isnand(x)   __isnand((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns 1 is x is nan, else 0 */
LIB_FUNC int __isnanl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	if ((xw_u.parts64.msw & 0x7fffffffU) > 0x7fff00000U) { return 1; }
	return 0;
}
/** Return a nonzero value if `X` is NaN */
#   define isnan(x)   _Generic ((x), const float: __isnanf((x)), float: __isnanf((x)), const double: __isnan((x)), double: __isnan((x)), const long double: __isnanl((x)), long double: __isnanl((x)), default: 0)
#   define isnanl(x)   __isnanl((x))
#   define rpl_isnanl(x)   __isnanl((x))
#else
/** Return a nonzero value if `X` is NaN */
#   define isnan(x)   _Generic ((x), const float: __isnanf((x)), float: __isnanf((x)), const double: __isnan((x)), double: __isnan((x)), default: 0)
#endif


/** Returns a quiet NaN (Not-A-Number) value */
LIB_FUNC float nanf(const char* tagp) {
	if (tagp[0] != '\0' && (tagp != (char*)NULL)) {
		const char buf[6 + strlen(tagp)];
		return strtof(buf, (const char**)NULL);
	}
	return NANF;
}


/** Returns a quiet NaN (Not-A-Number) value */
LIB_FUNC double nan(const char* tagp) {
	if (tagp[0] != '\0' && (tagp != (char*)NULL)) {
		const char buf[6 + strlen(tagp)];
		return strtod(buf, (const char**)NULL);
	}
	return NAN;
}
#define nand(x)   nan((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns a quiet NaN (Not-A-Number) value */
LIB_FUNC long double nanl(const char* tagp) {
	if (tagp[0] != '\0' && (tagp != (char*)NULL)) {
		const char buf[6 + strlen(tagp)];
		return strtold(buf, (const char**)NULL);
	}
	return NAN;
}
#endif


// ISSIGNALING

/** Returns 1 is x is signaling, else 0 */
LIB_FUNC int __issignalingf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	return (int)((((int32_t)xf_u.word & 0x7fc00000) == 0x7fc00000) && ((int32_t)xf_u.word ^ 0x7fc00000));
}


/** Returns 1 is x is signaling, else 0 */
LIB_FUNC int __issignaling(const double x) {
	ieee_double_shape_type x_u;
	x_u.value = x;
	return (int)((((int32_t)x_u.parts.msw & 0x7ff80000) == 0x7ff80000) && ((int64_t)x_u.dword ^ (int64_t)0x7ff8000000000000));
}


#if SUPPORTS_LONG_DOUBLE
/** Returns 1 is x is signaling, else 0 */
LIB_FUNC int __issignalingl(const long double x) {
	ieee854_long_double_shape_type x_u;
	x_u.value = x;
	return (int)((x_u.parts64.msw & (uint64_t)0x7fff800000000000ULL) == (uint64_t)0x7fff800000000000ULL);
}
/** Return a nonzero value if `X` is a signaling NaN */
#   define issignaling(x)   _Generic ((x), const float: __issignalingf((x)), float: __issignalingf((x)), const double: __issignaling((x)), double: __issignaling((x)), const long double: __issignalingl((x)), long double: __issignalingl((x)), default: 0)

#else

/** Return a nonzero value if `X` is a signaling NaN */
#   define issignaling(x)   _Generic ((x), const float: __issignalingf((x)), float: __issignalingf((x)), const double: __issignaling((x)), double: __issignaling((x)), default: 0)
#endif


// ISNORMAL

/** Return a nonzero value if `X` is neither zero, subnormal, Inf, nor NaN */
#define isnormal(x)   _Generic ((x), const float: (__fpclassifyf((x)) == FP_NORMAL), float: (__fpclassifyf((x)) == FP_NORMAL), const double: (__fpclassify((x)) == FP_NORMAL), double: (__fpclassify((x)) == FP_NORMAL), const long double: (__fpclassifyl((x)) == FP_NORMAL), long double: (__fpclassifyl((x)) == FP_NORMAL), default: 0)


// ISGREATER, ISLESS, ETC.


// ISO C99 defines some macros to compare numbers while taking care for unordered numbers; Many FPUs provide special instructions to support these operations

/** Return the number of the float-point's classification */
#define fpclassify(x)   _Generic ((x), const float: __fpclassifyf((x)), float: __fpclassifyf((x)), const double: __fpclassify((x)), double: __fpclassify((x)), const long double: __fpclassifyl((x)), long double: __fpclassifyl((x)), default: 0)


#ifndef isunordered
/** Return a nonzero value if arguments are unordered */
#   define __isunorderedf(u, v)   (__extension__ ({ float __u = (float)(u); float __v = (float)(v); __fpclassifyf(__u) == FP_NAN || __fpclassifyf(__v) == FP_NAN; }))
/** Return a nonzero value if arguments are unordered */
#   define __isunordered(u, v)   (__extension__ ({ double __u = (u); double __v = (v); __fpclassify(__u) == FP_NAN || __fpclassify(__v) == FP_NAN; }))
/** Return a nonzero value if arguments are unordered */
#   define __isunorderedl(u, v)   (__extension__ ({ long double __u = (u); long double __v = (v); __fpclassifyl(__u) == FP_NAN || __fpclassifyl(__v) == FP_NAN; }))
/** Return a nonzero value if arguments are unordered */
#   define isunordered(u, v)   _Generic ((u), const float: __isunorderedf((u), (v)), float: __isunorderedf((u), (v)), const double: __isunordered((u), (v)), double: __isunordered((u), (v)), const long double: __isunorderedl((u), (v)), long double: __isunorderedl((u), (v)), default: 0)
#endif


/** Return a nonzero value if `X` is positive or negative infinity */
#define isinf(x)   _Generic ((x), const float: __isinff((x)), float: __isinff((x)), const double: __isinf((x)), double: __isinf((x)), const long double: __isinfl((x)), long double: __isinfl((x)), default: 0)


#ifndef isgreater
/** Return a nonzero value if X is greater than Y */
#   define __isgreaterf(x, y)   (__extension__ ({ float __x = (x); float __y = (y); (!__isunorderedf(__x, __y)) && (__x > __y); }))
/** Return a nonzero value if X is greater than Y */
#   define __isgreater(x, y)   (__extension__ ({ double __x = (x); double __y = (y); (!__isunordered(__x, __y)) && (__x > __y); }))
/** Return a nonzero value if X is greater than Y */
#   define __isgreaterl(x, y)   (__extension__ ({ long double __x = (x); long double __y = (y); (!__isunorderedl(__x, __y)) && (__x > __y); }))
/** Return a nonzero value if X is greater than Y */
#   define isgreater(x, y)   _Generic ((x), const float: __isgreaterf((x), (y)), float: __isgreaterf((x), (y)), const double: __isgreater((x), (y)), double: __isgreater((x), (y)), const long double: __isgreaterl((x), (y)), long double: __isgreaterl((x), (y)), default: 0)
#endif


#ifndef isgreaterequal
/** Return a nonzero value if X is greater than or equal to Y */
#   define __isgreaterequalf(x, y)   (__extension__ ({ float __x = (x); float __y = (y); (!__isunorderedf(__x, __y)) && (__x >= __y); }))
/** Return a nonzero value if X is greater than or equal to Y */
#   define __isgreaterequal(x, y)   (__extension__ ({ double __x = (x); double __y = (y); (!__isunordered(__x, __y)) && (__x >= __y); }))
/** Return a nonzero value if X is greater than or equal to Y */
#   define __isgreaterequall(x, y)   (__extension__ ({ long double __x = (x); long double __y = (y); (!__isunorderedl(__x, __y)) && (__x >= __y); }))
/** Return a nonzero value if X is greater than or equal to Y */
#   define isgreaterequal(x, y)   _Generic ((x), const float: __isgreaterequalf((x), (y)), float: __isgreaterequalf((x), (y)), const double: __isgreaterequal((x), (y)), double: __isgreaterequal((x), (y)), const long double: __isgreaterequall((x), (y)), long double: __isgreaterequall((x), (y)), default: 0)
#endif


#ifndef isless
/** Return a nonzero value if X is less than Y */
#   define __islessf(x, y)   (__extension__ ({ float __x = (x); float __y = (y); (!__isunorderedf(__x, __y)) && (__x < __y); }))
/** Return a nonzero value if X is less than Y */
#   define __isless(x, y)   (__extension__ ({ double __x = (x); double __y = (y); (!__isunordered(__x, __y)) && (__x < __y); }))
/** Return a nonzero value if X is less than Y */
#   define __islessl(x, y)   (__extension__ ({ long double __x = (x); long double __y = (y); (!__isunorderedl(__x, __y)) && (__x < __y); }))
/** Return a nonzero value if X is less than Y */
#   define isless(x, y)   _Generic ((x), const float: __islessf((x), (y)), float: __islessf((x), (y)), const double: __isless((x), (y)), double: __isless((x), (y)), const long double: __islessl((x), (y)), long double: __islessl((x), (y)), default: 0)
#endif


#ifndef islessequal
/** Return a nonzero value if X is less than or equal to Y */
#   define __islessequalf(x, y)   (__extension__ ({ float __x = (x); float __y = (y); (!__isunorderedf(__x, __y)) && (__x <= __y); }))
/** Return a nonzero value if X is less than or equal to Y */
#   define __islessequal(x, y)   (__extension__ ({ double __x = (x); double __y = (y); (!__isunordered(__x, __y)) && (__x <= __y); }))
/** Return a nonzero value if X is less than or equal to Y */
#   define __islessequall(x, y)   (__extension__ ({ long double __x = (x); long double __y = (y); (!__isunorderedl(__x, __y)) && (__x <= __y); }))
/** Return a nonzero value if X is less than or equal to Y */
#   define islessequal(x, y)   _Generic ((x), const float: __islessequalf((x), (y)), float: __islessequalf((x), (y)), const double: __islessequal((x), (y)), double: __islessequal((x), (y)), const long double: __islessequall((x), (y)), long double: __islessequall((x), (y)), default: 0)
#endif


#ifndef islessgreater
/** Return a nonzero value if either X is less than Y or Y is less than X */
#   define __islessgreaterf(x, y)   (__extension__ ({ float __x = (x); float __y = (y); (!__isunorderedf(__x, __y)) && ((__x < __y) || (__y < __x)); }))
/** Return a nonzero value if either X is less than Y or Y is less than X */
#   define __islessgreater(x, y)   (__extension__ ({ double __x = (x); double __y = (y); (!__isunordered(__x, __y)) && ((__x < __y) || (__y < __x)); }))
/** Return a nonzero value if either X is less than Y or Y is less than X */
#   define __islessgreaterl(x, y)   (__extension__ ({ long double __x = (x); long double __y = (y); (!__isunorderedl(__x, __y)) && ((__x < __y) || (__y < __x)); }))
/** Return a nonzero value if either X is less than Y or Y is less than X */
#   define islessgreater(x, y)   _Generic ((x), const float: __islessgreaterf((x), (y)), float: __islessgreaterf((x), (y)), const double: __islessgreater((x), (y)), double: __islessgreater((x), (y)), const long double: __islessgreaterl((x), (y)), long double: __islessgreaterl((x), (y)), default: 0)
#endif


// FLOAT MAX, MIN, & DIM

/** Returns the larger of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC float fmaxf(const float x, const float y) {
	if (PREDICT_UNLIKELY(__fpclassifyf(x) == FP_NAN)) { return (float)x; }
	else if (PREDICT_UNLIKELY(__fpclassifyf(y) == FP_NAN)) { return (float)y; }
	return (float)((x > y) ? x : y);
}


/** Returns the larger of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC double fmax(const double x, const double y) {
	if (PREDICT_UNLIKELY(__fpclassify(x) == FP_NAN)) { return (double)x; }
	else if (PREDICT_UNLIKELY(__fpclassify(y) == FP_NAN)) { return (double)y; }
	return (double)((x > y) ? x : y);
}


#if SUPPORTS_LONG_DOUBLE
/** Returns the larger of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC long double fmaxl(const long double x, const long double y) {
	if (PREDICT_UNLIKELY(__fpclassifyl(x) == FP_NAN)) { return (long double)x; }
	else if (PREDICT_UNLIKELY(__fpclassifyl(y) == FP_NAN)) { return (long double)y; }
	return (long double)((x > y) ? x : y);
}
#endif


/** Returns the smaller of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC float fminf(const float x, const float y) {
	if (__fpclassifyf(x) == FP_NAN) { return (float)x; }
	else if (__fpclassifyf(y) == FP_NAN) { return (float)y; }
	return (float)((x < y) ? x : y);
}


/** Returns the smaller of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC double fmin(const double x, const double y) {
	if (__fpclassify(x) == FP_NAN) { return (double)x; }
	else if (__fpclassify(y) == FP_NAN) { return (double)y; }
	return (double)((x < y) ? x : y);
}


#if SUPPORTS_LONG_DOUBLE
/** Returns the smaller of the two arguments (either x or y); If one of the arguments in a NaN, the other is returned */
LIB_FUNC long double fminl(const long double x, const long double y) {
	if (__fpclassifyl(x) == FP_NAN) { return (long double)x; }
	else if (__fpclassifyl(y) == FP_NAN) { return (long double)y; }
	return (long double)((x < y) ? x : y);
}
#endif


/** Return the positive difference between x and y; Returns `x-y` if `x>y`, or zero otherwise */
LIB_FUNC float fdimf(const float x, const float y) {
	register int c = __fpclassifyf(x);
	if (PREDICT_UNLIKELY(c == FP_NAN || c == FP_INFINITE)) { return HUGEF; }
	return (float)((x > y) ? (x - y) : 0.0F);
}


/** Return the positive difference between x and y; Returns `x-y` if `x>y`, or zero otherwise */
LIB_FUNC double fdim(const double x, const double y) {
	register int c = __fpclassify(x);
	if (PREDICT_UNLIKELY(c == FP_NAN || c == FP_INFINITE)) { return HUGE; }
	return (double)((x > y) ? (x - y) : 0.0);
}


#if SUPPORTS_LONG_DOUBLE
/** Return the positive difference between x and y; Returns `x-y` if `x>y`, or zero otherwise */
LIB_FUNC long double fdiml(const long double x, const long double y) {
	register int c = __fpclassifyl(x);
	if (PREDICT_UNLIKELY(c == FP_NAN || c == FP_INFINITE)) { return HUGEL; }
	return (long double)((x > y) ? (x - y) : 0.0L);
}
#endif


// CEILING, FLOOR, ROUND, TRUNC, ETC.

/** Return x rounded toward inf to integral value; An inexact flag is raised if x not equal to ceil(x) */
LIB_FUNC float ceilf(float x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	float z;
	asm volatile ("frip %0, %1;" "frsp %0, %0;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_float_shape_stype xf_s;
	xf_s.value = x;
	register int32_t i0 = xf_s.word;
	register int32_t j0 = (int32_t)((i0 >> 23) & 0xff) - 0x7f;
	if (PREDICT_LIKELY(j0 < 23)) {
		if (j0 < 0) {  // Raise inexact if x != 0
			raise_flag(HUGEF + x);  // Return 0*sign(x) if |x|<1
			if (i0 < 0) { i0 = (int32_t)0x80000000; }
			else if (i0 != 0) { i0 = 0x3f800000;}
		} else {
			register uint32_t i = (uint32_t)((0x7fffff) >> j0);
			if ((uint32_t)((uint32_t)i0 & i) == (uint32_t)0) { return (float)x; }  // x is integral
			raise_flag(HUGEF + x);  // Raise inexact flag
			if (i0 > 0) { i0 += (int32_t)((0x800000) >> j0); }
			i0 &= ((int32_t)(~i));
		}
	} else {
		if (j0 == 0x80) { return (float)(x + x); }  // inf or NaN
		else { return (float)x; }  // x is integral
	}
	SET_FLOAT_WORD(x, i0);
	return (float)x;
#   endif
}


/** Return x rounded toward inf to integral value; An inexact flag is raised if x not equal to ceil(x) */
LIB_FUNC double ceil(double x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	double z;
	asm volatile ("frip %0, %1;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_double_shape_stype xw_s;
	xw_s.value = x;
	register int32_t i0 = xw_s.parts.msw;
	register int32_t i1 = xw_s.parts.lsw;
	register int32_t j0 = (int32_t)((i0 >> 20) & 0x7ff) - 0x3ff;
	if (PREDICT_LIKELY(j0 < 20)) {
		if (j0 < 0) {  // Raise inexact if x != 0
			if ((HUGE + x) > 0.0) {  // Return 0*sign(x) if |x|<1
				if (i0 < 0) { i0 = (int32_t)0x80000000; i1 = 0; }
				else if ((i0 | i1) != 0) { i0 = 0x3ff00000; i1 = 0; }
			}
		} else {
			register int32_t i = (int32_t)(0xfffff >> j0);
			if (((int32_t)(i0 & i) | i1) == 0) { return x; }  // x is integral
			else if ((HUGE + x) > 0.0) {  // Raise inexact flag
				if (i0 > 0) { i0 += (0x100000 >> j0); }
				i0 &= ((int32_t)(~i));
				i1 = 0;
			}
		}
	} else if (j0 > 51) {
		if (j0 == 0x400) { return (x + x); }  // inf or NaN
		else { return x; }  // x is integral
	} else {
		register int32_t i = ((int32_t)0xffffffff) >> (j0 - 20);
		if ((int32_t)(i1 & i) == 0) { return x; }  // x is integral
		else if ((HUGE + x) > 0.0) {  // Raise inexact flag
			if (i0 > 0) {
				if (j0 == 20) { i0 += 1; }
				else {
					register int32_t j = (int32_t)(i1 + (1 << (52 - j0)));
					if (j < i1) { i0 += 1; }  // Got a carry
					i1 = (int32_t)j;
				}
			}
			i1 &= ((int32_t)(~i));
		}
	}
	xw_s.parts.msw = (int32_t)i0;
	xw_s.parts.lsw = (int32_t)i1;
	return xw_s.value;
#   endif
}


#if SUPPORTS_LONG_DOUBLE
/** Return x rounded toward inf to integral value; An inexact flag is raised if x not equal to ceil(x) */
LIB_FUNC long double ceill(long double x) {
	ieee854_long_double_shape_stype qw;
	qw.value = x;
	register int64_t i0 = qw.parts64.msw;
	register int64_t i1 = qw.parts64.lsw;
	register int64_t j0 = (((i0 >> 48) & 0x7fff) - 0x3fff);
	register int64_t i;
	if (PREDICT_LIKELY(j0 < 48)) {
		if (j0 < 0x0) {  // Raise inexact if x != 0
			if ((HUGEL + x) > 0.0L) {  // Return 0*sign(x) if |x|<1
				if (i0 < 0x0) { i0 = (int64_t)0x8000000000000000LL; i1 = 0x0; }
				else if ((i0 | i1) != 0x0) { i0 = (int64_t)0x3fff000000000000LL; i1= 0x0; }
			}
		} else {
			i = (int64_t)((0xffffffffffffLL) >> j0);
			if (((i0 & i) | i1) == 0) { return x; }  // x is integral
			if ((HUGEL + x) > 0.0L) {  // Raise inexact flag
				if (i0 > 0) { i0 += (int64_t)((0x1000000000000LL) >> j0); }
				i0 &= (~i);
				i1 = 0;
			}
		}
	} else if (j0 > 111) {
		if (j0 == 0x4000) { return (x + x); }  // inf or NaN
		else { return x; }  // x is integral
	} else {
		i = ((-1LL) >> (j0 - 48));
		if ((i1 & i) == 0x0) { return x; }  // x is integral
		if ((HUGEL + x) > 0.0L) {  // raise inexact flag
			if (i0 > 0x0) {
				if (j0 == 48) { i0 += 0x1; }
				else {
					register int64_t j = i1 + (0x1LL << (112 - j0));
					if (j < i1) { i0 += 0x1 ; }  // got a carry
					i1 = j;
				}
			}
			i1 &= (~i);
		}
	}
	SET_LDOUBLE_WORDS64(x, i0, i1);
	return x;
}
#endif


/** Return x rounded toward -inf (downward) to an integral value that is not greater than x; An inexact is flag raised if x is not equal to floor(x) */
LIB_FUNC float floorf(float x) {
#   if ((defined(ARCHX86_64) || defined(ARCHX86) || defined(ARCHI386)) && (CPU_SSE4_1 || CPU_AVX || CPU_SSE2AVX))
	float res;
#      if (CPU_AVX || CPU_SSE2AVX)
	asm ("vroundss $1, %1, %0, %0;" : "=x"(res) : "xm"(x));
#      elif CPU_SSE4_1
	asm ("roundss $1, %1, %0;" : "=x"(res) : "xm"(x));
#      endif
	return res;
#   elif (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	float z;
	asm volatile ("frim %0, %1;" "frsp %0, %0;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register int32_t i0 = (int32_t)xf_u.word;
	register int32_t j0 = (int32_t)(((i0 >> 23) & 0xff) - 0x7f);
	if (PREDICT_LIKELY(j0 < 23)) {
		if (j0 < 0) {  // Raise inexact if x != 0
			raise_flag(HUGEF + x);  // Return 0*sign(x) if |x|<1
			if (i0 >= 0) { i0 = 0; }
			else if ((i0 & 0x7fffffff) != 0) { i0 = (int32_t)0xbf800000; }
		} else {
			register int32_t i = (int32_t)((0x7fffff) >> j0);
			if ((i0 & i) == 0) { return (float)x; }  // x is integral
			raise_flag(HUGEF + x);  // Raise inexact flag
			if (i0 < 0) { i0 += (int32_t)((0x800000) >> j0); }
			i0 &= ((int32_t)(~i));
		}
	} else {
		if (PREDICT_UNLIKELY(j0 == 0x80)) { return (float)(x + x); }  // inf or NaN
		else { return (float)x; }  // x is integral
	}
	SET_FLOAT_WORD(x, i0);
	return (float)x;
#   endif
}


/** Return x rounded toward -inf (downward) to an integral value that is not greater than x; An inexact is flag raised if x is not equal to floor(x) */
LIB_FUNC double floor(double x) {
#   if ((defined(ARCHX86_64) || defined(ARCHX86) || defined(ARCHI386)) && (CPU_SSE4_1 || CPU_AVX || CPU_SSE2AVX))
	double res;
#      if (CPU_AVX || CPU_SSE2AVX)
	asm ("vroundsd $1, %1, %0, %0;" : "=x"(res) : "xm"(x));
#      elif CPU_SSE4_1
	asm ("roundsd $1, %1, %0;" : "=x"(res) : "xm"(x));
#      endif
	return res;
#   elif (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	double z;
	asm volatile ("frim %0, %1;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	register int32_t i0 = (int32_t)xw_u.parts.msw;
	register int32_t i1 = (int32_t)xw_u.parts.lsw;
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	if (PREDICT_LIKELY(j0 < 20)) {
		if (j0 < 0) {  // Raise inexact if x != 0
			if (HUGE + x > 0.0) {  // Return 0*sign(x) if |x|<1
				if (i0 >= 0) { i0 = i1 = 0; }
				else if (((i0 & 0x7fffffff) | i1) != 0x0) { i0 = (int32_t)0xbff00000; i1 = 0; }
			}
		} else {
			register int32_t i = (int32_t)((0xfffff) >> j0);
			if (((i0 & i) | i1) == 0) { return x; }  // x is integral
			if ((HUGE + x) > 0.0) {  // Raise inexact flag
				if (i0 < 0) { i0 += (int32_t)((0x100000) >> j0); }
				i0 &= ((int32_t)(~i));
				i1 = 0;
			}
		}
	} else if (j0 > 51) {
		if (PREDICT_UNLIKELY(j0 == 0x400)) { return (x + x); }  // inf or NaN
		else { return x; }  // x is integral
	} else {
		register int32_t i = ((int32_t)(0xffffffff)) >> (j0 - 20);
		if ((i1 & i) == 0) { return x; }  // x is integral
		if ((HUGE + x) > 0.0) {  // Raise inexact flag
			if (i0 < 0) {
				if (j0 == 20) { ++i0; }
				else {
					register int32_t j = (int32_t)(i1 + (1 << (52 - j0)));
					if (j < i1) { ++i0; }  // Got a carry
					i1 = j;
				}
			}
			i1 &= ((int32_t)(~i));
		}
	}
	xw_u.parts.msw = (uint32_t)i0;
	xw_u.parts.lsw = (uint32_t)i1;
	return xw_u.value;
#   endif
}


#if SUPPORTS_LONG_DOUBLE
/** Return x rounded toward -inf (downward) to an integral value that is not greater than x; An inexact is flag raised if x is not equal to floor(x) */
LIB_FUNC long double floorl(long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register int64_t i0 = (int64_t)xw_u.parts64.msw;
	register int64_t i1 = (int64_t)xw_u.parts64.lsw;
	register int64_t j0 = (int64_t)((i0 >> 48) & 0x7fff) - 0x3fff;
	if (PREDICT_LIKELY(j0 < 48)) {
		if (j0 < 0) {  // Raise inexact if x != 0
			if (HUGEL + x > 0.0L) {  // Return 0*sign(x) if |x|<1
				if (i0 >= 0x0) { i0 = i1 = 0; }
				else if (((i0 & (int64_t)0x7fffffffffffffffLL) | i1) != 0) { i0 = (int64_t)0xbfff000000000000LL; i1 = 0; }
			}
		} else {
			register int64_t i = (int64_t)((0xffffffffffffLL) >> j0);
			if (((i0 & i) | i1) == 0) { return x; }  // x is integral
			if (HUGEL + x > 0.0L) {  // Raise inexact flag
				if (i0 < 0) { i0 += (int64_t)((0x1000000000000LL) >> j0); }
				i0 &= ((int64_t)(~i));
				i1 = 0;
			}
		}
	} else if (j0 > 111) {
		if (PREDICT_UNLIKELY(j0 == 0x4000)) { return (x + x); }  // inf or NaN
		else { return x; }  // x is integral
	} else {
		register int64_t i = (int64_t)((-1LL) >> (j0 - 48));
		if ((i1 & i) == 0x0) { return x; }  // x is integral
		if (HUGEL + x > 0.0L) {  // Raise inexact flag
			if (i0 < 0x0) {
				if (j0 == 48) { ++i0; }
				else {
					register int64_t j = (int64_t)(i1 + (1LL << (112 - j0)));
					if (j < i1) { ++i0; }  // Got a carry
					i1 = (int64_t)j;
				}
			}
			i1 &= ((int64_t)(~i));
		}
	}
	SET_LDOUBLE_WORDS64(x, i0, i1);
	return x;
}
#endif


LIB_FUNC int round_intf(const float x) {
	return (int)((x > 0.0F) ? (x + 0.5F) : (x - 0.5F));
}


LIB_FUNC int round_int(const double x) {
	return (int)((x > 0.0) ? (x + 0.5) : (x - 0.5));
}


/** Returns the integral value that is nearest to x, with halfway cases rounded away from zero */
LIB_FUNC float roundf(const float x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	float z;
	asm volatile ("frin %0, %1;" "frsp %0, %0;" : "=f"(z) : "f"(x));
	return z;
#   else
	return (float)floorf(((x > 0.0F) ? (x + 0.5F) : (x - 0.5F)));
#   endif
}


/** Returns the integral value that is nearest to x, with halfway cases rounded away from zero */
LIB_FUNC double round(const double x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	double z;
	asm volatile ("frin %0, %1;" : "=f"(z) : "f"(x));
	return z;
#   else
	return (double)floor(((x > 0.0) ? (x + 0.5) : (x - 0.5)));
#   endif
}
#define __round(x)   round((x))


#if SUPPORTS_LONG_DOUBLE
/** Returns the integral value that is nearest to x, with halfway cases rounded away from zero */
LIB_FUNC long double roundl(const long double x) {
	return (long double)floorl(((x > 0.0L) ? (x + 0.5L) : (x - 0.5L)));
}
#endif


/** Round up the given digit string; If the digit string is fff...f, this procedure sets it to 100...0 and returns 1 to indicate that the exponent needs to be bumped; Otherwise, 0 is returned */
LIB_FUNC int roundup(char* restrict s0, const int ndigits) {
	char* s;
	for (s = (s0 + ndigits - 1); *s == 0xf; s--) {
		if (s == s0) {
			*s = 1;
			return 1;
		}
		*s = 0;
	}
	++*s;
	return 0;
}


/** Return x rounded to integral value according to the prevailing rounding mode; An inexact flag is raised if x not equal to rintl(x) */
LIB_FUNC float rintf(const float x) {
#   if ((defined(ARCHX86_64) || defined(ARCHX86) || defined(ARCHI386)) && (CPU_SSE4_1 || CPU_AVX || CPU_SSE2AVX))
	float res;
#      if (CPU_AVX || CPU_SSE2AVX)
	asm ("vroundss $4, %1, %0, %0;" : "=x"(res) : "xm"(x));
#      elif CPU_SSE4_1
	asm ("roundss $4, %1, %0;" : "=x"(res) : "xm"(x));
#      endif
	return res;
#   else
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i0 = xf_u.word;
	register uint32_t sx = (uint32_t)((i0 >> 31) & 1);
	register int32_t j0 = (int32_t)((((int32_t)i0 >> 23) & 0xff) - 0x7f);
	if (PREDICT_LIKELY(j0 < 23)) {
		if (j0 < 0) {
			ieee_float_shape_type tf_u;
			tf_u.value = (float)((TWO23[sx] + x) - TWO23[sx]);
			i0 = tf_u.word;
			tf_u.word = (uint32_t)((i0 & (uint32_t)0x7fffffff) | (uint32_t)(sx << 31));
			return (float)tf_u.value;
		}
	} else {
		if (j0 == 0x80) { return (float)(x + x); }  // inf or NaN
		else { return (float)x; }  // x is integral
	}
	return (float)((TWO23[sx]+x) - TWO23[sx]);
#   endif
}
#define __rintf(x)   rintf((x))


/** Return x rounded to integral value according to the prevailing rounding mode; An inexact flag is raised if x not equal to rintl(x) */
LIB_FUNC double rint(const double x) {
#   if ((defined(ARCHX86_64) || defined(ARCHX86) || defined(ARCHI386)) && (CPU_SSE4_1 || CPU_AVX || CPU_SSE2AVX))
	double res;
#      if (CPU_AVX || CPU_SSE2AVX)
	asm ("vroundsd $4, %1, %0, %0;" : "=x"(res) : "xm"(x));
#      elif CPU_SSE4_1
	asm ("roundsd $4, %1, %0;" : "=x"(res) : "xm"(x));
#      endif
	return res;
#   else
	ieee_double_shape_type xh_u;
	xh_u.value = x;
	register uint32_t i0 = xh_u.parts.msw;
	register const uint32_t sx = (uint32_t)(((uint32_t)i0 >> 31) & 1);
	register int32_t j0 = (int32_t)((((int32_t)i0 >> 20) & 0x7ff) - 0x3ff);
	if (PREDICT_LIKELY(j0 < 52)) {
		if (j0 < 0) {
			ieee_double_shape_type th_u;
			th_u.value = (double)((TWO52[sx] + x) - TWO52[sx]);
			i0 = th_u.parts.msw;
			th_u.parts.msw = (uint32_t)((i0 & (uint32_t)0x7fffffff) | (uint32_t)(sx << 31));
			return (double)th_u.value;
		}
	} else {
		if (j0 == 0x400) { return (double)(x + x); }  // inf or NaN
		else { return (double)x; }  // x is integral
	}
	return (double)((TWO52[sx] + x) - TWO52[sx]);
#   endif
}
#define __rint(x)   rint((x))


#if SUPPORTS_LONG_DOUBLE
/** Return x rounded to integral value according to the prevailing rounding mode; An inexact flag is raised if x not equal to rintl(x) */
LIB_FUNC long double rintl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t sx = (uint64_t)(((uint64_t)i0) >> 63);
	register int64_t j0 = (int64_t)((((int64_t)i0 >> 48) & 0x7fff) - 0x3fff);
	if (PREDICT_LIKELY(j0 < 112)) {
		if (j0 < 0x0) {
			ieee854_long_double_shape_type th_u;
			th_u.value = (long double)((TWO112[sx] + x) - TWO112[sx]);
			i0 = th_u.parts64.msw;
			th_u.parts64.msw = (uint64_t)((i0 & (uint64_t)0x7fffffffffffffffLL) | (uint64_t)(sx << 63));
			return (long double)th_u.value;
		}
	} else {
		if (j0 == 0x4000) { return (long double)(x + x); }  // inf or NaN
		else { return (long double)x; }  // x is integral
	}
	return (long double)((TWO112[sx] + x) - TWO112[sx]);
}
#   define __rintl(x)   rintl((x))
#endif


/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long lrintf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i0 = xf_u.word;
	register long sx = (long)(i0 >> 31);
	register int32_t j0 = (int32_t)(((i0 >> 23) & 0xff) - 0x7f);
	i0 = (uint32_t)((i0 & 0x7fffff) | 0x800000);
	register long result;
	if (j0 < ((int32_t)(SIZEOF_LONG * 8) - 1)) {
		if (j0 >= 23) { result = (long)(i0 << (uint32_t)(j0 - 23)); }
		else {
			ieee_float_shape_type tf_u;
			tf_u.value = (float)((TWO23[sx] + x) - TWO23[sx]);
			i0 = tf_u.word;
			j0 = (int32_t)(((i0 >> 23) & 0xff) - 0x7f);
			i0 = (uint32_t)((i0 & (uint32_t)0x7fffff) | (uint32_t)0x800000);
			result = (long)((j0 < 0) ? 0 : (i0 >> (23 - j0)));
		}
	} else { return (long)x; }  // The number is too large
	return (long)(sx ? (-result) : result);
}
#define __lrintf(x)   lrintf((x))


/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long lrint(const double x) {
	register uint32_t i0, i1;
	ieee_double_shape_type ew_u;
	ew_u.value = (double)((x));
	i0 = (uint32_t)ew_u.parts.msw;
	i1 = (uint32_t)ew_u.parts.lsw;
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	register long sx = (long)(i0 >> 31);
	i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
	register long result;
	if (j0 < 20) {
		register double t = (double)((TWO52[sx] + x) - TWO52[sx]);
		ew_u.value = (double)((t));
		i0 = (uint32_t)ew_u.parts.msw;
		i1 = (uint32_t)ew_u.parts.lsw;
		j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
		i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
		result = (long)((j0 < 0) ? 0 : ((int32_t)i0 >> (20 - j0)));
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG) - 1) {
		if (j0 >= 52) { result = (long)(((int32_t)i0 << (j0 - 20)) | (int32_t)((int32_t)i1 << (j0 - 52))); }
		register double t = (double)((TWO52[sx] + x) - TWO52[sx]);
		EXTRACT_WORDS(i0, i1, t);
		j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
		i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
		if (j0 == 20) { result = (long)i0; }
		else { result = (long)((int32_t)i0 << (j0 - 20)) | (int32_t)((int32_t)i1 >> (52 - j0)); }
	} else { return (long)x; }  // The number is too large
	return (long)(sx ? (-result) : result);
}
#define __lrint(x)   lrint((x))


#if SUPPORTS_LONG_DOUBLE
/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long lrintl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t i1 = xw_u.parts64.lsw;
	register int32_t j0 = (int32_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	register long sx = (long)(i0 >> 63);
	i0 = (uint64_t)((i0 & 0xffffffffffffULL) | 0x1000000000000ULL);
	register long result;
	if (j0 < 48) {
		ieee854_long_double_shape_type tw_u;
		tw_u.value = (long double)((TWO112[sx] + x) - TWO112[sx]);
		i0 = tw_u.parts64.msw;
		j0 = (int32_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
		i0 = (uint64_t)((i0 & (uint64_t)0xffffffffffffULL) | (uint64_t)0x1000000000000ULL);
		result = (long)((j0 < 0) ? 0 : (i0 >> (48 - j0)));
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG) - 1) {
		if (j0 >= 112) { result = (long)((i0 << (j0 - 48)) | (i1 << (j0 - 112))); }
		else {
			ieee854_long_double_shape_type tw_u;
			tw_u.value = (long double)((TWO112[sx] + x) - TWO112[sx]);
			i0 = tw_u.parts64.msw;
			j0 = (int32_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
			i0 = (uint64_t)((i0 & 0xffffffffffffULL) | 0x1000000000000ULL);
			if (j0 == 48) { result = (long)i0; }
			else { result = (long)((int32_t)(((int64_t)i0) << (j0 - 48)) | (int32_t)(((int64_t)tw_u.parts64.lsw) >> (112 - j0))); }
		}
	} else { return (long)x; }  // The number is too large
	return (long)(sx ? (-result) : result);
}
#   define __lrintl(x)   lrintl((x))
#endif


/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long long llrintf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i0 = xf_u.word;
	register const int32_t sx = (int32_t)(i0 >> 31);
	register int32_t j0 = (int32_t)((i0 >> 23) & 0xff) - 0x7f;
	i0 = (uint32_t)((i0 & 0x7fffff) | 0x800000);
	register long long result;
	if (j0 < (int32_t)(SIZEOF_LONG_LONG * 8) - 1) {
		if (j0 >= 23) { result = (long long)i0 << (j0 - 23); }
		else {
			ieee_float_shape_type tf_u;
			tf_u.value = ((TWO23[sx] + x) - TWO23[sx]);
			i0 = tf_u.word;
			j0 = (int32_t)(((i0 >> 23) & 0xff) - 0x7f);
			i0 = (uint32_t)((i0 & 0x7fffff) | 0x800000);
			result = ((j0 < 0) ? 0 : (i0 >> (23 - j0)));
		}
	} else { return (long long)x; }  // The number is too large
	return (long long)(sx ? (-result) : result);
}
#define __llrintf(x)   llrintf((x))


/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long long llrint(const double x) {
	register uint32_t i1, i0;
	EXTRACT_WORDS(i0, i1, x);
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	register int32_t sx = (int32_t)(i0 >> 31);
	i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
	register long long result;
	if (PREDICT_LIKELY(j0 < 20)) {
		register double t = ((TWO52[sx] + x) - TWO52[sx]);
		EXTRACT_WORDS(i0, i1, t);
		j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
		i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
		result = ((j0 < 0) ? 0 : (i0 >> (20 - j0)));
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG_LONG) - 1) {
		if (j0 >= 52) { result = (((long long)i0 << 32) | i1) << (j0 - 52); }
		else {
			register double t = ((TWO52[sx] + x) - TWO52[sx]);
			EXTRACT_WORDS(i0, i1, t);
			j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
			i0 = (uint32_t)((i0 & 0xfffff) | 0x100000);
			if (j0 == 20) { result = (long long)i0; }
			else { result = ((long long)i0 << (j0 - 20)) | (i1 >> (52 - j0)); }
		}
	} else { return (long long)x; }  // The number is too large
	return (long long)(sx ? (-result) : result);
}
#define __llrint(x)   llrint((x))


#if SUPPORTS_LONG_DOUBLE
/** Round argument to nearest integral value according to current rounding direction */
LIB_FUNC long long llrintl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t i1 = xw_u.parts64.lsw;
	register int32_t j0 = (int32_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	register uint32_t sx = (uint32_t)(i0 >> 63);
	i0 = (uint64_t)((i0 & 0xffffffffffffULL) | 0x1000000000000ULL);
	register long long result;
	if (j0 < (int32_t)(8 * SIZEOF_LONG_LONG) - 1) {
		ieee854_long_double_shape_type tw_u;
		tw_u.value = ((TWO112[sx] + x) - TWO112[sx]);
		i0 = tw_u.parts64.msw;
		i1 = tw_u.parts64.lsw;
		j0 = (int32_t)((((int32_t)(i0 >> 48)) & 0x7fff) - 0x3fff);
		i0 = (uint64_t)((uint64_t)(i0 & (uint64_t)0xffffffffffffULL) | 0x1000000000000ULL);
		if (j0 < 0x0) { result = 0x0; }
		else if (j0 <= 48) { result = (long long)(((int64_t)i0) >> (48 - j0)); }
		else { result = (long long)((((int64_t)i0) << (int64_t)(j0 - 48)) | (int64_t)(((int64_t)i1) >> (int64_t)(112 - j0))); }
	} else { return (long long)x; }  // The number is too large
	return (long long)(sx ? (-result) : result);
}
#   define __llrintl(x)   llrintl((x))
#endif


/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long lroundf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i = xf_u.word;
	register int32_t j0 = (int32_t)(((i >> 23) & 0xff) - 0x7f);
	register long sign = (long)(((i & (uint32_t)0x80000000) != 0x0) ? (-1) : 1);
	i = (uint32_t)((i & 0x7fffff) | 0x800000);
	register long result;
	if (j0 < (int32_t)(8 * SIZEOF_LONG) - 1) {
		if (j0 < 0) { return (long)((j0 < (-1)) ? 0x0 : sign); }
		else if (j0 >= 23) { result = (long)((int32_t)i << (j0 - 23)); }
		else {
			i += (uint32_t)(0x400000 >> j0);
			result = (long)((int32_t)i >> (23 - j0));
		}
	} else { return (long)x; }  // The number is too large
	return (long)(sign * result);
}


/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long lround(const double x) {
	register uint32_t i1, i0;
	EXTRACT_WORDS(i0, i1, x);
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	register long sign = (long)((i0 & (uint32_t)0x80000000) != 0x0 ? (-1) : 1);
	i0 = ((i0 & 0xfffff) | 0x100000);
	register long result;
	if (j0 < 20) {
		if (j0 < 0) { return ((j0 < (-1)) ? 0x0 : sign); }
		else {
			i0 += (uint32_t)(0x80000 >> j0);
			result = (long)(i0 >> (20 - j0));
		}
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG) - 1) {
		if (j0 >= 52) { result = ((long)i0 << (j0 - 20)) | ((long)i1 << (j0 - 52)); }
		else {
			register uint32_t j = (uint32_t)(i1 + (uint32_t)(0x80000000 >> (j0 - 20)));
			if (j < i1) { ++i0; }
			if (j0 == 20) { result = (long)i0; }
			else { result = (long)((long)i0 << (j0 - 20)) | (j >> (52 - j0)); }
		}
	} else { return (long)x; }  // The number is too large
	return (long)(sign * result);
}


#if SUPPORTS_LONG_DOUBLE
/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long lroundl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t i1 = xw_u.parts64.lsw;
	register int64_t j0 = (int64_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	register long sign = (long)((i0 & (uint64_t)0x8000000000000000ULL) != 0 ? (-1) : 1);
	i0 = (uint64_t)((i0 & (uint64_t)0xffffffffffffULL) | (uint64_t)0x1000000000000ULL);
	register long result;
	if (j0 < 48) {
		if (j0 < 0x0) { return (long)((j0 < (-1)) ? 0 : sign); }
		else {
			i0 += (uint64_t)(0x800000000000ULL >> (uint64_t)j0);
			result = (long)((int64_t)i0 >> (int64_t)(48 - j0));
		}
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG) - 1) {
		if (j0 >= 112) { result = (long)((i0 << (j0 - 48)) | (i1 << (j0 - 112))); }
		else {
			register uint64_t j = (i1 + (uint64_t)(0x8000000000000000ULL >> (uint64_t)(j0 - 48)));
			if (j < i1) { ++i0; }
			if (j0 == 48) { result = (long)i0; }
			else { result = (long)(((int64_t)i0 << (int64_t)(j0 - 48)) | (int64_t)((int64_t)j >> (int64_t)(112 - j0))); }
		}
	} else {return (long) x; }  // The number is too large
	return (long)(sign * result);
}
#endif


/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long long llroundf(const float x) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i = xf_u.word;
	register int32_t j0 = (int32_t)(((i >> 23) & 0xff) - 0x7f);
	register long long sign = (long long)(((i & (uint32_t)0x80000000) != 0) ? (-1) : 1);
	i = (uint32_t)((uint32_t)(i & (uint32_t)0x7fffff) | (uint32_t)0x800000);
	register long long result;
	if (PREDICT_LIKELY(j0 < (int32_t)((8 * SIZEOF_LONG_LONG) - 1))) {
		if (j0 < 0x0) { return ((j0 < (-1)) ? 0x0 : sign); }
		else if (j0 >= 23) { result = (long long)(i << (j0 - 23)); }
		else {
			i += (uint32_t)(0x400000 >> j0);
			result = (long long)(i >> (23 - j0));
		}
	} else { return (long long)x; }  // The number is too large
	return (sign * result);
}


/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long long llround(const double x) {
	register uint32_t i1, i0;
	EXTRACT_WORDS(i0, i1, x);
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	register long long sign = (long long)(((i0 & (uint32_t)0x80000000) != 0x0) ? (-1) : 1);
	i0 = (uint32_t)((i0 & (uint32_t)0xfffff) | (uint32_t)0x100000);
	register long long result;
	if (j0 < 20) {
		if (j0 < 0x0) { return ((j0 < (int32_t)(-1)) ? 0x0 : sign); }
		else {
			i0 += (uint32_t)(0x80000 >> j0);
			result = (long long)(i0 >> (20 - j0));
		}
	} else if (j0 < (int32_t)(8 * SIZEOF_LONG_LONG) - 1) {
		if (j0 >= 52) { result = (((long long)i0 << 32) | i1) << (j0 - 52); }
		else {
			uint32_t j = (uint32_t)(i1 + (0x80000000 >> (j0 - 20)));
			if (j < i1) { ++i0; }
			if (j0 == 20) { result = (long long)i0; }
			else { result = ((long long)i0 << (j0 - 20)) | (j >> (52 - j0)); }
		}
	} else { return (long long)x; }  // The number is too large
	return (sign * result);
}


#if SUPPORTS_LONG_DOUBLE
/** Returns an integer that is nearest in value to x, with halfway cases rounded away from zero */
LIB_FUNC long long llroundl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t i1 = xw_u.parts64.lsw;
	register int64_t j0 = (int64_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	register long long sign = (long long)(((i0 & (uint64_t)0x8000000000000000ULL) != 0) ? (-1) : 1);
	i0 = (uint64_t)((i0 & 0xffffffffffffULL) | 0x1000000000000ULL);
	register long long result;
	if (PREDICT_LIKELY(j0 < 48)) {
		if (j0 < 0x0) { return ((j0 < (-1)) ? 0 : sign); }
		else {
			i0 += (uint64_t)(0x800000000000LL >> j0);
			result = (long long)(((int64_t)i0) >> (48 - j0));
		}
	} else if (j0 < (int64_t)(8 * SIZEOF_LONG_LONG) - 1) {
		if (j0 >= 112) { result = (long long)(((int64_t)i0 << (j0 - 48)) | ((int64_t)i1 << (j0 - 112))); }
		else {
			register uint64_t j = (i1 + (0x8000000000000000ULL >> (uint64_t)(j0 - 48)));
			if (j < i1) { ++i0; }
			if (j0 == 48) { result = (long long)i0; }
			else { result = (long long)((i0 << (uint64_t)(j0 - 48)) | (j >> (uint64_t)(112 - j0))); }
		}
	} else { return (long long)x; }  // The number is too large
	return (long long)(sign * result);
}
#endif


/** Round x towards zero, returning the nearest integral value that is not larger than x */
LIB_FUNC float truncf(float x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	float z;
	asm volatile ("friz %0, %1;" "frsp %0, %0;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register uint32_t i0 = xf_u.word;
	register uint32_t sx = (uint32_t)(i0 & (uint32_t)0x80000000);
	register int32_t j0 = (int32_t)((int32_t)((int32_t)(i0 >> 23) & 0xff) - 0x7f);
	if (PREDICT_LIKELY(j0 < 23)) {
		if (j0 < 0x0) { SET_FLOAT_WORD(x, (int)sx); }  // The number is < 1 so the result is +-0
		else { SET_FLOAT_WORD(x, (int)(sx | (uint32_t)(i0 & (uint32_t)(~(0x7fffff >> j0))))); }
	} else if (j0 == 0x80) { return (float)(x + x); }  // x is inf or NaN
	return (float)x;
#   endif
}


/** Round x towards zero, returning the nearest integral value that is not larger than x */
LIB_FUNC double trunc(double x) {
#   if (defined(ARCHPOWERPC) && defined(_ARCH_PWR5X))
	double z;
	asm volatile ("friz %0, %1;" : "=f"(z) : "f"(x));
	return z;
#   else
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	register int32_t i0 = (int32_t)xw_u.parts.msw;
	register uint32_t i1 = xw_u.parts.lsw;
	register uint32_t sx = (uint32_t)((uint32_t)i0 & (uint32_t)0x80000000);
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	if (PREDICT_LIKELY(j0 < 20)) {
		if (j0 < 0x0) {  // The number is < 1 so the result is +-0
			xw_u.parts.msw = (uint32_t)sx;
			xw_u.parts.lsw = (uint32_t)0;
			return (double)xw_u.value;
		} else {
			xw_u.parts.msw = (uint32_t)(sx | (uint32_t)(i0 & (~(0xfffff >> j0))));
			xw_u.parts.lsw = (uint32_t)0;
			return (double)xw_u.value;
		}
	} else if (j0 > 51) {
		if (j0 == 0x400) { return (double)(x + x); }  // x is inf or NaN
	} else {
		xw_u.parts.msw = (uint32_t)i0;
		xw_u.parts.lsw = (uint32_t)(i1 & (uint32_t)(~(0xffffffff >> (j0 - 20))));
		return (double)xw_u.value;
	}
	UNREACHABLE
#   endif
}


#if SUPPORTS_LONG_DOUBLE
/** Round x towards zero, returning the nearest integral value that is not larger than x */
LIB_FUNC long double truncl(long double x) {
	ieee854_long_double_shape_type x_u;
	x_u.value = x;
	register uint64_t i0 = x_u.parts64.msw;
	register uint64_t i1 = x_u.parts64.lsw;
	register uint64_t sx = (uint64_t)(i0 & (uint64_t)0x8000000000000000ULL);
	register int32_t j0 = (int32_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	if (PREDICT_LIKELY(j0 < 48)) {
		if (j0 < 0x0) { SET_LDOUBLE_WORDS64(x, sx, 0); }  // The number is < 1 so the result is +-0
		else { SET_LDOUBLE_WORDS64(x, (uint64_t)(i0 & (uint64_t)(~(0xffffffffffffULL >> (uint64_t)j0))), 0); }
	} else if (j0 > 111) {
		if (j0 == 0x4000) { return (long double)(x + x); }  // x is inf or NaN
	} else { SET_LDOUBLE_WORDS64(x, i0, (uint64_t)(i1 & (uint64_t)(~(0xffffffffffffffffULL >> (uint64_t)(j0 - 48))))); }
	return x;
}
#endif


/** Rounds x to an integral value, using the rounding direction specified by fegetround */
LIB_FUNC float nearbyintf(const float x) {
	ieee_float_shape_stype xf_s;
	xf_s.value = x;
	register int32_t i0 = xf_s.word;
	register int32_t sx = ((i0 >> 31) & 0x1);
	register int32_t j0 = (((i0 >> 23) & 0xFF) - 0x7F);
	fenv_t env;
	if (PREDICT_LIKELY(j0 < 23)) {
		if (j0 < 0x0) {
			libc_feholdexceptf(&env);
			ieee_float_shape_type tf_u;
			tf_u.value = (float)((TWO23[sx] + x) - TWO23[sx]);
			i0 = (int32_t)tf_u.word;
			raise_flag(tf_u.value);
			libc_fesetenvf(&env);
			tf_u.word = (uint32_t)(((int32_t)i0 & (int32_t)0x7fffffff) | (int32_t)(sx << 31));
			return (float)tf_u.value;
		}
	} else {
		if (PREDICT_UNLIKELY(j0 == 0x80)) { return (float)(x + x); }  // inf or NaN
		else { return (float)x; }  // x is integral
	}
	libc_feholdexceptf(&env);
	register float t = (float)((TWO23[sx] + x) - TWO23[sx]);
	raise_flag(t);
	libc_fesetenvf(&env);
	return (float)t;
}


/** Rounds x to an integral value, using the rounding direction specified by fegetround */
LIB_FUNC double nearbyint(const double x) {
	ieee_double_shape_type xh_u;
	xh_u.value = x;
	register int32_t i0 = (int32_t)xh_u.parts.msw;
	register uint32_t sx = (uint32_t)((i0 >> 31) & 1);
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);
	if (PREDICT_LIKELY(j0 < 52)) {
		if (j0 < 0x0) {
			fenv_t env;
			libc_feholdexcept(&env);
			ieee_double_shape_type th_u;
			th_u.value = ((TWO52[sx] + x) - TWO52[sx]);
			i0 = (int32_t)th_u.parts.msw;
			raise_flag(th_u.value);
			libc_fesetenv(&env);
			th_u.parts.msw = (uint32_t)(((int32_t)i0 & 0x7fffffff) | (sx << 31));
			return (double)th_u.value;
		}
	} else {
		if (PREDICT_UNLIKELY(j0 == 0x400)) { return (double)(x + x); }  // inf or NaN
		else { return (double)x; }  // x is integral
	}
	fenv_t env;
	libc_feholdexcept(&env);
	register double t = (TWO52[sx] + x) - TWO52[sx];
	raise_flag(t);
	libc_fesetenv(&env);
	return (double)t;
}


#if SUPPORTS_LONG_DOUBLE
/** Rounds x to an integral value, using the rounding direction specified by fegetround */
LIB_FUNC long double nearbyintl(const long double x) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register uint64_t i0 = xw_u.parts64.msw;
	register uint64_t sx = (uint64_t)(i0 >> 63);
	register int64_t j0 = (int64_t)(((i0 >> 48) & 0x7fff) - 0x3fff);
	if (PREDICT_LIKELY(j0 < 112)) {
		if (j0 < 0x0) {
			fenv_t env;
			feholdexcept(&env);
			register long double t = (long double)((TWO112[sx] + x) - TWO112[sx]);
			raise_flag(t);
			fesetenv(&env);
			GET_LDOUBLE_MSW64(i0, t);
			SET_LDOUBLE_MSW64(t, (uint64_t)((i0 & 0x7fffffffffffffffULL) | (sx << 63)));
			return (long double)t;
		}
	} else {
		if (PREDICT_UNLIKELY(j0 == 0x4000)) { return (long double)(x + x); }  // inf or NaN
		else { return (long double)x; }  // x is integral
	}
	fenv_t env;
	feholdexcept(&env);
	register long double t = (long double)((TWO112[sx] + x) - TWO112[sx]);
	raise_flag(t);
	fesetenv(&env);
	return (long double)t;
}
#endif


// REMAINDER

/** Returns the floating-point remainder of x/y (rounded towards zero) */
LIB_FUNC float fmodf(float x, float y) {
	ieee_float_shape_type xf_u, yf_u;
	xf_u.value = x;
	yf_u.value = y;
	register int32_t hx = (int32_t)xf_u.word;
	register int32_t hy = (int32_t)yf_u.word;
	register int32_t sx = (int32_t)(hx & (int32_t)0x80000000);  // Sign of x
	hx ^= (int32_t)sx;  // |x|
	hy &= 0x7fffffff;  // |y|
	if (hy == 0x0 || (hx >= 0x7f800000) || (hy > 0x7f800000)) { return (float)((x * y) / (x * y)); }  // y=0, x not finite, or y is NaN
	else if (hx < hy) { return (float)x; }  // |x|<|y| return x
	else if (hx == hy) { return (float)ZEROF[(uint32_t)sx >> 31]; }  // |x|=|y| return x*0
	register int32_t i, ix, iy;
	if (hx < 0x800000) {  // Subnormal x
		for (ix = -126, i = (hx << 8); i > 0x0; i <<= 1) { --ix; }
	} else { ix = (hx >> 23) - 127; }
	if (hy < 0x800000) {  // Subnormal y
		for (iy = -126, i = (hy << 8); i >= 0x0; i <<= 1) { --iy; }
	} else { iy = (hy >> 23) - 127; }
	register int32_t n;
	if (ix >= -126) { hx = 0x800000 | (0x7fffff & hx); }  // Align y to x
	else {  // Subnormal x, shift x to normal
		n = ((-126) - ix);
		hx = (hx << n);
	}
	if (iy >= -126) { hy = (int32_t)(0x800000 | (0x7fffff & hy)); }
	else {  // Subnormal y, shift y to normal
		n = (int32_t)((-126) - iy);
		hy = (hy << n);
	}
	// Fix-point fmod
	n = (int32_t)(ix - iy);
	register int32_t hz;
	while (n--) {
		hz = hx - hy;
		if (hz < 0x0) { hx += hx; }
		else {
			if (hz == 0x0) { return (float)ZEROF[(uint32_t)sx >> 31]; }  // Return sign(x)*0
			hx = (hz + hz);
		}
	}
	hz = hx - hy;
	if (hz >= 0) { hx = hz; }
	// Convert back to floating value and restore the sign
	if (hx == 0) { return (float)ZEROF[(uint32_t)sx >> 31]; }  // Return sign(x)*0
	while (hx < 0x800000) {  // Normalize x
		hx += hx;
		--iy;
	}
	if (iy >= -126) {  // Normalize output
		hx = ((hx - 0x800000) | ((iy + 127) << 23));
		SET_FLOAT_WORD(x, (hx | sx));
	} else {  // Subnormal output
		n = ((-126) - iy);
		hx >>= n;
		SET_FLOAT_WORD(x, (hx | sx));
		x *= 1.0F;  // Create necessary signal
	}
	return (float)x;  // Exact output
}
#define __ieee754_fmodf(x, y)   fmodf((x), (y))
#define __fmodf_finite(x, y)   fmodf((x), (y))
#define ieee754_fmodf(x, y)   fmodf((x), (y))
#define fmodf_finite(x, y)   fmodf((x), (y))


/** Returns the floating-point remainder of x/y (rounded towards zero) */
LIB_FUNC double fmod(double x, double y) {
	ieee_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	yw_u.value = y;
	register int32_t hx = (int32_t)xw_u.parts.msw;
	register uint32_t lx = (uint32_t)xw_u.parts.lsw;
	register int32_t hy = (int32_t)yw_u.parts.msw;
	register uint32_t ly = (uint32_t)yw_u.parts.lsw;
	register int32_t sx = (int32_t)(hx & (int32_t)0x80000000);  // Sign of x
	hx ^= sx;  // |x|
	hy &= (int32_t)0x7fffffff;  // |y|
	if ((hy | (int32_t)ly) == 0 || (hx >= 0x7ff00000) || ((hy | (int32_t)((ly | -ly) >> 31)) > 0x7ff00000)) { return ((x * y) / (x * y)); }  // y=0, x not finite, or y is NaN
	else if (hx <= hy) {
		if ((hx < hy) || (lx < ly)) { return x; }  // |x|<|y| return x
		if (lx == ly) { return ZERO[(uint32_t)sx >> 31]; }  // |x|=|y| return x*0
	}
	register int32_t ix, iy, i;
	if (hx < 0x100000) {  // Subnormal x
		if (hx == 0) {
			for (ix = -1043, i = (int32_t)lx; i > 0; i <<= 1) { --ix; }
		} else {
			for (ix = -1022, i = (int32_t)(hx << 11); i > 0; i <<= 1) { --ix; }
		}
	} else { ix = (int32_t)((hx >> 20) - 1023); }
	if (hy < 0x100000) {  // Subnormal y
		if (hy == 0x0) {
			for (iy = -1043, i = (int32_t)ly; i > 0; i <<= 1) { --iy; }
		} else {
			for (iy = -1022, i = (int32_t)(hy << 11); i > 0; i <<= 1) { --iy; }
		}
	} else { iy = (int32_t)((hy >> 20) - 1023); }
	register int32_t n;
	if (ix >= -1022) { hx = 0x100000 | (0xfffff & hx); }  // Align y to x
	else {  // Subnormal x, shift x to normal
		n = (int32_t)((-1022) - ix);
		if (n <= 31) {
			hx = (int32_t)((hx << n) | (int32_t)(lx >> (32 - n)));
			lx <<= (uint32_t)n;
		} else {
			hx = (int32_t)(lx << (n - 32));
			lx = 0x0;
		}
	}
	if (iy >= -1022) { hy = 0x100000 | (0xfffff & hy); }
	else {  // Subnormal y, shift y to normal
		n = (int32_t)((-1022) - iy);
		if (n <= 31) {
			hy = (int32_t)((hy << n) | (int32_t)(ly >> (32 - n)));
			ly <<= (uint32_t)n;
		} else {
			hy = (int32_t)(ly << (n - 32));
			ly = 0x0;
		}
	}
	// Fix-point fmod
	register int32_t hz;
	register uint32_t lz;
	n = ix - iy;
	while (n--) {
		hz = hx - hy;
		lz = lx - ly;
		if (lx < ly) { --hz; }
		if (hz < 0x0) {
			hx = (int32_t)((hx + hx) + (int32_t)(lx >> 31));
			lx += lx;
		} else {
			if ((hz | (int32_t)lz) == 0x0) { return ZERO[(uint32_t) sx >> 31]; }  // Return sign(x)*0
			hx = (int32_t)((hz + hz) + (int32_t)(lz >> 31));
			lx = lz + lz;
		}
	}
	hz = hx - hy;
	lz = lx - ly;
	if (lx < ly) { --hz; }
	if (hz >= 0) { hx = hz; lx = lz; }
	// Convert back to floating value and restore the sign
	if ((hx | (int32_t)lx) == 0) { return ZERO[(uint32_t)sx >> 31]; }  // Return sign(x)*0
	while (hx < 0x100000) {  // Normalize x
		hx = (int32_t)((hx + hx) + ((int32_t)lx >> 31));
		lx += lx;
		--iy;
	}
	if (iy >= -1022) {  // Normalize output
		hx = (int32_t)((hx - 0x100000) | ((iy + 1023) << 20));
		xw_u.parts.msw = (uint32_t)(hx | sx);
		xw_u.parts.lsw = (uint32_t)lx;
		x = xw_u.value;
	} else {  // Subnormal output
		n = (-1022) - iy;
		if (n <= 20) {
			lx = (uint32_t)((lx >> (uint32_t)n) | (uint32_t)((uint32_t)hx << (uint32_t)(32 - n)));
			hx >>= n;
		} else if (n <= 31) {
			lx = (uint32_t)((uint32_t)(hx << (32 - n)) | (uint32_t)(lx >> n));
			hx = sx;
		} else {
			lx = (uint32_t)(hx >> (n - 32));
			hx = sx;
		}
		xw_u.parts.msw = (uint32_t)(hx | sx);
		xw_u.parts.lsw = (uint32_t)lx;
		x = xw_u.value * 1.0;  // Create necessary signal
	}
	return x;  // Exact output
}
#define __ieee754_fmod(x, y)   fmod((x), (y))
#define __fmod_finite(x, y)   fmod((x), (y))
#define ieee754_fmod(x, y)   fmod((x), (y))
#define fmod_finite(x, y)   fmod((x), (y))


#if SUPPORTS_LONG_DOUBLE
/** Returns the floating-point remainder of x/y (rounded towards zero) */
LIB_FUNC long double fmodl(long double x, long double y) {
	ieee854_long_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	yw_u.value = y;
	register int64_t hx = (int64_t)xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	register int64_t hy = (int64_t)yw_u.parts64.msw;
	register uint64_t ly = yw_u.parts64.lsw;
	register int64_t sx = (int64_t)(hx & (int64_t)0x8000000000000000LL);  // Sign of x
	hx ^= sx;  // |x|
	hy &= 0x7fffffffffffffffLL;  // |y|
	if ((hy | (int64_t)ly) == 0x0 || (hx >= 0x7fff000000000000LL) || ((hy | (int64_t)((ly | (-ly)) >> 63)) > 0x7fff000000000000LL)) { return ((x * y) / (x * y)); }  // y=0, x not finite, or y is NaN
	else if (hx <= hy) {
		if ((hx < hy) || (lx < ly)) { return x; }  // |x|<|y| return x
		else if (lx == ly) { return ZEROL[(uint64_t)sx >> 63]; }  // |x|=|y| return x*0
	}
	register int64_t ix, iy, i;
	if (hx < 0x1000000000000LL) {  // Subnormal x
		if (hx == 0x0) {
			for (ix = -16431, i = (int64_t)lx; i > 0x0; i <<= 1) { --ix; }
		} else {
			for (ix = -16382, i = (int64_t)(hx << 15); i > 0x0; i <<= 1) { --ix; }
		}
	} else { ix = (int64_t)((hx >> 48) - 0x3FFF); }
	if (hy < 0x1000000000000LL) {  // Subnormal y
		if (hy == 0x0) {
			for (iy = -16431, i = (int64_t)ly; i > 0x0; i <<= 1) { --iy; }
		} else {
			for (iy = -16382, i = (int64_t)(hy << 15); i > 0x0; i <<= 1) { --iy; }
		}
	} else iy = (int64_t)((hy >> 48) - 0x3FFF);
	// Align y to x
	register int64_t n;
	if (ix >= -16382) { hx = (int64_t)(0x1000000000000LL | (0xffffffffffffLL & hx)); }
	else {  // Subnormal x, shift x to normal
		n = (-16382) - ix;
		if (n <= 63) {
			hx = (int64_t)((hx << n) | (int64_t)(lx >> (64 - n)));
			lx <<= n;
		} else {
			hx = (int64_t)(lx << (n - 64));
			lx = 0x0;
		}
	}
	if (iy >= (-16382)) { hy = (int64_t)(0x1000000000000LL | (0xffffffffffffLL & hy)); }
	else {  // Subnormal y, shift y to normal
		n = ((-16382) - iy);
		if (n <= 63) {
			hy = (int64_t)((hy << n) | (int64_t)(ly >> (uint64_t)(64 - n)));
			ly <<= n;
		} else {
			hy = (int64_t)(ly << (uint64_t)(n - 64));
			ly = 0x0;
		}
	}
	// Fix-point fmod
	register int64_t hz;
	register uint64_t lz;
	n = ix - iy;
	while (n--) {
		hz = hx - hy;
		lz = lx - ly;
		if (lx < ly) { --hz; }
		if (hz < 0x0) {
			hx = (int64_t)((hx + hx) + (int64_t)(lx >> 63));
			lx += lx;
		} else {
			if ((hz | (int64_t)lz) == 0x0) { return ZEROL[(uint64_t)sx >> 63]; }  // Return sign(x)*0
			hx = (int64_t)((hz + hz) + (int64_t)(lz >> 63));
			lx = (lz + lz);
		}
	}
	hz = hx - hy;
	lz = lx - ly;
	if (lx < ly) { --hz; }
	if (hz >= 0) { hx = hz; lx = lz; }
	// Convert back to floating value and restore the sign
	if ((hx | (int64_t)lx) == 0) { return ZEROL[(uint64_t)sx >> 63]; }  // Return sign(x)*0
	while (hx < 0x1000000000000LL) {  // Normalize x
		hx = (int64_t)((hx + hx) + (int64_t)(lx >> 63));
		lx += lx;
		--iy;
	}
	if (iy >= -16382) {  // Normalize output
		hx = ((hx - 0x1000000000000LL) | (int64_t)((iy + 16383) << 48));
		SET_LDOUBLE_WORDS64(x, (hx | sx) ,lx);
	} else {  // Subnormal output
		n = (-16382) - iy;
		if (n <= 48) {
			lx = (uint64_t)((lx >> n) | (uint64_t)(hx << (64 - n)));
			hx >>= n;
		} else if (n <= 63) {
			lx = (uint64_t)((uint64_t)(hx << (64 - n)) | (lx >> n));
			hx = sx;
		} else {
			lx = (uint64_t)(hx >> (n - 64));
			hx = sx;
		}
		SET_LDOUBLE_WORDS64(x, (uint64_t)(hx | sx), lx);
		x *= 1.0L;  // Create necessary signal
	}
	return x;  // Exact output
}
#endif
#define __ieee754_fmodl(x, y)   fmodl((x), (y))
#define __fmodl_finite(x, y)   fmodl((x), (y))
#define ieee754_fmodl(x, y)   fmodl((x), (y))
#define fmodl_finite(x, y)   fmodl((x), (y))


/** Returns the floating-point remainder of x/p (rounded to nearest) */
LIB_FUNC float remainderf(float x, float p) {
	ieee_float_shape_type xf_u, pf_u;
	xf_u.value = x;
	pf_u.value = p;
	register int32_t hx = (int32_t)xf_u.word;
	register int32_t hp = (int32_t)pf_u.word;
	register uint32_t sx = (uint32_t)(hx & (int32_t)0x80000000);
	hp &= (int32_t)0x7fffffff;
	hx &= (int32_t)0x7fffffff;
	if (hp == 0x0) { return (float)((x * p) / (x * p)); }  // p = 0
	else if ((hx >= 0x7f800000) || ((hp > 0x7f800000))) { return (float)((x * p) / (x * p)); }  // x not finite or p is NaN
	else if (hp <= 0x7effffff) { x = (float)fmodf(x, (float)(p + p)); }  // Now x < 2p
	if ((hx - hp) == 0x0) { return (float)(0.0F * x); }
	x = (float)fabsf(x);
	p = (float)fabsf(p);
	if (hp < 0x01000000) {
		if ((float)(x + x) > p) {
			x -= p;
			if ((float)(x + x) >= p) { x -= p; }
		}
	} else {
		register float p_half = (float)((float)0.5F * p);
		if (x > p_half) {
			x -= p;
			if (x >= p_half) { x -= p; }
		}
	}
	xf_u.value = x;
	hx = (int32_t)xf_u.word;
	xf_u.word = (uint32_t)((uint32_t)hx ^ sx);
	return (float)xf_u.value;
}
#define __ieee754_remainderf(x, y)   remainderf((x), (y))
#define ieee754_remainderf(x, y)   remainderf((x), (y))
#define __remainderf_finite(x, y)   remainderf((x), (y))
#define remainderf_finite(x, y)   remainderf((x), (y))
#define __remainderf(x, y)   remainderf((x), (y))


/** Returns the floating-point remainder of x/p (rounded to nearest) */
LIB_FUNC double remainder(double x, double y) {
	ieee754_remainder_double u, t, w = { { 0, 0 } }, v = { { 0, 0 } }, ww = { { 0, 0 } }, r;
	u.x = x;
	t.x = y;
	register int kx = (u.i[HIGH_HALF] & 0x7fffffff);  // No sign for x
	t.i[HIGH_HALF] &= 0x7fffffff;  // No sign for y
	register int ky = t.i[HIGH_HALF];
	register double z;
	if (PREDICT_LIKELY(kx < 0x7fe00000 && ky < 0x7ff00000 && ky >= 0x3500000)) {  // |x| < 2^1023 and 2^-970 < |y| < 2^1024
		if (kx + 0x100000 < ky) { return (double)x; }
		else if ((kx - 0x1500000) < ky) {
			z = (double)(x / t.x);
			v.i[HIGH_HALF] = t.i[HIGH_HALF];
			register double d = (double)((z + _BIG.x) - _BIG.x);
			register double xx = (double)((x - d * v.x) - d * (t.x - v.x));
			if ((d - z) != 0.5 && (d - z) != (-0.5)) {
				return (double)((xx != 0) ? xx : ((x > 0) ? _ZERO.x : _NZERO.x));
			} else if (fabs(xx) > (0.5 * t.x)) {
				return (double)((z > d) ? (xx - t.x) : (xx + t.x));
			} else { return (double)xx; }
		} else {  // (kx < (ky + 0x01500000))
			r.x = (1.0 / t.x);
			register int n = t.i[HIGH_HALF];
			register int nn = (n & 0x7ff00000) + 0x1400000;
			w.i[HIGH_HALF] = n;
			ww.x = t.x - w.x;
			register int l = ((int)(kx - nn) & (int)0xfff00000);
			register int n1 = ww.i[HIGH_HALF];
			register int m1 = r.i[HIGH_HALF];
			register double d;
			while (l > 0x0) {
				r.i[HIGH_HALF] = m1 - l;
				z = (u.x * r.x);
				w.i[HIGH_HALF] = n + l;
				ww.i[HIGH_HALF] = ((n1) ? (n1 + l) : n1);
				d = (z + _BIG.x) - _BIG.x;
				u.x = (u.x - d * w.x) - d * ww.x;
				l = (u.i[HIGH_HALF] & 0x7ff00000) - nn;
			}
			r.i[HIGH_HALF] = m1;
			w.i[HIGH_HALF] = n;
			ww.i[HIGH_HALF] = n1;
			z = (u.x * r.x);
			d = (z + _BIG.x) - _BIG.x;
			u.x = (u.x - d * w.x) - d * ww.x;
			if (fabs(u.x) < (0.5 * t.x)) {
				return (double)((u.x != 0) ? u.x : ((x > 0) ? _ZERO.x : _NZERO.x));
			} else if (fabs(u.x) > (0.5 * t.x)) {
				return (double)((d > z) ? (u.x + t.x) : (u.x - t.x));
			} else {
				d = (double)((((double)(u.x / t.x)) + _BIG.x) - _BIG.x);
				return (double)((u.x - d * w.x) - d * ww.x);
			}
		}
	} else {  // (kx<0x7fe00000&&ky<0x7ff00000&&ky>=0x03500000)
		if (PREDICT_LIKELY(kx < 0x7fe00000 && ky < 0x7ff00000 && (ky > 0 || t.i[LOW_HALF] != 0))) {
			y = (fabs(y) * _T128.x);
			z = (remainder(x, y) * _T128.x);
			z = (remainder(z, y) * _TM128.x);
			return (double)z;
		} else if ((kx & 0x7ff00000) == 0x7fe00000 && ky < 0x7ff00000 && (ky > 0 || t.i[LOW_HALF] != 0)) {
			y = fabs(y);
			z = (2.0 * remainder((0.5 * x), y));
			register double d = (double)fabs(z);
			if (d <= fabs(d - y)) { return (double)z; }
			else { return (double)((z > 0) ? (z - y) : (z + y)); }
		} else {  // x is too big
			if (ky == 0 && t.i[LOW_HALF] == 0) { return (double)((x * y) / (x * y)); }  // y = 0
			else if (kx >= 0x7ff00000 || (ky > 0x7ff00000 || (ky == 0x7ff00000 && t.i[LOW_HALF] != 0))) { return (double)((x * y) / (x * y)); }  // x not is finite or y is NaN
			else { return (double)x; }
		}
	UNREACHABLE
	}
}
#define __ieee754_remainder(x, y)   remainder((x), (y))
#define ieee754_remainder(x, y)   remainder((x), (y))
#define __remainder_finite(x, y)   remainder((x), (y))
#define remainder_finite(x, y)   remainder((x), (y))
#define __remainder(x, y)   remainder((x), (y))


#if SUPPORTS_LONG_DOUBLE
/** Returns the floating-point remainder of x/p (rounded to nearest) */
LIB_FUNC long double remainderl(long double x, long double p) {
	ieee854_long_double_shape_type xw_u, pw_u;
	xw_u.value = x;
	pw_u.value = p;
	register int64_t hx = (int64_t)xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	register int64_t hp = (int64_t)pw_u.parts64.msw;
	register uint64_t lp = pw_u.parts64.lsw;
	register int64_t sx = (int64_t)(hx & (int64_t)0x8000000000000000LL);
	hp &= (int32_t)0x7fffffffffffffffLL;
	hx &= (int32_t)0x7fffffffffffffffLL;
	if ((hp | (int64_t)lp) == 0x0) { return (long double)((x * p) / (x * p)); }  // p = 0
	else if ((hx >= 0x7fff000000000000LL) || ((hp >= 0x7fff000000000000LL) && (((hp - 0x7fff000000000000LL) | (int64_t)lp) != 0x0))) { return (long double)((x * p) / (x * p)); }  // x is not finite or p is NaN
	else if (hp <= 0x7ffdffffffffffffLL) { x = fmodl(x, (long double)(p + p)); }  // Now x < 2p
	if (((hx - hp) | (int64_t)(lx - lp)) == 0x0) { return (long double)(0.0L * x); }
	x = (long double)fabsl(x);
	p = (long double)fabsl(p);
	if (hp < (int64_t)0x2000000000000LL) {
		if ((long double)(x + x) > p) {
			x -= p;
			if ((long double)(x + x) >= p) { x -= p; }
		}
	} else {
		register long double p_half = (long double)(0.5L * p);
		if (x > p_half) {
			x -= p;
			if (x >= p_half) { x -= p; }
		}
	}
	xw_u.value = x;
	hx = (int64_t)xw_u.parts64.msw;
	xw_u.parts64.msw = (uint64_t)(hx ^ sx);
	return (long double)xw_u.value;
}
#endif
#define __ieee754_remainderl(x, y)   remainderl((x), (y))
#define ieee754_remainderl(x, y)   remainderl((x), (y))
#define __remainderl_finite(x, y)   remainderl((x), (y))
#define remainderl_finite(x, y)   remainderl((x), (y))
#define __remainderl(x, y)   remainderl((x), (y))


/** Returns the same as remainder, but it additionally stores the quotient internally used to determine its result in the object pointed by quot; The value pointed by quot contains the congruent modulo with at least 3 bits of the integral quotient x/y */
LIB_FUNC float remquof(float x, float y, int* quo) {
	ieee_float_shape_type xf_u, yf_u;
	xf_u.value = x;
	yf_u.value = y;
	register int32_t hx = (int32_t)xf_u.word;
	register int32_t hy = (int32_t)yf_u.word;
	register int32_t sx = (int32_t)(hx & (int32_t)0x80000000);
	register int qs = (int)(sx ^ (int32_t)(hy & (int32_t)0x80000000));
	hy &= (int32_t)0x7fffffff;
	hx &= (int32_t)0x7fffffff;
	if (hy == 0 || ((hx >= 0x7f800000) || (hy > 0x7f800000))) { return (float)((x * y) / (x * y)); }  // y = 0, x is not finite, or y is NaN
	else if (hy <= 0x7dffffff) { x = fmodf(x, (8.0F * y)); }  // Now x < 8y
	if ((hx - hy) == 0x0) {
		*quo = (qs ? (-1) : 1);
		return (float)(0.0F * x);
	}
	x = fabsf(x);
	y = fabsf(y);
	register int cquo = 0x0;
	if (hy <= 0x7e7fffff && x >= (float)(4.0F * y)) {
		x -= (float)(4.0F * y);
		cquo += 4;
	}
	if (hy <= 0x7effffff && x >= 2 * y) {
		x -= (float)(2.0F * y);
		cquo += 2;
	}
	if (hy < 0x01000000) {
		if ((float)(x + x) > y) {
			x -= y;
			++cquo;
			if ((float)(x + x) >= y) {
				x -= y;
				++cquo;
			}
		}
	} else {
		float y_half = (0.5F * y);
		if (x > y_half) {
			x -= y;
			++cquo;
			if (x >= y_half) {
				x -= y;
				++cquo;
			}
		}
	}
	*quo = (qs ? (-cquo) : cquo);
	if (x == 0.0F) { x = (float)0.0F; }  // Ensure correct sign of zero result in round-downward mode
	if (sx) { x = (float)(-x); }
	return (float)x;
}


/** Returns the same as remainder, but it additionally stores the quotient internally used to determine its result in the object pointed by quot; The value pointed by quot contains the congruent modulo with at least 3 bits of the integral quotient x/y */
LIB_FUNC double remquo(double x, double y, int* quo) {
	ieee_double_shape_type xh_u, yh_u;
	xh_u.value = x;
	yh_u.value = y;
	register int signx = (int)((xh_u.parts.msw & 0x80000000) >> 31);
	register int signy = (int)((yh_u.parts.msw & 0x80000000) >> 31);
	register int signres = (int)((signx ^ signy) ? (-1) : 1);
	*quo = (signres * (int)(lrint(((double)fabs((double)(x / y)))) & 0x7f));
	return (double)remainder(x, y);
}


#if SUPPORTS_LONG_DOUBLE
/** Returns the same as remainder, but it additionally stores the quotient internally used to determine its result in the object pointed by quot; The value pointed by quot contains the congruent modulo with at least 3 bits of the integral quotient x/y */
LIB_FUNC long double remquol(long double x, long double y, int* quo) {
	ieee854_long_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	yw_u.value = y;
	register int64_t hx = (int64_t)xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	register int64_t hy = (int64_t)yw_u.parts64.msw;
	register uint64_t ly = yw_u.parts64.lsw;
	register uint64_t sx = (uint64_t)((uint64_t)hx & 0x8000000000000000ULL);
	register uint64_t qs = (uint64_t)(sx ^ (uint64_t)((uint64_t)hy & 0x8000000000000000ULL));
	hy &= 0x7fffffffffffffffLL;
	hx &= 0x7fffffffffffffffLL;
	if ((hy | (int64_t)ly) == 0x0 || ((hx >= 0x7fff000000000000LL) || ((hy >= 0x7fff000000000000LL) && (((hy - 0x7fff000000000000LL) | (int64_t)ly) != 0)))) { return (long double)((x * y) / (x * y)); }  // y = 0, x is not finite, or y is NaN
	else if (hy <= 0x7ffbffffffffffffLL) { x = fmodl(x, (long double)(8.0L * y)); }  // Now x < 8y
	if (((hx - hy) | (int64_t)(lx - ly)) == 0x0) {
		*quo = (qs ? (-1) : 1);
		return (long double)(0.0L * x);
	}
	x = (long double)fabsl(x);
	y = (long double)fabsl(y);
	register int cquo = 0x0;
	if (hy <= 0x7ffcffffffffffffLL && x >= (long double)(4.0L * y)) {
		x -= (long double)(4.0L * y);
		cquo += 4;
	}
	if (hy <= 0x7ffdffffffffffffLL && x >= (long double)(2.0L * y)) {
		x -= (long double)(2.0L * y);
		cquo += 2;
	}
	if (hy < 0x2000000000000LL) {
		if ((long double)(x + x) > y) {
			x -= y;
			++cquo;
			if ((long double)(x + x) >= y) {
				x -= y;
				++cquo;
			}
		}
	} else {
		register long double y_half = (long double)(0.5L * y);
		if (x > y_half) {
			x -= y;
			++cquo;
			if (x >= y_half) {
				x -= y;
				++cquo;
			}
		}
	}
	*quo = (qs ? (-cquo) : cquo);
	if (x == (long double)0.0L) { x = (long double)0.0L; }  // Ensure correct sign of zero result in round-downward mode
	if (sx) { x = (long double)(-x); }
	return (long double)x;
}
#endif


// NEXTTOWARD & NEXTAFTER

/** Returns the next representable value after x in the direction of y */
LIB_FUNC float nextafterf(float x, const float y) {
	ieee_float_shape_stype xf_s, yf_s;
	xf_s.value = x;
	yf_s.value = y;
	register int32_t hx = xf_s.word;
	register int32_t hy = yf_s.word;
	register int32_t ix = (int32_t)(hx & 0x7fffffff);  // |x|
	register int32_t iy = (int32_t)(hy & 0x7fffffff);  // |y|
	if ((ix > 0x7f800000) || (iy > 0x7f800000)) { return (float)(x + y); }  // x or y is nan
	else if (x == y) { return (float)y; }  // x=y, return y
	else if (ix == 0x0) {  // x == 0
		SET_FLOAT_WORD(x, (int)((uint32_t)hy & (uint32_t)0x80000000) | 0x1);  // return +-minsubnormal
		raise_flag(x);  // Raise underflow flag
		return (float)x;
	}
	if (hx >= 0x0) {  // x > 0
		if (hx > hy) { --hx; }  // x > y, x -= ulp
		else { ++hx; }  // x < y, x += ulp
	} else {  // x < 0
		if (hy >= 0x0 || hx > hy) { --hx; }  // x < y, x -= ulp
		else { ++hx; }  // x > y, x += ulp
	}
	hy = (hx & 0x7f800000);
	if (hy >= 0x7f800000) {
		register float u = (x + x);  // Overflow
		raise_flag(u);
	} else if (hy < 0x800000) {
		register float u = (x * x);  // Underflow
		raise_flag(u);  // Raise underflow flag
	}
	SET_FLOAT_WORD(x, hx);
	return (float)x;
}


/** Returns the next representable value after x in the direction of y */
LIB_FUNC double nextafter(double x, double y) {
	ieee_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	yw_u.value = y;
	register int32_t hx = (int32_t)xw_u.parts.msw;
	register uint32_t lx = xw_u.parts.lsw;
	register int32_t hy = (int32_t)yw_u.parts.msw;
	register uint32_t ly = yw_u.parts.lsw;
	register int32_t ix = (int32_t)(hx & 0x7fffffff);  // |x|
	register int32_t iy = (int32_t)(hy & 0x7fffffff);  // |y|
	if (((ix >= 0x7ff00000) && ((ix - 0x7ff00000) | (int32_t)lx) != 0x0) || ((iy >= 0x7ff00000) && ((iy - 0x7ff00000) | (int32_t)ly) != 0x0)) { return (double)(x + y); }  // x or y is nan
	else if (x == y) { return (double)x; }  // x=y, return x
	else if (((uint32_t)ix | lx) == 0x0) {  // x == 0
		xw_u.parts.msw = (uint32_t)((uint32_t)hy & (uint32_t)0x80000000);
		xw_u.parts.lsw = (uint32_t)1;
		x = xw_u.value;  // Return +-minsubnormal
		y = (double)(x * x);
		if (PREDICT_LIKELY(y == x)) { return (double)y; }  // Raise underflow flag
		else { return (double)x; }
	} else if (hx >= 0x0) {  // x > 0
		if (hx > hy || ((hx == hy) && (lx > ly))) {  // x > y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x < y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	} else {  // x < 0
		if (hy >= 0x0 || hx > hy || ((hx == hy) && (lx > ly))) {  // x < y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x > y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	}
	hy = (hx & 0x7ff00000);
	if (hy >= 0x7ff00000) { return (double)(x + x); }  // Overflow
	else if (hy < 0x100000) {  // Underflow
		y = (double)(x * x);
		if (y != x) {  // Raise underflow flag
			xw_u.parts.msw = (uint32_t)hx;
			xw_u.parts.lsw = (uint32_t)lx;
			return (double)xw_u.value;
		}
	}
	xw_u.parts.msw = (uint32_t)hx;
	xw_u.parts.lsw = (uint32_t)lx;
	return (double)xw_u.value;
}


#if SUPPORTS_LONG_DOUBLE
/** Returns the next representable value after x in the direction of y */
LIB_FUNC long double nextafterl(long double x, const long double y) {
	ieee854_long_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	yw_u.value = y;
	register int64_t hx = (int64_t)xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	register int64_t hy = (int64_t)yw_u.parts64.msw;
	register uint64_t ly = yw_u.parts64.lsw;
	register int64_t ix = (int64_t)(hx & 0x7fffffffffffffffLL);  // |x|
	register int64_t iy = (int64_t)(hy & 0x7fffffffffffffffLL);  // |y|
	if (((ix >= 0x7fff000000000000LL) && ((ix - 0x7fff000000000000LL) | (int64_t)lx) != 0x0) || ((iy >= 0x7fff000000000000LL) && ((iy - 0x7fff000000000000LL) | (int64_t)ly) != 0x0)) { return (long double)(x + y); }  // x or y is nan
	if (x == y) { return (long double)y; }  // x=y, return y
	else if (((uint64_t)ix | lx) == 0x0) {  // x == 0
		SET_LDOUBLE_WORDS64(x, (uint64_t)(hy & (int64_t)0x8000000000000000LL), 1);  // Return +-minsubnormal
		raise_flag(x);  // Raise underflow flag
		return (long double)x;
	} else if (hx >= 0x0) {  // x > 0
		if (hx > hy || ((hx == hy) && (lx > ly))) {  // x > y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x < y, x += ulp
			lx++;
			if (lx == 0x0) { ++hx; }
		}
	} else {  // x < 0
		if (hy >= 0x0 || hx > hy || ((hx == hy) && (lx > ly))) {  // x < y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x > y, x += ulp
			lx++;
			if (lx == 0x0) { ++hx; }
		}
	}
	hy = (int64_t)(hx & 0x7fff000000000000LL);
	if (hy == 0x7fff000000000000LL) {
		register long double u = (long double)(x + x);  // Overflow
		raise_flag(u);
	} else if (hy == 0x0) {
		register long double u = (long double)(x * x);  // Underflow
		raise_flag(u);  // Raise underflow flag
	}
	xw_u.parts64.msw = (uint64_t)hx;
	xw_u.parts64.lsw = (uint64_t)lx;
	return (long double)xw_u.value;
}
#endif


/** Returns the next representable value after x in the direction of y; This function is like nextafter, but with a more precise y */
LIB_FUNC float nexttowardf(float x, const long double y) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register int32_t hx = (int32_t)xf_u.word;
	ieee854_long_double_shape_type y_u;
	y_u.value = y;
	register int64_t hy = (int64_t)y_u.parts64.msw;
	register uint64_t ly = y_u.parts64.lsw;
	register int32_t ix = (int32_t)(hx & 0x7fffffff);  // |x|
	register int64_t iy = (int64_t)(hy & 0x7fffffffffffffffLL); // |y|
	if ((ix > (int32_t)0x7f800000) || ((iy >= 0x7fff000000000000LL) && ((iy - 0x7fff000000000000LL) | (int64_t)ly) != 0x0)) { return (float)(x + y); }  // x or y is nan
	else if (((long double)x) == y) { return (float)y; }  // x=y, return y
	else if (ix == 0x0) {  // x == 0
		ieee_float_shape_type uf_u;  // Return +-minsub
		uf_u.word = (uint32_t)(((uint64_t)(hy >> 32) & (uint32_t)0x80000000) | 1);
		x = (float)uf_u.value;
		raise_flag(uf_u.value);  // Raise underflow flag
		return (float)x;
	} else if (hx >= 0x0) {  // x > 0
		if (x > y) { --hx; }  // x -= ulp
		else { ++hx; }  // x < y, x += ulp
	} else {  // x < 0
		if (x < y) { --hx; }  // x < y, x -= ulp
		else { ++hx; }  // x > y, x += ulp
	}
	hy = hx & 0x7f800000;
	if (hy >= 0x7f800000) { return (float)(x + x); }  // Overflow
	else if (hy < 0x800000) {
		register float u = (float)(x * x);  // Underflow
		raise_flag(u);  // Raise underflow flag
	}
	xf_u.word = (uint32_t)hx;
	return (float)xf_u.value;
}


/** Returns the next representable value after x in the direction of y; This function is like nextafter, but with a more precise y */
LIB_FUNC double nexttoward(double x, const long double y) {
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	register int32_t hx = (int32_t)xw_u.parts.msw;
	register uint32_t lx = xw_u.parts.lsw;
	ieee854_long_double_shape_type yw_u;
	yw_u.value = y;
	register int64_t hy = (int64_t)yw_u.parts64.msw;
	register uint64_t ly = yw_u.parts64.lsw;
	register int32_t ix = (int32_t)(hx & 0x7fffffff);  // |x|
	register int64_t iy = (int64_t)(hy & 0x7fffffffffffffffLL);  // |y|
	if (((ix >= 0x7ff00000) && ((ix - 0x7ff00000) | (int32_t)lx) != 0x0) || ((iy >= 0x7fff000000000000LL) && ((int64_t)(iy - 0x7fff000000000000LL) | (int64_t)ly) != 0x0)) { return (double)(x + y); }  // x or y is nan
	else if ((long double) x == y) { return (double)y; }  // x=y, return y
	else if (((uint64_t)ix | lx) == 0x0) {  // x == 0
		xw_u.parts.msw = (uint32_t)((hy >> 32) & 0x80000000);
		xw_u.parts.lsw = (uint32_t)1;
		raise_flag(xw_u.value);  // Raise underflow flag
		return (double)xw_u.value;  // Return +-minsub
	} else if (hx >= 0x0) {  // x > 0
		if (x > y) {  // x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x < y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	} else {  // x < 0
		if (x < y) {  // x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x > y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	}
	hy = hx & 0x7ff00000;
	if (hy >= 0x7ff00000) {
		x += x;  // Overflow
		if ((FLT_EVAL_METHOD != 0x0) && (FLT_EVAL_METHOD != 0x1)) { asm (";" : "+m"(x)); }  // Force conversion to double
		return (double)x;
	} else if (hy < 0x100000) {
		register double u = (double)(x * x);  // Underflow
		raise_flag(u);  // Raise underflow flag
	}
	xw_u.parts.msw = (uint32_t)hx;
	xw_u.parts.lsw = lx;
	return (double)xw_u.value;
}


#if SUPPORTS_LONG_DOUBLE
/** Returns the next representable value after x in the direction of y; This function is like nextafter, but with a more precise y */
LIB_FUNC long double nexttowardl(long double x, const long double y) {
	ieee854_long_double_shape_type xw_u, yw_u;
	xw_u.value = x;
	xw_u.value = y;
	register int64_t hx = (int64_t)xw_u.parts64.msw;
	register uint64_t lx = xw_u.parts64.lsw;
	register int64_t hy = (int64_t)yw_u.parts64.msw;
	register uint64_t ly = yw_u.parts64.lsw;
	register int64_t ix = (int64_t)(hx & 0x7fffffffffffffffLL);  // |x|
	register int64_t iy = (int64_t)(hy & 0x7fffffffffffffffLL);  // |y|
	if (((ix >= 0x7fff000000000000LL) && ((ix - 0x7fff000000000000LL) | (int64_t)lx) != 0x0) || ((iy >= 0x7fff000000000000LL) && ((iy - 0x7fff000000000000LL) | (int64_t)ly) != 0x0)) { return (long double)(x + y); }  // x or y is nan
	else if (x == y) { return (long double)y; }  // x=y, return y
	else if (((uint64_t)ix | lx) == 0x0) {  // x == 0
		xw_u.parts64.msw = (uint64_t)((uint64_t)hy & (uint64_t)0x8000000000000000ULL);  // Return +-minsubnormal
		xw_u.parts64.lsw = (uint64_t)1;
		raise_flag(x);  // Raise underflow flag
		return (long double)xw_u.value;
	} else if (hx >= 0x0) {  // x > 0
		if (hx > hy || ((hx == hy) && (lx > ly))) {  // x > y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x < y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	} else {  // x < 0
		if (hy >= 0x0 || hx > hy || ((hx == hy) && (lx > ly))) {  // x < y, x -= ulp
			if (lx == 0x0) { --hx; }
			--lx;
		} else {  // x > y, x += ulp
			++lx;
			if (lx == 0x0) { ++hx; }
		}
	}
	hy = (int64_t)(hx & 0x7fff000000000000LL);
	if (hy == 0x7fff000000000000LL) {
		register long double u = (long double)(x + x);  // Overflow
		raise_flag(u);
	} else if (hy == 0x0) {
		register long double u = (long double)(x * x);  // Underflow
		raise_flag(u);  // Raise underflow flag
	}
	xw_u.parts64.msw = (uint64_t)hx;
	xw_u.parts64.lsw = lx;
	return (long double)xw_u.value;
}
#endif


// MOD

/** Breaks x into an integral and a fractional part; The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function */
LIB_FUNC float modff(float x, float* iptr) {
	ieee_float_shape_type xf_u;
	xf_u.value = x;
	register int32_t i0 = (int32_t)xf_u.word;
	register int32_t j0 = (int32_t)(((i0 >> 23) & 0xff) - 0x7f);  // Exponent of x
	if (PREDICT_LIKELY(j0 < 23)) {  // Integer part in x
		if (j0 < 0x0) {  // |x|<1
			SET_FLOAT_WORD(*iptr, (int)(i0 & (int32_t)0x80000000));  // *iptr = +-0
			return x;
		} else {
			register uint32_t i = (uint32_t)((0x7fffff) >> j0);
			if (PREDICT_LIKELY(((((uint32_t)i0) & i) == 0x0))) {  // x is integral
				register uint32_t ix;
				*iptr = x;
				ieee_float_shape_type ixf_u;
				ixf_u.value = x;
				ix = ixf_u.word;
				ixf_u.word = (uint32_t)(ix & (uint32_t)0x80000000);  // return +-0
				return ixf_u.value;
			} else {
				SET_FLOAT_WORD(*iptr, (int)((uint32_t)i0 & (~i)));
				return (x - *iptr);
			}
		}
	} else {  // No fraction part
		*iptr = (x * ONEF);
		if (j0 == 0x80 && (int32_t)(i0 & 0x7fffff)) { return (x * ONEF); }  // Handle NaNs separately
		SET_FLOAT_WORD(x, (int)((uint32_t)i0 & (uint32_t)0x80000000));  // return +-0
		return x;
	}
	UNREACHABLE
}


/** Breaks x into an integral and a fractional part; The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function */
LIB_FUNC double modf(double x, double* iptr) {
	ieee_double_shape_type xw_u;
	xw_u.value = x;
	register int32_t i0 = (int32_t)xw_u.parts.msw;
	register int32_t i1 = (int32_t)xw_u.parts.lsw;
	register int32_t j0 = (int32_t)(((i0 >> 20) & 0x7ff) - 0x3ff);  // Exponent of x
	if (PREDICT_LIKELY(j0 < 20)) {  // Integer part in high x
		if (j0 < 0x0) {  // |x|<1
			xw_u.parts.msw = (uint32_t)(i0 & (int32_t)0x80000000);
			xw_u.parts.lsw = (uint32_t)0;  // *iptr = +-0
			return (double)xw_u.value;
		} else {
			register uint32_t i = (uint32_t)(0xfffff >> j0);
			if (PREDICT_LIKELY(((uint32_t)(((uint32_t)i0) & i) | (uint32_t)i1) == 0x0)) {  // x is integral
				*iptr = x;
				xw_u.parts.msw = (uint32_t)(i0 & (int32_t)0x80000000);
				xw_u.parts.lsw = (uint32_t)0;  // return +-0
				return (double)xw_u.value;  // return +-0
			} else {
				xw_u.parts.msw = (uint32_t)((uint32_t)i0 & (uint32_t)(~i));
				xw_u.parts.lsw = (uint32_t)0;
				return (double)(x - xw_u.value);
			}
		}
	} else if (j0 > 51) {  // No fraction part
		*iptr = (x * 1.0);
		if (j0 == 0x400 && ((int32_t)(i0 & (int32_t)0xfffff) | i1)) { return (double)(x * 1.0); }  // Handle NaNs separately
		xw_u.parts.msw = (uint32_t)((uint32_t)i0 & (uint32_t)0x80000000);
		xw_u.parts.lsw = (uint32_t)0;
		return (double)xw_u.value;  // Return +-0
	} else {  // Fraction part in low x
		register uint32_t i = (uint32_t)((uint32_t)(0xffffffff)) >> (j0 - 20);
		if (PREDICT_LIKELY((i1 & (int32_t)i) == 0)) {  // x is integral
			*iptr = x;
			ieee_double_shape_type ixw_u;
			ixw_u.parts.msw = (uint32_t)((uint32_t)i0 & (uint32_t)0x80000000);
			ixw_u.parts.lsw = (uint32_t)0;
			return (double)ixw_u.value;  // Return +-0
		} else {
			xw_u.parts.msw = (uint32_t)i0;
			xw_u.parts.lsw = (uint32_t)(((uint32_t)i1) & (~i));
			return (double)(x - xw_u.value);
		}
	}
	UNREACHABLE
}


#if SUPPORTS_LONG_DOUBLE
/** Breaks x into an integral and a fractional part; The integer part is stored in the object pointed by intpart, and the fractional part is returned by the function */
LIB_FUNC long double modfl(long double x, long double* iptr) {
	ieee854_long_double_shape_type xw_u;
	xw_u.value = x;
	register int64_t i0 = (int64_t)xw_u.parts64.msw;
	register int64_t i1 = (int64_t)xw_u.parts64.lsw;
	register int64_t j0 = (int64_t)(((i0 >> 48) & 0x7fff) - 0x3fff);  // Exponent of x
	if (PREDICT_LIKELY(j0 < 48)) {  // Integer part in high x
		if (j0 < 0) {  // |x|<1
			SET_LDOUBLE_WORDS64(*iptr, (uint64_t)((uint64_t)i0 & 0x8000000000000000ULL), 0);
			return (long double)x;
		} else {
			register uint64_t i = (uint64_t)(0xffffffffffffLL >> j0);
			if (PREDICT_LIKELY(((i0 & (int64_t)i) | i1) == 0)) {  // x is integral
				*iptr = x;
				SET_LDOUBLE_WORDS64(x, (uint64_t)((uint64_t)i0 & 0x8000000000000000ULL) ,0);
				return (long double)x;  // Return +-0
			} else {
				SET_LDOUBLE_WORDS64(*iptr, ((uint64_t)i0 & (~i)), 0);
				return (long double)(x - *iptr);
			}
		}
	} else if (j0 > 111) {  // No fraction part
		*iptr = (x * 1.0L);
		if (j0 == 0x4000 && ((int64_t)(i0 & 0xffffffffffffLL) | i1)) { return (long double)(x * 1.0L); }  // Handle NaNs separately
		SET_LDOUBLE_WORDS64(x, (uint64_t)(i0 & (int64_t)0x8000000000000000LL), 0);
		return (long double)x;  // Return +-0
	} else {  // Fraction part in low x
		register uint64_t i = (uint64_t)(((int64_t)-1LL) >> (int64_t)(j0 - 48));
		if (PREDICT_LIKELY((i1 & (int64_t)i) == 0)) {  // x is integral
			*iptr = x;
			SET_LDOUBLE_WORDS64(x, (uint64_t)(i0 & (int64_t)0x8000000000000000LL), 0);
			return (long double)x;  // Return +-0
		} else {
			SET_LDOUBLE_WORDS64(*iptr, i0, ((uint64_t)i1 & (~i)));
			return (long double)(x - *iptr);
		}
	}
}
#endif


// MATH ERROR-HANDLING FUNCTIONS


/** Handle errors for a libm function as specified by TYPE, with arguments X and Y, returning the appropriate return value for that function

@section Mapping for exception cases
 - 1: acos(|x|>1)
 - 2: asin(|x|>1)
 - 3: atan2(+-0,+-0)
 - 4: hypot overflow
 - 5: cosh overflow
 - 6: exp overflow
 - 7: exp underflow
 - 8: y0(0)
 - 9: y0(-ve)
 - 10: y1(0)
 - 11: y1(-ve)
 - 12: yn(0)
 - 13: yn(-ve)
 - 14: lgamma(finite) overflow
 - 15: lgamma(-integer)
 - 16: log(0)
 - 17: log(x<0)
 - 18: log10(0)
 - 19: log10(x<0)
 - 20: pow(0.0,0.0)
 - 21: pow(x,y) overflow
 - 22: pow(x,y) underflow
 - 23: pow(0,negative)
 - 24: pow(neg,non-integral)
 - 25: sinh(finite) overflow
 - 26: sqrt(negative)
 - 27: fmod(x,0)
 - 28: remainder(x,0)
 - 29: acosh(x<1)
 - 30: atanh(|x|>1)
 - 31: atanh(|x|=1)
 - 32: scalb overflow
 - 33: scalb underflow
 - 34: j0(|x|>X_TLOSS)
 - 35: y0(x>X_TLOSS)
 - 36: j1(|x|>X_TLOSS)
 - 37: y1(x>X_TLOSS)
 - 38: jn(|x|>X_TLOSS, n)
 - 39: yn(x>X_TLOSS, n)
 - 40: tgamma(finite) overflow
 - 41: tgamma(-integer)
 - 42: pow(NaN,0.0)
 - 43: +0**neg
 - 44: exp2 overflow
 - 45: exp2 underflow
 - 46: exp10 overflow
 - 47: exp10 underflow
 - 48: log2(0)
 - 49: log2(x<0)
 - 50: tgamma(+-0)
*/
LIB_FUNC double __kernel_standard(const double x, double y, const int type) {
	struct exception exc;
#define kernel_standard_CSTR(func)   ((const char*)(type < 100 ? func : (type < 200 ? func "f" : func "l")))
	exc.arg1 = x;
	exc.arg2 = y;
	switch (type) {
		case 1:
		case 101:
		case 201:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("acos");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 2:
		case 102:
		case 202:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("asin");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 3:
		case 103:
		case 203:
			exc.arg1 = y;
			exc.arg2 = x;
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("atan2");
			exc.retval = HUGE;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 4:
		case 104:
		case 204:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("hypot");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 5:
		case 105:
		case 205:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("cosh");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 6:
		case 106:
		case 206:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("exp");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 7:
		case 107:
		case 207:
			exc.type = UNDERFLOW;
			exc.name = kernel_standard_CSTR("exp");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 8:
		case 108:
		case 208:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("y0");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 9:
		case 109:
		case 209:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("y0");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 10:
		case 110:
		case 210:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("y1");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 11:
		case 111:
		case 211:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("y1");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 12:
		case 112:
		case 212:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("yn");
			exc.retval = ((x < 0 && ((int) x & 1) != 0) ? HUGE_VAL : -HUGE_VAL);
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 13:
		case 113:
		case 213:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("yn");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 14:
		case 114:
		case 214:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("lgamma");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 15:
		case 115:
		case 215:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("lgamma");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 16:
		case 116:
		case 216:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("log");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 17:
		case 117:
		case 217:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("log");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 18:
		case 118:
		case 218:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("log10");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 19:
		case 119:
		case 219:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("log10");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 20:
		case 120:
		case 220:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = 0.0;
			exc.retval = 1.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 21:
		case 121:
		case 221:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = HUGE_VAL;
			y *= 0.5;
			if (x < 0.0 && __rint(y) != y) { exc.retval = -HUGE_VAL; }
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 22:
		case 122:
		case 222:
			exc.type = UNDERFLOW;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = 0.0;
			y *= 0.5;
			if (x < 0.0 && __rint(y) != y) { exc.retval = -0.0; }
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 23:
		case 123:
		case 223:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 43:
		case 143:
		case 243:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 24:
		case 124:
		case 224:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 25:
		case 125:
		case 225:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("sinh");
			exc.retval = ((x > 0.0) ? HUGE_VAL : -HUGE_VAL);
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 26:
		case 126:
		case 226:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("sqrt");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 27:
		case 127:
		case 227:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("fmod");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 28:
		case 128:
		case 228:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("remainder");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 29:
		case 129:
		case 229:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("acosh");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 30:
		case 130:
		case 230:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("atanh");
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 31:
		case 131:
		case 231:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("atanh");
			exc.retval = x / 0.0;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 32:
		case 132:
		case 232:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("scalb");
			exc.retval = x > 0.0 ? HUGE_VAL : -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 33:
		case 133:
		case 233:
			exc.type = UNDERFLOW;
			exc.name = kernel_standard_CSTR("scalb");
			exc.retval = copysign(0.0, x);
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 34:
		case 134:
		case 234:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("j0");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 35:
		case 135:
		case 235:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("y0");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 36:
		case 136:
		case 236:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("j1");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 37:
		case 137:
		case 237:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("y1");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 38:
		case 138:
		case 238:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("jn");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 39:
		case 139:
		case 239:
			exc.type = TLOSS;
			exc.name = kernel_standard_CSTR("yn");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 40:
		case 140:
		case 240:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("tgamma");
			exc.retval = copysign(HUGE_VAL, x);
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 41:
		case 141:
		case 241:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("tgamma");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 42:
		case 142:
		case 242:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("pow");
			exc.retval = x;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 44:
		case 144:
		case 244:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("exp2");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 45:
		case 145:
		case 245:
			exc.type = UNDERFLOW;
			exc.name = kernel_standard_CSTR("exp2");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 46:
		case 146:
		case 246:
			exc.type = OVERFLOW;
			exc.name = kernel_standard_CSTR("exp10");
			exc.retval = HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 47:
		case 147:
		case 247:
			exc.type = UNDERFLOW;
			exc.name = kernel_standard_CSTR("exp10");
			exc.retval = 0.0;
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		case 48:
		case 148:
		case 248:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("log2");
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 49:
		case 149:
		case 249:
			exc.type = DOMAIN;
			exc.name = kernel_standard_CSTR("log2");
			exc.retval = NAN;
			if (!matherr(&exc)) { __set_errno(EDOM); }
			break;
		case 50:
		case 150:
		case 250:
			exc.type = SING;
			exc.name = kernel_standard_CSTR("tgamma");
			exc.retval = copysign(HUGE_VAL, x);
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			break;
		default:
			break;
	}
#undef kernel_standard_CSTR
	return exc.retval;
}


/** Handle errors for a libm function as specified by TYPE, with arguments X and Y, returning the appropriate return value for that function */
LIB_FUNC float __kernel_standard_f(const float x, const float y, const int type) {
	return (float)__kernel_standard(x, (double)y, type);
}


/** Handle errors for a libm function as specified by TYPE, with arguments X and Y, returning the appropriate return value for that function */
LIB_FUNC long double __kernel_standard_l(const long double x, long double y, const int type) {
	struct exception exc;
	fenv_t env;
	feholdexcept(&env);
	double dx = (double)x;
	double dy = (double)y;
	math_force_eval(dx);
	math_force_eval(dy);
	fesetenv(&env);
	switch (type) {
		case 221:
			exc.arg1 = dx;
			exc.arg2 = dy;
			exc.type = OVERFLOW;
			exc.name = (const char*)"powl";
			exc.retval = HUGE_VAL;
			y *= 0.5;
			if (x < 0.0 && rintl(y) != y) { exc.retval = -HUGE_VAL; }
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			return exc.retval;
		case 222:
			exc.arg1 = dx;
			exc.arg2 = dy;
			exc.type = UNDERFLOW;
			exc.name = (const char*)"powl";
			exc.retval = 0.0;
			y *= 0.5;
			if (x < 0.0 && rintl(y) != y) { exc.retval = -0.0; }
			if (!matherr(&exc)) { __set_errno(ERANGE); }
			return exc.retval;
		default:
			return __kernel_standard(dx, dy, type);
	}
}


// IBM LONG DOUBLE FUNCTIONS

/** Extract high double */
#define ldbl_high(x)   ((double)x)


#if (SUPPORTS_LONG_DOUBLE && SUPPORTS_LONG_DOUBLE_128 && (SIZEOF_LONG_DOUBLE == 128) && (!(LONG_DOUBLE_IS_BINARY64 || LONG_DOUBLE_IS_X87_EXTENDED)))


LIB_FUNC void ldbl_extract_mantissa(int64_t* hi64, uint64_t* lo64, int* exp, long double x) {
	uint64_t hi, lo;
	union ibm_extended_long_double u;
	u.ld = x;
	*exp = u.d[0].ieee.exponent - IEEE754_DOUBLE_BIAS;
	lo = ((uint64_t)u.d[1].ieee.mantissa0 << 32) | u.d[1].ieee.mantissa1;
	hi = ((uint64_t)u.d[0].ieee.mantissa0 << 32) | u.d[0].ieee.mantissa1;
	if (u.d[0].ieee.exponent != 0) {
		int ediff;
		hi |= (uint64_t)0x100000;
		if (u.d[1].ieee.exponent != 0) { lo |= (uint64_t)0x100000; }
		else { lo <<= 1; }
		lo <<= 7;
		ediff = u.d[0].ieee.exponent - u.d[1].ieee.exponent - 53;
		if (ediff > 0) {
			if (ediff < 64) { lo >>= ediff; }
			else { lo = 0; }
		} else if (ediff < 0) { lo <<= -ediff; }
		if (u.d[0].ieee.negative != u.d[1].ieee.negative && lo != 0) {
			hi--;
			lo = ((uint64_t)0x10000000) - lo;
			if (hi < (uint64_t)0x100000) {
				hi = (hi << 1) | (lo >> 59);
				lo = (((uint64_t)0x10000000) - 1) & (lo << 1);
				*exp = *exp - 1;
			}
		}
	} else { hi = hi << 1; }
	*lo64 = (hi << 60) | lo;
	*hi64 = (int64_t)(hi >> 4);
}


LIB_FUNC long double ldbl_insert_mantissa(int sign, int exp, int64_t hi64, uint64_t lo64) {
	union ibm_extended_long_double u;
	int expnt2;
	uint64_t hi, lo;
	u.d[0].ieee.negative = sign;
	u.d[1].ieee.negative = sign;
	u.d[0].ieee.exponent = exp + IEEE754_DOUBLE_BIAS;
	u.d[1].ieee.exponent = 0;
	expnt2 = exp - 53 + IEEE754_DOUBLE_BIAS;
	lo = (lo64 >> 7) & (((uint64_t)0x200000) - 1);
	hi = lo64 >> 60;
	hi |= ((uint64_t)(hi64 << 4));
	if (lo != 0) {
		if ((lo & ((uint64_t)0x100000)) != 0 && ((hi & 1) != 0 || (lo & (((uint64_t)0x100000) - 1)) != 0)) {
			hi++;
			if ((hi & ((uint64_t)0x200000)) != 0) {
				hi = hi >> 1;
				u.d[0].ieee.exponent++;
			}
			u.d[1].ieee.negative = !(sign);
			lo = ((uint64_t)0x200000) - lo;
		}
		int lzcount;
		if (sizeof(lo) == SIZEOF_LONG) { lzcount = clzl(lo); }
		else if ((lo >> 32) != 0) { lzcount = clzl((long)(lo >> 32)); }
		else { lzcount = clzl((unsigned long)lo) + 32; }
		lzcount -= 0xb;
		lo <<= lzcount;
		expnt2 -= lzcount;
		if (expnt2 >= 1) { u.d[1].ieee.exponent = expnt2; }
		else {
			if (expnt2 > -53) { lo >>= 1 - expnt2; }
			else { lo = 0; }
		}
	} else { u.d[1].ieee.negative = 0; }
	u.d[1].ieee.mantissa1 = lo;
	u.d[1].ieee.mantissa0 = lo >> 32;
	u.d[0].ieee.mantissa1 = hi;
	u.d[0].ieee.mantissa0 = hi >> 32;
	return u.ld;
}


/** Pack/Unpack/Cononicalize and find the nearbyint of long double implemented as double double */
LIB_FUNC long double default_ldbl_pack(const double a, const double aa) {
	union ibm_extended_long_double u;
	u.d[0].d = a;
	u.d[1].d = aa;
	return u.ld;
}


LIB_FUNC void default_ldbl_unpack(const long double l, double* a, double* aa) {
	union ibm_extended_long_double u;
	u.ld = l;
	*a = u.d[0].d;
	*aa = u.d[1].d;
}

#ifndef ldbl_pack
#   define ldbl_pack(a, aa)   default_ldbl_pack((a), (aa))
#endif
#ifndef ldbl_unpack
#   define ldbl_unpack(l, a, aa)   default_ldbl_unpack((l), (a), (aa))
#endif


/** Convert a finite long double to canonical form; Does not handle +/-Inf properly */
LIB_FUNC void ldbl_canonicalize(double* a, double* aa) {
	double xh, xl;
	xh = *a + *aa;
	xl = (*a - xh) + *aa;
	*a = xh;
	*aa = xl;
}


/** Simple inline nearbyint function */
LIB_FUNC double ldbl_nearbyint(double a) {
	if (PREDICT_LIKELY((fabs(a) < 0x1p52))) {
		if (PREDICT_LIKELY((a > 0.0))) {
			a += 0x1p52;
			a -= 0x1p52;
		} else if (a < 0.0) {
			a = 0x1p52 - a;
			a = -(a - 0x1p52);
		}
	}
	return a;
}


#endif


#ifdef ARCHPOWERPC


LIB_FUNC long double ldbl_pack_ppc(const double a, const double aa) {
	register long double x asm ("fr1");
	register double xh asm ("fr1");
	register double xl asm ("fr2");
	xh = a;
	xl = aa;
	asm (";" : "=f"(x) : "f"(xh), "f"(xl));
	return x;
}
#   define ldbl_pack(a, aa)   ldbl_pack_ppc((a), (aa))


LIB_FUNC void ldbl_unpack_ppc(const long double l, double* a, double* aa) {
	register long double x asm ("fr1");
	register double xh asm ("fr1");
	register double xl asm ("fr2");
	x = l;
	asm (";" : "=f"(xh), "=f"(xl) : "f"(x));
	*a = xh;
	*aa = xl;
}
#   define ldbl_unpack(l, a, aa)   ldbl_unpack_ppc((l), (a), (aa))


#endif


// SCAL FUNCTIONS

LIB_FUNC float scalbnf(float x, const int num) {
	int32_t k, ix;
	uint32_t hx;
	register int n = num;
	GET_FLOAT_WORD(ix, x);
	hx = ix & 0x7fffffff;
	k = (int32_t)(hx >> 23);
	if (FLT_UWORD_IS_ZERO(hx)) { return x; }
	else if (!FLT_UWORD_IS_FINITE(hx)) { return x + x; }
	else if (FLT_UWORD_IS_SUBNORMAL(hx)) {
		x = (float)(x * ((float)3.355443200e+07));
		GET_FLOAT_WORD(ix, x);
		k = ((ix & 0x7f800000) >> 23) - 25;
		if (n < -50000) { return (float)(((float)1.0e-30) * x); }
	}
	k += n;
	if (k > FLT_LARGEST_EXP) { return (float)((float)1.0e+30 * copysignf((float)1.0e+30, x)); }
	else if (k > 0) { SET_FLOAT_WORD(x, (int)((unsigned int)((unsigned int)ix & 0x807fffff) | (unsigned int)(k << 23))); return x; }
	if (k < FLT_SMALLEST_EXP) {
		if (n > OVERFLOW_INT) { return ((float)1.0e+30 * copysignf((float)1.0e+30, x)); }
		else { return (float)((float)1.0e-30 * copysignf((float)1.0e-30, x)); }
	}
	k += 25;
	SET_FLOAT_WORD(x, (int)((unsigned int)((unsigned int)ix & 0x807fffff) | (unsigned int)(k << 23)));
	return (float)(x * (float)2.9802322388e-08);
}
#define ldexpf(x, n)   scalbnf((x), (n))
#define __scalbnf(x, n)   scalbnf((x), (n))


LIB_FUNC double scalbn(double x, const int n) {
	return (double)scalbnf((float)x, n);
}
#define ldexp(x, n)   scalbn((x), (n))
#define __scalbn(x, n)   scalbn((x), (n))


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double scalbnl(long double x, const int n) {
	register int n = num;
	return scalbn(x, n);
}
#elif ((LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384)
LIB_FUNC long double scalbnl(long double x, const int num) {
	union ldshape u;
	register int n = num;
	if (n > 16383) {
		x *= 0x1p16383L;
		n -= 16383;
		if (n > 16383) {
			x *= 0x1p16383L;
			n -= 16383;
			if (n > 16383) { n = 16383; }
		}
	} else if (n < -16382) {
		x *= 0x1p-16382L;
		n += 16382;
		if (n < -16382) {
			x *= 0x1p-16382L;
			n += 16382;
			if (n < -16382) { n = -16382; }
		}
	}
	u.f = 1.0;
	u.i.se = (uint16_t)(0x3fff + n);
	return x * u.f;
}
#endif
#define ldexpl(x, n)   scalbnl((x), (n))
#define __scalbnl(x, n)   scalbnl((x), (n))


LIB_FUNC float scalblnf(float x, const long n) {
	int32_t k, ix;
	GET_FLOAT_WORD(ix, x);
	k = (ix & 0x7f800000) >> 23;
	if (k == 0) {
		if ((ix & 0x7fffffff) == 0) { return x; }
		x *= (float)3.355443200e+07;
		GET_FLOAT_WORD(ix,x);
		k = ((ix & 0x7f800000) >> 23) - 25;
	}
	if (k == 0xff) { return x + x; }
	k += (int32_t)n;
	if (n > 50000 || k > 0xfe) { return (float)1.0e+30 * copysignf((float)1.0e+30, x); }
	else if (n < -50000) { return (float)1.0e-30 * copysignf((float)1.0e-30, x); }
	else if (k > 0) { SET_FLOAT_WORD(x, (int)((unsigned int)((unsigned int)ix & 0x807fffff) | (unsigned int)(k << 23))); return x; }
	else if (k <= -25) { return (float)1.0e-30 * copysignf((float)1.0e-30, x); }
	k += 25;
	SET_FLOAT_WORD(x, (int)((unsigned int)((unsigned int)ix & 0x807fffff) | (unsigned int)(k << 23)));
	return x * (float)2.9802322388e-08;
}
#define __scalblnf(x, n)   scalblnf((x), (n))


LIB_FUNC double scalbln(double x, const long n) {
	int32_t k, hx, lx;
	EXTRACT_SIGNED_WORDS(hx, lx, x);
	k = (hx & 0x7ff00000) >> 20;
	if (k == 0) {
		if ((lx | (hx & 0x7fffffff)) == 0) { return x; }
		x *= (double)1.80143985094819840000e+16;
		GET_HIGH_SIGNED_WORD(hx, x);
		k = ((hx & 0x7ff00000) >> 20) - 54;
	}
	if (k == 0x7ff) { return x + x; }
	k += (int32_t)n;
	if (n > 50000 || k >  0x7fe) { return (double)1.0e+300 * copysign((double)1.0e+300, x); }
	else if (n < -50000) { return (double)1.0e-300 * copysign((double)1.0e-300, x); }
	else if (k > 0) { SET_HIGH_WORD(x, (int)((unsigned int)((uint32_t)hx & 0x800fffff) | (unsigned int)(k << 20))); return x; }
	else if (k <= -54) { return (double)1.0e-300 * copysign((double)1.0e-300, x); }
	k += 54;
	SET_HIGH_WORD(x, (unsigned int)(((unsigned int)hx & 0x800fffff) | (unsigned int)(k << 20)));
	return (double)(x * (double)5.55111512312578270212e-17);
}
#define __scalbln(x, n)   scalbln((x), (n))


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double scalblnl(long double x, const long n) {
	return scalbln(x, n);
}
#else
LIB_FUNC long double scalblnl(long double x, const long n) {
	if (n > INT_MAX) { return scalbnl(x, (int)INT_MAX); }
	else if (n < INT_MIN) { return scalbnl(x, (int)INT_MIN); }
	UNREACHABLE
}
#endif
#define __scalblnl(x, n)   scalblnl((x), (n))


// SGN FUNCTIONS

/** Signum function - extract sign */
LIB_FUNC signed int sgn_int(const signed int num) {
	if (num < 0) { return -1; }
	else if (num > 0) { return 1; }
	return 0;
}


/** Signum function - extract sign */
LIB_FUNC float sgnf(const float num) {
	if (num < (float)0.0F) { return (float)-1.0F; }
	else if (num > (float)0.0F) { return (float)1.0F; }
	else if (num == (float)-0.0F) { return (float)-0.0F; }
	return (float)0.0F;
}


/** Signum function - extract sign */
LIB_FUNC double sgn(const double num) {
	if (num < (double)0.0) { return (double)-1.0; }
	else if (num > (double)0.0) { return (double)1.0; }
	else if (num == (double)-0.0) { return (double)-0.0; }
	return (double)0.0;
}


/** Signum function - extract sign */
LIB_FUNC long double sgnl(const long double num) {
	if (num < (long double)0.0L) { return (long double)-1.0L; }
	else if (num > (long double)0.0L) { return (long double)1.0L; }
	else if (num == (long double)-0.0L) { return (long double)-0.0L; }
	return (long double)0.0L;
}


// POLYNOMIAL FUNCTIONS

/** Generate a Polynomial and then evaluate the equation; if n=4, then c[4]*x^4 + c[3]*x^3 + c[2]*x^2 + c[1]*x + c[0] */
LIB_FUNC double __poly(const double x, const size_t n, const double* restrict c) {
	register double ret = 0.0;
	register size_t i = n;
	c += n;
	do { ret = ((ret * x) + *c--); } while (i--);
	return (double)ret;
}


#if (!LONG_DOUBLE_IS_BINARY64)
/** Polynomial evaluator: P[0] x^n  +  P[1] x^(n-1)  +  ...  +  P[n] */
LIB_FUNC long double __polevll(const long double x, long double* P, int n) {
	long double y = *P++;
	do { y = y * x + *P++; } while (--n);
	return y;
}


/** Polynomial evaluator: x^n  +  P[0] x^(n-1)  +  P[1] x^(n-2)  +  ...  +  P[n] */
LIB_FUNC long double __p1evll(const long double x, long double* P, int n) {
	n -= 1;
	register long double y = x + *P++;
	do { y = y * x + *P++; } while (--n);
	return y;
}
#endif


// POWER FUNCTIONS

LIB_FUNC float __ieee754_powf(const float x, const float y) {
	float z, ax, z_h, z_l, p_h, p_l;
	float y1, t1, t2, r, s, t, u, v, w;
	int32_t i, j, k, yisint, n, hx, hy, ix, iy, is;
	static const float bp[2] = { 1.0F, 1.5F };
	static const float dp_h[2] = { 0.0F, (float)5.84960938e-01 };
	static const float dp_l[2] = { 0.0F, (float)1.56322085e-06 };
	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	ix = hx & 0x7fffffff;
	iy = hy & 0x7fffffff;
	if (FLT_UWORD_IS_ZERO(iy)) { return (float)1.0; }
	else if (FLT_UWORD_IS_NAN(ix) || FLT_UWORD_IS_NAN(iy)) {
		if (ix == 0x3f800000) { return (float)1.0; }
		else { return nanf(""); }
	}
	yisint = 0;
	if (hx < 0) {
		if (iy >= 0x4b800000) { yisint = 2; }
		else if (iy >= 0x3f800000) {
			k = (iy >> 23) - 0x7f;
			j = iy >> (23 - k);
			if ((j << (23 - k)) == iy) { yisint = 2 - (j & 1); }
		}
	}
	if (FLT_UWORD_IS_INFINITE(iy)) {
		if (ix == 0x3f800000) { return (float)1.0; }
		else if (ix > 0x3f800000) { return (hy >= 0) ? y : (float)0.0; }
		else { return (hy < 0) ? -y : (float)0.0; }
	} else if (iy == 0x3f800000) {
		if (hy < 0) { return (float)1.0 / x; }
		else { return x; }
	} else if (hy == 0x40000000) { return x * x; }
	else if (hy == 0x3f000000 && hx >= 0) { return __ieee754_sqrtf(x); }
	ax = fabsf(x);
	if (FLT_UWORD_IS_INFINITE(ix) || FLT_UWORD_IS_ZERO(ix) || ix == 0x3f800000) {
		z = ax;
		if (hy < 0) { z = (float)1.0 / z; }
		if (hx < 0) {
			if (((ix - 0x3f800000) | yisint) == 0) { z = (z - z) / (z - z); }
			else if (yisint == 1) { z = -z; }
		}
		return z;
	} else if (((((uint32_t)hx >> 31) - 1) | (uint32_t)yisint) == 0) { return (x - x) / (x - x); }
	if (iy > 0x4d000000) {
		if (ix < 0x3f7ffff8) { return (hy < 0) ? (float)1.0e30 * (float)1.0e30 : (float)1.0e-30 * (float)1.0e-30; }
		else if (ix > 0x3f800007) { return (hy > 0) ? (float)1.0e30 * (float)1.0e30 : (float)1.0e-30 * (float)1.0e-30; }
		t = ax - 1;
		w = (t * t) * ((float)0.5F - t * ((float)0.333333333333 - t * (float)0.25));
		u = (float)1.4426879883e+00 * t;
		v = t * (float)7.0526075433e-06 - w * (float)1.4426950216e+00;
		t1 = u + v;
		GET_FLOAT_WORD(is, t1);
		SET_FLOAT_WORD(t1, (int)((int32_t)is & (int32_t)0xfffff000));
		t2 = (float)(v - (t1 - u));
	} else {
		float s2, s_h, s_l, t_h, t_l;
		n = 0;
		if (FLT_UWORD_IS_SUBNORMAL(ix)) {
			ax *= (float)16777216.0;
			n -= 24;
			GET_FLOAT_WORD(ix, ax);
		}
		n += ((ix) >> 23) - 0x7f;
		j = ix & 0x7fffff;
		ix = j | 0x3f800000;
		if (j <= 0x1cc471) { k = 0; }
		else if (j < 0x5db3d7) { k = 1; }
		else {
			k = 0;
			n += 1;
			ix -= 0x800000;
		}
		SET_FLOAT_WORD(ax, ix);
		u = ax - bp[k];
		v = (float)1.0F / (ax + bp[k]);
		s = u * v;
		s_h = s;
		GET_FLOAT_WORD(is, s_h);
		SET_FLOAT_WORD(s_h, (int)((int32_t)is & (int32_t)0xfffff000));
		SET_FLOAT_WORD(t_h, ((ix >> 1) | 0x20000000) + 0x40000 + (k << 21));
		t_l = ax - (t_h - bp[k]);
		s_l = v * ((u - s_h * t_h) - s_h * t_l);
		s2 = s * s;
		r = s2 * s2 * ((float)6.0000002384e-01 + s2 * ((float)4.2857143283e-01 + s2 * ((float)3.3333334327e-01 + s2 * ((float)2.7272811532e-01 + s2 * ((float)2.3066075146e-01 + s2 * (float)2.0697501302e-01)))));
		r += s_l * (s_h + s);
		s2 = s_h * s_h;
		t_h = (float)3.0F + s2 + r;
		GET_FLOAT_WORD(is, t_h);
		SET_FLOAT_WORD(t_h, (int)((int32_t)is & (int32_t)0xfffff000));
		t_l = r - ((t_h - (float)3.0F) - s2);
		u = s_h * t_h;
		v = s_l * t_h + t_l * s;
		p_h = u + v;
		GET_FLOAT_WORD(is, p_h);
		SET_FLOAT_WORD(p_h, (int)((int32_t)is & (int32_t)0xfffff000));
		p_l = v - (p_h - u);
		z_h = (float)9.6179199219e-01 * p_h;
		z_l = (float)4.7017383622e-06 * p_h + p_l * (float)9.6179670095e-01 + dp_l[k];
		t = (float)n;
		t1 = (((z_h + z_l) + dp_h[k]) + t);
		GET_FLOAT_WORD(is, t1);
		SET_FLOAT_WORD(t1, (int)((int32_t)is & (int32_t)0xfffff000));
		t2 = z_l - (((t1 - t) - dp_h[k]) - z_h);
	}
	s = (float)1.0F;
	if (((((uint32_t)hx >> 31) - 1) | (uint32_t)(yisint - 1)) == 0) { s = -(float)1.0F; }
	GET_FLOAT_WORD(is, y);
	SET_FLOAT_WORD(y1, (int)((int32_t)is & (int32_t)0xfffff000));
	p_l = (y - y1) * t1 + y * t2;
	p_h = y1 * t1;
	z = p_l + p_h;
	GET_FLOAT_WORD(j, z);
	i = j & 0x7fffffff;
	if (j > 0) {
		if (i > FLT_UWORD_EXP_MAX) { return s * HUGEF * HUGEF; }
		else if (i == FLT_UWORD_EXP_MAX && (p_l + (float)4.2995665694e-08 > z - p_h)) { return s * v * HUGEF; }
	} else {
		if (i > FLT_UWORD_EXP_MIN) { return s * TINYF * TINYF; }
		else if (i == FLT_UWORD_EXP_MIN && (p_l <= z - p_h)) { return s * TINYF * TINYF; }
	}
	k = (i >> 23) - 0x7f;
	n = 0;
	if (i > 0x3f000000) {
		n = j + (0x800000 >> (k + 1));
		k = ((n & 0x7fffffff) >> 23) - 0x7f;
		SET_FLOAT_WORD(t, (n & (~(0x7fffff >> k))));
		n = ((n & 0x7fffff) | 0x800000) >> (23 - k);
		if (j < 0) { n = -n; }
		p_h -= t;
	}
	t = p_l + p_h;
	GET_FLOAT_WORD(is, t);
	SET_FLOAT_WORD(t, (int)((int32_t)is & (int32_t)0xfffff000));
	u = t * (float)6.93145752e-01;
	v = (p_l - (t - p_h)) * (float)6.9314718246e-01 + t * (float)1.42860654e-06;
	z = u + v;
	w = v - (z - u);
	t = z * z;
	t1 = z - t * ((float)1.6666667163e-01 + t * ((float)-2.7777778450e-03 + t * ((float)6.6137559770e-05 + t * ((float)-1.6533901999e-06 + t * (float)4.1381369442e-08))));
	r = (z * t1) / (t1 - (float)2.0) - (w + z * w);
	z = (float)1.0 - (r - z);
	GET_FLOAT_WORD(j, z);
	j += (n << 23);
	if ((j >> 23) <= 0) { z = scalbnf(z, (int)n); }
	else { SET_FLOAT_WORD(z, j); }
	return s * z;
}


LIB_FUNC double __ieee754_pow(const double x, const double y) {
	double z, ax, z_h, z_l, p_h, p_l;
	double y1, t1, t2, r, s, t, u, v, w;
	int32_t i, j, k, n, hx, hy, ix, iy;
	uint32_t lx, ly;
	ieee_double_shape_type ew_su;
	ew_su.value = (double)(x);
	hx = (int32_t)ew_su.parts.msw;
	lx = ew_su.parts.lsw;
	ew_su.value = (double)(y);
	hy = (int32_t)ew_su.parts.msw;
	ly = ew_su.parts.lsw;
	ix = hx & 0x7fffffff;
	iy = hy & 0x7fffffff;
	if (((uint32_t)iy | ly) == 0) { return 1.0; }
	else if (ix > 0x7ff00000 || ((ix == 0x7ff00000) && (lx != 0)) || iy > 0x7ff00000 || ((iy == 0x7ff00000) && (ly != 0))) {
		if (((uint32_t)(ix - 0x3ff00000) | lx) == 0) { return 1.0; }
		else { return nan(""); }
	}
	register int32_t yisint = 0;
	if (hx < 0) {
		if (iy >= 0x43400000) { yisint = 2; }
		else if (iy >= 0x3ff00000) {
			k = (int32_t)((iy >> 20) - 0x3ff);
			if (k > 20) {
				j = (int32_t)(ly >> (52 - k));
				if ((uint32_t)(j << (52 - k)) == ly) { yisint = (2 - (j & 1)); }
			} else if (ly == 0) {
				j = (int32_t)(iy >> (20 - k));
				if ((j << (20 - k)) == iy) { yisint = (2 - (j & 1)); }
			}
		}
	}
	if (ly == 0) {
		if (iy == 0x7ff00000) {
			if (((uint32_t)(ix - 0x3ff00000) | lx) == 0) { return 1.0; }
			else if (ix >= 0x3ff00000) { return (hy >= 0) ? y : 0.0; }
			else { return (hy < 0) ? -y : 0.0; }
		} else if (iy == 0x3ff00000) {
			if (hy < 0) { return 1.0 / x; }
			else { return x; }
		} else if (hy == 0x40000000) { return x * x; }
		else if (hy == 0x3fe00000 && hx >= 0) { return __ieee754_sqrt(x); }
	}
	ax = fabs(x);
	if (lx == 0) {
		if (ix == 0x7ff00000 || ix == 0 || ix == 0x3ff00000) {
			z = ax;
			if (hy < 0) { z = 1.0 / z; }
			if (hx < 0) {
				if (((ix - 0x3ff00000) | yisint) == 0) { z = (z - z) / (z - z); }
				else if (yisint == 1) { z = -z; }
			}
			return z;
		}
	}
	static const double bp[2] = { 1.0, 1.5 };
	static const double dp_h[2] = { 0.0, 5.84962487220764160156e-01 };
	static const double dp_l[2] = { 0.0, 1.35003920212974897128e-08 };
	if (((((uint32_t)hx >> 31) - 1) | (uint32_t)yisint) == 0) { return (x - x) / (x - x); }
	else if (iy > 0x41e00000) {
		if (iy > 0x43f00000) {
			if (ix <= 0x3fefffff) { return (hy < 0) ? 1.0e300 * 1.0e300 : 1.0e-300 * 1.0e-300; }
			else if (ix >= 0x3ff00000) { return (hy > 0) ? 1.0e300 * 1.0e300 : 1.0e-300 * 1.0e-300; }
		}
		else if (ix < 0x3fefffff) { return (hy < 0) ? 1.0e300 * 1.0e300 : 1.0e-300 * 1.0e-300; }
		else if (ix > 0x3ff00000) { return (hy > 0) ? 1.0e300 * 1.0e300 : 1.0e-300 * 1.0e-300; }
		t = ax - 1;
		w = (t * t) * (0.5 - t * (0.3333333333333333333333 - t * 0.25));
		u = (double)1.44269502162933349609e+00 * t;
		v = t * (double)1.92596299112661746887e-08 - w * (double)1.44269504088896338700e+00;
		t1 = u + v;
		SET_LOW_WORD(t1, 0);
		t2 = v - (t1 - u);
	} else {
		register double s2, s_h, s_l, t_h, t_l;
		n = 0;
		if (ix < 0x100000) {
			ax *= (double)9007199254740992.0;
			n -= 53;
			ieee_double_shape_type gh_s;
			gh_s.value = (double)((ax));
			ix = (int32_t)gh_s.parts.msw;
		}
		n += ((ix) >> 20) - 0x3ff;
		j = ix & 0xfffff;
		ix = j | 0x3ff00000;
		if (j <= 0x3988E) { k = 0; }
		else if (j < 0xBB67A) { k = 1; }
		else {
			k = 0;
			n += 1;
			ix -= 0x100000;
		}
		SET_HIGH_WORD(ax, ix);
		u = ax - bp[k];
		v = 1.0 / (ax + bp[k]);
		s = u * v;
		s_h = s;
		SET_LOW_WORD(s_h, 0);
		t_h = 0.0;
		SET_HIGH_WORD(t_h, ((ix >> 1) | 0x20000000) + 0x80000 + (k << 18));
		t_l = ax - (t_h - bp[k]);
		s_l = v * ((u - s_h * t_h) - s_h * t_l);
		s2 = s * s;
		r = s2 * s2 * ((double)5.99999999999994648725e-01 + s2 * ((double)4.28571428578550184252e-01 + s2 * ((double)3.33333329818377432918e-01 + s2 * ((double)2.72728123808534006489e-01 + s2 * ((double)2.30660745775561754067e-01 + s2 * (double)2.06975017800338417784e-01)))));
		r += s_l * (s_h + s);
		s2 = s_h * s_h;
		t_h = 3.0 + s2 + r;
		SET_LOW_WORD(t_h, 0);
		t_l = r - ((t_h - 3.0) - s2);
		u = s_h * t_h;
		v = s_l * t_h + t_l * s;
		p_h = u + v;
		SET_LOW_WORD(p_h, 0);
		p_l = v - (p_h - u);
		z_h = (double)9.61796700954437255859e-01 * p_h;
		z_l = (double)-7.02846165095275826516e-09 * p_h + p_l * (double)9.61796693925975554329e-01 + dp_l[k];
		t = (double)n;
		t1 = (((z_h + z_l) + dp_h[k]) + t);
		SET_LOW_WORD(t1, 0);
		t2 = z_l - (((t1 - t) - dp_h[k]) - z_h);
	}
	s = 1.0;
	if (((((uint32_t)hx >> 31) - 1) | (uint32_t)(yisint - 1)) == 0) { s = -1.0; }
	y1 = y;
	SET_LOW_WORD(y1, 0);
	p_l = (y - y1) * t1 + y * t2;
	p_h = y1 * t1;
	z = p_l + p_h;
	EXTRACT_SIGNED_WORDS(j, i, z);
	if (j >= 0x40900000) {
		if (((j - 0x40900000) | i) != 0) { return s * HUGE * HUGE; }
		else if (p_l + (double)8.0085662595372944372e-0017 > z - p_h) { return s * HUGE * HUGE; }
	} else if ((j & 0x7fffffff) >= 0x4090cc00 ) {
		if (((uint32_t)((uint32_t)j - 0xc090cc00) | (uint32_t)i) != 0) { return s * TINY * TINY; }
		else if (p_l <= z - p_h) { return s * TINY * TINY; }
	}
	i = j & 0x7fffffff;
	k = (i >> 20) - 0x3ff;
	n = 0;
	if (i > 0x3fe00000) {
		n = j + (0x100000 >> (k + 1));
		k = ((n & 0x7fffffff) >> 20) - 0x3ff;
		t = 0.0;
		SET_HIGH_WORD(t, n & (~(0xfffff >> k)));
		n = ((n & 0xfffff) | 0x100000) >> (20 - k);
		if (j < 0) { n = -n; }
		p_h -= t;
	}
	t = p_l + p_h;
	SET_LOW_WORD(t, 0);
	u = t * (double)6.93147182464599609375e-01;
	v = (p_l - (t - p_h)) * (double)6.93147180559945286227e-01 + t * (double)-1.90465429995776804525e-09;
	z = u + v;
	w = v - (z - u);
	t = z * z;
	t1 = z - t * ((double)1.66666666666666019037e-01 + t * ((double)-2.77777777770155933842e-03 + t * ((double)6.61375632143793436117e-05 + t * ((double)-1.65339022054652515390e-06 + t * (double)4.13813679705723846039e-08))));
	r = (z * t1) / (t1 - 2.0) - (w + z * w);
	z = 1.0 - (r - z);
	GET_HIGH_SIGNED_WORD(j, z);
	j += (n << 20);
	if ((j >> 20) <= 0) { z = scalbn(z, (int)n); }
	else { SET_HIGH_WORD(z, j); }
	return s * z;
}


LIB_FUNC double ipow(const double mant, const int expo) {
	register double ret = 1.0;
	register unsigned int e = (unsigned int)expo;
	register double m = mant;
	if ((int)e < 0) {
		e = -e;
		m = 1.0 / m;
	}
	while (1) {
		if (e & 1) { ret *= m; }
		if ((e >>= 1) == 0) { break; }
		m *= m;
	}
	return ret;
}


LIB_FUNC float powf(const float x, const float y) {
#ifdef _IEEE_LIBM
	return __ieee754_powf(x, y);
#else
	struct exception exc;
	float z = __ieee754_powf(x, y);
	if (isnan(x)) {
		if (y == (float)0.0F) {
			exc.type = DOMAIN;
			exc.name = "powf";
			exc.err = 0;
			exc.arg1 = (double)x;
			exc.arg2 = (double)y;
			exc.retval = 1.0;
			if (!matherr(&exc)) { errno = EDOM; }
			if (exc.err != 0) { errno = exc.err; }
			return (float)exc.retval;
		} else { return z; }
	} else if (x == (float)0.0F) {
		if (y == (float)0.0F) {
			exc.type = DOMAIN;
			exc.name = "powf";
			exc.err = 0;
			exc.arg1 = (double)x;
			exc.arg2 = (double)y;
			exc.retval = 0.0;
			if (!matherr(&exc)) { errno = EDOM; }
			if (exc.err != 0) { errno = exc.err; }
			return (float)exc.retval;
		} else if (finitef(y) && y < (float)0.0F) {
			exc.type = DOMAIN;
			exc.name = "powf";
			exc.err = 0;
			exc.arg1 = (double)x;
			exc.arg2 = (double)y;
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { errno = EDOM; }
			if (exc.err != 0) { errno = exc.err; }
			return (float)exc.retval;
		}
		return z;
	}
	if (!finitef(z)) {
		if (finitef(x) && finitef(y)) {
			if (isnan(z)) {
				exc.type = DOMAIN;
				exc.name = "powf";
				exc.err = 0;
				exc.arg1 = (double)x;
				exc.arg2 = (double)y;
				exc.retval = 0.0 / 0.0;
				if (!matherr(&exc)) { errno = EDOM; }
				if (exc.err != 0) { errno = exc.err; }
				return (float)exc.retval;
			} else {
				exc.type = OVERFLOW;
				exc.name = "powf";
				exc.err = 0;
				exc.arg1 = (double)x;
				exc.arg2 = (double)y;
				exc.retval = HUGE_VAL;
				register const float y5 = (0.5F * y);
				if (x < 0.0F && rintf(y5) != y5) { exc.retval = -HUGE_VAL; }
				if (!matherr(&exc)) { errno = ERANGE; }
				if (exc.err != 0) { errno = exc.err; }
				return (float)exc.retval;
			}
		}
	} else if (z == (float)0.0F && finitef(x) && finitef(y)) {
		exc.type = UNDERFLOW;
		exc.name = "powf";
		exc.err = 0;
		exc.arg1 = (double)x;
		exc.arg2 = (double)y;
		exc.retval = 0.0;
		if (!matherr(&exc)) { errno = ERANGE; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	}
	return z;
#endif
}


LIB_FUNC double pow(const double x, const double y) {
#ifdef _IEEE_LIBM
	return __ieee754_pow(x, y);
#else
	double z = __ieee754_pow(x, y);
	struct exception exc;
	if (_LIB_VERSION == _IEEE_ || __isnan(y)) { return z; }
	if (__isnan(x)) {
		if (y == 0.0) {
		exc.type = DOMAIN;
		exc.name = "pow";
		exc.err = 0;
		exc.arg1 = x;
		exc.arg2 = y;
		exc.retval = 1.0;
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; return exc.retval; }
		} else { return z; }
	} else if (x == 0.0) {
		if (y == 0.0) {
			exc.type = DOMAIN;
			exc.name = "pow";
			exc.err = 0;
			exc.arg1 = x;
			exc.arg2 = y;
			exc.retval = 0.0;
			if (!matherr(&exc)) { errno = EDOM; }
			if (exc.err != 0) { errno = exc.err; }
			return exc.retval;
		} else if (finite(y) && y < 0.0) {
			exc.type = DOMAIN;
			exc.name = "pow";
			exc.err = 0;
			exc.arg1 = x;
			exc.arg2 = y;
			exc.retval = -HUGE_VAL;
			if (!matherr(&exc)) { errno = EDOM; }
			if (exc.err != 0) { errno = exc.err; }
			return exc.retval;
		}
		return z;
	} else if (!finite(z)) {
		if (finite(x) && finite(y)) {
			if (__isnan(z)) {
				exc.type = DOMAIN;
				exc.name = "pow";
				exc.err = 0;
				exc.arg1 = x;
				exc.arg2 = y;
				exc.retval = 0.0 / 0.0;
				if (!matherr(&exc)) { errno = EDOM; }
				if (exc.err != 0) { errno = exc.err; }
				return exc.retval;
			} else {
				exc.type = OVERFLOW;
				exc.name = "pow";
				exc.err = 0;
				exc.arg1 = x;
				exc.arg2 = y;
				exc.retval = HUGE_VAL;
				register const double y5 = (0.5 * y);
				if (x < 0.0 && rint(y5) != y5) { exc.retval = -HUGE_VAL; }
				if (!matherr(&exc)) { errno = ERANGE; }
				if (exc.err != 0) { errno = exc.err; }
				return exc.retval;
			}
		}
	}
	if (z == 0.0 && finite(x) && finite(y)) {
		exc.type = UNDERFLOW;
		exc.name = "pow";
		exc.err = 0;
		exc.arg1 = x;
		exc.arg2 = y;
		exc.retval = 0.0;
		if (!matherr(&exc)) { errno = ERANGE; }
		else if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	}
	return z;
#endif
}


#include "t_exp2f.h"
#include "t_exp.h"
#include "t_exp2.h"
LIB_FUNC float __ieee754_expf(const float x) {
	if (isless(x, 88.72283935546875F) && isgreater(x, -103.972084045410F)) {
		int tval;
		double x22, t, result, dx;
		float n, delta;
		union ieee754_double ex2_u;
		n = x * 1.44269502163F + 12582912.0F;
		n -= 12582912.0F;
		dx = (double)(x - n * 0.6931471805599452862F);
		t = dx + 13194139533312.0;
		t -= 13194139533312.0;
		dx -= t;
		tval = (int)(t * 512.0);
		if (t >= 0) { delta = -(__exp_deltatable[tval]); }
		else { delta = __exp_deltatable[-tval]; }
		ex2_u.d = __exp_atable[tval + 177];
		uint11_t tmpval;
		tmpval.val16 = (unsigned short)(ex2_u.ieee.exponent + (unsigned short)n);
		ex2_u.ieee.exponent = tmpval.val11;
		x22 = (0.5000000496709180453 * dx + 1.0000001192102037084) * dx + (double)delta;
		result = x22 * ex2_u.d + ex2_u.d;
		return (float)result;
	} else if (isless(x, 88.72283935546875F)) {
		if (isinf(x)) { return 0; }
		else { return 7.88860905e-31F * 7.88860905e-31F; }
	} else { return 1.7014118346e+38F * x; }
}
#define __expf_finite(x)   __ieee754_expf((x))


#if LONG_DOUBLE_IS_BINARY128
#   include "t_expl.h"
LIB_FUNC long double __ieee754_expl(const long double num) {
	long double x = num;
	if (__islessl(x, 11356.523406294143949491931077970765L) && __isgreaterl(x, -11433.4627433362978788372438434526231L)) {
		int tval1, tval2, unsafe, n_i;
		long double x22, n, t, result, xl;
		union ieee854_long_double ex2_u, scale_u;
		fenv_t oldenv;
		feholdexcept(&oldenv);
#   ifdef FE_TONEAREST
		fesetround(FE_TONEAREST);
#   endif
		n = x * 1.44269504088896340735992468100189204L + 7788445287802241442795744493830144.0L;
		n -= 7788445287802241442795744493830144.0L;
		x = x - n * 0.693147180559945309417232121457981864L;
		xl = n * -1.94704509238074995158795957333327386E-31L;
		t = x + 30423614405477505635920876929024.0L;
		t -= 30423614405477505635920876929024.0L;
		tval1 = (int)(t * 256.0L);
		x -= __expl_table[T_EXPL_ARG1 + 2 * tval1];
		xl -= __expl_table[T_EXPL_ARG1 + 2 * tval1 + 1];
		t = x + 59421121885698253195157962752.0L;
		t -= 59421121885698253195157962752.0L;
		tval2 = (int)(t * 32768.0L);
		x -= __expl_table[T_EXPL_ARG2 + 2 * tval2];
		xl -= __expl_table[T_EXPL_ARG2 + 2 * tval2 + 1];
		x = x + xl;
		ex2_u.ld = __expl_table[T_EXPL_RES1 + tval1] * __expl_table[T_EXPL_RES2 + tval2];
		n_i = (int)n;
		unsafe = (abs(n_i) >= 15000);
#   if (LDBL_EXP_BITS == 11)
		uint11_t tmpval;
		tmpval.val16 = (unsigned short)(ex2_u.ieee.exponent + (unsigned short)(n_i >> unsafe));
		ex2_u.ieee.exponent = tmpval.val11;
		scale_u.ld = 1.0L;
		tmpval.val11 = scale_u.ieee.exponent;
		tmpval.val16 = (unsigned short)(((int)tmpval.val16 + n_i) - (n_i >> unsafe));
		scale_u.ieee.exponent = tmpval.val11;
#   elif (LDBL_EXP_BITS == 15)
		uint15_t tmpval;
		tmpval.val16 = (unsigned short)(ex2_u.ieee.exponent + (unsigned short)(n_i >> unsafe));
		ex2_u.ieee.exponent = tmpval.val15;
		scale_u.ld = 1.0L;
		tmpval.val15 = scale_u.ieee.exponent;
		tmpval.val16 = (unsigned short)(((int)tmpval.val16 + n_i) - (n_i >> unsafe));
		scale_u.ieee.exponent = tmpval.val15;
#   endif
		x22 = x + x * x * (0.5L + x * (1.66666666666666666666666666666666683E-01L + x * (4.16666666666666666666654902320001674E-02L + x * (8.33333333333333333333314659767198461E-03L + x * (1.38888888889899438565058018857254025E-03L + x * 1.98412698413981650382436541785404286E-04L)))));
		fesetenv(&oldenv);
		result = x22 * ex2_u.ld + ex2_u.ld;
		if (!unsafe) { return result; }
		else {
			result *= scale_u.ld;
			math_check_force_underflow_nonneg(result);
			return result;
		}
	} else if (__islessl(x, 11356.523406294143949491931077970765L)) {
		if (__isinfl(x)) { return 0; }
		else { return 1.0e-4900L * 1.0e-4900L; }
	} else { return 5.94865747678615882542879663314003565E+4931L * x; }
}
#   define __expl_finite(x)   __ieee754_expl((x))


LIB_FUNC long double __ieee754_exp2l(const long double x) {
	if (PREDICT_LIKELY(__islessl(x, (long double)LDBL_MAX_EXP))) {
		if (PREDICT_LIKELY(__isgreaterequall(x, (long double)(LDBL_MIN_EXP - LDBL_MANT_DIG - 1)))) {
			int intx = (int) x;
			long double fractx = x - intx;
			long double result;
			if (fabsl(fractx) < LDBL_EPSILON / 4.0L) { result = scalbnl(1.0L + fractx, intx); }
			else { result = scalbnl(__ieee754_expl(M_LN2l * fractx), intx); }
			math_check_force_underflow_nonneg(result);
			return result;
		} else {
			if (__isinfl(x)) { return 0; }
			else { return LDBL_MIN * LDBL_MIN; }
		}
	} else { return LDBL_MAX * x; }
}
#   define __exp2l_finite(x)   __ieee754_exp2l((x))
#endif


LIB_FUNC float __ieee754_exp10f(const float arg) {
	if (isfinitef(arg) && arg < (FLT_MIN_10_EXP - FLT_DIG - 10)) { return FLT_MIN * FLT_MIN; }
	return expf((M_LN10F * arg));
}
#define __exp10f_finite(x)   __ieee754_exp10f((x))


LIB_FUNC double __ieee754_exp10(const double arg) {
	if (isfinite(arg) && arg < (DBL_MIN_10_EXP - DBL_DIG - 10)) { return DBL_MIN * DBL_MIN; }
	return exp(M_LN10 * arg);
}
#define __exp10_finite(x)   __ieee754_exp10((x))


#if LONG_DOUBLE_IS_BINARY128
LIB_FUNC long double __ieee754_exp10l(const long double arg) {
	if (isfinitel(arg) && arg < (LDBL_MIN_10_EXP - LDBL_DIG - 10)) { return LDBL_MIN * LDBL_MIN; }
	return __ieee754_expl(M_LN10l * arg);
}
#   define __exp10l_finite(x)   __ieee754_exp10l((x))
#endif


LIB_FUNC float expf(const float num) {
	float c, y, x = num;
	uint32_t hx;
	GET_FLOAT_UWORD(hx, x);
	register int k, sign = (int)(hx >> 31);
	hx &= 0x7fffffff;
	if (hx >= 0x42aeac50) {
		if (hx >= 0x42b17218 && !sign) {
			x *= 0x1p127f;
			return x;
		} else if (sign) {
			FORCE_EVAL(((float)(-0x1p-149) / x));
			if (hx >= 0x42cff1b5) { return 0; }
		}
	}
	static const float expf_half[2] = { 0.5F, -0.5F };
	float hi, lo;
	if (hx > 0x3eb17218) {
		if (hx > 0x3f851592) { k = (int)(1.4426950216e+0F * x + expf_half[sign]); }
		else { k = (1 - sign) - sign; }
		hi = (x - ((float)k) * 6.9314575195e-1f);
		lo = (float)k * 1.4286067653e-6f;
		x = hi - lo;
	} else if (hx > 0x39000000) {
		k = 0;
		hi = x;
		lo = 0;
	} else {
		FORCE_EVAL(0x1p127F + x);
		return (1.0F + x);
	}
	register float xx = x * x;
	c = x - xx * (1.6666625440e-1f + xx * -2.7667332906e-3f);
	y = 1 + (x * c / (2 - c) - lo + hi);
	if (k == 0) { return y; }
	return scalbnf(y, k);
}


LIB_FUNC double exp(const double num) {
	double x = num, c, y;
	uint32_t hx;
	GET_HIGH_WORD(hx, x);
	int k, sign = (int)(hx >> 31);
	hx &= 0x7fffffff;
	if (hx >= 0x4086232b) {
		if (__isnan(x)) { return x; }
		else if (x > 709.782712893383973096) {
			x *= 0x1p1023;
			return x;
		} else if (x < -708.39641853226410622) {
			FORCE_EVAL(-0x1p-149 / x);
			if (x < -745.13321910194110842) { return 0; }
		}
	}
	static const double exp_half[2] = { 0.5, -0.5 };
	double hi, lo;
	if (hx > 0x3fd62e42) {
		if (hx >= 0x3ff0a2b2) { k = (int)(1.44269504088896338700 * x + exp_half[sign]); }
		else { k = 1 - sign - sign; }
		hi = x - k * 6.93147180369123816490e-01;
		lo = k * 1.90821492927058770002e-10;
		x = hi - lo;
	} else if (hx > 0x3e300000)  {
		k = 0;
		hi = x;
		lo = 0;
	} else {
		FORCE_EVAL(0x1p1023 + x);
		return 1 + x;
	}
	register double xx = x * x;
	c = x - xx * (1.66666666666666019037e-01 + xx * (-2.77777777770155933842e-03 + xx * (6.61375632143793436117e-05 + xx * (-1.65339022054652515390e-06 + xx * 4.13813679705723846039e-08))));
	y = 1 + (x * c / (2 - c) - lo + hi);
	if (k == 0) { return y; }
	return scalbn(y, k);
}


#if LONG_DOUBLE_IS_X87_EXTENDED
LIB_FUNC long double expl(const long double num) {
	long double x = num;
	if (isnan(x)) { return x; }
	else if (x > 11356.5234062941439488L) { return x * 0x1p16383L; }
	else if (x < -11399.4985314888605581L) { return -0x1p-16445L / x; }
	long double px = floorl(1.4426950408889634073599E0L * x + 0.5);
	int k = (int)px;
	x -= px * 6.9314575195312500000000E-1L;
	x -= px * 1.4286068203094172321215E-6L;
	long double xx = x * x;
	static const long double expl_P[3] = {
		1.2617719307481059087798E-4L, 3.0299440770744196129956E-2L, 9.9999999999999999991025E-1L
	};
	static const long double expl_Q[4] = {
		3.0019850513866445504159E-6L, 2.5244834034968410419224E-3L,
		2.2726554820815502876593E-1L, 2.0000000000000000000897E0L
	};
	px = x * __polevll(xx, P, 2);
	x = 1.0L + 2.0L * (px / (__polevll(xx, expl_Q, 3) - px));
	return scalbnl(x, k);
}
#else
LIB_FUNC long double expl(const long double num) {
	return (long double)exp((double)num);
}
#endif


LIB_FUNC float exp2f(const float num) {
	float x = num;
	double t, r, z;
	union { float f; uint32_t i; } u = { x };
	union { double f; uint64_t i; } uk;
	uint32_t k, ix = u.i & 0x7fffffff;
	if (ix > 0x42fc0000) {
		if (u.i >= 0x43000000 && u.i < 0x80000000) {
			x *= 0x1p127f;
			return x;
		} else if (u.i >= 0x80000000) {
			if (u.i >= 0xc3160000 || (u.i & 0xffff)) { FORCE_EVAL(((float)-0x1p-149) / x); }
			if (u.i >= 0xc3160000) { return 0; }
		}
	} else if (ix <= 0x33000000) { return 1.0F + x; }
	u.f = x + (0x1.8p23f / 16);
	uint32_t i0 = (uint32_t)u.i;
	i0 += 16 / 2;
	k = i0 / 16;
	uk.i = (uint64_t)(0x3ff + k) << 52;
	i0 &= 16 - 1;
	u.f -= (0x1.8p23f / 16);
	z = x - u.f;
	static const double exp2f_exp2ft[16] = {
		0x1.6a09e667f3bcdp-1, 0x1.7a11473eb0187p-1,
		0x1.8ace5422aa0dbp-1, 0x1.9c49182a3f090p-1,
		0x1.ae89f995ad3adp-1, 0x1.c199bdd85529cp-1,
		0x1.d5818dcfba487p-1, 0x1.ea4afa2a490dap-1,
		0x1.0000000000000p0, 0x1.0b5586cf9890fp0,
		0x1.172b83c7d517bp0, 0x1.2387a6e756238p0,
		0x1.306fe0a31b715p0, 0x1.3dea64c123422p0,
		0x1.4bfdad5362a27p0, 0x1.5ab07dd485429p0
	};
	r = exp2f_exp2ft[i0];
	t = r * z;
	r = r + t * ((0x1.62e430p-1) + z * (0x1.ebfbe0p-3)) + t * (z * z) * ((0x1.c6b348p-5) + z * (0x1.3b2c9cp-7));
	return (float)((double)r * uk.f);
}


LIB_FUNC double exp2(const double num) {
	double x = num;
	union { double f; uint64_t i; } u = { x };
	union { uint32_t u; int32_t i; } k;
	uint32_t ix = ((u.i >> 32) & 0x7fffffff);
	if (ix >= 0x408ff000) {
		if (ix >= 0x40900000 && u.i >> 63 == 0) {
			x *= 0x1p1023;
			return x;
		} else if (ix >= 0x7ff00000) { return -1 / x; }
		else if (u.i >> 63) {
			if (x <= -1075 || x - 0x1p52 + 0x1p52 != x) { FORCE_EVAL(((-0x1p-149) / x)); }
			if (x <= -1075) { return 0; }
		}
	} else if (ix < 0x3c900000) { return 1.0 + x; }
	u.f = x + (0x1.8p52 / 256);
	uint32_t i0 = (uint32_t)u.i;
	i0 += 256 / 2;
	k.u = i0 / 256 * 256;
	k.i /= 256;
	i0 %= 256;
	u.f -= (0x1.8p52 / 256);
	double z = x - u.f;
	static const double exp2_tbl[512] = {
		0x1.6a09e667f3d5dp-1, 0x1.9880p-44, 0x1.6b052fa751744p-1, 0x1.8000p-50,
		0x1.6c012750bd9fep-1, -0x1.8780p-45, 0x1.6cfdcddd476bfp-1, 0x1.ec00p-46,
		0x1.6dfb23c651a29p-1, -0x1.8000p-50, 0x1.6ef9298593ae3p-1, -0x1.c000p-52,
		0x1.6ff7df9519386p-1, -0x1.fd80p-45, 0x1.70f7466f42da3p-1, -0x1.c880p-45,
		0x1.71f75e8ec5fc3p-1, 0x1.3c00p-46, 0x1.72f8286eacf05p-1, -0x1.8300p-44,
		0x1.73f9a48a58152p-1, -0x1.0c00p-47, 0x1.74fbd35d7ccfcp-1, 0x1.f880p-45,
		0x1.75feb564267f1p-1, 0x1.3e00p-47, 0x1.77024b1ab6d48p-1, -0x1.7d00p-45,
		0x1.780694fde5d38p-1, -0x1.d000p-50, 0x1.790b938ac1d00p-1, 0x1.3000p-49,
		0x1.7a11473eb0178p-1, -0x1.d000p-49, 0x1.7b17b0976d060p-1, 0x1.0400p-45,
		0x1.7c1ed0130c133p-1, 0x1.0000p-53, 0x1.7d26a62ff8636p-1, -0x1.6900p-45,
		0x1.7e2f336cf4e3bp-1, -0x1.2e00p-47, 0x1.7f3878491c3e8p-1, -0x1.4580p-45,
		0x1.80427543e1b4ep-1, 0x1.3000p-44, 0x1.814d2add1071ap-1, 0x1.f000p-47,
		0x1.82589994ccd7ep-1, -0x1.1c00p-45, 0x1.8364c1eb942d0p-1, 0x1.9d00p-45,
		0x1.8471a4623cab5p-1, 0x1.7100p-43, 0x1.857f4179f5bbcp-1, 0x1.2600p-45,
		0x1.868d99b4491afp-1, -0x1.2c40p-44, 0x1.879cad931a395p-1, -0x1.3000p-45,
		0x1.88ac7d98a65b8p-1, -0x1.a800p-45, 0x1.89bd0a4785800p-1, -0x1.d000p-49,
		0x1.8ace5422aa223p-1, 0x1.3280p-44, 0x1.8be05bad619fap-1, 0x1.2b40p-43,
		0x1.8cf3216b54383p-1, -0x1.ed00p-45, 0x1.8e06a5e08664cp-1, -0x1.0500p-45,
		0x1.8f1ae99157807p-1, 0x1.8280p-45, 0x1.902fed0282c0ep-1, -0x1.cb00p-46,
		0x1.9145b0b91ff96p-1, -0x1.5e00p-47, 0x1.925c353aa2ff9p-1, 0x1.5400p-48,
		0x1.93737b0cdc64ap-1, 0x1.7200p-46, 0x1.948b82b5f98aep-1, -0x1.9000p-47,
		0x1.95a44cbc852cbp-1, 0x1.5680p-45, 0x1.96bdd9a766f21p-1, -0x1.6d00p-44,
		0x1.97d829fde4e2ap-1, -0x1.1000p-47, 0x1.98f33e47a23a3p-1, 0x1.d000p-45,
		0x1.9a0f170ca0604p-1, -0x1.8a40p-44, 0x1.9b2bb4d53ff89p-1, 0x1.55c0p-44,
		0x1.9c49182a3f15bp-1, 0x1.6b80p-45, 0x1.9d674194bb8c5p-1, -0x1.c000p-49,
		0x1.9e86319e3238ep-1, 0x1.7d00p-46, 0x1.9fa5e8d07f302p-1, 0x1.6400p-46,
		0x1.a0c667b5de54dp-1, -0x1.5000p-48, 0x1.a1e7aed8eb8f6p-1, 0x1.9e00p-47,
		0x1.a309bec4a2e27p-1, 0x1.ad80p-45, 0x1.a42c980460a5dp-1, -0x1.af00p-46,
		0x1.a5503b23e259bp-1, 0x1.b600p-47, 0x1.a674a8af46213p-1, 0x1.8880p-44,
		0x1.a799e1330b3a7p-1, 0x1.1200p-46, 0x1.a8bfe53c12e8dp-1, 0x1.6c00p-47,
		0x1.a9e6b5579fcd2p-1, -0x1.9b80p-45, 0x1.ab0e521356fb8p-1, 0x1.b700p-45,
		0x1.ac36bbfd3f381p-1, 0x1.9000p-50, 0x1.ad5ff3a3c2780p-1, 0x1.4000p-49,
		0x1.ae89f995ad2a3p-1, -0x1.c900p-45, 0x1.afb4ce622f367p-1, 0x1.6500p-46,
		0x1.b0e07298db790p-1, 0x1.fd40p-45, 0x1.b20ce6c9a89a9p-1, 0x1.2700p-46,
		0x1.b33a2b84f1a4bp-1, 0x1.d470p-43, 0x1.b468415b747e7p-1, -0x1.8380p-44,
		0x1.b59728de5593ap-1, 0x1.8000p-54, 0x1.b6c6e29f1c56ap-1, 0x1.ad00p-47,
		0x1.b7f76f2fb5e50p-1, 0x1.e800p-50, 0x1.b928cf22749b2p-1, -0x1.4c00p-47,
		0x1.ba5b030a10603p-1, -0x1.d700p-47, 0x1.bb8e0b79a6f66p-1, 0x1.d900p-47,
		0x1.bcc1e904bc1ffp-1, 0x1.2a00p-47, 0x1.bdf69c3f3a16fp-1, -0x1.f780p-46,
		0x1.bf2c25bd71db8p-1, -0x1.0a00p-46, 0x1.c06286141b2e9p-1, -0x1.1400p-46,
		0x1.c199bdd8552e0p-1, 0x1.be00p-47, 0x1.c2d1cd9fa64eep-1, -0x1.9400p-47,
		0x1.c40ab5fffd02fp-1, -0x1.ed00p-47, 0x1.c544778fafd15p-1, 0x1.9660p-44,
		0x1.c67f12e57d0cbp-1, -0x1.a100p-46, 0x1.c7ba88988c1b6p-1, -0x1.8458p-42,
		0x1.c8f6d9406e733p-1, -0x1.a480p-46, 0x1.ca3405751c4dfp-1, 0x1.b000p-51,
		0x1.cb720dcef9094p-1, 0x1.1400p-47, 0x1.ccb0f2e6d1689p-1, 0x1.0200p-48,
		0x1.cdf0b555dc412p-1, 0x1.3600p-48, 0x1.cf3155b5bab3bp-1, -0x1.6900p-47,
		0x1.d072d4a0789bcp-1, 0x1.9a00p-47, 0x1.d1b532b08c8fap-1, -0x1.5e00p-46,
		0x1.d2f87080d8a85p-1, 0x1.d280p-46, 0x1.d43c8eacaa203p-1, 0x1.1a00p-47,
		0x1.d5818dcfba491p-1, 0x1.f000p-50, 0x1.d6c76e862e6a1p-1, -0x1.3a00p-47,
		0x1.d80e316c9834ep-1, -0x1.cd80p-47, 0x1.d955d71ff6090p-1, 0x1.4c00p-48,
		0x1.da9e603db32aep-1, 0x1.f900p-48, 0x1.dbe7cd63a8325p-1, 0x1.9800p-49,
		0x1.dd321f301b445p-1, -0x1.5200p-48, 0x1.de7d5641c05bfp-1, -0x1.d700p-46,
		0x1.dfc97337b9aecp-1, -0x1.6140p-46, 0x1.e11676b197d5ep-1, 0x1.b480p-47,
		0x1.e264614f5a3e7p-1, 0x1.0ce0p-43, 0x1.e3b333b16ee5cp-1, 0x1.c680p-47,
		0x1.e502ee78b3fb4p-1, -0x1.9300p-47, 0x1.e653924676d68p-1, -0x1.5000p-49,
		0x1.e7a51fbc74c44p-1, -0x1.7f80p-47, 0x1.e8f7977cdb726p-1, -0x1.3700p-48,
		0x1.ea4afa2a490e8p-1, 0x1.5d00p-49, 0x1.eb9f4867ccae4p-1, 0x1.61a0p-46,
		0x1.ecf482d8e680dp-1, 0x1.5500p-48, 0x1.ee4aaa2188514p-1, 0x1.6400p-51,
		0x1.efa1bee615a13p-1, -0x1.e800p-49, 0x1.f0f9c1cb64106p-1, -0x1.a880p-48,
		0x1.f252b376bb963p-1, -0x1.c900p-45, 0x1.f3ac948dd7275p-1, 0x1.a000p-53,
		0x1.f50765b6e4524p-1, -0x1.4f00p-48, 0x1.f6632798844fdp-1, 0x1.a800p-51,
		0x1.f7bfdad9cbe38p-1, 0x1.abc0p-48, 0x1.f91d802243c82p-1, -0x1.4600p-50,
		0x1.fa7c1819e908ep-1, -0x1.b0c0p-47, 0x1.fbdba3692d511p-1, -0x1.0e00p-51,
		0x1.fd3c22b8f7194p-1, -0x1.0de8p-46, 0x1.fe9d96b2a23eep-1, 0x1.e430p-49,
		0x1.0000000000000p0, 0x0.0000p0, 0x1.00b1afa5abcbep0, -0x1.3400p-52,
		0x1.0163da9fb3303p0, -0x1.2170p-46, 0x1.02168143b0282p0, 0x1.a400p-52,
		0x1.02c9a3e77806cp0, 0x1.f980p-49, 0x1.037d42e11bbcap0, -0x1.7400p-51,
		0x1.04315e86e7f89p0, 0x1.8300p-50, 0x1.04e5f72f65467p0, -0x1.a3f0p-46,
		0x1.059b0d315855ap0, -0x1.2840p-47, 0x1.0650a0e3c1f95p0, 0x1.1600p-48,
		0x1.0706b29ddf71ap0, 0x1.5240p-46, 0x1.07bd42b72a82dp0, -0x1.9a00p-49,
		0x1.0874518759bd0p0, 0x1.6400p-49, 0x1.092bdf66607c8p0, -0x1.0780p-47,
		0x1.09e3ecac6f383p0, -0x1.8000p-54, 0x1.0a9c79b1f3930p0, 0x1.fa00p-48,
		0x1.0b5586cf988fcp0, -0x1.ac80p-48, 0x1.0c0f145e46c8ap0, 0x1.9c00p-50,
		0x1.0cc922b724816p0, 0x1.5200p-47, 0x1.0d83b23395dd8p0, -0x1.ad00p-48,
		0x1.0e3ec32d3d1f3p0, 0x1.bac0p-46, 0x1.0efa55fdfa9a6p0, -0x1.4e80p-47,
		0x1.0fb66affed2f0p0, -0x1.d300p-47, 0x1.1073028d7234bp0, 0x1.1500p-48,
		0x1.11301d0125b5bp0, 0x1.c000p-49, 0x1.11edbab5e2af9p0, 0x1.6bc0p-46,
		0x1.12abdc06c31d5p0, 0x1.8400p-49, 0x1.136a814f2047dp0, -0x1.ed00p-47,
		0x1.1429aaea92de9p0, 0x1.8e00p-49, 0x1.14e95934f3138p0, 0x1.b400p-49,
		0x1.15a98c8a58e71p0, 0x1.5300p-47, 0x1.166a45471c3dfp0, 0x1.3380p-47,
		0x1.172b83c7d5211p0, 0x1.8d40p-45, 0x1.17ed48695bb9fp0, -0x1.5d00p-47,
		0x1.18af9388c8d93p0, -0x1.c880p-46, 0x1.1972658375d66p0, 0x1.1f00p-46,
		0x1.1a35beb6fcba7p0, 0x1.0480p-46, 0x1.1af99f81387e3p0, -0x1.7390p-43,
		0x1.1bbe084045d54p0, 0x1.4e40p-45, 0x1.1c82f95281c43p0, -0x1.a200p-47,
		0x1.1d4873168b9b2p0, 0x1.3800p-49, 0x1.1e0e75eb44031p0, 0x1.ac00p-49,
		0x1.1ed5022fcd938p0, 0x1.1900p-47, 0x1.1f9c18438cdf7p0, -0x1.b780p-46,
		0x1.2063b88628d8fp0, 0x1.d940p-45, 0x1.212be3578a81ep0, 0x1.8000p-50,
		0x1.21f49917ddd41p0, 0x1.b340p-45, 0x1.22bdda2791323p0, 0x1.9f80p-46,
		0x1.2387a6e7561e7p0, -0x1.9c80p-46, 0x1.2451ffb821427p0, 0x1.2300p-47,
		0x1.251ce4fb2a602p0, -0x1.3480p-46, 0x1.25e85711eceb0p0, 0x1.2700p-46,
		0x1.26b4565e27d16p0, 0x1.1d00p-46, 0x1.2780e341de00fp0, 0x1.1ee0p-44,
		0x1.284dfe1f5633ep0, -0x1.4c00p-46, 0x1.291ba7591bb30p0, -0x1.3d80p-46,
		0x1.29e9df51fdf09p0, 0x1.8b00p-47, 0x1.2ab8a66d10e9bp0, -0x1.27c0p-45,
		0x1.2b87fd0dada3ap0, 0x1.a340p-45, 0x1.2c57e39771af9p0, -0x1.0800p-46,
		0x1.2d285a6e402d9p0, -0x1.ed00p-47, 0x1.2df961f641579p0, -0x1.4200p-48,
		0x1.2ecafa93e2ecfp0, -0x1.4980p-45, 0x1.2f9d24abd8822p0, -0x1.6300p-46,
		0x1.306fe0a31b625p0, -0x1.2360p-44, 0x1.31432edeea50bp0, -0x1.0df8p-40,
		0x1.32170fc4cd7b8p0, -0x1.2480p-45, 0x1.32eb83ba8e9a2p0, -0x1.5980p-45,
		0x1.33c08b2641766p0, 0x1.ed00p-46, 0x1.3496266e3fa27p0, -0x1.c000p-50,
		0x1.356c55f929f0fp0, -0x1.0d80p-44, 0x1.36431a2de88b9p0, 0x1.2c80p-45,
		0x1.371a7373aaa39p0, 0x1.0600p-45, 0x1.37f26231e74fep0, -0x1.6600p-46,
		0x1.38cae6d05d838p0, -0x1.ae00p-47, 0x1.39a401b713ec3p0, -0x1.4720p-43,
		0x1.3a7db34e5a020p0, 0x1.8200p-47, 0x1.3b57fbfec6e95p0, 0x1.e800p-44,
		0x1.3c32dc313a8f2p0, 0x1.f800p-49, 0x1.3d0e544ede122p0, -0x1.7a00p-46,
		0x1.3dea64c1234bbp0, 0x1.6300p-45, 0x1.3ec70df1c4eccp0, -0x1.8a60p-43,
		0x1.3fa4504ac7e8cp0, -0x1.cdc0p-44, 0x1.40822c367a0bbp0, 0x1.5b80p-45,
		0x1.4160a21f72e95p0, 0x1.ec00p-46, 0x1.423fb27094646p0, -0x1.3600p-46,
		0x1.431f5d950a920p0, 0x1.3980p-45, 0x1.43ffa3f84b9ebp0, 0x1.a000p-48,
		0x1.44e0860618919p0, -0x1.6c00p-48, 0x1.45c2042a7d201p0, -0x1.bc00p-47,
		0x1.46a41ed1d0016p0, -0x1.2800p-46, 0x1.4786d668b3326p0, 0x1.0e00p-44,
		0x1.486a2b5c13c00p0, -0x1.d400p-45, 0x1.494e1e192af04p0, 0x1.c200p-47,
		0x1.4a32af0d7d372p0, -0x1.e500p-46, 0x1.4b17dea6db801p0, 0x1.7800p-47,
		0x1.4bfdad53629e1p0, -0x1.3800p-46, 0x1.4ce41b817c132p0, 0x1.0800p-47,
		0x1.4dcb299fddddbp0, 0x1.c700p-45, 0x1.4eb2d81d8ab96p0, -0x1.ce00p-46,
		0x1.4f9b2769d2d02p0, 0x1.9200p-46, 0x1.508417f4531c1p0, -0x1.8c00p-47,
		0x1.516daa2cf662ap0, -0x1.a000p-48, 0x1.5257de83f51eap0, 0x1.a080p-43,
		0x1.5342b569d4edap0, -0x1.6d80p-45, 0x1.542e2f4f6ac1ap0, -0x1.2440p-44,
		0x1.551a4ca5d94dbp0, 0x1.83c0p-43, 0x1.56070dde9116bp0, 0x1.4b00p-45,
		0x1.56f4736b529dep0, 0x1.15a0p-43, 0x1.57e27dbe2c40ep0, -0x1.9e00p-45,
		0x1.58d12d497c76fp0, -0x1.3080p-45, 0x1.59c0827ff0b4cp0, 0x1.dec0p-43,
		0x1.5ab07dd485427p0, -0x1.4000p-51, 0x1.5ba11fba87af4p0, 0x1.0080p-44,
		0x1.5c9268a59460bp0, -0x1.6c80p-45, 0x1.5d84590998e3fp0, 0x1.69a0p-43,
		0x1.5e76f15ad20e1p0, -0x1.b400p-46, 0x1.5f6a320dcebcap0, 0x1.7700p-46,
		0x1.605e1b976dcb8p0, 0x1.6f80p-45, 0x1.6152ae6cdf715p0, 0x1.1000p-47,
		0x1.6247eb03a5531p0, -0x1.5d00p-46, 0x1.633dd1d1929b5p0, -0x1.2d00p-46,
		0x1.6434634ccc313p0, -0x1.a800p-49, 0x1.652b9febc8efap0, -0x1.8600p-45,
		0x1.6623882553397p0, 0x1.1fe0p-40, 0x1.671c1c708328ep0, -0x1.7200p-44,
		0x1.68155d44ca97ep0, 0x1.6800p-49, 0x1.690f4b19e9471p0, -0x1.9780p-45
	};
	double t = exp2_tbl[2 * i0];
	z -= exp2_tbl[2 * i0 + 1];
	double r = t + t * z * ((0x1.62e42fefa39efp-1) + z * ((0x1.ebfbdff82c575p-3) + z * ((0x1.c6b08d704a0a6p-5) + z * ((0x1.3b2ab88f70400p-7) + z * (0x1.5d88003875c74p-10)))));
	return scalbn(r, k.i);
}


#if LONG_DOUBLE_IS_X87_EXTENDED
LIB_FUNC long double exp2l(const long double num) {
	long double x = num;
	union ldshape u = {x};
	int e = u.i.se & 0x7fff;
	union {uint32_t u; int32_t i;} k;
	if (e >= 0x3fff + 13) {
		if (u.i.se >= 0x3fff + 14 && u.i.se >> 15 == 0) { return x * 0x1p16383L; }
		else if (e == 0x7fff) { return -1 / x; }
		else if (x < -16382) {
			if (x <= -16446 || x - 0x1p63 + 0x1p63 != x) { FORCE_EVAL(((long double)(-0x1p-149) / x)); }
			if (x <= -16446) { return 0; }
		}
	} else if (e < 0x3fbf) { return 1 + x; }
	u.f = x + (0x1.8p63 / 0x80);
	uint32_t i0 = u.i.m + 0x40;
	k.u = i0 / 0x80 * 0x80;
	k.i /= 0x80;
	i0 %= 0x80;
	u.f -= (0x1.8p63 / 0x80);
	static const double exp2l_tbl[0x100] = {
		0x1.6a09e667f3bcdp-1, -0x1.bdd3413b2648p-55,
		0x1.6c012750bdabfp-1, -0x1.2895667ff0cp-57,
		0x1.6dfb23c651a2fp-1, -0x1.bbe3a683c88p-58,
		0x1.6ff7df9519484p-1, -0x1.83c0f25860fp-56,
		0x1.71f75e8ec5f74p-1, -0x1.16e4786887bp-56,
		0x1.73f9a48a58174p-1, -0x1.0a8d96c65d5p-55,
		0x1.75feb564267c9p-1, -0x1.0245957316ep-55,
		0x1.780694fde5d3fp-1, 0x1.866b80a0216p-55,
		0x1.7a11473eb0187p-1, -0x1.41577ee0499p-56,
		0x1.7c1ed0130c132p-1, 0x1.f124cd1164ep-55,
		0x1.7e2f336cf4e62p-1, 0x1.05d02ba157ap-57,
		0x1.80427543e1a12p-1, -0x1.27c86626d97p-55,
		0x1.82589994cce13p-1, -0x1.d4c1dd41533p-55,
		0x1.8471a4623c7adp-1, -0x1.8d684a341cep-56,
		0x1.868d99b4492edp-1, -0x1.fc6f89bd4f68p-55,
		0x1.88ac7d98a6699p-1, 0x1.994c2f37cb5p-55,
		0x1.8ace5422aa0dbp-1, 0x1.6e9f156864bp-55,
		0x1.8cf3216b5448cp-1, -0x1.0d55e32e9e4p-57,
		0x1.8f1ae99157736p-1, 0x1.5cc13a2e397p-56,
		0x1.9145b0b91ffc6p-1, -0x1.dd6792e5825p-55,
		0x1.93737b0cdc5e5p-1, -0x1.75fc781b58p-58,
		0x1.95a44cbc8520fp-1, -0x1.64b7c96a5fp-57,
		0x1.97d829fde4e5p-1, -0x1.d185b7c1b86p-55,
		0x1.9a0f170ca07bap-1, -0x1.173bd91cee6p-55,
		0x1.9c49182a3f09p-1, 0x1.c7c46b071f2p-57,
		0x1.9e86319e32323p-1, 0x1.824ca78e64cp-57,
		0x1.a0c667b5de565p-1, -0x1.359495d1cd5p-55,
		0x1.a309bec4a2d33p-1, 0x1.6305c7ddc368p-55,
		0x1.a5503b23e255dp-1, -0x1.d2f6edb8d42p-55,
		0x1.a799e1330b358p-1, 0x1.bcb7ecac564p-55,
		0x1.a9e6b5579fdbfp-1, 0x1.0fac90ef7fdp-55,
		0x1.ac36bbfd3f37ap-1, -0x1.f9234cae76dp-56,
		0x1.ae89f995ad3adp-1, 0x1.7a1cd345dcc8p-55,
		0x1.b0e07298db666p-1, -0x1.bdef54c80e4p-55,
		0x1.b33a2b84f15fbp-1, -0x1.2805e3084d8p-58,
		0x1.b59728de5593ap-1, -0x1.c71dfbbba6ep-55,
		0x1.b7f76f2fb5e47p-1, -0x1.5584f7e54acp-57,
		0x1.ba5b030a1064ap-1, -0x1.efcd30e5429p-55,
		0x1.bcc1e904bc1d2p-1, 0x1.23dd07a2d9fp-56,
		0x1.bf2c25bd71e09p-1, -0x1.efdca3f6b9c8p-55,
		0x1.c199bdd85529cp-1, 0x1.11065895049p-56,
		0x1.c40ab5fffd07ap-1, 0x1.b4537e083c6p-55,
		0x1.c67f12e57d14bp-1, 0x1.2884dff483c8p-55,
		0x1.c8f6d9406e7b5p-1, 0x1.1acbc48805cp-57,
		0x1.cb720dcef9069p-1, 0x1.503cbd1e94ap-57,
		0x1.cdf0b555dc3fap-1, -0x1.dd83b53829dp-56,
		0x1.d072d4a07897cp-1, -0x1.cbc3743797a8p-55,
		0x1.d2f87080d89f2p-1, -0x1.d487b719d858p-55,
		0x1.d5818dcfba487p-1, 0x1.2ed02d75b37p-56,
		0x1.d80e316c98398p-1, -0x1.11ec18bedep-55,
		0x1.da9e603db3285p-1, 0x1.c2300696db5p-55,
		0x1.dd321f301b46p-1, 0x1.2da5778f019p-55,
		0x1.dfc97337b9b5fp-1, -0x1.1a5cd4f184b8p-55,
		0x1.e264614f5a129p-1, -0x1.7b627817a148p-55,
		0x1.e502ee78b3ff6p-1, 0x1.39e8980a9cdp-56,
		0x1.e7a51fbc74c83p-1, 0x1.2d522ca0c8ep-55,
		0x1.ea4afa2a490dap-1, -0x1.e9c23179c288p-55,
		0x1.ecf482d8e67f1p-1, -0x1.c93f3b411ad8p-55,
		0x1.efa1bee615a27p-1, 0x1.dc7f486a4b68p-55,
		0x1.f252b376bba97p-1, 0x1.3a1a5bf0d8e8p-55,
		0x1.f50765b6e454p-1, 0x1.9d3e12dd8a18p-55,
		0x1.f7bfdad9cbe14p-1, -0x1.dbb12d00635p-55,
		0x1.fa7c1819e90d8p-1, 0x1.74853f3a593p-56,
		0x1.fd3c22b8f71f1p-1, 0x1.2eb74966578p-58,
		0x1p0, 0x0p0,
		0x1.0163da9fb3335p0, 0x1.b61299ab8cd8p-54,
		0x1.02c9a3e778061p0, -0x1.19083535b08p-56,
		0x1.04315e86e7f85p0, -0x1.0a31c1977c98p-54,
		0x1.059b0d3158574p0, 0x1.d73e2a475b4p-55,
		0x1.0706b29ddf6dep0, -0x1.c91dfe2b13cp-55,
		0x1.0874518759bc8p0, 0x1.186be4bb284p-57,
		0x1.09e3ecac6f383p0, 0x1.14878183161p-54,
		0x1.0b5586cf9890fp0, 0x1.8a62e4adc61p-54,
		0x1.0cc922b7247f7p0, 0x1.01edc16e24f8p-54,
		0x1.0e3ec32d3d1a2p0, 0x1.03a1727c58p-59,
		0x1.0fb66affed31bp0, -0x1.b9bedc44ebcp-57,
		0x1.11301d0125b51p0, -0x1.6c51039449bp-54,
		0x1.12abdc06c31ccp0, -0x1.1b514b36ca8p-58,
		0x1.1429aaea92dep0, -0x1.32fbf9af1368p-54,
		0x1.15a98c8a58e51p0, 0x1.2406ab9eeabp-55,
		0x1.172b83c7d517bp0, -0x1.19041b9d78ap-55,
		0x1.18af9388c8deap0, -0x1.11023d1970f8p-54,
		0x1.1a35beb6fcb75p0, 0x1.e5b4c7b4969p-55,
		0x1.1bbe084045cd4p0, -0x1.95386352ef6p-54,
		0x1.1d4873168b9aap0, 0x1.e016e00a264p-54,
		0x1.1ed5022fcd91dp0, -0x1.1df98027bb78p-54,
		0x1.2063b88628cd6p0, 0x1.dc775814a85p-55,
		0x1.21f49917ddc96p0, 0x1.2a97e9494a6p-55,
		0x1.2387a6e756238p0, 0x1.9b07eb6c7058p-54,
		0x1.251ce4fb2a63fp0, 0x1.ac155bef4f5p-55,
		0x1.26b4565e27cddp0, 0x1.2bd339940eap-55,
		0x1.284dfe1f56381p0, -0x1.a4c3a8c3f0d8p-54,
		0x1.29e9df51fdee1p0, 0x1.612e8afad12p-55,
		0x1.2b87fd0dad99p0, -0x1.10adcd6382p-59,
		0x1.2d285a6e4030bp0, 0x1.0024754db42p-54,
		0x1.2ecafa93e2f56p0, 0x1.1ca0f45d524p-56,
		0x1.306fe0a31b715p0, 0x1.6f46ad23183p-55,
		0x1.32170fc4cd831p0, 0x1.a9ce78e1804p-55,
		0x1.33c08b26416ffp0, 0x1.327218436598p-54,
		0x1.356c55f929ff1p0, -0x1.b5cee5c4e46p-55,
		0x1.371a7373aa9cbp0, -0x1.63aeabf42ebp-54,
		0x1.38cae6d05d866p0, -0x1.e958d3c99048p-54,
		0x1.3a7db34e59ff7p0, -0x1.5e436d661f6p-56,
		0x1.3c32dc313a8e5p0, -0x1.efff8375d2ap-54,
		0x1.3dea64c123422p0, 0x1.ada0911f09fp-55,
		0x1.3fa4504ac801cp0, -0x1.7d023f956fap-54,
		0x1.4160a21f72e2ap0, -0x1.ef3691c309p-58,
		0x1.431f5d950a897p0, -0x1.1c7dde35f7ap-55,
		0x1.44e086061892dp0, 0x1.89b7a04ef8p-59,
		0x1.46a41ed1d0057p0, 0x1.c944bd1648a8p-54,
		0x1.486a2b5c13cdp0, 0x1.3c1a3b69062p-56,
		0x1.4a32af0d7d3dep0, 0x1.9cb62f3d1be8p-54,
		0x1.4bfdad5362a27p0, 0x1.d4397afec42p-56,
		0x1.4dcb299fddd0dp0, 0x1.8ecdbbc6a78p-54,
		0x1.4f9b2769d2ca7p0, -0x1.4b309d25958p-54,
		0x1.516daa2cf6642p0, -0x1.f768569bd94p-55,
		0x1.5342b569d4f82p0, -0x1.07abe1db13dp-55,
		0x1.551a4ca5d920fp0, -0x1.d689cefede6p-55,
		0x1.56f4736b527dap0, 0x1.9bb2c011d938p-54,
		0x1.58d12d497c7fdp0, 0x1.295e15b9a1ep-55,
		0x1.5ab07dd485429p0, 0x1.6324c0546478p-54,
		0x1.5c9268a5946b7p0, 0x1.c4b1b81698p-60,
		0x1.5e76f15ad2148p0, 0x1.ba6f93080e68p-54,
		0x1.605e1b976dc09p0, -0x1.3e2429b56de8p-54,
		0x1.6247eb03a5585p0, -0x1.383c17e40b48p-54,
		0x1.6434634ccc32p0, -0x1.c483c759d89p-55,
		0x1.6623882552225p0, -0x1.bb60987591cp-54,
		0x1.68155d44ca973p0, 0x1.038ae44f74p-57,
	};
	const long double z = x - u.f;
	const long double t_hi = exp2l_tbl[2 * i0];
	const long double t_lo = exp2l_tbl[2 * i0 + 1];
	long double r = t_lo + (t_hi + t_lo) * z * ((0x1.62e42fefa39efp-1) + z * ((0x1.ebfbdff82c58fp-3) + z * ((0x1.c6b08d7049fap-5) + z * ((0x1.3b2ab6fba4da5p-7) + z * ((0x1.5d8804780a736p-10) + z * (0x1.430918835e33dp-13)))))) + t_hi;
	return scalbnl(r, k.i);
}
#elif LONG_DOUBLE_IS_BINARY128
LIB_FUNC long double exp2l(const long double num) {
	long double x = num;
	union ldshape u = { x };
	int e = u.i.se & 0x7fff;
	union { uint32_t u; int32_t i; } k;
	if (e >= 0x3fff + 14) {
		if (u.i.se >= (0x3fff + 15) && u.i.se >> 15 == 0) { return x * 0x1p16383L; }
		else if (e == 0x7fff) { return -1 / x; }
		else if (x < -16382) {
			if (x <= -16495 || x - 0x1p112 + 0x1p112 != x) { FORCE_EVAL(((long double)(-0x1p-149) / x)); }
			if (x <= -16446) { return 0; }
		}
	} else if (e < 0x3fff - 114) { return 1 + x; }
	u.f = x + (0x1.8p112 / 0x80);
	uint32_t i0 = (uint32_t)(u.i2.lo + 0x40);
	k.u = i0 / 0x80 * 0x80;
	k.i /= 0x80;
	i0 %= 0x80;
	u.f -= (0x1.8p112 / 0x80);
	long double z = x - u.f;
	static const long double exp2l_tbl[0x80] = {
		0x1.6a09e667f3bcc908b2fb1366dfeap-1L, 0x1.6c012750bdabeed76a99800f4edep-1L,
		0x1.6dfb23c651a2ef220e2cbe1bc0d4p-1L, 0x1.6ff7df9519483cf87e1b4f3e1e98p-1L,
		0x1.71f75e8ec5f73dd2370f2ef0b148p-1L, 0x1.73f9a48a58173bd5c9a4e68ab074p-1L,
		0x1.75feb564267c8bf6e9aa33a489a8p-1L, 0x1.780694fde5d3f619ae02808592a4p-1L,
		0x1.7a11473eb0186d7d51023f6ccb1ap-1L, 0x1.7c1ed0130c1327c49334459378dep-1L,
		0x1.7e2f336cf4e62105d02ba1579756p-1L, 0x1.80427543e1a11b60de67649a3842p-1L,
		0x1.82589994cce128acf88afab34928p-1L, 0x1.8471a4623c7acce52f6b97c6444cp-1L,
		0x1.868d99b4492ec80e41d90ac2556ap-1L, 0x1.88ac7d98a669966530bcdf2d4cc0p-1L,
		0x1.8ace5422aa0db5ba7c55a192c648p-1L, 0x1.8cf3216b5448bef2aa1cd161c57ap-1L,
		0x1.8f1ae991577362b982745c72eddap-1L, 0x1.9145b0b91ffc588a61b469f6b6a0p-1L,
		0x1.93737b0cdc5e4f4501c3f2540ae8p-1L, 0x1.95a44cbc8520ee9b483695a0e7fep-1L,
		0x1.97d829fde4e4f8b9e920f91e8eb6p-1L, 0x1.9a0f170ca07b9ba3109b8c467844p-1L,
		0x1.9c49182a3f0901c7c46b071f28dep-1L, 0x1.9e86319e323231824ca78e64c462p-1L,
		0x1.a0c667b5de564b29ada8b8cabbacp-1L, 0x1.a309bec4a2d3358c171f770db1f4p-1L,
		0x1.a5503b23e255c8b424491caf88ccp-1L, 0x1.a799e1330b3586f2dfb2b158f31ep-1L,
		0x1.a9e6b5579fdbf43eb243bdff53a2p-1L, 0x1.ac36bbfd3f379c0db966a3126988p-1L,
		0x1.ae89f995ad3ad5e8734d17731c80p-1L, 0x1.b0e07298db66590842acdfc6fb4ep-1L,
		0x1.b33a2b84f15faf6bfd0e7bd941b0p-1L, 0x1.b59728de559398e3881111648738p-1L,
		0x1.b7f76f2fb5e46eaa7b081ab53ff6p-1L, 0x1.ba5b030a10649840cb3c6af5b74cp-1L,
		0x1.bcc1e904bc1d2247ba0f45b3d06cp-1L, 0x1.bf2c25bd71e088408d7025190cd0p-1L,
		0x1.c199bdd85529c2220cb12a0916bap-1L, 0x1.c40ab5fffd07a6d14df820f17deap-1L,
		0x1.c67f12e57d14b4a2137fd20f2a26p-1L, 0x1.c8f6d9406e7b511acbc48805c3f6p-1L,
		0x1.cb720dcef90691503cbd1e949d0ap-1L, 0x1.cdf0b555dc3f9c44f8958fac4f12p-1L,
		0x1.d072d4a07897b8d0f22f21a13792p-1L, 0x1.d2f87080d89f18ade123989ea50ep-1L,
		0x1.d5818dcfba48725da05aeb66dff8p-1L, 0x1.d80e316c98397bb84f9d048807a0p-1L,
		0x1.da9e603db3285708c01a5b6d480cp-1L, 0x1.dd321f301b4604b695de3c0630c0p-1L,
		0x1.dfc97337b9b5eb968cac39ed284cp-1L, 0x1.e264614f5a128a12761fa17adc74p-1L,
		0x1.e502ee78b3ff6273d130153992d0p-1L, 0x1.e7a51fbc74c834b548b2832378a4p-1L,
		0x1.ea4afa2a490d9858f73a18f5dab4p-1L, 0x1.ecf482d8e67f08db0312fb949d50p-1L,
		0x1.efa1bee615a27771fd21a92dabb6p-1L, 0x1.f252b376bba974e8696fc3638f24p-1L,
		0x1.f50765b6e4540674f84b762861a6p-1L, 0x1.f7bfdad9cbe138913b4bfe72bd78p-1L,
		0x1.fa7c1819e90d82e90a7e74b26360p-1L, 0x1.fd3c22b8f71f10975ba4b32bd006p-1L,
		0x1.0000000000000000000000000000p0, 0x1.0163da9fb33356d84a66ae336e98p0,
		0x1.02c9a3e778060ee6f7caca4f7a18p0, 0x1.04315e86e7f84bd738f9a20da442p0,
		0x1.059b0d31585743ae7c548eb68c6ap0, 0x1.0706b29ddf6ddc6dc403a9d87b1ep0,
		0x1.0874518759bc808c35f25d942856p0, 0x1.09e3ecac6f3834521e060c584d5cp0,
		0x1.0b5586cf9890f6298b92b7184200p0, 0x1.0cc922b7247f7407b705b893dbdep0,
		0x1.0e3ec32d3d1a2020742e4f8af794p0, 0x1.0fb66affed31af232091dd8a169ep0,
		0x1.11301d0125b50a4ebbf1aed9321cp0, 0x1.12abdc06c31cbfb92bad324d6f84p0,
		0x1.1429aaea92ddfb34101943b2588ep0, 0x1.15a98c8a58e512480d573dd562aep0,
		0x1.172b83c7d517adcdf7c8c50eb162p0, 0x1.18af9388c8de9bbbf70b9a3c269cp0,
		0x1.1a35beb6fcb753cb698f692d2038p0, 0x1.1bbe084045cd39ab1e72b442810ep0,
		0x1.1d4873168b9aa7805b8028990be8p0, 0x1.1ed5022fcd91cb8819ff61121fbep0,
		0x1.2063b88628cd63b8eeb0295093f6p0, 0x1.21f49917ddc962552fd29294bc20p0,
		0x1.2387a6e75623866c1fadb1c159c0p0, 0x1.251ce4fb2a63f3582ab7de9e9562p0,
		0x1.26b4565e27cdd257a673281d3068p0, 0x1.284dfe1f5638096cf15cf03c9fa0p0,
		0x1.29e9df51fdee12c25d15f5a25022p0, 0x1.2b87fd0dad98ffddea46538fca24p0,
		0x1.2d285a6e4030b40091d536d0733ep0, 0x1.2ecafa93e2f5611ca0f45d5239a4p0,
		0x1.306fe0a31b7152de8d5a463063bep0, 0x1.32170fc4cd8313539cf1c3009330p0,
		0x1.33c08b26416ff4c9c8610d96680ep0, 0x1.356c55f929ff0c94623476373be4p0,
		0x1.371a7373aa9caa7145502f45452ap0, 0x1.38cae6d05d86585a9cb0d9bed530p0,
		0x1.3a7db34e59ff6ea1bc9299e0a1fep0, 0x1.3c32dc313a8e484001f228b58cf0p0,
		0x1.3dea64c12342235b41223e13d7eep0, 0x1.3fa4504ac801ba0bf701aa417b9cp0,
		0x1.4160a21f72e29f84325b8f3dbacap0, 0x1.431f5d950a896dc704439410b628p0,
		0x1.44e086061892d03136f409df0724p0, 0x1.46a41ed1d005772512f459229f0ap0,
		0x1.486a2b5c13cd013c1a3b69062f26p0, 0x1.4a32af0d7d3de672d8bcf46f99b4p0,
		0x1.4bfdad5362a271d4397afec42e36p0, 0x1.4dcb299fddd0d63b36ef1a9e19dep0,
		0x1.4f9b2769d2ca6ad33d8b69aa0b8cp0, 0x1.516daa2cf6641c112f52c84d6066p0,
		0x1.5342b569d4f81df0a83c49d86bf4p0, 0x1.551a4ca5d920ec52ec620243540cp0,
		0x1.56f4736b527da66ecb004764e61ep0, 0x1.58d12d497c7fd252bc2b7343d554p0,
		0x1.5ab07dd48542958c93015191e9a8p0, 0x1.5c9268a5946b701c4b1b81697ed4p0,
		0x1.5e76f15ad21486e9be4c20399d12p0, 0x1.605e1b976dc08b076f592a487066p0,
		0x1.6247eb03a5584b1f0fa06fd2d9eap0, 0x1.6434634ccc31fc76f8714c4ee122p0,
		0x1.66238825522249127d9e29b92ea2p0, 0x1.68155d44ca973081c57227b9f69ep0
};
	const long double t = exp2l_tbl[i0];
	static const float exp2l_eps[0x80] = {
		-0x1.5c50p-101, -0x1.5d00p-106, 0x1.8e90p-102, -0x1.5340p-103,
		0x1.1bd0p-102, -0x1.4600p-105, -0x1.7a40p-104, 0x1.d590p-102,
		-0x1.d590p-101, 0x1.b100p-103, -0x1.0d80p-105, 0x1.6b00p-103,
		-0x1.9f00p-105, 0x1.c400p-103, 0x1.e120p-103, -0x1.c100p-104,
		-0x1.9d20p-103, 0x1.a800p-108, 0x1.4c00p-106, -0x1.9500p-106,
		0x1.6900p-105, -0x1.29d0p-100, 0x1.4c60p-103, 0x1.13a0p-102,
		-0x1.5b60p-103, -0x1.1c40p-103, 0x1.db80p-102, 0x1.91a0p-102,
		0x1.dc00p-105, 0x1.44c0p-104, 0x1.9710p-102, 0x1.8760p-103,
		-0x1.a720p-103, 0x1.ed20p-103, -0x1.49c0p-102, -0x1.e000p-111,
		0x1.86a0p-103, 0x1.2b40p-103, -0x1.b400p-108, 0x1.1280p-99,
		-0x1.02d8p-102, -0x1.e3d0p-103, -0x1.b080p-105, -0x1.f100p-107,
		-0x1.16c0p-105, -0x1.1190p-103, -0x1.a7d2p-100, 0x1.3450p-103,
		-0x1.67c0p-105, 0x1.4b80p-104, -0x1.c4e0p-103, 0x1.6000p-108,
		-0x1.3f60p-105, 0x1.93f0p-104, 0x1.5fe0p-105, 0x1.6f80p-107,
		-0x1.7600p-106, 0x1.21e0p-106, -0x1.3a40p-106, -0x1.40c0p-104,
		-0x1.9860p-105, -0x1.5d40p-108, -0x1.1d70p-106, 0x1.2760p-105,
		0x0.0000p0, 0x1.21e2p-104, -0x1.9520p-108, -0x1.5720p-106,
		-0x1.4810p-106, -0x1.be00p-109, 0x1.0080p-105, -0x1.5780p-108,
		-0x1.d460p-105, -0x1.6140p-105, 0x1.4630p-104, 0x1.ad50p-103,
		0x1.82e0p-105, 0x1.1d3cp-101, 0x1.6100p-107, 0x1.ec30p-104,
		0x1.f200p-108, 0x1.0b40p-103, 0x1.3660p-102, 0x1.d9d0p-103,
		-0x1.02d0p-102, 0x1.b070p-103, 0x1.b9c0p-104, -0x1.01c0p-103,
		-0x1.dfe0p-103, 0x1.1b60p-104, -0x1.ae94p-101, -0x1.3340p-104,
		0x1.b3d8p-102, -0x1.6e40p-105, -0x1.3670p-103, 0x1.c140p-104,
		0x1.1840p-101, 0x1.1ab0p-102, -0x1.a400p-104, 0x1.1f00p-104,
		-0x1.7180p-103, 0x1.4ce0p-102, 0x1.9200p-107, -0x1.54c0p-103,
		0x1.1b80p-105, -0x1.1828p-101, 0x1.5720p-102, -0x1.a060p-100,
		0x1.9160p-102, 0x1.a280p-104, 0x1.3400p-107, 0x1.2b20p-102,
		0x1.7800p-108, 0x1.cfd0p-101, 0x1.2ef0p-102, -0x1.2760p-99,
		0x1.b380p-104, 0x1.0048p-101, -0x1.60b0p-102, 0x1.a1ccp-100,
		-0x1.a640p-104, -0x1.08a0p-101, 0x1.7e60p-102, 0x1.22c0p-103,
		-0x1.7200p-106, 0x1.f0f0p-102, 0x1.eb4ep-99, 0x1.c6e0p-103
	};
	z -= exp2l_eps[i0];
	long double r = t + t * z * ((0x1.62e42fefa39ef35793c7673007e6p-1L) + z * ((0x1.ebfbdff82c58ea86f16b06ec9736p-3L) + z * ((0x1.c6b08d704a0bf8b33a762bad3459p-5L) + z * ((0x1.3b2ab6fba4e7729ccbbe0b4f3fc2p-7L) + z * ((0x1.5d87fe78a67311071dee13fd11d9p-10L) + z * ((0x1.430912f86c7876f4b663b23c5fe5p-13L) + z * ((double)(0x1.ffcbfc588b041p-17) + z * ((double)(0x1.62c0223a5c7c7p-20) + z * ((double)(0x1.b52541ff59713p-24) + z * (double)(0x1.e4cf56a391e22p-28))))))))));
	return scalbnl(r, k.i);
}
#else
LIB_FUNC long double exp2l(const long double x) {
	return (long double)exp2((double)x);
}
#endif


LIB_FUNC float exp10f(const float x) {
	return powf(10.0F, x);
}
#define pow10f(x)   exp10f((x))


LIB_FUNC double exp10(const double x) {
	return pow(10.0, x);
}
#define pow10(x)   exp10((x))


#if ((LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384)
LIB_FUNC long double exp10l(long double x) {
	static const long double p10[32] = {
		1e-15L, 1e-14L, 1e-13L, 1e-12L, 1e-11L, 1e-10L,
		1e-9L, 1e-8L, 1e-7L, 1e-6L, 1e-5L, 1e-4L, 1e-3L, 1e-2L, 1e-1L,
		1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
		1e10, 1e11, 1e12, 1e13, 1e14, 1e15
	};
	long double n, y = modfl(x, &n);
	union ldshape u = { n };
	if ((u.i.se & 0x7fff) < 0x3fff + 4) {
		if (!y) { return p10[(int)n + 15]; }
		y = exp2l(3.32192809488736234787031942948939L * y);
		return y * p10[(int)n + 15];
	}
	// return powl(10.0L, x);
	return (long double)pow(10.0, (double)x);
}
#else
LIB_FUNC long double exp10l(long double x) {
	return (long double)exp10((double)x);
}
#endif
#define pow10l(x)   exp10l((x))


LIB_FUNC float __expo2f(const float x) {
	float scale;
	SET_FLOAT_WORD(scale, (uint32_t)(0x7f + 235 / 2) << 23);
	return expf(x - 0x1.45c778p+7f) * scale * scale;
}


LIB_FUNC double __expo2(const double x) {
	double scale;
	INSERT_WORDS(scale, (uint32_t)(0x3ff + 2043 / 2) << 20, 0);
	return exp(x - 0x1.62066151add8bp+10) * scale * scale;
}


LIB_FUNC float expm1f(const float num) {
	float y, hi, lo, c, t, e, x = num;
	uint32_t hx;
	register int32_t k;
	GET_FLOAT_UWORD(hx, x);
	const int32_t xsb = (int32_t)((int32_t)hx & (int32_t)0x80000000);
	if (xsb == 0) { y = x; }
	else { y = -x; }
	hx &= 0x7fffffff;
	if (hx >= 0x4195b844) {
		if (FLT_UWORD_IS_NAN(hx)) { return x + x; }
		else if (FLT_UWORD_IS_INFINITE(hx)) { return (xsb == 0) ? x : -1.0F; }
		else if (xsb == 0 && hx > FLT_UWORD_LOG_MAX) { return (float)1.0e+30 * (float)1.0e+30; }
		else if ((xsb != 0) && (x + (float)1.0e-30 < (float)0.0F)) { return (float)1.0e-30 - (float)1.0F; }
	} else if (hx > 0x3eb17218) {
		if (hx < 0x3F851592) {
			if (xsb == 0) {
				hi = x - (float)6.9313812256e-01;
				lo = (float)9.0580006145e-06;
				k = 1;
			} else {
				hi = x + (float)6.9313812256e-01;
				lo = -(float)9.0580006145e-06;
				k = -1;
			}
		} else {
			k = (int32_t)((float)1.4426950216e+00 * x + ((xsb == 0) ? (float)0.5F : (float) - 0.5F));
			t = (float)k;
			hi = x - t * (float)6.9313812256e-01;
			lo = t * (float)9.0580006145e-06;
		}
		x = hi - lo;
		c = (hi - x) - lo;
	} else if (hx < 0x33000000) {
		t = (float)1.0e+30 + x;
		return x - (t - ((float)1.0e+30 + x));
	} else { k = 0; }
	const float hfx = (float)0.5F * x;
	const float hxs = x * hfx;
	const float r1 = (float)1.0F + hxs * ((float)-3.3333335072e-02 + hxs * ((float)1.5873016091e-03 + hxs * ((float)-7.9365076090e-05 + hxs * ((float)4.0082177293e-06 + hxs * (float)-2.0109921195e-07))));
	t = (float)3.0F - r1 * hfx;
	e = hxs * ((r1 - t) / ((float)6.0F - x * t));
	if (k == 0) { return x - (x * e - hxs); }
	else {
		e = (x * (e - c) - c);
		e -= hxs;
		if (k == -1) { return (float)0.5F * (x - e) - (float)0.5F; }
		else if (k == 1) {
			if (x < (float)-0.25F) { return -(float)2.0F * (e - (x + (float)0.5F)); }
			else { return (float)1.0F + (float)2.0F * (x - e); }
		} else if (k <= -2 || k > 56) {
			int32_t i;
			y = (float)1.0F - (e - x);
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, i + (k << 23));
			return y - (float)1.0F;
		}
		t = (float)1.0F;
		if (k < 23) {
			int32_t i;
			SET_FLOAT_WORD(t, 0x3f800000 - (0x1000000 >> k));
			y = t - (e - x);
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, i + (k << 23));
		} else {
			int32_t i;
			SET_FLOAT_WORD(t, ((0x7f - k) << 23));
			y = x - (e + t);
			y += (float)1.0F;
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, (i + (k << 23)));
		}
	}
	return y;
}
#define __expm1f(x)   expm1f((x))


LIB_FUNC double expm1(const double num) {
	double y, hi, lo, c, t, e, x = num;
	int32_t k;
	uint32_t hx;
	GET_HIGH_WORD(hx, x);
	const int32_t xsb = (int32_t)(hx & 0x80000000);
	if (xsb == 0) { y = x; }
	else { y = -x; }
	hx &= 0x7fffffff;
	if (hx >= 0x4043687A) {
		if (hx >= 0x40862E42) {
			if (hx >= 0x7ff00000) {
				uint32_t low;
				GET_LOW_WORD(low, x);
				if (((hx & 0xfffff) | low) != 0) { return x + x; }
				else { return (xsb == 0) ? x : -1.0; }
			} else if (x > (double)7.09782712893383973096e+02) { return (double)1.0e+300 * (double)1.0e+300; }
		}
		if ((xsb != 0) && (x + (double)1.0e-300 < 0.0)) { return (double)1.0e-300 - (double)1.0; }
	}
	if (hx > 0x3fd62e42) {
		if (hx < 0x3FF0A2B2) {
			if (xsb == 0) {
				hi = x - (double)6.93147180369123816490e-01;
				lo = (double)1.90821492927058770002e-10;
				k = 1;
			} else {
				hi = x + (double)6.93147180369123816490e-01;
				lo = -(double)1.90821492927058770002e-10;
				k = -1;
			}
		} else {
			k = (int32_t)((double)1.44269504088896338700e+00 * x + (double)((xsb == 0) ? 0.5 : -0.5));
			t = (double)k;
			hi = x - t * (double)6.93147180369123816490e-01;
			lo = t * (double)1.90821492927058770002e-10;
		}
		x = hi - lo;
		c = (hi - x) - lo;
	} else if (hx < 0x3c900000) {
		t = (double)1.0e+300 + x;
		return x - (t - ((double)1.0e+300 + x));
	} else { k = 0; }
	const double hfx = 0.5 * x;
	const double hxs = x * hfx;
	const double r1 = (double)1.0 + hxs * ((double)-3.33333333333331316428e-02 + hxs * ((double)1.58730158725481460165e-03 + hxs * ((double)-7.93650757867487942473e-05 + hxs * ((double)4.00821782732936239552e-06 + hxs * (double)-2.01099218183624371326e-07))));
	t = 3.0 - r1 * hfx;
	e = hxs * ((r1 - t) / (6.0 - x * t));
	if (k == 0) { return x - (x * e - hxs); }
	else {
		e = (x * (e - c) - c);
		e -= hxs;
		if (k == -1) { return 0.5 * (x - e) - 0.5; }
		else if (k == 1) {
			if (x < -0.25) { return -2.0 * (e - (x + 0.5)); }
			else { return (double)1.0 + 2.0 * (x - e); }
		} else if (k <= -2 || k > 56) {
			uint32_t high;
			y = (double)1.0 - (e - x);
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, (high + (uint32_t)(k << 20)));
			return y - (double)1.0;
		}
		t = (double)1.0;
		if (k < 20) {
			uint32_t high;
			SET_HIGH_WORD(t, 0x3ff00000 - (0x200000 >> k));
			y = t - (e - x);
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, (high + (uint32_t)(k << 20)));
		} else {
			uint32_t high;
			SET_HIGH_WORD(t, ((0x3ff - k) << 20));
			y = x - (e + t);
			y += (double)1.0;
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, (high + (uint32_t)(k << 20)));
		}
	}
	return y;
}
#define __expm1(x)   expm1((x))


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double expm1l(long double x) {
	return expm1(x);
}
#   define __expm1l(x)   expm1l((x))
#elif LONG_DOUBLE_IS_X87_EXTENDED
LIB_FUNC long double expm1l(long double x) {
	if (isnan(x)) { return x; }
	else if (x > 1.1356523406294143949492E4L) { return x * 0x1p16383L; }
	else if (x == 0.0) { return x; }
	else if (x < -4.5054566736396445112120088E1L) { return -1.0L; }
	long double xx = 6.93145751953125E-1L + 1.428606820309417232121458176568075500134E-6L;
	register long double px = floorl(0.5L + x / xx);
	int k = px;
	x -= px * 6.93145751953125E-1L;
	x -= px * 1.428606820309417232121458176568075500134E-6L;
	px = ((((-5.238523121205561042771939008061958820811E-1L * x + 1.800826371455042224581246202420972737840E1L) * x + -3.423199068835684263987132888286791620673E2L) * x + 2.642771505685952966904660652518429479531E3L) * x + -1.586135578666346600772998894928250240826E4L) * x;
	register long double qx = ((((x + -4.002027679107076077238836622982900945173E1L) * x + 7.206038318724600171970199625081491823079E2L) * x + -7.207678383830091850230366618190187434796E3L) * x + 3.964866271411091674556850458227710004570E4L) * x + -9.516813471998079611319047060563358064497E4L;
	xx = x * x;
	qx = x + (0.5L * xx + xx * px / qx);
	px = scalbnl(1.0L, k);
	x = px * qx + (px - 1.0L);
	return x;
}
#   define __expm1l(x)   expm1l((x))
#endif


LIB_FUNC float frexpf(const float num, int* e) {
	float x = num;
	union { float f; uint32_t i; } y = { x };
	const int ee = (int)((y.i >> 23) & 0xff);
	if (!ee) {
		if (x) {
			x = frexpf((float)(x * (float)0x1p64), e);
			*e -= 64;
		} else { *e = 0; }
		return x;
	} else if (ee == 0xff) { return x; }
	*e = ee - 0x7e;
	y.i &= 0x807ffffful;
	y.i |= 0x3f000000ul;
	return y.f;
}


LIB_FUNC double frexp(const double num, int* e) {
	double x = num;
	union { double d; uint64_t i; } y = { x };
	const int ee = (int)((y.i >> 52) & 0x7ff);
	if (!ee) {
		if (x) {
			x = frexp((x * 0x1p64), e);
			*e -= 64;
		} else  { *e = 0; }
		return x;
	} else if (ee == 0x7ff) { return x; }
	*e = ee - 0x3fe;
	y.i &= 0x800fffffffffffffULL;
	y.i |= 0x3fe0000000000000ULL;
	return y.d;
}


#if ((LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384)
LIB_FUNC long double frexpl(const long double num, int* e) {
	long double x = num;
	union ldshape u = {x};
	const int ee = u.i.se & 0x7fff;
	if (!ee) {
		if (x) {
			x = frexpl((x * 0x1p120L), e);
			*e -= 120;
		} else { *e = 0; }
		return x;
	} else if (ee == 0x7fff) { return x; }
	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
	u.i.se |= 0x3ffe;
	return u.f;
}
#   define __frexpl(x, e)   frexpl((x), (e))
#else
LIB_FUNC long double frexpl(const long double x, int* e) {
	return (long double)frexp((double)x, e);
}
#   define __frexpl(x, e)   frexpl((x), (e))
#endif


// ROOT FUNCTIONS

LIB_FUNC float __ieee754_sqrtf(const float x) {
#ifdef AARCH64
	float result;
	asm ("fsqrt %s0, %s1;" : "=w"(result) : "w"(x));
	return result;
#elif defined(ARCHALPHA)
	float ret;
#   ifdef _IEEE_FP_INEXACT
	asm ("sqrts/suid %1, %0;" : "=f"(ret) : "f"(x));
#   else
	asm ("sqrts/sud %1, %0;" : "=f"(ret) : "f"(x));
#   endif
	return ret;
#elif defined(ARCHPOWERPC)
	float __z;
	asm ("fsqrts %0, %1;" : "=f"(__z) : "f"(x));
	return __z;
#elif ((defined(ARCHX86) || defined(ARCHX86_64)) && (CPU_AVX || CPU_SSE2AVX))
	float res;
#   if CPU_AVX
	asm ("vsqrtss %1, %0, %0;" : "=x"(res) : "xm"(x));
#   elif (CPU_SSE2AVX || CPU_SSE)
	asm ("sqrtss %1, %0;" : "=x"(res) : "xm"(x));
#   endif
	return res;
#elif ((defined(ARCHX86) || defined(ARCHX86_64)) && (!(CPU_AVX || CPU_SSE2AVX)))
	float r = x;
	asm ("fld %0;" "fsqrt;" "fstp %1;" : "=m"(r) : "m"(r));
	return r;
#else
	if (x <= 0.0F) {
		if (x < 0.0F) { return NANF; }
		return 0.0F;
	} else if (__isinff(x)) { return x; }
	register float est = x, nest = x - 1.0F;
	register int i;
	for (i = 0; (est != nest) && i != 20; i++) {
		est = nest;
		nest = est - (est * est - x) / (2.0F * est);
	}
	return nest;
#endif
}


LIB_FUNC double __ieee754_sqrt(const double x) {
#ifdef AARCH64
	double result;
	asm ("fsqrt %d0, %d1;" : "=w"(result) : "w"(x));
	return result;
#elif defined(ARCHALPHA)
	double ret;
#   ifdef _IEEE_FP_INEXACT
	asm ("sqrtt/suid %1, %0;" : "=f"(ret) : "f"(x));
#   else
	asm ("sqrtt/sud %1, %0;" : "=f"(ret) : "f"(x));
#   endif
	return ret;
#elif defined(ARCHPOWERPC)
	double __z;
	asm ("fsqrt %0, %1;" : "=f"(__z) : "f"(x));
	return __z;
#elif ((defined(ARCHX86) || defined(ARCHX86_64)) && (CPU_AVX || CPU_SSE2AVX))
	double res;
#   if CPU_AVX
	asm ("vsqrtsd %1, %0, %0;" : "=x"(res) : "xm"(x));
#   elif (CPU_SSE2AVX || CPU_SSE)
	asm ("sqrtsd %1, %0;" : "=x"(res) : "xm"(x));
#   endif
	return res;
#elif ((defined(ARCHX86) || defined(ARCHX86_64)) && (!(CPU_AVX || CPU_SSE2AVX)))
	double r = x;
	asm ("fldl %0;" "fsqrt;" "fstpl %1;" : "=m"(r) : "m"(r));
	return r;
#else
	if (x <= 0.0) {
		if (x < 0.0) { return NAN; }
		return 0.0;
	} else if (__isinf(x)) { return x; }
	register double est = x, nest = x - 1.0;
	register int i;
	for (i = 0; (est != nest) && i != 20; i++) {
		est = nest;
		nest = est - (est * est - x) / (2.0 * est);
	}
	return nest;
#endif
}


#if (defined(ARCHX86) || defined(ARCHX86_64))
LIB_FUNC long double __ieee754_sqrtl(const long double d) {
	long double res;
	asm ("fsqrt;" : "=t"(res) : "0"(d));
	return res;
}
#else
LIB_FUNC long double __ieee754_sqrtl(const long double d) {
	return (long double)__ieee754_sqrt((double)d);
}
#endif


LIB_FUNC float sqrtf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_sqrtf(x);
#else
	struct exception exc;
	const float z = __ieee754_sqrtf(x);
	if (__isnanf(x)) { return z; }
	else if (x < (float)0.0F) {
		exc.type = DOMAIN;
		exc.name = "sqrtf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = 0.0 / 0.0;
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double sqrt(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_sqrt(x);
#else
	struct exception exc;
	const double z = __ieee754_sqrt(x);
	if (__isnan(x)) { return z; }
	else if (x < 0.0) {
		exc.type = DOMAIN;
		exc.name = "sqrt";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = 0.0 / 0.0;
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double sqrtl(const long double x) {
	return (long double)sqrt((double)x);
}


/** Return the cubed root of x */
LIB_FUNC float cbrtf(const float num) {
	float x = num;
	int32_t hx;
	GET_FLOAT_WORD(hx, x);
	const uint32_t sign = (uint32_t)((uint32_t)hx & 0x80000000);
	hx = (int32_t)(hx ^ (int32_t)sign);
	if (!FLT_UWORD_IS_FINITE(hx)) { return x + x; }
	else if (FLT_UWORD_IS_ZERO(hx)) { return x; }
	SET_FLOAT_WORD(x, hx);
	uint32_t high;
	float t = 0.0F;
	if (FLT_UWORD_IS_SUBNORMAL(hx)) {
		SET_FLOAT_WORD(t, 0x4b800000);
		t *= x;
		GET_FLOAT_UWORD(high, t);
		SET_FLOAT_UWORD(t, (high / 3 + (uint32_t)642849266));
	}
	else { SET_FLOAT_UWORD(t, ((uint32_t)(hx / 3) + (uint32_t)709958130)); }
	const float r = t * t / x;
	const float s = (float)5.4285717010e-01 + r * t;
	t *= (float)3.5714286566e-01 + (float)1.6071428061e+00 / (s + (float)1.4142856598e+00 + (float)-7.0530611277e-01 / s);
	GET_FLOAT_UWORD(high, t);
	SET_FLOAT_UWORD(t, (high | sign));
	return t;
}


/** Return the cubed root of x */
LIB_FUNC double cbrt(const double num) {
	int32_t hx;
	double s, t = 0.0, w, x = num;
	uint32_t low;
	GET_HIGH_SIGNED_WORD(hx, x);
	const uint32_t sign = (uint32_t)((uint32_t)hx & 0x80000000);
	hx = (int32_t)(hx ^ (int32_t)sign);
	if (hx >= 0x7ff00000) { return x + x; }
	GET_LOW_WORD(low, x);
	if ((((uint32_t)hx) | low) == 0) { return x; }
	SET_HIGH_WORD(x, hx);
	uint32_t high;
	if (hx < 0x100000) {
		SET_HIGH_WORD(t, 0x43500000);
		t *= x;
		GET_HIGH_WORD(high, t);
		SET_HIGH_WORD(t, ((uint32_t)(high / 3) + (uint32_t)696219795));
	} else { SET_HIGH_WORD(t, ((uint32_t)(hx / 3) + (uint32_t)715094163)); }
	double r = (t * t) / x;
	s = (double)5.42857142857142815906e-01 + r * t;
	t *= (double)((double)3.57142857142857150787e-01 + (double)1.60714285714285720630e+00 / (s + (double)1.41428571428571436819e+00 + ((double)-7.05306122448979611050e-01 / s)));
	GET_HIGH_WORD(high, t);
	INSERT_WORDS(t, (high + 1), 0);
	s = t * t;
	r = x / s;
	w = t + t;
	r = (r - t) / (w + r);
	t = t + (t * r);
	GET_HIGH_WORD(high, t);
	SET_HIGH_WORD(t, (high | sign));
	return t;
}


LIB_FUNC long double cbrtl(const long double num) {
	return (long double)cbrt((double)num);
}


/** Approximate (and rounded) square-root of an ullint */
LIB_FUNC ullint sqrtull(const ullint num) {
	register ullint y = 1, delta = 3;
	while (y <= num) {
		y += delta;  // (y+1)^2
		delta += (ullint)2;
	}
	return ((delta >> (ullint)1) - (ullint)1);
}


/** Return the Square-Root of a positive number (Limit: 1000000000.0) */
LIB_FUNC float squarerootf(const float num) {
	if (num < (float)0.0F) { return -1.0F; }
	else if (floorf(num) == num && num <= (float)81.0F) {
		if (num == (float)0.0F) { return 0.0F; }
		else if (num == (float)1.0F) { return 1.0F; }
		else if (num == (float)4.0F) { return 2.0F; }
		else if (num == (float)9.0F) { return 3.0F; }
		else if (num == (float)16.0F) { return 4.0F; }
		else if (num == (float)25.0F) { return 5.0F; }
		else if (num == (float)36.0F) { return 6.0F; }
		else if (num == (float)49.0F) { return 7.0F; }
		else if (num == (float)64.0F) { return 8.0F; }
		else if (num == (float)81.0F) { return 9.0F; }
	}
	register float start = (float)0.0F;  // if num < 1; then 0 < num < sqrt(num); else 0 < sqrt(num) < num
	register float end = (num < (float)1.0F ? (float)1.0F : num);
	register float mid, midSqr;
	while ((end - start) > (float)0.0001F) {  // Define precision
		mid = (start + end) * (float)0.5F;
		midSqr = mid * mid;
		if (midSqr == num) { return mid; }  // Exact sqrt value
		else if (midSqr < num) { start = mid; }
		else { end = mid; }
	}
	return (float)((start + end) * (float)0.5F);
}


/** Return the Square-Root of a positive number (Limit: 1000000000000000.0) */
LIB_FUNC double squareroot(const double num) {
	if (num < (double)0.0) { return -1.0; }
	else if (floor(num) == num && num <= (double)81.0) {
		if (num == (double)0.0) { return 0.0; }
		else if (num == (double)1.0) { return 1.0; }
		else if (num == (double)4.0) { return 2.0; }
		else if (num == (double)9.0) { return 3.0; }
		else if (num == (double)16.0) { return 4.0; }
		else if (num == (double)25.0) { return 5.0; }
		else if (num == (double)36.0) { return 6.0; }
		else if (num == (double)49.0) { return 7.0; }
		else if (num == (double)64.0) { return 8.0; }
		else if (num == (double)81.0) { return 9.0; }
	}
	register double start = (double)0.0;  // if num < 1; then 0 < num < sqrt(num); else 0 < sqrt(num) < num
	register double end = (num < (double)1.0 ? (double)1.0 : num);
	register double mid, midSqr;
	while ((end - start) > (double)0.00001) {  // Define precision
		mid = (start + end) * (double)0.5;
		midSqr = mid * mid;
		if (midSqr == num) { return mid; }  // Exact sqrt value
		else if (midSqr < num) { start = mid; }
		else { end = mid; }
	}
	return (double)((start + end) * (double)0.5);
}


/** Return the Square-Root of a positive number */
LIB_FUNC long double squarerootl(const long double num) {
	if (num < (long double)0.0L) { return -1.0L; }
	else if (floorl(num) == num && num <= (long double)81.0L) {
		if (num == (long double)0.0L) { return 0.0L; }
		else if (num == (long double)1.0L) { return 1.0L; }
		else if (num == (long double)4.0L) { return 2.0L; }
		else if (num == (long double)9.0L) { return 3.0L; }
		else if (num == (long double)16.0L) { return 4.0L; }
		else if (num == (long double)25.0L) { return 5.0L; }
		else if (num == (long double)36.0L) { return 6.0L; }
		else if (num == (long double)49.0L) { return 7.0L; }
		else if (num == (long double)64.0L) { return 8.0L; }
		else if (num == (long double)81.0L) { return 9.0L; }
	}
	register long double start = (long double)0.0L;  // if num < 1; then 0 < num < sqrt(num); else 0 < sqrt(num) < num
	register long double end = (num < (long double)1.0L ? (long double)1.0L : num);
	register long double mid, midSqr;
	while ((end - start) > (long double)0.00000001L) {  // Define precision
		mid = (start + end) * (long double)0.5L;
		midSqr = mid * mid;
		if (midSqr == num) { return mid; }  // Exact sqrt value
		else if (midSqr < num) { start = mid; }
		else { end = mid; }
	}
	return (long double)((start + end) * (long double)0.5L);
}


/** Approximate square root of an integer */
LIB_FUNC uint8_t sqrt16(const uint16_t num) {
	register uint8_t x = 8, y = 8;
	for (;;) {
		if ((uint16_t)(y * y) > num) { y ^= x; }
		x >>= 1;
		if (x == 0) { return y; }
		y |= x;
	}
}


/** Approximate square root of an integer */
LIB_FUNC uint16_t sqrt32(const uint32_t num) {
	register uint16_t x = 0x80, y = 0x80;
	for (;;) {
		if ((uint32_t)(y * y) > num) { y ^= x; }
		x >>= 1;
		if (x == 0) { return y; }
		y |= x;
	}
}


/** Approximate square root of an integer */
LIB_FUNC uint32_t sqrt64(const uint64_t num) {
	register uint32_t x = 0x8000, y = 0x8000;
	for (;;) {
		if ((uint64_t)(y * y) > num) { y ^= x; }
		x >>= 1;
		if (x == 0) { return y; }
		y |= x;
	}
}


/** Inverse Square Root of an integer */
LIB_FUNC uint8_t isqrt8(const uint8_t num) {
	register uint8_t root = 0, remainder = num, place = 0x40;
	while (place > remainder) { place >>= 2; }
	while (place) {
		if (remainder >= (root + place)) {
			remainder = (uint8_t)((remainder - root) - place);
			root = (uint8_t)(root + (uint8_t)((uint8_t)place << (uint8_t)1));
		}
		root >>= 1;
		place >>= 2;
	}
	return root;
}


/** Inverse Square Root of an integer */
LIB_FUNC uint16_t isqrt16(const uint16_t num) {
	register uint16_t root = 0, remainder = num, place = 0x4000;
	while (place > remainder) { place >>= 2; }
	while (place) {
		if (remainder >= (root + place)) {
			remainder = (uint16_t)((remainder - root) - place);
			root = (uint16_t)(root + ((uint16_t)place << (uint16_t)1));
		}
		root >>= 1;
		place >>= 2;
	}
	return root;
}


/** Inverse Square Root of an integer */
LIB_FUNC uint32_t isqrt32(const uint32_t num) {
	register uint32_t root = 0, remainder = num, place = 0x40000000;
	while (place > remainder) { place >>= 2; }
	while (place) {
		if (remainder >= (root + place)) {
			remainder = (uint32_t)((remainder - root) - place);
			root += (uint32_t)(place << 1);
		}
		root >>= 1;
		place >>= 2;
	}
	return root;
}


/** Inverse Square Root of an integer */
LIB_FUNC uint64_t isqrt64(const uint64_t num) {
	register uint64_t root = 0, remainder = num, place = 0x4000000000000000;
	while (place > remainder) { place >>= 2; }
	while (place) {
		if (remainder >= (root + place)) {
			remainder = (uint64_t)((remainder - root) - place);
			root += (uint64_t)(place << 1);
		}
		root >>= 1;
		place >>= 2;
	}
	return root;
}


/** Return the Triangular root of the given number ((√(8*num+1)−1)/2) */
LIB_FUNC double triangular_root(const long num) {
	return ((sqrt((double)(8 * num + 1)) - 1.0) * 0.5);
}


/** Return the Hexagonal root of the given number ((√(8*num+1)+1)/4) */
LIB_FUNC double hexagonal_root(const long num) {
	return ((sqrt((double)(8 * num + 1)) + 1.0) * 0.25);
}


/** Return the Heptagonal root of the given number ((√(40*num+9)+3)/10) */
LIB_FUNC double heptagonal_root(const long num) {
	return ((sqrt((double)(40 * num + 9)) + 3.0) * 0.1);
}


// LOGARITHM FUNCTIONS

LIB_FUNC float __ieee754_logf(const float num) {
	float hfsq, f, s, z, R, w, t1, t2, dk, x = num;
	int32_t k, ix, i, j;
	GET_FLOAT_WORD(ix, x);
	k = 0;
	if (ix < 0x800000) {
		if (PREDICT_UNLIKELY((ix & 0x7fffffff) == 0)) { return -3.355443200e+07F / 0.0F; }
		else if (PREDICT_UNLIKELY(ix < 0)) { return (x - x) / (x - x); }
		k -= 25;
		x *= 3.355443200e+07F;
		GET_FLOAT_WORD(ix, x);
	}
	if (PREDICT_UNLIKELY(ix >= 0x7f800000)) { return x + x; }
	k += (ix >> 23) - 127;
	ix &= 0x7fffff;
	i = (ix + (0x95f64 << 3)) & 0x800000;
	SET_FLOAT_WORD(x, ix | (i ^ 0x3f800000));
	k += (i >> 23);
	f = x - (float)1.0F;
	if ((0x7fffff & (15 + ix)) < 16) {
		if (f == 0.0F) {
			if (k == 0) { return 0.0F; }
			else {
				dk = (float)k;
				return dk * 6.9313812256e-01F + dk * 9.0580006145e-06F;
			}
		}
		R = f * f * ((float)0.5F - (float)0.33333333333333333 * f);
		if (k == 0) { return f - R; }
		else {
			dk = (float)k;
			return dk * 6.9313812256e-01F - ((R - dk * 9.0580006145e-06F) - f);
		}
	}
	s = f / (2.0F + f);
	dk = (float)k;
	z = s * s;
	i = ix - (0x6147a << 3);
	w = z * z;
	j = (0x6b851 << 3) - ix;
	t1 = w * (4.0000000596e-01F + w * (2.2222198546e-01F + w * 1.5313838422e-01F));
	t2 = z * (6.6666668653e-01F + w * (2.8571429849e-01F + w * (1.8183572590e-01F + w * 1.4798198640e-01F)));
	i |= j;
	R = t2 + t1;
	if (i > 0) {
		hfsq = (float)0.5F * f * f;
		if (k == 0) { return f - (hfsq - s * (hfsq + R)); }
		else { return dk * 6.9313812256e-01F - ((hfsq - (s * (hfsq + R) + dk * 9.0580006145e-06F)) - f); }
	} else {
		if (k == 0) { return f - s * (f - R); }
		else { return dk * 6.9313812256e-01F - ((s * (f - R) - dk * 9.0580006145e-06F) - f); }
	}
}
#define __logf_finite(x)   __ieee754_logf((x))


LIB_FUNC double __ieee754_log(const double num) {
	double hfsq, f, s, z, R, w, t1, t2, dk, x = num;
	int32_t k, hx, i, j, lx;
	EXTRACT_SWORDS(hx, lx, x);
	k = 0;
	if (hx < 0x00100000) {
		if (((hx & 0x7fffffff) | lx) == 0) { return -1.80143985094819840000e+16 / 0.0; }
		else if (hx < 0) { return (x - x) / 0.0; }
		k -= 54;
		x *= 1.80143985094819840000e+16;
		GET_HIGH_SWORD(hx, x);
	}
	if (hx >= 0x7ff00000) { return x + x; }
	k += (hx >> 20) - 1023;
	hx &= 0x000fffff;
	i = (hx + 0x95f64) & 0x100000;
	SET_HIGH_WORD(x, (hx | (i ^ 0x3ff00000)));
	k += (i >> 20);
	f = x - 1.0;
	if ((0x000fffff & (2 + hx)) < 3) {
		if (f == 0.0) {
			if (k == 0) { return 0.0; }
			else {
				dk = (double)k;
				return dk * 6.93147180369123816490e-01 + dk * 1.90821492927058770002e-10;
			}
		}
		R = f * f * (0.5 - 0.33333333333333333 * f);
		if (k == 0) { return f - R; }
		else {
			dk = (double)k;
			return dk * 6.93147180369123816490e-01 - ((R - dk * 1.90821492927058770002e-10) - f);
		}
	}
	s = f / (2.0 + f);
	dk = (double)k;
	z = s * s;
	i = hx - 0x6147a;
	w = z * z;
	j = 0x6b851 - hx;
	t1 = w * (3.999999999940941908e-01 + w * (2.222219843214978396e-01 + w * 1.531383769920937332e-01));
	t2 = z * (6.666666666666735130e-01 + w * (2.857142874366239149e-01 + w * (1.818357216161805012e-01 + w * 1.479819860511658591e-01)));
	i |= j;
	R = t2 + t1;
	if (i > 0) {
		hfsq = 0.5 * f * f;
		if (k == 0) { return f - (hfsq - s * (hfsq + R)); }
		else { return dk * 6.93147180369123816490e-01 - ((hfsq - (s * (hfsq + R) + dk * 1.90821492927058770002e-10)) - f); }
	} else {
		if (k == 0) { return f - s * (f - R); }
		else { return dk * 6.93147180369123816490e-01 - ((s * (f - R) - dk * 1.90821492927058770002e-10) - f); }
	}
}
#define __log_finite(x)   __ieee754_log((x))


#if LONG_DOUBLE_IS_BINARY128
static const UNUSED long double ieee754_logtbl[92] = {
	-5.5345593589352099112142921677820359632418E-2L,
	-5.2108257402767124761784665198737642086148E-2L,
	-4.8991686870576856279407775480686721935120E-2L,
	-4.5993270766361228596215288742353061431071E-2L,
	-4.3110481649613269682442058976885699556950E-2L,
	-4.0340872319076331310838085093194799765520E-2L,
	-3.7682072451780927439219005993827431503510E-2L,
	-3.5131785416234343803903228503274262719586E-2L,
	-3.2687785249045246292687241862699949178831E-2L,
	-3.0347913785027239068190798397055267411813E-2L,
	-2.8110077931525797884641940838507561326298E-2L,
	-2.5972247078357715036426583294246819637618E-2L,
	-2.3932450635346084858612873953407168217307E-2L,
	-2.1988775689981395152022535153795155900240E-2L,
	-2.0139364778244501615441044267387667496733E-2L,
	-1.8382413762093794819267536615342902718324E-2L,
	-1.6716169807550022358923589720001638093023E-2L,
	-1.5138929457710992616226033183958974965355E-2L,
	-1.3649036795397472900424896523305726435029E-2L,
	-1.2244881690473465543308397998034325468152E-2L,
	-1.0924898127200937840689817557742469105693E-2L,
	-9.6875626072830301572839422532631079809328E-3L,
	-8.5313926245226231463436209313499745894157E-3L,
	-7.4549452072765973384933565912143044991706E-3L,
	-6.4568155251217050991200599386801665681310E-3L,
	-5.5356355563671005131126851708522185605193E-3L,
	-4.6900728132525199028885749289712348829878E-3L,
	-3.9188291218610470766469347968659624282519E-3L,
	-3.2206394539524058873423550293617843896540E-3L,
	-2.5942708080877805657374888909297113032132E-3L,
	-2.0385211375711716729239156839929281289086E-3L,
	-1.5522183228760777967376942769773768850872E-3L,
	-1.1342191863606077520036253234446621373191E-3L,
	-7.8340854719967065861624024730268350459991E-4L,
	-4.9869831458030115699628274852562992756174E-4L,
	-2.7902661731604211834685052867305795169688E-4L,
	-1.2335696813916860754951146082826952093496E-4L,
	-3.0677461025892873184042490943581654591817E-5L,
	0.0000000000000000000000000000000000000000E0L,
	-3.0359557945051052537099938863236321874198E-5L,
	-1.2081346403474584914595395755316412213151E-4L,
	-2.7044071846562177120083903771008342059094E-4L,
	-4.7834133324631162897179240322783590830326E-4L,
	-7.4363569786340080624467487620270965403695E-4L,
	-1.0654639687057968333207323853366578860679E-3L,
	-1.4429854811877171341298062134712230604279E-3L,
	-1.8753781835651574193938679595797367137975E-3L,
	-2.3618380914922506054347222273705859653658E-3L,
	-2.9015787624124743013946600163375853631299E-3L,
	-3.4938307889254087318399313316921940859043E-3L,
	-4.1378413103128673800485306215154712148146E-3L,
	-4.8328735414488877044289435125365629849599E-3L,
	-5.5782063183564351739381962360253116934243E-3L,
	-6.3731336597098858051938306767880719015261E-3L,
	-7.2169643436165454612058905294782949315193E-3L,
	-8.1090214990427641365934846191367315083867E-3L,
	-9.0486422112807274112838713105168375482480E-3L,
	-1.0035177140880864314674126398350812606841E-2L,
	-1.1067990155502102718064936259435676477423E-2L,
	-1.2146457974158024928196575103115488672416E-2L,
	-1.3269969823361415906628825374158424754308E-2L,
	-1.4437927104692837124388550722759686270765E-2L,
	-1.5649743073340777659901053944852735064621E-2L,
	-1.6904842527181702880599758489058031645317E-2L,
	-1.8202661505988007336096407340750378994209E-2L,
	-1.9542647000370545390701192438691126552961E-2L,
	-2.0924256670080119637427928803038530924742E-2L,
	-2.2346958571309108496179613803760727786257E-2L,
	-2.3810230892650362330447187267648486279460E-2L,
	-2.5313561699385640380910474255652501521033E-2L,
	-2.6856448685790244233704909690165496625399E-2L,
	-2.8438398935154170008519274953860128449036E-2L,
	-3.0058928687233090922411781058956589863039E-2L,
	-3.1717563112854831855692484086486099896614E-2L,
	-3.3413836095418743219397234253475252001090E-2L,
	-3.5147290019036555862676702093393332533702E-2L,
	-3.6917475563073933027920505457688955423688E-2L,
	-3.8723951502862058660874073462456610731178E-2L,
	-4.0566284516358241168330505467000838017425E-2L,
	-4.2444048996543693813649967076598766917965E-2L,
	-4.4356826869355401653098777649745233339196E-2L,
	-4.6304207416957323121106944474331029996141E-2L,
	-4.8285787106164123613318093945035804818364E-2L,
	-5.0301169421838218987124461766244507342648E-2L,
	-5.2349964705088137924875459464622098310997E-2L,
	-5.4431789996103111613753440311680967840214E-2L,
	-5.6546268881465384189752786409400404404794E-2L,
	-5.8693031345788023909329239565012647817664E-2L,
	-6.0871713627532018185577188079210189048340E-2L,
	-6.3081958078862169742820420185833800925568E-2L,
	-6.5323413029406789694910800219643791556918E-2L,
	-6.7595732653791419081537811574227049288168E-2L
};


LIB_FUNC long double __ieee754_logl(const long double num) {
	long double z, y, w, x = num;
	ieee854_long_double_shape_type u, t;
	u.value = x;
	unsigned int m = u.parts32.w0;
	int k = m & 0x7fffffff;
	if (((uint32_t)k | u.parts32.w1 | u.parts32.w2 | u.parts32.w3) == 0) { return -0.5L / ieee754_logtbl[38]; }
	else if (m & 0x80000000) { return (x - x) / ieee754_logtbl[38]; }
	else if (k >= 0x7fff0000) { return x + x; }
	int e;
	u.value = frexpl(x, &e);
	m = u.parts32.w0 & 0xffff;
	m |= 0x10000;
	if (m < 0x16800) {
		k = (int)((m - 0xff00) >> 9);
		t.parts32.w0 = (uint32_t)(0x3fff0000 + (k << 9));
		t.parts32.w1 = 0;
		t.parts32.w2 = 0;
		t.parts32.w3 = 0;
		u.parts32.w0 += 0x10000;
		e -= 1;
		k += 64;
	} else {
		k = (int)((m - 0xfe00) >> 10);
		t.parts32.w0 = (uint32_t)(0x3ffe0000 + (k << 10));
		t.parts32.w1 = 0;
		t.parts32.w2 = 0;
		t.parts32.w3 = 0;
	}
	if ((x <= 1.0078125L) && (x >= 0.9921875L)) {
		if (x == 1.0L) { return 0.0L; }
		z = x - 1.0L;
		k = 64;
		t.value = 1.0L;
		e = 0;
	} else {
		z = (u.value - t.value) / t.value;
	}
	w = z * z;
	y = ((((((((((((6.668057591071739754844678883223432347481E-2L * z + -7.144242754190814657241902218399056829264E-2L) * z + 7.692307559897661630807048686258659316091E-2L) * z + -8.333333211818065121250921925397567745734E-2L) * z + 9.090909090915566247008015301349979892689E-2L) * z + -1.000000000000532974938900317952530453248E-1L) * z + 1.111111111111111093947834982832456459186E-1L) * z + -1.249999999999999987884655626377588149000E-1L) * z + 1.428571428571428571428808945895490721564E-1L) * z + -1.666666666666666666666798448356171665678E-1L) * z + 1.999999999999999999999999998515277861905E-1L) * z + -2.499999999999999999999999999486853077002E-1L) * z + 3.333333333333333333333333333333336096926E-1L) * z * w;
	y -= 0.5 * w;
	y += e * 1.4286068203094172321214581765680755001344E-6L;
	y += z;
	y += ieee754_logtbl[k - 26];
	y += (t.value - 1.0L);
	y += e * 6.93145751953125e-1L;
	return y;
}
#   define __logl_finite(x)   __ieee754_logl((x))
#else
LIB_FUNC long double __ieee754_logl(const long double num) {
	return (long double)__ieee754_log((double)num);
}
#endif


LIB_FUNC float __logf(const float x) {
	if (PREDICT_UNLIKELY(__islessequalf(x, 0.0F))) {
		if (x == 0.0F) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, 116);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, 117);
		}
	}
	return __ieee754_logf(x);
}
#define logf(x)   __logf((x))


LIB_FUNC double __log(const double x) {
	if (PREDICT_UNLIKELY(__islessequal(x, 0.0))) {
		if (x == 0.0) {
			__feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, 16);
		} else {
			__feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, 17);
		}
	}
	return __ieee754_log(x);
}
#define log(x)   __log((x))


LIB_FUNC long double __logl(const long double x) {
	if (PREDICT_UNLIKELY(__islessequall(x, 0.0L))) {
		if (x == 0.0L) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, 216);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, 217);
		}
	}
	return __ieee754_logl(x);
}
#define logl(x)   __logl((x))


LIB_FUNC float __ieee754_log2f(const float num) {
	float hfsq, f, s, z, R, w, t1, t2, dk, x = num;
	int32_t k, ix, i, j;
	GET_FLOAT_WORD(ix, x);
	k = 0;
	if (ix < 0x00800000) {
		if (PREDICT_UNLIKELY((ix & 0x7fffffff) == 0)) { return -3.355443200e+07F / (x - x); }
		else if (PREDICT_UNLIKELY(ix < 0)) { return (x - x) / (x - x); }
		k -= 25;
		x *= 3.355443200e+07F;
		GET_FLOAT_WORD(ix, x);
	}
	if (PREDICT_UNLIKELY(ix >= 0x7f800000)) { return x + x; }
	k += (ix >> 23) - 127;
	ix &= 0x007fffff;
	i = (ix + (0x95f64 << 3)) & 0x800000;
	SET_FLOAT_WORD(x, ix | (i ^ 0x3f800000));
	k += (i >> 23);
	dk = (float)k;
	f = x - (float)1.0;
	if ((0x007fffff & (15 + ix)) < 16) {
		if (f == 0.0F) {
			if (FIX_INT_FP_CONVERT_ZERO && dk == 0.0f) { dk = 0.0F; }
			return dk;
		}
		R = f * f * ((float)0.5F - (float)0.33333333333333333 * f);
		return dk - (R - f) / 0.69314718055994530942F;
	}
	s = f / ((float)2.0F + f);
	z = s * s;
	i = ix - (0x6147a << 3);
	w = z * z;
	j = (0x6b851 << 3) - ix;
	t1 = w * (4.0000000596e-01F + w * (2.2222198546e-01F + w * 1.5313838422e-01F));
	t2 = z * (6.6666668653e-01F + w * (2.8571429849e-01F + w * (1.8183572590e-01F + w * 1.4798198640e-01F)));
	i |= j;
	R = t2 + t1;
	if (i > 0) {
		hfsq = (float)0.5F * f * f;
		return dk - ((hfsq - (s * (hfsq + R))) - f) / 0.69314718055994530942F;
	} else {
		return dk - ((s * (f - R)) - f) / 0.69314718055994530942F;
	}
}
#define __log2f_finite(x)   __ieee754_log2f((x))


LIB_FUNC double __ieee754_log2(const double num) {
	double hfsq, f, s, z, R, w, t1, t2, dk, x = num;
	int32_t k, hx, i, j, lx;
	EXTRACT_SWORDS(hx, lx, x);
	k = 0;
	if (hx < 0x100000) {
		if (PREDICT_UNLIKELY(((hx & 0x7fffffff) | lx) == 0)) { return -1.80143985094819840000e+16 / (x - x); }
		if (PREDICT_UNLIKELY(hx < 0)) { return (x - x) / (x - x); }
		k -= 54;
		x *= 1.80143985094819840000e+16;
		GET_HIGH_SWORD(hx, x);
	}
	if (PREDICT_UNLIKELY(hx >= 0x7ff00000)) { return x + x; }
	k += (hx >> 20) - 1023;
	hx &= 0x000fffff;
	i = (hx + 0x95f64) & 0x100000;
	SET_HIGH_WORD(x, hx | (i ^ 0x3ff00000));
	k += (i >> 20);
	dk = (double) k;
	f = x - 1.0;
	if ((0x000fffff & (2 + hx)) < 3) {
		if (f == 0.0) {
			if (FIX_INT_FP_CONVERT_ZERO && dk == 0.0) { dk = 0.0; }
			return dk;
		}
		R = f * f * (0.5 - 0.33333333333333333 * f);
		return dk - (R - f) / 0.69314718055994530942;
	}
	s = f / (2.0 + f);
	z = s * s;
	i = hx - 0x6147a;
	w = z * z;
	j = 0x6b851 - hx;
	t1 = w * (3.999999999940941908e-01 + w * (2.222219843214978396e-01 + w * 1.531383769920937332e-01));
	t2 = z * (6.666666666666735130e-01 + w * (2.857142874366239149e-01 + w * (1.818357216161805012e-01 + w * 1.479819860511658591e-01)));
	i |= j;
	R = t2 + t1;
	if (i > 0) {
		hfsq = 0.5 * f * f;
		return dk - ((hfsq - (s * (hfsq + R))) - f) / 0.69314718055994530942;
	} else {
		return dk - ((s * (f - R)) - f) / 0.69314718055994530942;
	}
}
#define __log2_finite(x)   __ieee754_log2((x))


#if SUPPORTS_LONG_DOUBLE
LIB_FUNC long double neval(long double x, const long double* p, int n) {
	long double y;
	p += n;
	y = *p--;
	do { y = (long double)(y * x + *p--); } while (--n > 0);
	return y;
}


LIB_FUNC long double deval(long double x, const long double* p, int n) {
	long double y;
	p += n;
	y = x + *p--;
	do { y = (long double)(y * x + *p--); } while (--n > 0);
	return y;
}
#endif


#if LONG_DOUBLE_IS_BINARY128
static const long double ieee754_log2l_P[13] = {
	1.313572404063446165910279910527789794488E4L,
	7.771154681358524243729929227226708890930E4L,
	2.014652742082537582487669938141683759923E5L,
	3.007007295140399532324943111654767187848E5L,
	2.854829159639697837788887080758954924001E5L,
	1.797628303815655343403735250238293741397E5L,
	7.594356839258970405033155585486712125861E4L,
	2.128857716871515081352991964243375186031E4L,
	3.824952356185897735160588078446136783779E3L,
	4.114517881637811823002128927449878962058E2L,
	2.321125933898420063925789532045674660756E1L,
	4.998469661968096229986658302195402690910E-1L,
	1.538612243596254322971797716843006400388E-6L
};


static const long double ieee754_log2l_Q[12] = {
	3.940717212190338497730839731583397586124E4L,
	2.626900195321832660448791748036714883242E5L,
	7.777690340007566932935753241556479363645E5L,
	1.347518538384329112529391120390701166528E6L,
	1.514882452993549494932585972882995548426E6L,
	1.158019977462989115839826904108208787040E6L,
	6.132189329546557743179177159925690841200E5L,
	2.248234257620569139969141618556349415120E5L,
	5.605842085972455027590989944010492125825E4L,
	9.147150349299596453976674231612674085381E3L,
	9.104928120962988414618126155557301584078E2L,
	4.839208193348159620282142911143429644326E1L

};


static const long double ieee754_log2l_R[6] = {
	1.418134209872192732479751274970992665513E5L,
	-8.977257995689735303686582344659576526998E4L,
	2.048819892795278657810231591630928516206E4L,
	-2.024301798136027039250415126250455056397E3L,
	8.057002716646055371965756206836056074715E1L,
	-8.828896441624934385266096344596648080902E-1L
};


static const long double ieee754_log2l_S[6] = {
	1.701761051846631278975701529965589676574E6L,
	-1.332535117259762928288745111081235577029E6L,
	4.001557694070773974936904547424676279307E5L,
	-5.748542087379434595104154610899551484314E4L,
	3.998526750980007367835804959888064681098E3L,
	-1.186359407982897997337150403816839480438E2L
};


LIB_FUNC long double __ieee754_log2l(const long double num) {
	long double z, y, x = num;
	int e;
	int64_t hx, lx;
	GET_LDOUBLE_SWORDS64(hx, lx, x);
	if (((hx & 0x7fffffffffffffffLL) | lx) == 0) { return (-1.0L / (x - x)); }
	else if (hx < 0) { return (x - x) / (x - x); }
	else if (hx >= 0x7fff000000000000LL) { return (x + x); }
	else if (x == 1.0L) { return 0.0L; }
	x = frexpl(x, &e);
	if ((e > 2) || (e < -2)) {
		if (x < 7.071067811865475244008443621048490392848359E-1L) {
			e -= 1;
			z = x - 0.5L;
			y = 0.5L * z + 0.5L;
		} else {
			z = x - 0.5L;
			z -= 0.5L;
			y = 0.5L * x + 0.5L;
		}
		x = z / y;
		z = x * x;
		y = x * (z * neval(z, ieee754_log2l_R, 5) / deval(z, ieee754_log2l_S, 5));
		goto ieee754_log2l_done;
	}
	if (x < 7.071067811865475244008443621048490392848359E-1L) {
		e -= 1;
		x = 2.0L * x - 1.0L;
	} else {
		x = x - 1.0L;
	}
	z = x * x;
	y = x * (z * neval(x, ieee754_log2l_P, 12) / deval(x, ieee754_log2l_Q, 11));
	y = y - 0.5L * z;
ieee754_log2l_done:
	z = y * 4.4269504088896340735992468100189213742664595E-1L;
	z += x * 4.4269504088896340735992468100189213742664595E-1L;
	z += y;
	z += x;
	z += e;
	return (z);
}
#   define __log2l_finite(x)   __ieee754_log2l((x))
#else
LIB_FUNC long double __ieee754_log2l(const long double num) {
	return (long double)__ieee754_log2((double)num);
}
#   define __log2l_finite(x)   __ieee754_log2l((x))
#endif


LIB_FUNC float __log2f(const float x) {
	if (PREDICT_UNLIKELY(__islessequalf(x, 0.0F))) {
		if (x == 0.0F) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, 148);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, 149);
		}
	}
	return __ieee754_log2f(x);
}
#define log2f(x)   __log2f((x))


LIB_FUNC double __log2(const double x) {
	if (PREDICT_UNLIKELY(__islessequal(x, 0.0))) {
		if (x == 0.0) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, 48);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, 49);
		}
	}
	return __ieee754_log2(x);
}
#define log2(x)   __log2((x))


LIB_FUNC long double __log2l(const long double x) {
	if (PREDICT_UNLIKELY(__islessequall(x, 0.0L))) {
		if (x == 0.0L) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, 248);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, 249);
		}
	}
	return __ieee754_log2l(x);
}
#define log2l(x)   __log2l((x))


LIB_FUNC float __ieee754_log10f(const float num) {
	float y, z, x = num;
	int32_t i, k, hx;
	GET_FLOAT_WORD(hx, x);
	k = 0;
	if (hx < 0x00800000) {
		if (PREDICT_UNLIKELY((hx & 0x7fffffff) == 0)) { return -3.3554432000e+07F / (x - x); }
		else if (PREDICT_UNLIKELY(hx < 0)) { return (x - x) / (x - x); }
		k -= 25;
		x *= 3.3554432000e+07F;
		GET_FLOAT_WORD(hx, x);
	}
	if (PREDICT_UNLIKELY(hx >= 0x7f800000)) { return x + x; }
	k += (hx >> 23) - 127;
	i = (int32_t)(((uint32_t)k & 0x80000000) >> 31);
	hx = (hx & 0x007fffff) | ((0x7f - i) << 23);
	y = (float)(k + i);
	if (FIX_INT_FP_CONVERT_ZERO && y == 0.0F) { y = 0.0F; }
	SET_FLOAT_WORD(x, hx);
	z = y * 7.9034151668e-07F + 4.3429449201e-01F * __ieee754_logf(x);
	return  z + y * 3.0102920532e-01F;
}
#define __log10f_finite(x)   __ieee754_log10f((x))


LIB_FUNC double __ieee754_log10(const double num) {
	double y, z, x = num;
	int32_t i, k, hx, lx;
	EXTRACT_SWORDS(hx, lx, x);
	k = 0;
	if (hx < 0x100000) {
		if (PREDICT_UNLIKELY(((hx & 0x7fffffff) | lx) == 0)) { return -1.80143985094819840000e+16 / (x - x); }
		else if (PREDICT_UNLIKELY(hx < 0)) { return (x - x) / (x - x); }
		k -= 54;
		x *= 1.80143985094819840000e+16;
		GET_HIGH_SWORD(hx, x);
	}
	if (PREDICT_UNLIKELY(hx >= 0x7ff00000)) { return x + x; }
	k += (hx >> 20) - 1023;
	i = (int32_t)(((uint32_t) k & 0x80000000) >> 31);
	hx = (hx & 0x000fffff) | ((0x3ff - i) << 20);
	y = (double)(k + i);
	if (FIX_INT_FP_CONVERT_ZERO && y == 0.0) { y = 0.0; }
	SET_HIGH_WORD(x, hx);
	z = y * 3.69423907715893078616e-13 + 4.34294481903251816668e-01 * __ieee754_log(x);
	return z + y * 3.01029995663611771306e-01;
}
#define __log10_finite(x)   __ieee754_log10((x))


#if LONG_DOUBLE_IS_BINARY128
static const long double log10l_P[13] = {
	1.313572404063446165910279910527789794488E4L,
	7.771154681358524243729929227226708890930E4L,
	2.014652742082537582487669938141683759923E5L,
	3.007007295140399532324943111654767187848E5L,
	2.854829159639697837788887080758954924001E5L,
	1.797628303815655343403735250238293741397E5L,
	7.594356839258970405033155585486712125861E4L,
	2.128857716871515081352991964243375186031E4L,
	3.824952356185897735160588078446136783779E3L,
	4.114517881637811823002128927449878962058E2L,
	2.321125933898420063925789532045674660756E1L,
	4.998469661968096229986658302195402690910E-1L,
	1.538612243596254322971797716843006400388E-6L
};


static const long double log10l_Q[12] = {
	3.940717212190338497730839731583397586124E4L,
	2.626900195321832660448791748036714883242E5L,
	7.777690340007566932935753241556479363645E5L,
	1.347518538384329112529391120390701166528E6L,
	1.514882452993549494932585972882995548426E6L,
	1.158019977462989115839826904108208787040E6L,
	6.132189329546557743179177159925690841200E5L,
	2.248234257620569139969141618556349415120E5L,
	5.605842085972455027590989944010492125825E4L,
	9.147150349299596453976674231612674085381E3L,
	9.104928120962988414618126155557301584078E2L,
	4.839208193348159620282142911143429644326E1L

};


static const long double log10l_R[6] = {
	1.418134209872192732479751274970992665513E5L,
	-8.977257995689735303686582344659576526998E4L,
	2.048819892795278657810231591630928516206E4L,
	-2.024301798136027039250415126250455056397E3L,
	8.057002716646055371965756206836056074715E1L,
	-8.828896441624934385266096344596648080902E-1L
};


static const long double log10l_S[6] = {
	1.701761051846631278975701529965589676574E6L,
	-1.332535117259762928288745111081235577029E6L,
	4.001557694070773974936904547424676279307E5L,
	-5.748542087379434595104154610899551484314E4L,
	3.998526750980007367835804959888064681098E3L,
	-1.186359407982897997337150403816839480438E2L

};


LIB_FUNC long double __ieee754_log10l(const long double num) {
	long double z, y, x = num;
	int e;
	int64_t hx, lx;
	GET_LDOUBLE_SWORDS64(hx, lx, x);
	if (((hx & 0x7fffffffffffffffLL) | lx) == 0) { return (-1.0L / (x - x)); }
	else if (hx < 0) { return (x - x) / (x - x); }
	else if (hx >= 0x7fff000000000000LL) { return (x + x); }
	else if (x == 1.0L) { return 0.0L; }
	x = frexpl(x, &e);
	if ((e > 2) || (e < -2)) {
		if (x < 7.071067811865475244008443621048490392848359E-1L) {
			e -= 1;
			z = x - 0.5L;
			y = 0.5L * z + 0.5L;
		} else {
			z = x - 0.5L;
			z -= 0.5L;
			y = 0.5L * x + 0.5L;
		}
		x = z / y;
		z = x * x;
		y = x * (z * neval(z, log10l_R, 5) / deval(z, log10l_S, 5));
		goto ieee754_log10l_done;
	}
	if (x < 7.071067811865475244008443621048490392848359E-1L) {
		e -= 1;
		x = 2.0 * x - 1.0L;
	} else { x = x - 1.0L; }
	z = x * x;
	y = x * (z * neval(x, log10l_P, 12) / deval(x, log10l_Q, 11));
	y = y - 0.5 * z;
ieee754_log10l_done:
	z = y * -6.570551809674817234887108108339491770560299E-2L;
	z += x * -6.570551809674817234887108108339491770560299E-2L;
	z += e * -1.14700043360188047862611052755069732318101185E-2L;
	z += y * 0.5L;
	z += x * 0.5L;
	z += e * 0.3125L;
	return z;
}
#   define __log10l_finite(x)   __ieee754_log10l((x))
#else
LIB_FUNC long double __ieee754_log10l(const long double num) {
	return (long double)__ieee754_log10((double)num);
}
#   define __log10l_finite(x)   __ieee754_log10l((x))
#endif


LIB_FUNC float __log10f(const float x) {
	if (PREDICT_UNLIKELY(__islessequalf(x, 0.0F))) {
		if (x == 0.0F) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, 118);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, 119);
		}
	}
	return __ieee754_log10f(x);
}
#define log10f(x)   __log10f((x))


LIB_FUNC double __log10(const double x) {
	if (PREDICT_UNLIKELY(__islessequal(x, 0.0))) {
		if (x == 0.0) {
			__feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, 18);
		} else {
			__feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, 19);
		}
	}
	return __ieee754_log10(x);
}
#define log10(x)   __log10((x))


LIB_FUNC long double __log10l(const long double x) {
	if (PREDICT_UNLIKELY(__islessequall(x, 0.0L))) {
		if (x == 0.0L) {
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, 218);
		} else {
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, 219);
		}
	}
	return __ieee754_log10l(x);
}
#define log10l(x)   __log10l((x))


/** Return the binary exponent of non-zero x */
LIB_FUNC int __ieee754_ilogbf(const float x) {
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	hx &= 0x7fffffff;
	if (hx < 0x800000) {
		if (hx == 0) { return FP_ILOGB0; }
		else { for (ix = -126, hx <<= 8; hx > 0; hx <<= 1) { ix -= 1; } }
		return ix;
	} else if (hx < 0x7f800000) { return (hx >> 23) - 127; }
	else if ((FP_ILOGBNAN != INT_MAX) && (hx == 0x7f800000)) { return INT_MAX; }
	return FP_ILOGBNAN;
}


/** Return the binary exponent of non-zero x */
LIB_FUNC int __ieee754_ilogb(const double x) {
	int32_t hx, lx, ix;
	GET_HIGH_SWORD(hx, x);
	hx &= 0x7fffffff;
	if (hx < 0x100000) {
		GET_LOW_SWORD(lx, x);
		if ((hx | lx) == 0) { return FP_ILOGB0; }
		else if (hx == 0) { for (ix = -1043; lx > 0; lx <<= 1) { ix -= 1; } }
		else { for (ix = -1022, hx <<= 11; hx > 0; hx <<= 1) { ix -= 1; } }
		return ix;
	} else if (hx < 0x7ff00000) { return (hx >> 20) - 1023; }
	else if (FP_ILOGBNAN != INT_MAX) {
		GET_LOW_SWORD(lx, x);
		if (((hx ^ 0x7ff00000) | lx) == 0) { return INT_MAX; }
	}
	return FP_ILOGBNAN;
}


#if LONG_DOUBLE_IS_BINARY128
/** Return the binary exponent of non-zero x */
LIB_FUNC int __ieee754_ilogbl(const long double x) {
	int64_t hx, lx;
	int ix;
	GET_LDOUBLE_SWORDS64(hx, lx, x);
	hx &= 0x7fffffffffffffffLL;
	if (hx <= 0x1000000000000LL) {
		if ((hx | lx) == 0) { return FP_ILOGB0; }
		else if (hx == 0) { for (ix = -16431; lx > 0; lx <<= 1) { ix -=1; } }
		else { for (ix = -16382, hx <<= 15; hx > 0; hx <<= 1) { ix -=1; } }
		return ix;
	} else if (hx < 0x7fff000000000000LL) { return (int)((hx >> 48) - 0x3fff); }
	else if ((FP_ILOGBNAN != INT_MAX) && (((hx ^ 0x7fff000000000000LL) | lx) == 0)) { return INT_MAX; }
	return FP_ILOGBNAN;
}
#elif SUPPORTS_LONG_DOUBLE_128
/** Return the binary exponent of non-zero x */
LIB_FUNC int __ieee754_ilogbl(const long double x) {
	register int ix;
	double xhi, xlo;
	ldbl_unpack(x, &xhi, &xlo);
	int64_t hx;
	EXTRACT_WORDS64(hx, xhi);
	int64_t hxs = hx;
	hx &= 0x7fffffffffffffffLL;
	if (hx <= 0x10000000000000LL) {
		if (hx == 0) { return FP_ILOGB0; }
		else { for (ix = -1022, hx <<= 11; hx > 0; hx <<= 1) { ix -=1; } }
		return ix;
	} else if (hx < 0x7ff0000000000000LL) {
		register int hexp = (hx >> 52) - 0x3ff;
		if ((hx & 0xfffffffffffffLL) == 0) {
			int64_t lx;
			EXTRACT_WORDS64 (lx, xlo);
			if ((hxs ^ lx) < 0 && (lx & 0x7fffffffffffffffLL) != 0) { hexp--; }
		}
		return hexp;
	} else if ((FP_ILOGBNAN != INT_MAX) && (hx == 0x7ff0000000000000LL)) { return INT_MAX; }
	return FP_ILOGBNAN;
}
#else
/** Return the binary exponent of non-zero x */
LIB_FUNC int __ieee754_ilogbl(const long double x) {
	return (int)__ieee754_ilogb((double)x);
}
#endif


LIB_FUNC int __ilogbf(const float x) {
	const int r = __ieee754_ilogbf(x);
	if (PREDICT_UNLIKELY(r == FP_ILOGB0) || PREDICT_UNLIKELY(r == FP_ILOGBNAN) || PREDICT_UNLIKELY(r == INT_MAX)) {
		__set_errno(EDOM);
		feraiseexcept(FE_INVALID);
	}
	return r;
}
#define ilogbf(x)   __ilogbf((x))


LIB_FUNC int __ilogb(const double x) {
	const int r = __ieee754_ilogb(x);
	if (PREDICT_UNLIKELY(r == FP_ILOGB0) || PREDICT_UNLIKELY(r == FP_ILOGBNAN) || PREDICT_UNLIKELY(r == INT_MAX)) {
		__set_errno(EDOM);
		__feraiseexcept(FE_INVALID);
	}
	return r;
}
#define ilogb(x)   __ilogb((x))


LIB_FUNC int __ilogbl(const long double x) {
	const int r = __ieee754_ilogbl(x);
	if (PREDICT_UNLIKELY(r == FP_ILOGB0) || PREDICT_UNLIKELY(r == FP_ILOGBNAN) || PREDICT_UNLIKELY(r == INT_MAX)) {
		__set_errno(EDOM);
		feraiseexcept(FE_INVALID);
	}
	return r;
}
#define ilogbl(x)   __ilogbl((x))


LIB_FUNC float __log1pf(const float num) {
	float hfsq, f, c, s, z, R, u, x = num;
	int32_t hx, hu, k = 1;
	GET_FLOAT_WORD(hx, x);
	const int32_t ax = (hx & 0x7fffffff);
	if (hx < 0x3ed413d7) {
		if (ax >= 0x3f800000) {
			if (x == -1.0F) { return (float)(-3.355443200e+07F / 0.0F); }
			else { return (x - x) / (x - x); }
		} else if (ax < 0x31000000) {
			math_force_eval((3.355443200e+07F + x));
			if (ax < 0x24800000) {
				// math_check_force_underflow(x);
				return x;
			}
			else { return x - x * x * 0.5F; }
		}
		if (hx > 0 || hx <= ((int32_t)0xbe95f61f)) {
			k = 0;
			f = x;
			hu = 1;
		}
	}
	if (hx >= 0x7f800000) { return x + x; }
	else if (k != 0) {
		if (hx < 0x5a000000) {
			u = 1.0F + x;
			GET_FLOAT_WORD(hu, u);
			k = (hu >> 23) - 127;
			c = (k > 0) ? 1.0F - (u - x) : x - (u - 1.0F);
			c /= u;
		} else {
			u = x;
			GET_FLOAT_WORD(hu, u);
			k = (hu >> 23) - 127;
			c = 0;
		}
		hu &= 0x7fffff;
		if (hu < 0x3504f7) { SET_FLOAT_WORD(u, (hu | 0x3f800000)); }
		else {
			k += 1;
			SET_FLOAT_WORD(u, (hu | 0x3f000000));
			hu = (0x800000 - hu) >> 2;
		}
		f = u - 1.0F;
	}
	hfsq = 0.5F * f * f;
	if (hu == 0) {
		if (f == 0.0F) {
			if (k == 0) { return 0.0F; }
			else {
				c += ((float)k) * 9.0580006145e-06F;
				return ((float)k) * 6.9313812256e-01F + c;
			}
		}
		R = hfsq * (1.0F - 0.66666666666666666F * f);
		if (k == 0) { return f - R; }
		else { return ((float)k) * 6.9313812256e-01F - ((R - (((float)k) * 9.0580006145e-06F + c)) - f); }
	}
	s = f / (2.0F + f);
	z = s * s;
	R = z * (6.6666668653e-01F + z * (4.0000000596e-01F + z * (2.8571429849e-01F + z * (2.2222198546e-01F + z * (1.8183572590e-01F + z * (1.5313838422e-01F + z * 1.4798198640e-01F))))));
	if (k == 0) { return f - (hfsq - s * (hfsq + R)); }
	else { return ((float)k) * 6.9313812256e-01F - ((hfsq - (s * (hfsq + R) + (((float)k) * 9.0580006145e-06F + c))) - f); }
}


LIB_FUNC double __log1p(const double num) {
	double hfsq, f = 0, c = 0, s, z, R, u, x = num;
	int32_t hx, hu = 0, k = 1;
	GET_HIGH_SWORD(hx, x);
	int32_t ax = (hx & 0x7fffffff);
	if (hx < 0x3FDA827A) {
		if (ax >= 0x3ff00000) {
			if (x == -1.0) { return -1.80143985094819840000e+16 / 0.0; }
			else { return (x - x) / (x - x); }
		} else if (ax < 0x3e200000) {
			if ((1.80143985094819840000e+16 + x) > 0.0 && ax < 0x3c900000) { return x; }
			else { return x - x * x * 0.5; }
		} else if (hx > 0 || hx <= ((int32_t)0xbfd2bec3)) {
			k = 0;
			f = x;
			hu = 1;
		}
	}
	if (hx >= 0x7ff00000) { return x + x; }
	else if (k != 0) {
		if (hx < 0x43400000) {
			u = 1.0 + x;
			GET_HIGH_SWORD(hu, u);
			k = (hu >> 20) - 1023;
			c = (k > 0) ? 1.0 - (u - x) : x - (u - 1.0);
			c /= u;
		} else {
			u = x;
			GET_HIGH_SWORD(hu, u);
			k = (hu >> 20) - 1023;
			c = 0;
		}
		hu &= 0x000fffff;
		if (hu < 0x6a09e) {
			SET_HIGH_WORD(u, hu | 0x3ff00000);
		} else {
			k += 1;
			SET_HIGH_WORD(u, hu | 0x3fe00000);
			hu = (0x00100000 - hu) >> 2;
		}
		f = u - 1.0;
	}
	hfsq = 0.5 * f * f;
	if (hu == 0) {
		if (f == 0.0) {
			if (k == 0) { return 0.0; }
			else {
				c += ((double)k) * 1.90821492927058770002e-10;
				return ((double)k) * 6.93147180369123816490e-01 + c;
			}
		}
		R = hfsq * (1.0 - 0.66666666666666666 * f);
		if (k == 0) { return f - R; }
		else { return ((double)k) * 6.93147180369123816490e-01 - ((R - (((double)k) * 1.90821492927058770002e-10 + c)) - f); }
	}
	s = f / (2.0 + f);
	z = s * s;
	R = z * (6.666666666666735130e-01 + z * (3.999999999940941908e-01 + z * (2.857142874366239149e-01 + z * (2.222219843214978396e-01 + z * (1.818357216161805012e-01 + z * (1.531383769920937332e-01 + z * 1.479819860511658591e-01))))));
	if (k == 0) { return f - (hfsq - s * (hfsq + R)); }
	else { return ((double)k) * 6.93147180369123816490e-01 - ((hfsq - (s * (hfsq + R) + (((double)k) * 1.90821492927058770002e-10 + c))) - f); }
}


#if LONG_DOUBLE_IS_BINARY128
LIB_FUNC long double __log1pl(const long double xm1) {
	long double x, y, z, r, s;
	ieee854_long_double_shape_type u;
	int e;
	u.value = xm1;
	int32_t hx = (int32_t)u.parts32.w0;
	if ((hx & 0x7fffffff) >= 0x7fff0000) { return xm1 + fabsl(xm1); }
	else if (((hx & 0x7fffffff) == 0) && (u.parts32.w1 | u.parts32.w2 | u.parts32.w3) == 0) { return xm1; }
	else if ((hx & 0x7fffffff) < 0x3f8e0000) {
		// math_check_force_underflow(xm1);
		if ((int) xm1 == 0) { return xm1; }
	}
	if (xm1 >= 0x1p113L) { x = xm1; }
	else { x = xm1 + 1.0L; }
	if (x <= 0.0L) {
		if (x == 0.0L) { return (-1.0L / 0.0L); }
		else { return (0.0L / (x - x)); }
	}
	x = frexpl(x, &e);
	if ((e > 2) || (e < -2)) {
		if (x < 0.7071067811865475244008443621048490392848L) {
			e -= 1;
			z = x - 0.5L;
			y = 0.5L * z + 0.5L;
		} else {
			z = x - 0.5L;
			z -= 0.5L;
			y = 0.5L * x + 0.5L;
		}
		x = z / y;
		z = x * x;
		r = ((((-8.828896441624934385266096344596648080902E-1L * z + 8.057002716646055371965756206836056074715E1L) * z + -2.024301798136027039250415126250455056397E3L) * z + 2.048819892795278657810231591630928516206E4L) * z + -8.977257995689735303686582344659576526998E4L) * z + 1.418134209872192732479751274970992665513E5L;
		s = (((((z + -1.186359407982897997337150403816839480438E2L) * z + 3.998526750980007367835804959888064681098E3L) * z + -5.748542087379434595104154610899551484314E4L) * z + 4.001557694070773974936904547424676279307E5L) * z + -1.332535117259762928288745111081235577029E6L) * z + 1.701761051846631278975701529965589676574E6L;
		z = x * (z * r / s);
		z = (z + e * 1.428606820309417232121458176568075500134E-6L) + x;
		z = z + e * 6.93145751953125E-1L;
		return (z);
	}
	if (x < 0.7071067811865475244008443621048490392848L) {
		e -= 1;
		if (e != 0) { x = 2.0L * x - 1.0L; }
		else { x = xm1; }
	} else {
		if (e != 0) { x = x - 1.0L; }
		else { x = xm1; }
	}
	z = x * x;
	r = (((((((((((1.538612243596254322971797716843006400388E-6L * x + 4.998469661968096229986658302195402690910E-1L) * x + 2.321125933898420063925789532045674660756E1L) * x + 4.114517881637811823002128927449878962058E2L) * x + 3.824952356185897735160588078446136783779E3L) * x + 2.128857716871515081352991964243375186031E4L) * x + 7.594356839258970405033155585486712125861E4L) * x + 1.797628303815655343403735250238293741397E5L) * x + 2.854829159639697837788887080758954924001E5L) * x + 3.007007295140399532324943111654767187848E5L) * x + 2.014652742082537582487669938141683759923E5L) * x + 7.771154681358524243729929227226708890930E4L) * x + 1.313572404063446165910279910527789794488E4L;
	s = (((((((((((x + 4.839208193348159620282142911143429644326E1L) * x + 9.104928120962988414618126155557301584078E2L) * x + 9.147150349299596453976674231612674085381E3L) * x + 5.605842085972455027590989944010492125825E4L) * x + 2.248234257620569139969141618556349415120E5L) * x + 6.132189329546557743179177159925690841200E5L) * x + 1.158019977462989115839826904108208787040E6L) * x + 1.514882452993549494932585972882995548426E6L) * x + 1.347518538384329112529391120390701166528E6L) * x + 7.777690340007566932935753241556479363645E5L) * x + 2.626900195321832660448791748036714883242E5L) * x + 3.940717212190338497730839731583397586124E4L;
	y = x * (z * r / s);
	y = y + e * 1.428606820309417232121458176568075500134E-6L;
	z = (y - 0.5L * z)  + x;
	z = z + e * 6.93145751953125E-1L;
	return z;
}
#endif


LIB_FUNC float __w_log1pf(const float x) {
	if (PREDICT_UNLIKELY(__islessequalf(x, -1.0F))) {
		if (x == -1.0f) { __set_errno(ERANGE); }
		else { __set_errno(EDOM); }
	}
	return __log1pf(x);
}
#define log1pf(x)   __w_log1pf((x))


LIB_FUNC double __w_log1p(const double x) {
	if (PREDICT_UNLIKELY(__islessequal(x, -1.0))) {
		if (x == -1.0) { __set_errno(ERANGE); }
		else { __set_errno(EDOM); }
	}
	return __log1p(x);
}
#define log1p(x)   __w_log1p((x))


LIB_FUNC long double __w_log1pl(const long double x) {
	if (PREDICT_UNLIKELY(__islessequall(x, -1.0L))) {
		if (x == -1.0L) { __set_errno(ERANGE); }
		else { __set_errno(EDOM); }
	}
	return __log1pl(x);
}
#define log1pl(x)   __w_log1pl((x))


LIB_FUNC float logbf(const float x) {
	if (!isfinitef(x)) { return x * x; }
	else if (x == 0) { return -1 / (x * x); }
	return (float)((uint32_t)ilogbf(x));
}


LIB_FUNC double logb(const double x) {
	if (!isfinite(x)) { return x * x; }
	else if (x == 0) { return -1 / (x * x); }
	return ilogb(x);
}


#if SUPPORTS_LONG_DOUBLE
LIB_FUNC long double logbl(const long double x) {
	return (long double)logb((double)x);
}
#endif


// TRIGONOMETRY FUNCTIONS

#if LONG_DOUBLE_IS_BINARY128
#   define pio2_hi   (long double)1.57079632679489661926L
#   define pio2_lo   (long double)-2.50827880633416601173e-20L
/** R(x^2) is a rational approximation of (asin(x)-x)/x^3 with Remez algorithm */
LIB_FUNC long double __invtrigl_R(const long double z) {
	const long double p = z * (1.66666666666666666631e-01L + z * (-4.16313987993683104320e-01L + z * (3.69068046323246813704e-01L + z * (-1.36213932016738603108e-01L + z * (1.78324189708471965733e-02L + z * (-2.19216428382605211588e-04L + z * -7.10526623669075243183e-06L))))));
	const long double q = 1.0L + z * (-2.94788392796209867269e+00L + z * (3.27309890266528636716e+00L + z * (-1.68285799854822427013e+00L + z * (3.90699412641738801874e-01L + z * -3.14365703596053263322e-02L))));
	return p / q;
}
#elif SUPPORTS_LONG_DOUBLE_128
#   define pio2_hi   (long double)1.57079632679489661923132169163975140L
#   define pio2_lo   (long double)4.33590506506189051239852201302167613e-35L
/** R(x^2) is a rational approximation of (asin(x)-x)/x^3 with Remez algorithm */
LIB_FUNC long double __invtrigl_R(const long double z) {
	const long double p = z * (1.66666666666666666666666666666700314e-01L + z * (-7.32816946414566252574527475428622708e-01L + z * (1.34215708714992334609030036562143589e+00L + z * (-1.32483151677116409805070261790752040e+00L + z * (7.61206183613632558824485341162121989e-01L + z * (-2.56165783329023486777386833928147375e-01L + z * (4.80718586374448793411019434585413855e-02L + z * (-4.42523267167024279410230886239774718e-03L + z * (1.44551535183911458253205638280410064e-04L + z * -2.10558957916600254061591040482706179e-07L)))))))));
	const long double q = 1.0L + z * (-4.84690167848739751544716485245697428e+00L + z * (9.96619113536172610135016921140206980e+00L + z * (-1.13177895428973036660836798461641458e+01L + z * (7.74004374389488266169304117714658761e+00L + z * (-3.25871986053534084709023539900339905e+00L + z * (4.80718586374448793411019434585413855e-02L + z * (-4.42523267167024279410230886239774718e-03L + z * (1.44551535183911458253205638280410064e-04L + z * -2.10558957916600254061591040482706179e-07L))))))));
	return p / q;
}
#endif


#ifdef pio2_hi
#   define __pio2_hi   pio2_hi
#   define __pio2_lo   pio2_lo
#endif


/** 53 bits of 2/pi; 0x3FE45F30, 0x6DC9C883 */
#define invpio2   6.36619772367581382433e-01
/** first 25 bits of pi/2; 0x3FF921FB, 0x50000000 */
#define pio2_1   1.57079631090164184570e+00
/** pi/2 - pio2_1; 0x3E5110b4, 0x611A6263  */
#define pio2_1t   1.58932547735281966916e-08
/** second 33 bit of pi/2; 0x3DD0B461, 0x1A600000 */
#define pio2_2   6.07710050630396597660e-11
/** pi/2 - (pio2_1+pio2_2); 0x3BA3198A, 0x2E037073 */
#define pio2_2t   2.02226624879595063154e-21
/** third 33 bit of pi/2; 0x3BA3198A, 0x2E000000 */
#define pio2_3   2.02226624871116645580e-21
/** pi/2 - (pio2_1+pio2_2+pio2_3); 0x397B839A, 0x252049C1 */
#define pio2_3t   8.47842766036889956997e-32


static const UNUSED int init_jk[4] = { 3, 4, 4, 6 };


static const UNUSED int32_t ipio2[] = {
	0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,
	0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,
	0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,
	0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,
	0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,
	0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,
	0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,
	0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,
	0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,
	0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,
	0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,
#if (LDBL_MAX_EXP > 1024)
	0x47C419, 0xC367CD, 0xDCE809, 0x2A8359, 0xC4768B, 0x961CA6,
	0xDDAF44, 0xD15719, 0x053EA5, 0xFF0705, 0x3F7E33, 0xE832C2,
	0xDE4F98, 0x327DBB, 0xC33D26, 0xEF6B1E, 0x5EF89F, 0x3A1F35,
	0xCAF27F, 0x1D87F1, 0x21907C, 0x7C246A, 0xFA6ED5, 0x772D30,
	0x433B15, 0xC614B5, 0x9D19C3, 0xC2C4AD, 0x414D2C, 0x5D000C,
	0x467D86, 0x2D71E3, 0x9AC69B, 0x006233, 0x7CD2B4, 0x97A7B4,
	0xD55537, 0xF63ED7, 0x1810A3, 0xFC764D, 0x2A9D64, 0xABD770,
	0xF87C63, 0x57B07A, 0xE71517, 0x5649C0, 0xD9D63B, 0x3884A7,
	0xCB2324, 0x778AD6, 0x23545A, 0xB91F00, 0x1B0AF1, 0xDFCE19,
	0xFF319F, 0x6A1E66, 0x615799, 0x47FBAC, 0xD87F7E, 0xB76522,
	0x89E832, 0x60BFE6, 0xCDC4EF, 0x09366C, 0xD43F5D, 0xD7DE16,
	0xDE3B58, 0x929BDE, 0x2822D2, 0xE88628, 0x4D58E2, 0x32CAC6,
	0x16E308, 0xCB7DE0, 0x50C017, 0xA71DF3, 0x5BE018, 0x34132E,
	0x621283, 0x014883, 0x5B8EF5, 0x7FB0AD, 0xF2E91E, 0x434A48,
	0xD36710, 0xD8DDAA, 0x425FAE, 0xCE616A, 0xA4280A, 0xB499D3,
	0xF2A606, 0x7F775C, 0x83C2A3, 0x883C61, 0x78738A, 0x5A8CAF,
	0xBDD76F, 0x63A62D, 0xCBBFF4, 0xEF818D, 0x67C126, 0x45CA55,
	0x36D9CA, 0xD2A828, 0x8D61C2, 0x77C912, 0x142604, 0x9B4612,
	0xC459C4, 0x44C5C8, 0x91B24D, 0xF31700, 0xAD43D4, 0xE54929,
	0x10D5FD, 0xFCBE00, 0xCC941E, 0xEECE70, 0xF53E13, 0x80F1EC,
	0xC3E7B3, 0x28F8C7, 0x940593, 0x3E71C1, 0xB3092E, 0xF3450B,
	0x9C1288, 0x7B20AB, 0x9FB52E, 0xC29247, 0x2F327B, 0x6D550C,
	0x90A772, 0x1FE76B, 0x96CB31, 0x4A1679, 0xE27941, 0x89DFF4,
	0x9794E8, 0x84E6E2, 0x973199, 0x6BED88, 0x365F5F, 0x0EFDBB,
	0xB49A48, 0x6CA467, 0x427271, 0x325D8D, 0xB8159F, 0x09E5BC,
	0x25318D, 0x3974F7, 0x1C0530, 0x010C0D, 0x68084B, 0x58EE2C,
	0x90AA47, 0x02E774, 0x24D6BD, 0xA67DF7, 0x72486E, 0xEF169F,
	0xA6948E, 0xF691B4, 0x5153D1, 0xF20ACF, 0x339820, 0x7E4BF5,
	0x6863B2, 0x5F3EDD, 0x035D40, 0x7F8985, 0x295255, 0xC06437,
	0x10D86D, 0x324832, 0x754C5B, 0xD4714E, 0x6E5445, 0xC1090B,
	0x69F52A, 0xD56614, 0x9D0727, 0x50045D, 0xDB3BB4, 0xC576EA,
	0x17F987, 0x7D6B49, 0xBA271D, 0x296996, 0xACCCC6, 0x5414AD,
	0x6AE290, 0x89D988, 0x50722C, 0xBEA404, 0x940777, 0x7030F3,
	0x27FC00, 0xA871EA, 0x49C266, 0x3DE064, 0x83DD97, 0x973FA3,
	0xFD9443, 0x8C860D, 0xDE4131, 0x9D3992, 0x8C70DD, 0xE7B717,
	0x3BDF08, 0x2B3715, 0xA0805C, 0x93805A, 0x921110, 0xD8E80F,
	0xAF806C, 0x4BFFDB, 0x0F9038, 0x761859, 0x15A562, 0xBBCB61,
	0xB989C7, 0xBD4010, 0x04F2D2, 0x277549, 0xF6B6EB, 0xBB22DB,
	0xAA140A, 0x2F2689, 0x768364, 0x333B09, 0x1A940E, 0xAA3A51,
	0xC2A31D, 0xAEEDAF, 0x12265C, 0x4DC26D, 0x9C7A2D, 0x9756C0,
	0x833F03, 0xF6F009, 0x8C402B, 0x99316D, 0x07B439, 0x15200C,
	0x5BC3D8, 0xC492F5, 0x4BADC6, 0xA5CA4E, 0xCD37A7, 0x36A9E6,
	0x9492AB, 0x6842DD, 0xDE6319, 0xEF8C76, 0x528B68, 0x37DBFC,
	0xABA1AE, 0x3115DF, 0xA1AE00, 0xDAFB0C, 0x664D64, 0xB705ED,
	0x306529, 0xBF5657, 0x3AFF47, 0xB9F96A, 0xF3BE75, 0xDF9328,
	0x3080AB, 0xF68C66, 0x15CB04, 0x0622FA, 0x1DE4D9, 0xA4B33D,
	0x8F1B57, 0x09CD36, 0xE9424E, 0xA4BE13, 0xB52333, 0x1AAAF0,
	0xA8654F, 0xA5C1D2, 0x0F3F0B, 0xCD785B, 0x76F923, 0x048B7B,
	0x721789, 0x53A6C6, 0xE26E6F, 0x00EBEF, 0x584A9B, 0xB7DAC4,
	0xBA66AA, 0xCFCF76, 0x1D02D1, 0x2DF1B1, 0xC1998C, 0x77ADC3,
	0xDA4886, 0xA05DF7, 0xF480C6, 0x2FF0AC, 0x9AECDD, 0xBC5C3F,
	0x6DDED0, 0x1FC790, 0xB6DB2A, 0x3A25A3, 0x9AAF00, 0x9353AD,
	0x0457B6, 0xB42D29, 0x7E804B, 0xA707DA, 0x0EAA76, 0xA1597B,
	0x2A1216, 0x2DB7DC, 0xFDE5FA, 0xFEDB89, 0xFDBE89, 0x6C76E4,
	0xFCA906, 0x70803E, 0x156E85, 0xFF87FD, 0x073E28, 0x336761,
	0x86182A, 0xEABD4D, 0xAFE7B3, 0x6E6D8F, 0x396795, 0x5BBF31,
	0x48D784, 0x16DF30, 0x432DC7, 0x356125, 0xCE70C9, 0xB8CB30,
	0xFD6CBF, 0xA200A4, 0xE46C05, 0xA0DD5A, 0x476F21, 0xD21262,
	0x845CB9, 0x496170, 0xE0566B, 0x015299, 0x375550, 0xB7D51E,
	0xC4F133, 0x5F6E13, 0xE4305D, 0xA92E85, 0xC3B21D, 0x3632A1,
	0xA4B708, 0xD4B1EA, 0x21F716, 0xE4698F, 0x77FF27, 0x80030C,
	0x2D408D, 0xA0CD4F, 0x99A520, 0xD3A2B3, 0x0A5D2F, 0x42F9B4,
	0xCBDA11, 0xD0BE7D, 0xC1DB9B, 0xBD17AB, 0x81A2CA, 0x5C6A08,
	0x17552E, 0x550027, 0xF0147F, 0x8607E1, 0x640B14, 0x8D4196,
	0xDEBE87, 0x2AFDDA, 0xB6256B, 0x34897B, 0xFEF305, 0x9EBFB9,
	0x4F6A68, 0xA82A4A, 0x5AC44F, 0xBCF82D, 0x985AD7, 0x95C7F4,
	0x8D4D0D, 0xA63A20, 0x5F57A4, 0xB13F14, 0x953880, 0x0120CC,
	0x86DD71, 0xB6DEC9, 0xF560BF, 0x11654D, 0x6B0701, 0xACB08C,
	0xD0C0B2, 0x485551, 0x0EFB1E, 0xC37295, 0x3B06A3, 0x3540C0,
	0x7BDC06, 0xCC45E0, 0xFA294E, 0xC8CAD6, 0x41F3E8, 0xDE647C,
	0xD8649B, 0x31BED9, 0xC397A4, 0xD45877, 0xC5E369, 0x13DAF0,
	0x3C3ABA, 0x461846, 0x5F7555, 0xF5BDD2, 0xC6926E, 0x5D2EAC,
	0xED440E, 0x423E1C, 0x87C461, 0xE9FD29, 0xF3D6E7, 0xCA7C22,
	0x35916F, 0xC5E008, 0x8DD7FF, 0xE26A6E, 0xC6FDB0, 0xC10893,
	0x745D7C, 0xB2AD6B, 0x9D6ECD, 0x7B723E, 0x6A11C6, 0xA9CFF7,
	0xDF7329, 0xBAC9B5, 0x5100B7, 0x0DB2E2, 0x24BA74, 0x607DE5,
	0x8AD874, 0x2C150D, 0x0C1881, 0x94667E, 0x162901, 0x767A9F,
	0xBEFDFD, 0xEF4556, 0x367ED9, 0x13D9EC, 0xB9BA8B, 0xFC97C4,
	0x27A831, 0xC36EF1, 0x36C594, 0x56A8D8, 0xB5A8B4, 0x0ECCCF,
	0x2D8912, 0x34576F, 0x89562C, 0xE3CE99, 0xB920D6, 0xAA5E6B,
	0x9C2A3E, 0xCC5F11, 0x4A0BFD, 0xFBF4E1, 0x6D3B8E, 0x2C86E2,
	0x84D4E9, 0xA9B4FC, 0xD1EEEF, 0xC9352E, 0x61392F, 0x442138,
	0xC8D91B, 0x0AFC81, 0x6A4AFB, 0xD81C2F, 0x84B453, 0x8C994E,
	0xCC2254, 0xDC552A, 0xD6C6C0, 0x96190B, 0xB8701A, 0x649569,
	0x605A26, 0xEE523F, 0x0F117F, 0x11B5F4, 0xF5CBFC, 0x2DBC34,
	0xEEBC34, 0xCC5DE8, 0x605EDD, 0x9B8E67, 0xEF3392, 0xB817C9,
	0x9B5861, 0xBC57E1, 0xC68351, 0x103ED8, 0x4871DD, 0xDD1C2D,
	0xA118AF, 0x462C21, 0xD7F359, 0x987AD9, 0xC0549E, 0xFA864F,
	0xFC0656, 0xAE79E5, 0x362289, 0x22AD38, 0xDC9367, 0xAAE855,
	0x382682, 0x9BE7CA, 0xA40D51, 0xB13399, 0x0ED7A9, 0x480569,
	0xF0B265, 0xA7887F, 0x974C88, 0x36D1F9, 0xB39221, 0x4A827B,
	0x21CF98, 0xDC9F40, 0x5547DC, 0x3A74E1, 0x42EB67, 0xDF9DFE,
	0x5FD45E, 0xA4677B, 0x7AACBA, 0xA2F655, 0x23882B, 0x55BA41,
	0x086E59, 0x862A21, 0x834739, 0xE6E389, 0xD49EE5, 0x40FB49,
	0xE956FF, 0xCA0F1C, 0x8A59C5, 0x2BFA94, 0xC5C1D3, 0xCFC50F,
	0xAE5ADB, 0x86C547, 0x624385, 0x3B8621, 0x94792C, 0x876110,
	0x7B4C2A, 0x1A2C80, 0x12BF43, 0x902688, 0x893C78, 0xE4C4A8,
	0x7BDBE5, 0xC23AC4, 0xEAF426, 0x8A67F7, 0xBF920D, 0x2BA365,
	0xB1933D, 0x0B7CBD, 0xDC51A4, 0x63DD27, 0xDDE169, 0x19949A,
	0x9529A8, 0x28CE68, 0xB4ED09, 0x209F44, 0xCA984E, 0x638270,
	0x237C7E, 0x32B90F, 0x8EF5A7, 0xE75614, 0x08F121, 0x2A9DB5,
	0x4D7E6F, 0x5119A5, 0xABF9B5, 0xD6DF82, 0x61DD96, 0x023616,
	0x9F3AC4, 0xA1A283, 0x6DED72, 0x7A8D39, 0xA9B882, 0x5C326B,
	0x5B2746, 0xED3400, 0x7700D2, 0x55F4FC, 0x4D5901, 0x8071E0
#endif
};


static const UNUSED double PIo2[8] = {
	1.57079625129699707031e+00,
	7.54978941586159635335e-08,
	5.39030252995776476554e-15,
	3.28200341580791294123e-22,
	1.27065575308067607349e-29,
	1.22933308981111328932e-36,
	2.73370053816464559624e-44,
	2.16741683877804819444e-51
};


LIB_FUNC int __rem_pio2_large(double* x, double* y, int e0, int nx, const int prec) {
	int32_t jz, carry, n, iq[20], i, j, k, m, q0, ih;
	double z, fw, f[20], fq[20], q[20];
	int32_t jk = init_jk[prec];
	int32_t jp = jk;
	int32_t jx = nx - 1;
	int32_t jv = (e0 - 3) / 24;
	if (jv < 0) { jv = 0; }
	q0 = e0 - 24 * (jv + 1);
	j = jv - jx;
	m = jx + jk;
	for (i = 0; i <= m; i++, j++) { f[i] = j < 0 ? 0.0 : (double)ipio2[j]; }
	for (i = 0; i <= jk; i++) {
		for (j = 0, fw = 0.0; j <= jx; j++) { fw += x[j] * f[jx + i - j]; }
		q[i] = fw;
	}
	jz = jk;
rem_pio2_large_recompute:
	for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--) {
		fw = (double)(int32_t)(0x1p-24 * z);
		iq[i] = (int32_t)(z - 0x1p24 * fw);
		z = q[j - 1] + fw;
	}
	z = scalbn(z, q0);
	z -= 8.0 * floor(z * 0.125);
	n = (int32_t)z;
	z -= (double)n;
	ih = 0;
	if (q0 > 0) {
		i = iq[jz - 1] >> (24 - q0);
		n += i;
		iq[jz - 1] -= i << (24 - q0);
		ih = iq[jz - 1] >> (23 - q0);
	}
	else if (q0 == 0) { ih = iq[jz - 1] >> 23; }
	else if (z >= 0.5) { ih = 2; }
	if (ih > 0) {
		n += 1;
		carry = 0;
		for (i = 0; i < jz; i++) {
			j = iq[i];
			if (carry == 0) {
				if (j != 0) {
					carry = 1;
					iq[i] = 0x1000000 - j;
				}
			} else { iq[i] = 0xffffff - j; }
		}
		if (q0 > 0) {
			switch (q0) {
				case 1:
					iq[jz - 1] &= 0x7fffff;
					break;
				default:  // case 2
					iq[jz - 1] &= 0x3fffff;
					break;
			}
		}
		if (ih == 2) {
			z = 1.0 - z;
			if (carry != 0) { z -= scalbn(1.0, q0); }
		}
	}
	if (z == 0.0) {
		j = 0;
		for (i = jz - 1; i >= jk; i--) { j |= iq[i]; }
		if (j == 0) {
			for (k = 1; iq[jk - k] == 0; k++);
			for (i = jz + 1; i <= jz + k; i++) {
				f[jx + i] = (double)ipio2[jv + i];
				for (j = 0, fw = 0.0; j <= jx; j++) { fw += x[j] * f[jx + i - j]; }
				q[i] = fw;
			}
			jz += k;
			goto rem_pio2_large_recompute;
		}
	}
	if (z == 0.0) {
		jz -= 1;
		q0 -= 24;
		while (iq[jz] == 0) { jz--; q0 -= 24; }
	} else {
		z = scalbn(z, -q0);
		if (z >= 0x1p24) {
			fw = (double)(int32_t)(0x1p-24 * z);
			iq[jz] = (int32_t)(z - 0x1p24 * fw);
			jz += 1;
			q0 += 24;
			iq[jz] = (int32_t)fw;
		} else { iq[jz] = (int32_t)z; }
	}
	fw = scalbn(1.0, q0);
	for (i = jz; i >= 0; i--) {
		q[i] = fw * (double)iq[i];
		fw *= 0x1p-24;
	}
	for (i = jz; i >= 0; i--) {
		for (fw = 0.0, k = 0; k <= jp && k <= jz - i; k++) { fw += PIo2[k] * q[i + k]; }
		fq[jz - i] = fw;
	}
	switch (prec) {
		case 0:
			fw = 0.0;
			for (i = jz; i >= 0; i--) { fw += fq[i]; }
			y[0] = ih == 0 ? fw : -fw;
			break;
		case 1:
		case 2:
			fw = 0.0;
			for (i = jz; i >= 0; i--) { fw += fq[i]; }
			fw = (double)fw;
			y[0] = ih == 0 ? fw : -fw;
			fw = fq[0] - fw;
			for (i = 1; i <= jz; i++) { fw += fq[i]; }
			y[1] = ih == 0 ? fw : -fw;
			break;
		default:  // case 3
			for (i = jz; i > 0; i--) {
				fw = fq[i - 1] + fq[i];
				fq[i] += fq[i - 1] - fw;
				fq[i - 1] = fw;
			}
			for (i = jz; i > 1; i--) {
				fw = fq[i - 1] + fq[i];
				fq[i] += fq[i - 1] - fw;
				fq[i - 1] = fw;
			}
			for (fw = 0.0, i = jz; i >= 2; i--) { fw += fq[i]; }
			if (ih == 0) {
				y[0] = fq[0];
				y[1] = fq[1];
				y[2] = fw;
			} else {
				y[0] = -fq[0];
				y[1] = -fq[1];
				y[2] = -fw;
			}
	}
	return n & 7;
}
#define __ieee754_rem_pio2_large(x, y, e0, nx, prec)   __rem_pio2_large((x), (y), (e0), (nx), (prec))


/** Return the remainder of x rem pi/2 in *y */
LIB_FUNC int __rem_pio2f(const float x, double* y) {
	union { float f; uint32_t i; } u = { x };
	double tx[1], ty[1];
	int32_t n;
	const uint32_t ix = u.i & 0x7fffffff;
	if (ix < 0x4dc90fdb) {
		const double fn = (double)((double)x * invpio2 + (double)(1.5 / EPS) - (double)(1.5 / EPS));
		n = (int32_t)fn;
		*y = ((double)x) - (double)(fn * pio2_1) - (double)(fn * pio2_1t);
		return n;
	} else if (ix >= 0x7f800000) {
		*y = x - x;
		return 0;
	}
	const int sign = (int)(u.i >> 31);
	const int e0 = (int)((ix >> 23) - (0x7f + 23));
	u.i = (unsigned int)(ix - (uint32_t)(e0 << 23));
	tx[0] = u.f;
	n = __rem_pio2_large(tx, ty, e0, 1, 0);
	if (sign) {
		*y = -ty[0];
		return -n;
	}
	*y = ty[0];
	return n;
}
#define __ieee754_rem_pio2f(x, y)   __rem_pio2f((x), (y))


LIB_FUNC int __rem_pio2(const double x, double* y) {
	union { double f; uint64_t i; } u = { x };
	double z, w, t, r, fn, tx[3], ty[2];
	int n, ex, ey, i;
	const int sign = (int)(u.i >> 63);
	const uint32_t ix = (uint32_t)(u.i >> 32 & 0x7fffffff);
	if (ix <= 0x400f6a7a) {
		if ((ix & 0xfffff) == 0x921fb) { goto __rem_pio2_medium; }
		else if (ix <= 0x4002d97c) {
			if (!sign) {
				z = x - pio2_1;
				y[0] = z - pio2_1t;
				y[1] = (z - y[0]) - pio2_1t;
				return 1;
			} else {
				z = x + pio2_1;
				y[0] = z + pio2_1t;
				y[1] = (z - y[0]) + pio2_1t;
				return -1;
			}
		} else {
			if (!sign) {
				z = x - 2 * pio2_1;
				y[0] = z - 2 * pio2_1t;
				y[1] = (z - y[0]) - 2 * pio2_1t;
				return 2;
			} else {
				z = x + 2 * pio2_1;
				y[0] = z + 2 * pio2_1t;
				y[1] = (z - y[0]) + 2 * pio2_1t;
				return -2;
			}
		}
	}
	if (ix <= 0x401c463b) {
		if (ix <= 0x4015fdbc) {
			if (ix == 0x4012d97c) { goto __rem_pio2_medium; }
			else if (!sign) {
				z = x - 3 * pio2_1;
				y[0] = z - 3 * pio2_1t;
				y[1] = (z - y[0]) - 3 * pio2_1t;
				return 3;
			} else {
				z = x + 3 * pio2_1;
				y[0] = z + 3 * pio2_1t;
				y[1] = (z - y[0]) + 3 * pio2_1t;
				return -3;
			}
		} else {
			if (ix == 0x401921fb) { goto __rem_pio2_medium; }
			else if (!sign) {
				z = x - 4 * pio2_1;
				y[0] = z - 4 * pio2_1t;
				y[1] = (z - y[0]) - 4 * pio2_1t;
				return 4;
			} else {
				z = x + 4 * pio2_1;
				y[0] = z + 4 * pio2_1t;
				y[1] = (z - y[0]) + 4 * pio2_1t;
				return -4;
			}
		}
	}
	if (ix < 0x413921fb) {
__rem_pio2_medium:
		fn = (double)x * invpio2 + (double)(1.5 / EPS) - (double)(1.5 / EPS);
		n = (int32_t)fn;
		r = x - fn * pio2_1;
		w = fn * pio2_1t;
		y[0] = r - w;
		u.f = y[0];
		ey = u.i >> 52 & 0x7ff;
		ex = (int)(ix >> 20);
		if (ex - ey > 16) {
			t = r;
			w = fn * pio2_2;
			r = t - w;
			w = fn * pio2_2t - ((t - r) - w);
			y[0] = r - w;
			u.f = y[0];
			ey = u.i >> 52 & 0x7ff;
			if (ex - ey > 49) {
				t = r;
				w = fn * pio2_3;
				r = t - w;
				w = fn * pio2_3t - ((t - r) - w);
				y[0] = r - w;
			}
		}
		y[1] = (r - y[0]) - w;
		return n;
	}
	if (ix >= 0x7ff00000) {  // x is inf or NaN
		y[0] = y[1] = x - x;
		return 0;
	}
	u.f = x;
	u.i &= (uint64_t)-1 >> 12;
	u.i |= (uint64_t)1046 << 52;
	z = u.f;
	for (i = 0; i < 2; i++) {
		tx[i] = (double)((int32_t)z);
		z = (z - tx[i]) * 0x1p24;
	}
	tx[i] = (double)z;
	while (tx[i] == 0.0) { i--; }
	n = __rem_pio2_large(tx, ty, ((int)(ix >> 20) - (0x3ff + 23)), (i + 1), 1);
	if (sign) {
		y[0] = -ty[0];
		y[1] = -ty[1];
		return -n;
	}
	y[0] = ty[0];
	y[1] = ty[1];
	return n;
}
#define __ieee754_rem_pio2(x, y)   __rem_pio2((x), (y))


#if LONG_DOUBLE_IS_X87_EXTENDED


LIB_FUNC int __rem_pio2l(const long double x, long double* y) {
	union ldshape u, uz;
	long double z, w, t, r, fn;
	double tx[3], ty[2];
	int ex, ey, n, i;
	u.f = x;
	ex = u.i.se & 0x7fff;
	if (((((u.i.se & 0x7fffU) << 16) | (u.i.m >> 48)) < (((0x3fff + 25) << 16) | (0x921f >> 1) | 0x8000))) {
		fn = x * (long double)6.36619772367581343076e-01L + (long double)(1.5 / LDBL_EPSILON) - (long double)(1.5 / LDBL_EPSILON);
		n = (int)((int32_t)fn & 0x7fffffff);
		r = x - fn * (long double)1.5707963267948966192292994253909555e+00L;
		w = fn * (long double)-1.07463465549719416346e-12L;
		y[0] = r - w;
		u.f = y[0];
		ey = u.i.se & 0x7fff;
		if (ex - ey > 22) {
			t = r;
			w = fn * (long double)2.0222662487959507323994779168837751e-21L;
			r = t - w;
			w = fn * (long double)6.36831716351095013979e-25L - ((t - r) - w);
			y[0] = r - w;
			u.f = y[0];
			ey = u.i.se & 0x7fff;
			if (ex - ey > 61) {
				t = r;
				w = fn * (long double)2.0670321098263988236499468110329591e-43L;
				r = t - w;
				w = fn * (long double)-2.75299651904407171810e-37L - ((t - r) - w);
				y[0] = r - w;
			}
		}
		y[1] = (r - y[0]) - w;
		return n;
	} else if (ex == 0x7fff) { // x is inf or NaN
		y[0] = y[1] = x - x;
		return 0;
	}
	uz.f = x;
	uz.i.se = 0x3fff + 23;
	z = uz.f;
	for (i = 0; i < 3 - 1; i++) {
		tx[i] = (double)((int32_t)z);
		z = (z - tx[i]) * 0x1p24;
	}
	tx[i] = (double)z;
	while (tx[i] == 0) { --i; }
	n = __rem_pio2_large(tx, ty, (ex - 0x3fff - 23), (i + 1), 2);
	w = ty[1];
	r = ty[0] + w;
	w -= r - ty[0];
	if (u.i.se >> 15) {
		y[0] = -r;
		y[1] = -w;
		return -n;
	}
	y[0] = r;
	y[1] = w;
	return n;
}
#define __ieee754_rem_pio2l(x, y)   __rem_pio2l((x), (y))


#elif SUPPORTS_LONG_DOUBLE_128


LIB_FUNC int __rem_pio2l(const long double x, long double* y) {
	union ldshape u, uz;
	long double z, w, t, r, fn;
	double tx[5], ty[3];
	int ex, ey, n, i;
	u.f = x;
	ex = u.i.se & 0x7fff;
	if ((((u.i.se & 0x7fffU) << 16 | u.i.top) < ((0x3fff + 45) << 16 | 0x921f))) {
		fn = x * (long double)6.3661977236758134307553505349005747e-01L + (long double)(1.5 / LDBL_EPSILON) - (long double)(1.5 / LDBL_EPSILON);
		n = (int)((int64_t)fn & 0x7fffffff);
		r = x - fn * (long double)1.5707963267948966192292994253909555e+00L;
		w = fn * (long double)2.0222662487959507323996846200947577e-21L;
		y[0] = r - w;
		u.f = y[0];
		ey = u.i.se & 0x7fff;
		if (ex - ey > 51) {
			t = r;
			w = fn * (long double)2.0222662487959507323994779168837751e-21L;
			r = t - w;
			w = fn * (long double)2.0670321098263988236496903051604844e-43L - ((t - r) - w);
			y[0] = r - w;
			u.f = y[0];
			ey = u.i.se & 0x7fff;
			if (ex - ey > 119) {
				t = r;
				w = fn * (long double)2.0670321098263988236499468110329591e-43L;
				r = t - w;
				w = fn * (long double)-2.5650587247459238361625433492959285e-65L - ((t - r) - w);
				y[0] = r - w;
			}
		}
		y[1] = (r - y[0]) - w;
		return n;
	} else if (ex == 0x7fff) { // x is inf or NaN
		y[0] = y[1] = x - x;
		return 0;
	}
	uz.f = x;
	uz.i.se = 0x3fff + 23;
	z = uz.f;
	for (i = 0; i < 5 - 1; i++) {
		tx[i] = (double)((int32_t)z);
		z = (z - tx[i]) * 0x1p24;
	}
	tx[i] = (double)z;
	while (tx[i] == 0) { --i; }
	n = __rem_pio2_large(tx, ty, (ex - 0x3fff - 23), (i + 1), 3);
	w = ty[1] + ty[2];
	r = ty[0] + w;
	w -= r - ty[0];
	if (u.i.se >> 15) {
		y[0] = -r;
		y[1] = -w;
		return -n;
	}
	y[0] = r;
	y[1] = w;
	return n;
}
#define __ieee754_rem_pio2l(x, y)   __rem_pio2l((x), (y))


#endif


LIB_FUNC float __kernel_cosf(const float x, const float y) {
	float z, r;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix < 0x32000000 && (((int)x) == 0)) { return 1.0F; }
	z = x * x;
	r = z * (4.1666667908e-02F + z * (-1.3888889225e-03F + z * (2.4801587642e-05F + z * (-2.7557314297e-07F + z * (2.0875723372e-09F + z * -1.1359647598e-11F)))));
	float qx;
	if (ix < 0x3e99999a) { return 1.0F - ((float)0.5F * z - (z * r - x * y)); }
	else {
		if (ix > 0x3f480000) { qx = (float)0.28125F; }
		else { SET_FLOAT_WORD(qx, ix - 0x01000000); }
		register float hz = (float)(0.5F * z - qx);
		return (float)((1.0F - qx) - (hz - (z * r - x * y)));
	}
}


LIB_FUNC double __kernel_cos(const double x, const double y) {
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix < 0x3e400000 && (((int)x) == 0)) { return 1.0; }
	const double z = x * x;
	const double r = z * (4.16666666666666019037e-02 + z * (-1.38888888888741095749e-03 + z * (2.48015872894767294178e-05 + z * (-2.75573143513906633035e-07 + z * (2.08757232129817482790e-09 + z * -1.13596475577881948265e-11)))));
	double qx;
	if (ix < 0x3FD33333)
	{ return 1.0 - (0.5 * z - (z * r - x * y)); }
	else {
		if (ix > 0x3fe90000) { qx = 0.28125; }
		else { INSERT_WORDS(qx, (uint32_t)(ix - 0x200000), 0); }
		register double hz = 0.5 * z - qx;
		return (double)((1.0 - qx) - (hz - (z * r - x * y)));
	}
}


LIB_FUNC float __kernel_sinf(const float x, const float y, const int iy) {
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix < 0x32000000 && ((int)x == 0)) { return x; }
	const float z = x * x;
	const float v = z * x;
	const float r = 8.3333337680e-03F + z * (-1.9841270114e-04F + z * (2.7557314297e-06F + z * (-2.5050759689e-08F + z * 1.5896910177e-10F)));
	if (iy == 0) { return x + v * (-1.6666667163e-01F + z * r); }
	else { return x - ((z * (5.0000000000e-01F * y - v * r) - y) - v * -1.6666667163e-01F); }
}


LIB_FUNC double __kernel_sin(const double x, const double y, const int iy) {
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix < 0x3e400000 && ((int)x == 0)) { return x; }
	const double z = x * x;
	const double v = z * x;
	const double r = 8.33333333332248946124e-03 + z * (-1.98412698298579493134e-04 + z * (2.75573137070700676789e-06 + z * (-2.50507602534068634195e-08 + z * 1.58969099521155010221e-10)));
	if (iy == 0) { return x + v * (-1.66666666666666324348e-01 + z * r); }
	else { return x - ((z * (5.0e-01 * y - v * r) - y) - v * -1.66666666666666324348e-01); }
}


LIB_FUNC float __kernel_tanf(const float numx, const float numy, const int iy) {
	float z, r, v, w, s, x = numx, y = numy;
	int32_t ix, hx;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix < 0x31800000 && ((int)x == 0)) {
		if ((ix | (iy + 1)) == 0) { return 1.0F / fabsf(x); }
		else { return ((iy == 1) ? x : (-1.0F / x)); }
	} else if (ix >= 0x3f2ca140) {
		if (hx < 0) { x = -x; y = -y; }
		z = 7.8539812565e-01F - x;
		w = 3.7748947079e-08F - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	w = z * z;
	static const float T[16] = {
		3.3333334327e-01F, 1.3333334029e-01F, 5.3968254477e-02F,
		2.1869488060e-02F, 8.8632395491e-03F, 3.5920790397e-03F,
		1.4562094584e-03F, 5.8804126456e-04F, 2.4646313977e-04F,
		7.8179444245e-05F, 7.1407252108e-05F, -1.8558637748e-05F,
		2.5907305826e-05F
	};
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] + w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] + w * T[12])))));
	s = z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if (ix >= 0x3f2ca140) {
		v = (float)iy;
		return (float)(1 - ((hx >> 30) & 2)) * (v - (float)2.0F * (x - (w * w / (w + v) - r)));
	}
	if (iy == 1) { return w; }
	else {
		int32_t i;
		z = w;
		GET_FLOAT_WORD(i, z);
		SET_FLOAT_WORD(z, (i & (int32_t)0xfffff000));
		v = r - (z - x);
		float t = -1.0F / w;
		const float a = t;
		GET_FLOAT_WORD(i, t);
		SET_FLOAT_WORD(t, (i & (int32_t)0xfffff000));
		return (t + a * ((1.0F + t * z) + t * v));
	}
}


LIB_FUNC double __kernel_tan(const double numx, const double numy, const int iy) {
	double z, r, v, w, s, x = numx, y = numy;
	int32_t ix, hx;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix < 0x3e300000 && ((int)x == 0)) {
		uint32_t low;
		GET_LOW_WORD(low, x);
		if (((ix | (int32_t)low) | (int32_t)(iy + 1)) == 0) { return 1.0 / fabs(x); }
		else { return ((iy == 1) ? x : (-1.0 / x)); }
	} else if (ix >= 0x3FE59428) {
		if (hx < 0) { x = -x; y = -y; }
		z = 7.85398163397448278999e-01 - x;
		w = 3.06161699786838301793e-17 - y;
		x = z + w;
		y = 0.0;
	}
	z	= x * x;
	w 	= z * z;
	static const double T[16] = {
		3.33333333333334091986e-01, 1.33333333333201242699e-01, 5.39682539762260521377e-02,
		2.18694882948595424599e-02, 8.86323982359930005737e-03, 3.59207910759131235356e-03,
		1.45620945432529025516e-03, 5.88041240820264096874e-04, 2.46463134818469906812e-04,
		7.81794442939557092300e-05, 7.14072491382608190305e-05, -1.85586374855275456654e-05,
		2.59073051863633712884e-05
	};
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] + w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] + w * T[12])))));
	s = z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if (ix >= 0x3FE59428) {
		v = (double)iy;
		return (double)(1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));
	} else if (iy == 1) { return w; }
	else {
		double a, t;
		z = w;
		SET_LOW_WORD(z, 0);
		v = r - (z - x);
		t = a = -1.0 / w;
		SET_LOW_WORD(t, 0);
		return t + a * ((1.0 + t * z) + t * v);
	}
}


#if (SIZEOF_LONG_DOUBLE == 96)


const long double __sincosl_table[] = {
	0xf.d2f5320e1b7902100p-4L, -0x6.4b225d06708635580p-68L,
	0x2.5dc50bc95711d0d80p-4L, 0x1.787d108fd438cf5a0p-68L,
	0xf.ce1a053e621438b00p-4L, 0x6.d60c76e8c45bf0a80p-68L,
	0x2.7d66258bacd96a400p-4L, -0x1.4cca4c9a3782a6bc0p-68L,
	0xf.c8ffa01ba68074100p-4L, 0x7.e05962b0d9fdf2000p-68L,
	0x2.9cfd49b8be4f66540p-4L, -0x1.89354fe340fbd96c0p-68L,
	0xf.c3a6170f767ac7300p-4L, 0x5.d63d99a9d439e1d80p-68L,
	0x2.bc89f9f424de54840p-4L, 0x1.de7ce03b2514952c0p-68L,
	0xf.be0d7f7fef11e7100p-4L, -0x5.5bc47540b095ba800p-68L,
	0x2.dc0bb80b49a97ffc0p-4L, -0xc.b1722e07246208500p-72L,
	0xf.b835efcf670dd2d00p-4L, -0x1.90186db968115ec20p-68L,
	0x2.fb8205f75e56a2b40p-4L, 0x1.6a1c4792f85625880p-68L,
	0xf.b21f7f5c156696b00p-4L, 0xa.c1fe28ac5fd766700p-76L,
	0x3.1aec65df552876f80p-4L, 0x2.ece9a235671324700p-72L,
	0xf.abca467fb3cb8f200p-4L, -0x2.f960fe2715cc521c0p-68L,
	0x3.3a4a5a19d86246700p-4L, 0x1.0f602c44df4fa5140p-68L,
	0xf.a5365e8f1d3ca2800p-4L, -0x4.1e24a289519b26800p-68L,
	0x3.599b652f40ec999c0p-4L, 0x1.f12a0a4c8561de160p-68L,
	0xf.9e63e1d9e8b6f6f00p-4L, 0x2.e296bae5b5ed9c100p-68L,
	0x3.78df09db8c332ce00p-4L, 0xd.2b53d865582e45200p-72L,
	0xf.9752eba9fff6b9900p-4L, -0x7.bd415254fab56cd00p-68L,
	0x3.9814cb10513453cc0p-4L, -0x6.84de43e3595cc8500p-72L,
	0xf.90039843324f9b900p-4L, 0x4.0416c1984b6cbed00p-68L,
	0x3.b73c2bf6b4b9f6680p-4L, 0xe.f9499c81f0d965100p-72L,
	0xf.887604e2c39dbb200p-4L, 0xe.4ec5825059a78a000p-72L,
	0x3.d654aff15cb457a00p-4L, 0xf.ca854698aba330400p-72L,
	0xf.80aa4fbef750ba800p-4L, -0x7.c2cc346a06b075c00p-68L,
	0x3.f55dda9e62aed7500p-4L, 0x1.3bd7b8e6a3d1635e0p-68L,
	0xf.78a098069792dab00p-4L, -0x4.3611bda6e483a5980p-68L,
	0x4.14572fd94556e6480p-4L, -0xc.29dfd8ec7722b8400p-72L,
	0xf.7058fde0788dfc800p-4L, 0x5.b8fe88789e4f42500p-72L,
	0x4.334033bcd90d66080p-4L, -0x3.0a0c93e2b47bbae40p-68L,
	0xf.67d3a26af7d07aa00p-4L, 0x4.bd6d42af8c0068000p-68L,
	0x4.52186aa5377ab2080p-4L, 0x3.bf2524f52e3a06a80p-68L,
	0xf.5f10a7bb77d3dfa00p-4L, 0xc.1da8b578427832800p-72L,
	0x4.70df5931ae1d94600p-4L, 0x7.6fe0dcff47fe31b80p-72L,
	0xf.561030ddd7a789600p-4L, 0xe.a9f4a32c652155500p-72L,
	0x4.8f948446abcd6b100p-4L, -0x8.0334eff185e4d9100p-72L,
	0xf.4cd261d3e6c15bb00p-4L, 0x3.69c8758630d2ac000p-68L,
	0x4.ae37710fad27c8a80p-4L, 0x2.9c4cf96c03519b9c0p-68L,
	0xf.43575f94d4f6b2700p-4L, 0x2.f5fb76b14d2a64ac0p-68L,
	0x4.ccc7a50127e1de100p-4L, -0x3.494bf3cfd39ae0840p-68L,
	0xf.399f500c9e9fd3800p-4L, -0x5.166a8d9c254778900p-68L,
	0x4.eb44a5da74f600200p-4L, 0x7.aaa090f0734e28880p-72L,
	0xf.2faa5a1b74e82fd00p-4L, 0x6.1fa05f9177380e900p-68L,
	0x5.09adf9a7b9a5a0f80p-4L, -0x1.c75705c59f5e66be0p-68L,
	0xf.2578a595224dd2e00p-4L, 0x6.bfa2eb2f99cc67500p-68L,
	0x5.280326c3cf4818200p-4L, 0x3.ba6bb08eac82c2080p-68L,
	0xf.1b0a5b406b526d900p-4L, -0x7.93aa0152372f23380p-68L,
	0x5.4643b3da29de9b380p-4L, -0x2.8eaa110f0ccd04c00p-68L,
	0xf.105fa4d66b607a600p-4L, 0x7.d44e0427252044380p-68L,
	0x5.646f27e8bd65cbe00p-4L, 0x3.a5d61ff0657229100p-68L,
	0xf.0578ad01ede708000p-4L, -0x5.c63f6239467b50100p-68L,
	0x5.82850a41e1dd46c80p-4L, -0x9.fd15dbb3244403200p-76L,
	0xe.fa559f5ec3aec3a00p-4L, 0x4.eb03319278a2d4200p-68L,
	0x5.a084e28e35fda2780p-4L, -0x9.202444aace28b3100p-72L,
	0xe.eef6a879146af0c00p-4L, -0x6.46a15d15f53f2c200p-72L,
	0x5.be6e38ce809554280p-4L, 0x3.c14ee9da0d3648400p-68L,
	0xe.e35bf5ccac8905300p-4L, -0x3.26e2248cb2c5b81c0p-68L,
	0x5.dc40955d9084f4880p-4L, 0x2.94675a2498de5d840p-68L,
	0xe.d785b5c44741b4500p-4L, -0x6.c3a943462cc75eb00p-68L,
	0x5.f9fb80f21b5364a00p-4L, -0x3.bcdabf5af1dd3ad00p-68L,
	0xe.cb7417b8d4ee3ff00p-4L, -0x3.c8545bf8c55b70e00p-68L,
	0x6.179e84a09a5258a80p-4L, -0x3.f164a0531fc1ada00p-68L,
	0xe.bf274bf0bda4f6200p-4L, 0x4.47e56a09362679900p-68L,
	0x6.352929dd264bd4480p-4L, 0x2.02ea766325d8aa8c0p-68L,
	0xe.b29f839f201fd1400p-4L, -0x4.6c8697d86e9587100p-68L,
	0x6.529afa7d51b129600p-4L, 0x3.1ec197c0a840a11c0p-68L,
	0xe.a5dcf0e30cf03e700p-4L, -0x6.8910f4e13d9aea080p-68L,
	0x6.6ff380ba014410a00p-4L, -0x1.c65cdf4f5c05a02a0p-68L,
	0xe.98dfc6c6be031e600p-4L, 0xd.d3089cbdd18a75b00p-72L,
	0x6.8d324731433279700p-4L, 0x3.bc712bcc4ccddc480p-68L,
	0xe.8ba8393eca7821b00p-4L, -0x5.a9c27cb6e49efee80p-68L,
	0x6.aa56d8e8249db4e80p-4L, 0x3.60a761fe3f9e559c0p-68L,
	0xe.7e367d2956cfb1700p-4L, -0x4.955ee1abe632ffa80p-68L,
	0x6.c760c14c8585a5200p-4L, -0x2.42cb99f5193ad5380p-68L,
	0xe.708ac84d4172a3e00p-4L, 0x2.737662213429e1400p-68L,
	0x6.e44f8c36eb10a1c80p-4L, -0xa.d2f6c3ff0b2b84600p-72L,
	0xe.62a551594b970a700p-4L, 0x7.0b15d41d4c0e48400p-68L,
	0x7.0122c5ec5028c8d00p-4L, -0xc.c540b02cbf333c800p-76L,
	0xe.54864fe33e8575d00p-4L, -0x5.40a42f1a30e4e5780p-68L,
	0x7.1dd9fb1ff46778500p-4L, 0x3.acb970a9f6729c700p-68L,
	0xe.462dfc670d421ab00p-4L, 0x3.d1a15901228f146c0p-68L,
	0x7.3a74b8f52947b6800p-4L, 0x1.baf6928eb3fb02180p-68L,
	0xe.379c9045f29d51800p-4L, -0x3.b7f755b683dfa84c0p-68L,
	0x7.56f28d011d9852880p-4L, 0x2.44a75fc29c779bd80p-68L,
	0xe.28d245c58baef7200p-4L, 0x2.25e232abc003c4380p-68L,
	0x7.7353054ca72690d80p-4L, -0x3.391e8e0266194c600p-68L,
	0xe.19cf580eeec046b00p-4L, -0x5.ebdd058b7f8131080p-68L,
	0x7.8f95b0560a9a3bd80p-4L, -0x1.2084267e23c739ee0p-68L,
	0xe.0a94032dbea7cee00p-4L, -0x4.222625d0505267a80p-68L,
	0x7.abba1d12c17bfa200p-4L, -0x2.6d0f26c09f2126680p-68L,
	0xd.fb20840f3a9b36f00p-4L, 0x7.ae2c515342890b600p-68L,
	0x7.c7bfdaf13e5ed1700p-4L, 0x2.12f8a7525bfb113c0p-68L,
	0xd.eb7518814a7a93200p-4L, -0x4.433773ef632be3b00p-68L,
	0x7.e3a679daaf25c6780p-4L, -0x1.abd434bfd72f69be0p-68L,
	0xd.db91ff31879917300p-4L, -0x4.2dbad2f5c7760ae80p-68L,
	0x7.ff6d8a34bd5e8fa80p-4L, -0x2.b368b7d24aea62100p-68L,
	0xd.cb7777ac420705100p-4L, 0x6.8f31e3eb780ce9c80p-68L,
	0x8.1b149ce34caa5a500p-4L, -0x1.9af072f602b295580p-68L,
	0xd.bb25c25b8260c1500p-4L, -0x9.1843671366e48f400p-72L,
	0x8.369b434a372da7f00p-4L, -0x4.a3758e01c931e1f80p-68L,
	0xd.aa9d2086082706400p-4L, -0x2.1ae3f617aa166cd00p-72L,
	0x8.52010f4f080052100p-4L, 0x3.78bd8dd614753d080p-68L,
	0xd.99ddd44e44a43d500p-4L, -0x2.b5c5c126adfbef900p-68L,
	0x8.6d45935ab396cb500p-4L, -0x1.bde17dd211ab0caa0p-68L,
	0xd.88e820b1526311e00p-4L, -0x2.a9e1043f3e565ac80p-68L,
	0x8.8868625b4e1dbb200p-4L, 0x3.13310133022527200p-68L,
	0xd.77bc4985e93a60800p-4L, -0x3.6279746f944394400p-68L,
	0x8.a3690fc5bfc11c000p-4L, -0x6.aca1d8c657aed0b80p-68L,
	0xd.665a937b4ef2b1f00p-4L, 0x6.d51bad6d988a44180p-68L,
	0x8.be472f9776d809b00p-4L, -0xd.477e8edbc29c29900p-72L,
	0xd.54c3441844897fd00p-4L, -0x7.07ac0f9aa0e459680p-68L,
	0x8.d902565817ee78400p-4L, -0x6.431c32ed7f9fee680p-68L,
	0xd.42f6a1b9f0168ce00p-4L, -0xf.ce3d09c3726cfb200p-72L,
	0x8.f39a191b2ba612300p-4L, -0x5.c05b0be2a5c002c00p-68L,
	0xd.30f4f392c357ab000p-4L, 0x6.61c5fa8a7d9b26600p-68L,
	0x9.0e0e0d81ca6787900p-4L, 0x6.cc92c8ea8c2815c00p-68L,
	0xd.1ebe81a95ee752e00p-4L, 0x4.8a26bcd32d6e92300p-68L,
	0x9.285dc9bc45dd9ea00p-4L, 0x3.d02457bcce59c4180p-68L,
	0xd.0c5394d7722281900p-4L, 0x5.e25736c0357470800p-68L,
	0x9.4288e48bd0335fc00p-4L, 0x4.1c4cbd2920497a900p-68L,
	0xc.f9b476c897c25c600p-4L, -0x4.018af22c0cf715080p-68L,
	0x9.5c8ef544210ec0c00p-4L, -0x6.e3b642d55f617ae80p-68L,
	0xc.e6e171f92f2e27f00p-4L, 0x3.2225327ec440ddb00p-68L,
	0x9.766f93cd18413a700p-4L, -0x5.503e303903d754480p-68L,
	0xc.d3dad1b5328a2e400p-4L, 0x5.9f993f4f510881a00p-68L,
	0x9.902a58a45e27bed00p-4L, 0x6.8412b426b675ed500p-68L,
	0xc.c0a0e21709883a400p-4L, -0xf.f6ee1ee5f811c4300p-76L,
	0x9.a9bedcdf01b38da00p-4L, -0x6.c0c287df87e21d700p-68L,
	0xc.ad33f00658fe5e800p-4L, 0x2.04bbc0f3a66a0e6c0p-68L,
	0x9.c32cba2b14156ef00p-4L, 0x5.256c4f857991ca680p-72L,
	0xc.99944936cf48c8900p-4L, 0x1.1ff93fe64b3ddb7a0p-68L,
	0x9.dc738ad14204e6900p-4L, -0x6.53a7d2f07a7d9a700p-68L,
	0xc.85c23c26ed7b6f000p-4L, 0x1.4ef546c4792968220p-68L,
	0x9.f592e9b66a9cf9000p-4L, 0x6.a3c7aa3c101998480p-68L,
	0xc.71be181ecd6875d00p-4L, -0x1.d25a9ea5fc335df80p-68L,
	0xa.0e8a725d33c828c00p-4L, 0x1.1fa50fd9e9a15ffe0p-68L,
	0xc.5d882d2ee48030c00p-4L, 0x7.c07d28e981e348080p-68L,
	0xa.2759c0e79c3558200p-4L, 0x5.27c32b55f5405c180p-68L,
	0xc.4920cc2ec38fb8900p-4L, 0x1.b38827db08884fc60p-68L,
	0xa.400072188acf49d00p-4L, -0x2.94e8c7da1fc7cb900p-68L,
	0xc.348846bbd36313400p-4L, -0x7.001d401622ec7e600p-68L,
	0xa.587e23555bb080800p-4L, 0x6.d02b9c662cdd29300p-68L,
	0xc.1fbeef380e4ffdd00p-4L, 0x5.a613ec8722f644000p-68L,
	0xa.70d272a76a8d4b700p-4L, -0x2.5f136f8ed448b7480p-68L,
	0xc.0ac518c8b6ae71100p-4L, -0x4.5c85c1146f34ea500p-68L,
	0xa.88fcfebd9a8dd4800p-4L, -0x1.d0c3891061dbc66e0p-68L,
	0xb.f59b17550a4406800p-4L, 0x7.5969296567cf3e380p-68L,
	0xa.a0fd66eddb9212300p-4L, 0x2.c28520d3911b8a040p-68L,
	0xb.e0413f84f2a771c00p-4L, 0x6.14946a88cbf4da200p-68L,
	0xa.b8d34b36acd987200p-4L, 0x1.0ed343ec65d7e3ae0p-68L,
	0xb.cab7e6bfb2a14aa00p-4L, -0x4.edd3a8b5c89413680p-68L,
	0xa.d07e4c409d08c5000p-4L, -0x5.c56fa844f53db4780p-68L,
	0xb.b4ff632a908f73f00p-4L, -0x3.eae7c6346266c4b00p-68L,
	0xa.e7fe0b5fc786b2e00p-4L, -0x6.991e2950ebf5b7780p-68L,
	0xb.9f180ba77dd075100p-4L, 0x6.28e135a9508299000p-68L,
	0xa.ff522a954f2ba1700p-4L, -0x2.621023be91cc0a180p-68L,
	0xb.890237d3bb3c28500p-4L, -0x4.9eb5fac6fe9405f00p-68L,
	0xb.167a4c90d63c42400p-4L, 0x4.cf5493b7cc23bd400p-68L,
	0xb.72be40067aaf2c000p-4L, 0x5.0dbdb7a14c3d7d500p-68L,
	0xb.2d7614b1f3aaa2500p-4L, -0x2.0d291df5881e35c00p-68L,
	0xb.5c4c7d4f7dae91600p-4L, -0x5.3879330b4e5b67300p-68L,
	0xb.44452709a59752900p-4L, 0x5.913765434a59d1100p-72L,
	0xb.45ad4975b1294cb00p-4L, -0x2.35b30bf1370dd5980p-68L,
	0xb.5ae7285bc10cf5100p-4L, 0x5.753847e8f8b7a3100p-68L
};


LIB_FUNC long double __kernel_cosl(const long double numx, const long double numy) {
	long double h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int index;
	if (signbitl(x)) {
		x = -x;
		y = -y;
	}
	if (x < 0.1484375L) {
		if (x < 0x1p-33L && (!((int)x))) { return 1.00000000000000000000000000000000000E+00L; }
		z = x * x;
		return 1.00000000000000000000000000000000000E+00L + (z * (-4.99999999999999999999999999999999759E-01L + z * (4.16666666666666666666666666651287795E-02L + z * (-1.38888888888888888888888742314300284E-03L + z * (2.48015873015873015867694002851118210E-05L + z * (-2.75573192239858811636614709689300351E-07L + z * (2.08767569877762248667431926878073669E-09L + z * (-1.14707451049343817400420280514614892E-11L + z * 4.77810092804389587579843296923533297E-14L))))))));
	} else {
		index = (int)(128 * (x - (0.1484375L - 1.0L / 256.0L)));
		h = 0.1484375L + index / 128.0;
		index *= 4;
		l = y - (h - x);
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		return __sincosl_table[index + 0] + (__sincosl_table[index + 1] - (__sincosl_table[index + 2] * sin_l - __sincosl_table[index + 0] * cos_l_m1));
	}
}


LIB_FUNC long double __kernel_sinl(const long double numx, const long double numy, int iy) {
	long double absx, h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int index;
	absx = fabsl(x);
	if (absx < 0.1484375L) {
		if (absx < 0x1p-33L) {
			// math_check_force_underflow(x);
			if (!((int)x)) { return x; }
		}
		z = x * x;
		return x + (x * (z * (-1.66666666666666666666666666666666538e-01L + z * (8.33333333333333333333333333307532934e-03L + z * (-1.98412698412698412698412534478712057e-04L + z * (2.75573192239858906520896496653095890e-06L + z * (-2.50521083854417116999224301266655662e-08L + z * (1.60590438367608957516841576404938118e-10L + z * (-7.64716343504264506714019494041582610e-13L + z * 2.81068754939739570236322404393398135e-15L)))))))));
	} else {
		index = (int)(128 * (absx - (0.1484375L - 1.0L / 256.0L)));
		h = 0.1484375L + index / 128.0;
		index *= 4;
		if (iy) { l = (x < 0 ? -y : y) - (h - absx); }
		else { l = absx - h; }
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		z = __sincosl_table[index + 2] + (__sincosl_table[index + 3] + (__sincosl_table[index + 2] * cos_l_m1) + (__sincosl_table[index + 0] * sin_l));
		return (x < 0) ? -z : z;
	}
}


LIB_FUNC long double cosl(const long double num) {
	long double y[2], z = 0.0, x = num;
	int32_t n, se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	se &= 0x7fff;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= 0xc90fdaa2)) { return __kernel_cosl(x, z); }
	else if (se == 0x7fff) {
		if (i1 == 0 && i0 == 0x80000000) { __set_errno(EDOM); }
		return x - x;
	}
	else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_cosl(y[0], y[1]);
			case 1:
				return -__kernel_sinl(y[0], y[1], 1);
			case 2:
				return -__kernel_cosl(y[0], y[1]);
			default:
				return  __kernel_sinl(y[0], y[1], 1);
		}
	}
}
#define __cosl(x)   cosl((x))


LIB_FUNC long double sinl(const long double numx) {
	long double y[2], z = 0.0, x = numx;
	int32_t n, se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	se &= 0x7fff;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= 0xc90fdaa2)) { return __kernel_sinl(x, z, 0); }
	else if (se == 0x7fff) {
		if (i1 == 0 && i0 == 0x80000000) { __set_errno(EDOM); }
		return x - x;
	} else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_sinl(y[0], y[1], 1);
			case 1:
				return  __kernel_cosl(y[0], y[1]);
			case 2:
				return -__kernel_sinl(y[0], y[1], 1);
			default:
				return -__kernel_cosl(y[0], y[1]);
		}
	}
}
#define __sinl(x)   sinl((x))


#elif LONG_DOUBLE_IS_BINARY128


const UNUSED long double __sincosl_table[] = {
	9.89003367927322909016887196069562069e-01L, 2.15663692029265697782289400027743703e-35L,
	1.47892995873409608580026675734609314e-01L, 9.74950446464233268291647449768590886e-36L,
	9.87817783816471944100503034363211317e-01L, 4.74271307836705897892468107620526395e-35L,
	1.55614992773556041209920643203516258e-01L, -7.83989563419287980121718050629497270e-36L,
	9.86571908399497588757337407495308409e-01L, -2.47327949936985362476252401212720725e-35L,
	1.63327491736612850846866172454354370e-01L, 1.81380344301155485770367902300754350e-36L,
	9.85265817718213816204294709759578994e-01L, 2.26568029505818066141517497778527952e-35L,
	1.71030022031395019281347969239834331e-01L, 7.01395875187487608875416030203241317e-36L,
	9.83899591489663972178309351416487245e-01L, 2.73414318948066207810486330723761265e-35L,
	1.78722113535153659375356241864180724e-01L, -1.52906926517265103202547561260594148e-36L,
	9.82473313101255257487327683243622495e-01L, -1.64924358891557584625463868014230342e-35L,
	1.86403296762269884552379983103205261e-01L, 1.76460304806826780010586715975331753e-36L,
	9.80987069605669190469329896435309665e-01L, -1.90899259410096419886996331536278461e-36L,
	1.94073102892909791156055200214145404e-01L, -9.67304741051998267208945242944928999e-36L,
	9.79440951715548359998530954502987493e-01L, 4.42878056591560757066844797290067990e-35L,
	2.01731063801638804725038151164000971e-01L, -4.27513434754966978435151290617384120e-36L,
	9.77835053797959793331971572944454549e-01L, -3.79207422905180416937210853779192702e-35L,
	2.09376712085993643711890752724881652e-01L, -1.59470287344329449965314638482515925e-36L,
	9.76169473868635276723989035435135534e-01L, -2.87727974249481583047944860626985460e-35L,
	2.17009581095010156760578095826055396e-01L, 1.07356488794216831812829549198201194e-35L,
	9.74444313585988980349711056045434344e-01L, 3.09947905955053419304514538592548333e-35L,
	2.24629204957705292350428549796424820e-01L, 2.42061510849297469844695751870058679e-36L,
	9.72659678244912752670913058267565260e-01L, -3.91759231819314904966076958560252735e-35L,
	2.32235118611511462413930877746235872e-01L, -4.96930483364191020075024624332928910e-36L,
	9.70815676770349462947490545785046027e-01L, 2.97458820972393859125277682021202860e-35L,
	2.39826857830661564441369251810886574e-01L, 2.39867036569896287240938444445071448e-36L,
	9.68912421710644784144595449494189205e-01L, -5.53634706113461989398873287749326500e-36L,
	2.47403959254522929596848704849389203e-01L, -7.36487001108599532943597115275811618e-36L,
	9.66950029230677822008341623610531503e-01L, -4.38972214432792412062088059990480514e-35L,
	2.54965960415878467487556574864872628e-01L, 2.20280377918534721005071688328074154e-35L,
	9.64928619104771009581074665315748371e-01L, -3.66685832670820775002475545602761113e-35L,
	2.62512399769153281450949626395692931e-01L, 3.24923677072031064673177178571821843e-36L,
	9.62848314709379699899701093480214365e-01L, 4.88986966383343450799422013051821394e-36L,
	2.70042816718585031552755063618827102e-01L, -2.37608892440611310321138680065803162e-35L,
	9.60709243015561903066659350581313472e-01L, -5.87011558231583960712013351601221840e-36L,
	2.77556751646336325922023446828128568e-01L, -1.35848595468998128214344668770082997e-36L,
	9.58511534581228627301969408154919822e-01L, 2.50770779371636481145735089393154404e-35L,
	2.85053745940547424587763033323252561e-01L, 2.04269325885902918802700123680403749e-35L,
	9.56255323543175296975599942263028361e-01L, 3.21616572190865997051103645135837207e-35L,
	2.92533342023327543624702326493913423e-01L, 1.93539408668704450308003687950685128e-35L,
	9.53940747608894733981324795987611623e-01L, 2.88075689052478602008395972924657164e-35L,
	2.99995083378683051163248282011699944e-01L, 1.35174265535697850139283361475571050e-35L,
	9.51567948048172202145488217364270962e-01L, 6.36842628598115658308749288799884606e-36L,
	3.07438514580380850670502958201982091e-01L, 1.06515172423204645839241099453417152e-35L,
	9.49137069684463027665847421762105623e-01L, 6.84433965991637152250309190468859701e-37L,
	3.14863181319745250865036315126939016e-01L, 1.92431240212432926993057705062834160e-35L,
	9.46648260886053321846099507295532976e-01L, -4.32906339663000890941529420498824645e-35L,
	3.22268630433386625687745919893188031e-01L, -1.49505897804759263483853908335500228e-35L,
	9.44101673557004345630017691253124860e-01L, 1.03812535240120229609822461172145584e-35L,
	3.29654409930860171914317725126463176e-01L, -1.22606996784743214973082192294232854e-35L,
	9.41497463127881068644511236053670815e-01L, 3.20709366603165602071590241054884900e-36L,
	3.37020069022253076261281754173810024e-01L, -2.21435756148839473677777545049890664e-35L,
	9.38835788546265488632578305984712554e-01L, -3.98758068773974031348585072752245458e-35L,
	3.44365158145698408207172046472223747e-01L, -3.19791885005480924937758467594051927e-36L,
	9.36116812267055290294237411019508588e-01L, 3.40481591236710658435409862439032162e-35L,
	3.51689228994814059222584896955547016e-01L, 1.75293433418270210567525412802083294e-35L,
	9.33340700242548435655299229469995527e-01L, -4.75255707251679831124800898831382223e-35L,
	3.58991834546065053677710299152868941e-01L, -2.06772389262723368139416970257112089e-35L,
	9.30507621912314291149476792229555481e-01L, 2.74541088551732982573335285685416092e-35L,
	3.66272529086047561372909351716264177e-01L, -1.96768433534936592675897818253108989e-35L,
	9.27617750192851909628030798799961350e-01L, 7.58520371916345756281201167126854712e-36L,
	3.73530868238692946416839752660848112e-01L, -1.48023494778986556048879113411517128e-35L,
	9.24671261467036098502113014560138771e-01L, -4.14187124860031825108649347251175815e-35L,
	3.80766408992390192057200703388896675e-01L, -2.02009541175208636336924533372496107e-35L,
	9.21668335573351918175411368202712714e-01L, -1.83587995433957622948710263541479322e-35L,
	3.87978709727025046051079690813741960e-01L, 8.01904783870935075844443278617586301e-36L,
	9.18609155794918267837824977718549863e-01L, 2.97608282778274433460057745798409849e-35L,
	3.95167330240934236244832640419653657e-01L, 7.57560031388312550940040194042627704e-36L,
	9.15493908848301228563917732180221882e-01L, -3.50775517955306954815090901168305659e-35L,
	4.02331831777773111217105598880982387e-01L, -1.95678722882848174723569916504871563e-35L,
	9.12322784872117846492029542047341734e-01L, 7.86903886556373674267948132178845568e-36L,
	4.09471777053295066122694027011452236e-01L, 2.23945241468457597921655785729821354e-35L,
	9.09095977415431051650381735684476417e-01L, 1.20886014028444155733776025085677953e-35L,
	4.16586730282041119259112448831069657e-01L, -2.00488106831998813675438269796963612e-35L,
	9.05813683425936420744516660652700258e-01L, -3.60950307605941169775676563004467163e-35L,
	4.23676257203938010361683988031102480e-01L, 1.40484456388654470329473096579312595e-35L,
	9.02476103237941504925183272675895999e-01L, 2.26282899501344419018306295680210602e-35L,
	4.30739925110803197216321517850849190e-01L, 1.54096780001629398850891218396761548e-35L,
	8.99083440560138456216544929209379307e-01L, -2.06772615490904370666670275154751976e-35L,
	4.37777302872755132861618974702796680e-01L, 9.62794364503442612477117426033922467e-36L,
	8.95635902463170698900570000446256350e-01L, 3.73593741659866883088620495542311808e-35L,
	4.44787960964527211433056012529525211e-01L, -1.67187936511493678007508371613954899e-35L,
	8.92133699366994404723900253723788575e-01L, -1.10771937602567314732693079264692504e-35L,
	4.51771471491683776581688750134062870e-01L, -1.19387223016472295893794387275284505e-35L,
	8.88577045028035543317609023116020980e-01L, 4.12354278954664731443813655177022170e-36L,
	4.58727408216736592377295028972874773e-01L, -4.70946994194182908929251719575431779e-36L,
	8.84966156526143291697296536966647926e-01L, 4.53370570288325630442037826313462165e-35L,
	4.65655346585160182681199512507546779e-01L, -1.56282598978971872478619772155305961e-35L,
	8.81301254251340599140161908298100173e-01L, -1.43419192312116687783945619009629445e-35L,
	4.72554863751304451146551317808516942e-01L, 9.31324774957768018850224267625371204e-36L,
	8.77582561890372716116281582603829681e-01L, -2.89484960181363924855192538540698851e-35L,
	4.79425538604203000273287935215571402e-01L, -1.38426977616718318950175848639381926e-35L,
	8.73810306413054508282556837071377159e-01L, 1.25716864497849302237218128599994785e-35L,
	4.86266951793275574311011306895834993e-01L, -1.12269393250914752644352376448094271e-35L,
	8.69984718058417388828915599901466243e-01L, -4.68168638300575626782741319792183837e-35L,
	4.93078685753923057265136552753487121e-01L, 7.06498693112535056352301101088624950e-36L,
	8.66106030320656714696616831654267220e-01L, 2.35610597588322493119667003904687628e-35L,
	4.99860324733013463819556536946425724e-01L, 1.94636052312235297538564591686645139e-35L,
	8.62174479934880504367162510253324274e-01L, -3.71556818317533582234562471835771823e-35L,
	5.06611454814257367642296000893867192e-01L, -3.10963699824274155702706043065967062e-35L,
	8.58190306862660347046629564970494649e-01L, 2.06439574601190798155563653000684861e-35L,
	5.13331663943471218288801270215706878e-01L, -2.26614796466671970772244932848067224e-35L,
	8.54153754277385385143451785105103176e-01L, -1.68707534013095152873222061722573172e-35L,
	5.20020541953727004760213699874674730e-01L, -3.32415021330884924833711842866896734e-35L,
	8.50065068549420263957072899177793617e-01L, -4.73753917078785974356016104842568442e-35L,
	5.26677680590386730710789410624833901e-01L, -3.67066148195515214077582496518566735e-35L,
	8.45924499231067954459723078597493262e-01L, 1.98054947141989878179164342925274053e-35L,
	5.33302673536020173329131103308161529e-01L, -3.42715291319551615996993795226755157e-35L,
	8.41732299041338366963111794309701085e-01L, -4.30821936750410026005408345400225948e-35L,
	5.39895116435204405041660709903993340e-01L, 1.42595803521626714477253741404712093e-35L,
	8.37488723850523685315353348917240617e-01L, 2.72761997872084533045777718677326179e-35L,
	5.46454606919203564403349553749411001e-01L, -2.11870230730160315420936523771864858e-35L,
	8.33194032664581363070224042208032321e-01L, 4.39440050052045486567668031751259899e-35L,
	5.52980744630527369849695082681623667e-01L, 8.26624790417342895897164123189984127e-37L,
	8.28848487609325734810171790119116638e-01L, 1.43082508100496581719048175506239770e-35L,
	5.59473131247366877384844006003116688e-01L, -1.28922620524163922306886952100992796e-37L,
	8.24452353914429207485643598212356053e-01L, 3.79160239225080026987031418939026741e-35L,
	5.65931370507905990773159095689276114e-01L, 1.02202775968053982310991962521535027e-36L,
	8.20005899897234008255550633876556043e-01L, -1.72008811955230823416724332297991247e-35L,
	5.72355068234507240384953706824503608e-01L, 2.12572273479933123944580199464514529e-35L,
	8.15509396946375476876345384201386217e-01L, -4.28589138410712954051679139949341961e-35L,
	5.78743832357770354521111378581385347e-01L, 1.77998063432551282609698670002456093e-35L,
	8.10963119505217902189534803941080724e-01L, 1.10481292856794436426051402418804358e-35L,
	5.85097272940462154805399314150080459e-01L, -1.78164576278056195136525335403380464e-35L,
	8.06367345055103913698795406077297399e-01L, 1.04235088143133625463876245029180850e-35L,
	5.91415002201316315087000225758031236e-01L, 8.07390238063560077355762466502569603e-36L,
	8.01722354098418450607492605652964208e-01L, 6.09487851305233089325627939458963741e-36L,
	5.97696634538701531238647618967334337e-01L, -2.49527608940873714527427941350461554e-35L,
	7.97028430141468342004642741431945296e-01L, -8.35364432831812599727083251866305534e-37L,
	6.03941786554156657267270287527367726e-01L, -2.54578992328947177770363936132309779e-35L,
	7.92285859677178543141501323781709399e-01L, 2.47519558228473167879248891673807645e-35L,
	6.10150077075791371273742393566183220e-01L, 1.33842237929938963780969418369150532e-35L,
	7.87494932167606083931328295965533034e-01L, -2.57915385618070637156514241185180920e-35L,
	6.16321127181550943005700433761731837e-01L, 2.88497530050197716298085892460478666e-35L,
	7.82655940026272796930787447428139026e-01L, 1.69332045679237919427807771288506254e-35L,
	6.22454560222343683041926705090443330e-01L, 1.91974786921147072717621236192269859e-35L,
	7.77769178600317903122203513685412863e-01L, -4.05296033424632846931240580239929672e-35L,
	6.28550001845029662028004327939032867e-01L, 1.65507421184028099672784511397428852e-35L,
	7.72834946152471544810851845913425178e-01L, 3.94975229341211664237241534741146939e-35L,
	6.34607080015269296850309914203671436e-01L, 4.33025916939968369326060156455927002e-36L,
	7.67853543842850365879920759114193964e-01L, 3.75100035267325597157244776081706979e-36L,
	6.40625425040230409188409779413961021e-01L, 2.46542747294664049615806500747173281e-36L,
	7.62825275710576250507098753625429792e-01L, 4.22067411888601505004748939382325080e-35L,
	6.46604669591152370524042159882800763e-01L, -3.41742981816219412415674365946079826e-35L,
	7.57750448655219342240234832230493361e-01L, -2.08767968311222650582659938787920125e-35L,
	6.52544448725765956407573982284767763e-01L, -8.61758060284379660697102362141557170e-36L,
	7.52629372418066476054541324847143116e-01L, 3.71306958657663189665450864311104571e-35L,
	6.58444399910567541589583954884041989e-01L, -4.54412944084300330523721391865787219e-35L,
	7.47462359563216166669700384714767552e-01L, -9.11094340926220027288083639048016945e-36L,
	6.64304163042946276515506587432846246e-01L, 4.26004843895378210155889028714676019e-35L,
	7.42249725458501306991347253449610537e-01L, -3.78925270049800913539923473871287550e-35L,
	6.70123380473162894654531583500648495e-01L, -1.33165852952743729897634069393684656e-36L,
	7.36991788256240741057089385586450844e-01L, 4.72358938637974850573747497460125519e-35L,
	6.75901697026178809189642203142423973e-01L, 2.76252586616364878801928456702948857e-35L,
	7.31688868873820886311838753000084529e-01L, 1.48255637548931697184991710293198620e-35L,
	6.81638760023334166733241952779893908e-01L, 2.74838775935027549024224114338667371e-35L,
	7.26341290974108590410147630237598973e-01L, 3.12683579338351123545814364980658990e-35L,
	6.87334219303873534951703613035647220e-01L, 4.76739454455410744997012795035529128e-35L,
	7.20949380945696418043812784148447688e-01L, 4.78691285733673379499536326050811832e-35L,
	6.92987727246317910281815490823048210e-01L, 4.50089871077663557180849219529189918e-35L,
	7.15513467882981573520620561289896903e-01L, -3.02191815581445336509438104625489192e-35L,
	6.98598938789681741301929277107891591e-01L, 2.15465226809256290914423429408722521e-35L,
	7.10033883566079674974121643959490219e-01L, -4.09623224763692443220896752907902465e-35L,
	7.04167511454533672780059509973942844e-01L, -2.87259372740393348676633610275598640e-35L,
	7.04510962440574606164129481545916976e-01L, 2.60682037357042658395360726992048803e-35L,
	7.09693105363899724959669028139035515e-01L, -4.37026016974122945368562319136420097e-36L
};


LIB_FUNC long double __kernel_cosl(const long double numx, const long double numy) {
	long double h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int64_t ix;
	uint32_t tix, hix, index;
	GET_LDOUBLE_MSW64S(ix, x);
	tix = (uint32_t)(((uint64_t)ix) >> 32);
	tix &= (uint32_t)(~0x80000000);
	if (tix < 0x3ffc3000) {
		if (tix < 0x3fc60000 && (!((int)x))) { return 1.00000000000000000000000000000000000E+00L; }
		z = x * x;
		return 1.00000000000000000000000000000000000E+00L + (z * (-4.99999999999999999999999999999999759E-01L + z * (4.16666666666666666666666666651287795E-02L + z * (-1.38888888888888888888888742314300284E-03L + z * (2.48015873015873015867694002851118210E-05L + z * (-2.75573192239858811636614709689300351E-07L + z * (2.08767569877762248667431926878073669E-09L + z * (-1.14707451049343817400420280514614892E-11L + z * 4.77810092804389587579843296923533297E-14L))))))));
	} else {
		index = 0x3ffe - (tix >> 16);
		hix = (uint32_t)((tix + (uint32_t)(0x200 << index)) & (uint32_t)(0xfffffc00 << index));
		if (signbitl(x)) {
			x = -x;
			y = -y;
		}
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		SET_LDOUBLE_WORDS64(h, ((uint64_t)hix) << 32, 0);
		l = y - (h - x);
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		return __sincosl_table[index + 0] + (__sincosl_table[index + 1] - (__sincosl_table[index + 2] * sin_l - __sincosl_table[index + 0] * cos_l_m1));
	}
}


LIB_FUNC long double __kernel_sinl(const long double numx, const long double numy, int iy) {
	long double h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int64_t ix;
	uint32_t tix, hix, index;
	GET_LDOUBLE_MSW64S(ix, x);
	tix = (uint32_t)(((uint64_t)ix) >> 32);
	tix &= (uint32_t)(~0x80000000);
	if (tix < 0x3ffc3000) {
		if (tix < 0x3fc60000) {
			// math_check_force_underflow(x);
			if (!((int)x)) { return x; }
		}
		z = x * x;
		return x + (x * (z * (-1.66666666666666666666666666666666538e-01L + z * (8.33333333333333333333333333307532934e-03L + z * (-1.98412698412698412698412534478712057e-04L + z * (2.75573192239858906520896496653095890e-06L + z * (-2.50521083854417116999224301266655662e-08L + z * (1.60590438367608957516841576404938118e-10L + z * (-7.64716343504264506714019494041582610e-13L + z * 2.81068754939739570236322404393398135e-15L)))))))));
	} else {
		index = 0x3ffe - (tix >> 16);
		hix = (uint32_t)((uint32_t)(tix + (uint32_t)(0x200 << index)) & (uint32_t)(0xfffffc00 << index));
		x = fabsl(x);
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		SET_LDOUBLE_WORDS64(h, ((uint64_t)hix) << 32, 0);
		if (iy) { l = (ix < 0 ? -y : y) - (h - x); }
		else { l = x - h; }
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		z = __sincosl_table[index + 2] + (__sincosl_table[index + 3] + (__sincosl_table[index + 2] * cos_l_m1) + (__sincosl_table[index + 0] * sin_l));
		return (ix < 0) ? -z : z;
	}
}


LIB_FUNC long double cosl(const long double num) {
	long double y[2], z = 0.0L, x = num;
	int64_t n, ix;
	GET_LDOUBLE_MSW64S(ix, x);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3ffe921fb54442d1LL) { return __kernel_cosl(x, z); }
	else if (ix >= 0x7fff000000000000LL) {
		if (ix == 0x7fff000000000000LL) {
			GET_LDOUBLE_LSW64S(n, x);
			if (n == 0) { __set_errno(EDOM); }
		}
		return x - x;
	}
	else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_cosl(y[0], y[1]);
			case 1:
				return -__kernel_sinl(y[0], y[1], 1);
			case 2:
				return -__kernel_cosl(y[0], y[1]);
			default:
				return  __kernel_sinl(y[0], y[1], 1);
		}
	}
}
#define __cosl(x)   cosl((x))


LIB_FUNC long double sinl(const long double numx) {
	long double y[2], z = 0.0L, x = numx;
	int64_t n, ix;
	GET_LDOUBLE_MSW64S(ix, x);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3ffe921fb54442d1LL) { return __kernel_sinl(x, z, 0); }
	else if (ix >= 0x7fff000000000000LL) {
		if (ix == 0x7fff000000000000LL) {
			GET_LDOUBLE_LSW64S(n, x);
			if (n == 0) { __set_errno(EDOM); }
		}
		return x - x;
	} else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_sinl(y[0], y[1], 1);
			case 1:
				return  __kernel_cosl(y[0], y[1]);
			case 2:
				return -__kernel_sinl(y[0], y[1], 1);
			default:
				return -__kernel_cosl(y[0], y[1]);
		}
	}
}
#define __sinl(x)   sinl((x))


#elif SUPPORTS_IBM_LONG_DOUBLE


const UNUSED long double __sincosl_table[] = {
	0x0.fd2f5320e1b790209b4dda2f98p0L, 0x0.f79caaa7b873aff1014b0fbc52p-104L,
	0x0.25dc50bc95711d0d9787d108fdp0L, 0x0.438cf5959ee0bfb7a1e36e8b1ap-104L,
	0x0.fce1a053e621438b6d60c76e8cp0L, 0x0.45bf0a9dc71aa16f922acc10e9p-104L,
	0x0.27d66258bacd96a3eb335b365cp0L, 0x0.87d59438c5142bb56a489e9b8dp-104L,
	0x0.fc8ffa01ba6807417e05962b0dp0L, 0x0.9fdf1fddb0cc4c07d22e19e080p-104L,
	0x0.29cfd49b8be4f665276cab01cbp0L, 0x0.f0426934906c3dd105473b226ep-104L,
	0x0.fc3a6170f767ac735d63d99a9dp0L, 0x0.439e1db5e59d3ef153a4265d58p-104L,
	0x0.2bc89f9f424de5485de7ce03b2p0L, 0x0.514952b9faf5648c3244d4736fp-104L,
	0x0.fbe0d7f7fef11e70aa43b8abf4p0L, 0x0.f6a457cea20c8f3f676b47781fp-104L,
	0x0.2dc0bb80b49a97ffb34e8dd1f8p0L, 0x0.db9df7af47ed2dcf58b12c8e78p-104L,
	0x0.fb835efcf670dd2ce6fe792469p0L, 0x0.7eea13ea358867e9cdb3899b78p-104L,
	0x0.2fb8205f75e56a2b56a1c4792fp0L, 0x0.856258769af396e0189ef72c05p-104L,
	0x0.fb21f7f5c156696b00ac1fe28ap0L, 0x0.c5fd76674a92b4df80d9c8a46cp-104L,
	0x0.31aec65df552876f82ece9a235p0L, 0x0.6713246eba6799983d7011b0b3p-104L,
	0x0.fabca467fb3cb8f1d069f01d8ep0L, 0x0.a33ade5bfd68296ecd1cc9f7b7p-104L,
	0x0.33a4a5a19d86246710f602c44dp0L, 0x0.f4fa513f4639ce938477aeeabbp-104L,
	0x0.fa5365e8f1d3ca27be1db5d76ap0L, 0x0.e64d983d7470a4ab0f4ccf65a2p-104L,
	0x0.3599b652f40ec999df12a0a4c8p0L, 0x0.561de159c98d4e54555de518b9p-104L,
	0x0.f9e63e1d9e8b6f6f2e296bae5bp0L, 0x0.5ed9c11fd7fa2fe11e09fc7bdep-104L,
	0x0.378df09db8c332ce0d2b53d865p0L, 0x0.582e4526ea336c768f68c32b49p-104L,
	0x0.f9752eba9fff6b98842beadab0p0L, 0x0.54a932fb0f8d5b875ae63d6b22p-104L,
	0x0.39814cb10513453cb97b21bc1cp0L, 0x0.a6a337b150c21a675ab85503bcp-104L,
	0x0.f90039843324f9b940416c1984p0L, 0x0.b6cbed1fc733d97354d4265788p-104L,
	0x0.3b73c2bf6b4b9f668ef9499c81p0L, 0x0.f0d965087f1753fa64b086e58cp-104L,
	0x0.f887604e2c39dbb20e4ec58250p0L, 0x0.59a789ffc95b275ad9954078bap-104L,
	0x0.3d654aff15cb457a0fca854698p0L, 0x0.aba33039a8a40626609204472dp-104L,
	0x0.f80aa4fbef750ba783d33cb95fp0L, 0x0.94f8a41426dbe79edc4a023ef9p-104L,
	0x0.3f55dda9e62aed7513bd7b8e6ap0L, 0x0.3d1635dd5676648d7db525898dp-104L,
	0x0.f78a098069792daabc9ee42591p0L, 0x0.b7c5a68cb1ab822aeb446b3311p-104L,
	0x0.414572fd94556e6473d6202713p0L, 0x0.88dd47c0ba050cdb5270112e3ep-104L,
	0x0.f7058fde0788dfc805b8fe8878p0L, 0x0.9e4f4253e3c50afe8b22f41159p-104L,
	0x0.4334033bcd90d6604f5f36c1d4p0L, 0x0.b84451a87150438275b77470b5p-104L,
	0x0.f67d3a26af7d07aa4bd6d42af8p0L, 0x0.c0067fefb96d5b46c031eff536p-104L,
	0x0.452186aa5377ab20bbf2524f52p0L, 0x0.e3a06a969f47166ab88cf88c11p-104L,
	0x0.f5f10a7bb77d3dfa0c1da8b578p0L, 0x0.42783280d01ce3c0f82bae3b9dp-104L,
	0x0.470df5931ae1d946076fe0dcffp0L, 0x0.47fe31bb2ede618ebc607821f8p-104L,
	0x0.f561030ddd7a78960ea9f4a32cp0L, 0x0.6521554995667f5547bafee9ecp-104L,
	0x0.48f948446abcd6b0f7fccb100ep0L, 0x0.7a1b26eccad880b0d24b59948cp-104L,
	0x0.f4cd261d3e6c15bb369c875863p0L, 0x0.0d2ac00b7ace2a51c0631bfeb3p-104L,
	0x0.4ae37710fad27c8aa9c4cf96c0p0L, 0x0.3519b9ce07dc08a1471775499fp-104L,
	0x0.f43575f94d4f6b272f5fb76b14p0L, 0x0.d2a64ab52df1ee8ddf7c651034p-104L,
	0x0.4ccc7a50127e1de0cb6b40c302p0L, 0x0.c651f7bded4f9e7702b0471ae0p-104L,
	0x0.f399f500c9e9fd37ae9957263dp0L, 0x0.ab8877102beb569f101ee44953p-104L,
	0x0.4eb44a5da74f600207aaa090f0p0L, 0x0.734e288603ffadb3eb2542a469p-104L,
	0x0.f2faa5a1b74e82fd61fa05f917p0L, 0x0.7380e8e69b7b15a945e8e5ae11p-104L,
	0x0.509adf9a7b9a5a0f638a8fa3a6p0L, 0x0.0a199418859f18b37169a644fdp-104L,
	0x0.f2578a595224dd2e6bfa2eb2f9p0L, 0x0.9cc674f5ea6f479eae2eb58018p-104L,
	0x0.5280326c3cf481823ba6bb08eap0L, 0x0.c82c2093f2bce3c4eb4ee3dec7p-104L,
	0x0.f1b0a5b406b526d886c55feadcp0L, 0x0.8d0dcc8eb9ae2ac707051771b4p-104L,
	0x0.54643b3da29de9b357155eef0fp0L, 0x0.332fb3e66c83bf4dddd9491c5ep-104L,
	0x0.f105fa4d66b607a67d44e04272p0L, 0x0.5204435142ac8ad54dfb0907a4p-104L,
	0x0.5646f27e8bd65cbe3a5d61ff06p0L, 0x0.572290ee826d9674a00246b05ap-104L,
	0x0.f0578ad01ede707fa39c09dc6bp0L, 0x0.984afef74f3dc8d0efb0f4c5a6p-104L,
	0x0.582850a41e1dd46c7f602ea244p0L, 0x0.cdbbbfcdfa8f3189be794dda42p-104L,
	0x0.efa559f5ec3aec3a4eb0331927p0L, 0x0.8a2d41fcf9189462261125fe61p-104L,
	0x0.5a084e28e35fda2776dfdbbb55p0L, 0x0.31d74ced2b5d17c0b1afc46475p-104L,
	0x0.eeef6a879146af0bf9b95ea2eap0L, 0x0.0ac0d3e2e4d7e15d93f48cbd41p-104L,
	0x0.5be6e38ce8095542bc14ee9da0p0L, 0x0.d36483e6734bcab2e07624188ap-104L,
	0x0.ee35bf5ccac89052cd91ddb734p0L, 0x0.d3a47e262e3b609db604e21705p-104L,
	0x0.5dc40955d9084f48a94675a249p0L, 0x0.8de5d851320ff5528a6afb3f2ep-104L,
	0x0.ed785b5c44741b4493c56bcb9dp0L, 0x0.338a151c6f6b85d8f8aca658b2p-104L,
	0x0.5f9fb80f21b53649c432540a50p0L, 0x0.e22c53057ff42ae0fdf1307760p-104L,
	0x0.ecb7417b8d4ee3fec37aba4073p0L, 0x0.aa48f1f14666006fb431d96713p-104L,
	0x0.6179e84a09a5258a40e9b5facep0L, 0x0.03e525f8b5753cd0105d93fe62p-104L,
	0x0.ebf274bf0bda4f62447e56a093p0L, 0x0.626798d3013b5942b1abfd155ap-104L,
	0x0.6352929dd264bd44a02ea76632p0L, 0x0.5d8aa8bd9695fc8def3caefba5p-104L,
	0x0.eb29f839f201fd13b937968279p0L, 0x0.16a78f15c85230a4e8ea4b2155p-104L,
	0x0.6529afa7d51b129631ec197c0ap0L, 0x0.840a11d7dc5368b0a47956feb2p-104L,
	0x0.ea5dcf0e30cf03e6976ef0b1ecp0L, 0x0.26515fba47383855c3b4055a99p-104L,
	0x0.66ff380ba0144109e39a320b0ap0L, 0x0.3fa5fd65ea0585bcbf9b1a769ap-104L,
	0x0.e98dfc6c6be031e60dd3089cbdp0L, 0x0.d18a75b1f6b2c1e97f79225202p-104L,
	0x0.68d32473143327973bc712bcc4p0L, 0x0.ccddc47630d755850c0655243bp-104L,
	0x0.e8ba8393eca7821aa563d83491p0L, 0x0.b6101189b3b101c3677f73d7bap-104L,
	0x0.6aa56d8e8249db4eb60a761fe3p0L, 0x0.f9e559be456b9e13349ca99b0bp-104L,
	0x0.e7e367d2956cfb16b6aa11e541p0L, 0x0.9cd0057f5c132a6455bf064297p-104L,
	0x0.6c760c14c8585a51dbd34660aep0L, 0x0.6c52ac7036a0b40887a0b63724p-104L,
	0x0.e708ac84d4172a3e2737662213p0L, 0x0.429e14021074d7e702e77d72a8p-104L,
	0x0.6e44f8c36eb10a1c752d093c00p0L, 0x0.f4d47ba446ac4c215d26b03164p-104L,
	0x0.e62a551594b970a770b15d41d4p0L, 0x0.c0e483e47aca550111df6966f9p-104L,
	0x0.70122c5ec5028c8cff33abf4fdp0L, 0x0.340ccc382e038379b09cf04f9ap-104L,
	0x0.e54864fe33e8575cabf5bd0e5cp0L, 0x0.f1b1a8bc7c0d5f61702450fa6bp-104L,
	0x0.71dd9fb1ff4677853acb970a9fp0L, 0x0.6729c6e3aac247b1c57cea66c7p-104L,
	0x0.e462dfc670d421ab3d1a159012p0L, 0x0.28f146a0547011202bf5ab01f9p-104L,
	0x0.73a74b8f52947b681baf6928ebp0L, 0x0.3fb021769bf4779bad0e3aa9b1p-104L,
	0x0.e379c9045f29d517c4808aa497p0L, 0x0.c2057b2b3d109e76c0dc302d4dp-104L,
	0x0.756f28d011d98528a44a75fc29p0L, 0x0.c779bd734ecdfb582fdb74b68ap-104L,
	0x0.e28d245c58baef72225e232abcp0L, 0x0.003c4366acd9eb4fc2808c2ab7p-104L,
	0x0.77353054ca72690d4c6e171fd9p0L, 0x0.9e6b39fa8e1ede5f052fd29645p-104L,
	0x0.e19cf580eeec046aa1422fa748p0L, 0x0.07ecefb2a1911c94e7b5f20a00p-104L,
	0x0.78f95b0560a9a3bd6df7bd981dp0L, 0x0.c38c61224d08bc20631ea932e6p-104L,
	0x0.e0a94032dbea7cedbddd9da2fap0L, 0x0.fad98556566b3a89f43eabd723p-104L,
	0x0.7abba1d12c17bfa1d92f0d93f6p0L, 0x0.0ded9992f45b4fcaf13cd58b30p-104L,
	0x0.dfb20840f3a9b36f7ae2c51534p0L, 0x0.2890b5ec583b8366cc2b55029ep-104L,
	0x0.7c7bfdaf13e5ed17212f8a7525p0L, 0x0.bfb113aba6c0741b5362bb8d59p-104L,
	0x0.deb7518814a7a931bbcc88c109p0L, 0x0.cd41c50bf8bb48f20ae8c36628p-104L,
	0x0.7e3a679daaf25c676542bcb402p0L, 0x0.8d0964172961c921823a4ef0c3p-104L,
	0x0.ddb91ff318799172bd2452d0a3p0L, 0x0.889f5169c64a0094bcf0b8aa7dp-104L,
	0x0.7ff6d8a34bd5e8fa54c97482dbp0L, 0x0.5159df1f24e8038419c0b448b9p-104L,
	0x0.dcb7777ac420705168f31e3eb7p0L, 0x0.80ce9c939ecada62843b54522fp-104L,
	0x0.81b149ce34caa5a4e650f8d09fp0L, 0x0.d4d6aa74206c32ca951a93074cp-104L,
	0x0.dbb25c25b8260c14f6e7bc98ecp0L, 0x0.991b70c65335198b0ab628bad2p-104L,
	0x0.8369b434a372da7eb5c8a71fe3p0L, 0x0.6ce1e0b2b493f6f5cb2e38bcaep-104L,
	0x0.daa9d20860827063fde51c09e8p0L, 0x0.55e9932e1b17143e7244fd267ap-104L,
	0x0.852010f4f0800521378bd8dd61p0L, 0x0.4753d080c2e9e0775ffc609947p-104L,
	0x0.d99ddd44e44a43d4d4a3a3ed95p0L, 0x0.204106fd54d78e8c7684545c0dp-104L,
	0x0.86d45935ab396cb4e421e822dep0L, 0x0.e54f3562dfcefeaa782184c234p-104L,
	0x0.d88e820b1526311dd561efbc0cp0L, 0x0.1a9a5375eb26f65d246c5744b1p-104L,
	0x0.88868625b4e1dbb23133101330p0L, 0x0.22527200c143a5cb16637cb7dap-104L,
	0x0.d77bc4985e93a607c9d868b906p0L, 0x0.bbc6bbe3a04258814acb035846p-104L,
	0x0.8a3690fc5bfc11bf9535e2739ap0L, 0x0.8512f448a41251514bbed7fc18p-104L,
	0x0.d665a937b4ef2b1f6d51bad6d9p0L, 0x0.88a4419c1d7051faf31a9efa15p-104L,
	0x0.8be472f9776d809af2b8817124p0L, 0x0.3d63d66dfceeeb739cc894e023p-104L,
	0x0.d54c3441844897fc8f853f0655p0L, 0x0.f1ba695eba9fbfd7439dbb1171p-104L,
	0x0.8d902565817ee7839bce3cd128p0L, 0x0.060119492cd36d42d82ada30d7p-104L,
	0x0.d42f6a1b9f0168cdf031c2f63cp0L, 0x0.8d9304d86f8d34cb1d5fccb68cp-104L,
	0x0.8f39a191b2ba6122a3fa4f41d5p0L, 0x0.a3ffd421417d46f19a22230a14p-104L,
	0x0.d30f4f392c357ab0661c5fa8a7p0L, 0x0.d9b26627846fef214b1d19a223p-104L,
	0x0.90e0e0d81ca678796cc92c8ea8p0L, 0x0.c2815bc72ca78abe571bfa8576p-104L,
	0x0.d1ebe81a95ee752e48a26bcd32p0L, 0x0.d6e922d7eb44b8ad2232f69307p-104L,
	0x0.9285dc9bc45dd9ea3d02457bccp0L, 0x0.e59c4175aab6ff7929a8d28719p-104L,
	0x0.d0c5394d772228195e25736c03p0L, 0x0.574707de0af1ca344b13bd3914p-104L,
	0x0.94288e48bd0335fc41c4cbd292p0L, 0x0.0497a8f5d1d8185c99fa0081f9p-104L,
	0x0.cf9b476c897c25c5bfe750dd3fp0L, 0x0.308eaf7bcc1ed00179a256870fp-104L,
	0x0.95c8ef544210ec0b91c49bd2aap0L, 0x0.09e8515fa61a156ebb10f5f8c2p-104L,
	0x0.ce6e171f92f2e27f32225327ecp0L, 0x0.440ddaefae248413efc0e58ceep-104L,
	0x0.9766f93cd18413a6aafc1cfc6fp0L, 0x0.c28abb6817bf94ce349901ae3fp-104L,
	0x0.cd3dad1b5328a2e459f993f4f5p0L, 0x0.108819faccbc4eeba9604e81c7p-104L,
	0x0.9902a58a45e27bed68412b426bp0L, 0x0.675ed503f54d14c8172e0d373fp-104L,
	0x0.cc0a0e21709883a3ff00911e11p0L, 0x0.a07ee3bd7ea2b04e081be99be0p-104L,
	0x0.9a9bedcdf01b38d993f3d78207p0L, 0x0.81de292033ead73b89e28f3931p-104L,
	0x0.cad33f00658fe5e8204bbc0f3ap0L, 0x0.66a0e6a773f87987a780b243d7p-104L,
	0x0.9c32cba2b14156ef05256c4f85p0L, 0x0.7991ca6a547cd7ceb1ac8a8e62p-104L,
	0x0.c99944936cf48c8911ff93fe64p0L, 0x0.b3ddb7981e414bdaf6aae12035p-104L,
	0x0.9dc738ad14204e689ac582d0f8p0L, 0x0.5826590feece34886cfefe2e08p-104L,
	0x0.c85c23c26ed7b6f014ef546c47p0L, 0x0.929682122876bfbf157de0aff3p-104L,
	0x0.9f592e9b66a9cf906a3c7aa3c1p0L, 0x0.0199849040c45ec3f0a7475973p-104L,
	0x0.c71be181ecd6875ce2da5615a0p0L, 0x0.3cca207d9adcb9dfb0a1d6c40ap-104L,
	0x0.a0e8a725d33c828c11fa50fd9ep0L, 0x0.9a15ffecfad43f3e534358076bp-104L,
	0x0.c5d882d2ee48030c7c07d28e98p0L, 0x0.1e34804f82ed4cf93655d23653p-104L,
	0x0.a2759c0e79c35582527c32b55fp0L, 0x0.5405c182c66160cb1d9eb7bb0bp-104L,
	0x0.c4920cc2ec38fb891b38827db0p0L, 0x0.8884fc66371ac4c2052ca8885bp-104L,
	0x0.a400072188acf49cd6b173825ep0L, 0x0.038346f105e1301afe642bcc36p-104L,
	0x0.c348846bbd3631338ffe2bfe9dp0L, 0x0.d1381a35b4e9c0c51b4c13fe37p-104L,
	0x0.a587e23555bb08086d02b9c662p0L, 0x0.cdd29316c3e9bd08d93793634ap-104L,
	0x0.c1fbeef380e4ffdd5a613ec872p0L, 0x0.2f643ffe814ec2343e53adb549p-104L,
	0x0.a70d272a76a8d4b6da0ec90712p0L, 0x0.bb748b96dabf88c3079246f3dbp-104L,
	0x0.c0ac518c8b6ae710ba37a3eeb9p0L, 0x0.0cb15aebcb8bed4356fb507a48p-104L,
	0x0.a88fcfebd9a8dd47e2f3c76ef9p0L, 0x0.e2439920f7e7fbe735f8bcc985p-104L,
	0x0.bf59b17550a440687596929656p0L, 0x0.7cf3e3b4e483061877c02811c6p-104L,
	0x0.aa0fd66eddb921232c28520d39p0L, 0x0.11b8a03193b47f187f1471ac21p-104L,
	0x0.be0413f84f2a771c614946a88cp0L, 0x0.bf4da1d75a5560243de8f2283fp-104L,
	0x0.ab8d34b36acd987210ed343ec6p0L, 0x0.5d7e3adc2e7109fce43d55c8d5p-104L,
	0x0.bcab7e6bfb2a14a9b122c574a3p0L, 0x0.76bec98ab14808c64a4e731b34p-104L,
	0x0.ad07e4c409d08c4fa3a9057bb0p0L, 0x0.ac24b8636e74e76f51e09bd6b2p-104L,
	0x0.bb4ff632a908f73ec151839cb9p0L, 0x0.d993b4e0bfb8f20e7e44e6e4aep-104L,
	0x0.ae7fe0b5fc786b2d966e1d6af1p0L, 0x0.40a488476747c2646425fc7533p-104L,
	0x0.b9f180ba77dd0751628e135a95p0L, 0x0.08299012230f14becacdd14c3fp-104L,
	0x0.aff522a954f2ba16d9defdc416p0L, 0x0.e33f5e9a5dfd5a6c228e0abc4dp-104L,
	0x0.b890237d3bb3c284b614a05390p0L, 0x0.16bfa1053730bbdf940fa895e1p-104L,
	0x0.b167a4c90d63c4244cf5493b7cp0L, 0x0.c23bd3c3c1225e078baa0c53d6p-104L,
	0x0.b72be40067aaf2c050dbdb7a14p0L, 0x0.c3d7d4f203f6b3f0224a4afe55p-104L,
	0x0.b2d7614b1f3aaa24df2d6e20a7p0L, 0x0.7e1ca3e6d838c03e29c1bcb026p-104L,
	0x0.b5c4c7d4f7dae915ac786ccf4bp0L, 0x0.1a498d3e73b6e5e74fe7519d9cp-104L,
	0x0.b44452709a5975290591376543p0L, 0x0.4a59d111f0433eb2b133f7d103p-104L,
	0x0.b45ad4975b1294cadca4cf40ecp0L, 0x0.8f22a68cd14b175835239a37e6p-104L,
	0x0.b5ae7285bc10cf515753847e8fp0L, 0x0.8b7a30e0a580d929d770103509p-104L
};


LIB_FUNC long double __kernel_cosl(const long double numx, const long double numy) {
	long double h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int64_t ix;
	uint32_t tix, hix, index;
	double xhi, hhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	tix = (uint32_t)(((uint64_t)ix) >> 32);
	tix &= (uint32_t)(~0x80000000);
	if (tix < 0x3fc30000) {
		if (tix < 0x3c600000 && (!((int)x))) { return 1.00000000000000000000000000000000000E+00L; }
		z = x * x;
		return 1.00000000000000000000000000000000000E+00L + (z * (-4.99999999999999999999999999999999759E-01L + z * (4.16666666666666666666666666651287795E-02L + z * (-1.38888888888888888888888742314300284E-03L + z * (2.48015873015873015867694002851118210E-05L +  z * (-2.75573192239858811636614709689300351E-07L + z * (2.08767569877762248667431926878073669E-09L + z * (-1.14707451049343817400420280514614892E-11L + z * 4.77810092804389587579843296923533297E-14L))))))));
	} else {
		int six = tix;
		tix = ((six - 0x3ff00000) >> 4) + 0x3fff0000;
		index = 0x3ffe - (tix >> 16);
		hix = (tix + (0x200 << index)) & (0xfffffc00 << index);
		x = fabsl(x);
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		hix = (hix << 4) & 0x3fffffff;
		INSERT_WORDS64(hhi, ((uint64_t)hix) << 32);
		h = hhi;
		l = y - (h - x);
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		return __sincosl_table[index + 0] + (__sincosl_table[index + 1] - (__sincosl_table[index + 2] * sin_l - __sincosl_table[index + 0] * cos_l_m1));
	}
}


LIB_FUNC long double __kernel_sinl(const long double numx, const long double numy, int iy) {
	long double h, l, z, sin_l, cos_l_m1, x = numx, y = numy;
	int64_t ix;
	uint32_t tix, hix, index;
	double xhi, hhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	tix = ((uint64_t)ix) >> 32;
	tix &= (uint32_t)(~0x80000000);
	if (tix < 0x3fc30000) {
		if (tix < 0x3c600000) {
			math_check_force_underflow(x);
			if (!((int)x)) { return x; }
		}
		z = x * x;
		return x + (x * (z * (-1.66666666666666666666666666666666538e-01L + z * (8.33333333333333333333333333307532934e-03L + z * (-1.98412698412698412698412534478712057e-04L + z * (2.75573192239858906520896496653095890e-06L + z * (-2.50521083854417116999224301266655662e-08L + z * (1.60590438367608957516841576404938118e-10L + z * (-7.64716343504264506714019494041582610e-13L + z * 2.81068754939739570236322404393398135e-15L)))))))));
	} else {
		int six = tix;
		tix = ((six - 0x3ff00000) >> 4) + 0x3fff0000;
		index = 0x3ffe - (tix >> 16);
		hix = (tix + (0x200 << index)) & (0xfffffc00 << index);
		x = fabsl(x);
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		hix = (hix << 4) & 0x3fffffff;
		INSERT_WORDS64(hhi, ((uint64_t)hix) << 32);
		h = hhi;
		if (iy) { l = (ix < 0 ? -y : y) - (h - x); }
		else { l = x - h; }
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		z = __sincosl_table[index + 2] + (__sincosl_table[index + 3] + (__sincosl_table[index + 2] * cos_l_m1) + (__sincosl_table[index + 0] * sin_l));
		return (ix < 0) ? -z : z;
	}
}


LIB_FUNC long double cosl(const long double num) {
	long double y[2], z = 0.0L, x = num;
	int64_t n, ix;
	double xhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3fe921fb54442d18LL) { return __kernel_cosl(x, z); }
	else if (ix >= 0x7ff0000000000000LL) {
		if (ix == 0x7ff0000000000000LL) { __set_errno(EDOM); }
		return x - x;
	} else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_cosl(y[0], y[1]);
			case 1:
				return -__kernel_sinl(y[0], y[1], 1);
			case 2:
				return -__kernel_cosl(y[0], y[1]);
			default:
				return  __kernel_sinl(y[0], y[1], 1);
		}
	}
}
#define __cosl(x)   cosl((x))


LIB_FUNC long double sinl(const long double numx) {
	long double y[2], z = 0.0L, x = numx;
	int64_t n, ix;
	double xhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3fe921fb54442d10LL) { return __kernel_sinl(x, z, 0); }
	else if (ix >= 0x7ff0000000000000LL) {
		if (ix == 0x7ff0000000000000LL) { __set_errno(EDOM); }
		return x - x;
	} else {
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				return  __kernel_sinl(y[0], y[1], 1);
			case 1:
				return  __kernel_cosl(y[0], y[1]);
			case 2:
				return -__kernel_sinl(y[0], y[1], 1);
			default:
				return -__kernel_cosl(y[0], y[1]);
		}
	}
}
#define __sinl(x)   sinl((x))


#endif


LIB_FUNC void sincosf(const float x, float* sinx, float* cosx) {
	*sinx = sinf(x);
	*cosx = cosf(x);
}
#define __sincosf(x, sinx, cosx)   sincosf((x), (sinx), (cosx))


LIB_FUNC void sincos(const double x, double* sinx, double* cosx) {
	*sinx = sin(x);
	*cosx = cos(x);
}
#define __sincos(x, sinx, cosx)   sincos((x), (sinx), (cosx))


#if (SIZEOF_LONG_DOUBLE == 96)


LIB_FUNC void sincosl(long double x, long double* sinx, long double* cosx) {
	int32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	se &= 0x7fff;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= 0xc90fdaa2)) {
		*sinx = __kernel_sinl(x, 0.0, 0);
		*cosx = __kernel_cosl(x, 0.0);
	} else if (se == 0x7fff) {
		*sinx = *cosx = x - x;
		if (isinf(x)) { __set_errno(EDOM); }
	} else {
		long double y[2];
		int n;
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				*sinx = __kernel_sinl(y[0], y[1], 1);
				*cosx = __kernel_cosl(y[0], y[1]);
				break;
			case 1:
				*sinx = __kernel_cosl(y[0], y[1]);
				*cosx = -__kernel_sinl(y[0], y[1], 1);
				break;
			case 2:
				*sinx = -__kernel_sinl(y[0], y[1], 1);
				*cosx = -__kernel_cosl(y[0], y[1]);
				break;
			default:
				*sinx = -__kernel_cosl(y[0], y[1]);
				*cosx = __kernel_sinl(y[0], y[1], 1);
				break;
		}
	}
}
#define __sincosl(x, sinx, cosx)   sincosl((x), (sinx), (cosx))


#elif LONG_DOUBLE_IS_BINARY128


LIB_FUNC void __kernel_sincosl(long double x, long double y, long double* sinx, long double* cosx, int iy) {
	long double h, l, z, sin_l, cos_l_m1;
	int64_t ix;
	uint32_t tix, hix, index;
	GET_LDOUBLE_MSW64S(ix, x);
	tix = (uint32_t)(((uint64_t)ix) >> 32);
	tix &= (uint32_t)(~0x80000000);
	if (tix < 0x3ffc3000) {
		if (tix < 0x3fc60000) {
			// math_check_force_underflow(x);
			if (!((int)x)) {
				*sinx = x;
				*cosx = 1.00000000000000000000000000000000000E+00L;
				return;
			}
		}
		z = x * x;
		*sinx = x + (x * (z * (-1.66666666666666666666666666666666538e-01L + z * (8.33333333333333333333333333307532934e-03L + z * (-1.98412698412698412698412534478712057e-04L + z * (2.75573192239858906520896496653095890e-06L + z * (-2.50521083854417116999224301266655662e-08L + z * (1.60590438367608957516841576404938118e-10L + z * (-7.64716343504264506714019494041582610e-13L + z * 2.81068754939739570236322404393398135e-15L)))))))));
		*cosx = 1.00000000000000000000000000000000000E+00L + (z * (-4.99999999999999999999999999999999759E-01L + z * (4.16666666666666666666666666651287795E-02L + z * (-1.38888888888888888888888742314300284E-03L + z * (2.48015873015873015867694002851118210E-05L + z * (-2.75573192239858811636614709689300351E-07L + z * (2.08767569877762248667431926878073669E-09L + z * (-1.14707451049343817400420280514614892E-11L + z * 4.77810092804389587579843296923533297E-14L))))))));
	} else {
		index = 0x3ffe - (tix >> 16);
		hix = (uint32_t)(tix + (uint32_t)(0x200 << index)) & (uint32_t)(0xfffffc00 << index);
		if (signbitl(x)) {
			x = -x;
			y = -y;
		}
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		SET_LDOUBLE_WORDS64(h, (uint64_t)(((uint64_t)hix) << 32), 0);
		if (iy) { l = y - (h - x); }
		else { l = x - h; }
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		z = __sincosl_table[index + 2] + (__sincosl_table[index + 3] + (__sincosl_table[index + 2] * cos_l_m1) + (__sincosl_table[index + 0] * sin_l));
		*sinx = (ix < 0) ? -z : z;
		*cosx = __sincosl_table[index + 0] + (__sincosl_table[index + 1] - (__sincosl_table[index + 2] * sin_l - __sincosl_table[index + 0] * cos_l_m1));
	}
}


LIB_FUNC void sincosl(long double x, long double* sinx, long double* cosx) {
	int64_t ix;
	GET_LDOUBLE_MSW64S(ix, x);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3ffe921fb54442d1LL) { __kernel_sincosl(x, 0.0L, sinx, cosx, 0); }
	else if (ix >= 0x7fff000000000000LL) {
		*sinx = *cosx = x - x;
		if (__isinfl(x)) { __set_errno(EDOM); }
	} else {
		long double y[2];
		int n;
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				__kernel_sincosl(y[0], y[1], sinx, cosx, 1);
				break;
			case 1:
				__kernel_sincosl(y[0], y[1], cosx, sinx, 1);
				*cosx = -*cosx;
				break;
			case 2:
				__kernel_sincosl(y[0], y[1], sinx, cosx, 1);
				*sinx = -*sinx;
				*cosx = -*cosx;
				break;
			default:
				__kernel_sincosl(y[0], y[1], cosx, sinx, 1);
				*sinx = -*sinx;
				break;
		}
	}
}
#define __sincosl(x, sinx, cosx)   sincosl((x), (sinx), (cosx))


#elif SUPPORTS_IBM_LONG_DOUBLE


LIB_FUNC void __kernel_sincosl(long double x, long double y, long double* sinx, long double* cosx, int iy) {
	long double h, l, z, sin_l, cos_l_m1;
	int64_t ix;
	uint32_t tix, hix, index;
	double xhi, hhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	tix = ((uint64_t)ix) >> 32;
	tix &= (~0x80000000);
	if (tix < 0x3fc30000) {
		if (tix < 0x3c600000) {
			math_check_force_underflow(x);
			if (!((int)x)) {
				*sinx = x;
				*cosx = 1.00000000000000000000000000000000000E+00L;
				return;
			}
		}
		z = x * x;
		*sinx = x + (x * (z * (-1.66666666666666666666666666666666538e-01L + z * (8.33333333333333333333333333307532934e-03L + z * (-1.98412698412698412698412534478712057e-04L + z * (2.75573192239858906520896496653095890e-06L + z * (-2.50521083854417116999224301266655662e-08L + z * (1.60590438367608957516841576404938118e-10L + z * (-7.64716343504264506714019494041582610e-13L + z * 2.81068754939739570236322404393398135e-15L)))))))));
		*cosx = 1.00000000000000000000000000000000000E+00L + (z * (-4.99999999999999999999999999999999759E-01L + z * (4.16666666666666666666666666651287795E-02L + z * (-1.38888888888888888888888742314300284E-03L + z * (2.48015873015873015867694002851118210E-05L + z * (-2.75573192239858811636614709689300351E-07L + z * (2.08767569877762248667431926878073669E-09L + z * (-1.14707451049343817400420280514614892E-11L + z * 4.77810092804389587579843296923533297E-14L))))))));
	} else {
		int six = tix;
		tix = ((six - 0x3ff00000) >> 4) + 0x3fff0000;
		index = 0x3ffe - (tix >> 16);
		hix = (tix + (0x200 << index)) & (0xfffffc00 << index);
		x = fabsl(x);
		switch (index) {
			case 0:
				index = ((45 << 10) + hix - 0x3ffe0000) >> 8;
				break;
			case 1:
				index = ((13 << 11) + hix - 0x3ffd0000) >> 9;
				break;
			default:
			case 2:
				index = (hix - 0x3ffc3000) >> 10;
				break;
		}
		hix = (hix << 4) & 0x3fffffff;
		INSERT_WORDS64(hhi, ((uint64_t)hix) << 32);
		h = hhi;
		if (iy) { l = y - (h - x); }
		else { l = x - h; }
		z = l * l;
		sin_l = l * (1.00000000000000000000000000000000000E+00L + z * (-1.66666666666666666666666666666666659E-01L + z * (8.33333333333333333333333333146298442E-03L + z * (-1.98412698412698412697726277416810661E-04L + z * (2.75573192239848624174178393552189149E-06L + z * -2.50521016467996193495359189395805639E-08L)))));
		cos_l_m1 = z * (-5.00000000000000000000000000000000000E-01L + z * (4.16666666666666666666666666556146073E-02L + z * (-1.38888888888888888888309442601939728E-03L + z * (2.48015873015862382987049502531095061E-05L + z * -2.75573112601362126593516899592158083E-07L))));
		z = __sincosl_table[index + 2] + (__sincosl_table[index + 3] + (__sincosl_table[index + 2] * cos_l_m1) + (__sincosl_table[index + 0] * sin_l));
		*sinx = (ix < 0) ? -z : z;
		*cosx = __sincosl_table[index + 0] + (__sincosl_table[index + 1] - (__sincosl_table[index + 2] * sin_l - __sincosl_table[index + 0] * cos_l_m1));
	}
}


LIB_FUNC void sincosl(long double x, long double* sinx, long double* cosx) {
	int64_t ix;
	double xhi;
	xhi = ldbl_high(x);
	EXTRACT_WORDS64(ix, xhi);
	ix &= 0x7fffffffffffffffLL;
	if (ix <= 0x3fe921fb54442d10LL) { __kernel_sincosl(x, 0.0L, sinx, cosx, 0); }
	else if (ix >= 0x7ff0000000000000LL) {
		*sinx = *cosx = x - x;
		if (isinf(x)) { __set_errno(EDOM); }
	} else {
		long double y[2];
		int n;
		n = __ieee754_rem_pio2l(x, y);
		switch (n & 3) {
			case 0:
				__kernel_sincosl(y[0], y[1], sinx, cosx, 1);
				break;
			case 1:
				__kernel_sincosl(y[0], y[1], cosx, sinx, 1);
				*cosx = -*cosx;
				break;
			case 2:
				__kernel_sincosl(y[0], y[1], sinx, cosx, 1);
				*sinx = -*sinx;
				*cosx = -*cosx;
				break;
			default:
				__kernel_sincosl(y[0], y[1], cosx, sinx, 1);
				*sinx = -*sinx;
				break;
		}
	}
}
#define __sincosl(x, sinx, cosx)   sincosl((x), (sinx), (cosx))


#endif


LIB_FUNC float __ieee754_acosf(const float x) {
	float z, p, q, r, w, s, c;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix == 0x3f800000) {
		if (hx > 0) { return 0.0; }
		else { return 3.1415925026e+00F + 2.0F * 7.5497894159e-08F; }
	} else if (ix > 0x3f800000) { return (x - x) / (x - x); }
	else if (ix < 0x3f000000) {
		if (ix <= 0x23000000) { return 1.5707962513e+00F + 7.5497894159e-08F; }
		z = x * x;
		p = z * (1.6666667163e-01F + z * (-3.2556581497e-01F + z * (2.0121252537e-01F + z * (-4.0055535734e-02F + z * (7.9153501429e-04F + z * 3.4793309169e-05F)))));
		q = 1.0F + z * (-2.4033949375e+00F + z * (2.0209457874e+00F + z * (-6.8828397989e-01F + z * 7.7038154006e-02F)));
		r = p / q;
		return 1.5707962513e+00F - (x - (7.5497894159e-08F - x * r));
	} else if (hx < 0) {
		z = (1.0F + x) * 0.5F;
		p = z * (1.6666667163e-01F + z * (-3.2556581497e-01F + z * (2.0121252537e-01F + z * (-4.0055535734e-02F + z * (7.9153501429e-04F + z * 3.4793309169e-05F)))));
		q = 1.0F + z * (-2.4033949375e+00F + z * (2.0209457874e+00F + z * (-6.8828397989e-01F + z * 7.7038154006e-02F)));
		s = __ieee754_sqrtf(z);
		r = p / q;
		w = r * s - (float)(7.5497894159e-08F);
		return 3.1415925026e+00F - 2.0F * (s + w);
	} else {
		int32_t idf;
		z = (1.0F - x) * 0.5F;
		s = __ieee754_sqrtf(z);
		float df = s;
		GET_FLOAT_WORD(idf, df);
		SET_FLOAT_SWORD(df, (idf & (int32_t)0xfffff000));
		c = (z - df * df) / (s + df);
		p = z * (1.6666667163e-01F + z * (-3.2556581497e-01F + z * (2.0121252537e-01F + z * (-4.0055535734e-02F + z * (7.9153501429e-04F + z * 3.4793309169e-05F)))));
		q = 1.0F + z * (-2.4033949375e+00F + z * (2.0209457874e+00F + z * (-6.8828397989e-01F + z * 7.7038154006e-02F)));
		return 2.0F * (df + ((p / q) * s + c));
	}
}


LIB_FUNC double __ieee754_acos(const double x) {
	double z, p, q, r, w, s, c;
	int32_t hx, ix;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x3ff00000) {
		uint32_t lx;
		GET_LOW_WORD(lx, x);
		if (((ix - 0x3ff00000) | (int32_t)lx) == 0) {
			if (hx > 0) { return 0.0; }
			else { return 3.14159265358979311600e+00 + 2.0 * 6.12323399573676603587e-17; }
		}
		return (x - x) / (x - x);
	} else if (ix < 0x3fe00000) {
		if (ix <= 0x3c600000) { return 1.57079632679489655800e+00 + 6.12323399573676603587e-17; }
		z = x * x;
		p = z * (1.66666666666666657415e-01 + z * (-3.25565818622400915405e-01 + z * (2.01212532134862925881e-01 + z * (-4.00555345006794114027e-02 + z * (7.91534994289814532176e-04 + z * 3.47933107596021167570e-05)))));
		q = 1.0 + z * (-2.40339491173441421878e+00 + z * (2.02094576023350569471e+00 + z * (-6.88283971605453293030e-01 + z * 7.70381505559019352791e-02)));
		r = p / q;
		return 1.57079632679489655800e+00 - (x - (6.12323399573676603587e-17 - x * r));
	} else if (hx < 0) {
		z = (1.0 + x) * 0.5;
		p = z * (1.66666666666666657415e-01 + z * (-3.25565818622400915405e-01 + z * (2.01212532134862925881e-01 + z * (-4.00555345006794114027e-02 + z * (7.91534994289814532176e-04 + z * 3.47933107596021167570e-05)))));
		q = 1.0 + z * (-2.40339491173441421878e+00 + z * (2.02094576023350569471e+00 + z * (-6.88283971605453293030e-01 + z * 7.70381505559019352791e-02)));
		s = __ieee754_sqrt(z);
		r = p / q;
		w = r * s - 6.12323399573676603587e-17;
		return 3.14159265358979311600e+00 - 2.0 * (s + w);
	} else {
		z = (1.0 - x) * 0.5;
		s = __ieee754_sqrt(z);
		double df = s;
		SET_LOW_WORD(df, 0);
		c = (z - df * df) / (s + df);
		p = z * (1.66666666666666657415e-01 + z * (-3.25565818622400915405e-01 + z * (2.01212532134862925881e-01 + z * (-4.00555345006794114027e-02 + z * (7.91534994289814532176e-04 + z * 3.47933107596021167570e-05)))));
		q = 1.0 + z * (-2.40339491173441421878e+00 + z * (2.02094576023350569471e+00 + z * (-6.88283971605453293030e-01 + z * 7.70381505559019352791e-02)));
		r = p / q;
		w = r * s + c;
		return 2.0 * (df + w);
	}
}


LIB_FUNC float __ieee754_acoshf(const float x) {
	int32_t hx;
	GET_FLOAT_WORD(hx, x);
	if (hx < 0x3f800000) { return ((x - x) / (x - x)); }
	else if (hx >= 0x4d800000) {
		if (!(FLT_UWORD_IS_FINITE(hx))) { return x + x; }
		else { return __ieee754_logf(x) + 6.9314718246e-01F; }
	} else if (hx == 0x3f800000) { return 0.0; }
	else if (hx > 0x40000000) {
		register float t = x * x;
		return __ieee754_logf((2.0F * x) - 1.0F / (x + __ieee754_sqrtf(t - 1.0F)));
	} else {
		register float t = x - 1.0F;
		return log1pf(t + __ieee754_sqrtf(2.0F * t + t * t));
	}
}


LIB_FUNC double __ieee754_acosh(const double x) {
	int32_t hx, lx;
	EXTRACT_SWORDS(hx, lx, x);
	if (hx < 0x3ff00000) { return (x - x) / (x - x); }
	else if (hx >= 0x41b00000) {
		if (hx >= 0x7ff00000) { return x + x; }
		else { return log(x) + 6.93147180559945286227e-01; }
	} else if (((uint32_t)(hx - 0x3ff00000) | (uint32_t)lx) == 0) { return 0.0; }
	else if (hx > 0x40000000) {
		return log(2.0 * x - 1.0 / (x + __ieee754_sqrt((x * x) - 1.0)));
	} else {
		const double t = x - 1.0;
		return log1p(t + __ieee754_sqrt(2.0 * t + t * t));
	}
}


LIB_FUNC float __ieee754_coshf(const float x) {
	float t;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (!(FLT_UWORD_IS_FINITE(ix))) { return x * x; }
	else if (ix < 0x3eb17218) {
		t = expm1f(fabsf(x));
		const float w = 1.0F + t;
		if (ix < 0x24000000) { return w; }
		return 1.0F + (t * t) / (w + w);
	} else if (ix < 0x41b00000) {
		t = __ieee754_expf(fabsf(x));
		return 0.5F * t + 0.5F / t;
	} else if (ix <= FLT_UWORD_LOG_MAX) { return 0.5F * __ieee754_expf(fabsf(x)); }
	else if (ix <= FLT_UWORD_LOG_2MAX) {
		const float w = __ieee754_expf(0.5F * fabsf(x));
		t = 0.5F * w;
		return t * w;
	}
	return 1.0e30F * 1.0e30F;
}


LIB_FUNC double __ieee754_cosh(const double x) {
	int32_t ix;
	uint32_t lx;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x7ff00000) { return x * x; }
	else if (ix < 0x3fd62e43) {
		const double t = expm1(fabs(x));
		const double w = 1.0 + t;
		if (ix < 0x3c800000) { return w; }
		return 1.0 + (t * t) / (w + w);
	} else if (ix < 0x40360000) {
		const double t = exp(fabs(x));
		return 0.5 * t + 0.5 / t;
	} else if (ix < 0x40862E42) { return 0.5 * exp(fabs(x)); }
	GET_LOW_WORD(lx, x);
	if (ix < 0x408633CE || (ix == 0x408633ce && lx <= (uint32_t)0x8fb9f87d)) {
		const double w = exp(0.5 * fabs(x));
		return (0.5 * w) * w;
	}
	return 1.0e300 * 1.0e300;
}


LIB_FUNC float __ieee754_asinf(const float x) {
	float t, w, p, q, c, r, s;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix == 0x3f800000) {
		return (float)(x * 1.57079637050628662109375F + x * -4.37113900018624283e-8F);
	} else if (ix > 0x3f800000) {
		return (x - x) / (x - x);
	} else if (ix < 0x3f000000) {
		if (ix < 0x32000000) {
			if ((float)(HUGEF + x) > 1.0F) { return x; }
		} else {
			t = x * x;
			p = t * (1.6666667163e-01F + t * (-3.2556581497e-01F + t * (2.0121252537e-01F + t * (-4.0055535734e-02F + t * (7.9153501429e-04F + t * 3.4793309169e-05F)))));
			q = 1.0F + t * (-2.4033949375e+00F + t * (2.0209457874e+00F + t * (-6.8828397989e-01F + t * 7.7038154006e-02F)));
			return x + x * (p / q);
		}
	}
	w = 1.0F - fabsf(x);
	t = w * 0.5F;
	p = t * (1.6666667163e-01F + t * (-3.2556581497e-01F + t * (2.0121252537e-01F + t * (-4.0055535734e-02F + t * (7.9153501429e-04F + t * 3.4793309169e-05F)))));
	q = 1.0F + t * (-2.4033949375e+00F + t * (2.0209457874e+00F + t * (-6.8828397989e-01F + t * 7.7038154006e-02F)));
	s = __ieee754_sqrtf(t);
	if (ix >= 0x3F79999A) {
		w = p / q;
		t = 1.57079637050628662109375F - (2.0F * (s + s * w) - -4.37113900018624283e-8F);
	} else {
		int32_t iw;
		w = s;
		GET_FLOAT_WORD(iw, w);
		SET_FLOAT_WORD(w, (iw & (int32_t)0xfffff000));
		c = (t - w * w) / (s + w);
		r = p / q;
		p = 2.0F * s * r - (-4.37113900018624283e-8F - 2.0F * c);
		q = 0.785398185253143310546875F - 2.0F * w;
		t = 0.785398185253143310546875F - (p - q);
	}
	if (hx > 0) { return t; }
	return -t;
}


LIB_FUNC double __ieee754_asin(const double x) {
	double t, w, p, q, c, r, s;
	int32_t hx, ix;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x3ff00000) {
		uint32_t lx;
		GET_LOW_WORD(lx, x);
		if (((ix - 0x3ff00000) | (int32_t)lx) == 0) { return x * 1.57079632679489655800e+00 + x * 6.12323399573676603587e-17; }
		return (x - x) / (x - x);
	} else if (ix < 0x3fe00000) {
		if (ix < 0x3e400000) {
			if ((double)(HUGE + x) > (double)1.0) { return x; }
		} else {
			t = x * x;
			p = t * (1.66666666666666657415e-01 + t * (-3.25565818622400915405e-01 + t * (2.01212532134862925881e-01 + t * (-4.00555345006794114027e-02 + t * (7.91534994289814532176e-04 + t * 3.47933107596021167570e-05)))));
			q = 1.0 + t * (-2.40339491173441421878e+00 + t * (2.02094576023350569471e+00 + t * (-6.88283971605453293030e-01 + t * 7.70381505559019352791e-02)));
			return x + x * (p / q);
		}
	}
	w = 1.0 - fabs(x);
	t = w * 0.5;
	p = t * (1.66666666666666657415e-01 + t * (-3.25565818622400915405e-01 + t * (2.01212532134862925881e-01 + t * (-4.00555345006794114027e-02 + t * (7.91534994289814532176e-04 + t * 3.47933107596021167570e-05)))));
	q = 1.0 + t * (-2.40339491173441421878e+00 + t * (2.02094576023350569471e+00 + t * (-6.88283971605453293030e-01 + t * 7.70381505559019352791e-02)));
	s = __ieee754_sqrt(t);
	if (ix >= 0x3FEF3333) {
		w = p / q;
		t = 1.57079632679489655800e+00 - (2.0 * (s + s * w) - 6.12323399573676603587e-17);
	} else {
		w = s;
		SET_LOW_WORD(w, 0);
		c = (t - w * w) / (s + w);
		r = p / q;
		p = 2.0 * s * r - (6.12323399573676603587e-17 - 2.0 * c);
		q = 7.85398163397448278999e-01 - 2.0 * w;
		t = 7.85398163397448278999e-01 - (p - q);
	}
	if (hx > 0) { return t; }
	return -t;
}


LIB_FUNC double __ieee754_sinh(const double x) {
	double t, w, h;
	int32_t ix, jx;
	uint32_t lx;
	GET_HIGH_SWORD(jx, x);
	ix = jx & 0x7fffffff;
	if (ix >= 0x7ff00000) { return x + x; }
	h = 0.5;
	if (jx < 0) { h = -h; }
	if (ix < 0x40360000) {
		if (ix < 0x3e300000 && ((double)((double)1.0e307 + x) > 1.0)) { return x; }
		t = expm1(fabs(x));
		if (ix < 0x3ff00000) { return h * (2.0 * t - t * t / (t + 1.0)); }
		return h * (t + t / (t + 1.0));
	} else if (ix < 0x40862E42) { return h * exp(fabs(x)); }
	GET_LOW_WORD(lx, x);
	if (ix < 0x408633CE || (ix == 0x408633ce && lx <= (uint32_t)0x8fb9f87d)) {
		w = exp(0.5 * fabs(x));
		t = h * w;
		return t * w;
	}
	return x * 1.0e307;
}


LIB_FUNC float __ieee754_atanhf(const float num) {
	float x = num;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix > 0x3f800000) { return (x - x) / (x - x); }
	else if (ix == 0x3f800000) { return x / 0.0F; }
	else if ((ix < 0x31800000) && ((1e30F + x) > 0.0F)) { return x; }
	SET_FLOAT_WORD(x, ix);
	register float t;
	if (ix < 0x3f000000) {
		t = x + x;
		t = 0.5F * log1pf(t + t * x / (1.0F - x));
	} else { t = 0.5F * log1pf((x + x) / (1.0F - x)); }
	if (hx >= 0) { return t; }
	return -t;
}


LIB_FUNC double __ieee754_atanh(const double num) {
	double t, x = num;
	int32_t hx, ix, lx;
	EXTRACT_SWORDS(hx, lx, x);
	ix = hx & 0x7fffffff;
	if ((ix | ((lx | (-lx)) >> 31)) > 0x3ff00000) { return (x - x) / (x - x); }
	else if (ix == 0x3ff00000) { return x / 0.0; }
	else if (ix < 0x3e300000 && (1e300 + x) > 0.0) { return x; }
	SET_HIGH_WORD(x, ix);
	if (ix < 0x3fe00000) {
		t = x + x;
		t = 0.5 * log1p(t + t * x / (1.0 - x));
	} else { t = 0.5 * log1p((x + x) / (1.0 - x)); }
	if (hx >= 0) { return t; }
	return -t;
}


LIB_FUNC float __ieee754_atan2f(const float y, float x) {
	float z;
	int32_t k, hx, hy, ix, iy;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	GET_FLOAT_WORD(hy, y);
	iy = hy & 0x7fffffff;
	if (FLT_UWORD_IS_NAN(ix) || FLT_UWORD_IS_NAN(iy)) { return x + y; }
	else if (hx == 0x3f800000) { return atanf(y); }
	const int32_t m = ((hy >> 31) & 1) | ((hx >> 30) & 2);
	if (FLT_UWORD_IS_ZERO(iy)) {
		switch (m) {
			case 0:
			case 1:
				return y;
			case 2:
				return 3.1415927410e+00F + TINYF;
			default:  // case 3
				return -3.1415927410e+00F - TINYF;
		}
	} else if (FLT_UWORD_IS_ZERO(ix)) { return (hy < 0) ? (-1.5707963705e+00F - TINYF) : (1.5707963705e+00F + TINYF); }
	else if (FLT_UWORD_IS_INFINITE(ix)) {
		if (FLT_UWORD_IS_INFINITE(iy)) {
			switch (m) {
				case 0:
					return 7.8539818525e-01F + TINYF;
				case 1:
					return -7.8539818525e-01F - TINYF;
				case 2:
					return 3.0F * 7.8539818525e-01F + TINYF;
				default:  // case 3
					return -3.0F * 7.8539818525e-01F - TINYF;
			}
		} else {
			switch (m) {
				case 0:
					return 0.0F ;
				case 1:
					return -0.0F ;
				case 2:
					return 3.1415927410e+00F + TINYF;
				default:  // case 3
					return -3.1415927410e+00F - TINYF;
			}
		}
	}
	if (FLT_UWORD_IS_INFINITE(iy)) { return (hy < 0) ? -1.5707963705e+00F - TINYF : 1.5707963705e+00F + TINYF; }
	k = (iy - ix) >> 23;
	if (k > 60) { z = 1.5707963705e+00F + 0.5F * -8.7422776573e-08F; }
	else if (hx < 0 && k < -60) { z = 0.0F; }
	else { z = atanf(fabsf(y / x)); }
	UNUSED uint32_t zh;
	switch (m) {
		case 0:
			return z ;
		case 1:
			GET_FLOAT_UWORD(zh, z);
			SET_FLOAT_UWORD(z, (zh ^ 0x80000000));
			return z ;
		case 2:
			return 3.1415927410e+00F - (z - -8.7422776573e-08F);
		default:
			return (z - -8.7422776573e-08F) - 3.1415927410e+00F;
	}
}


LIB_FUNC double __ieee754_atan2(const double y, double x) {
	double z;
	int32_t k, hx, hy, ix, lx, iy, ly;
	EXTRACT_SWORDS(hx, lx, x);
	ix = hx & 0x7fffffff;
	EXTRACT_SWORDS(hy, ly, y);
	iy = hy & 0x7fffffff;
	if ((((uint32_t)ix | (((uint32_t)lx | (uint32_t)-lx) >> 31)) > 0x7ff00000) || (((uint32_t)iy | (((uint32_t)ly | (uint32_t)-ly) >> 31)) > 0x7ff00000)) { return x + y; }
	else if (((uint32_t)(hx - 0x3ff00000) | (uint32_t)lx) == 0) { return atan(y); }
	const int32_t m = ((hy >> 31) & 1) | ((hx >> 30) & 2);
	if ((iy | ly) == 0) {
		switch (m) {
			case 0:
			case 1:
				return y;
			case 2:
				return 3.1415926535897931160 + 1.0e-300;
			default:  // case 3
				return -3.1415926535897931160 - 1.0e-300;
		}
	} else if ((ix | lx) == 0) { return (hy < 0) ? -1.5707963267948965580 - 1.0e-300 : 1.5707963267948965580 + 1.0e-300; }
	if (ix == 0x7ff00000) {
		if (iy == 0x7ff00000) {
			switch (m) {
				case 0:
					return 7.8539816339744827900E-01 + 1.0e-300;
				case 1:
					return -7.8539816339744827900E-01 - 1.0e-300;
				case 2:
					return 3.0 * 7.8539816339744827900E-01 + 1.0e-300;
				default:  // case 3
					return -3.0 * 7.8539816339744827900E-01 - 1.0e-300;
			}
		} else {
			switch (m) {
				case 0:
					return 0.0 ;
				case 1:
					return -0.0 ;
				case 2:
					return 3.1415926535897931160E+00 + 1.0e-300 ;
				default:  // case 3
					return -3.1415926535897931160E+00 - 1.0e-300 ;
			}
		}
	}
	if (iy == 0x7ff00000) { return (hy < 0) ? -1.5707963267948965580 - 1.0e-300 : 1.5707963267948965580 + 1.0e-300; }
	k = (iy - ix) >> 20;
	if (k > 60) { z = 1.5707963267948965580 + 0.5 * 1.2246467991473531772E-16; }
	else if (hx < 0 && k < -60) { z = 0.0; }
	else { z = atan(fabs(y / x)); }
	UNUSED uint32_t zh;
	switch (m) {
		case 0:
			return z ;
		case 1:
			GET_HIGH_WORD(zh, z);
			SET_HIGH_WORD(z, (zh ^ 0x80000000));
			return z ;
		case 2:
			return 3.1415926535897931160 - (z - 1.2246467991473531772E-16);
		default:
			return (z - 1.2246467991473531772E-16) - 3.1415926535897931160;
	}
}


#if SUPPORTS_LONG_DOUBLE
LIB_FUNC long double atan2l(const long double y, long double x) {
	return (long double)__ieee754_atan2((double)y, (double)x);
}
#endif


LIB_FUNC float acosf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_acosf(x);
#else
	struct exception exc;
	float z = __ieee754_acosf(x);
	if (__isnanf(x)) { return z; }
	else if (fabsf(x) > 1.0F) {
		exc.type = DOMAIN;
		exc.name = "acosf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = nan("");
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double acos(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_acos(x);
#else
	struct exception exc;
	double z = __ieee754_acos(x);
	if (__isnan(x)) { return z; }
	else if (fabs(x) > 1.0) {
		exc.type = DOMAIN;
		exc.name = "acos";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = nan("");
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double acosl(const long double x) {
	return (long double)acos((double)x);
}


LIB_FUNC float acoshf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_acoshf(x);
#else
	struct exception exc;
	float z = __ieee754_acoshf(x);
	if (__isnanf(x)) { return z; }
	else if (x < 1.0F) {
		exc.type = DOMAIN;
		exc.name = "acoshf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = 0.0 / 0.0;
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double acosh(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_acosh(x);
#else
	struct exception exc;
	double z = __ieee754_acosh(x);
	if (__isnan(x)) { return z; }
	else if (x < 1.0) {
		exc.type = DOMAIN;
		exc.name = "acosh";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = 0.0 / 0.0;
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double acoshl(const long double x) {
	return (long double)acosh((double)x);
}


LIB_FUNC float cosf(const float x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	float r = x;
	asm ("fld %0;" "fcos;" "fstp %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	float y[2];
	int32_t n, ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3f490fd8) { return __kernel_cosf(x, 0.0F); }
	else if (!FLT_UWORD_IS_FINITE(ix)) { return x - x; }
	else {
		n = __rem_pio2f(x, (double*)&y);
		switch ((n & 3)) {
			case 0:
				return __kernel_cosf(y[0], y[1]);
			case 1:
				return -__kernel_sinf(y[0], y[1], 1);
			case 2:
				return -__kernel_cosf(y[0], y[1]);
			default:
				return __kernel_sinf(y[0], y[1], 1);
		}
	}
#   endif
}


LIB_FUNC double cos(const double x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	double r = x;
	asm ("fldl %0;" "fcos;" "fstpl %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	double y[2];
	int32_t n, ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3fe921fb) { return __kernel_cos(x, 0.0); }
	else if (ix >= 0x7ff00000) { return x - x; }
	else {
		n = __ieee754_rem_pio2(x, y);
		switch ((n & 3)) {
			case 0:
				return __kernel_cos(y[0], y[1]);
			case 1:
				return -__kernel_sin(y[0], y[1], 1);
			case 2:
				return -__kernel_cos(y[0], y[1]);
			default:
				return __kernel_sin(y[0], y[1], 1);
		}
	}
#  endif
}


LIB_FUNC float coshf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_coshf(x);
#else
	struct exception exc;
	float z = __ieee754_coshf(x);
	if (__isnanf(x)) { return z; }
	else if (fabsf(x) > (float)8.9415985107e+01) {
		exc.type = OVERFLOW;
		exc.name = "coshf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = HUGE_VAL;
		if (!matherr(&exc)) { errno = ERANGE; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double cosh(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_cosh(x);
#else
	struct exception exc;
	double z = __ieee754_cosh(x);
	if (__isnan(x)) { return z; }
	else if (fabs(x) > 7.10475860073943863426e+02) {
		exc.type = OVERFLOW;
		exc.name = "cosh";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = HUGE_VAL;
		if (!matherr(&exc)) { errno = ERANGE; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double coshl(const long double x) {
	return (long double)cosh((double)x);
}


LIB_FUNC float asinf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_asinf(x);
#else
	struct exception exc;
	float z = __ieee754_asinf(x);
	if (__isnanf(x)) { return z; }
	else if (fabsf(x) > 1.0F) {
		exc.type = DOMAIN;
		exc.name = "asinf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = nan("");
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double asin(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_asin(x);
#else
	struct exception exc;
	double z = __ieee754_asin(x);
	if (__isnan(x)) { return z; }
	else if (fabs(x) > 1.0) {
		exc.type = DOMAIN;
		exc.name = "asin";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = nan("");
		if (!matherr(&exc)) { errno = EDOM; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double asinl(const long double x) {
	return (long double)asin((double)x);
}


LIB_FUNC float asinhf(const float x) {
	float t, w;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (!FLT_UWORD_IS_FINITE(ix)) { return x + x; }
	else if (ix < 0x31800000 && ((float)1.0e+30 + x > 1.0F)) { return x; }
	if (ix > 0x4d800000) {
		w = __ieee754_logf(fabsf(x)) + (float)6.9314718246e-01;
	} else if (ix > 0x40000000) {
		t = fabsf(x);
		w = __ieee754_logf(2.0F * t + 1.0F / (__ieee754_sqrtf(x * x + 1.0F) + t));
	} else {
		t = x * x;
		w = log1pf(fabsf(x) + t / (1.0F + __ieee754_sqrtf(1.0F + t)));
	}
	if (hx > 0) { return w; }
	else { return -w; }
}


LIB_FUNC double asinh(const double x) {
	double t, w;
	int32_t hx, ix;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x7ff00000) { return x + x; }
	else if (ix < 0x3e300000 && (1.0e+300 + x > 1.0)) { return x; }
	if (ix > 0x41b00000) {
		w = log(fabs(x)) + 6.93147180559945286227e-01;
	} else if (ix > 0x40000000) {
		t = fabs(x);
		w = log(2.0 * t + 1.0 / (__ieee754_sqrt(x * x + 1.0) + t));
	} else {
		t = x * x;
		w = log1p(fabs(x) + t / (1.0 + __ieee754_sqrt(1.0 + t)));
	}
	if (hx > 0) { return w; }
	else { return -w; }
}


LIB_FUNC long double asinhl(const long double x) {
	return (long double)asinh((double)x);
}


LIB_FUNC float sinf(const float x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	float r = x;
	asm ("fld %0;" "fsin;" "fstp %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	float y[2];
	int32_t n, ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3f490fd8) { return __kernel_sinf(x, 0.0F, 0); }
	else if (!FLT_UWORD_IS_FINITE(ix)) { return x - x; }
	else {
		n = __rem_pio2f(x, (double*)&y);
		switch (n & 3) {
			case 0:
				return __kernel_sinf(y[0], y[1], 1);
			case 1:
				return __kernel_cosf(y[0], y[1]);
			case 2:
				return -__kernel_sinf(y[0], y[1], 1);
			default:
				return -__kernel_cosf(y[0], y[1]);
		}
	}
#   endif
}


LIB_FUNC double sin(const double x) {
#   if (defined(ARCHX86_64) || defined(ARCHX86))
	double r = x;
	asm ("fldl %0;" "fsin;" "fstpl %1;" : "=m"(r) : "m"(r));
	return r;
#   else
	double y[2];
	int32_t n, ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3fe921fb) { return __kernel_sin(x, 0.0, 0); }
	else if (ix >= 0x7ff00000) { return x - x; }
	else {
		n = __ieee754_rem_pio2(x, y);
		switch (n & 3) {
			case 0:
				return __kernel_sin(y[0], y[1], 1);
			case 1:
				return __kernel_cos(y[0], y[1]);
			case 2:
				return -__kernel_sin(y[0], y[1], 1);
			default:
				return -__kernel_cos(y[0], y[1]);
		}
	}
#   endif
}


LIB_FUNC float __ieee754_sinhf(const float num) {
	float t, w, h, x = num;
	int32_t ix, jx;
	GET_FLOAT_WORD(jx, x);
	ix = jx & 0x7fffffff;
	if (PREDICT_UNLIKELY(ix >= 0x7f800000)) { return x + x; }
	h = 0.5F;
	if (jx < 0) { h = -h; }
	if (ix < 0x41b00000) {
		if (PREDICT_UNLIKELY(ix < 0x31800000)) {
			// math_check_force_underflow(x);
			if (1.0e37F + x > 1.0F) { return x; }
		}
		t = expm1f(fabsf(x));
		if (ix < 0x3f800000) { return h * ((float)2.0F * t - t * t / (t + 1.0F)); }
		return h * (t + t / (t + 1.0F));
	}
	if (ix < 0x42b17180) { return h * __ieee754_expf(fabsf(x)); }
	else if (ix <= 0x42b2d4fc) {
		w = __ieee754_expf((float)0.5F * fabsf(x));
		t = h * w;
		return t * w;
	}
	return math_narrow_eval(x * 1.0e37F);
}
#define __sinhf_finite(x)   __ieee754_sinhf((x))


LIB_FUNC float sinhf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_sinhf(x);
#else
	struct exception exc;
	float z = __ieee754_sinhf(x);
	if (!finitef(z) && finitef(x)) {
		exc.type = OVERFLOW;
		exc.name = "sinhf";
		exc.err = 0;
		exc.arg1 = exc.arg2 = (double)x;
		exc.retval = ((x > 0.0F) ? HUGE_VAL : -HUGE_VAL);
		if (!matherr(&exc)) { errno = ERANGE; }
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double sinh(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_sinh(x);
#else
	struct exception exc;
	double z = __ieee754_sinh(x);
	if (!finite(z) && finite(x)) {
		exc.type = OVERFLOW;
		exc.name = "sinh";
		exc.err = 0;
		exc.arg1 = exc.arg2 = x;
		exc.retval = ( (x > 0.0) ? HUGE_VAL : -HUGE_VAL);
		if (!matherr(&exc)) { errno = ERANGE; }
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double sinhl(const long double x) {
	return (long double)sinh((double)x);
}


/** Return the Pi Sine of the given number; return 0.0 on error */
LIB_FUNC double sinpi(const double num) {
	register double r;
	if (!(isfinite(num))) { return 0.0; }
	register double x = fmod(fabs(num), 2.0);
	register slint n = (slint)lround(2.0 * x);
	switch (n) {
		case 0:
			r = sin(PI * x);
			break;
		case 1:
			r = cos(PI * (x - 0.5));
			break;
		case 2:
			r = sin(PI * (1.0 - x));
			break;
		case 3:
			r = (-cos(PI * (x - 1.5)));
			break;
		case 4:
			r = sin(PI * (x - 2.0));
			break;
		default:  // Should never get here
			r = 0.0;
			break;
	}
	return (copysign(1.0, num) * r);
}


LIB_FUNC float tanf(const float x) {
	float y[2];
	int32_t n, ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3f490fda) { return __kernel_tanf(x, 0.0F, 1); }
	else if (!FLT_UWORD_IS_FINITE(ix)) { return x - x; }
	else {
		n = __ieee754_rem_pio2f(x, (double*)&y);
		return __kernel_tanf(y[0], y[1], 1 - ((n & 1) << 1));
	}
}


LIB_FUNC double tan(const double x) {
	double y[2];
	int32_t n, ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix <= 0x3fe921fb) { return __kernel_tan(x, 0.0, 1); }
	else if (ix >= 0x7ff00000) { return x - x; }
	else {
		n = __ieee754_rem_pio2(x, y);
		return __kernel_tan(y[0], y[1], 1 - ((n & 1) << 1));
	}
}


LIB_FUNC long double tanl(const long double x) {
	return (long double)tan((double)x);
}


LIB_FUNC float atanf(const float num) {
	float w, z, x = num;
	int32_t ix, hx, idx;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	static const float atanhi[4] = {
		4.6364760399e-01F, 7.8539812565e-01F,
		9.8279368877e-01F, 1.5707962513e+00F
	};
	static const float atanlo[4] = {
		5.0121582440e-09F, 3.7748947079e-08F,
		3.4473217170e-08F, 7.5497894159e-08F
	};
	static const float aT[16] = {
		3.3333334327e-01F, -2.0000000298e-01F, 1.4285714924e-01F,
		-1.1111110449e-01F, 9.0908870101e-02F, -7.6918758452e-02F,
		6.6610731184e-02F, -5.8335702866e-02F, 4.9768779427e-02F,
		-3.6531571299e-02F, 1.6285819933e-02F
	};
	if (ix >= 0x50800000) {
		if (FLT_UWORD_IS_NAN(ix)) { return x + x; }
		else if (hx > 0) { return atanhi[3] + atanlo[3]; }
		else { return -atanhi[3] - atanlo[3]; }
	}
	if (ix < 0x3ee00000) {
		if (ix < 0x31000000 && (HUGEF + x > 1.0F)) { return x; }
		idx = -1;
	} else {
		x = fabsf(x);
		if (ix < 0x3f980000) {
			if (ix < 0x3f300000) {
				idx = 0;
				x = (2.0F * x - 1.0F) / (2.0F + x);
			} else {
				idx = 1;
				x = (x - 1.0F) / (x + 1.0F);
			}
		} else {
			if (ix < 0x401c0000) {
				idx = 2;
				x = (x - 1.5F) / (1.0F + 1.5F * x);
			} else {
				idx = 3;
				x = -1.0F / x;
			}
		}
	}
	z = x * x;
	w = z * z;
	const float s1 = z * (aT[0] + w * (aT[2] + w * (aT[4] + w * (aT[6] + w * (aT[8] + w * aT[10])))));
	const float s2 = w * (aT[1] + w * (aT[3] + w * (aT[5] + w * (aT[7] + w * aT[9]))));
	if (idx < 0) { return x - x * (s1 + s2); }
	else {
		z = atanhi[idx] - ((x * (s1 + s2) - atanlo[idx]) - x);
		return (hx < 0) ? -z : z;
	}
}


LIB_FUNC double atan(const double num) {
	double w, z, x = num;
	int32_t ix, hx, idx;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	static const double atanhi[4] = {
		4.63647609000806093515e-01, 7.85398163397448278999e-01,
		9.82793723247329054082e-01, 1.57079632679489655800e+00
	};
	static const double atanlo[4] = {
		2.26987774529616870924e-17, 3.06161699786838301793e-17,
		1.39033110312309984516e-17, 6.12323399573676603587e-17
	};
	static const double aT[16] = {
		3.33333333333329318027e-01, -1.99999999998764832476e-01, 1.42857142725034663711e-01,
		-1.11111104054623557880e-01, 9.09088713343650656196e-02, -7.69187620504482999495e-02,
		6.66107313738753120669e-02, -5.83357013379057348645e-02, 4.97687799461593236017e-02,
		-3.65315727442169155270e-02, 1.62858201153657823623e-02
	};
	if (ix >= 0x44100000) {
		uint32_t low;
		GET_LOW_WORD(low, x);
		if (ix > 0x7ff00000 || (ix == 0x7ff00000 && (low != 0))) { return x + x; }
		else if (hx > 0) { return atanhi[3] + atanlo[3]; }
		else { return -atanhi[3] - atanlo[3]; }
	}
	if (ix < 0x3fdc0000) {
		if (ix < 0x3e200000 && (1.0e300 + x > 1.0)) { return x; }
		idx = -1;
	} else {
		x = fabs(x);
		if (ix < 0x3ff30000) {
			if (ix < 0x3fe60000) {
				idx = 0;
				x = (2.0 * x - 1.0) / (2.0 + x);
			} else {
				idx = 1;
				x = (x - 1.0) / (x + 1.0);
			}
		} else {
			if (ix < 0x40038000) {
				idx = 2;
				x = (x - 1.5) / (1.0 + 1.5 * x);
			} else {
				idx = 3;
				x = -1.0 / x;
			}
		}
	}
	z = x * x;
	w = z * z;
	const double s1 = z * (aT[0] + w * (aT[2] + w * (aT[4] + w * (aT[6] + w * (aT[8] + w * aT[10])))));
	const double s2 = w * (aT[1] + w * (aT[3] + w * (aT[5] + w * (aT[7] + w * aT[9]))));
	if (idx < 0) { return x - x * (s1 + s2); }
	else {
		z = atanhi[idx] - ((x * (s1 + s2) - atanlo[idx]) - x);
		return (hx < 0) ? -z : z;
	}
}


LIB_FUNC long double atanl(const long double num) {
	return (long double)atan((double)num);
}


LIB_FUNC float atan2f(const float y, const float x) {
	return __ieee754_atan2f(y, x);
}


LIB_FUNC double atan2(const double y, const double x) {
	return __ieee754_atan2(y, x);
}


/** Returns the principal value of the arc tangent of y/x, expressed in radians */
LIB_FUNC double ATAN2(const double y, const double x) {
	if (__isnan(x) || __isnan(y)) { return NAN; }
	else if (__isinf(y)) {
		if (__isinf(x)) {
			if (copysign(1.0, x) == 1.0) { return copysign(0.25 * PI, y); }  // atan2(+-inf, +inf) == +-pi/4
			else { return copysign(0.75 * PI, y); }  // atan2(+-inf, -inf) == +-pi*3/4
		}
		return copysign(0.5 * PI, y);  // atan2(+-inf, x) == +-pi/2 for finite x
	}
	if (__isinf(x) || y == 0.0) {
		if (copysign(1.0, x) == 1.0) { return copysign(0.0, y); }  // atan2(+-y, +inf) = atan2(+-0, +x) = +-0.0
		else { return copysign(PI, y); }  // atan2(+-y, -inf) = atan2(+-0., -x) = +-pi
	}
	return atan2(y, x);
}


LIB_FUNC float atanhf(const float x) {
#ifdef _IEEE_LIBM
	return __ieee754_atanhf(x);
#else
	struct exception exc;
	const float z = __ieee754_atanhf(x);
	if (__isnanf(x)) { return z; }
	const float y = fabsf(x);
	if (y >= 1.0F) {
		if (y > 1.0F) {
			exc.type = DOMAIN;
			exc.name = "atanhf";
			exc.err = 0;
			exc.arg1 = exc.arg2 = (double)x;
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { errno = EDOM; }
		} else {
			exc.type = SING;
			exc.name = "atanhf";
			exc.err = 0;
			exc.arg1 = exc.arg2 = (double)x;
			exc.retval = x / 0.0F;
			if (!matherr(&exc)) { errno = EDOM; }
		}
		if (exc.err != 0) { errno = exc.err; }
		return (float)exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC double atanh(const double x) {
#ifdef _IEEE_LIBM
	return __ieee754_atanh(x);
#else
	struct exception exc;
	double z = __ieee754_atanh(x);
	if (__isnan(x)) { return z; }
	const double y = fabs(x);
	if (y >= 1.0) {
		if (y > 1.0) {
			exc.type = DOMAIN;
			exc.name = "atanh";
			exc.err = 0;
			exc.arg1 = exc.arg2 = x;
			exc.retval = 0.0 / 0.0;
			if (!matherr(&exc)) { errno = EDOM; }
		} else {
			exc.type = SING;
			exc.name = "atanh";
			exc.err = 0;
			exc.arg1 = exc.arg2 = x;
			exc.retval = x / 0.0;
			if (!matherr(&exc)) { errno = EDOM; }
		}
		if (exc.err != 0) { errno = exc.err; }
		return exc.retval;
	} else { return z; }
#endif
}


LIB_FUNC long double atanhl(const long double x) {
	return (long double)atanh((double)x);
}


LIB_FUNC float tanhf(const float x) {
	float t, z;
	int32_t jx, ix;
	GET_FLOAT_WORD(jx, x);
	ix = jx & 0x7fffffff;
	if (!FLT_UWORD_IS_FINITE(ix)) {
		if (jx >= 0) { return 1.0F / x + 1.0F; }
		else { return 1.0F / x - 1.0F; }
	} else if (ix < 0x41b00000) {
		if (ix < 0x24000000) { return x * (1.0F + x); }
		else if (ix >= 0x3f800000) {
			t = expm1f(2.0F * fabsf(x));
			z = 1.0F - 2.0F / (t + 2.0F);
		} else {
			t = expm1f(-2.0F * fabsf(x));
			z = -t / (t + 2.0F);
		}
	} else { z = 1.0F - (float)1.0e-30; }
	return (jx >= 0) ? z : -z;
}


LIB_FUNC double tanh(const double x) {
	double t, z;
	int32_t jx, ix;
	GET_HIGH_SWORD(jx, x);
	ix = jx & 0x7fffffff;
	if (ix >= 0x7ff00000) {
		if (jx >= 0) { return 1.0 / x + 1.0; }
		else { return 1.0 / x - 1.0; }
	} else if (ix < 0x40360000) {
		if (ix < 0x3c800000) { return x * (1.0 + x); }
		else if (ix >= 0x3ff00000) {
			t = expm1(2.0 * fabs(x));
			z = 1.0 - 2.0 / (t + 2.0);
		} else {
			t = expm1(-2.0 * fabs(x));
			z = -t / (t + 2.0);
		}
	} else { z = 1.0 - 1.0e-300; }
	return (jx >= 0) ? z : -z;
}


LIB_FUNC long double tanhl(const long double x) {
	return (long double)tanh((double)x);
}


/** Return the Chord */
LIB_FUNC float crdf(const float radians) {
	return ((float)2.0F * sinf(radians / (float)2.0F));
}


/** Return the Chord */
LIB_FUNC double crd(const double radians) {
	return ((double)2.0 * sin(radians / (double)2.0));
}


/** Return the Chord */
LIB_FUNC long double crdl(const long double radians) {
	return ((long double)2.0L * sinl(radians / (long double)2.0L));
}


LIB_FUNC float __ieee754_hypotf(const float x, const float y) {
	int32_t ha, hb;
	GET_FLOAT_WORD(ha, x);
	ha &= 0x7fffffff;
	GET_FLOAT_WORD(hb, y);
	hb &= 0x7fffffff;
	if (ha == 0x7f800000) { return fabsf(x); }
	else if (hb == 0x7f800000) { return fabsf(y); }
	else if (ha > 0x7f800000 || hb > 0x7f800000) { return fabsf(x) * fabsf(y); }
	else if (ha == 0) { return fabsf(y); }
	else if (hb == 0) { return fabsf(x); }
	double d_x = (double)x, d_y = (double)y;
	return (float)__ieee754_sqrt(d_x * d_x + d_y * d_y);
}
#define __hypotf_finite(x, y)   __ieee754_hypotf((x), (y))


LIB_FUNC double __ieee754_hypot(const double x, const double y) {
	double a, b, t1, t2, y1, y2, w;
	int32_t j, k, ha, hb;
	GET_HIGH_SWORD(ha, x);
	ha &= 0x7fffffff;
	GET_HIGH_SWORD(hb, y);
	hb &= 0x7fffffff;
	if (hb > ha) {
		a = y;
		b = x;
		j = ha;
		ha = hb;
		hb = j;
	} else {
		a = x;
		b = y;
	}
	SET_HIGH_WORD(a, ha);
	SET_HIGH_WORD(b, hb);
	if ((ha - hb) > 0x3c00000) { return a + b; }
	k = 0;
	if (PREDICT_UNLIKELY(ha > 0x5f300000)) {
		if (ha >= 0x7ff00000) {
			uint32_t low;
			w = a + b;
			GET_LOW_WORD(low, a);
			if (((ha & 0xfffff) | low) == 0) { w = a; }
			GET_LOW_WORD(low, b);
			if (((uint32_t)(hb ^ 0x7ff00000) | low) == 0) { w = b; }
			return w;
		}
		ha -= 0x25800000;
		hb -= 0x25800000;
		k += 600;
		SET_HIGH_WORD(a, ha);
		SET_HIGH_WORD(b, hb);
	}
	if (PREDICT_UNLIKELY(hb < 0x23d00000)) {
		if (hb <= 0xfffff) {
			uint32_t low;
			GET_LOW_WORD(low, b);
			if (((uint32_t)hb | low) == 0) { return a; }
			t1 = 0;
			SET_HIGH_WORD(t1, 0x7fd00000);
			b *= t1;
			a *= t1;
			k -= 1022;
			GET_HIGH_SWORD(ha, a);
			GET_HIGH_SWORD(hb, b);
			if (hb > ha) {
				t1 = a;
				a = b;
				b = t1;
				j = ha;
				ha = hb;
				hb = j;
			}
		} else {
			ha += 0x25800000;
			hb += 0x25800000;
			k -= 600;
			SET_HIGH_WORD(a, ha);
			SET_HIGH_WORD(b, hb);
		}
	}
	w = a - b;
	if (w > b) {
		t1 = 0;
		SET_HIGH_WORD(t1, ha);
		t2 = a - t1;
		w = __ieee754_sqrt(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else {
		a = a + a;
		y1 = 0;
		SET_HIGH_WORD(y1, hb);
		y2 = b - y1;
		t1 = 0;
		SET_HIGH_WORD(t1, (ha + 0x100000));
		t2 = a - t1;
		w = __ieee754_sqrt(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0) {
		uint32_t high;
		t1 = 1.0;
		GET_HIGH_WORD(high, t1);
		SET_HIGH_WORD(t1, (high + (uint32_t)(k << 20)));
		w *= t1;
		math_check_force_underflow_nonneg(w);
		return w;
	} else { return w; }
}
#define __hypot_finite(x, y)   __ieee754_hypot((x), (y))


#if (SIZEOF_LONG_DOUBLE == 96)
LIB_FUNC long double __ieee754_hypotl(const long double x, const long double y) {
	long double a, b, t1, t2, y1, y2, w;
	uint32_t j, k, ea, eb;
	GET_LDOUBLE_EXP(ea, x);
	ea &= 0x7fff;
	GET_LDOUBLE_EXP(eb, y);
	eb &= 0x7fff;
	if (eb > ea) { a = y; b = x; j = ea; ea = eb; eb = j; }
	else {a = x; b = y;}
	SET_LDOUBLE_EXP(a, ea);
	SET_LDOUBLE_EXP(b, eb);
	if ((ea - eb) > 0x46) { return a + b; }
	k = 0;
	if (PREDICT_UNLIKELY(ea > 0x5f3f)) {
		if (ea == 0x7fff) {
			uint32_t exp, high, low;
			w = a + b;
			GET_LDOUBLE_WORDS(exp, high, low, a);
			if (((high & 0x7fffffff) | low) == 0) { w = a; }
			GET_LDOUBLE_WORDS(exp, high, low, b);
			if (((eb ^ 0x7fff) | (high & 0x7fffffff) | low) == 0) { w = b; }
			return w;
		}
		ea -= 0x2580;
		eb -= 0x2580;
		k += 9600;
		SET_LDOUBLE_EXP(a, ea);
		SET_LDOUBLE_EXP(b, eb);
	}
	if (PREDICT_UNLIKELY(eb < 0x20bf)) {
		if (eb == 0) {
			uint32_t exp, high, low;
			GET_LDOUBLE_WORDS(exp, high, low, b);
			if ((high | low) == 0) { return a; }
			SET_LDOUBLE_WORDS(t1, 0x7ffd, 0x80000000, 0);
			b *= t1;
			a *= t1;
			k -= 16382;
			GET_LDOUBLE_EXP(ea, a);
			GET_LDOUBLE_EXP(eb, b);
			if (eb > ea) {
				t1 = a;
				a = b;
				b = t1;
				j = ea;
				ea = eb;
				eb = j;
			}
		} else {
			ea += 0x2580;
			eb += 0x2580;
			k -= 9600;
			SET_LDOUBLE_EXP(a, ea);
			SET_LDOUBLE_EXP(b, eb);
		}
	}
	w = a - b;
	if (w > b) {
		uint32_t high;
		GET_LDOUBLE_MSW(high, a);
		SET_LDOUBLE_WORDS(t1, ea, high, 0);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else {
		uint32_t high;
		GET_LDOUBLE_MSW(high, b);
		a = a + a;
		SET_LDOUBLE_WORDS(y1, eb, high, 0);
		y2 = b - y1;
		GET_LDOUBLE_MSW(high, a);
		SET_LDOUBLE_WORDS(t1, ea + 1, high, 0);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0) {
		uint32_t exp;
		t1 = 1.0;
		GET_LDOUBLE_EXP(exp, t1);
		SET_LDOUBLE_EXP(t1, exp + k);
		w *= t1;
		math_check_force_underflow_nonneg(w);
		return w;
	} else { return w; }
}
#   define __hypotl_finite(x, y)   __ieee754_hypotl((x), (y))
#elif LONG_DOUBLE_IS_BINARY128
LIB_FUNC long double __ieee754_hypotl(const long double x, const long double y) {
	long double a, b, y1, y2, w;
	int64_t j, k, ha, hb;
	GET_LDOUBLE_MSW64S(ha, x);
	ha &= 0x7fffffffffffffffLL;
	GET_LDOUBLE_MSW64S(hb, y);
	hb &= 0x7fffffffffffffffLL;
	if (hb > ha) {a = y; b = x; j = ha; ha = hb; hb = j;}
	else {a = x; b = y;}
	SET_LDOUBLE_MSW64(a, ha);
	SET_LDOUBLE_MSW64(b, hb);
	if ((ha - hb) > 0x78000000000000LL) { return a + b; }
	k = 0;
	if (ha > 0x5f3f000000000000LL) {
		if (ha >= 0x7fff000000000000LL) {
			uint64_t low;
			w = a + b;
			GET_LDOUBLE_LSW64(low, a);
			if (((ha & 0xffffffffffffLL) | low) == 0) { w = a; }
			GET_LDOUBLE_LSW64(low, b);
			if (((uint64_t)(hb ^ 0x7fff000000000000LL) | low) == 0) { w = b; }
			return w;
		}
		ha -= 0x2580000000000000LL;
		hb -= 0x2580000000000000LL;
		k += 9600;
		SET_LDOUBLE_MSW64(a, ha);
		SET_LDOUBLE_MSW64(b, hb);
	}
	long double t1;
	if (hb < 0x20bf000000000000LL) {
		if (hb <= 0xffffffffffffLL) {
			uint64_t low;
			GET_LDOUBLE_LSW64(low, b);
			if (((uint64_t)hb | low) == 0) { return a; }
			t1 = 0;
			SET_LDOUBLE_MSW64(t1, 0x7ffd000000000000LL);
			b *= t1;
			a *= t1;
			k -= 16382;
			GET_LDOUBLE_MSW64S(ha, a);
			GET_LDOUBLE_MSW64S(hb, b);
			if (hb > ha) {
				t1 = a;
				a = b;
				b = t1;
				j = ha;
				ha = hb;
				hb = j;
			}
		} else {
			ha += 0x2580000000000000LL;
			hb += 0x2580000000000000LL;
			k -= 9600;
			SET_LDOUBLE_MSW64(a, ha);
			SET_LDOUBLE_MSW64(b, hb);
		}
	}
	w = a - b;
	long double t2;
	if (w > b) {
		t1 = 0;
		SET_LDOUBLE_MSW64(t1, ha);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else {
		a = a + a;
		y1 = 0;
		SET_LDOUBLE_MSW64(y1, hb);
		y2 = b - y1;
		t1 = 0;
		SET_LDOUBLE_MSW64(t1, ha + 0x1000000000000LL);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0) {
		uint64_t high;
		t1 = 1.0L;
		GET_LDOUBLE_MSW64(high, t1);
		SET_LDOUBLE_MSW64(t1, (high + (uint64_t)(k << 48)));
		w *= t1;
		math_check_force_underflow_nonneg(w);
		return w;
	} else { return w; }
}
#   define __hypotl_finite(x, y)   __ieee754_hypotl((x), (y))
#endif


LIB_FUNC float __hypotf(const float x, const float y) {
	return __ieee754_hypotf(x, y);
}
#define hypotf(x, y)   __hypotf((x), (y))


LIB_FUNC double __hypot(const double x, const double y) {
	return __ieee754_hypot(x, y);
}
#define hypot(x, y)   __hypot((x), (y))


LIB_FUNC long double __hypotl(const long double x, const long double y) {
	return __ieee754_hypotl(x, y);
}
#define hypotl(x, y)   __hypotl((x), (y))


// EXTRA TRIGONOMETRY FUNCTIONS (FLOATS)

/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC float acotf(const float radians) {
	return atanf((float)1.0F / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC float arccotf(const float radians) {
	return atanf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC float acothf(const float radians) {
	return atanhf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC float arccothf(const float radians) {
	return atanhf((float)1.0F / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC float cothf(const float radians) {
	return ((float)1.0F / tanhf(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC float cotf(const float radians) {
	return ((float)1.0F / tanf(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC float acscf(const float radians) {
	return asinf((float)1.0F / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC float arccscf(const float radians) {
	return asinf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC float acschf(const float radians) {
	return asinhf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC float arccschf(const float radians) {
	return asinhf((float)1.0F / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC float cschf(const float radians) {
	return ((float)1.0F / sinhf(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC float cscf(const float radians) {
	return ((float)1.0F / sinf(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC float asecf(const float radians) {
	return acosf((float)1.0F / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC float arcsecf(const float radians) {
	return acosf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC float asechf(const float radians) {
	return acoshf((float)1.0F / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC float arcsechf(const float radians) {
	return acoshf((float)1.0F / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC float sechf(const float radians) {
	return ((float)1.0F / coshf(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC float secf(const float radians) {
	return ((float)1.0F / cosf(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC float arcversinf(const float radians) {
	return ((float)1.0F - acosf(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC float arcversinhf(const float radians) {
	return ((float)1.0F - acoshf(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC float versinhf(const float radians) {
	return ((float)1.0F - coshf(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC float versinf(const float radians) {
	return ((float)1.0F - cosf(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC float arcvercosf(const float radians) {
	return ((float)1.0F - asinf(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC float arcvercoshf(const float radians) {
	return ((float)1.0F - asinhf(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC float vercoshf(const float radians) {
	return ((float)1.0F - sinhf(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC float vercosf(const float radians) {
	return ((float)1.0F - sinf(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC float haversinf(const float radians) {
	return ((float)0.5F * ((float)1.0F - cosf(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC float hacoversinf(const float radians) {
	return ((float)0.5F * ((float)1.0F - sinf(radians)));
}


// EXTRA TRIGONOMETRY FUNCTIONS (DOUBLES)

/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC double acot(const double radians) {
	return atan((double)1.0 / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC double arccot(const double radians) {
	return atan((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC double acoth(const double radians) {
	return atanh((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC double arccoth(const double radians) {
	return atanh((double)1.0 / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC double coth(const double radians) {
	return ((double)1.0 / tanh(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC double cot(const double radians) {
	return ((double)1.0 / tan(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC double acsc(const double radians) {
	return asin((double)1.0 / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC double arccsc(const double radians) {
	return asin((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC double acsch(const double radians) {
	return asinh((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC double arccsch(const double radians) {
	return asinh((double)1.0 / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC double csch(const double radians) {
	return ((double)1.0 / sinh(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC double csc(const double radians) {
	return ((double)1.0 / sin(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC double asec(const double radians) {
	return acos((double)1.0 / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC double arcsec(const double radians) {
	return acos((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC double asech(const double radians) {
	return acosh((double)1.0 / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC double arcsech(const double radians) {
	return acosh((double)1.0 / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC double sech(const double radians) {
	return ((double)1.0 / cosh(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC double sec(const double radians) {
	return ((double)1.0 / cos(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC double arcversin(const double radians) {
	return ((double)1.0 - acos(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC double arcversinh(const double radians) {
	return ((double)1.0 - acosh(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC double versinh(const double radians) {
	return ((double)1.0 - cosh(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC double versin(const double radians) {
	return ((double)1.0 - cos(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC double arcvercos(const double radians) {
	return ((double)1.0 - asin(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC double arcvercosh(const double radians) {
	return ((double)1.0 - asinh(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC double vercosh(const double radians) {
	return ((double)1.0 - sinh(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC double vercos(const double radians) {
	return ((double)1.0 - sin(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC double haversin(const double radians) {
	return ((double)0.5 * ((double)1.0 - cos(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC double hacoversin(const double radians) {
	return ((double)0.5 * ((double)1.0 - sin(radians)));
}


// EXTRA TRIGONOMETRY FUNCTIONS (LONG DOUBLES)

#if SUPPORTS_LONG_DOUBLE
/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC long double acotl(const long double radians) {
	return atanl((long double)1.0L / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC long double arccotl(const long double radians) {
	return atanl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC long double acothl(const long double radians) {
	return atanhl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC long double arccothl(const long double radians) {
	return atanhl((long double)1.0L / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC long double cothl(const long double radians) {
	return ((long double)1.0L / tanhl(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC long double cotl(const long double radians) {
	return ((long double)1.0L / tanl(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC long double acscl(const long double radians) {
	return asinl((long double)1.0L / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC long double arccscl(const long double radians) {
	return asinl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC long double acschl(const long double radians) {
	return asinhl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC long double arccschl(const long double radians) {
	return asinhl((long double)1.0L / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC long double cschl(const long double radians) {
	return ((long double)1.0L / sinhl(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC long double cscl(const long double radians) {
	return ((long double)1.0L / sinl(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC long double asecl(const long double radians) {
	return acosl((long double)1.0L / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC long double arcsecl(const long double radians) {
	return acosl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC long double asechl(const long double radians) {
	return acoshl((long double)1.0L / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC long double arcsechl(const long double radians) {
	return acoshl((long double)1.0L / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC long double sechl(const long double radians) {
	return ((long double)1.0L / coshl(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC long double secl(const long double radians) {
	return ((long double)1.0L / cosl(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC long double arcversinl(const long double radians) {
	return ((long double)1.0L - acosl(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC long double arcversinhl(const long double radians) {
	return ((long double)1.0L - acoshl(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC long double versinhl(const long double radians) {
	return ((long double)1.0L - coshl(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC long double versinl(const long double radians) {
	return ((long double)1.0L - cosl(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC long double arcvercosl(const long double radians) {
	return ((long double)1.0L - asinl(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC long double arcvercoshl(const long double radians) {
	return ((long double)1.0L - asinhl(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC long double vercoshl(const long double radians) {
	return ((long double)1.0L - sinhl(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC long double vercosl(const long double radians) {
	return ((long double)1.0L - sinl(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC long double haversinl(const long double radians) {
	return ((long double)0.5L * ((long double)1.0L - cosl(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC long double hacoversinl(const long double radians) {
	return ((long double)0.5L * ((long double)1.0L - sinl(radians)));
}
#endif


// EXTERNAL TRIGONOMETRY (FLOATS)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC float arcexcotf(const float radians) {
	return atanf((float)1.0F / (radians + (float)1.0F));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC float arcexcothf(const float radians) {
	return (((float)1.0F / atanhf(radians)) - (float)1.0F);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC float excothf(const float radians) {
	return (((float)1.0F / tanhf(radians)) - (float)1.0F);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC float excotf(const float radians) {
	return (((float)1.0F / tanf(radians)) - (float)1.0F);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC float arcexcscf(const float radians) {
	return asinf((float)1.0F / (radians + (float)1.0F));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC float arcexcschf(const float radians) {
	return (((float)1.0F / asinhf(radians)) - (float)1.0F);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC float excschf(const float radians) {
	return (((float)1.0F / sinhf(radians)) - (float)1.0F);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC float excscf(const float radians) {
	return (((float)1.0F / sinf(radians)) - (float)1.0F);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC float arcexsecf(const float radians) {
	return acosf((float)1.0F / (radians + (float)1.0F));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC float arcexsechf(const float radians) {
	return (((float)1.0F / acoshf(radians)) - (float)1.0F);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC float exsechf(const float radians) {
	return (((float)1.0F / coshf(radians)) - (float)1.0F);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC float exsecf(const float radians) {
	return (((float)1.0F / cosf(radians)) - (float)1.0F);
}


// EXTERNAL TRIGONOMETRY (DOUBLES)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC double arcexcot(const double radians) {
	return atan((double)1.0 / (radians + (double)1.0));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC double arcexcoth(const double radians) {
	return (((double)1.0 / atanh(radians)) - (double)1.0);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC double excoth(const double radians) {
	return (((double)1.0 / tanh(radians)) - (double)1.0);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC double excot(const double radians) {
	return (((double)1.0 / tan(radians)) - (double)1.0);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC double arcexcsc(const double radians) {
	return asin((double)1.0 / (radians + (double)1.0));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC double arcexcsch(const double radians) {
	return (((double)1.0 / asinh(radians)) - (double)1.0);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC double excsch(const double radians) {
	return (((double)1.0 / sinh(radians)) - (double)1.0);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC double excsc(const double radians) {
	return (((double)1.0 / sin(radians)) - (double)1.0);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC double arcexsec(const double radians) {
	return acos((double)1.0 / (radians + (double)1.0));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC double arcexsech(const double radians) {
	return (((double)1.0 / acosh(radians)) - (double)1.0);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC double exsech(const double radians) {
	return (((double)1.0 / cosh(radians)) - (double)1.0);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC double exsec(const double radians) {
	return (((double)1.0 / cos(radians)) - (double)1.0);
}


// EXTERNAL TRIGONOMETRY (LONG DOUBLES)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC long double arcexcotl(const long double radians) {
	return atanl((long double)1.0L / (radians + (long double)1.0L));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC long double arcexcothl(const long double radians) {
	return (((long double)1.0L / atanhl(radians)) - (long double)1.0L);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC long double excothl(const long double radians) {
	return (((long double)1.0L / tanhl(radians)) - (long double)1.0L);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC long double excotl(const long double radians) {
	return (((long double)1.0L / tanl(radians)) - (long double)1.0L);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC long double arcexcscl(const long double radians) {
	return asinl((long double)1.0L / (radians + (long double)1.0L));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC long double arcexcschl(const long double radians) {
	return (((long double)1.0L / asinhl(radians)) - (long double)1.0L);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC long double excschl(const long double radians) {
	return (((long double)1.0L / sinhl(radians)) - (long double)1.0L);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC long double excscl(const long double radians) {
	return (((long double)1.0L / sinl(radians)) - (long double)1.0L);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC long double arcexsecl(const long double radians) {
	return acosl((long double)1.0L / (radians + (long double)1.0L));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC long double arcexsechl(const long double radians) {
	return (((long double)1.0L / acoshl(radians)) - (long double)1.0L);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC long double exsechl(const long double radians) {
	return (((long double)1.0L / coshl(radians)) - (long double)1.0L);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC long double exsecl(const long double radians) {
	return (((long double)1.0L / cosl(radians)) - (long double)1.0L);
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (FLOATS)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC float cos_arcsinf(const float radians) {
	return (sqrtf((float)1.0 - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC float cos_arctanf(const float radians) {
	return ((float)1.0 / sqrtf((float)1.0 + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC float sin_arcsecf(const float radians) {
	return (sqrtf((radians * radians) - (float)1.0) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC float sin_arctanf(const float radians) {
	return (radians / sqrtf((float)1.0 + (radians * radians)));
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (DOUBLES)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC double cos_arcsin(const double radians) {
	return (sqrt((double)1.0 - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC double cos_arctan(const double radians) {
	return ((double)1.0 / sqrt((double)1.0 + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC double sin_arcsec(const double radians) {
	return (sqrt((radians * radians) - (double)1.0) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC double sin_arctan(const double radians) {
	return (radians / sqrt((double)1.0 + (radians * radians)));
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (LONG DOUBLES)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC long double cos_arcsinl(const long double radians) {
	return (sqrtl((long double)1.0L - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC long double cos_arctanl(const long double radians) {
	return ((long double)1.0L / sqrtl((long double)1.0 + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC long double sin_arcsecl(const long double radians) {
	return (sqrtl((radians * radians) - (long double)1.0L) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC long double sin_arctanl(const long double radians) {
	return (radians / sqrtl((long double)1.0L + (radians * radians)));
}


// TRIGONOMETRY FUNCTION MACROS

#define vcs(x)   (vercos((x)))
#define vercosine(x)   (vercos((x)))
#define covercos(x)   (vercos((x)))
#define cvc(x)   (vercos((x)))
#define coversine(x)   (vercos((x)))
#define cosiv(x)   (vercos((x)))
#define cvs(x)   (vercos((x)))
#define ver(x)   (versin((x)))
#define sinver(x)   (versin((x)))
#define siv(x)   (versin((x)))
#define vers(x)   (versin((x)))
#define hav(x)   (haversin((x)))


// BESSEL & GAMMA FUNCTIONS

static const UNUSED float pzerof_pR8[6] = {
	0.0000000000e+00F, -7.0312500000e-02F,
	-8.0816707611e+00F, -2.5706311035e+02F,
	-2.4852163086e+03F, -5.2530439453e+03F
};


static const UNUSED float pzerof_pS8[5] = {
	1.1653436279e+02F, 3.8337448730e+03F,
	4.0597855469e+04F, 1.1675296875e+05F,
	4.7627726562e+04F
};


static const UNUSED float pzerof_pR5[6] = {
	-1.1412546255e-11F, -7.0312492549e-02F,
	-4.1596107483e+00F, -6.7674766541e+01F,
	-3.3123129272e+02F, -3.4643338013e+02F
};


static const UNUSED float pzerof_pS5[5] = {
	6.0753936768e+01F, 1.0512523193e+03F,
	5.9789707031e+03F, 9.6254453125e+03F,
	2.4060581055e+03F
};


static const UNUSED float pzerof_pR3[6] = {
	-2.5470459075e-09F, -7.0311963558e-02F,
	-2.4090321064e+00F, -2.1965976715e+01F,
	-5.8079170227e+01F, -3.1447946548e+01F
};


static const UNUSED float pzerof_pS3[5] = {
	3.5856033325e+01F, 3.6151397705e+02F,
	1.1936077881e+03F, 1.1279968262e+03F,
	1.7358093262e+02F
};


static const UNUSED float pzerof_pR2[6] = {
	-8.8753431271e-08F, -7.0303097367e-02F,
	-1.4507384300e+00F, -7.6356959343e+00F,
	-1.1193166733e+01F, -3.2336456776e+00F
};


static const UNUSED float pzerof_pS2[5] = {
	2.2220300674e+01F, 1.3620678711e+02F,
	2.7047027588e+02F, 1.5387539673e+02F,
	1.4657617569e+01F
};


LIB_FUNC float pzerof(const float x) {
	const float *p, *q;
	float z, r, s;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41000000) { p = pzerof_pR8; q = pzerof_pS8; }
	else if (ix >= 0x40f71c58) { p = pzerof_pR5; q = pzerof_pS5; }
	else if (ix >= 0x4036db68) { p = pzerof_pR3; q = pzerof_pS3; }
	else { p = pzerof_pR2; q = pzerof_pS2; }
	z = 1.0F / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = 1.0F + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
	return 1.0F + r / s;
}


static const UNUSED float qzerof_qR8[6] = {
	0.0000000000e+00F, 7.3242187500e-02F,
	1.1768206596e+01F, 5.5767340088e+02F,
	8.8591972656e+03F, 3.7014625000e+04F
};


static const UNUSED float qzerof_qS8[6] = {
	1.6377603149e+02F, 8.0983447266e+03F,
	1.4253829688e+05F, 8.0330925000e+05F,
	8.4050156250e+05F, -3.4389928125e+05F
};


static const UNUSED float qzerof_qR5[6] = {
	1.8408595828e-11F, 7.3242180049e-02F,
	5.8356351852e+00F, 1.3511157227e+02F,
	1.0272437744e+03F, 1.9899779053e+03F
};


static const UNUSED float qzerof_qS5[6] = {
	8.2776611328e+01F, 2.0778142090e+03F,
	1.8847289062e+04F, 5.6751113281e+04F,
	3.5976753906e+04F, -5.3543427734e+03F
};


static const UNUSED float qzerof_qR3[6] = {
	4.3774099900e-09F, 7.3241114616e-02F,
	3.3442313671e+00F, 4.2621845245e+01F,
	1.7080809021e+02F, 1.6673394775e+02F
};


static const UNUSED float qzerof_qS3[6] = {
	4.8758872986e+01F, 7.0968920898e+02F,
	3.7041481934e+03F, 6.4604252930e+03F,
	2.5163337402e+03F, -1.4924745178e+02F
};


static const UNUSED float qzerof_qR2[6] = {
	1.5044444979e-07F, 7.3223426938e-02F,
	1.9981917143e+00F, 1.4495602608e+01F,
	3.1666231155e+01F, 1.6252708435e+01F
};


static const UNUSED float qzerof_qS2[6] = {
	3.0365585327e+01F, 2.6934811401e+02F,
	8.4478375244e+02F, 8.8293585205e+02F,
	2.1266638184e+02F, -5.3109550476e+00F
};


LIB_FUNC float qzerof(const float x) {
	const float *p, *q;
	float s, r, z;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41000000) { p = qzerof_qR8; q = qzerof_qS8; }
	else if (ix >= 0x40f71c58) { p = qzerof_qR5; q = qzerof_qS5; }
	else if (ix >= 0x4036db68) { p = qzerof_qR3; q = qzerof_qS3; }
	else { p = qzerof_qR2; q = qzerof_qS2; }
	z = 1.0F / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = 1.0F + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
	return (-0.125F + r / s) / x;
}


LIB_FUNC float __ieee754_j0f(const float num) {
	float z, s, c, ss, cc, r, u, v, x = num;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x7f800000) { return 1.0F / (x * x); }
	x = fabsf(x);
	if (ix >= 0x40000000) {
		sincosf(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7f000000) {
			z = -cosf(x + x);
			if ((s * c) < 0.0F) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.6418961287e-01F * cc) / __ieee754_sqrtf(x); }
		else {
			u = pzerof(x);
			v = qzerof(x);
			z = 5.6418961287e-01F * (u * cc - v * ss) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (ix < 0x39000000) {
		math_force_eval(1e30F + x);
		if (ix < 0x32000000) { return 1.0F; }
		else { return 1.0F - 0.25F * x * x; }
	}
	z = x * x;
	r = z * (1.5625000000e-02F + z * (-1.8997929874e-04F + z * (1.8295404516e-06F + z * -4.6183270541e-09F)));
	s = 1.0F + z * (1.5619102865e-02F + z * (1.1692678527e-04F + z * (5.1354652442e-07F + z * 1.1661400734e-09F)));
	if (ix < 0x3F800000) {
		return 1.0F + z * (-0.25F + (r / s));
	} else {
		u = 0.5F * x;
		return ((1.0F + u) * (1.0F - u) + z * (r / s));
	}
}
#define __j0f_finite(x)   __ieee754_j0f((x))


static const UNUSED float ponef_pr8[6] = {
	0.0000000000e+00F, 1.1718750000e-01F,
	1.3239480972e+01F, 4.1205184937e+02F,
	3.8747453613e+03F, 7.9144794922e+03F
};


static const UNUSED float ponef_ps8[5] = {
	1.1420736694e+02F, 3.6509309082e+03F,
	3.6956207031e+04F, 9.7602796875e+04F,
	3.0804271484e+04F
};


static const UNUSED float ponef_pr5[6] = {
	1.3199052094e-11F, 1.1718749255e-01F,
	6.8027510643e+00F, 1.0830818176e+02F,
	5.1763616943e+02F, 5.2871520996e+02F
};


static const UNUSED float ponef_ps5[5] = {
	5.9280597687e+01F, 9.9140142822e+02F,
	5.3532670898e+03F, 7.8446904297e+03F,
	1.5040468750e+03F
};


static const UNUSED float ponef_pr3[6] = {
	3.0250391081e-09F, 1.1718686670e-01F,
	3.9329774380e+00F, 3.5119403839e+01F,
	9.1055007935e+01F, 4.8559066772e+01F
};


static const UNUSED float ponef_ps3[5] = {
	3.4791309357e+01F, 3.3676245117e+02F,
	1.0468714600e+03F, 8.9081134033e+02F,
	1.0378793335e+02F
};


static const UNUSED float ponef_pr2[6] = {
	1.0771083225e-07F, 1.1717621982e-01F,
	2.3685150146e+00F, 1.2242610931e+01F,
	1.7693971634e+01F, 5.0735230446e+00F
};


static const UNUSED float ponef_ps2[5] = {
	2.1436485291e+01F, 1.2529022980e+02F,
	2.3227647400e+02F, 1.1767937469e+02F,
	8.3646392822e+00F
};


LIB_FUNC float ponef(const float x) {
	const float *p, *q;
	float z, r, s;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41000000) { p = ponef_pr8; q = ponef_ps8; }
	else if (ix >= 0x40f71c58) { p = ponef_pr5; q = ponef_ps5; }
	else if (ix >= 0x4036db68) { p = ponef_pr3; q = ponef_ps3; }
	else {p = ponef_pr2; q = ponef_ps2;}
	z = 1.0F / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = 1.0F + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
	return 1.0F + r / s;
}


static const UNUSED float qonef_qr8[6] = {
	0.0000000000e+00F, -1.0253906250e-01F,
	-1.6271753311e+01F, -7.5960174561e+02F,
	-1.1849806641e+04F, -4.8438511719e+04F
};


static const UNUSED float qonef_qs8[6] = {
	1.6139537048e+02F, 7.8253862305e+03F,
	1.3387534375e+05F, 7.1965775000e+05F,
	6.6660125000e+05F, -2.9449025000e+05F
};


static const UNUSED float qonef_qr5[6] = {
	-2.0897993405e-11F, -1.0253904760e-01F,
	-8.0564479828e+00F, -1.8366960144e+02F,
	-1.3731937256e+03F, -2.6124443359e+03F
};


static const UNUSED float qonef_qs5[6] = {
	8.1276550293e+01F, 1.9917987061e+03F,
	1.7468484375e+04F, 4.9851425781e+04F,
	2.7948074219e+04F, -4.7191835938e+03F
};


static const UNUSED float qonef_qr3[6] = {
	-5.0783124372e-09F, -1.0253783315e-01F,
	-4.6101160049e+00F, -5.7847221375e+01F,
	-2.2824453735e+02F, -2.1921012878e+02F
};


static const UNUSED float qonef_qs3[6] = {
	4.7665153503e+01F, 6.7386511230e+02F,
	3.3801528320e+03F, 5.5477290039e+03F,
	1.9031191406e+03F, -1.3520118713e+02F
};


static const UNUSED float qonef_qr2[6] = {
	-1.7838172539e-07F, -1.0251704603e-01F,
	-2.7522056103e+00F, -1.9663616180e+01F,
	-4.2325313568e+01F, -2.1371921539e+01F
};


static const UNUSED float qonef_qs2[6] = {
	2.9533363342e+01F, 2.5298155212e+02F,
	7.5750280762e+02F, 7.3939318848e+02F,
	1.5594900513e+02F, -4.9594988823e+00F
};


LIB_FUNC float qonef(const float x) {
	const float *p, *q;
	float s, r, z;
	int32_t ix;
	GET_FLOAT_WORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x40200000) { p = qonef_qr8; q = qonef_qs8; }
	else if (ix >= 0x40f71c58) { p = qonef_qr5; q = qonef_qs5; }
	else if (ix >= 0x4036db68) { p = qonef_qr3; q = qonef_qs3; }
	else {p = qonef_qr2; q = qonef_qs2;}
	z = 1.0F / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = 1.0F + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
	return (0.375F + r / s) / x;
}


LIB_FUNC float __ieee754_j1f(const float num) {
	float z, s, c, ss, cc, r, u, v, y, x = num;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = hx & 0x7fffffff;
	if (PREDICT_UNLIKELY(ix >= 0x7f800000)) { return 1.0F / x; }
	y = fabsf(x);
	if (ix >= 0x40000000) {
		sincosf(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7f000000) {
			z = cosf(y + y);
			if ((s * c) > 0.0F) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.6418961287e-01F * cc) / __ieee754_sqrtf(y); }
		else {
			u = ponef(y);
			v = qonef(y);
			z = 5.6418961287e-01F * (u * cc - v * ss) / __ieee754_sqrtf(y);
		}
		if (hx < 0) { return -z; }
		else { return z; }
	}
	if (PREDICT_UNLIKELY(ix < 0x32000000)) {
		if (1e30F + x > 1.0F) {
			float ret = math_narrow_eval(0.5F * x);
			math_check_force_underflow(ret);
			if (ret == 0 && x != 0) { __set_errno(ERANGE); }
			return ret;
		}
	}
	z = x * x;
	r = z * (-6.2500000000e-02F + z * (1.4070566976e-03F + z * (-1.5995563444e-05F + z * 4.9672799207e-08F)));
	s = 1.0F + z * (1.9153760746e-02F + z * (1.8594678841e-04F + z * (1.1771846857e-06F + z * (5.0463624390e-09F + z * 1.2354227016e-11F))));
	r *= x;
	return (x * 0.5F + r / s);
}
#define __j1f_finite(x)   __ieee754_j1f((x))


LIB_FUNC float __ieee754_y1f(const float num) {
	float z, s, c, ss, cc, u, v, x = num;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(ix >= 0x7f800000)) { return 1.0F / (x + x * x); }
	else if (PREDICT_UNLIKELY(ix == 0)) { return -HUGE_VALF + x; }
	else if (PREDICT_UNLIKELY(hx < 0)) { return 0.0F / (0.0F * x); }
	else if (ix >= 0x40000000) {
		// SET_RESTORE_ROUNDF(FE_TONEAREST);
		sincosf(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7f000000) {
			z = cosf(x + x);
			if ((s * c) > 0.0F) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.6418961287e-01F * ss) / __ieee754_sqrtf(x); }
		else {
			u = ponef(x);
			v = qonef(x);
			z = 5.6418961287e-01F * (u * ss + v * cc) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (PREDICT_UNLIKELY(ix <= 0x33000000)) {
		z = -6.3661974669e-01F / x;
		if (isinf(z)) { __set_errno(ERANGE); }
		return z;
	}
	z = x * x;
	u = -1.9605709612e-01F + z * (5.0443872809e-02F + z * (-1.9125689287e-03F + z * (2.3525259166e-05F + z * -9.1909917899e-08F)));
	v = 1.0F + z * (1.9916731864e-02F + z * (2.0255257550e-04F + z * (1.3560879779e-06F + z * (6.2274145840e-09F + z * 1.6655924903e-11F))));
	return (x * (u / v) + 6.3661974669e-01F * (__ieee754_j1f(x) * __ieee754_logf(x) - 1.0F / x));
}
#define __y1f_finite(x)   __ieee754_y1f((x))


LIB_FUNC float __ieee754_y0f(const float num) {
	float z, s, c, ss, cc, u, v, x = num;
	int32_t hx, ix;
	GET_FLOAT_WORD(hx, x);
	ix = 0x7fffffff & hx;
	if (ix >= 0x7f800000) { return 1.0F / (x + x * x); }
	else if (ix == 0) { return -HUGE_VALF + x; }
	else if (hx < 0) { return 0.0F / (0.0F * x); }
	else if (ix >= 0x40000000) {
		sincosf(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7f000000) {
			z = -cosf(x + x);
			if ((s * c) < 0.0F) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.6418961287e-01F * ss) / __ieee754_sqrtf(x); }
		else {
			u = pzerof(x);
			v = qzerof(x);
			z = 5.6418961287e-01F * (u * ss + v * cc) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (ix <= 0x39800000) {
		return (-7.3804296553e-02F + 6.3661974669e-01F * __ieee754_logf(x));
	}
	z = x * x;
	u = -7.3804296553e-02F + z * (1.7666645348e-01F + z * (-1.3818567619e-02F + z * (3.4745343146e-04F + z * (-3.8140706238e-06F + z * (1.9559013964e-08F + z * -3.9820518410e-11F)))));
	v = 1.0F + z * (1.2730483897e-02F + z * (7.6006865129e-05F + z * (2.5915085189e-07F + z * 4.4111031494e-10F)));
	return (u / v + 6.3661974669e-01F * (__ieee754_j0f(x) * __ieee754_logf(x)));
}
#define __y0f_finite(x)   __ieee754_y0f((x))


LIB_FUNC float __ieee754_jnf(const int num, const float numx) {
	int32_t i, hx, ix, sgn, n = (int32_t)num;
	float ret, a, b, temp, di, z, w, x = numx;
	GET_FLOAT_WORD(hx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(ix > 0x7f800000)) { return x + x; }
	if (n < 0) {
		n = -n;
		x = -x;
		hx ^= (int32_t)0x80000000;
	}
	if (n == 0) { return (__ieee754_j0f(x)); }
	else if (n == 1) { return (__ieee754_j1f(x)); }
	sgn = (n & 1) & (hx >> 31);
	x = fabsf(x);
	// SET_RESTORE_ROUNDF(FE_TONEAREST);
	if (PREDICT_UNLIKELY(ix == 0 || ix >= 0x7f800000)) { return sgn == 1 ? -0.0F : 0.0F; }
	else if ((float)n <= x) {
		a = __ieee754_j0f(x);
		b = __ieee754_j1f(x);
		for (i = 1; i < n; i++) {
			temp = b;
			b = b * (((float)(i + i)) / x) - a;
			a = temp;
		}
	} else {
		if (ix < 0x30800000) {
			if (n > 33) { b = 0.0F; }
			else {
				temp = x * 0.5F;
				b = temp;
				for (a = 1.0F, i = 2; i <= n; i++) {
					a *= (float)i;
					b *= temp;
				}
				b = b / a;
			}
		} else {
			float t, v, q0, q1, h, tmp;
			int32_t k, m;
			w = ((float)(n + n)) / x;
			h = 2.0F / x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0F;
			k = 1;
			while (q1 < (float)1.0e9F) {
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = 0.0F, i = 2 * (n + k); i >= m; i -= 2) { t = 1.0F / (float)((float)i / x - t); }
			a = t;
			b = 1.0F;
			tmp = (float)n;
			v = 2.0F / x;
			tmp = tmp * __ieee754_logf(fabsf(v * tmp));
			if (tmp < (float)8.8721679688e+01) {
				for (i = n - 1, di = (float)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0F;
				}
			} else {
				for (i = n - 1, di = (float)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0F;
					if (b > (float)1e10) {
						a /= b;
						t /= b;
						b = 1.0F;
					}
				}
			}
			z = __ieee754_j0f(x);
			w = __ieee754_j1f(x);
			if (fabsf(z) >= fabsf(w)) { b = (t * z / b); }
			else { b = (t * w / a); }
		}
	}
	if (sgn == 1) { ret = -b; }
	else { ret = b; }
	ret = math_narrow_eval (ret);
	if (ret == 0) {
		ret = math_narrow_eval(copysignf(FLT_MIN, ret) * FLT_MIN);
		__set_errno (ERANGE);
	} // else { math_check_force_underflow(ret); }
	return ret;
}
#define __jnf_finite(n, x)   __ieee754_jnf((n), (x))


LIB_FUNC float __ieee754_ynf(const int num, const float x) {
	int32_t i, hx, ix, sign, n = (int32_t)num;
	uint32_t ib;
	float ret, a, b, temp;
	GET_FLOAT_WORD(hx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(ix > 0x7f800000)) { return x + x; }
	else if (PREDICT_UNLIKELY(ix == 0)) { return -HUGE_VALF + x; }
	else if (PREDICT_UNLIKELY(hx < 0)) { return 0.0F / (0.0F * x); }
	sign = 1;
	if (n < 0) {
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0) { return __ieee754_y0f(x); }
	// SET_RESTORE_ROUNDF(FE_TONEAREST);
	else if (n == 1) {
		const float tmpf = __ieee754_y1f(x);
		ret = (float)(sign * (int32_t)tmpf);
		goto ieee754_ynf_out;
	} else if (PREDICT_UNLIKELY(ix == 0x7f800000)) { return 0.0F; }
	a = __ieee754_y0f(x);
	b = __ieee754_y1f(x);
	GET_FLOAT_UWORD(ib, b);
	for (i = 1; i < n && ib != 0xff800000; i++) {
		temp = b;
		b = (((float)(i + i)) / x) * b - a;
		GET_FLOAT_UWORD(ib, b);
		a = temp;
	}
	if (!isfinite(b)) { __set_errno(ERANGE); }
	if (sign > 0) { ret = b; }
	else { ret = -b; }
ieee754_ynf_out:
	if (isinf(ret)) { ret = copysignf(FLT_MAX, ret) * FLT_MAX; }
	return ret;
}
#define __ynf_finite(n, x)   __ieee754_ynf((n), (x))


static const UNUSED double pzero_pR8[6] = {
	0.00000000000000000000e+00, -7.03124999999900357484e-02,
	-8.08167041275349795626e+00, -2.57063105679704847262e+02,
	-2.48521641009428822144e+03, -5.25304380490729545272e+03
};


static const UNUSED double pzero_pS8[5] = {
	1.16534364619668181717e+02, 3.83374475364121826715e+03,
	4.05978572648472545552e+04, 1.16752972564375915681e+05,
	4.76277284146730962675e+04
};


static const UNUSED double pzero_pR5[6] = {
	-1.14125464691894502584e-11, -7.03124940873599280078e-02,
	-4.15961064470587782438e+00, -6.76747652265167261021e+01,
	-3.31231299649172967747e+02, -3.46433388365604912451e+02
};


static const UNUSED double pzero_pS5[5] = {
	6.07539382692300335975e+01, 1.05125230595704579173e+03,
	5.97897094333855784498e+03, 9.62544514357774460223e+03,
	2.40605815922939109441e+03
};


static const UNUSED double pzero_pR3[6] = {
	-2.54704601771951915620e-09, -7.03119616381481654654e-02,
	-2.40903221549529611423e+00, -2.19659774734883086467e+01,
	-5.80791704701737572236e+01, -3.14479470594888503854e+01
};


static const UNUSED double pzero_pS3[5] = {
	3.58560338055209726349e+01, 3.61513983050303863820e+02,
	1.19360783792111533330e+03, 1.12799679856907414432e+03,
	1.73580930813335754692e+02
};


static const UNUSED double pzero_pR2[6] = {
	-8.87534333032526411254e-08, -7.03030995483624743247e-02,
	-1.45073846780952986357e+00, -7.63569613823527770791e+00,
	-1.11931668860356747786e+01, -3.23364579351335335033e+00
};


static const UNUSED double pzero_pS2[5] = {
	2.22202997532088808441e+01, 1.36206794218215208048e+02,
	2.70470278658083486789e+02, 1.53875394208320329881e+02,
	1.46576176948256193810e+01
};


LIB_FUNC double pzero(const double x) {
	const double *p, *q;
	double z, r, s, z2, z4, r1, r2, r3, s1, s2, s3;
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41b00000) { return 1.0; }
	else if (ix >= 0x40200000) {
		p = pzero_pR8;
		q = pzero_pS8;
	} else if (ix >= 0x40122E8B) {
		p = pzero_pR5;
		q = pzero_pS5;
	} else if (ix >= 0x4006DB6D) {
		p = pzero_pR3;
		q = pzero_pS3;
	} else {
		p = pzero_pR2;
		q = pzero_pS2;
	}
	z = 1.0 / (x * x);
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	r = r1 + z2 * r2 + z4 * r3;
	s1 = 1.0 + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3;
	return 1.0 + r / s;
}


static const UNUSED double qzero_qR8[6] = {
	0.00000000000000000000e+00, 7.32421874999935051953e-02,
	1.17682064682252693899e+01, 5.57673380256401856059e+02,
	8.85919720756468632317e+03, 3.70146267776887834771e+04
};


static const UNUSED double qzero_qS8[6] = {
	1.63776026895689824414e+02, 8.09834494656449805916e+03,
	1.42538291419120476348e+05, 8.03309257119514397345e+05,
	8.40501579819060512818e+05, -3.43899293537866615225e+05
};


static const UNUSED double qzero_qR5[6] = {
	1.84085963594515531381e-11, 7.32421766612684765896e-02,
	5.83563508962056953777e+00, 1.35111577286449829671e+02,
	1.02724376596164097464e+03, 1.98997785864605384631e+03
};


static const UNUSED double qzero_qS5[6] = {
	8.27766102236537761883e+01, 2.07781416421392987104e+03,
	1.88472887785718085070e+04, 5.67511122894947329769e+04,
	3.59767538425114471465e+04, -5.35434275601944773371e+03
};


static const UNUSED double qzero_qR3[6] = {
	4.37741014089738620906e-09, 7.32411180042911447163e-02,
	3.34423137516170720929e+00, 4.26218440745412650017e+01,
	1.70808091340565596283e+02, 1.66733948696651168575e+02
};


static const UNUSED double qzero_qS3[6] = {
	4.87588729724587182091e+01, 7.09689221056606015736e+02,
	3.70414822620111362994e+03, 6.46042516752568917582e+03,
	2.51633368920368957333e+03, -1.49247451836156386662e+02
};


static const UNUSED double qzero_qR2[6] = {
	1.50444444886983272379e-07, 7.32234265963079278272e-02,
	1.99819174093815998816e+00, 1.44956029347885735348e+01,
	3.16662317504781540833e+01, 1.62527075710929267416e+01
};


static const UNUSED double qzero_qS2[6] = {
	3.03655848355219184498e+01, 2.69348118608049844624e+02,
	8.44783757595320139444e+02, 8.82935845112488550512e+02,
	2.12666388511798828631e+02, -5.31095493882666946917e+00
};


LIB_FUNC double qzero(const double x) {
	const double *p, *q;
	double s, r, z, z2, z4, z6, r1, r2, r3, s1, s2, s3;
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41b00000) { return -0.125 / x; }
	else if (ix >= 0x40200000) {
		p = qzero_qR8;
		q = qzero_qS8;
	} else if (ix >= 0x40122E8B) {
		p = qzero_qR5;
		q = qzero_qS5;
	} else if (ix >= 0x4006DB6D) {
		p = qzero_qR3;
		q = qzero_qS3;
	} else {
		p = qzero_qR2;
		q = qzero_qS2;
	}
	z = 1.0 / (x * x);
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	z6 = z4 * z2;
	r = r1 + z2 * r2 + z4 * r3;
	s1 = 1.0 + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3 + z6 * q[5];
	return (-0.125 + r / s) / x;
}


LIB_FUNC double __ieee754_j0(const double num) {
	double z, s, c, ss, cc, r, u, v, r1, r2, s1, s2, z2, z4, x = num;
	int32_t hx, ix;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x7ff00000) { return 1.0 / (x * x); }
	x = fabs(x);
	if (ix >= 0x40000000) {
		sincos(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7fe00000) {
			z = -cos(x + x);
			if ((s * c) < 0.0) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.64189583547756279280e-01 * cc) / __ieee754_sqrt(x); }
		else {
			u = pzero(x);
			v = qzero(x);
			z = 5.64189583547756279280e-01 * (u * cc - v * ss) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (ix < 0x3f200000) {
		math_force_eval(1e300 + x);
		if (ix < 0x3e400000) { return 1.0; }
		else { return 1.0 - 0.25 * x * x; }
	}
	z = x * x;
	r1 = z * 1.56249999999999947958e-02;
	z2 = z * z;
	r2 = -1.89979294238854721751e-04 + z * 1.82954049532700665670e-06;
	z4 = z2 * z2;
	r = r1 + z2 * r2 + z4 * -4.61832688532103189199e-09;
	s1 = 1.0 + z * 1.56191029464890010492e-02;
	s2 = 1.16926784663337450260e-04 + z * 5.13546550207318111446e-07;
	s = s1 + z2 * s2 + z4 * 1.16614003333790000205e-09;
	if (ix < 0x3FF00000) { return 1.0 + z * (-0.25 + (r / s)); }
	else {
		u = 0.5 * x;
		return ((1.0 + u) * (1.0 - u) + z * (r / s));
	}
}
#define __j0_finite(x)   __ieee754_j0((x))


LIB_FUNC double __ieee754_y0(const double num) {
	double z, s, c, ss, cc, u, v, z2, z4, z6, u1, u2, u3, v1, v2, x = num;
	int32_t hx, ix, lx;
	EXTRACT_SWORDS(hx, lx, x);
	ix = 0x7fffffff & hx;
	if (ix >= 0x7ff00000) { return 1.0 / (x + x * x); }
	if ((ix | lx) == 0) { return -HUGE_VAL + x; }
	if (hx < 0) { return 0.0 / (0.0 * x); }
	if (ix >= 0x40000000) {
		sincos(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7fe00000) {
			z = -cos(x + x);
			if ((s * c) < 0.0) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.64189583547756279280e-01 * ss) / __ieee754_sqrt(x); }
		else {
			u = pzero(x);
			v = qzero(x);
			z = 5.64189583547756279280e-01 * (u * ss + v * cc) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (ix <= 0x3e400000) {
		return (-7.38042951086872317523e-02 + 6.36619772367581382433e-01 * __ieee754_log(x));
	}
	z = x * x;
	u1 = -7.38042951086872317523e-02 + z * 1.76666452509181115538e-01;
	z2 = z * z;
	u2 = -1.38185671945596898896e-02 + z * 3.47453432093683650238e-04;
	z4 = z2 * z2;
	u3 = -3.81407053724364161125e-06 + z * 1.95590137035022920206e-08;
	z6 = z4 * z2;
	u = u1 + z2 * u2 + z4 * u3 + z6 * -3.98205194132103398453e-11;
	v1 = 1.0 + z * 1.27304834834123699328e-02;
	v2 = 7.60068627350353253702e-05 + z * 2.59150851840457805467e-07;
	v = v1 + z2 * v2 + z4 * 4.41110311332675467403e-10;
	return (u / v + 6.36619772367581382433e-01 * (__ieee754_j0(x) * __ieee754_log(x)));
}
#define __y0_finite(x)   __ieee754_y0((x))


static const UNUSED double pone_pr8[6] = {
	0.00000000000000000000e+00, 1.17187499999988647970e-01,
	1.32394806593073575129e+01, 4.12051854307378562225e+02,
	3.87474538913960532227e+03, 7.91447954031891731574e+03
};


static const UNUSED double pone_ps8[5] = {
	1.14207370375678408436e+02, 3.65093083420853463394e+03,
	3.69562060269033463555e+04, 9.76027935934950801311e+04,
	3.08042720627888811578e+04
};


static const UNUSED double pone_pr5[6] = {
	1.31990519556243522749e-11, 1.17187493190614097638e-01,
	6.80275127868432871736e+00, 1.08308182990189109773e+02,
	5.17636139533199752805e+02, 5.28715201363337541807e+02
};


static const UNUSED double pone_ps5[5] = {
	5.92805987221131331921e+01, 9.91401418733614377743e+02,
	5.35326695291487976647e+03, 7.84469031749551231769e+03,
	1.50404688810361062679e+03
};


static const UNUSED double pone_pr3[6] = {
	3.02503916137373618024e-09, 1.17186865567253592491e-01,
	3.93297750033315640650e+00, 3.51194035591636932736e+01,
	9.10550110750781271918e+01, 4.85590685197364919645e+01
};


static const UNUSED double pone_ps3[5] = {
	3.47913095001251519989e+01, 3.36762458747825746741e+02,
	1.04687139975775130551e+03, 8.90811346398256432622e+02,
	1.03787932439639277504e+02
};


static const UNUSED double pone_pr2[6] = {
	1.07710830106873743082e-07, 1.17176219462683348094e-01,
	2.36851496667608785174e+00, 1.22426109148261232917e+01,
	1.76939711271687727390e+01, 5.07352312588818499250e+00
};


static const UNUSED double pone_ps2[5] = {
	2.14364859363821409488e+01, 1.25290227168402751090e+02,
	2.32276469057162813669e+02, 1.17679373287147100768e+02,
	8.36463893371618283368e+00
};


LIB_FUNC double pone(const double x) {
	const double *p, *q;
	double z, r, s, r1, r2, r3, s1, s2, s3, z2, z4;
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41b00000) { return 1.0; }
	else if (ix >= 0x40200000) {
		p = pone_pr8;
		q = pone_ps8;
	} else if (ix >= 0x40122E8B) {
		p = pone_pr5;
		q = pone_ps5;
	} else if (ix >= 0x4006DB6D) {
		p = pone_pr3;
		q = pone_ps3;
	} else {
		p = pone_pr2;
		q = pone_ps2;
	}
	z = 1.0 / (x * x);
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	r = r1 + z2 * r2 + z4 * r3;
	s1 = 1.0 + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3;
	return 1.0 + r / s;
}


static const UNUSED double qone_qr8[6] = {
	0.00000000000000000000e+00, -1.02539062499992714161e-01,
	-1.62717534544589987888e+01, -7.59601722513950107896e+02,
	-1.18498066702429587167e+04, -4.84385124285750353010e+04
};


static const UNUSED double qone_qs8[6] = {
	1.61395369700722909556e+02, 7.82538599923348465381e+03,
	1.33875336287249578163e+05, 7.19657723683240939863e+05,
	6.66601232617776375264e+05, -2.94490264303834643215e+05
};


static const UNUSED double qone_qr5[6] = {
	-2.08979931141764104297e-11, -1.02539050241375426231e-01,
	-8.05644828123936029840e+00, -1.83669607474888380239e+02,
	-1.37319376065508163265e+03, -2.61244440453215656817e+03
};


static const UNUSED double qone_qs5[6] = {
	8.12765501384335777857e+01, 1.99179873460485964642e+03,
	1.74684851924908907677e+04, 4.98514270910352279316e+04,
	2.79480751638918118260e+04, -4.71918354795128470869e+03
};


static const UNUSED double qone_qr3[6] = {
	-5.07831226461766561369e-09, -1.02537829820837089745e-01,
	-4.61011581139473403113e+00, -5.78472216562783643212e+01,
	-2.28244540737631695038e+02, -2.19210128478909325622e+02
};


static const UNUSED double qone_qs3[6] = {
	4.76651550323729509273e+01, 6.73865112676699709482e+02,
	3.38015286679526343505e+03, 5.54772909720722782367e+03,
	1.90311919338810798763e+03, -1.35201191444307340817e+02
};


static const UNUSED double qone_qr2[6] = {
	-1.78381727510958865572e-07, -1.02517042607985553460e-01,
	-2.75220568278187460720e+00, -1.96636162643703720221e+01,
	-4.23253133372830490089e+01, -2.13719211703704061733e+01
};


static const UNUSED double qone_qs2[6] = {
	2.95333629060523854548e+01, 2.52981549982190529136e+02,
	7.57502834868645436472e+02, 7.39393205320467245656e+02,
	1.55949003336666123687e+02, -4.95949898822628210127e+00
};


LIB_FUNC double qone(const double x) {
	const double *p, *q;
	double s, r, z, r1, r2, r3, s1, s2, s3, z2, z4, z6;
	int32_t ix;
	GET_HIGH_SWORD(ix, x);
	ix &= 0x7fffffff;
	if (ix >= 0x41b00000) { return 0.375 / x; }
	else if (ix >= 0x40200000) {
		p = qone_qr8;
		q = qone_qs8;
	} else if (ix >= 0x40122E8B) {
		p = qone_qr5;
		q = qone_qs5;
	} else if (ix >= 0x4006DB6D) {
		p = qone_qr3;
		q = qone_qs3;
	} else {
		p = qone_qr2;
		q = qone_qs2;
	}
	z = 1.0 / (x * x);
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	z6 = z4 * z2;
	r = r1 + z2 * r2 + z4 * r3;
	s1 = 1.0 + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3 + z6 * q[5];
	return (0.375 + r / s) / x;
}


LIB_FUNC double __ieee754_j1(double x) {
	double z, s, c, ss, cc, r, u, v, y;
	int32_t hx, ix;
	GET_HIGH_SWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (PREDICT_UNLIKELY(ix >= 0x7ff00000)) { return 1.0 / x; }
	y = fabs(x);
	if (ix >= 0x40000000) {
		sincos(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7fe00000) {
			z = cos(y + y);
			if ((s * c) > 0.0) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.64189583547756279280e-01 * cc) / __ieee754_sqrt(y); }
		else {
			u = pone(y);
			v = qone(y);
			z = 5.64189583547756279280e-01 * (u * cc - v * ss) / __ieee754_sqrt(y);
		}
		if (hx < 0) { return -z; }
		else { return z; }
	}
	if (PREDICT_UNLIKELY(ix < 0x3e400000)) {
		if (1e300 + x > 1.0) {
			double ret = math_narrow_eval(0.5 * x);
			// math_check_force_underflow(ret);
			if (ret == 0 && x != 0) { __set_errno(ERANGE); }
			return ret;
		}
	}
	double r1, r2, s1, s2, s3, z2, z4;
	z = x * x;
	r1 = z * -6.25000000000000000000e-02;
	z2 = z * z;
	r2 = 1.40705666955189706048e-03 + z * -1.59955631084035597520e-05;
	z4 = z2 * z2;
	r = r1 + z2 * r2 + z4 * 4.96727999609584448412e-08;
	r *= x;
	s1 = 1.0 + z * 1.91537599538363460805e-02;
	s2 = 1.85946785588630915560e-04 + z * 1.17718464042623683263e-06;
	s3 = 5.04636257076217042715e-09 + z * 1.23542274426137913908e-11;
	s = s1 + z2 * s2 + z4 * s3;
	return (x * 0.5 + r / s);
}
#define __j1_finite(x)   __ieee754_j1((x))


LIB_FUNC double __ieee754_y1(double x) {
	double z, s, c, ss, cc, u, v, u1, u2, v1, v2, v3, z2, z4;
	int32_t hx, ix, lx;
	EXTRACT_SWORDS(hx, lx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(ix >= 0x7ff00000)) { return 1.0 / (x + x * x); }
	else if (PREDICT_UNLIKELY((ix | lx) == 0)) { return -HUGE_VAL + x; }
	else if (PREDICT_UNLIKELY(hx < 0)) { return 0.0 / (0.0 * x); }
	else if (ix >= 0x40000000) {
		sincos(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7fe00000) {
			z = cos(x + x);
			if ((s * c) > 0.0) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (ix > 0x48000000) { z = (5.64189583547756279280e-01 * ss) / __ieee754_sqrt(x); }
		else {
			u = pone(x);
			v = qone(x);
			z = 5.64189583547756279280e-01 * (u * ss + v * cc) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (PREDICT_UNLIKELY(ix <= 0x3c900000)) {
		z = -6.36619772367581382433e-01 / x;
		if (__isinf(z)) { __set_errno(ERANGE); }
		return z;
	}
	z = x * x;
	u1 = -1.96057090646238940668e-01 + z * 5.04438716639811282616e-02;
	z2 = z * z;
	u2 = -1.91256895875763547298e-03 + z * 2.35252600561610495928e-05;
	z4 = z2 * z2;
	u = u1 + z2 * u2 + z4 * -9.19099158039878874504e-08;
	v1 = 1.0 + z * 1.99167318236649903973e-02;
	v2 = 2.02552581025135171496e-04 + z * 1.35608801097516229404e-06;
	v3 = 6.22741452364621501295e-09 + z * 1.66559246207992079114e-11;
	v = v1 + z2 * v2 + z4 * v3;
	return (x * (u / v) + 6.36619772367581382433e-01 * (__ieee754_j1(x) * __ieee754_log(x) - 1.0 / x));
}
#define __y1_finite(x)   __ieee754_y1((x))


LIB_FUNC double __ieee754_jn(const int num, const double numx) {
	int32_t i, hx, ix, lx, sgn, n = (int32_t)num;
	double a, b, temp, di, ret, z, w, x = numx;
	EXTRACT_SWORDS(hx, lx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(((uint32_t)ix | ((uint32_t)(lx | -lx)) >> 31) > 0x7ff00000)) { return x + x; }
	else if (n < 0) {
		n = -n;
		x = -x;
		hx ^= (int32_t)0x80000000;
	}
	if (n == 0) { return __ieee754_j0(x); }
	else if (n == 1) { return __ieee754_j1(x); }
	sgn = (n & 1) & (hx >> 31);
	x = fabs (x);
	// SET_RESTORE_ROUND(FE_TONEAREST);
	if (PREDICT_UNLIKELY((ix | lx) == 0 || ix >= 0x7ff00000)) { return sgn == 1 ? -0.0 : 0.0; }
	else if ((double)n <= x) {
		if (ix >= 0x52D00000) {
			double s, c;
			sincos(x, &s, &c);
			switch (n & 3) {
				case 0:
					temp = c + s;
					break;
				case 1:
					temp = -c + s;
					break;
				case 2:
					temp = -c - s;
					break;
				default:  // case 3
					temp = c - s;
					break;
			}
			b = 5.64189583547756279280e-01 * temp / __ieee754_sqrt(x);
		} else {
			a = __ieee754_j0 (x);
			b = __ieee754_j1 (x);
			for (i = 1; i < n; i++) {
				temp = b;
				b = b * ((double)(i + i) / x) - a;
				a = temp;
			}
		}
	} else {
		if (ix < 0x3e100000) {
			if (n > 33) { b = 0.0; }
			else {
				temp = x * 0.5;
				b = temp;
				for (a = 1.0, i = 2; i <= n; i++) {
					a *= (double) i;
					b *= temp;
				}
				b = b / a;
			}
		} else {
			double t, v;
			double q0, q1, h, tmp;
			int32_t k, m;
			w = (n + n) / (double) x;
			h = 2.0 / (double) x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0;
			k = 1;
			while (q1 < 1.0e9) {
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = 0.0, i = 2 * (n + k); i >= m; i -= 2) { t = 1.0 / (i / x - t); }
			a = t;
			b = 1.0;
			tmp = n;
			v = 2.0 / x;
			tmp = tmp * __ieee754_log (fabs (v * tmp));
			if (tmp < 7.09782712893383973096e+02) {
				for (i = n - 1, di = (double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0;
				}
			} else {
				for (i = n - 1, di = (double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0;
					if (b > 1e100) {
						a /= b;
						t /= b;
						b = 1.0;
					}
				}
			}
			z = __ieee754_j0(x);
			w = __ieee754_j1(x);
			if (fabs (z) >= fabs(w)) { b = (t * z / b); }
			else { b = (t * w / a); }
		}
	}
	if (sgn == 1) { ret = -b; }
	else { ret = b; }
	ret = math_narrow_eval(ret);
	if (ret == 0) {
		ret = math_narrow_eval (copysign(DBL_MIN, ret) * DBL_MIN);
		__set_errno(ERANGE);
	}  // else { math_check_force_underflow(ret); }
	return ret;
}
#define __jn_finite(n, x)   __ieee754_jn((n), (x))


LIB_FUNC double __ieee754_yn(const int num, const double x) {
	int32_t i, hx, ix, lx, sign, n = (int32_t)num;
	double a, b, temp, ret;
	EXTRACT_SWORDS(hx, lx, x);
	ix = 0x7fffffff & hx;
	if (PREDICT_UNLIKELY(((uint32_t)ix | (((uint32_t)lx | (uint32_t)-lx)) >> 31) > 0x7ff00000)) { return x + x; }
	else if (PREDICT_UNLIKELY((ix | lx) == 0)) { return -HUGE_VAL + x; }
	if (PREDICT_UNLIKELY(hx < 0)) { return 0.0 / (0.0 * x); }
	sign = 1;
	if (n < 0) {
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0) { return (__ieee754_y0(x)); }
	// SET_RESTORE_ROUND(FE_TONEAREST);
	if (n == 1) {
		ret = sign * __ieee754_y1(x);
		goto ieee754_yn_out;
	}
	if (PREDICT_UNLIKELY(ix == 0x7ff00000)) { return 0.0; }
	else if (ix >= 0x52D00000) {
		double c, s;
		sincos(x, &s, &c);
		switch (n & 3) {
			case 0:
				temp = s - c;
				break;
			case 1:
				temp = -s - c;
				break;
			case 2:
				temp = -s + c;
				break;
			default:  // case 3
				temp = s + c;
				break;
		}
		b = 5.64189583547756279280e-01 * temp / __ieee754_sqrt(x);
	} else {
		uint32_t high;
		a = __ieee754_y0(x);
		b = __ieee754_y1(x);
		GET_HIGH_WORD(high, b);
		for (i = 1; i < n && high != 0xfff00000; i++) {
			temp = b;
			b = ((double)(i + i) / x) * b - a;
			GET_HIGH_WORD(high, b);
			a = temp;
		}
		if (!isfinite(b)) { __set_errno(ERANGE); }
	}
	if (sign > 0) { ret = b; }
	else { ret = -b; }
ieee754_yn_out:
	if (__isinf(ret)) { ret = copysign(DBL_MAX, ret) * DBL_MAX; }
	return ret;
}
#define __yn_finite(n, x)   __ieee754_yn((n), (x))


#if (SIZEOF_LONG_DOUBLE == 96)


static const UNUSED long double pzerol_pR8[7] = {
	-4.094398895124198016684337960227780260127E-9L, -8.929643669432412640061946338524096893089E-7L,
	-6.281267456906136703868258380673108109256E-5L, -1.736902783620362966354814353559382399665E-3L,
	-1.831506216290984960532230842266070146847E-2L, -5.827178869301452892963280214772398135283E-2L,
	-2.087563267939546435460286895807046616992E-2L
};


static const UNUSED long double pzerol_pS8[6] = {
	5.823145095287749230197031108839653988393E-8L, 1.279281986035060320477759999428992730280E-5L,
	9.132668954726626677174825517150228961304E-4L, 2.606019379433060585351880541545146252534E-2L,
	2.956262215119520464228467583516287175244E-1L, 1.149498145388256448535563278632697465675E0L
};


static const UNUSED long double pzerol_pR5[7] = {
	-2.041226787870240954326915847282179737987E-7L, -2.255373879859413325570636768224534428156E-5L,
	-7.957485746440825353553537274569102059990E-4L, -1.093205102486816696940149222095559439425E-2L,
	-5.657957849316537477657603125260701114646E-2L, -8.641175552716402616180994954177818461588E-2L,
	-1.354654710097134007437166939230619726157E-2L
};


static const UNUSED long double pzerol_pS5[6] = {
	2.903078099681108697057258628212823545290E-6L, 3.253948449946735405975737677123673867321E-4L,
	1.181269751723085006534147920481582279979E-2L, 1.719212057790143888884745200257619469363E-1L,
	1.006306498779212467670654535430694221924E0L, 2.069568808688074324555596301126375951502E0L

};


static const UNUSED long double pzerol_pR3[7] = {
	-5.755732156848468345557663552240816066802E-6L, -3.703675625855715998827966962258113034767E-4L,
	-7.390893350679637611641350096842846433236E-3L, -5.571922144490038765024591058478043873253E-2L,
	-1.531290690378157869291151002472627396088E-1L, -1.193350853469302941921647487062620011042E-1L,
	-8.567802507331578894302991505331963782905E-3L
};


static const UNUSED long double pzerol_pS3[6] = {
	8.185931139070086158103309281525036712419E-5L, 5.398016943778891093520574483111255476787E-3L,
	1.130589193590489566669164765853409621081E-1L, 9.358652328786413274673192987670237145071E-1L,
	3.091711512598349056276917907005098085273E0L, 3.594602474737921977972586821673124231111E0L
};


static const UNUSED long double pzerol_pR2[7] = {
	-1.219525235804532014243621104365384992623E-4L, -4.838597135805578919601088680065298763049E-3L,
	-5.732223181683569266223306197751407418301E-2L, -2.472947430526425064982909699406646503758E-1L,
	-3.753373645974077960207588073975976327695E-1L, -1.556241316844728872406672349347137975495E-1L,
	-5.355423239526452209595316733635519506958E-3L
};


static const UNUSED long double pS2[6] = {
	1.734442793664291412489066256138894953823E-3L, 7.158111826468626405416300895617986926008E-2L,
	9.153839713992138340197264669867993552641E-1L, 4.539209519433011393525841956702487797582E0L,
	8.868932430625331650266067101752626253644E0L, 6.067161890196324146320763844772857713502E0L
};


LIB_FUNC long double pzerol(const long double x) {
	const long double *p, *q;
	long double z, r, s;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002) {
		p = pzerol_pR8;
		q = pzerol_pS8;
	} else {
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= 0x40019174) {
			p = pzerol_pR5;
			q = pzerol_pS5;
		} else if (i1 >= 0x4000b6db) {
			p = pzerol_pR3;
			q = pzerol_pS3;
		} else {
			p = pzerol_pR2;
			q = pzerol_pS2;
		}
	}
	z = 1.0L / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z)))));
	return (1.0L + z * r / s);
}


static const UNUSED long double qzerol_qR8[7] = {
	3.001267180483191397885272640777189348008E-10L, 8.693186311430836495238494289942413810121E-8L,
	8.496875536711266039522937037850596580686E-6L, 3.482702869915288984296602449543513958409E-4L,
	6.036378380706107692863811938221290851352E-3L, 3.881970028476167836382607922840452192636E-2L,
	6.132191514516237371140841765561219149638E-2L
};


static const UNUSED long double qzerol_qS8[7] = {
	4.097730123753051126914971174076227600212E-9L, 1.199615869122646109596153392152131139306E-6L,
	1.196337580514532207793107149088168946451E-4L, 5.099074440112045094341500497767181211104E-3L,
	9.577420799632372483249761659674764460583E-2L, 7.385243015344292267061953461563695918646E-1L,
	1.917266424391428937962682301561699055943E0L
};


static const UNUSED long double qzerol_qR5[7] = {
	3.406256556438974327309660241748106352137E-8L, 4.855492710552705436943630087976121021980E-6L,
	2.301011739663737780613356017352912281980E-4L, 4.500470249273129953870234803596619899226E-3L,
	3.651376459725695502726921248173637054828E-2L, 1.071578819056574524416060138514508609805E-1L,
	7.458950172851611673015774675225656063757E-2L
};


static const UNUSED long double qzerol_qS5[7] = {
	4.650675622764245276538207123618745150785E-7L, 6.773573292521412265840260065635377164455E-5L,
	3.340711249876192721980146877577806687714E-3L, 7.036218046856839214741678375536970613501E-2L,
	6.569599559163872573895171876511377891143E-1L, 2.557525022583599204591036677199171155186E0L,
	3.457237396120935674982927714210361269133E0L
};


static const UNUSED long double qzerol_qR3[7] = {
	1.749459596550816915639829017724249805242E-6L, 1.446252487543383683621692672078376929437E-4L,
	3.842084087362410664036704812125005761859E-3L, 4.066369994699462547896426554180954233581E-2L,
	1.721093619117980251295234795188992722447E-1L, 2.538595333972857367655146949093055405072E-1L,
	8.560591367256769038905328596020118877936E-2L
};


static const UNUSED long double qzerol_qS3[7] = {
	2.388596091707517488372313710647510488042E-5L, 2.048679968058758616370095132104333998147E-3L,
	5.824663198201417760864458765259945181513E-2L, 6.953906394693328750931617748038994763958E-1L,
	3.638186936390881159685868764832961092476E0L, 7.900169524705757837298990558459547842607E0L,
	5.992718532451026507552820701127504582907E0L
};


static const UNUSED long double qzerol_qR2[7] = {
	6.306524405520048545426928892276696949540E-5L, 3.209606155709930950935893996591576624054E-3L,
	5.027828775702022732912321378866797059604E-2L, 3.012705561838718956481911477587757845163E-1L,
	6.960544893905752937420734884995688523815E-1L, 5.431871999743531634887107835372232030655E-1L,
	9.447736151202905471899259026430157211949E-2L
};


static const UNUSED long double qzerol_qS2[7] = {
	8.610579901936193494609755345106129102676E-4L, 4.649054352710496997203474853066665869047E-2L,
	8.104282924459837407218042945106320388339E-1L, 5.807730930825886427048038146088828206852E0L,
	1.795310145936848873627710102199881642939E1L, 2.281313316875375733663657188888110605044E1L,
	1.011242067883822301487154844458322200143E1L
};


LIB_FUNC long double qzerol(const long double x) {
	const long double *p, *q;
	long double s, r, z;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002) {
		p = qzerol_qR8;
		q = qzerol_qS8;
	} else {
		i1 = (uint32_t)((ix << 16) | (i0 >> 16));
		if (i1 >= 0x40019174) {
			p = qzerol_qR5;
			q = qzerol_qS5;
		} else if (i1 >= 0x4000b6db) {
			p = qzerol_qR3;
			q = qzerol_qS3;
		} else {
			p = qzerol_qR2;
			q = qzerol_qS2;
		}
	}
	z = 1.0L / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z * (q[6] + z))))));
	return (-0.125L + z * r / s) / x;
}


LIB_FUNC long double __ieee754_j0l(const long double num) {
	long double z, s, c, ss, cc, r, u, v, x = num;
	int32_t ix;
	uint32_t se;
	GET_LDOUBLE_EXP(se, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY(ix >= 0x7fff)) { return 1.0L / (x * x); }
	x = fabsl(x);
	if (ix >= 0x4000) {
		sincosl(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7ffe) {
			z = -cosl(x + x);
			if ((s * c) < zero) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (PREDICT_UNLIKELY(ix > 0x4080)) { z = (5.6418958354775628694807945156077258584405e-1L * cc) / __ieee754_sqrtl(x); }
		else {
			u = pzerol(x);
			v = qzerol(x);
			z = 5.6418958354775628694807945156077258584405e-1L * (u * cc - v * ss) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (PREDICT_UNLIKELY(ix < 0x3fef)) {
		math_force_eval(1e4930L + x);
		if (ix < 0x3fde) { return 1.0L; }
		else { return 1.0L - 0.25 * x * x; }
	}
	z = x * x;
	r = z * (4.287176872744686992880841716723478740566E7L + z * (-6.652058897474241627570911531740907185772E5L + z * (7.011848381719789863458364584613651091175E3L + z * (-3.168040850193372408702135490809516253693E1L + z * 6.030778552661102450545394348845599300939E-2L))));
	s = 2.743793198556599677955266341699130654342E9L + z * (3.364330079384816249840086842058954076201E7L + z * (1.924119649412510777584684927494642526573E5L + z * (6.239282256012734914211715620088714856494E2L + z)));
	if (ix < 0x3fff) {
		return (1.0L - 0.25 * z + z * (r / s));
	} else {
		u = 0.5L * x;
		return ((1.0L + u) * (1.0L - u) + z * (r / s));
	}
}
#define __j0l_finite(x)   __ieee754_j0l((x))


LIB_FUNC long double __ieee754_y0l(const long double num) {
	long double z, s, c, ss, cc, u, v, x = num;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY(se & 0x8000)) { return 0.0L / (0.0L * x); }
	else if (PREDICT_UNLIKELY(ix >= 0x7fff)) { return 1.0L / (x + x * x); }
	else if (PREDICT_UNLIKELY((i0 | i1) == 0)) { return -HUGE_VALL + x; }
	else if (ix >= 0x4000) {
		sincosl(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7ffe) {
			z = -cosl(x + x);
			if ((s * c) < 0.0L) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (PREDICT_UNLIKELY(ix > 0x4080)) { z = (5.6418958354775628694807945156077258584405e-1L * ss) / __ieee754_sqrtl(x); }
		else {
			u = pzerol(x);
			v = qzerol(x);
			z = 5.6418958354775628694807945156077258584405e-1L * (u * ss + v * cc) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (PREDICT_UNLIKELY(ix <= 0x3fde)) {
		z = -7.380429510868722527629822444004602747322E-2L + 6.3661977236758134307553505349005744813784e-1L * __ieee754_logl(x);
		return z;
	}
	z = x * x;
	u = -1.054912306975785573710813351985351350861E10L + z * (2.520192609749295139432773849576523636127E10L + z * (-1.856426071075602001239955451329519093395E9L + z * (4.079209129698891442683267466276785956784E7L + z * (-3.440684087134286610316661166492641011539E5L + z * 1.005524356159130626192144663414848383774E3L))));
	v = 1.429337283720789610137291929228082613676E11L + z * (2.492593075325119157558811370165695013002E9L + z * (2.186077620785925464237324417623665138376E7L + z * (1.238407896366385175196515057064384929222E5L + z * (4.693924035211032457494368947123233101664E2L + z))));
	return (u / v + 6.3661977236758134307553505349005744813784e-1L * (__ieee754_j0l(x) * __ieee754_logl(x)));
}
#define __y0l_finite(x)   __ieee754_y0l((x))


static const UNUSED long double ponel_pr8[7] = {
	8.402048819032978959298664869941375143163E-9L, 1.813743245316438056192649247507255996036E-6L,
	1.260704554112906152344932388588243836276E-4L, 3.439294839869103014614229832700986965110E-3L,
	3.576910849712074184504430254290179501209E-2L, 1.131111483254318243139953003461511308672E-1L,
	4.480715825681029711521286449131671880953E-2L
};


static const UNUSED long double ponel_ps8[6] = {
	7.169748325574809484893888315707824924354E-8L, 1.556549720596672576431813934184403614817E-5L,
	1.094540125521337139209062035774174565882E-3L, 3.060978962596642798560894375281428805840E-2L,
	3.374146536087205506032643098619414507024E-1L, 1.253830208588979001991901126393231302559E0L
};


static const UNUSED long double ponel_pr5[7] = {
	4.318486887948814529950980396300969247900E-7L, 4.715341880798817230333360497524173929315E-5L,
	1.642719430496086618401091544113220340094E-3L, 2.228688005300803935928733750456396149104E-2L,
	1.142773760804150921573259605730018327162E-1L, 1.755576530055079253910829652698703791957E-1L,
	3.218803858282095929559165965353784980613E-2L
};


static const UNUSED long double ponel_ps5[6] = {
	3.685108812227721334719884358034713967557E-6L, 4.069102509511177498808856515005792027639E-4L,
	1.449728676496155025507893322405597039816E-2L, 2.058869213229520086582695850441194363103E-1L,
	1.164890985918737148968424972072751066553E0L, 2.274776933457009446573027260373361586841E0L
};


static const UNUSED long double ponel_pr3[7] = {
	1.265251153957366716825382654273326407972E-5L, 8.031057269201324914127680782288352574567E-4L,
	1.581648121115028333661412169396282881035E-2L, 1.179534658087796321928362981518645033967E-1L,
	3.227936912780465219246440724502790727866E-1L, 2.559223765418386621748404398017602935764E-1L,
	2.277136933287817911091370397134882441046E-2L
};


static const UNUSED long double ponel_ps3[6] = {
	1.079681071833391818661952793568345057548E-4L, 6.986017817100477138417481463810841529026E-3L,
	1.429403701146942509913198539100230540503E-1L, 1.148392024337075609460312658938700765074E0L,
	3.643663015091248720208251490291968840882E0L, 3.990702269032018282145100741746633960737E0L
};


static const UNUSED long double ponel_pr2[7] = {
	2.795623248568412225239401141338714516445E-4L, 1.092578168441856711925254839815430061135E-2L,
	1.278024620468953761154963591853679640560E-1L, 5.469680473691500673112904286228351988583E-1L,
	8.313769490922351300461498619045639016059E-1L, 3.544176317308370086415403567097130611468E-1L,
	1.604142674802373041247957048801599740644E-2L
};


static const UNUSED long double ponel_ps2[6] = {
	2.385605161555183386205027000675875235980E-3L, 9.616778294482695283928617708206967248579E-2L,
	1.195215570959693572089824415393951258510E0L, 5.718412857897054829999458736064922974662E0L,
	1.065626298505499086386584642761602177568E1L, 6.809140730053382188468983548092322151791E0L

};


LIB_FUNC long double ponel(const long double x) {
	const long double *p, *q;
	long double z, r, s;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002) {
		p = ponel_pr8;
		q = ponel_ps8;
	} else {
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= 0x40019174) {
			p = ponel_pr5;
			q = ponel_ps5;
		} else if (i1 >= 0x4000b6db) {
			p = ponel_pr3;
			q = ponel_ps3;
		} else {
			p = ponel_pr2;
			q = ponel_ps2;
		}
	}
	z = 1.0L / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z)))));
	return 1.0L + z * r / s;
}


static const UNUSED long double qonel_qr8[7] = {
	-5.691925079044209246015366919809404457380E-10L, -1.632587664706999307871963065396218379137E-7L,
	-1.577424682764651970003637263552027114600E-5L, -6.377627959241053914770158336842725291713E-4L,
	-1.087408516779972735197277149494929568768E-2L, -6.854943629378084419631926076882330494217E-2L,
	-1.055448290469180032312893377152490183203E-1L
};


static const UNUSED long double qonel_qs8[7] = {
	5.550982172325019811119223916998393907513E-9L, 1.607188366646736068460131091130644192244E-6L,
	1.580792530091386496626494138334505893599E-4L, 6.617859900815747303032860443855006056595E-3L,
	1.212840547336984859952597488863037659161E-1L, 9.017885953937234900458186716154005541075E-1L,
	2.201114489712243262000939120146436167178E0L
};


static const UNUSED long double qonel_qr5[7] = {
	-6.719134139179190546324213696633564965983E-8L, -9.467871458774950479909851595678622044140E-6L,
	-4.429341875348286176950914275723051452838E-4L, -8.539898021757342531563866270278505014487E-3L,
	-6.818691805848737010422337101409276287170E-2L, -1.964432669771684034858848142418228214855E-1L,
	-1.333896496989238600119596538299938520726E-1L
};


static const UNUSED long double qonel_qs5[7] = {
	6.552755584474634766937589285426911075101E-7L, 9.410814032118155978663509073200494000589E-5L,
	4.561677087286518359461609153655021253238E-3L, 9.397742096177905170800336715661091535805E-2L,
	8.518538116671013902180962914473967738771E-1L, 3.177729183645800174212539541058292579009E0L,
	4.006745668510308096259753538973038902990E0L
};


static const UNUSED long double qonel_qr3[7] = {
	-3.618746299358445926506719188614570588404E-6L, -2.951146018465419674063882650970344502798E-4L,
	-7.728518171262562194043409753656506795258E-3L, -8.058010968753999435006488158237984014883E-2L,
	-3.356232856677966691703904770937143483472E-1L, -4.858192581793118040782557808823460276452E-1L,
	-1.592399251246473643510898335746432479373E-1L
};


static const UNUSED long double qonel_qs3[7] = {
	3.529139957987837084554591421329876744262E-5L, 2.973602667215766676998703687065066180115E-3L,
	8.273534546240864308494062287908662592100E-2L, 9.613359842126507198241321110649974032726E-1L,
	4.853923697093974370118387947065402707519E0L, 1.002671608961669247462020977417828796933E1L,
	7.028927383922483728931327850683151410267E0L
};


static const UNUSED long double qonel_qr2[7] = {
	-1.372751603025230017220666013816502528318E-4L, -6.879190253347766576229143006767218972834E-3L,
	-1.061253572090925414598304855316280077828E-1L, -6.262164224345471241219408329354943337214E-1L,
	-1.423149636514768476376254324731437473915E0L, -1.087955310491078933531734062917489870754E0L,
	-1.826821119773182847861406108689273719137E-1L
};


static const UNUSED long double qonel_qs2[7] = {
	1.338768933634451601814048220627185324007E-3L, 7.071099998918497559736318523932241901810E-2L,
	1.200511429784048632105295629933382142221E0L, 8.327301713640367079030141077172031825276E0L,
	2.468479301872299311658145549931764426840E1L, 2.961179686096262083509383820557051621644E1L,
	1.201402313144305153005639494661767354977E1L
};


LIB_FUNC long double qonel(const long double x) {
	const long double *p, *q;
	static long double s, r, z;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002) {
		p = qonel_qr8;
		q = qonel_qs8;
	} else {
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= 0x40019174) {
			p = qonel_qr5;
			q = qonel_qs5;
		} else if (i1 >= 0x4000b6db) {
			p = qonel_qr3;
			q = qonel_qs3;
		} else {
			p = qonel_qr2;
			q = qonel_qs2;
		}
	}
	z = 1.0L / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z * (q[6] + z))))));
	return (0.375 + z * r / s) / x;
}


LIB_FUNC long double __ieee754_j1l(const long double num) {
	long double z, c, r, s, ss, cc, u, v, y, x = num;
	int32_t ix;
	uint32_t se;
	GET_LDOUBLE_EXP(se, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY(ix >= 0x7fff))
	{ return 1.0L / x; }
	y = fabsl(x);
	if (ix >= 0x4000) {
		sincosl(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7ffe) {
			z = cosl(y + y);
			if ((s * c) > 0.0L) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (PREDICT_UNLIKELY(ix > 0x4080)) { z = (5.6418958354775628694807945156077258584405e-1L * cc) / __ieee754_sqrtl(y); }
		else {
			u = ponel(y);
			v = qonel(y);
			z = 5.6418958354775628694807945156077258584405e-1L * (u * cc - v * ss) / __ieee754_sqrtl(y);
		}
		if (se & 0x8000) { return -z; }
		else { return z; }
	}
	if (PREDICT_UNLIKELY(ix < 0x3fde) {
		if (1e4930L + x > 1.0L) {
			long double ret = 0.5 * x;
			math_check_force_underflow(ret);
			if (ret == 0 && x != 0) { __set_errno(ERANGE); }
			return ret;
		}
	}
	z = x * x;
	r = z * (-9.647406112428107954753770469290757756814E7L + z * (2.686288565865230690166454005558203955564E6L + z * (-3.689682683905671185891885948692283776081E4L + z * (2.195031194229176602851429567792676658146E2L + z * -5.124499848728030297902028238597308971319E-1L))));
	s = 1.543584977988497274437410333029029035089E9L + z * (2.133542369567701244002565983150952549520E7L + z * (1.394077011298227346483732156167414670520E5L + z * (5.252401789085732428842871556112108446506E2L + z)));
	r *= x;
	return (x * 0.5L + r / s);
}
#define __j1l_finite(x)   __ieee754_j1l((x))


LIB_FUNC long double __ieee754_y1l(const long double num) {
	long double z, s, c, ss, cc, u, v, x = num;
	int32_t ix;
	uint32_t se, i0, i1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY(se & 0x8000)) { return 0.0L / (0.0L * x); }
	else if (PREDICT_UNLIKELY(ix >= 0x7fff)) { return 1.0L / (x + x * x); }
	else if (PREDICT_UNLIKELY((i0 | i1) == 0)) { return -HUGE_VALL + x; }
	else if (ix >= 0x4000) {
		sincosl(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7ffe) {
			z = cosl(x + x);
			if ((s * c) > 0.0L) { cc = z / ss; }
			else { ss = z / cc; }
		}
		if (PREDICT_UNLIKELY(ix > 0x4080)) { z = (5.6418958354775628694807945156077258584405e-1L * ss) / __ieee754_sqrtl(x); }
		else {
			u = ponel(x);
			v = qonel(x);
			z = 5.6418958354775628694807945156077258584405e-1L * (u * ss + v * cc) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (PREDICT_UNLIKELY(ix <= 0x3fbe)) {
		z = -6.3661977236758134307553505349005744813784e-1L / x;
		if (isinf(z)) { __set_errno(ERANGE); }
		return z;
	}
	z = x * x;
	u = -5.908077186259914699178903164682444848615E10L + z * (1.546219327181478013495975514375773435962E10L + z * (-6.438303331169223128870035584107053228235E8L + z * (9.708540045657182600665968063824819371216E6L + z * (-6.138043997084355564619377183564196265471E4L + z * 1.418503228220927321096904291501161800215E2L))));
	v = 3.013447341682896694781964795373783679861E11L + z * (4.669546565705981649470005402243136124523E9L + z * (3.595056091631351184676890179233695857260E7L + z * (1.761554028569108722903944659933744317994E5L + z * (5.668480419646516568875555062047234534863E2L + z))));
	return (x * (u / v) + 6.3661977236758134307553505349005744813784e-1L * (__ieee754_j1l(x) * __ieee754_logl(x) - 1.0L / x));
}
#define __y1l_finite(x)   __ieee754_y1l((x))


LIB_FUNC long double __ieee754_jnl(const int n, const long double x) {
	uint32_t se, i0, i1;
	int32_t i, ix, sgn;
	long double a, b, temp, di, ret, z, w;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY((ix == 0x7fff) && ((i0 & 0x7fffffff) != 0))) { return x + x; }
	if (n < 0) {
		n = -n;
		x = -x;
		se ^= 0x8000;
	}
	if (n == 0) { return __ieee754_j0l(x); }
	else if (n == 1) { return __ieee754_j1l(x); }
	sgn = (n & 1) & (se >> 15);
	x = fabsl(x);
	// SET_RESTORE_ROUNDL(FE_TONEAREST);
	if (PREDICT_UNLIKELY((ix | i0 | i1) == 0 || ix >= 0x7fff)) { return sgn == 1 ? -0.0L : 0.0L; }
	else if ((long double) n <= x) {
		if (ix >= 0x412D) {
			long double s, c;
			sincosl(x, &s, &c);
			switch (n & 3) {
				case 0:
					temp = c + s;
					break;
				case 1:
					temp = -c + s;
					break;
				case 2:
					temp = -c - s;
					break;
				case 3:
					temp = c - s;
					break;
			}
			b = 5.64189583547756286948079e-1L * temp / __ieee754_sqrtl(x);
		} else {
			a = __ieee754_j0l(x);
			b = __ieee754_j1l(x);
			for (i = 1; i < n; i++) {
				temp = b;
				b = b * ((long double)(i + i) / x) - a;
				a = temp;
			}
		}
	} else {
		if (ix < 0x3fde) {
			if (n >= 400) { b = 0.0L; }
			else {
				temp = x * 0.5;
				b = temp;
				for (a = 1.0L, i = 2; i <= n; i++) {
					a *= (long double) i;
					b *= temp;
				}
				b = b / a;
			}
		} else {
			long double t, v, q0, q1, h, tmp;
			int32_t k, m;
			w = (n + n) / (long double) x;
			h = 2.0L / (long double) x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0L;
			k = 1;
			while (q1 < 1.0e11L) {
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = 0.0L, i = 2 * (n + k); i >= m; i -= 2) { t = 1.0L / (i / x - t); }
			a = t;
			b = 1.0L;
			tmp = n;
			v = 2.0L / x;
			tmp = tmp * __ieee754_logl(fabsl(v * tmp));
			if (tmp < 1.1356523406294143949491931077970765006170e+04L) {
				for (i = n - 1, di = (long double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0L;
				}
			} else {
				for (i = n - 1, di = (long double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0L;
					if (b > 1e100L) {
						a /= b;
						t /= b;
						b = 1.0L;
					}
				}
			}
			z = __ieee754_j0l(x);
			w = __ieee754_j1l(x);
			if (fabsl(z) >= fabsl(w)) { b = (t * z / b); }
			else { b = (t * w / a); }
		}
	}
	if (sgn == 1) { ret = -b; }
	else { ret = b; }
	if (ret == 0) {
		ret = copysignl(LDBL_MIN, ret) * LDBL_MIN;
		__set_errno(ERANGE);
	}  // else { math_check_force_underflow(ret); }
	return ret;
}
#define __jnl_finite(n, x)   __ieee754_jnl((n), (x))


LIB_FUNC long double __ieee754_ynl(const int n, const long double x) {
	uint32_t se, i0, i1;
	int32_t i, ix, sign;
	long double a, b, temp, ret;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (PREDICT_UNLIKELY((ix == 0x7fff) && ((i0 & 0x7fffffff) != 0))) { return x + x; }
	else if (PREDICT_UNLIKELY((((uint32_t)ix) | i0 | i1) == 0)) { return ((n < 0 && (n & 1) != 0) ? 1.0L : -1.0L) / 0.0L; }
	else if (PREDICT_UNLIKELY(se & 0x8000)) { return 0.0L / (0.0L * x); }
	sign = 1;
	if (n < 0) {
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0) { return __ieee754_y0l(x); }
	// SET_RESTORE_ROUNDL(FE_TONEAREST);
	if (n == 1) {
		ret = sign * __ieee754_y1l(x);
		goto ieee754_ynl_out;
	}
	else if (PREDICT_UNLIKELY(ix == 0x7fff)) { return 0.0L; }
	else if (ix >= 0x412D) {
		long double s, c;
		sincosl(x, &s, &c);
		switch (n & 3) {
			case 0:
				temp = s - c;
				break;
			case 1:
				temp = -s - c;
				break;
			case 2:
				temp = -s + c;
				break;
			case 3:
				temp = s + c;
				break;
		}
		b = 5.64189583547756286948079e-1L * temp / __ieee754_sqrtl(x);
	} else {
		a = __ieee754_y0l(x);
		b = __ieee754_y1l(x);
		GET_LDOUBLE_WORDS(se, i0, i1, b);
		for (i = 1; i < n && se != 0xffffffff; i++) {
			temp = b;
			b = ((long double)(i + i) / x) * b - a;
			GET_LDOUBLE_WORDS(se, i0, i1, b);
			a = temp;
		}
	}
	if (!isfinitel(b)) { __set_errno(ERANGE); }
	if (sign > 0) { ret = b; }
	else { ret = -b; }
ieee754_ynl_out:
	if (isinf(ret)) { ret = copysignl(LDBL_MAX, ret) * LDBL_MAX; }
	return ret;
}
#define __ynl_finite(n, x)   __ieee754_ynl((n), (x))


#elif ((SIZEOF_LONG_DOUBLE == 128) || SUPPORTS_IBM_LONG_DOUBLE)


static const UNUSED long double J0_2N_j0l[7] = {
	3.133239376997663645548490085151484674892E16L, -5.479944965767990821079467311839107722107E14L,
	6.290828903904724265980249871997551894090E12L, -3.633750176832769659849028554429106299915E10L,
	1.207743757532429576399485415069244807022E8L, -2.107485999925074577174305650549367415465E5L,
	1.562826808020631846245296572935547005859E2L
};


static const UNUSED long double J0_2D_j0l[7] = {
	2.005273201278504733151033654496928968261E18L, 2.063038558793221244373123294054149790864E16L,
	1.053350447931127971406896594022010524994E14L, 3.496556557558702583143527876385508882310E11L,
	8.249114511878616075860654484367133976306E8L, 1.402965782449571800199759247964242790589E6L,
	1.619910762853439600957801751815074787351E3L
};


static const UNUSED long double P16_IN_j0l[10] = {
	-1.901689868258117463979611259731176301065E-16L, -1.798743043824071514483008340803573980931E-13L,
	-6.481746687115262291873324132944647438959E-11L, -1.150651553745409037257197798528294248012E-8L,
	-1.088408467297401082271185599507222695995E-6L, -5.551996725183495852661022587879817546508E-5L,
	-1.477286941214245433866838787454880214736E-3L, -1.882877976157714592017345347609200402472E-2L,
	-9.620983176855405325086530374317855880515E-2L, -1.271468546258855781530458854476627766233E-1L
};


static const UNUSED long double P16_ID_j0l[10] = {
	2.704625590411544837659891569420764475007E-15L, 2.562526347676857624104306349421985403573E-12L,
	9.259137589952741054108665570122085036246E-10L, 1.651044705794378365237454962653430805272E-7L,
	1.573561544138733044977714063100859136660E-5L, 8.134482112334882274688298469629884804056E-4L,
	2.219259239404080863919375103673593571689E-2L, 2.976990606226596289580242451096393862792E-1L,
	1.713895630454693931742734911930937246254E0L, 3.231552290717904041465898249160757368855E0L
};


static const UNUSED long double P8_16N_j0l[11] = {
	-2.335166846111159458466553806683579003632E-15L, -1.382763674252402720401020004169367089975E-12L,
	-3.192160804534716696058987967592784857907E-10L, -3.744199606283752333686144670572632116899E-8L,
	-2.439161236879511162078619292571922772224E-6L, -9.068436986859420951664151060267045346549E-5L,
	-1.905407090637058116299757292660002697359E-3L, -2.164456143936718388053842376884252978872E-2L,
	-1.212178415116411222341491717748696499966E-1L, -2.782433626588541494473277445959593334494E-1L,
	-1.670703190068873186016102289227646035035E-1L
};


static const UNUSED long double P8_16D_j0l[11] = {
	3.321126181135871232648331450082662856743E-14L, 1.971894594837650840586859228510007703641E-11L,
	4.571144364787008285981633719513897281690E-9L, 5.396419143536287457142904742849052402103E-7L,
	3.551548222385845912370226756036899901549E-5L, 1.342353874566932014705609788054598013516E-3L,
	2.899133293006771317589357444614157734385E-2L, 3.455374978185770197704507681491574261545E-1L,
	2.116616964297512311314454834712634820514E0L, 5.850768316827915470087758636881584174432E0L,
	5.655273858938766830855753983631132928968E0L
};


static const UNUSED long double P5_8N_j0l[11] = {
	-1.270478335089770355749591358934012019596E-12L, -4.007588712145412921057254992155810347245E-10L,
	-4.815187822989597568124520080486652009281E-8L, -2.867070063972764880024598300408284868021E-6L,
	-9.218742195161302204046454768106063638006E-5L, -1.635746821447052827526320629828043529997E-3L,
	-1.570376886640308408247709616497261011707E-2L, -7.656484795303305596941813361786219477807E-2L,
	-1.659371030767513274944805479908858628053E-1L, -1.185340550030955660015841796219919804915E-1L,
	-8.920026499909994671248893388013790366712E-3L
};


static const UNUSED long double P5_8D_j0l[10] = {
	1.806902521016705225778045904631543990314E-11L, 5.728502760243502431663549179135868966031E-9L,
	6.938168504826004255287618819550667978450E-7L, 4.183769964807453250763325026573037785902E-5L,
	1.372660678476925468014882230851637878587E-3L, 2.516452105242920335873286419212708961771E-2L,
	2.550502712902647803796267951846557316182E-1L, 1.365861559418983216913629123778747617072E0L,
	3.523825618308783966723472468855042541407E0L, 3.656365803506136165615111349150536282434E0L
};


static const UNUSED long double P4_5N_j0l[10] = {
	-9.791405771694098960254468859195175708252E-10L, -1.917193059944531970421626610188102836352E-7L,
	-1.393597539508855262243816152893982002084E-5L, -4.881863490846771259880606911667479860077E-4L,
	-8.946571245022470127331892085881699269853E-3L, -8.707474232568097513415336886103899434251E-2L,
	-4.362042697474650737898551272505525973766E-1L, -1.032712171267523975431451359962375617386E0L,
	-9.630502683169895107062182070514713702346E-1L, -2.251804386252969656586810309252357233320E-1L
};


static const UNUSED long double P4_5D_j0l[10] = {
	1.392555487577717669739688337895791213139E-8L, 2.748886559120659027172816051276451376854E-6L,
	2.024717710644378047477189849678576659290E-4L, 7.244868609350416002930624752604670292469E-3L,
	1.373631762292244371102989739300382152416E-1L, 1.412298581400224267910294815260613240668E0L,
	7.742495637843445079276397723849017617210E0L, 2.138429269198406512028307045259503811861E1L,
	2.651547684548423476506826951831712762610E1L, 1.167499382465291931571685222882909166935E1L
};


static const UNUSED long double P3r2_4N_j0l[10] = {
	-2.589155123706348361249809342508270121788E-8L, -3.746254369796115441118148490849195516593E-6L,
	-1.985595497390808544622893738135529701062E-4L, -5.008253705202932091290132760394976551426E-3L,
	-6.529469780539591572179155511840853077232E-2L, -4.468736064761814602927408833818990271514E-1L,
	-1.556391252586395038089729428444444823380E0L, -2.533135309840530224072920725976994981638E0L,
	-1.605509621731068453869408718565392869560E0L, -2.518966692256192789269859830255724429375E-1L
};


static const UNUSED long double P3r2_4D_j0l[10] = {
	3.682353957237979993646169732962573930237E-7L, 5.386741661883067824698973455566332102029E-5L,
	2.906881154171822780345134853794241037053E-3L, 7.545832595801289519475806339863492074126E-2L,
	1.029405357245594877344360389469584526654E0L, 7.565706120589873131187989560509757626725E0L,
	2.951172890699569545357692207898667665796E1L, 5.785723537170311456298467310529815457536E1L,
	5.095621464598267889126015412522773474467E1L, 1.602958484169953109437547474953308401442E1L
};


static const UNUSED long double P2r7_3r2N_j0l[10] = {
	-1.917322340814391131073820537027234322550E-7L, -1.966595744473227183846019639723259011906E-5L,
	-7.177081163619679403212623526632690465290E-4L, -1.206467373860974695661544653741899755695E-2L,
	-1.008656452188539812154551482286328107316E-1L, -4.216016116408810856620947307438823892707E-1L,
	-8.378631013025721741744285026537009814161E-1L, -6.973895635309960850033762745957946272579E-1L,
	-1.797864718878320770670740413285763554812E-1L, -4.098025357743657347681137871388402849581E-3L
};


static const UNUSED long double P2r7_3r2D_j0l[9] = {
	2.726858489303036441686496086962545034018E-6L, 2.840430827557109238386808968234848081424E-4L,
	1.063826772041781947891481054529454088832E-2L, 1.864775537138364773178044431045514405468E-1L,
	1.665660052857205170440952607701728254211E0L, 7.723745889544331153080842168958348568395E0L,
	1.810726427571829798856428548102077799835E1L, 1.986460672157794440666187503833545388527E1L,
	8.645503204552282306364296517220055815488E0L
};


static const UNUSED long double P2r3_2r7N_j0l[10] = {
	-1.594642785584856746358609622003310312622E-6L, -1.323238196302221554194031733595194539794E-4L,
	-3.856087818696874802689922536987100372345E-3L, -5.113241710697777193011470733601522047399E-2L,
	-3.334229537209911914449990372942022350558E-1L, -1.075703518198127096179198549659283422832E0L,
	-1.634174803414062725476343124267110981807E0L, -1.030133247434119595616826842367268304880E0L,
	-1.989811539080358501229347481000707289391E-1L, -3.246859189246653459359775001466924610236E-3L
};


static const UNUSED long double P2r3_2r7D_j0l[9] = {
	2.267936634217251403663034189684284173018E-5L, 1.918112982168673386858072491437971732237E-3L,
	5.771704085468423159125856786653868219522E-2L, 8.056124451167969333717642810661498890507E-1L,
	5.687897967531010276788680634413789328776E0L, 2.072596760717695491085444438270778394421E1L,
	3.801722099819929988585197088613160496684E1L, 3.254620235902912339534998592085115836829E1L,
	1.104847772130720331801884344645060675036E1L
};


static const UNUSED long double P2_2r3N_j0l[9] = {
	-1.001042324337684297465071506097365389123E-4L, -6.289034524673365824853547252689991418981E-3L,
	-1.346527918018624234373664526930736205806E-1L, -1.268808313614288355444506172560463315102E0L,
	-5.654126123607146048354132115649177406163E0L, -1.186649511267312652171775803270911971693E1L,
	-1.094032424931998612551588246779200724257E1L, -3.728792136814520055025256353193674625267E0L,
	-3.000348318524471807839934764596331810608E-1L
};


static const UNUSED long double P2_2r3D_j0l[9] = {
	1.423705538269770974803901422532055612980E-3L, 9.171476630091439978533535167485230575894E-2L,
	2.049776318166637248868444600215942828537E0L, 2.068970329743769804547326701946144899583E1L,
	1.025103500560831035592731539565060347709E2L, 2.528088049697570728252145557167066708284E2L,
	2.992160327587558573740271294804830114205E2L, 1.540193761146551025832707739468679973036E2L,
	2.779516701986912132637672140709452502650E1L
};


static const UNUSED long double Q16_IN_j0l[11] = {
	2.343640834407975740545326632205999437469E-18L, 2.667978112927811452221176781536278257448E-15L,
	1.178415018484555397390098879501969116536E-12L, 2.622049767502719728905924701288614016597E-10L,
	3.196908059607618864801313380896308968673E-8L, 2.179466154171673958770030655199434798494E-6L,
	8.139959091628545225221976413795645177291E-5L, 1.563900725721039825236927137885747138654E-3L,
	1.355172364265825167113562519307194840307E-2L, 3.928058355906967977269780046844768588532E-2L,
	1.107891967702173292405380993183694932208E-2L
};


static const UNUSED long double Q16_ID_j0l[10] = {
	3.199850952578356211091219295199301766718E-17L, 3.652601488020654842194486058637953363918E-14L,
	1.620179741394865258354608590461839031281E-11L, 3.629359209474609630056463248923684371426E-9L,
	4.473680923894354600193264347733477363305E-7L, 3.106368086644715743265603656011050476736E-5L,
	1.198239259946770604954664925153424252622E-3L, 2.446041004004283102372887804475767568272E-2L,
	2.403235525011860603014707768815113698768E-1L, 9.491006790682158612266270665136910927149E-1L
};


static const UNUSED long double Q8_16N_j0l[12] = {
	1.001954266485599464105669390693597125904E-17L, 7.545499865295034556206475956620160007849E-15L,
	2.267838684785673931024792538193202559922E-12L, 3.561909705814420373609574999542459912419E-10L,
	3.216201422768092505214730633842924944671E-8L, 1.731194793857907454569364622452058554314E-6L,
	5.576944613034537050396518509871004586039E-5L, 1.051787760316848982655967052985391418146E-3L,
	1.102852974036687441600678598019883746959E-2L, 5.834647019292460494254225988766702933571E-2L,
	1.290281921604364618912425380717127576529E-1L, 7.598886310387075708640370806458926458301E-2L
};


static const UNUSED long double Q8_16D_j0l[12] = {
	1.368001558508338469503329967729951830843E-16L, 1.034454121857542147020549303317348297289E-13L,
	3.128109209247090744354764050629381674436E-11L, 4.957795214328501986562102573522064468671E-9L,
	4.537872468606711261992676606899273588899E-7L, 2.493639207101727713192687060517509774182E-5L,
	8.294957278145328349785532236663051405805E-4L, 1.646471258966713577374948205279380115839E-2L,
	1.878910092770966718491814497982191447073E-1L, 1.152641605706170353727903052525652504075E0L,
	3.383550240669773485412333679367792932235E0L, 3.823875252882035706910024716609908473970E0L
};


static const UNUSED long double Q5_8N_j0l[11] = {
	1.750399094021293722243426623211733898747E-13L, 6.483426211748008735242909236490115050294E-11L,
	9.279430665656575457141747875716899958373E-9L, 6.696634968526907231258534757736576340266E-7L,
	2.666560823798895649685231292142838188061E-5L, 6.025087697259436271271562769707550594540E-4L,
	7.652807734168613251901945778921336353485E-3L, 5.226269002589406461622551452343519078905E-2L,
	1.748390159751117658969324896330142895079E-1L, 2.378188719097006494782174902213083589660E-1L,
	8.383984859679804095463699702165659216831E-2L
};


static const UNUSED long double Q5_8D_j0l[11] = {
	2.389878229704327939008104855942987615715E-12L, 8.926142817142546018703814194987786425099E-10L,
	1.294065862406745901206588525833274399038E-7L, 9.524139899457666250828752185212769682191E-6L,
	3.908332488377770886091936221573123353489E-4L, 9.250427033957236609624199884089916836748E-3L,
	1.263420066165922645975830877751588421451E-1L, 9.692527053860420229711317379861733180654E-1L,
	3.937813834630430172221329298841520707954E0L, 7.603126427436356534498908111445191312181E0L,
	5.670677653334105479259958485084550934305E0L
};


static const UNUSED long double Q4_5N_j0l[11] = {
	2.233870042925895644234072357400122854086E-11L, 5.146223225761993222808463878999151699792E-9L,
	4.459114531468296461688753521109797474523E-7L, 1.891397692931537975547242165291668056276E-5L,
	4.279519145911541776938964806470674565504E-4L, 5.275239415656560634702073291768904783989E-3L,
	3.468698403240744801278238473898432608887E-2L, 1.138773146337708415188856882915457888274E-1L,
	1.622717518946443013587108598334636458955E-1L, 7.249040006390586123760992346453034628227E-2L,
	1.941595365256460232175236758506411486667E-3L
};


static const UNUSED long double Q4_5D_j0l[10] = {
	3.049977232266999249626430127217988047453E-10L, 7.120883230531035857746096928889676144099E-8L,
	6.301786064753734446784637919554359588859E-6L, 2.762010530095069598480766869426308077192E-4L,
	6.572163250572867859316828886203406361251E-3L, 8.752566114841221958200215255461843397776E-2L,
	6.487654992874805093499285311075289932664E-1L, 2.576550017826654579451615283022812801435E0L,
	5.056392229924022835364779562707348096036E0L, 4.179770081068251464907531367859072157773E0L
};


static const UNUSED long double Q3r2_4N_j0l[11] = {
	6.126167301024815034423262653066023684411E-10L, 1.043969327113173261820028225053598975128E-7L,
	6.592927270288697027757438170153763220190E-6L, 2.009103660938497963095652951912071336730E-4L,
	3.220543385492643525985862356352195896964E-3L, 2.774405975730545157543417650436941650990E-2L,
	1.258114008023826384487378016636555041129E-1L, 2.811724258266902502344701449984698323860E-1L,
	2.691837665193548059322831687432415014067E-1L, 7.949087384900985370683770525312735605034E-2L,
	1.229509543620976530030153018986910810747E-3L
};


static const UNUSED long double Q3r2_4D_j0l[10] = {
	8.364260446128475461539941389210166156568E-9L, 1.451301850638956578622154585560759862764E-6L,
	9.431830010924603664244578867057141839463E-5L, 3.004105101667433434196388593004526182741E-3L,
	5.148157397848271739710011717102773780221E-2L, 4.901089301726939576055285374953887874895E-1L,
	2.581760991981709901216967665934142240346E0L, 7.257105880775059281391729708630912791847E0L,
	1.006014717326362868007913423810737369312E1L, 5.879416600465399514404064187445293212470E0L
};


static const UNUSED long double Q2r7_3r2N_j0l[10] = {
	7.584861620402450302063691901886141875454E-8L, 9.300939338814216296064659459966041794591E-6L,
	4.112108906197521696032158235392604947895E-4L, 8.515168851578898791897038357239630654431E-3L,
	8.971286321017307400142720556749573229058E-2L, 4.885856732902956303343015636331874194498E-1L,
	1.334506268733103291656253500506406045846E0L, 1.681207956863028164179042145803851824654E0L,
	8.165042692571721959157677701625853772271E-1L, 9.805848115375053300608712721986235900715E-2L
};


static const UNUSED long double Q2r7_3r2D_j0l[10] = {
	1.035586492113036586458163971239438078160E-6L, 1.301999337731768381683593636500979713689E-4L,
	5.993695702564527062553071126719088859654E-3L, 1.321184892887881883489141186815457808785E-1L,
	1.528766555485015021144963194165165083312E0L, 9.561463309176490874525827051566494939295E0L,
	3.203719484883967351729513662089163356911E1L, 5.497294687660930446641539152123568668447E1L,
	4.391158169390578768508675452986948391118E1L, 1.347836630730048077907818943625789418378E1L
};


static const UNUSED long double Q2r3_2r7N_j0l[10] = {
	4.455027774980750211349941766420190722088E-7L, 4.031998274578520170631601850866780366466E-5L,
	1.273987274325947007856695677491340636339E-3L, 1.818754543377448509897226554179659122873E-2L,
	1.266748858326568264126353051352269875352E-1L, 4.327578594728723821137731555139472880414E-1L,
	6.892532471436503074928194969154192615359E-1L, 4.490775818438716873422163588640262036506E-1L,
	8.649615949297322440032000346117031581572E-2L, 7.261345286655345047417257611469066147561E-4L
};


static const UNUSED long double Q2r3_2r7D_j0l[9] = {
	6.082600739680555266312417978064954793142E-6L, 5.693622538165494742945717226571441747567E-4L,
	1.901625907009092204458328768129666975975E-2L, 2.958689532697857335456896889409923371570E-1L,
	2.343124711045660081603809437993368799568E0L, 9.665894032187458293568704885528192804376E0L,
	2.035273104990617136065743426322454881353E1L, 2.044102010478792896815088858740075165531E1L,
	8.445937177863155827844146643468706599304E0L
};


static const UNUSED long double Q2_2r3N_j0l[10] = {
	2.817566786579768804844367382809101929314E-6L, 2.122772176396691634147024348373539744935E-4L,
	5.501378031780457828919593905395747517585E-3L, 6.355374424341762686099147452020466524659E-2L,
	3.539652320122661637429658698954748337223E-1L, 9.571721066119617436343740541777014319695E-1L,
	1.196258777828426399432550698612171955305E0L, 6.069388659458926158392384709893753793967E-1L,
	9.026746127269713176512359976978248763621E-2L, 5.317668723070450235320878117210807236375E-4L
};


static const UNUSED long double Q2_2r3D_j0l[9] = {
	3.846924354014260866793741072933159380158E-5L, 3.017562820057704325510067178327449946763E-3L,
	8.356305620686867949798885808540444210935E-2L, 1.068314930499906838814019619594424586273E0L,
	6.900279623894821067017966573640732685233E0L, 2.307667390886377924509090271780839563141E1L,
	3.921043465412723970791036825401273528513E1L, 3.167569478939719383241775717095729233436E1L,
	1.051023841699200920276198346301543665909E1L
};


LIB_FUNC long double __ieee754_j0l(const long double num) {
	long double xx, xinv, z, p, q, c, s, cc, ss, x = num;
	if (!isfinitel(x)) {
		if (x != x) { return x; }
		else { return 0.0L; }
	}
	if (x == 0.0L) { return 1.0L; }
	xx = fabsl(x);
	if (xx <= 2.0L) {
		if (xx < 0x1p-57L) { return 1.0L; }
		z = xx * xx;
		p = z * z * neval(z, J0_2N_j0l, 6) / deval(z, J0_2D_j0l, 6);
		p -= 0.25L * z;
		p += 1.0L;
		return p;
	}
	sincosl(xx, &s, &c);
	ss = s - c;
	cc = s + c;
	if (xx <= LDBL_MAX / 2.0L) {
		z = -cosl(xx + xx);
		if ((s * c) < 0) { cc = z / ss; }
		else { ss = z / cc; }
	}
	if (xx > 0x1p256L) { return 5.6418958354775628694807945156077258584405E-1L * cc / __ieee754_sqrtl(xx); }
	xinv = 1.0L / xx;
	z = xinv * xinv;
	if (xinv <= 0.25L) {
		if (xinv <= 0.125L) {
			if (xinv <= 0.0625L) {
				p = neval(z, P16_IN_j0l, 9) / deval(z, P16_ID_j0l, 9);
				q = neval(z, Q16_IN_j0l, 10) / deval(z, Q16_ID_j0l, 9);
			} else {
				p = neval(z, P8_16N_j0l, 10) / deval(z, P8_16D_j0l, 10);
				q = neval(z, Q8_16N_j0l, 11) / deval(z, Q8_16D_j0l, 11);
			}
		} else if (xinv <= 0.1875L) {
			p = neval(z, P5_8N_j0l, 10) / deval(z, P5_8D_j0l, 9);
			q = neval(z, Q5_8N_j0l, 10) / deval(z, Q5_8D_j0l, 10);
		} else {
			p = neval(z, P4_5N_j0l, 9) / deval(z, P4_5D_j0l, 9);
			q = neval(z, Q4_5N_j0l, 10) / deval(z, Q4_5D_j0l, 9);
		}
	} else {
		if (xinv <= 0.375L) {
			if (xinv <= 0.3125L) {
				p = neval(z, P3r2_4N_j0l, 9) / deval(z, P3r2_4D_j0l, 9);
				q = neval(z, Q3r2_4N_j0l, 10) / deval(z, Q3r2_4D_j0l, 9);
			} else {
				p = neval(z, P2r7_3r2N_j0l, 9) / deval(z, P2r7_3r2D_j0l, 8);
				q = neval(z, Q2r7_3r2N_j0l, 9) / deval(z, Q2r7_3r2D_j0l, 9);
			}
		} else if (xinv <= 0.4375L) {
			p = neval(z, P2r3_2r7N_j0l, 9) / deval(z, P2r3_2r7D_j0l, 8);
			q = neval(z, Q2r3_2r7N_j0l, 9) / deval(z, Q2r3_2r7D_j0l, 8);
		} else {
			p = neval(z, P2_2r3N_j0l, 8) / deval(z, P2_2r3D_j0l, 8);
			q = neval(z, Q2_2r3N_j0l, 9) / deval(z, Q2_2r3D_j0l, 8);
		}
	}
	p = 1.0L + z * p;
	q = z * xinv * q;
	q = q - 0.125L * xinv;
	z = 5.6418958354775628694807945156077258584405E-1L * (p * cc - q * ss) / __ieee754_sqrtl(xx);
	return z;
}
#define __j0l_finite(x)   __ieee754_j0l((x))


static const UNUSED long double Y0_2N_y0l[8] = {
	-1.062023609591350692692296993537002558155E19L, 2.542000883190248639104127452714966858866E19L,
	-1.984190771278515324281415820316054696545E18L, 4.982586044371592942465373274440222033891E16L,
	-5.529326354780295177243773419090123407550E14L, 3.013431465522152289279088265336861140391E12L,
	-7.959436160727126750732203098982718347785E9L, 8.230845651379566339707130644134372793322E6L
};


static const UNUSED long double Y0_2D_y0l[8] = {
	1.438972634353286978700329883122253752192E20L, 1.856409101981569254247700169486907405500E18L,
	1.219693352678218589553725579802986255614E16L, 5.389428943282838648918475915779958097958E13L,
	1.774125762108874864433872173544743051653E11L, 4.522104832545149534808218252434693007036E8L,
	8.872187401232943927082914504125234454930E5L, 1.251945613186787532055610876304669413955E3L
};


LIB_FUNC long double __ieee754_y0l(const long double num) {
	long double xx, xinv, z, p, q, c, s, cc, ss, x = num;
	if (!isfinitel(x)) {
		if (x != x) { return x; }
		else { return 0.0L; }
	}
	if (x <= 0.0L) {
		if (x < 0.0L) { return (0.0L / (0.0L * x)); }
		return (long double)((-(HUGE_VALL)) + x);
	}
	xx = fabsl(x);
	if (xx <= 0x1p-57) { return -7.3804295108687225274343927948483016310862e-02L + 6.3661977236758134307553505349005744813784E-1L * __ieee754_logl(x); }
	if (xx <= 2.0L) {
		z = xx * xx;
		p = neval(z, Y0_2N_y0l, 7) / deval(z, Y0_2D_y0l, 7);
		p = 6.3661977236758134307553505349005744813784E-1L * __ieee754_logl(x) * __ieee754_j0l(x) + p;
		return p;
	}
	sincosl(x, &s, &c);
	ss = s - c;
	cc = s + c;
	if (xx <= LDBL_MAX / 2.0L) {
		z = -cosl(x + x);
		if ((s * c) < 0) { cc = z / ss; }
		else { ss = z / cc; }
	}
	if (xx > 0x1p256L) { return 5.6418958354775628694807945156077258584405E-1L * ss / __ieee754_sqrtl(x); }
	xinv = 1.0L / xx;
	z = xinv * xinv;
	if (xinv <= 0.25L) {
		if (xinv <= 0.125L) {
			if (xinv <= 0.0625L) {
				p = neval(z, P16_IN_j0l, 9) / deval(z, P16_ID_j0l, 9);
				q = neval(z, Q16_IN_j0l, 10) / deval(z, Q16_ID_j0l, 9);
			} else {
				p = neval(z, P8_16N_j0l, 10) / deval(z, P8_16D_j0l, 10);
				q = neval(z, Q8_16N_j0l, 11) / deval(z, Q8_16D_j0l, 11);
			}
		} else if (xinv <= 0.1875L) {
			p = neval(z, P5_8N_j0l, 10) / deval(z, P5_8D_j0l, 9);
			q = neval(z, Q5_8N_j0l, 10) / deval(z, Q5_8D_j0l, 10);
		} else {
			p = neval(z, P4_5N_j0l, 9) / deval(z, P4_5D_j0l, 9);
			q = neval(z, Q4_5N_j0l, 10) / deval(z, Q4_5D_j0l, 9);
		}
	} else {
		if (xinv <= 0.375L) {
			if (xinv <= 0.3125L) {
				p = neval(z, P3r2_4N_j0l, 9) / deval(z, P3r2_4D_j0l, 9);
				q = neval(z, Q3r2_4N_j0l, 10) / deval(z, Q3r2_4D_j0l, 9);
			} else {
				p = neval(z, P2r7_3r2N_j0l, 9) / deval(z, P2r7_3r2D_j0l, 8);
				q = neval(z, Q2r7_3r2N_j0l, 9) / deval(z, Q2r7_3r2D_j0l, 9);
			}
		} else if (xinv <= 0.4375L) {
			p = neval(z, P2r3_2r7N_j0l, 9) / deval(z, P2r3_2r7D_j0l, 8);
			q = neval(z, Q2r3_2r7N_j0l, 9) / deval(z, Q2r3_2r7D_j0l, 8);
		} else {
			p = neval(z, P2_2r3N_j0l, 8) / deval(z, P2_2r3D_j0l, 8);
			q = neval(z, Q2_2r3N_j0l, 9) / deval(z, Q2_2r3D_j0l, 8);
		}
	}
	p = 1.0L + z * p;
	q = z * xinv * q;
	q = q - 0.125L * xinv;
	z = 5.6418958354775628694807945156077258584405E-1L * (p * ss + q * cc) / __ieee754_sqrtl(x);
	return z;
}
#define __y0l_finite(x)   __ieee754_y0l((x))


static const UNUSED long double J0_2N_j1l[7] = {
	-5.943799577386942855938508697619735179660E16L, 1.812087021305009192259946997014044074711E15L,
	-2.761698314264509665075127515729146460895E13L, 2.091089497823600978949389109350658815972E11L,
	-8.546413231387036372945453565654130054307E8L, 1.797229225249742247475464052741320612261E6L,
	-1.559552840946694171346552770008812083969E3L
};


static const UNUSED long double J0_2D_j1l[7] = {
	9.510079323819108569501613916191477479397E17L, 1.063193817503280529676423936545854693915E16L,
	5.934143516050192600795972192791775226920E13L, 2.168000911950620999091479265214368352883E11L,
	5.673775894803172808323058205986256928794E8L, 1.080329960080981204840966206372671147224E6L,
	1.411951256636576283942477881535283304912E3L
};


static const UNUSED long double P16_IN_j1l[10] = {
	5.143674369359646114999545149085139822905E-16L, 4.836645664124562546056389268546233577376E-13L,
	1.730945562285804805325011561498453013673E-10L, 3.047976856147077889834905908605310585810E-8L,
	2.855227609107969710407464739188141162386E-6L, 1.439362407936705484122143713643023998457E-4L,
	3.774489768532936551500999699815873422073E-3L, 4.723962172984642566142399678920790598426E-2L,
	2.359289678988743939925017240478818248735E-1L, 3.032580002220628812728954785118117124520E-1L
};


static const UNUSED long double P16_ID_j1l[10] = {
	4.389268795186898018132945193912677177553E-15L, 4.132671824807454334388868363256830961655E-12L,
	1.482133328179508835835963635130894413136E-9L, 2.618941412861122118906353737117067376236E-7L,
	2.467854246740858470815714426201888034270E-5L, 1.257192927368839847825938545925340230490E-3L,
	3.362739031941574274949719324644120720341E-2L, 4.384458231338934105875343439265370178858E-1L,
	2.412830809841095249170909628197264854651E0L, 4.176078204111348059102962617368214856874E0L
};


static const UNUSED long double P8_16N_j1l[12] = {
	2.984612480763362345647303274082071598135E-16L, 1.923651877544126103941232173085475682334E-13L,
	4.881258879388869396043760693256024307743E-11L, 6.368866572475045408480898921866869811889E-9L,
	4.684818344104910450523906967821090796737E-7L, 2.005177298271593587095982211091300382796E-5L,
	4.979808067163957634120681477207147536182E-4L, 6.946005761642579085284689047091173581127E-3L,
	5.074601112955765012750207555985299026204E-2L, 1.698599455896180893191766195194231825379E-1L,
	1.957536905259237627737222775573623779638E-1L, 2.991314703282528370270179989044994319374E-2L
};


static const UNUSED long double P8_16D_j1l[11] = {
	2.546869316918069202079580939942463010937E-15L, 1.644650111942455804019788382157745229955E-12L,
	4.185430770291694079925607420808011147173E-10L, 5.485331966975218025368698195861074143153E-8L,
	4.062884421686912042335466327098932678905E-6L, 1.758139661060905948870523641319556816772E-4L,
	4.445143889306356207566032244985607493096E-3L, 6.391901016293512632765621532571159071158E-2L,
	4.933040207519900471177016015718145795434E-1L, 1.839144086168947712971630337250761842976E0L,
	2.715120873995490920415616716916149586579E0L
};


static const UNUSED long double P5_8N_j1l[11] = {
	2.837678373978003452653763806968237227234E-12L, 9.726641165590364928442128579282742354806E-10L,
	1.284408003604131382028112171490633956539E-7L, 8.524624695868291291250573339272194285008E-6L,
	3.111516908953172249853673787748841282846E-4L, 6.423175156126364104172801983096596409176E-3L,
	7.430220589989104581004416356260692450652E-2L, 4.608315409833682489016656279567605536619E-1L,
	1.396870223510964882676225042258855977512E0L, 1.718500293904122365894630460672081526236E0L,
	5.465927698800862172307352821870223855365E-1L
};


static const UNUSED long double P5_8D_j1l[11] = {
	2.421485545794616609951168511612060482715E-11L, 8.329862750896452929030058039752327232310E-9L,
	1.106137992233383429630592081375289010720E-6L, 7.405786153760681090127497796448503306939E-5L,
	2.740364785433195322492093333127633465227E-3L, 5.781246470403095224872243564165254652198E-2L,
	6.927711353039742469918754111511109983546E-1L, 4.558679283460430281188304515922826156690E0L,
	1.534468499844879487013168065728837900009E1L, 2.313927430889218597919624843161569422745E1L,
	1.194506341319498844336768473218382828637E1L
};


static const UNUSED long double P4_5N_j1l[11] = {
	1.846029078268368685834261260420933914621E-10L, 3.916295939611376119377869680335444207768E-8L,
	3.122158792018920627984597530935323997312E-6L, 1.218073444893078303994045653603392272450E-4L,
	2.536420827983485448140477159977981844883E-3L, 2.883011322006690823959367922241169171315E-2L,
	1.755255190734902907438042414495469810830E-1L, 5.379317079922628599870898285488723736599E-1L,
	7.284904050194300773890303361501726561938E-1L, 3.270110346613085348094396323925000362813E-1L,
	1.804473805689725610052078464951722064757E-2L
};


static const UNUSED long double P4_5D_j1l[10] = {
	1.575278146806816970152174364308980863569E-9L, 3.361289173657099516191331123405675054321E-7L,
	2.704692281550877810424745289838790693708E-5L, 1.070854930483999749316546199273521063543E-3L,
	2.282373093495295842598097265627962125411E-2L, 2.692025460665354148328762368240343249830E-1L,
	1.739892942593664447220951225734811133759E0L, 5.890727576752230385342377570386657229324E0L,
	9.517442287057841500750256954117735128153E0L, 6.100616353935338240775363403030137736013E0L
};


static const UNUSED long double P3r2_4N_j1l[10] = {
	8.240803130988044478595580300846665863782E-8L, 1.179418958381961224222969866406483744580E-5L,
	6.179787320956386624336959112503824397755E-4L, 1.540270833608687596420595830747166658383E-2L,
	1.983904219491512618376375619598837355076E-1L, 1.341465722692038870390470651608301155565E0L,
	4.617865326696612898792238245990854646057E0L, 7.435574801812346424460233180412308000587E0L,
	4.671327027414635292514599201278557680420E0L, 7.299530852495776936690976966995187714739E-1L
};


static const UNUSED long double P3r2_4D_j1l[10] = {
	7.032152009675729604487575753279187576521E-7L, 1.015090352324577615777511269928856742848E-4L,
	5.394262184808448484302067955186308730620E-3L, 1.375291438480256110455809354836988584325E-1L,
	1.836247144461106304788160919310404376670E0L, 1.314378564254376655001094503090935880349E1L,
	4.957184590465712006934452500894672343488E1L, 9.287394244300647738855415178790263465398E1L,
	7.652563275535900609085229286020552768399E1L, 2.147042473003074533150718117770093209096E1L
};


static const UNUSED long double P2r7_3r2N_j1l[10] = {
	4.599033469240421554219816935160627085991E-7L, 4.665724440345003914596647144630893997284E-5L,
	1.684348845667764271596142716944374892756E-3L, 2.802446446884455707845985913454440176223E-2L,
	2.321937586453963310008279956042545173930E-1L, 9.640277413988055668692438709376437553804E-1L,
	1.911021064710270904508663334033003246028E0L, 1.600811610164341450262992138893970224971E0L,
	4.266299218652587901171386591543457861138E-1L, 1.316470424456061252962568223251247207325E-2L
};


static const UNUSED long double P2r7_3r2D_j1l[9] = {
	3.924508608545520758883457108453520099610E-6L, 4.029707889408829273226495756222078039823E-4L,
	1.484629715787703260797886463307469600219E-2L, 2.553136379967180865331706538897231588685E-1L,
	2.229457223891676394409880026887106228740E0L, 1.005708903856384091956550845198392117318E1L,
	2.277082659664386953166629360352385889558E1L, 2.384726835193630788249826630376533988245E1L,
	9.700989749041320895890113781610939632410E0L
};


static const UNUSED long double P2r3_2r7N_j1l[10] = {
	3.916766777108274628543759603786857387402E-6L, 3.212176636756546217390661984304645137013E-4L,
	9.255768488524816445220126081207248947118E-3L, 1.214853146369078277453080641911700735354E-1L,
	7.855163309847214136198449861311404633665E-1L, 2.520058073282978403655488662066019816540E0L,
	3.825136484837545257209234285382183711466E0L, 2.432569427554248006229715163865569506873E0L,
	4.877934835018231178495030117729800489743E-1L, 1.109902737860249670981355149101343427885E-2L
};


static const UNUSED long double P2r3_2r7D_j1l[9] = {
	3.342307880794065640312646341190547184461E-5L, 2.782182891138893201544978009012096558265E-3L,
	8.221304931614200702142049236141249929207E-2L, 1.123728246291165812392918571987858010949E0L,
	7.740482453652715577233858317133423434590E0L, 2.737624677567945952953322566311201919139E1L,
	4.837181477096062403118304137851260715475E1L, 3.941098643468580791437772701093795299274E1L,
	1.245821247166544627558323920382547533630E1L
};


static const UNUSED long double P2_2r3N_j1l[9] = {
	3.397930802851248553545191160608731940751E-4L, 2.104020902735482418784312825637833698217E-2L,
	4.442291771608095963935342749477836181939E-1L, 4.131797328716583282869183304291833754967E0L,
	1.819920169779026500146134832455189917589E1L, 3.781779616522937565300309684282401791291E1L,
	3.459605449728864218972931220783543410347E1L, 1.173594248397603882049066603238568316561E1L,
	9.455702270242780642835086549285560316461E-1L
};


static const UNUSED long double P2_2r3D_j1l[9] = {
	2.899568897241432883079888249845707400614E-3L, 1.831107138190848460767699919531132426356E-1L,
	3.999350044057883839080258832758908825165E0L, 3.929041535867957938340569419874195303712E1L,
	1.884245613422523323068802689915538908291E2L, 4.461469948819229734353852978424629815929E2L,
	5.004998753999796821224085972610636347903E2L, 2.386342520092608513170837883757163414100E2L,
	3.791322528149347975999851588922424189957E1L
};


static const UNUSED long double Q16_IN_j1l[11] = {
	-3.917420835712508001321875734030357393421E-18L, -4.440311387483014485304387406538069930457E-15L,
	-1.951635424076926487780929645954007139616E-12L, -4.318256438421012555040546775651612810513E-10L,
	-5.231244131926180765270446557146989238020E-8L, -3.540072702902043752460711989234732357653E-6L,
	-1.311017536555269966928228052917534882984E-4L, -2.495184669674631806622008769674827575088E-3L,
	-2.141868222987209028118086708697998506716E-2L, -6.184031415202148901863605871197272650090E-2L,
	-1.922298704033332356899546792898156493887E-2L
};


static const UNUSED long double Q16_ID_j1l[10] = {
	3.820418034066293517479619763498400162314E-17L, 4.340702810799239909648911373329149354911E-14L,
	1.914985356383416140706179933075303538524E-11L, 4.262333682610888819476498617261895474330E-9L,
	5.213481314722233980346462747902942182792E-7L, 3.585741697694069399299005316809954590558E-5L,
	1.366513429642842006385029778105539457546E-3L, 2.745282599850704662726337474371355160594E-2L,
	2.637644521611867647651200098449903330074E-1L, 1.006953426110765984590782655598680488746E0L
};


static const UNUSED long double Q8_16N_j1l[12] = {
	-2.028630366670228670781362543615221542291E-17L, -1.519634620380959966438130374006858864624E-14L,
	-4.540596528116104986388796594639405114524E-12L, -7.085151756671466559280490913558388648274E-10L,
	-6.351062671323970823761883833531546885452E-8L, -3.390817171111032905297982523519503522491E-6L,
	-1.082340897018886970282138836861233213972E-4L, -2.020120801187226444822977006648252379508E-3L,
	-2.093169910981725694937457070649605557555E-2L, -1.092176538874275712359269481414448063393E-1L,
	-2.374790947854765809203590474789108718733E-1L, -1.365364204556573800719985118029601401323E-1L
};


static const UNUSED long double Q8_16D_j1l[12] = {
	1.978397614733632533581207058069628242280E-16L, 1.487361156806202736877009608336766720560E-13L,
	4.468041406888412086042576067133365913456E-11L, 7.027822074821007443672290507210594648877E-9L,
	6.375740580686101224127290062867976007374E-7L, 3.466887658320002225888644977076410421940E-5L,
	1.138625640905289601186353909213719596986E-3L, 2.224470799470414663443449818235008486439E-2L,
	2.487052928527244907490589787691478482358E-1L, 1.483927406564349124649083853892380899217E0L,
	4.182773513276056975777258788903489507705E0L, 4.419665392573449746043880892524360870944E0L
};


static const UNUSED long double Q5_8N_j1l[11] = {
	-3.656082407740970534915918390488336879763E-13L, -1.344660308497244804752334556734121771023E-10L,
	-1.909765035234071738548629788698150760791E-8L, -1.366668038160120210269389551283666716453E-6L,
	-5.392327355984269366895210704976314135683E-5L, -1.206268245713024564674432357634540343884E-3L,
	-1.515456784370354374066417703736088291287E-2L, -1.022454301137286306933217746545237098518E-1L,
	-3.373438906472495080504907858424251082240E-1L, -4.510782522110845697262323973549178453405E-1L,
	-1.549000892545288676809660828213589804884E-1L
};


static const UNUSED long double Q5_8D_j1l[11] = {
	3.565550843359501079050699598913828460036E-12L, 1.321016015556560621591847454285330528045E-9L,
	1.897542728662346479999969679234270605975E-7L, 1.381720283068706710298734234287456219474E-5L,
	5.599248147286524662305325795203422873725E-4L, 1.305442352653121436697064782499122164843E-2L,
	1.750234079626943298160445750078631894985E-1L, 1.311420542073436520965439883806946678491E0L,
	5.162757689856842406744504211089724926650E0L, 9.527760296384704425618556332087850581308E0L,
	6.604648207463236667912921642545100248584E0L
};


static const UNUSED long double Q4_5N_j1l[11] = {
	-4.079513568708891749424783046520200903755E-11L, -9.326548104106791766891812583019664893311E-9L,
	-8.016795121318423066292906123815687003356E-7L, -3.372350544043594415609295225664186750995E-5L,
	-7.566238665947967882207277686375417983917E-4L, -9.248861580055565402130441618521591282617E-3L,
	-6.033106131055851432267702948850231270338E-2L, -1.966908754799996793730369265431584303447E-1L,
	-2.791062741179964150755788226623462207560E-1L, -1.255478605849190549914610121863534191666E-1L,
	-4.320429862021265463213168186061696944062E-3L
};


static const UNUSED long double Q4_5D_j1l[10] = {
	3.978497042580921479003851216297330701056E-10L, 9.203304163828145809278568906420772246666E-8L,
	8.059685467088175644915010485174545743798E-6L, 3.490187375993956409171098277561669167446E-4L,
	8.189109654456872150100501732073810028829E-3L, 1.072572867311023640958725265762483033769E-1L,
	7.790606862409960053675717185714576937994E-1L, 3.016049768232011196434185423512777656328E0L,
	5.722963851442769787733717162314477949360E0L, 4.510527838428473279647251350931380867663E0L
};


static const UNUSED long double Q3r2_4N_j1l[10] = {
	-1.087480809271383885936921889040388133627E-8L, -1.690067828697463740906962973479310170932E-6L,
	-9.608064416995105532790745641974762550982E-5L, -2.594198839156517191858208513873961837410E-3L,
	-3.610954144421543968160459863048062977822E-2L, -2.629866798251843212210482269563961685666E-1L,
	-9.709186825881775885917984975685752956660E-1L, -1.667521829918185121727268867619982417317E0L,
	-1.109255082925540057138766105229900943501E0L, -1.812932453006641348145049323713469043328E-1L
};


static const UNUSED long double Q3r2_4D_j1l[10] = {
	1.060552717496912381388763753841473407026E-7L, 1.676928002024920520786883649102388708024E-5L,
	9.803481712245420839301400601140812255737E-4L, 2.765559874262309494758505158089249012930E-2L,
	4.117921827792571791298862613287549140706E-1L, 3.323769515244751267093378361930279161413E0L,
	1.436602494405814164724810151689705353670E1L, 3.163087869617098638064881410646782408297E1L,
	3.198181264977021649489103980298349589419E1L, 1.203649258862068431199471076202897823272E1L
};


static const UNUSED long double Q2r7_3r2N_j1l[10] = {
	-1.723405393982209853244278760171643219530E-7L, -2.090508758514655456365709712333460087442E-5L,
	-9.140104013370974823232873472192719263019E-4L, -1.871349499990714843332742160292474780128E-2L,
	-1.948930738119938669637865956162512983416E-1L, -1.048764684978978127908439526343174139788E0L,
	-2.827714929925679500237476105843643064698E0L, -3.508761569156476114276988181329773987314E0L,
	-1.669332202790211090973255098624488308989E0L, -1.930796319299022954013840684651016077770E-1L
};


static const UNUSED long double Q2r7_3r2D_j1l[10] = {
	1.680730662300831976234547482334347983474E-6L, 2.084241442440551016475972218719621841120E-4L,
	9.445316642108367479043541702688736295579E-3L, 2.044637889456631896650179477133252184672E-1L,
	2.316091982244297350829522534435350078205E0L, 1.412031891783015085196708811890448488865E1L,
	4.583830154673223384837091077279595496149E1L, 7.549520609270909439885998474045974122261E1L,
	5.697605832808113367197494052388203310638E1L, 1.601496240876192444526383314589371686234E1L
};


static const UNUSED long double Q2r3_2r7N_j1l[10] = {
	-8.603042076329122085722385914954878953775E-7L, -7.701746260451647874214968882605186675720E-5L,
	-2.407932004380727587382493696877569654271E-3L, -3.403434217607634279028110636919987224188E-2L,
	-2.348707332185238159192422084985713102877E-1L, -7.957498841538254916147095255700637463207E-1L,
	-1.258469078442635106431098063707934348577E0L, -8.162415474676345812459353639449971369890E-1L,
	-1.581783890269379690141513949609572806898E-1L, -1.890595651683552228232308756569450822905E-3L
};


static const UNUSED long double Q2r3_2r7D_j1l[9] = {
	8.390017524798316921170710533381568175665E-6L, 7.738148683730826286477254659973968763659E-4L,
	2.541480810958665794368759558791634341779E-2L, 3.878879789711276799058486068562386244873E-1L,
	3.003783779325811292142957336802456109333E0L, 1.206480374773322029883039064575464497400E1L,
	2.458414064785315978408974662900438351782E1L, 2.367237826273668567199042088835448715228E1L,
	9.231451197519171090875569102116321676763E0L
};


static const UNUSED long double Q2_2r3N_j1l[10] = {
	-5.552507516089087822166822364590806076174E-6L, -4.135067659799500521040944087433752970297E-4L,
	-1.059928728869218962607068840646564457980E-2L, -1.212070036005832342565792241385459023801E-1L,
	-6.688350110633603958684302153362735625156E-1L, -1.793587878197360221340277951304429821582E0L,
	-2.225407682237197485644647380483725045326E0L, -1.123402135458940189438898496348239744403E0L,
	-1.679187241566347077204805190763597299805E-1L, -1.458550613639093752909985189067233504148E-3L
};


static const UNUSED long double Q2_2r3D_j1l[9] = {
	5.415024336507980465169023996403597916115E-5L, 4.179246497380453022046357404266022870788E-3L,
	1.136306384261959483095442402929502368598E-1L, 1.422640343719842213484515445393284072830E0L,
	8.968786703393158374728850922289204805764E0L, 2.914542473339246127533384118781216495934E1L,
	4.781605421020380669870197378210457054685E1L, 3.693865837171883152382820584714795072937E1L,
	1.153220502744204904763115556224395893076E1L
};


LIB_FUNC long double __ieee754_j1l(const long double num) {
	long double xx, xinv, z, p, q, c, s, cc, ss, x = num;
	if (!isfinitel(x)) {
		if (x != x) { return x; }
		else { return 0.0L; }
	}
	if (x == 0.0L) { return x; }
	xx = fabsl(x);
	if (xx <= 0x1p-58L) {
		long double ret = x * 0.5L;
		// math_check_force_underflow(ret);
		if (ret == 0) { __set_errno(ERANGE); }
		return ret;
	}
	if (xx <= 2.0L) {
		z = xx * xx;
		p = xx * z * neval(z, J0_2N_j1l, 6) / deval(z, J0_2D_j1l, 6);
		p += 0.5L * xx;
		if (x < 0) { p = -p; }
		return p;
	}
	sincosl(xx, &s, &c);
	ss = -s - c;
	cc = s - c;
	if (xx <= LDBL_MAX / 2.0L) {
		z = cosl(xx + xx);
		if ((s * c) > 0) { cc = z / ss; }
		else { ss = z / cc; }
	}
	if (xx > 0x1p256L) {
		z = 5.6418958354775628694807945156077258584405E-1L * cc / __ieee754_sqrtl(xx);
		if (x < 0) { z = -z; }
		return z;
	}
	xinv = 1.0L / xx;
	z = xinv * xinv;
	if (xinv <= 0.25L) {
		if (xinv <= 0.125L) {
			if (xinv <= 0.0625L) {
				p = neval(z, P16_IN_j1l, 9) / deval(z, P16_ID_j1l, 9);
				q = neval(z, Q16_IN_j1l, 10) / deval(z, Q16_ID_j1l, 9);
			} else {
				p = neval(z, P8_16N_j1l, 11) / deval(z, P8_16D_j1l, 10);
				q = neval(z, Q8_16N_j1l, 11) / deval(z, Q8_16D_j1l, 11);
			}
		} else if (xinv <= 0.1875L) {
			p = neval(z, P5_8N_j1l, 10) / deval(z, P5_8D_j1l, 10);
			q = neval(z, Q5_8N_j1l, 10) / deval(z, Q5_8D_j1l, 10);
		} else {
			p = neval(z, P4_5N_j1l, 10) / deval(z, P4_5D_j1l, 9);
			q = neval(z, Q4_5N_j1l, 10) / deval(z, Q4_5D_j1l, 9);
		}
	} else {
		if (xinv <= 0.375L) {
			if (xinv <= 0.3125L) {
				p = neval(z, P3r2_4N_j1l, 9) / deval(z, P3r2_4D_j1l, 9);
				q = neval(z, Q3r2_4N_j1l, 9) / deval(z, Q3r2_4D_j1l, 9);
			} else {
				p = neval(z, P2r7_3r2N_j1l, 9) / deval(z, P2r7_3r2D_j1l, 8);
				q = neval(z, Q2r7_3r2N_j1l, 9) / deval(z, Q2r7_3r2D_j1l, 9);
			}
		} else if (xinv <= 0.4375L) {
			p = neval(z, P2r3_2r7N_j1l, 9) / deval(z, P2r3_2r7D_j1l, 8);
			q = neval(z, Q2r3_2r7N_j1l, 9) / deval(z, Q2r3_2r7D_j1l, 8);
		} else {
			p = neval(z, P2_2r3N_j1l, 8) / deval(z, P2_2r3D_j1l, 8);
			q = neval(z, Q2_2r3N_j1l, 9) / deval(z, Q2_2r3D_j1l, 8);
		}
	}
	p = 1.0L + z * p;
	q = z * q;
	q = q * xinv + 0.375L * xinv;
	z = 5.6418958354775628694807945156077258584405E-1L * (p * cc - q * ss) / __ieee754_sqrtl(xx);
	if (x < 0) { z = -z; }
	return z;
}
#define __j1l_finite(x)   __ieee754_j1l((x))


static const UNUSED long double Y0_2N_y1l[8] = {
	-6.804415404830253804408698161694720833249E19L, 1.805450517967019908027153056150465849237E19L,
	-8.065747497063694098810419456383006737312E17L, 1.401336667383028259295830955439028236299E16L,
	-1.171654432898137585000399489686629680230E14L, 5.061267920943853732895341125243428129150E11L,
	-1.096677850566094204586208610960870217970E9L, 9.541172044989995856117187515882879304461E5L
};


static const UNUSED long double Y0_2D_y1l[8] = {
	3.470629591820267059538637461549677594549E20L, 4.120796439009916326855848107545425217219E18L,
	2.477653371652018249749350657387030814542E16L, 9.954678543353888958177169349272167762797E13L,
	2.957927997613630118216218290262851197754E11L, 6.748421382188864486018861197614025972118E8L,
	1.173453425218010888004562071020305709319E6L, 1.450335662961034949894009554536003377187E3L
};


LIB_FUNC long double __ieee754_y1l(const long double num) {
	long double xx, xinv, z, p, q, c, s, cc, ss, x = num;
	if (!isfinitel(x)) {
		if (x != x) { return x; }
		else { return 0.0L; }
	}
	if (x <= 0.0L) {
		if (x < 0.0L) { return (0.0L / (0.0L * x)); }
		return -HUGE_VALL + x;
	}
	xx = fabsl(x);
	if (xx <= 0x1p-114) {
		z = -6.3661977236758134307553505349005744813784E-1L / x;
		if (__isinfl(z)) { __set_errno(ERANGE); }
		return z;
	} else if (xx <= 2.0L) {
		// SET_RESTORE_ROUNDL(FE_TONEAREST);
		z = xx * xx;
		p = xx * neval(z, Y0_2N_y1l, 7) / deval(z, Y0_2D_y1l, 7);
		p = -6.3661977236758134307553505349005744813784E-1L / xx + p;
		p = 6.3661977236758134307553505349005744813784E-1L * __ieee754_logl(x) * __ieee754_j1l(x) + p;
		return p;
	}
	sincosl(xx, &s, &c);
	ss = -s - c;
	cc = s - c;
	if (xx <= LDBL_MAX / 2.0L) {
		z = cosl(xx + xx);
		if ((s * c) > 0) { cc = z / ss; }
		else { ss = z / cc; }
	}
	if (xx > 0x1p256L) { return 5.6418958354775628694807945156077258584405E-1L * ss / __ieee754_sqrtl(xx); }
	xinv = 1.0L / xx;
	z = xinv * xinv;
	if (xinv <= 0.25L) {
		if (xinv <= 0.125L) {
			if (xinv <= 0.0625L) {
				p = neval(z, P16_IN_j1l, 9) / deval(z, P16_ID_j1l, 9);
				q = neval(z, Q16_IN_j1l, 10) / deval(z, Q16_ID_j1l, 9);
			} else {
				p = neval(z, P8_16N_j1l, 11) / deval(z, P8_16D_j1l, 10);
				q = neval(z, Q8_16N_j1l, 11) / deval(z, Q8_16D_j1l, 11);
			}
		} else if (xinv <= 0.1875L) {
			p = neval(z, P5_8N_j1l, 10) / deval(z, P5_8D_j1l, 10);
			q = neval(z, Q5_8N_j1l, 10) / deval(z, Q5_8D_j1l, 10);
		} else {
			p = neval(z, P4_5N_j1l, 10) / deval(z, P4_5D_j1l, 9);
			q = neval(z, Q4_5N_j1l, 10) / deval(z, Q4_5D_j1l, 9);
		}
	} else {
		if (xinv <= 0.375L) {
			if (xinv <= 0.3125L) {
				p = neval(z, P3r2_4N_j1l, 9) / deval(z, P3r2_4D_j1l, 9);
				q = neval(z, Q3r2_4N_j1l, 9) / deval(z, Q3r2_4D_j1l, 9);
			} else {
				p = neval(z, P2r7_3r2N_j1l, 9) / deval(z, P2r7_3r2D_j1l, 8);
				q = neval(z, Q2r7_3r2N_j1l, 9) / deval(z, Q2r7_3r2D_j1l, 9);
			}
		} else if (xinv <= 0.4375L) {
			p = neval(z, P2r3_2r7N_j1l, 9) / deval(z, P2r3_2r7D_j1l, 8);
			q = neval(z, Q2r3_2r7N_j1l, 9) / deval(z, Q2r3_2r7D_j1l, 8);
		} else {
			p = neval(z, P2_2r3N_j1l, 8) / deval(z, P2_2r3D_j1l, 8);
			q = neval(z, Q2_2r3N_j1l, 9) / deval(z, Q2_2r3D_j1l, 8);
		}
	}
	p = 1.0L + z * p;
	q = z * q;
	q = q * xinv + 0.375L * xinv;
	z = 5.6418958354775628694807945156077258584405E-1L * (p * ss + q * cc) / __ieee754_sqrtl(xx);
	return z;
}
#define __y1l_finite(x)   __ieee754_y1l((x))


LIB_FUNC long double __ieee754_jnl(const int num, const long double numx) {
	uint32_t se;
	int32_t i, ix, sgn, n = (int32_t)num;
	long double a, b, temp, di, ret, z, w, x = numx;
	ieee854_long_double_shape_type u;
	u.value = x;
	se = u.parts32.w0;
	ix = se & 0x7fffffff;
	if (ix >= 0x7fff0000 && ((u.parts32.w0 & 0xffff) | u.parts32.w1 | u.parts32.w2 | u.parts32.w3)) { return x + x; }
	if (n < 0) {
		n = -n;
		x = -x;
		se ^= 0x80000000;
	}
	else if (n == 0) { return __ieee754_j0l(x); }
	else if (n == 1) { return __ieee754_j1l(x); }
	sgn = (n & 1) & (se >> 31);
	x = fabsl(x);
	// SET_RESTORE_ROUNDL(FE_TONEAREST);
	if (x == 0.0L || ix >= 0x7fff0000) { return sgn == 1 ? -0.0L : 0.0L; }
	else if ((long double)n <= x) {
		if (ix >= 0x412D0000) {
			long double s, c;
			sincosl(x, &s, &c);
			switch (n & 3) {
				case 0:
					temp = c + s;
					break;
				case 1:
					temp = -c + s;
					break;
				case 2:
					temp = -c - s;
					break;
				default:  // case 3
					temp = c - s;
					break;
			}
			b = 5.6418958354775628694807945156077258584405E-1L * temp / __ieee754_sqrtl(x);
		} else {
			a = __ieee754_j0l(x);
			b = __ieee754_j1l(x);
			for (i = 1; i < n; i++) {
				temp = b;
				b = b * ((long double)(i + i) / x) - a;
				a = temp;
			}
		}
	} else {
		if (ix < 0x3fc60000) {
			if (n >= 400) { b = 0.0L; }
			else {
				temp = x * 0.5;
				b = temp;
				for (a = 1.0L, i = 2; i <= n; i++) {
					a *= (long double)i;
					b *= temp;
				}
				b = b / a;
			}
		} else {
			long double t, v, q0, q1, h, tmp;
			int32_t k, m;
			w = (n + n) / (long double)x;
			h = 2.0L / (long double)x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0L;
			k = 1;
			while (q1 < 1.0e17L) {
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = 0.0L, i = 2 * (n + k); i >= m; i -= 2) { t = 1.0L / (i / x - t); }
			a = t;
			b = 1.0L;
			tmp = n;
			v = 2.0L / x;
			tmp = tmp * __ieee754_logl(fabsl(v * tmp));
			if (tmp < 1.1356523406294143949491931077970765006170e+04L) {
				for (i = n - 1, di = (long double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0L;
				}
			} else {
				for (i = n - 1, di = (long double)(i + i); i > 0; i--) {
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= 2.0L;
					if (b > 1e100L) {
						a /= b;
						t /= b;
						b = 1.0L;
					}
				}
			}
			z = __ieee754_j0l(x);
			w = __ieee754_j1l(x);
			if (fabsl(z) >= fabsl(w)) { b = (t * z / b); }
			else { b = (t * w / a); }
		}
	}
	if (sgn == 1) { ret = -b; }
	else { ret = b; }
	if (ret == 0) {
		ret = copysignl(LDBL_MIN, ret) * LDBL_MIN;
		__set_errno(ERANGE);
	}  // else { math_check_force_underflow(ret); }
	return ret;
}
#define __jnl_finite(n, x)   __ieee754_jnl((n), (x))


LIB_FUNC long double __ieee754_ynl(const int num, const long double numx) {
	uint32_t se;
	int32_t i, ix, sign, n = (int32_t)num;
	long double a, b, temp, ret, x = numx;
	ieee854_long_double_shape_type u;
	u.value = x;
	se = u.parts32.w0;
	ix = se & 0x7fffffff;
	if (ix >= 0x7fff0000 && ((u.parts32.w0 & 0xffff) | u.parts32.w1 | u.parts32.w2 | u.parts32.w3)) { return x + x; }
	if (x <= 0.0L) {
		if (x == 0.0L) { return ((n < 0 && (n & 1) != 0) ? 1.0L : -1.0L) / 0.0L; }
		else if (se & 0x80000000) { return 0.0L / (0.0L * x); }
	}
	sign = 1;
	if (n < 0) {
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0) { return __ieee754_y0l(x); } {
		// SET_RESTORE_ROUNDL(FE_TONEAREST);
		if (n == 1) {
			ret = sign * __ieee754_y1l(x);
			goto ieee754_ynl_out;
		}
		if (ix >= 0x7fff0000) { return 0.0L; }
		else if (ix >= 0x412D0000) {
			long double s, c;
			sincosl(x, &s, &c);
			switch (n & 3) {
				case 0:
					temp = s - c;
					break;
				case 1:
					temp = -s - c;
					break;
				case 2:
					temp = -s + c;
					break;
				default:  // case 3
					temp = s + c;
					break;
			}
			b = 5.6418958354775628694807945156077258584405E-1L * temp / __ieee754_sqrtl(x);
		} else {
			a = __ieee754_y0l(x);
			b = __ieee754_y1l(x);
			u.value = b;
			se = u.parts32.w0 & 0xffff0000;
			for (i = 1; i < n && se != 0xffff0000; i++) {
				temp = b;
				b = ((long double)(i + i) / x) * b - a;
				u.value = b;
				se = u.parts32.w0 & 0xffff0000;
				a = temp;
			}
		}
		if (!isfinitel(b)) { __set_errno(ERANGE); }
		if (sign > 0) { ret = b; }
		else { ret = -b; }
	}
ieee754_ynl_out:
	if (__isinfl(ret)) { ret = copysignl(LDBL_MAX, ret) * LDBL_MAX; }
	return ret;
}
#define __ynl_finite(n, x)   __ieee754_ynl((n), (x))


#else
#   error   "Add __ieee754_jnl() for the platform's long double!"
#endif


LIB_FUNC float jnf(const int n, const float x) {
	return __ieee754_jnf(n, x);
}
#define __jnf(n, x) jnf((n), (x))
#define ___jnf(n, x) jnf((n), (x))


LIB_FUNC float ynf(const int n, const float x) {
	return __ieee754_ynf(n, x);
}
#define __ynf(n, x) ynf((n), (x))
#define ___ynf(n, x) ynf((n), (x))


LIB_FUNC double jn(const int n, const double x) {
	return __ieee754_jn(n, x);
}
#define __jn(n, x) jn((n), (x))


LIB_FUNC double yn(const int n, const double x) {
	return __ieee754_yn(n, x);
}
#define __yn(n, x) yn((n), (x))


LIB_FUNC long double __jnl(int n, long double x) {
	return __ieee754_jnl(n, x);
}
#define __jnl(n, x) jnl((n), (x))
#define ___jnl(n, x) jnl((n), (x))


LIB_FUNC long double __ynl(int n, long double x) {
	return __ieee754_ynl(n, x);
}
#define __ynf(n, x) ynf((n), (x))
#define ___ynf(n, x) ynf((n), (x))


LIB_FUNC long double __P_bessel(const int My, double* x) {
	long double Sum = 0.0L, Fact = 1.0L;
	const long double z182 = (-0.015625L / (x[0] * x[0]));
	register int i;
	for (i = 1; ; i += 2) {
		Fact *= ((long)(My - (i + i - 1) * (i + i - 1))) * ((long)(My - (i + i + 1) * (i + i + 1))) * z182 / (i * (i + 1));
		if (EXPL(Fact) < 0x3FFF - 53) { break; }
		Sum += Fact;
	}
	return 1.0 + Sum;
}


LIB_FUNC long double __Q_bessel(const int My, double* x) {
	long double Fact = (My - 1) / x[0] * 0.125;
	long double Sum = Fact;
	const long double z182 = -0.015625 / (x[0] * x[0]);
	register int i;
	for (i = 2; ; i += 2) {
		Fact *= ((long)(My - (i + i - 1) * (i + i - 1))) * ((long)(My - (i + i + 1) * (i + i + 1))) * z182 / (i * (i + 1));
		if (EXPL(Fact) < 0x3FFF - 53) { break; }
		Sum += Fact;
	}
	return Sum;
}


LIB_FUNC long double ___jn(const int n, double* x) {
	long double Sum, Fact, y, Xi;
	register int i;
	double xx;
	int My;
	if (n < 0) { return n & 1 ? ___jn(-n, x) : -___jn(-n, x); }
	if ((x[0] >= 17.7 + 0.0144 * (n * n))) {
		Xi = (long double)(x[0] - M_PI * (n * 0.5 + 0.25));
		My = n * n << 2;
		return (long double)(((long double)sqrt(M_2_PI / x[0])) * (__P_bessel(My, x) * cosl(Xi) - __Q_bessel(My, x) * sinl(Xi)));
	}
	xx = x[0] * 0.5;
	Sum = 0.0L;
	Fact = 1.0L;
	y = -xx * xx;
	for (i = 1; i <= n; i++) { Fact *= xx / i; }
	for (i = 1; ; i++) {
		Sum += Fact;
		Fact *= y / (i * (n + i));
		if (EXPL(Sum) - EXPL(Fact) > 53 || (!EXPL(Fact))) { break; }
	}
	return Sum;
}


LIB_FUNC long double ___yn(const int n, double* x) {
	long double Sum1, Sum2, Fact1, Fact2, F1, F2, y, Xi;
	register int i;
	double xx;
	unsigned int My;
	if (EXPD(x[0]) == 0) { return -1.0L / 0.0L; }
	else if ((x[0] >= (n >= 32 ? 25.8 : (n < 8 ? (17.4 + 0.1 * n) : (16.2 + 0.3 * n))))) {
		Xi = x[0] - M_PI * (n * 0.5 + 0.25);
		My = (unsigned int)(n * (n << 2));
		return (long double)(((long double)sqrt(M_2_PI / x[0])) * (__P_bessel((int)My, x) * sinl(Xi) + __Q_bessel((int)My, x) * cosl(Xi)));
	}
	Sum1 = Sum2 = F1 = F2 = 0;
	Fact1 = 1.0 / (xx = x[0] * 0.5);
	Fact2 = 1.0;
	y = xx * xx;
	for (i = 1; i < n; i++) { Fact1 *= (n - i) / xx; }
	for (i = 1; i <= n; i++) {
		Sum1 += Fact1;
		if (i == n) { break; }
		Fact1 *= y / (i * (n - i));
	}
	for (i = 1; i <= n; i++) {
		Fact2 *= xx / i;
		F1 += 1.0 / i;
	}
	for (i = 1; ; i++) {
		Sum2 += Fact2 * (F1 + F2);
		Fact2 *= -y / (i * (n + i));
		if (EXPL(Sum2) - EXPL(Fact2) > 53 || (!EXPL(Fact2))) { break; }
		F1 += 1.0 / (n + i);
		F2 += 1.0 / i;
	}
	return (long double)(M_1_PI * (long double)(2.0 * (0.5772156649015328 + log(xx)) * ___jn(n, x) - Sum1 - Sum2));
}


LIB_FUNC double j0(double x) { return (double)___jn(0, &x); }
LIB_FUNC double j1(double x) { return (double)___jn(1, &x); }
LIB_FUNC double y0(double x) { return (double)___yn(0, &x); }
LIB_FUNC double y1(double x) { return (double)___yn(1, &x); }


static const UNUSED double logfact_coeff[16] = { (1.0 / 6 / 1 / 2), (-1.0 / 30 / 3 / 4), (1.0 / 42 / 5 / 6), (-1.0 / 30 / 7 / 8), (5.0 / 66 / 9 / 10), (-691.0 / 2730 / 11 / 12), (7.0 / 6 / 13 / 14), (-3617.0 / 510 / 15 / 16), (43867.0 / 798 / 17 / 18), (-174611.0 / 330 / 19 / 20), (854513.0 / 138 / 21 / 22), (-236364091.0 / 2730 / 23 / 24), (8553103.0 / 6 / 25 / 26) };


LIB_FUNC double logfact(const long double num) {
	long double x = num, z = (2.0L * M_PI * num);
	register int e = EXPL(x);
	static const unsigned char list[8] = { 6, 4, 3, 3, 2, 2 };
	return (double)((logl(x) - 1) * x + 0.5L * logl(z) + __poly((1.0 / (double)(x * x)), (e < 0x4003 ? 10 : (e > 0x4008 ? 1 : list[e - 0x4003])), logfact_coeff) / x);
}


/** Return the logarithm of the absolute value of the gamma function */
LIB_FUNC double lgamma(double x) {
	const double tmpk = floor(x);
	register int k = (int)tmpk;
	long double w, y, z;
	if (k >= 7) { return logfact(x - 1); }
	else if (k == x) {
		switch (k) {
			case 1 :
			case 2 :
				return 0.0;
			case 3 :
				return 0.693147180559945309432805516;
			case 4 :
				return 1.791759469228055000858148560;
			case 5 :
				return 3.178053830347945619723759592;
			case 6 :
				return 4.787491742782045994244981560;
			default:
				return 1.0 / 0.0;
		}
	}
	z = logfact(y = x - k + 7.0 - 1);
	w = 1;
	for (k = 7 - k; k--;) { w *= y, y -= 1.0; }
	return (double)(z - logl(w));
}
#define gamma(val)   lgamma((val))
#define __gamma(val)   lgamma((val))
#define __lgamma(val)   lgamma((val))


/** Coefficients for gamma(0) */
static const UNUSED double gauss_tab1[16] = {
	0.398942280401432677926, -0.066490380066905446321, 9.97355701003581694794E-3,
	-1.18732821548045439878E-3, 1.15434687616155288764E-4, -9.44465625950361453450E-6,
	6.65969351631665127484E-7, -4.12266741486268888409E-8, 2.27352982437280636972E-9,
	-1.13011716416192129505E-10
};


/** Coefficients for gamma(x), x>0 */
static const UNUSED double gauss_tab2[10][32] = {
	{ -0.158655253931457051468, 0.241970724519143349823, -0.120985362259571674911, 0, 0.0201642270432619458197, -4.03284540865238916394E-3, -2.01642270432619458197E-3, 7.68161030219502697887E-4, 1.20025160971797296538E-4, -8.80184513793180174807E-5, -1.86705805956129127862E-6, 7.37124220917704609315E-6, -4.72826391707080259142E-7, -4.83395817951682973566E-7, 6.57036391970156141055E-8, 2.5544260402922190768E-8, -5.4292285616752144141E-9, -1.08932444506260820153E-9, 3.44399256708718202774E-10, 3.6021429664641554881E-11, -1.81147204852239925966E-11, -7.66935128389784976374E-13, 8.19047721646461768154E-13, -3.78144699611990981391E-15, -3.24856460059989147863E-14, 1.44438130842455313227E-15, 1.14391687912824634892E-15, -9.38053726039148625184E-17, -3.59908648108845288945E-17, 4.36020846676166022246E-18, 1.01298640134330880603E-18, -1.68640470512244526894E-19 },
	{ -0.0227501319481792072104, 0.0539909665131880519553, -0.0539909665131880519553, 0.0269954832565940259776, -4.49924720943233766301E-3, -2.24962360471616883129E-3, 1.34977416282970129877E-3, -1.17837426913704081544E-4, -1.15159303574756261652E-4, 3.70473728554448438507E-5, 2.82690796888936559912E-6, -3.54513195524355369855E-6, 3.76695631261094890352E-7, 1.92024079214184701051E-7, -5.22690859049557191018E-8, -4.91799344974114749666E-9, 3.66377919234006038965E-9, -1.5981997209104676352E-10, -1.73812379171063320997E-10, 2.62403075313043113473E-11, 5.60918720760414713346E-12, -1.72126983666416144614E-12, -8.63428809787622525331E-14, 7.89441765474563834480E-14, -3.13747960081562321348E-15, -2.77519506625391157547E-15, 3.29321944203493138076E-16, 7.44375150395529134369E-17, -1.66428523299294690222E-17, -1.32735612757620496568E-18, 6.24122437514304644794E-19, 1.12471123532438919306E-21 },
	{ -1.3498980316300945272E-3, 4.43184841193800717687E-3, -6.64777261790701076574E-3, 5.90913121591734290293E-3, -3.32388630895350538287E-3, 1.10796210298450179421E-3, -1.10796210298450179595E-4, -8.44161602273906129349E-5, 4.35270826172482847927E-5, -6.30190085030867423515E-6, -1.9785037553294674925E-6, 1.05520200284238266374E-6, -1.13913852579575399458E-7, -4.81174572974454799623E-8, 1.78216871733806513653E-8, -5.85637697215219690327E-10, -9.29791350219350980904E-10, 1.96377023046901260016E-10, 1.58870373467897094393E-11, -1.22699105512396660364E-11, 1.08794270836433192571E-12, 3.99646995170699427940E-13, -1.01594404465456044793E-13, -3.33469605506835759271E-15, 4.46588935876766499879E-15, -4.08076707607833277747E-16, -1.17808602368979218862E-16, 2.76224909899945482352E-17, 1.09206599392049874162E-18, -1.03145418746203977253E-18, 6.79984672177279963209E-20, 2.55831283729070534712E-20 },
	{ -3.16712418331199212695E-5, 1.33830225764885351832E-4, -2.67660451529770703664E-4, 3.34575564412213379613E-4, -2.89965489157251595673E-4, 1.8178605666396926958E-4, -8.25286392216793003064E-5, 2.55180251904870680833E-5, -3.91665839292075186649E-6, -7.40182052221464123606E-7, 6.44220233592652481453E-7, -1.73701553397390201613E-7, 9.09595464817154590424E-9, 9.44943118114780783705E-9, -3.29957075383376125942E-9, 2.94920746951281580686E-10, 1.18744773902482360274E-10, -4.42039585809856402486E-11, 3.61422484008923382324E-12, 1.43638335494248833511E-12, -4.58476794992724591068E-13, 2.23496663226445199624E-14, 1.57839046076890756440E-14, -3.67258220998453293248E-15, -1.69716269032291432153E-17, 1.43497778353923791279E-16, -2.14499365995613073838E-17, -1.93255135682867953692E-18, 1.01377499752128183701E-18, -7.55713215369572830154E-20, -2.25510650946079103289E-20, 5.26633993110171917109E-21 },
	{ -2.86651571879193912033E-7, 1.48671951473429770924E-6, -3.7167987868357442731E-6, 5.9468780589371908374E-6, -6.81413110919886450076E-6, 5.92209940035828587496E-6, -4.02653201907205629582E-6, 2.17108246596119665457E-6, -9.25512396325170449452E-7, 3.03096091545533908077E-7, -6.92802772105295808398E-8, 6.69226396924248971087E-9, 2.46006252876483997508E-9, -1.41806830376639605249E-9, 3.44251040657349801884E-10, -2.6965166176434937652E-11, -1.16546962748761528049E-11, 4.91490145086991326748E-12, -7.55854519365765424197E-13, -4.53988828124843593484E-14, 4.71533558309731405623E-14, -9.17323049919073092370E-15, 4.35542982587998484108E-17, 3.71238868922011013332E-16, -7.90772907386322623053E-17, 1.58463483904927528072E-18, 2.61503941976309571331E-18, -5.40699423853895351239E-19, 6.61825040533797444037E-21, 1.68378440730394776550E-20, -3.01930850797704474581E-21, -3.80658085177617928332E-23 },
	{ -9.8658764503769814198E-10, 6.07588284982328549581E-9, -1.82276485494698564874E-8, 3.54426499573024987263E-8, -5.01260335110421053478E-8, 5.48348427196551516061E-8, -4.81513715848495375522E-8, 3.47446467489597046263E-8, -2.08994095347716137282E-8, 1.0554987922587771203E-8, -4.4752674615729637229E-9, 1.57746505810079893253E-9, -4.49697115294871911476E-10, 9.63210042443717269402E-11, -1.16300711402336909847E-11, -1.31070037808191623761E-12, 1.16993345829435057496E-12, -3.40636420312606285351E-13, 5.23724821541706939045E-14, 3.93541148139975862961E-16, -2.59886413069218394637E-15, 7.24729556829529838503E-16, -8.51485747763574768020E-17, -7.86503719948806184368E-18, 5.35986191777031053618E-18, -9.84873767617830925356E-19, 2.93759678710573738811E-20, 2.85458592629073152182E-20, -7.12725445137377009753E-21, 5.25419393758902871947E-22, 1.24299023131490990316E-22, -4.04419210566489645405E-23 },
	{ -1.27981254388583500631E-12, 9.1347204083645933588E-12, -3.19715214292760767584E-11, 7.30777632669167468738E-11, -1.22557498812224960902E-10, 1.60618833847077433236E-10, -1.71047639646627010648E-10, 1.51926349902927316213E-10, -1.14609023345779936276E-10, 7.43697341394886835864E-11, -4.18713451557949730558E-11, 2.05606050331840905587E-11, -8.82161466664564577599E-12, 3.30031395277698236679E-12, -1.06851205331295409813E-12, 2.94333808755089195146E-13, -6.64411715537625335642E-14, 1.11264855981436243262E-14, -8.52918435682649455145E-16, -2.38837813662069487819E-16, 1.23994634366691956599E-16, -3.05269770279941723219E-17, 4.34539596489459676621E-18, -5.55819387468189608390E-20, -1.56974672263484202926E-19, 4.60835492190702561464E-20, -6.61112150617493330405E-21, 7.28424268476803924831E-23, 2.09156005934313228089E-22, -5.29080328670107625978E-23, 5.61375000671507211726E-24, 3.82199410465700894394E-25 },
	{ -6.22096057427178413283E-16, 5.05227108353689229741E-15, -2.02090843341475691883E-14, 5.30488463771373691202E-14, -1.02729512031916810045E-13, 1.56409892294496290711E-13, -1.94849254788406146283E-13, 2.04064637342166989709E-13, -1.83187931471980616892E-13, 1.42994099344605424348E-13, -9.8111907789286062426E-14, 5.96545975367403288587E-14, -3.23370114040930933005E-14, 1.56932853967230342257E-14, -6.83548101324218922896E-15, 2.67410077774155118457E-15, -9.38313996431647887562E-16, 2.94090734842381109313E-16, -8.16448235152204729921E-17, 1.9758222496699617607E-17, -4.03590262164308783690E-18, 6.43662361965717426956E-19, -5.93446415094778572090E-20, -6.07164564350191039536E-21, 4.38906686886388095825E-21, -1.17175498170220204828E-21, 1.98482140750318604418E-22, -1.70803571702439545981E-23, -1.94600332107885234554E-24, 1.10477141319981582738E-24, -2.31975718243847439962E-25, 2.54148402104633283670E-26 },
	{ -1.12858840595384064928E-19, 1.02797735716689148111E-18, -4.62589810725101166456E-18, 1.37063647622252197466E-17, -3.0068337697131575822E-17, 5.2067053140503053517E-17, -7.40914680178037035E-17, 8.9062000172830588611E-17, -9.22563786210983011008E-17, 8.35975730487397716492E-17, -6.70372487553237232779E-17, 4.80088566412770650047E-17, -3.09280630297969106245E-17, 1.8026496052333452774E-17, -9.54924880090907168481E-18, 4.61362333444861021959E-18, -2.03812361224098073479E-18, 8.24578860830779678155E-19, -3.0572087552697254564E-19, 1.03827313453936543577E-19, -3.22407758977306397999E-20, 9.12052549039695437376E-21, -2.33541947993595580264E-21, 5.35339963891271164659E-22, -1.07674173853083520575E-22, 1.82413373046113374293E-23, -2.33864726317468746329E-24, 1.29928813344150027051E-25, 3.86668349205203745336E-26, -1.63203452712600670685E-26, 3.65165372186699607411E-27, -5.51243539825332137371E-28 },
	{ -7.61985302416052609616E-24, 7.69459862670641937159E-23, -3.84729931335320968601E-22, 1.26960877340655919637E-21, -3.10990027829384449637E-21, 6.02935924057670511377E-21, -9.6342786971886625897E-21, 1.30454744197246721374E-20, -1.52745988785284834672E-20, 1.57034665186695273938E-20, -1.43457243961336621961E-20, 1.17567385540485497556E-20, -8.7104848256363928121E-21, 5.87137214731944288587E-21, -3.61951956727412561213E-21, 2.04954715001535632502E-21, -1.06982832733527370879E-21, 5.1628428354196120786E-22, -2.30885865897937993512E-22, 9.58556229281154921137E-23, -3.69911125531027884646E-23, 1.32784897023484841369E-23, -4.43433027366044567275E-24, 1.37688611947822111040E-24, -3.96971995397574368025E-25, 1.06008163579031271153E-25, -2.61149430849477426613E-26, 5.89698164189548613154E-27, -1.20793190886658723050E-27, 2.20446342551066852143E-28, -3.46061447029252398335E-29, 4.28913922246949096952E-30 }
};


LIB_FUNC long double gauss(const double x) {
	unsigned int i = (unsigned int)(x + 0.5);
	double y = x * x;
	static const UNUSED double gauss_tab3[8] = { 1, -1, 3, -15, 105, -945, 10395, -135135.0 };
	if (i > 150) { return 0.0; }
	else if (i > 10) { return 0.398942280401432686 * exp(-0.5 * y) / x * __poly(1.0 / y, 7, gauss_tab3); }
	else if (i > 0) { return -__poly((x - i), 31, gauss_tab2[i - 1]); }
	return 0.5 - x * __poly(y, 9, gauss_tab1);
}


LIB_FUNC float erfc1(const float x) {
	const float s = fabsf(x) - 1;
	const float P = -2.3621185683e-03F + s * (4.1485610604e-01F + s * (-3.7220788002e-01F + s * (3.1834661961e-01F + s * (-1.1089469492e-01F + s * (3.5478305072e-02F + s * -2.1663755178e-03F)))));
	const float Q = 1 + s * (1.0642088205e-01F + s * (5.4039794207e-01F + s * (7.1828655899e-02F + s * (1.2617121637e-01F + s * (1.3637083583e-02F + s * 1.1984500103e-02F)))));
	return 1 - 8.4506291151e-01F - P / Q;
}


LIB_FUNC float erfc2(const uint32_t inum, const float num) {
	uint32_t ix = inum;
	if (ix < 0x3fa00000) { return erfc1(num); }
	float x = fabsf(num);
	const float s = 1 / (x * x);
	float R, S;
	if (ix < 0x4036db6d) {
		R = -9.8649440333e-03F + s * (-6.9385856390e-01F + s * (-1.0558626175e+01F + s * (-6.2375331879e+01F + s * (-1.6239666748e+02F + s * (-1.8460508728e+02F + s * (-8.1287437439e+01F + s * -9.8143291473e+00F))))));
		S = 1.0f + s * (1.9651271820e+01F + s * (1.3765776062e+02F + s * (4.3456588745e+02F + s * (6.4538726807e+02F + s * (4.2900814819e+02F + s * (1.0863500214e+02F + s * (6.5702495575e+00F + s * -6.0424413532e-02F)))))));
	} else {
		R = -9.8649431020e-03F + s * (-7.9928326607e-01F + s * (-1.7757955551e+01F + s * (-1.6063638306e+02F + s * (-6.3756646729e+02F + s * (-1.0250950928e+03F + s * -4.8351919556e+02F)))));
		S = 1.0F + s * (3.0338060379e+01F + s * (3.2579251099e+02F + s * (1.5367296143e+03F + s * (3.1998581543e+03F + s * (2.5530502930e+03F + s * (4.7452853394e+02F + s * -2.2440952301e+01F))))));
	}
	float z;
	GET_FLOAT_UWORD(ix, x);
	SET_FLOAT_WORD(z, (int)(ix & 0xffffe000));
	return expf((-z * z - 0.5625f)) * expf((z - x) * (z + x) + R / S) / x;
}


LIB_FUNC float erff(const float x) {
	uint32_t ix;
	GET_FLOAT_UWORD(ix, x);
	const int sign = (int)(ix >> 31);
	ix &= 0x7fffffff;
	float y;
	if (ix >= 0x7f800000) { return (float)(1 - (2 * sign) + (int)(1 / x)); }
	else if (ix < 0x3f580000) {
		if (ix < 0x31800000) { return 0.125F * (8 * x + 1.0270333290e+00F * x); }
		const float z = x * x;
		const float r = 1.2837916613e-01F + z * (-3.2504209876e-01F + z * (-2.8481749818e-02F + z * (-5.7702702470e-03F + z * -2.3763017452e-05F)));
		const float s = 1 + z * (3.9791721106e-01F + z * (6.5022252500e-02F + z * (5.0813062117e-03F + z * (1.3249473704e-04F + z * -3.9602282413e-06F))));
		y = r / s;
		return x + x * y;
	}
	if (ix < 0x40c00000) { y = 1 - erfc2(ix, x); }
	else { y = 1 - 0x1p-120F; }
	return sign ? -y : y;
}


/** erf(x) is the probability a normal distributed event occures within the range [0,x]. erfc(x) is the probability a normal distributed event occures within the range [x,inf] */
LIB_FUNC double erf(const double x) {
	return (double)(x < 0.0 ? -0.5 + (double)gauss(-x) : 0.5 - (double)gauss(x));
}


LIB_FUNC float erfcf(const float x) {
	uint32_t ix;
	GET_FLOAT_UWORD(ix, x);
	int sign = (int)(ix >> 31);
	ix &= 0x7fffffff;
	float y;
	if (ix >= 0x7f800000) { return (float)(2 * sign + (int)(1 / x)); }
	else if (ix < 0x3f580000) {
		if (ix < 0x23800000) { return 1.0F - x; }
		const float z = x * x;
		const float r = 1.2837916613e-01F + z * (-3.2504209876e-01F + z * (-2.8481749818e-02F + z * (-5.7702702470e-03F + z * -2.3763017452e-05F)));
		const float s = 1.0F + z * (3.9791721106e-01F + z * (6.5022252500e-02F + z * (5.0813062117e-03F + z * (1.3249473704e-04F + z * -3.9602282413e-06F))));
		y = r / s;
		if (sign || ix < 0x3e800000) { return 1.0F - (x + x * y); }
		return 0.5F - (x - 0.5F + x * y);
	}
	if (ix < 0x41e00000) { return sign ? 2 - erfc2(ix, x) : erfc2(ix, x); }
	return (float)(sign ? 2.0F - 0x1p-120F : 0x1p-120F * 0x1p-120F);
}


LIB_FUNC double erfc(const double x) {
	return (double)(x < 0.0 ? 1.0 - (double)gauss(-x) : (double)gauss(x));
}


#if (LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024)


LIB_FUNC long double erfl(long double x) {
	return erf(x);
}


LIB_FUNC long double erfcl(long double x) {
	return erfc(x);
}


#elif (LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384)


LIB_FUNC long double erfcl1(const long double x) {
	const long double s = fabsl(x) - 1;
	const long double P = -1.076952146179812072156734957705102256059E0L + s * (1.884814957770385593365179835059971587220E2L + s * (-5.339153975012804282890066622962070115606E1L + s * (4.435910679869176625928504532109635632618E1L + s * (1.683219516032328828278557309642929135179E1L + s * (-2.360236618396952560064259585299045804293E0L + s * (1.852230047861891953244413872297940938041E0L + s * 9.394994446747752308256773044667843200719E-2L))))));
	const long double Q = 4.559263722294508998149925774781887811255E2L + s * (3.289248982200800575749795055149780689738E2L + s * (2.846070965875643009598627918383314457912E2L + s * (1.398715859064535039433275722017479994465E2L + s * (6.060190733759793706299079050985358190726E1L + s * (2.078695677795422351040502569964299664233E1L + s * (4.641271134150895940966798357442234498546E0L + s))))));
	return 1 - 0.845062911510467529296875L - P / Q;
}


LIB_FUNC long double erfcl2(uint32_t ix, long double x) {
	union ldshape u;
	long double z, R, S;
	if (ix < 0x3fffa000) { return erfcl1(x); }
	x = fabsl(x);
	long double s = 1 / (x * x);
	if (ix < 0x4000b6db) {
		R = 1.363566591833846324191000679620738857234E-1L + s * (1.018203167219873573808450274314658434507E1L + s * (1.862359362334248675526472871224778045594E2L + s * (1.411622588180721285284945138667933330348E3L + s * (5.088538459741511988784440103218342840478E3L + s * (8.928251553922176506858267311750789273656E3L + s * (7.264436000148052545243018622742770549982E3L + s * (2.387492459664548651671894725748959751119E3L + s * 2.220916652813908085449221282808458466556E2L)))))));
		S = -1.382234625202480685182526402169222331847E1L + s * (-3.315638835627950255832519203687435946482E2L + s * (-2.949124863912936259747237164260785326692E3L + s * (-1.246622099070875940506391433635999693661E4L + s * (-2.673079795851665428695842853070996219632E4L + s * (-2.880269786660559337358397106518918220991E4L + s * (-1.450600228493968044773354186390390823713E4L + s * (-2.874539731125893533960680525192064277816E3L + s * (-1.402241261419067750237395034116942296027E2L + s))))))));
	} else if (ix < 0x4001d555) {
		R = -4.869587348270494309550558460786501252369E-5L + s * (-4.030199390527997378549161722412466959403E-3L + s * (-9.434425866377037610206443566288917589122E-2L + s * (-9.319032754357658601200655161585539404155E-1L + s * (-4.273788174307459947350256581445442062291E0L + s * (-8.842289940696150508373541814064198259278E0L + s * (-7.069215249419887403187988144752613025255E0L + s * -1.401228723639514787920274427443330704764E0L))))));
		S = 4.936254964107175160157544545879293019085E-3L + s * (1.583457624037795744377163924895349412015E-1L + s * (1.850647991850328356622940552450636420484E0L + s * (9.927611557279019463768050710008450625415E0L + s * (2.531667257649436709617165336779212114570E1L + s * (2.869752886406743386458304052862814690045E1L + s * (1.182059497870819562441683560749192539345E1L + s))))));
	} else {
		R = -8.299617545269701963973537248996670806850E-5L + s * (-6.243845685115818513578933902532056244108E-3L + s * (-1.141667210620380223113693474478394397230E-1L + s * (-7.521343797212024245375240432734425789409E-1L + s * (-1.765321928311155824664963633786967602934E0L + s * -1.029403473103215800456761180695263439188E0L))));
		S = 8.413244363014929493035952542677768808601E-3L + s * (2.065114333816877479753334599639158060979E-1L + s * (1.639064941530797583766364412782135680148E0L + s * (4.936788463787115555582319302981666347450E0L + s * (5.005177727208955487404729933261347679090E0L + s))));
	}
	u.f = x;
	u.i.m &= -1ULL << 40;
	z = u.f;
	return expl(-z * z - 0.5625) * expl((z - x) * (z + x) + R / S) / x;
}


LIB_FUNC long double erfl(const long double x) {
	long double r, s, z, y;
	union ldshape u = { x };
	uint32_t ix = (uint32_t)(((u.i.se & 0x7fffU) << 16) | (u.i.m >> 48));
	int sign = (int)(u.i.se >> 15);
	if (ix >= 0x7fff0000) { return 1 - 2 * sign + 1 / x; }
	else if (ix < 0x3ffed800) {
		if (ix < 0x3fde8000) { return 0.125L * (8 * x + 1.0270333367641005911692712249723613735048E0L * x);   }
		z = x * x;
		r = 1.122751350964552113068262337278335028553E6L + z * (-2.808533301997696164408397079650699163276E6L + z * (-3.314325479115357458197119660818768924100E5L + z * (-6.848684465326256109712135497895525446398E4L + z * (-2.657817695110739185591505062971929859314E3L + z * -1.655310302737837556654146291646499062882E2L))));
		s = 8.745588372054466262548908189000448124232E6L + z * (3.746038264792471129367533128637019611485E6L + z * (7.066358783162407559861156173539693900031E5L + z * (7.448928604824620999413120955705448117056E4L + z * (4.511583986730994111992253980546131408924E3L + z * (1.368902937933296323345610240009071254014E2L + z)))));
		y = r / s;
		return x + x * y;
	}
	if (ix < 0x4001d555) { y = 1 - erfcl2(ix, x); }
	else { y = 1 - 0x1p-16382L; }
	return sign ? -y : y;
}


LIB_FUNC long double erfcl(const long double x) {
	long double r, s, z, y;
	union ldshape u = { x };
	uint32_t ix = (uint32_t)(((u.i.se & 0x7fffU) << 16) | (u.i.m >> 48));
	int sign = u.i.se >> 15;
	if (ix >= 0x7fff0000) { return 2 * sign + 1 / x; }
	else if (ix < 0x3ffed800) {
		if (ix < 0x3fbe0000) { return 1.0 - x; }
		z = x * x;
		r = 1.122751350964552113068262337278335028553E6L + z * (-2.808533301997696164408397079650699163276E6L + z * (-3.314325479115357458197119660818768924100E5L + z * (-6.848684465326256109712135497895525446398E4L + z * (-2.657817695110739185591505062971929859314E3L + z * -1.655310302737837556654146291646499062882E2L))));
		s = 8.745588372054466262548908189000448124232E6L + z * (3.746038264792471129367533128637019611485E6L + z * (7.066358783162407559861156173539693900031E5L + z * (7.448928604824620999413120955705448117056E4L + z * (4.511583986730994111992253980546131408924E3L + z * (1.368902937933296323345610240009071254014E2L + z)))));
		y = r / s;
		if (ix < 0x3ffd8000) { return 1.0 - (x + x * y); }
		return 0.5 - (x - 0.5 + x * y);
	}
	if (ix < 0x4005d600) { return sign ? 2 - erfcl2(ix, x) : erfcl2(ix, x); }
	y = 0x1p-16382L;
	return sign ? 2 - y : y * y;
}


#endif


// FACTORIALS

/** Factorial (n!); return 0 on error */
LIB_FUNC ullint factorial(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)22) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)11) { return 0; }
#endif
	else if (num == (unsigned int)0x0 || num == (unsigned int)1) { return (ullint)1; }
	register ullint i, fct = (ullint)num;
	for (i = fct - (ullint)1; --i;) { fct *= i; }
	return fct;
}


/** Factorial (n!); return 0 on error */
LIB_FUNC sllint factoriallonglong(const sllint num) {
#if (defined(ENV64BIT))
	if (num > (sllint)20) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (sllint)10) { return 0; }
#endif
	else if (num == (sllint)0 || num == (sllint)1) { return (sllint)1; }
	register sllint i, fct = (sllint)num;
	for (i = fct - (sllint)1; --i;) fct *= i;
	return fct;
}


/** Double Factorial (n!!); return 0 on error */
LIB_FUNC ullint doublefactorial(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)30) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)10) { return 0; }
#endif
	else if (num == (unsigned int)0x0 || num == (unsigned int)1) { return (ullint)1; }
	else if (num == (unsigned int)0x2) { return (ullint)2; }
	else if (num == (unsigned int)0x3) { return (ullint)3; }
	else if (num == (unsigned int)0x4) { return (ullint)8; }
	register ullint i, fct = (ullint)num;
	if ((num % (unsigned int)2) == (unsigned int)0x0) {  // Even
		for (i = (fct - (ullint)2); i > 0x1; i = (ullint)(i - (ullint)2)) {
			if (i <= 0x1) { break; }
			else if (i == 0x2) { fct *= i; break; }
			fct *= i;
		}
	} else {  // Odd
		for (i = (fct - (ullint)2); i > 0x2; i = (ullint)(i - (ullint)2)) {
			if (i <= 0x2) { break; }
			else if (i == 0x3) { fct *= i; break; }
			fct *= i;
		}
	}
	return fct;
}


/** Double Factorial (n!!); return 0 on error */
LIB_FUNC sllint doublefactoriallonglong(const sllint num) {
#if (defined(ENV64BIT))
	if (num > (sllint)30) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (sllint)9) { return 0; }
#endif
	else if (num < (sllint)0x0) { return (sllint)0x0; }
	else if (num == (sllint)0x0 || num == (sllint)0x1) { return (sllint)0x1; }
	else if (num == (sllint)0x2) { return (sllint)2; }
	else if (num == (sllint)0x3) { return (sllint)3; }
	else if (num == (sllint)0x4) { return (sllint)8; }
	register sllint i, fct = (sllint)num;
	if ((num % (sllint)2) == (sllint)0x0) {  // Even
		for (i = (sllint)(fct - (sllint)2); i > 0x1; i = (sllint)(i - (sllint)2)) {
			if (i <= 0x1) { break; }
			else if (i == 0x2) { fct *= i; break; }
			fct *= i;
		}
	} else {  // Odd
		for (i = (fct - (sllint)2); i > 0x2; i = (sllint)(i - (sllint)2)) {
			if (i <= 0x2) { break; }
			else if (i == 0x3) { fct *= i; break; }
			fct *= i;
		}
	}
	return fct;
}


/** Quadruple Factorial - (2n)!/n!; return 0 on error */
LIB_FUNC ullint quadfactorial(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)10) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)5) { return 0; }
#endif
	else if (num == (unsigned int)0) { return (ullint)1; }
	else if (num == (unsigned int)1) { return (ullint)2; }
	register ullint i, fct1 = (ullint)num, fct2 = (ullint)(num + num);
	for (i = fct1 - (ullint)1; i > (ullint)0; --i) { fct1 *= i; }
	for (i = fct2 - (ullint)1; i > (ullint)0; --i) { fct2 *= i; }
	return (fct2 / fct1);
}


/** Quadruple Factorial - (2n)!/n!; return 0 on error */
LIB_FUNC sllint quadfactoriallonglong(const sllint num) {
	switch (num) {
		case (sllint)0: return (sllint)1;
		case (sllint)1: return (sllint)2;
		case (sllint)2: return (sllint)12;
		case (sllint)3: return (sllint)120;
		case (sllint)4: return (sllint)1680;
		case (sllint)5: return (sllint)30240;
		case (sllint)6: return (sllint)665280;
		case (sllint)7: return (sllint)17297280;
		case (sllint)8: return (sllint)518918400;
		case (sllint)9: return (sllint)17643225600;
		default: return 0;
	}
	return 0;
}


/** Super-Factorial; return 0 on error */
LIB_FUNC ullint superfactorial(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)9) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)4) { return 0; }
#endif
	else if (num == (unsigned int)0 || num == (unsigned int)1) { return (ullint)1; }
	register ullint i, j, fct = 1;
	for (i = (ullint)num; --i;) { for (j = i; --j;) fct *= j; }
	return fct;
}


/** Super-Factorial; return 0 on error */
LIB_FUNC sllint superfactoriallonglong(const sllint num) {
	switch (num) {
		case 0: return 1;
		case 1: return 1;
		case 2: return 2;
		case 3: return 12;
		case 4: return 288;
		case 5: return 34560;
		case 6: return 24883200;
#       if (defined(ENV64BIT))
		case 7: return 125411328000;
		case 8: return 5056584744960000;
#       elif (defined(ENV128BIT))
		case 9: return 1834933472251084800000;
		case 10: return 6658606584104736522240000000;
		case 11: return 265790267296391946810949632000000000;
		//case 12: return 127313963299399416749559771247411200000000000;
#       endif
		default: return 0;
	}
	return 0;
}


/** Find the number used to produce the factorial */
LIB_FUNC int unfactorial(const int num) {
	register int x, y = num;
	for (x = 1; y != x; ++x) { y /= x; }
	return x;
}


/** Find the number used to produce the factorial */
LIB_FUNC uint64_t unfactorial64(const uint64_t num) {
	register uint64_t x, y = num;
	for (x = 1; y != x; ++x) { y /= x; }
	return x;
}


// NUMBER GENERATORS

/** Return the Nth Pronic number */
LIB_FUNC unsigned int pronic(const unsigned int num) {
	return ((num * num) + num);
}


/** Return the Nth Pronic number */
LIB_FUNC ullint pronicull(const ullint num) {
	return (((ullint)num * (ullint)num) + (ullint)num);
}


/** Return the Nth Pronic number */
LIB_FUNC sllint proniclonglong(const sllint num) {
	return (((sllint)num * (sllint)num) + (sllint)num);
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Pronic number (128-bit unsigned integer) */
LIB_FUNC uint128_t pronic_u128(const uint128_t num) {
	return (((uint128_t)num * (uint128_t)num) + (uint128_t)num);
}
#endif


/** Fibonacci Number Generator; return 0 on error */
LIB_FUNC unsigned int fib(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)48) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)24) { return 0; }
#endif
	else if (num == (unsigned int)0) { return 0; }
	else if (num == (unsigned int)1 || num == (unsigned int)2) { return 1; }
	else {
#       if (defined(ENV64BIT))
		unsigned int fibval[49] = { 0 };
#       elif (defined(ENV32BIT))
		unsigned int fibval[25] = { 0 };
#       endif
		fibval[0] = (unsigned int)0;
		fibval[1] = (unsigned int)1;
		fibval[2] = (unsigned int)1;
		fibval[3] = (unsigned int)2;
		fibval[4] = (unsigned int)3;
		register unsigned int i;
		for (i = (unsigned int)4; i <= num; ++i) {
			fibval[i] = fibval[i - (unsigned int)1] + fibval[i - (unsigned int)2];
		}
		return fibval[num];
	}
}


/** Fibonacci Number Generator; return 0 on error */
LIB_FUNC unsigned long int longfib(const unsigned long int num) {
#if (defined(ENV64BIT))
	if (num > (ulint)91) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (ulint)37) { return 0; }
#endif
	else if (num <= (ulint)12) {
		switch (num) {
			case (ulint)0: return (ulint)0;
			case (ulint)1: return (ulint)1;
			case (ulint)2: return (ulint)1;
			case (ulint)3: return (ulint)2;
			case (ulint)4: return (ulint)3;
			case (ulint)5: return (ulint)5;
			case (ulint)6: return (ulint)8;
			case (ulint)7: return (ulint)13;
			case (ulint)8: return (ulint)21;
			case (ulint)9: return (ulint)34;
			case (ulint)10: return (ulint)55;
			case (ulint)11: return (ulint)89;
			default: return (ulint)144;  // case (ulint)12
		}
	}
#   if (defined(ENV64BIT))
	ulint fibval[92] = { 0 };
#   elif (defined(ENV32BIT))
	ulint fibval[98] = { 0 };
#   endif
	fibval[0] = (ulint)0;
	fibval[1] = (ulint)1;
	fibval[2] = (ulint)1;
	fibval[3] = (ulint)2;
	fibval[4] = (ulint)3;
	fibval[5] = (ulint)5;
	fibval[6] = (ulint)8;
	fibval[7] = (ulint)13;
	fibval[8] = (ulint)21;
	fibval[9] = (ulint)34;
	fibval[10] = (ulint)55;
	fibval[11] = (ulint)89;
	fibval[12] = (ulint)144;
	register ulint i;
	for (i = (ulint)13; i <= num; ++i) fibval[i] = fibval[i - (ulint)1] + fibval[i - (ulint)2];
	return fibval[num];
}


/** Fibonacci Number Generator; return 0 on error */
LIB_FUNC sllint longlongfib(const sllint num) {
#if (defined(ENV64BIT))
	if ((num < (sllint)0) || (num > (sllint)91)) { return 0; }
#elif (defined(ENV32BIT))
	if ((num < (sllint)0) || (num > (sllint)35)) { return 0; }
#endif
	else if ((num >= 0) && (num <= (sllint)14)) {
		switch (num) {
			case (sllint)0: return (sllint)0;
			case (sllint)1: return (sllint)1;
			case (sllint)2: return (sllint)1;
			case (sllint)3: return (sllint)2;
			case (sllint)4: return (sllint)3;
			case (sllint)5: return (sllint)5;
			case (sllint)6: return (sllint)8;
			case (sllint)7: return (sllint)13;
			case (sllint)8: return (sllint)21;
			case (sllint)9: return (sllint)34;
			case (sllint)10: return (sllint)55;
			case (sllint)11: return (sllint)89;
			case (sllint)12: return (sllint)144;
			case (sllint)13: return (sllint)233;
			default: return (sllint)377;  // case (sllint)14
		}
	}
#   if (defined(ENV64BIT))
	sllint fibval[92] = { 0 };
#   elif (defined(ENV32BIT))
	sllint fibval[36] = { 0 };
#   endif
	fibval[0] = (sllint)0;
	fibval[1] = (sllint)1;
	fibval[2] = (sllint)1;
	fibval[3] = (sllint)2;
	fibval[4] = (sllint)3;
	fibval[5] = (sllint)5;
	fibval[6] = (sllint)8;
	fibval[7] = (sllint)13;
	fibval[8] = (sllint)21;
	fibval[9] = (sllint)34;
	fibval[10] = (sllint)55;
	fibval[11] = (sllint)89;
	fibval[12] = (sllint)144;
	fibval[13] = (sllint)233;
	fibval[14] = (sllint)377;
	register sllint i;
	for (i = (sllint)15; i <= (sllint)num; ++i) { fibval[i] = (sllint)(fibval[i - (sllint)1] + fibval[i - (sllint)2]); if (i >= num) { break; } }
	return fibval[num];
}


#ifdef UINT128_SUPPORTED
/** Fibonacci Number Generator (128-bit integers); return 0 on error */
LIB_FUNC uint128_t fib128(const uint64_t num) {
	if (num > (uint64_t)180) { return 0; }
	else if (num <= (uint64_t)16) {
		switch (num) {
			case (uint64_t)0: return (uint128_t)0;
			case (uint64_t)1: return (uint128_t)1;
			case (uint64_t)2: return (uint128_t)1;
			case (uint64_t)3: return (uint128_t)2;
			case (uint64_t)4: return (uint128_t)3;
			case (uint64_t)5: return (uint128_t)5;
			case (uint64_t)6: return (uint128_t)8;
			case (uint64_t)7: return (uint128_t)13;
			case (uint64_t)8: return (uint128_t)21;
			default:  // Over 8, but less than 17
				switch (num) {
					case (uint64_t)9: return (uint128_t)34;
					case (uint64_t)10: return (uint128_t)55;
					case (uint64_t)11: return (uint128_t)89;
					case (uint64_t)12: return (uint128_t)144;
					case (uint64_t)13: return (uint128_t)233;
					case (uint64_t)14: return (uint128_t)377;
					case (uint64_t)15: return (uint128_t)610;
					default: return (uint128_t)987;  // case (uint128_t)16
				}
				break;
		}
	}
	uint128_t fibval[181] = { 0 };
	fibval[0] = (uint128_t)0;
	fibval[1] = (uint128_t)1;
	fibval[2] = (uint128_t)1;
	fibval[3] = (uint128_t)2;
	fibval[4] = (uint128_t)3;
	fibval[5] = (uint128_t)5;
	fibval[6] = (uint128_t)8;
	fibval[7] = (uint128_t)13;
	fibval[8] = (uint128_t)21;
	fibval[9] = (uint128_t)34;
	fibval[10] = (uint128_t)55;
	fibval[11] = (uint128_t)89;
	fibval[12] = (uint128_t)144;
	fibval[13] = (uint128_t)233;
	fibval[14] = (uint128_t)377;
	fibval[15] = (uint128_t)610;
	fibval[16] = (uint128_t)987;
	register uint64_t i;
	for (i = (uint64_t)17; i <= num; ++i) {
		fibval[i] = fibval[(i - (uint64_t)1)] + fibval[(i - (uint64_t)2)];
	}
	return fibval[num];
}
#endif


/** Fibonacci Prime Number Generator; return 0 on error

	@section DESCRIPTION
	A Fibonacci prime is a Fibonacci number that is prime.

	@param[in] num    Specify the first, second, etc. Fibonacci Prime
	@returns Fibonacci Prime
*/
LIB_FUNC uint64_t fibprime(const uint64_t num) {
	if (num > (uint64_t)11) { return 0; }
	switch (num) {
		case (uint64_t)0: return (uint64_t)2;
		case (uint64_t)1: return (uint64_t)3;
		case (uint64_t)2: return (uint64_t)5;
		case (uint64_t)3: return (uint64_t)13;
		case (uint64_t)4: return (uint64_t)89;
		case (uint64_t)5: return (uint64_t)233;
		case (uint64_t)6: return (uint64_t)1597;
		case (uint64_t)7: return (uint64_t)28657;
		case (uint64_t)8: return (uint64_t)514229;
		case (uint64_t)9: return (uint64_t)433494437;
		case (uint64_t)10: return (uint64_t)2971215073;
		default: return (uint64_t)99194853094755497;  // case (uint64_t)11
	}
	// [2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917, 475420437734698220747368027166749382927701417016557193662268716376935476241]
}


#ifdef UINT128_SUPPORTED
/** Fibonacci Prime Number Generator; return 0 on error

	@section DESCRIPTION
	A Fibonacci prime is a Fibonacci number that is prime.

	@param[in] num    Specify the first, second, etc. Fibonacci Prime
	@returns Fibonacci Prime
*/
LIB_FUNC uint128_t fibprime128(const uint64_t num) {
	if (num > (uint64_t)13) { return 0; }
	switch (num) {
		case (uint64_t)0: return (uint128_t)2;
		case (uint64_t)1: return (uint128_t)3;
		case (uint64_t)2: return (uint128_t)5;
		case (uint64_t)3: return (uint128_t)13;
		case (uint64_t)4: return (uint128_t)89;
		case (uint64_t)5: return (uint128_t)233;
		case (uint64_t)6: return (uint128_t)1597;
		case (uint64_t)7: return (uint128_t)28657;
		case (uint64_t)8: return (uint128_t)514229;
		case (uint64_t)9: return (uint128_t)433494437;
		case (uint64_t)10: return (uint128_t)2971215073;
		case (uint64_t)11: return (uint128_t)99194853094755497;
		case (uint64_t)12: return (uint128_t)((uint128_t)(10663404174917105UL * 100000000000UL) + 95814572169);  // 1066340417491710595814572169
		default: return (uint128_t)((uint128_t)(1913470240009327UL * 10000000000000UL) + 8081449423917);  // case (uint64_t)13; 19134702400093278081449423917
	}
	// [2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917, 475420437734698220747368027166749382927701417016557193662268716376935476241]
}
#endif


/** Lucas Number Generator; return 0 on error */
LIB_FUNC ulint lucas(const ulint num) {
#if (defined(ENV64BIT))
	if (num > (ulint)91) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (ulint)37) { return 0; }
#endif
	else if (num <= (ulint)12) {
		switch (num) {
			case (ulint)0: return (ulint)2;
			case (ulint)1: return (ulint)1;
			case (ulint)2: return (ulint)3;
			case (ulint)3: return (ulint)4;
			case (ulint)4: return (ulint)7;
			case (ulint)5: return (ulint)11;
			case (ulint)6: return (ulint)18;
			case (ulint)7: return (ulint)29;
			case (ulint)8: return (ulint)47;
			case (ulint)9: return (ulint)76;
			case (ulint)10: return (ulint)123;
			case (ulint)11: return (ulint)199;
			default: return (ulint)322;  // case (ulint)12
		}
	}
#   if (defined(ENV64BIT))
	ulint lucasval[92] = { 0 };
#   elif (defined(ENV32BIT))
	ulint lucasval[38] = { 0 };
#   endif
	lucasval[0] = (ulint)2;
	lucasval[1] = (ulint)1;
	lucasval[2] = (ulint)3;
	lucasval[3] = (ulint)4;
	lucasval[4] = (ulint)7;
	lucasval[5] = (ulint)11;
	lucasval[6] = (ulint)18;
	lucasval[7] = (ulint)29;
	lucasval[8] = (ulint)47;
	lucasval[9] = (ulint)76;
	lucasval[10] = (ulint)123;
	lucasval[11] = (ulint)199;
	lucasval[12] = (ulint)322;
	register ulint i;
	for (i = (ulint)13; i <= num; ++i) {
		lucasval[i] = lucasval[i - (ulint)1] + lucasval[i - (ulint)2];
	}
	return lucasval[num];
}


/** Lucas Prime Number Generator; return 0 on error

	@section DESCRIPTION
	A Lucas prime is a Lucas number that is prime.

	@param[in] num    Specify the first, second, etc. Lucas Prime
	@returns Lucas Prime
*/
LIB_FUNC uint64_t lucasprime(const uint64_t num) {
	if (num > (uint64_t)14) { return 0; }
	switch (num) {
		case (uint64_t)0: return (uint64_t)2;
		case (uint64_t)1: return (uint64_t)3;
		case (uint64_t)2: return (uint64_t)7;
		case (uint64_t)3: return (uint64_t)11;
		case (uint64_t)4: return (uint64_t)29;
		case (uint64_t)5: return (uint64_t)47;
		case (uint64_t)6: return (uint64_t)199;
		case (uint64_t)7: return (uint64_t)521;
		case (uint64_t)8: return (uint64_t)2207;
		case (uint64_t)9: return (uint64_t)3571;
		case (uint64_t)10: return (uint64_t)9349;
		case (uint64_t)11: return (uint64_t)3010349;
		case (uint64_t)12: return (uint64_t)54018521;
		case (uint64_t)13: return (uint64_t)370248451;
		default: return (uint64_t)6643838879;  // case (uint64_t)14
	}
	// [0, 2, 4, 5, 7, 8, 11, 13, 16, 17, 19, 31, 37, 41, 47, 53, 61, 71, 79, 113, 313, 353, 503, 613, 617, 863, 1097, 1361, 4787, 4793, 5851, 7741, 8467, 10691, 12251, 13963, 14449, 19469, 35449, 36779, 44507, 51169, 56003, 81671, 89849, 94823, 140057, 148091, 159521, 183089, 193201, 202667, 344293, 387433, 443609, 532277, 574219, 616787, 631181, 637751, 651821, 692147, 901657, 1051849]
}


/** Return the Nth Triangular Number */
LIB_FUNC unsigned int triangular_num(const unsigned int num) {
	return (unsigned int)((num * (num + 1)) / 2);
	// [0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351, 378, 406, 435, 465, 496, 528, 561, 595, 630, 666, 703, 741, 780, 820, 861, 903, 946, 990, 1035, 1081, 1128, 1176, 1225, 1275, 1326, 1378, 1431]
}


/** Return the Nth Triangular Number */
LIB_FUNC ullint triangular_numull(const ullint num) {
	return (ullint)((num * (num + (ullint)1)) / (ullint)2);
}


/** Return the Nth Triangular Number */
LIB_FUNC sllint triangular_numlonglong(const sllint num) {
	return (sllint)((num * (num + (sllint)1)) / (sllint)2);
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Triangular Number (128-bit unsigned integer) */
LIB_FUNC uint128_t triangular_u128(const uint128_t num) {
	return (uint128_t)((num * (num + (uint128_t)1)) / (uint128_t)2);
}
#endif


/** Return the Nth Hexagonal Number */
LIB_FUNC unsigned int hexagonal_num(const unsigned int num) {
	register unsigned int num2 = num + num;
	return (unsigned int)((num2 * (num2 - 1)) / 2);
	// [0, 1, 6, 15, 28, 45, 66, 91, 120, 153, 190, 231, 276, 325, 378, 435, 496, 561, 630, 703, 780, 861, 946, 1035, 1128, 1225, 1326, 1431, 1540, 1653, 1770, 1891, 2016, 2145, 2278, 2415, 2556, 2701, 2850, 3003, 3160, 3321, 3486, 3655, 3828, 4005, 4186, 4371, 4560]
}


/** Return the Nth Hexagonal Number */
LIB_FUNC ullint hexagonal_numull(const ullint num) {
	register ullint num2 = num + num;
	return (ullint)((num2 * (num2 - (ullint)1)) / (ullint)2);
}


/** Return the Nth Hexagonal Number */
LIB_FUNC sllint hexagonal_numlonglong(const sllint num) {
	register sllint num2 = (num + num);
	return (sllint)((num2 * (num2 - (sllint)0x1)) / (sllint)0x2);
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Hexagonal Number (128-bit unsigned integer) */
uint128_t hexagonal_u128(const uint128_t num) {
	register uint128_t num2 = (num + num);
	return (uint128_t)((num2 * (num2 - (uint128_t)1)) / (uint128_t)2);
}
#endif


/** Return the Nth Heptagonal Number ((5*(num^2) - 3 * num)/2) */
LIB_FUNC unsigned int heptagonal_num(const unsigned int num) {
	return (unsigned int)((((num * num) * 5) - (3 * num)) / 2);
	// [0, 1, 7, 18, 34, 55, 81, 112, 148, 189, 235, 286, 342, 403, 469, 540, 616, 697, 783, 874, 970, 1071, 1177, 1288, 1404, 1525, 1651, 1782, 1918, 2059, 2205, 2356, 2512, 2673, 2839, 3010, 3186, 3367, 3553, 3744, 3940, 4141, 4347, 4558, 4774, 4995, 5221, 5452, 5688]
}


/** Return the Nth Heptagonal Number ((5*(num^2) - 3 * num)/2) */
LIB_FUNC ullint heptagonal_numull(const ullint num) {
	return (ullint)((((num * num) * (ullint)5) - ((ullint)3 * num)) / (ullint)2);
}


/** Return the Nth Heptagonal Number ((5*(num^2) - 3 * num)/2) */
LIB_FUNC sllint heptagonal_numlonglong(const sllint num) {
	return (sllint)((((num * num) * (sllint)5) - ((sllint)3 * num)) / (sllint)2);
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Heptagonal Number ((5*(num^2) - 3 * num)/2) (128-bit unsigned integer) */
LIB_FUNC uint128_t heptagonal_u128(const uint128_t num) {
	return (uint128_t)((((num * num) * (uint128_t)5) - ((uint128_t)3 * num)) / (uint128_t)2);
}
#endif


/** Return the Nth Tetrahedral Number */
LIB_FUNC unsigned int tetrahedral_num(const unsigned int num) {
	return (unsigned int)((num * (num + 1) * (num + 2)) / 6);
	// [0, 1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180]
}


/** Return the Nth Tetrahedral Number */
LIB_FUNC ullint tetrahedral_numull(const ullint num) {
	return (ullint)((num * (num + (ullint)1) * (num + (ullint)2)) / (ullint)6);
}


/** Return the Nth Tetrahedral Number */
LIB_FUNC sllint tetrahedral_numlonglong(const sllint num) {
	return (num * (num + (sllint)1) * (num + (sllint)2)) / (sllint)6;
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Tetrahedral Number (128-bit unsigned integer) */
LIB_FUNC uint128_t tetrahedral_u128(const uint128_t num) {
	return (num * (num + (uint128_t)1) * (num + (uint128_t)2)) / (uint128_t)6;
}
#endif


/** Return the Nth Pentatope Number */
LIB_FUNC unsigned int pentatope_num(const unsigned int num) {
	return ((num * (num + 1) * (num + 2) * (num + 3)) / 24);
	// [2, 5, 70, 1088430, 58478088289964410654020]
}


/** Return the Nth Pentatope Number */
LIB_FUNC ullint pentatope_numull(const ullint num) {
	return ((num * (num + (ullint)1) * (num + (ullint)2) * (num + (ullint)3)) / (ullint)24);
}


/** Return the Nth Pentatope Number */
LIB_FUNC sllint pentatope_numlonglong(const sllint num) {
	return ((num * (num + (sllint)1) * (num + (sllint)2) * (num + (sllint)3)) / (sllint)24);
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Pentatope Number (128-bit unsigned integer) */
LIB_FUNC uint128_t pentatope_u128(const uint128_t num) {
	return ((num * (num + (uint128_t)0x1) * (num + (uint128_t)0x2) * (num + (uint128_t)0x3)) / (uint128_t)0x24);
}
#endif


/** Return the Nth Mersenne Number; return 0 on error */
LIB_FUNC unsigned int mersenne_num(const unsigned int num) {
#if (defined(ENV64BIT))
	if (num > (unsigned int)31) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (unsigned int)15) { return 0; }
#endif
	else { return (((unsigned int)0x1 << num) - 0x1); }
	// [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295]
}


/** Return the Nth Mersenne Number; return 0 on error */
LIB_FUNC ullint mersenne_numull(const ullint num) {
#if (defined(ENV64BIT))
	if (num > (ullint)63) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (ullint)31) { return 0; }
#endif
	return (((ullint)0x1 << num) - 0x1);
}


/** Return the Nth Mersenne Number; return 0 on error */
LIB_FUNC sllint mersenne_numlonglong(const sllint num) {
#if (defined(ENV64BIT))
	if (num > (sllint)63 || num < (sllint)1) { return 0; }
#elif (defined(ENV32BIT))
	if (num > (sllint)31 || num < (sllint)1) { return 0; }
#endif
	return (((sllint)0x1 << num) - 0x1);
	// [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295]
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Mersenne Number (128-bit unsigned integer); return 0 on error */
LIB_FUNC uint128_t mersenne_u128(const uint128_t num) {
	if ((uint128_t)num > (uint128_t)126) { return 0; }
	return (((uint128_t)0x1 << num) - (uint128_t)0x1);
}
#endif


/** Return the Nth Mersenne Prime Number; return 0 on error */
LIB_FUNC unsigned int mersenneprime_num(const unsigned int num) {
	switch (num) {
		case (unsigned int)0: return (unsigned int)1;
		case (unsigned int)1: return (unsigned int)3;
		case (unsigned int)2: return (unsigned int)7;
		case (unsigned int)3: return (unsigned int)31;
		case (unsigned int)4: return (unsigned int)127;
		case (unsigned int)5: return (unsigned int)2047;
		case (unsigned int)6: return (unsigned int)8191;
		case (unsigned int)7: return (unsigned int)131071;
		case (unsigned int)8: return (unsigned int)524287;
		case (unsigned int)9: return (unsigned int)8388607;
		case (unsigned int)10: return (unsigned int)536870911;
		case (unsigned int)11: return (unsigned int)2147483647;
		default: return (unsigned int)0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return (unsigned int)0;
}


/** Return the Nth Mersenne Prime Number; return 0 on error */
LIB_FUNC ullint mersenneprime_numull(const ullint num) {
	switch (num) {
		case (ullint)0: return (ullint)1;
		case (ullint)1: return (ullint)3;
		case (ullint)2: return (ullint)7;
		case (ullint)3: return (ullint)31;
		case (ullint)4: return (ullint)127;
		case (ullint)5: return (ullint)2047;
		case (ullint)6: return (ullint)8191;
		case (ullint)7: return (ullint)131071;
		case (ullint)8: return (ullint)524287;
		case (ullint)9: return (ullint)8388607;
		case (ullint)10: return (ullint)536870911;
		case (ullint)11: return (ullint)2147483647;
		case (ullint)12: return (ullint)137438953471;
		case (ullint)13: return (ullint)2199023255551;
		case (ullint)14: return (ullint)8796093022207;
		case (ullint)15: return (ullint)140737488355327;
		case (ullint)16: return (ullint)9007199254740991;
		case (ullint)17: return (ullint)576460752303423487;
		case (ullint)18: return (ullint)2305843009213693951;
		default: return (ullint)0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return (ullint)0;
}


/** Return the Nth Mersenne Prime Number; return 0 on error */
LIB_FUNC sllint mersenneprime_numlonglong(const sllint num) {
	switch (num) {
		case (sllint)0: return (sllint)1;
		case (sllint)1: return (sllint)3;
		case (sllint)2: return (sllint)7;
		case (sllint)3: return (sllint)31;
		case (sllint)4: return (sllint)127;
		case (sllint)5: return (sllint)2047;
		case (sllint)6: return (sllint)8191;
		case (sllint)7: return (sllint)131071;
		case (sllint)8: return (sllint)524287;
		case (sllint)9: return (sllint)8388607;
		case (sllint)10: return (sllint)536870911;
		case (sllint)11: return (sllint)2147483647;
		case (sllint)12: return (sllint)137438953471;
		case (sllint)13: return (sllint)2199023255551;
		case (sllint)14: return (sllint)8796093022207;
		case (sllint)15: return (sllint)140737488355327;
		case (sllint)16: return (sllint)9007199254740991;
		case (sllint)17: return (sllint)576460752303423487;
		case (sllint)18: return (sllint)2305843009213693951;
		default: return (sllint)0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return (sllint)0;
}


#ifdef UINT128_SUPPORTED
/** Return the Nth Mersenne Prime Number (128-bit unsigned integer); return 0 on error */
LIB_FUNC uint128_t mersenneprime_u128(const uint128_t num) {
	switch (num) {
		case (uint64_t)0: return (uint128_t)1;
		case (uint64_t)1: return (uint128_t)3;
		case (uint64_t)2: return (uint128_t)7;
		case (uint64_t)3: return (uint128_t)31;
		case (uint64_t)4: return (uint128_t)127;
		case (uint64_t)5: return (uint128_t)2047;
		case (uint64_t)6: return (uint128_t)8191;
		case (uint64_t)7: return (uint128_t)131071;
		case (uint64_t)8: return (uint128_t)524287;
		case (uint64_t)9: return (uint128_t)8388607;
		case (uint64_t)10: return (uint128_t)536870911;
		case (uint64_t)11: return (uint128_t)2147483647;
		case (uint64_t)12: return (uint128_t)137438953471;
		case (uint64_t)13: return (uint128_t)2199023255551;
		case (uint64_t)14: return (uint128_t)8796093022207;
		case (uint64_t)15: return (uint128_t)140737488355327;
		case (uint64_t)16: return (uint128_t)9007199254740991;
		case (uint64_t)17: return (uint128_t)576460752303423487;
		case (uint64_t)18: return (uint128_t)2305843009213693951;
		case (uint64_t)19: return (uint128_t)((uint128_t)(147573952589UL * 1000000000UL) + 676412927);  // 147573952589676412927
		case (uint64_t)20: return (uint128_t)((uint128_t)(23611832414UL * 100000000000UL) + 34822606847);  // 2361183241434822606847
		default: return (uint128_t)0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return (uint128_t)0;
}
#endif


// NUMBER-TYPE TESTS

/** Test if a number is a perfect square */
LIB_FUNC int issquare(const int num) {
	if (num < 0) { return -1; }
	register double test = floor(sqrt((double)num) + (double)0.5);
	if ((int)(test * test) == num) { return 1; }
	return 0;
}


/** Test if a number is a perfect square */
LIB_FUNC int islongsquare(const long num) {
	if (num < (long)0) { return -1; }
	register double test = floor(sqrt((double)num) + (double)0.5);
	if ((long)(test * test) == num) { return 1; }
	return 0;
}


/** Test if a number is a perfect square */
LIB_FUNC int islonglongsquare(const long long num) {
	if (num < (long long)0) { return -1; }
	long double test = floorl(sqrtl((long double)num) + (long double)0.5L);
	if ((long long)(test * test) == num) { return 1; }
	return 0;
}


/** Test if a float is a perfect square */
LIB_FUNC int isfloatsquare(const float num) {
	if (num < (float)0.0F) { return -1; }
	register float test = floorf(sqrtf(num) + (float)0.5F);
	if ((float)(test * test) == num) { return 1; }
	return 0;
}


/** Test if a double is a perfect square */
LIB_FUNC int isdoublesquare(const double num) {
	if (num < (double)0.0) { return -1; }
	register double test = floor(sqrt(num) + (double)0.5);
	if ((double)(test * test) == num) { return 1; }
	return 0;
}


/** Test if a long double is a perfect square */
LIB_FUNC int islongdoublesquare(const long double num) {
	if (num < (long double)0.0L) { return -1; }
	const long double test = floorl(sqrtl(num) + (long double)0.5L);
	if ((long double)(test * test) == num) { return 1; }
	return 0;
}


/** Test if the given number is a Triangular Number */
LIB_FUNC int istriangular(const long num) {
	if (num < (long)0) { return -1; }
	return islongsquare((long)((long)8 * num + (long)1));
}


/** Test if the given number is a Triangular Number */
LIB_FUNC int islonglongtriangular(const long long num) {
	if (num < (long long)0) { return -1; }
	return islonglongsquare((long long)((long long)8 * num + (long long)1));
}


/** Test if the given number is a Triangular Number */
LIB_FUNC int isdoubletriangular(const double num) {
	if (num < (double)0.0) { return -1; }
	return isdoublesquare((double)((double)8.0 * num + (double)1.0));
}


/** Test if the given number is a Hexagonal Number */
LIB_FUNC int ishexagonal(const long num) {
	if (num < (long)0) { return -1; }
	register double ans = ((sqrt((double)((long)8 * num + (long)1)) + 1.0) * 0.25);
	if (ans == floor(ans)) { return 1; }
	return 0;
}


/** Test if the given number is a Hexagonal Number */
LIB_FUNC int islonglonghexagonal(const long long num) {
	if (num < (long long)0) { return -1; }
	const long double ans = ((sqrtl((long double)((long long)8 * num + (long long)1)) + 1.0L) * 0.25L);
	if (ans == floorl(ans)) { return 1; }
	return 0;
}


/** Test if the given number is a Heptagonal Number */
LIB_FUNC int isheptagonal(const long num) {
	if (num < (long)0) { return -1; }
	register double ans = ((sqrt((double)((long)40 * num + (long)9)) + 3.0) * 0.1);
	if (ans == floor(ans)) { return 1; }
	return 0;
}


/** Test if the given number is a Heptagonal Number */
LIB_FUNC int islonglongheptagonal(const long long num) {
	if (num < (long long)0) { return -1; }
	long double ans = ((sqrtl((long double)((long long)40 * num + (long long)9)) + 3.0L) * 0.1L);
	if (ans == floorl(ans)) { return 1; }
	return 0;
}


/** Test if the given number is a Power-of-Two */
LIB_FUNC int ispoweroftwo(const unsigned int num) {
	return ((num != 0) && !(num & (num - 1)));
}


/** Test if the given number is a Power-of-Two */
LIB_FUNC int islonglongpoweroftwo(const long long num) {
	return ((num != (long long)0) && !(num & (num - (long long)1)));
}


/** Test if the given number is a Power-of-Two */
LIB_FUNC int isullpoweroftwo(const ullint num) {
	return ((num != (ullint)0) && !(num & (num - (ullint)1)));
}


/** Test if the given number is a Mersenne Number */
LIB_FUNC int ismersennenumber(const unsigned int num) {
	return (((num + 1) != 0) && !((num + 1) & ((num + 1) - 1)));
}


/** Test if the given number is a Mersenne Number */
LIB_FUNC int islonglongmersennenumber(const long long num) {
	return (((num + (long long)1) != (long long)0) && !((num + (long long)1) & ((num + (long long)1) - (long long)1)));
}


/** Test if the given number is a Mersenne Prime */
LIB_FUNC int ismersenneprime(const unsigned int num) {
	switch (num) {
		case 1: return 0;
		case 3:
		case 7:
		case 31:
		case 127:
		case 2047:
		case 8191:
		case 131071:
		case 524287:
		case 8388607:
		case 536870911:
		case 2147483647: return 1;
		default: return 0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return 0;
}


/** Test if the given number is a Mersenne Prime */
LIB_FUNC int islonglongmersenneprime(const sllint num) {
	switch (num) {
		case (sllint)1: return (int)0;
		case (sllint)3:
		case (sllint)7:
		case (sllint)31:
		case (sllint)127:
		case (sllint)2047:
		case (sllint)8191:
		case (sllint)131071:
		case (sllint)524287:
		case (sllint)8388607:
		case (sllint)536870911:
		case (sllint)2147483647:
		case (sllint)137438953471:
		case (sllint)2199023255551:
		case (sllint)8796093022207:
		case (sllint)140737488355327:
		case (sllint)9007199254740991:
		case (sllint)576460752303423487:
		case (sllint)2305843009213693951: return (int)1;
		default: return (int)0;
	} // [3, 7, 31, 127, 2047, 8191, 131071, 524287, 8388607, 536870911, 2147483647, 137438953471, 2199023255551, 8796093022207, 140737488355327, 9007199254740991, 576460752303423487, 2305843009213693951, 147573952589676412927, 2361183241434822606847]
	return (int)0;
}


/** Test if a signed int is prime */
LIB_FUNC int isprime(const int num) {
	if ((num & 1) == 0) { return 0; }
	else if (num < 20) {
		switch (num) {
			case 1: return 0;
			case 3:
			case 7:
			case 11:
			case 13:
			case 17:
			case 19: return 1;
			default: return 0;
		}
	} else if (num % 3 == 0 || num % 5 == 0 || num % 7 == 0 || num % 11 == 0) {
		return 0;
	} else if (num % 13 == 0 || num % 17 == 0 || num % 19 == 0) {
		return 0;
	}
	register int i;
	for (i = 23; i < num; i += 2) { if (num % i == 0x0) { return (int)(i == num); } }
	return 1;
}


/** Test if an unsigned int is prime */
LIB_FUNC int isunsignedprime(const unsigned int num) {
	if ((num & (unsigned int)1) == (unsigned int)0) { return 0; }
	else if (num < (unsigned int)20) {
		switch (num) {
			case (unsigned int)1: return 0;
			case (unsigned int)3:
			case (unsigned int)7:
			case (unsigned int)11:
			case (unsigned int)13:
			case (unsigned int)17:
			case (unsigned int)19: return 1;
			default: return 0;
		}
	} else if (num % (unsigned int)3 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)5 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)7 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)11 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)13 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)17 == (unsigned int)0) {
		return 0;
	} else if (num % (unsigned int)19 == (unsigned int)0) {
		return 0;
	}
	register unsigned int i;
	for (i = (unsigned int)23; i < num; i += (unsigned int)2) {
		if (num % i == (unsigned int)0) { return (int)(i == num); }
	}
	return 1;
}


/** Test if a long int is prime */
LIB_FUNC int islongprime(const long num) {
	if ((num & (long)1) == (long)0) { return 0; }
	else if (num < (long)20) {
		switch (num) {
			case (long)1: return 0;
			case (long)3:
			case (long)7:
			case (long)11:
			case (long)13:
			case (long)17:
			case (long)19: return 1;
			default: return 0;
		}
	} else if (num % (long)3 == (long)0 || num % (long)5 == (long)0 || num % (long)7 == (long)0) {
		return 0;
	} else if (num % (long)11 == (long)0 || num % (long)13 == (long)0) {
		return 0;
	} else if (num % (long)17 == (long)0 || num % (long)19 == (long)0) {
		return 0;
	}
	register long i;
	for (i = (long)23; i < num; i += (long)2) {
		if (num % i == (long)0) { return (int)(i == num); }
	}
	return 1;
}


/** Test if a long long int is prime */
LIB_FUNC int islonglongprime(const long long num) {
	if ((num & (long long)1) == (long long)0) { return 0; }
	else if (num < (long long)20) {
		switch (num) {
			case (long long)1: return 0;
			case (long long)3:
			case (long long)7:
			case (long long)11:
			case (long long)13:
			case (long long)17:
			case (long long)19: return 1;
			default: return 0;
		}
	} else if (num % (long long)3 == (long long)0 || num % (long long)5 == (long long)0) {
		return 0;
	} else if (num % (long long)7 == (long long)0 || num % (long long)11 == (long long)0) {
		return 0;
	} else if (num % (long long)13 == (long long)0 || num % (long long)17 == (long long)0 || num % (long long)19 == (long long)0) {
		return 0;
	}
	register long long i;
	for (i = (long long)23; i < num; i += (long long)2) {
		if (num % i == (long long)0) { return (int)(i == num); }
	}
	return 1;
}


/** Test if a unsigned long int is prime */
LIB_FUNC int isulprime(const ulint num) {
	if ((num & (ulint)1) == (ulint)0) { return 0; }
	else if (num < (ulint)20) {
		switch (num) {
			case (ulint)1: return 0;
			case (ulint)3:
			case (ulint)7:
			case (ulint)11:
			case (ulint)13:
			case (ulint)17:
			case (ulint)19: return 1;
			default: break;
		}
	} else if (num % (ulint)3 == (ulint)0) { return 0; }
	else if (num % (ulint)5 == (ulint)0) { return 0; }
	else if (num % (ulint)7 == (ulint)0) { return 0; }
	else if (num % (ulint)11 == (ulint)0) { return 0; }
	else if (num % (ulint)13 == (ulint)0) { return 0; }
	else if (num % (ulint)17 == (ulint)0) { return 0; }
	else if (num % (ulint)19 == (ulint)0) { return 0; }
	register ulint i;
	for (i = (ulint)23; i < num; i += (ulint)2) {
		if (num % i == (ulint)0) { return (int)(i == num); }
	}
	return 1;
}


/** Test if a ullint is prime */
LIB_FUNC int isullprime(const ullint num) {
	if ((num & (ullint)1) == (ullint)0) { return 0; }
	else if (num < (ullint)20) {
		switch (num) {
			case (ullint)1: return 0;
			case (ullint)3:
			case (ullint)7:
			case (ullint)11:
			case (ullint)13:
			case (ullint)17:
			case (ullint)19: return 1;
			default: break;
		}
	} else if (num % (ullint)3 == (ullint)0) { return 0; }
	else if (num % (ullint)5 == (ullint)0) { return 0; }
	else if (num % (ullint)7 == (ullint)0) { return 0; }
	else if (num % (ullint)11 == (ullint)0) { return 0; }
	else if (num % (ullint)13 == (ullint)0) { return 0; }
	else if (num % (ullint)17 == (ullint)0) { return 0; }
	else if (num % (ullint)19 == (ullint)0) { return 0; }
	register ullint i;
	for (i = (ullint)23; i < num; i += (ullint)2) {
		if (num % i == (ullint)0) { return (int)(i == num); }
	}
	return 1;
}


/** Test if an int is composite */
LIB_FUNC int iscomposite(const int num) {
	if ((num & 1) == 0) { return 1; }
	else if (num < 0) { return 0; }
	else if (num < 20) {
		switch (num) {
			case 1:
			case 3:
			case 7:
			case 11:
			case 13:
			case 17:
			case 19: return 0;
			default: return 1;
		}
	} else if (num % 3 == 0 || num % 5 == 0 || num % 7 == 0) {
		return 1;
	} else if (num % 11 == 0 || num % 13 == 0 || num % 17 == 0 || num % 19 == 0) {
		return 1;
	}
	register int i;
	for (i = 23; i < num; i += 2) {
		if (num % i == 0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an unsigned int is composite */
LIB_FUNC int isunsignedcomposite(const unsigned int num) {
	if ((num & (unsigned int)1) == (unsigned int)0) { return 1; }
	else if (num < (unsigned int)20) {
		switch (num) {
			case (unsigned int)1:
			case (unsigned int)3:
			case (unsigned int)7:
			case (unsigned int)11:
			case (unsigned int)13:
			case (unsigned int)17:
			case (unsigned int)19: return 0;
			default: return 1;
		}
	} else if (num % (unsigned int)3 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)5 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)7 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)11 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)13 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)17 == (unsigned int)0) { return 1; }
	else if (num % (unsigned int)19 == (unsigned int)0) { return 1; }
	register unsigned int i;
	for (i = (unsigned int)23; i < num; i += (unsigned int)2) {
		if (num % i == (unsigned int)0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an long is composite */
LIB_FUNC int islongcomposite(const long num) {
	if ((num & (long)1) == (long)0) return 1;
	else if (num < (long)0) { return 0; }
	else if (num < (long)20) {
		switch (num) {
			case (long)1:
			case (long)3:
			case (long)7:
			case (long)11:
			case (long)13:
			case (long)17:
			case (long)19: return 0;
			default: return 1;
		}
	} else if (num % (long)3 == (long)0) { return 1; }
	else if (num % (long)5 == (long)0) { return 1; }
	else if (num % (long)7 == (long)0) { return 1; }
	else if (num % (long)11 == (long)0) { return 1; }
	else if (num % (long)13 == (long)0) { return 1; }
	else if (num % (long)17 == (long)0) { return 1; }
	else if (num % (long)19 == (long)0) { return 1; }
	register long i;
	for (i = (long)23; i < num; i += (long)2) {
		if (num % i == (long)0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an long long is composite */
LIB_FUNC int islonglongcomposite(const long long num) {
	if ((num & (long long)1) == (long long)0) { return 1; }
	else if (num < (long long)0) { return 0; }
	else if (num < (long long)20) {
		switch (num) {
			case (long long)1:
			case (long long)3:
			case (long long)7:
			case (long long)11:
			case (long long)13:
			case (long long)17:
			case (long long)19: return 0;
			default: return 1;
		}
	} else if (num % (long long)3 == (long long)0) { return 1; }
	else if (num % (long long)5 == (long long)0) { return 1; }
	else if (num % (long long)7 == (long long)0) { return 1; }
	else if (num % (long long)11 == (long long)0) { return 1; }
	else if (num % (long long)13 == (long long)0) { return 1; }
	else if (num % (long long)17 == (long long)0) { return 1; }
	else if (num % (long long)19 == (long long)0) { return 1; }
	register long long i;
	for (i = (long long)23; i < num; i += (long long)2) {
		if (num % i == (long long)0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an unsigned long int is composite */
LIB_FUNC int isulcomposite(const ulint num) {
	if ((num & (ulint)1) == (ulint)0) { return 1; }
	else if (num < (ulint)20) {
		switch (num) {
			case (ulint)1:
			case (ulint)3:
			case (ulint)7:
			case (ulint)11:
			case (ulint)13:
			case (ulint)17:
			case (ulint)19: return 0;
			default: return 1;
		}
	} else if (num % (ulint)3 == (ulint)0) { return 1; }
	else if (num % (ulint)5 == (ulint)0) { return 1; }
	else if (num % (ulint)7 == (ulint)0) { return 1; }
	else if (num % (ulint)11 == (ulint)0) { return 1; }
	else if (num % (ulint)13 == (ulint)0) { return 1; }
	else if (num % (ulint)17 == (ulint)0) { return 1; }
	else if (num % (ulint)19 == (ulint)0) { return 1; }
	register ulint i;
	for (i = (ulint)23; i < num; i += (ulint)2) {
		if (num % i == (ulint)0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an ullint is composite */
LIB_FUNC int isullcomposite(const ullint num) {
	if ((num & (ullint)1) == (ullint)0) { return 1; }
	else if (num < (ullint)20) {
		switch (num) {
			case (ullint)1:
			case (ullint)3:
			case (ullint)7:
			case (ullint)11:
			case (ullint)13:
			case (ullint)17:
			case (ullint)19: return 0;
			default: return 1;
		}
	} else if (num % (ullint)3 == (ullint)0) { return 1; }
	else if (num % (ullint)5 == (ullint)0) { return 1; }
	else if (num % (ullint)7 == (ullint)0) { return 1; }
	else if (num % (ullint)11 == (ullint)0) { return 1; }
	else if (num % (ullint)13 == (ullint)0) { return 1; }
	else if (num % (ullint)17 == (ullint)0) { return 1; }
	else if (num % (ullint)19 == (ullint)0) { return 1; }
	register ullint i;
	for (i = (ullint)23; i < num; i += (ullint)2) {
		if (num % i == (ullint)0) { return (int)(i != num); }
	}
	return 0;
}


/** Test if an uint64_t is a Fibonacci Prime; A Fibonacci prime is a Fibonacci number that is prime

	@param[in] num    A 64-bit integer
	@retval 0    False: This is not a Fibonacci Prime
	@retval 1    True: This is a Fibonacci Prime
*/
LIB_FUNC int isfibprime(const uint64_t num) {
	switch (num) {
		case (uint64_t)2:
		case (uint64_t)3:
		case (uint64_t)5:
		case (uint64_t)13:
		case (uint64_t)89:
		case (uint64_t)233:
		case (uint64_t)1597:
		case (uint64_t)28657:
		case (uint64_t)514229:
		case (uint64_t)433494437:
		case (uint64_t)2971215073:
		case (uint64_t)99194853094755497: return (int)1;
		default: return (int)0;  // False
	}
	// [2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917, 475420437734698220747368027166749382927701417016557193662268716376935476241]
}


#ifdef UINT128_SUPPORTED
/** Test if an uint128_t is a Fibonacci Prime; A Fibonacci prime is a Fibonacci number that is prime

	@param[in] num    A 128-bit integer
	@retval 0    False: This is not a Fibonacci Prime
	@retval 1    True: This is a Fibonacci Prime
*/
LIB_FUNC int isfibprime128(const uint128_t num) {
	switch (num) {
		case (uint128_t)2:
		case (uint128_t)3:
		case (uint128_t)5:
		case (uint128_t)13:
		case (uint128_t)89:
		case (uint128_t)233:
		case (uint128_t)1597:
		case (uint128_t)28657:
		case (uint128_t)514229:
		case (uint128_t)433494437:
		case (uint128_t)2971215073:
		case (uint128_t)99194853094755497: return (int)1;
		case (uint128_t)((uint128_t)(10663404174917105UL * 100000000000UL) + 95814572169): return (int)1;  // 1066340417491710595814572169
		case (uint128_t)((uint128_t)(1913470240009327UL * 10000000000000UL) + 8081449423917): return (int)1;  // 19134702400093278081449423917
		default: return (int)0;  // False
	}
	// [2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, 1066340417491710595814572169, 19134702400093278081449423917, 475420437734698220747368027166749382927701417016557193662268716376935476241]
}
#endif


/** Test if an uint64_t is a Lucas Number */
LIB_FUNC int islucas(const uint64_t num) {
	if (num < (ullint)1024) {
		switch (num) {
			case (uint64_t)2:
			case (uint64_t)1:
			case (uint64_t)3:
			case (uint64_t)4:
			case (uint64_t)7:
			case (uint64_t)11:
			case (uint64_t)18:
			case (uint64_t)29:
			case (uint64_t)47:
			case (uint64_t)76:
			case (uint64_t)123:
			case (uint64_t)199:
			case (uint64_t)322:
			case (uint64_t)521:
			case (uint64_t)843: return (int)1;
			default: return (int)0;  // False
		}
	} else if (num > (ullint)1024 && num < (ullint)1860499) {
		switch (num) {
			case (uint64_t)1364:
			case (uint64_t)2207:
			case (uint64_t)3571:
			case (uint64_t)5778:
			case (uint64_t)9349:
			case (uint64_t)15127:
			case (uint64_t)24476:
			case (uint64_t)39603:
			case (uint64_t)64079:
			case (uint64_t)103682:  // 24
			case (uint64_t)167761:
			case (uint64_t)271443:
			case (uint64_t)439204:
			case (uint64_t)710647:
			case (uint64_t)1149851:
			case (uint64_t)1860498: return (int)1;
			default: return (int)0;  // False
		}
	} else if (num > (ullint)3010340 && num < (ullint)141422325) {
		switch (num) {
			case (uint64_t)3010349:
			case (uint64_t)4870847:
			case (uint64_t)7881196:
			case (uint64_t)12752043:  // 34
			case (uint64_t)20633239:
			case (uint64_t)33385282:
			case (uint64_t)54018521:
			case (uint64_t)87403803:
			case (uint64_t)141422324: return (int)1;
			default: return (int)0;  // False
		}
	} else { return (int)0; }  // False
	// [1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521, 843, 1364, 2207, 3571, 5778, 9349, 15127, 24476, 39603, 64079, 103682, 167761, 271443, 439204, 710647, 1149851, 1860498, 3010349, 4870847, 7881196, 12752043, 20633239, 33385282, 54018521, 87403803, 141422324]
}


/** Test if an uint64_t is a Lucas Prime; A Lucas prime is a Lucas number that is prime

	@param[in] num    A 64-bit integer
	@retval 0    False: This is not a Lucas Prime
	@retval 1    True: This is a Lucas Prime
*/
LIB_FUNC int islucasprime(const uint64_t num) {
	switch (num) {
		case (uint64_t)2:
		case (uint64_t)3:
		case (uint64_t)7:
		case (uint64_t)11:
		case (uint64_t)29:
		case (uint64_t)47:
		case (uint64_t)199:
		case (uint64_t)521:
		case (uint64_t)2207:
		case (uint64_t)3571:
		case (uint64_t)9349:
		case (uint64_t)3010349:
		case (uint64_t)54018521:
		case (uint64_t)370248451:
		case (uint64_t)6643838879: return (int)1;
		default: return (int)0;  // False
	}
	// [0, 2, 4, 5, 7, 8, 11, 13, 16, 17, 19, 31, 37, 41, 47, 53, 61, 71, 79, 113, 313, 353, 503, 613, 617, 863, 1097, 1361, 4787, 4793, 5851, 7741, 8467, 10691, 12251, 13963, 14449, 19469, 35449, 36779, 44507, 51169, 56003, 81671, 89849, 94823, 140057, 148091, 159521, 183089, 193201, 202667, 344293, 387433, 443609, 532277, 574219, 616787, 631181, 637751, 651821, 692147, 901657, 1051849]
}


// ANGLES

/** Return the complement of an angle (all in degrees) */
LIB_FUNC float complement_angle_degf(const float angle) {
	return (90.0F - angle);
}


/** Return the complement of an angle (all in degrees) */
LIB_FUNC double complement_angle_deg(const double angle) {
	return (90.0 - angle);
}


/** Return the complement of an angle (all in degrees) */
LIB_FUNC long double complement_angle_degl(const long double angle) {
	return (90.0L - angle);
}


/** Return the supplement of an angle (all in degrees) */
LIB_FUNC float supplement_angle_degf(const float angle) {
	return (180.0F - angle);
}


/** Return the supplement of an angle (all in degrees) */
LIB_FUNC double supplement_angle_deg(const double angle) {
	return (180.0 - angle);
}


/** Return the supplement of an angle (all in degrees) */
LIB_FUNC long double supplement_angle_degl(const long double angle) {
	return (180.0 - angle);
}


/** Return the angle (in radians) of an arc given arc-length and radius */
LIB_FUNC double arc_angle(const double arc_length, const double radius) {
	return (arc_length / radius);
}


// GRAPHING

/** Return the y coordinate for a given angle (radians) */
LIB_FUNC double sin_wave_equation(const double amplitude, const double angle) {
	return (amplitude * sin(angle));
}


/** Sawtooth-Wave function */
LIB_FUNC double sawtooth(const double x) {
	return (x - floor(x));
}


/** Advanced Sawtooth-Wave function (set period and amplitude) */
LIB_FUNC double sawtooth2(const double x, const double period, const double amplitude) {
	return ((((double)2.0 * amplitude) / PI) * (atan(cot((x * PI) / period))));
}


/** Sigmoid-Curve function */
LIB_FUNC double sigmoid(const double x) {
	return ((double)1.0 / ((double)1.0 + pow(E, -x)));
}


/** Square-Wave function */
LIB_FUNC double squarewave(const double x) {
	return sgn(sin(x));
}


/** Triangle-Wave function */
LIB_FUNC int trianglewave(const int x) {
	return (abs((x & 1)) - 1);
}


// MISCELLANEOUS MATH FUNCTIONS

#define SET_MANTISSA_FLOAT(flt, mant)   do { union ieee754_float u; u.f = (flt); if ((mant & 0x7fffff) == 0) { mant = 0x400000; } u.ieee.mantissa = (mant) & 0x7fffff; (flt) = u.f; } while (0x0)
#define SET_MANTISSA_DOUBLE(flt, mant)   do { union ieee754_double u; u.d = (flt); u.ieee_nan.mantissa0 = (mant) >> 32; u.ieee_nan.mantissa1 = (mant); if ((u.ieee.mantissa0 | u.ieee.mantissa1) != 0) { (flt) = u.d; } } while (0x0)


/** Return X^2 + Y^2 - 1, computed without large cancellation error; It is given that 1 > X >= Y >= epsilon / 2, and that X^2 + Y^2 >= 0.5 */
LIB_FUNC float __x2y2m1f(const float x, const float y) {
	double dx = x, dy = y;
	return (float)((dx - 1) * (dx + 1) + dy * dy);
}


/** Calculate X + Y exactly and store the result in *HI + *LO; It is given that |X| >= |Y| and the values are small enough that no overflow occurs */
LIB_FUNC void add_split_doubles(double* hi, double* lo, const double x, const double y) {
	*hi = x + y;  // Dekker's algorithm
	*lo = (x - *hi) + y;
}


/** Calculate X * Y exactly and store the result in *HI + *LO; It is given that the values are small enough that no overflow occurs and large enough (or zero) that no underflow occurs */
LIB_FUNC void mul_split_doubles(double* hi, double* lo, const double x, const double y) {
#ifdef __FP_FAST_FMA  // Fast built-in fused multiply-add
	*hi = x * y;
	*lo = fma(x, y, (-*hi));
#else  // Dekker's algorithm
	*hi = x * y;
	double x1 = x * ((1 << (DBL_MANT_DIG + 1) / 2) + 1);
	double y1 = y * ((1 << (DBL_MANT_DIG + 1) / 2) + 1);
	x1 = (x - x1) + x1;
	y1 = (y - y1) + y1;
	const double x2 = x - x1;
	const double y2 = y - y1;
	*lo = (((x1 * y1 - *hi) + x1 * y2) + x2 * y1) + x2 * y2;
#endif
}


/** Compare absolute values of floating-point values pointed to by P and Q for qsort */
LIB_FUNC int compare_doubles(const void* p, const void* q) {
	const double pd = fabs(*(const double*)p);
	const double qd = fabs(*(const double*)q);
	if (pd < qd) { return -1; }
	else if (pd == qd) { return 0; }
	else { return 1; }
}


/** Return X^2 + Y^2 - 1, computed without large cancellation error; It is given that 1 > X >= Y >= epsilon / 2, and that X^2 + Y^2 >= 0.5 */
LIB_FUNC double __x2y2m1(const double x, const double y) {
	double vals[5];
	// SET_RESTORE_ROUND(FE_TONEAREST);
	mul_split_doubles(&vals[1], &vals[0], x, x);
	mul_split_doubles(&vals[3], &vals[2], y, y);
	vals[4] = -1.0;
	qsort(vals, 5, SIZEOF_DOUBLE, compare_doubles);
	for (size_t i = 0; i <= 3; i++) {
		add_split_doubles(&vals[i + 1], &vals[i], vals[i + 1], vals[i]);
		qsort((vals + i + 1), 4 - i, SIZEOF_DOUBLE, compare_doubles);
	}
	return vals[4] + vals[3] + vals[2] + vals[1] + vals[0];
}


#if LONG_DOUBLE_IS_X87_EXTENDED


/** Calculate X + Y exactly and store the result in *HI + *LO; It is given that |X| >= |Y| and the values are small enough that no overflow occurs */
LIB_FUNC void add_split_long_doubles(long double* hi, long double* lo, const long double x, const long double y) {
	*hi = x + y;
	*lo = (x - *hi) + y;
}


/** Calculate X * Y exactly and store the result in *HI + *LO; It is given that the values are small enough that no overflow occurs and large enough (or zero) that no underflow occurs */
LIB_FUNC void mul_split_long_doubles(long double* hi, long double* lo, const long double x, const long double y) {
#ifdef __FP_FAST_FMAL  // Fast built-in fused multiply-add
	*hi = x * y;
	*lo = fmal(x, y, (-*hi));
#else  // Apply Dekker's algorithm
	*hi = x * y;
	long double x1 = x * ((1LL << (LDBL_MANT_DIG + 1) / 2) + 1);
	long double y1 = y * ((1LL << (LDBL_MANT_DIG + 1) / 2) + 1);
	x1 = (x - x1) + x1;
	y1 = (y - y1) + y1;
	const long double x2 = x - x1;
	const long double y2 = y - y1;
	*lo = (((x1 * y1 - *hi) + x1 * y2) + x2 * y1) + x2 * y2;
#endif
}


/** Compare absolute values of floating-point values pointed to by P and Q for qsort */
LIB_FUNC int compare_long_doubles(const void* p, const void* q) {
	const long double pld = fabsl(*(const long double*)p);
	const long double qld = fabsl(*(const long double*)q);
	if (pld < qld) { return -1; }
	else if (pld == qld) { return 0; }
	else { return 1; }
}


/** Return X^2 + Y^2 - 1, computed without large cancellation error; It is given that 1 > X >= Y >= epsilon / 2, and that X^2 + Y^2 >= 0.5 */
LIB_FUNC long double __x2y2m1l(const long double x, const long double y) {
	long double vals[5] = { 0.0L };
	// SET_RESTORE_ROUNDL(FE_TONEAREST);
	mul_split_long_doubles(&vals[1], &vals[0], x, x);
	mul_split_long_doubles(&vals[3], &vals[2], y, y);
	vals[4] = -1.0L;
	qsort(vals, 5, SIZEOF_LONG_DOUBLE, compare_long_doubles);
	for (size_t i = 0; i <= 3; i++) {
		add_split_long_doubles(&vals[i + 1], &vals[i], vals[i + 1], vals[i]);
		qsort(vals + i + 1, 4 - i, SIZEOF_LONG_DOUBLE, compare_long_doubles);
	}
	return vals[4] + vals[3] + vals[2] + vals[1] + vals[0];
}


#elif LONG_DOUBLE_IS_BINARY128


/** Calculate X + Y exactly and store the result in *HI + *LO; It is given that |X| >= |Y| and the values are small enough that no overflow occurs */
LIB_FUNC void add_split_long_doubles(long double* hi, long double* lo, const long double x, const long double y) {
	*hi = x + y;
	*lo = (x - *hi) + y;
}


/** Calculate X * Y exactly and store the result in *HI + *LO; It is given that the values are small enough that no overflow occurs and large enough (or zero) that no underflow occurs */
LIB_FUNC void mul_split_long_doubles(long double* hi, long double* lo, const long double x, const long double y) {
#ifdef __FP_FAST_FMAL  // Fast built-in fused multiply-add
	*hi = x * y;
	*lo = fmal(x, y, (-*hi));
#else  // Apply Dekker's algorithm
	*hi = x * y;
	long double x1 = x * ((1LL << (LDBL_MANT_DIG + 1) / 2) + 1);
	long double y1 = y * ((1LL << (LDBL_MANT_DIG + 1) / 2) + 1);
	x1 = (x - x1) + x1;
	y1 = (y - y1) + y1;
	const long double x2 = x - x1;
	const long double y2 = y - y1;
	*lo = (((x1 * y1 - *hi) + x1 * y2) + x2 * y1) + x2 * y2;
#endif
}


/** Compare absolute values of floating-point values pointed to by P and Q for qsort */
LIB_FUNC int compare_long_doubles(const void* p, const void* q) {
	const long double pld = fabsl(*(const long double*)p);
	const long double qld = fabsl(*(const long double*)q);
	if (pld < qld) { return -1; }
	else if (pld == qld) { return 0; }
	else { return 1; }
}


/** Return X^2 + Y^2 - 1, computed without large cancellation error; It is given that 1 > X >= Y >= epsilon / 2, and that X^2 + Y^2 >= 0.5 */
LIB_FUNC long double __x2y2m1l(const long double x, const long double y) {
	long double vals[5] = { 0.0L };
	// SET_RESTORE_ROUNDL(FE_TONEAREST);
	mul_split_long_doubles(&vals[1], &vals[0], x, x);
	mul_split_long_doubles(&vals[3], &vals[2], y, y);
	vals[4] = -1.0L;
	qsort(vals, 5, SIZEOF_LONG_DOUBLE, compare_long_doubles);
	for (register size_t i = 0; i <= 3; i++) {
		add_split_long_doubles(&vals[i + 1], &vals[i], vals[i + 1], vals[i]);
		qsort((vals + i + 1), (4 - i), SIZEOF_LONG_DOUBLE, compare_long_doubles);
	}
	return vals[4] + vals[3] + vals[2] + vals[1] + vals[0];
}


#elif SUPPORTS_LONG_DOUBLE_128


/** Calculate X + Y exactly and store the result in *HI + *LO It is given that |X| >= |Y| and the values are small enough that no overflow occurs */
LIB_FUNC void add_split_long_doubles(double* hi, double* lo, const double x, const double y) {
	*hi = x + y;
	*lo = (x - *hi) + y;
}


/** Calculate X * Y exactly and store the result in *HI + *LO; It is given that the values are small enough that no overflow occurs and large enough (or zero) that no underflow occurs */
LIB_FUNC void mul_split_long_doubles(double* hi, double* lo, const double x, const double y) {
#ifdef __FP_FAST_FMA  // Fast built-in fused multiply-add
	*hi = x * y;
	*lo = fma(x, y, (-*hi));
#else  // Apply Dekker's algorithm
	*hi = x * y;
	double x1 = x * ((1 << (DBL_MANT_DIG + 1) / 2) + 1);
	double y1 = y * ((1 << (DBL_MANT_DIG + 1) / 2) + 1);
	x1 = (x - x1) + x1;
	y1 = (y - y1) + y1;
	const double x2 = x - x1;
	const double y2 = y - y1;
	*lo = (((x1 * y1 - *hi) + x1 * y2) + x2 * y1) + x2 * y2;
#endif
}


/** Compare absolute values of floating-point values pointed to by P and Q for qsort */
LIB_FUNC int compare_long_doubles(const void* p, const void* q) {
	const double pd = fabs(*(const double*)p);
	const double qd = fabs(*(const double*)q);
	if (pd < qd) { return -1; }
	else if (pd == qd) { return 0; }
	else { return 1; }
}


/** Return X^2 + Y^2 - 1, computed without large cancellation error; It is given that 1 > X >= Y >= epsilon / 2, and that X^2 + Y^2 >= 0.5 */
LIB_FUNC long double __x2y2m1l(const long double x, const long double y) {
	double vals[13] = { 0.0L };
	// SET_RESTORE_ROUND(FE_TONEAREST);
	union ibm_extended_long_double xu, yu;
	xu.ld = x;
	yu.ld = y;
	if (fabs(xu.d[1].d) < 0x1p-500) { xu.d[1].d = 0.0; }
	if (fabs(yu.d[1].d) < 0x1p-500) { yu.d[1].d = 0.0; }
	mul_split_long_doubles(&vals[1], &vals[0], xu.d[0].d, xu.d[0].d);
	mul_split_long_doubles(&vals[3], &vals[2], xu.d[0].d, xu.d[1].d);
	vals[2] *= 2.0;
	vals[3] *= 2.0;
	mul_split_long_doubles(&vals[5], &vals[4], xu.d[1].d, xu.d[1].d);
	mul_split_long_doubles(&vals[7], &vals[6], yu.d[0].d, yu.d[0].d);
	mul_split_long_doubles(&vals[9], &vals[8], yu.d[0].d, yu.d[1].d);
	vals[8] *= 2.0;
	vals[9] *= 2.0;
	mul_split_long_doubles(&vals[11], &vals[10], yu.d[1].d, yu.d[1].d);
	vals[12] = -1.0;
	qsort(vals, 13, SIZEOF_DOUBLE, compare_long_doubles);
	for (size_t i = 0; i <= 11; i++) {
		add_split_long_doubles(&vals[i + 1], &vals[i], vals[i + 1], vals[i]);
		qsort(vals + i + 1, 12 - i, SIZEOF_DOUBLE, compare_long_doubles);
	}
	long double retval = (long double)vals[12];
	for (size_t i = 11; i != (size_t)-1; i--) { retval += (long double)vals[i]; }
	return retval;
}


#endif


/** Return the sum of division and modulus of the two given numbers */
LIB_FUNC int div_and_mod_int(const int num1, const int num2) {
	return (((num1 / num2) + (num1 % num2)));
}


/** Return the sum of division and modulus of the two given numbers */
LIB_FUNC double div_and_mod(const double num1, const double num2) {
	return (((num1 / num2) + fmod(num1, num2)));
}


/** Return the sum of division and modulus of the two given numbers */
LIB_FUNC float div_and_modf(const float num1, const float num2) {
	return (((num1 / num2) + fmodf(num1, num2)));
}


/** Return the Lanczos Sum for the given number */
LIB_FUNC double lanczos_sum(const double x) {
	register double num = 0.0, den = 0.0;
	if (!(x > 0.0)) { return 0.0; }
	register int i;
	if (x < 5.0) {
		for (i = 13; --i >= 0;) {
			num = ((num * x) + LANCZOS_NUM_COEFFS[i]);
			den = ((den * x) + LANCZOS_DEN_COEFFS[i]);
		}
	} else {
		for (i = 0; i < 13; i++) {
			num = ((num / x) + LANCZOS_NUM_COEFFS[i]);
			den = ((den / x) + LANCZOS_DEN_COEFFS[i]);
		}
	}
	return (num / den);
}


/** Dot Product Algorithm (Array of 32-bit integers) */
LIB_FUNC void dot_product32(const int32_t* restrict _array1, const int32_t* restrict _array2, int32_t* output_array, const size_t _length) {
	register uint32_t i;
	output_array = 0;
	for (i = 0; i < _length; i++) { output_array += _array1[i] * _array2[i]; }
}


/** Dot Product Algorithm (Array of 64-bit integers) */
LIB_FUNC void dot_product64(const int64_t* restrict _array1, const int64_t* restrict _array2, int64_t* output_array, const size_t _length) {
	register uint64_t i;
	output_array = 0;
	for (i = 0; i < _length; i++) { output_array += _array1[i] * _array2[i]; }
}


#endif  // MATH_H


/* COMPLEX/IMAGINARY MATH FUNCTIONS (<complex.h>) */


#if ((!(defined(COMPLEX_H) || defined(_COMPLEX_H) || defined(_COMPLEX_H_))) && SUPPORTS_COMPLEX)  // http://www.cplusplus.com/reference/complex/ & http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/complex.h.html
#define COMPLEX_H   (1)
#define _COMPLEX_H   (1)
#define _COMPLEX_H_   (1)
#define COMPLEX_INTERNAL_H_   (1)
#define __GSL_COMPLEX_MATH_H__   (1)
#define _XCOMPLEX_H_   (1)
#define _XREAL_H_   (1)


#if (!(defined(_DCOMPLEX_H) || defined(__SUPERLU_DCOMPLEX)))
#define _DCOMPLEX_H   (1)
#define __SUPERLU_DCOMPLEX   (1)


typedef struct doublecomplex { double r, i; } doublecomplex;


/** Complex Addition c = a + b */
#define z_add(c, a, b)   do { (c)->r = (a)->r + (b)->r; (c)->i = (a)->i + (b)->i; } while (0x0)
/** Complex Subtraction c = a - b */
#define z_sub(c, a, b)   do { (c)->r = (a)->r - (b)->r; (c)->i = (a)->i - (b)->i; } while (0x0)
/** Complex-Double Multiplication */
#define zd_mult(c, a, b)   do { (c)->r = (a)->r * (b); (c)->i = (a)->i * (b); } while (0x0)
/** Complex-Complex Multiplication */
#define zz_mult(c, a, b)   do { double cr, ci; cr = (a)->r * (b)->r - (a)->i * (b)->i; ci = (a)->i * (b)->r + (a)->r * (b)->i; (c)->r = cr; (c)->i = ci; } while (0x0)
/** Complex equality testing */
#define z_eq(a, b)   ((a)->r == (b)->r && (a)->i == (b)->i)


/** Complex Division */
LIB_FUNC void z_div(doublecomplex* c, doublecomplex* a, doublecomplex* b) {
	double ratio, den, abr, abi, cr, ci;
	if ((abr = b->r) < 0.0) { abr = - abr; }
	if ((abi = b->i) < 0.0) { abi = - abi; }
	if (abr <= abi ) {
		if (abi == 0) { fprintf(stderr, "z_div.c: division by zero"); exit(-1); }
		ratio = b->r / b->i ;
		den = b->i * (1 + ratio * ratio);
		cr = (a->r * ratio + a->i) / den;
		ci = (a->i * ratio - a->r) / den;
	} else {
		ratio = b->i / b->r ;
		den = b->r * (1 + ratio * ratio);
		cr = (a->r + a->i * ratio) / den;
		ci = (a->i - a->r * ratio) / den;
	}
	c->r = cr;
	c->i = ci;
}


/** Returns sqrt(z.r^2 + z.i^2) */
LIB_FUNC double z_abs(doublecomplex* z) {
	double temp, real = z->r, imag = z->i;
	if (real < 0) { real = -real; }
	if (imag < 0) { imag = -imag; }
	if (imag > real) {
		temp = real;
		real = imag;
		imag = temp;
	}
	if ((real + imag) == real) { return real; }
	temp = imag / real;
	return (double)(real * sqrt(1.0 + temp * temp));
}


/** Approximate abs */
LIB_FUNC double z_abs1(doublecomplex* z) {
	double real = z->r, imag = z->i;
	if (real < 0) { real = -real; }
	if (imag < 0) { imag = -imag; }
	return (real + imag);
}


/** Return the exponentiation */
LIB_FUNC void z_exp(doublecomplex* r, doublecomplex* z) {
	const double expx = exp(z->r);
	r->r = expx * cos(z->i);
	r->i = expx * sin(z->i);
}


/** Return the complex conjugate */
LIB_FUNC void d_cnjg(doublecomplex* r, doublecomplex* z) {
	r->r = z->r;
	r->i = -z->i;
}


/** Return the imaginary part */
LIB_FUNC double d_imag(doublecomplex* z) {
	return (double)(z->i);
}


#endif  // DCOMPLEX_H


#define REAL_PART(z)   ((z).parts[0])
#define GET_REAL_PART(z)   ((z).parts[0])
#define IMAG_PART(z)   ((z).parts[1])
#define GET_IMAG_PART(z)   ((z).parts[1])


LIB_FUNC float cimagf(const float complex z) {
	float_complex w = { .z = z };
	return IMAG_PART(w);
}


LIB_FUNC double cimag(const double complex z) {
	double_complex w = { .z = z };
	return IMAG_PART(w);
}


LIB_FUNC long double cimagl(const long double complex z) {
	long_double_complex w = { .z = z };
	return IMAG_PART(w);
}


LIB_FUNC float crealf(const float complex z) {
	float_complex w = { .z = z };
	return REAL_PART(w);
}


LIB_FUNC double creal(const double complex z) {
	double_complex w = { .z = z };
	return REAL_PART(w);
}


LIB_FUNC long double creall(const long double complex z) {
	long_double_complex w = { .z = z };
	return REAL_PART(w);
}


#ifndef normf
/** Return the norm value of the complex number */
LIB_FUNC float normf(const float complex x) {
	register const float real = crealf(x);
	register const float vector = cimagf(x);
	return sqrtf((real * real) + (vector * vector));
}
#endif


#ifndef norm
/** Return the norm value of the complex number */
LIB_FUNC double norm(const double complex x) {
	register const double real = creal(x);
	register const double vector = cimag(x);
	return sqrt((real * real) + (vector * vector));
}
#endif


#ifndef norml
/** Return the norm value of the complex number */
LIB_FUNC long double norml(const long double complex x) {
	register const long double real = creall(x);
	register const long double vector = cimagl(x);
	return sqrtl((real * real) + (vector * vector));
}
#endif


LIB_FUNC float cargf(const float complex z) {
	return atan2f(cimagf(z), crealf(z));
}


LIB_FUNC double carg(const double complex z) {
	return atan2(cimag(z), creal(z));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double cargl(const long double complex z) {
	return carg(z);
}
#else
LIB_FUNC long double cargl(const long double complex z) {
	return atan2l(cimagl(z), creall(z));
}
#endif


LIB_FUNC float cabsf(const float complex z) {
	return hypotf(crealf(z), cimagf(z));
}
#define c_absf(z)   cabsf((z))


LIB_FUNC double cabs(const double complex z) {
	return hypot(creal(z), cimag(z));
}
#define c_abs(z)   cabs((z))


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double cabsl(const long double complex z) {
	return (long double)cabs(z);
}
#else
LIB_FUNC long double cabsl(const long double complex z) {
	return hypotl(creall(z), cimagl(z));
}
#endif
#define c_absl(z)   cabsl((z))


LIB_FUNC float complex conjf(const float complex z) {
	return CMPLXF(crealf(z), -cimagf(z));
}


LIB_FUNC double complex conj(const double complex z) {
	return CMPLX(creal(z), -cimag(z));
}


LIB_FUNC long double complex conjl(const long double complex z) {
	return CMPLXL(creall(z), -cimagl(z));
}


/** Return the conjugate of a complex number */
LIB_FUNC float complex conjugatef(const float complex num) {
	return (crealf(num) + cimagf(num * -1.0F) * I_FLOAT);
}


/** Return the conjugate of a complex number */
LIB_FUNC double complex conjugate(const double complex num) {
	return (creal(num) + cimag(num * -1.0) * I_DOUBLE);
}


/** Return the conjugate of a complex number */
LIB_FUNC long double complex conjugatel(const long double complex num) {
	return (creall(num) + cimagl(num * -1.0L) * I_LONG_DOUBLE);
}


LIB_FUNC float complex cprojf(const float complex z) {
	if (__isinff(crealf(z)) || __isinff(cimagf(z))) {
		return CMPLXF(INFINITY, (copysignf(0.0F, crealf(z))));
	}
	return z;
}


LIB_FUNC double complex cproj(const double complex z) {
	if (__isinf(creal(z)) || __isinf(cimag(z))) {
		return CMPLX(INFINITY, (copysign(0.0, creal(z))));
	}
	return z;
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex cprojl(const long double complex z) {
	return cproj(z);
}
#else
LIB_FUNC long double complex cprojl(const long double complex z) {
	if (__isinfl(creall(z)) || __isinfl(cimagl(z))) {
		return CMPLXL(INFINITY, (copysignl(0.0L, creall(z))));
	}
	return z;
}
#endif


LIB_FUNC long double Complex __multc3(long double a, long double b, long double c, long double d) {
	long double ac = a * c, bd = b * d;
	long double ad = a * d, bc = b * c;
	long double x = ac - bd, y = ad + bc;
	if (isnanl(x) && isnanl(y)) {
		register bool recalc = 0;
		if (isinfl(a) || isinfl(b)) {
			a = copysignl(isinfl(a) ? 1 : 0, a);
			b = copysignl(isinfl(b) ? 1 : 0, b);
			if (isnanl(c)) { c = copysignl(0, c); }
			if (isnanl(d)) { d = copysignl(0, d); }
			recalc = 1;
		}
		if (isinfl(c) || isinfl(d)) {
			c = copysignl(isinfl(c) ? 1 : 0, c);
			d = copysignl(isinfl(d) ? 1 : 0, d);
			if (isnanl(a)) { a = copysignl(0, a); }
			if (isnanl(b)) { b = copysignl(0, b); }
			recalc = 1;
		}
		if ((!recalc) && (isinfl(ac) || isinfl(bd) || isinfl(ad) || isinfl(bc))) {
			if (isnanl(a)) { a = copysignl(0, a); }
			if (isnanl(b)) { b = copysignl(0, b); }
			if (isnanl(c)) { c = copysignl(0, c); }
			if (isnanl(d)) { d = copysignl(0, d); }
			recalc = 1;
		}
		if (recalc) { x = INFINITY * (a * c - b * d); }
		y = INFINITY * (a * d + b * c);
	}
	return x + I * y;
}


LIB_FUNC long double complex __divtc3(long double a, long double b, long double c, long double d) {
	long double denom, ratio, x, y;
	if (fabsl(c) < fabsl(d)) {
		ratio = c / d;
		denom = (c * ratio) + d;
		x = ((a * ratio) + b) / denom;
		y = ((b * ratio) - a) / denom;
	} else {
		ratio = d / c;
		denom = (d * ratio) + c;
		x = ((b * ratio) + a) / denom;
		y = (b - (a * ratio)) / denom;
	}
	if (isnanl(x) && isnanl(y)) {
		if (denom == 0.0 && (!isnanl(a) || !isnanl(b))) {
			x = copysignl(INFINITY, c) * a;
			y = copysignl(INFINITY, c) * b;
		} else if ((isinfl(a) || isinfl(b)) && isfinitel(c) && isfinitel(d)) {
			a = copysignl(isinfl(a) ? 1 : 0, a);
			b = copysignl(isinfl(b) ? 1 : 0, b);
			x = INFINITY * (a * c + b * d);
			y = INFINITY * (b * c - a * d);
		} else if ((isinfl(c) || isinfl(d)) && isfinitel(a) && isfinitel(b)) {
			c = copysignl(isinfl(c) ? 1 : 0, c);
			d = copysignl(isinfl(d) ? 1 : 0, d);
			x = 0.0 * (a * c + b * d);
			y = 0.0 * (b * c - a * d);
		}
	}
	return (x + I * y);
}


LIB_FUNC void cmul(const double c1, const double c2, const double d1, const double d2, double* e1, double* e2) {
	*e1 = c1 * d1 - c2 * d2;
	*e2 = c1 * d2 + c2 * d1;
}


LIB_FUNC void csq(const double c1, const double c2, double* e1, double* e2) {
	*e1 = c1 * c1 - c2 * c2;
	*e2 = c1 * c2 * 2;
}


/** Compute exp(x), scaled to avoid spurious overflow; An exponent is returned separately in 'expt'
* @Input: ln(FLT_MAX) <= x < ln(2 * FLT_MAX / FLT_MIN_DENORM) ~= 192.7
* @Output: 2**127 <= y < 2**128
*/
LIB_FUNC float __frexp_expf(const float x, int* expt) {
	float exp_x;
	uint32_t hx;
	exp_x = expf(x - 162.88958740F);
	GET_FLOAT_UWORD(hx, exp_x);
	*expt = (int)((int)(hx >> 23) - (0x7f + 127) + 235);
	SET_FLOAT_WORD(exp_x, (int)((int)(hx & 0x7fffff) | ((0x7f + 127) << 23)));
	return exp_x;
}


LIB_FUNC float complex __ldexp_cexpf(const float complex z, int expt) {
	const float x = crealf(z), y = cimagf(z);
	float exp_x, scale1, scale2;
	int ex_expt, half_expt;
	exp_x = __frexp_expf(x, &ex_expt);
	expt += ex_expt;
	half_expt = expt / 2;
	SET_FLOAT_WORD(scale1, ((0x7f + half_expt) << 23));
	half_expt = expt - half_expt;
	SET_FLOAT_WORD(scale2, ((0x7f + half_expt) << 23));
	return CMPLXF((cosf(y) * exp_x * scale1 * scale2), (sinf(y) * exp_x * scale1 * scale2));
}


LIB_FUNC float complex _cexpf(const float complex z) {
	const float x = crealf(z), y = cimagf(z);
	float exp_x;
	uint32_t hx, hy;
	GET_FLOAT_UWORD(hy, y);
	hy &= 0x7fffffff;
	if (hy == 0) { return CMPLXF(expf(x), y); }
	GET_FLOAT_UWORD(hx, x);
	if ((hx & 0x7fffffff) == 0) { return CMPLXF(cosf(y), sinf(y)); }
	else if (hy >= 0x7f800000) {
		if ((hx & 0x7fffffff) != 0x7f800000) {  // cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN
			return CMPLXF(y - y, y - y);
		} else if (hx & 0x80000000) {  // cexp(-Inf +- I Inf|NaN) = 0 + I 0
			return CMPLXF(0.0, 0.0);
		} else {  // cexp(+Inf +- I Inf|NaN) = Inf + I NaN
			return CMPLXF(x, y - y);
		}
	} else if (hx >= 0x42b17218 && hx <= 0x43400074) {
		// x is between 88.7 and 192, so we must scale to avoid overflow in expf(x)
		return __ldexp_cexpf(z, 0);
	} else {
		/* Cases covered here:
		 * - x < exp_ovfl and exp(x) will not overflow (common case)
		 * - x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 * - x = +-Inf (generated by exp())
		 * - x = NaN (spurious inexact exception from y) */
		exp_x = expf(x);
		return CMPLXF((exp_x * cosf(y)), (exp_x * sinf(y)));
	}
}


/** Compute exp(x), scaled to avoid spurious overflow; An exponent is returned separately in 'expt'
* @Input: ln(DBL_MAX) <= x < ln(2 * DBL_MAX / DBL_MIN_DENORM) ~= 1454.91
* @Output: 2**1023 <= y < 2**1024
*/
LIB_FUNC double __frexp_exp(const double x, int* expt) {
	double exp_x;
	uint32_t hx;
	exp_x = exp(x - 1246.97177782734161156);
	GET_HIGH_WORD(hx, exp_x);
	*expt = (int)((int)(hx >> 20) - (0x3ff + 1023) + 1799);
	SET_HIGH_WORD(exp_x, (int)((hx & 0xfffff) | ((0x3ff + 1023) << 20)));
	return exp_x;
}


/** Intended for large arguments (real part >= ln(DBL_MAX)) where care is needed to avoid overflow */
LIB_FUNC double complex __ldexp_cexp(const double complex z, int expt) {
	double x = creal(z), y = cimag(z), exp_x, scale1, scale2;
	int ex_expt, half_expt;
	exp_x = __frexp_exp(x, &ex_expt);
	expt += ex_expt;
	half_expt = expt / 2;
	INSERT_WORDS(scale1, (uint32_t)((0x3ff + half_expt) << 20), 0);
	half_expt = expt - half_expt;
	INSERT_WORDS(scale2, (uint32_t)((0x3ff + half_expt) << 20), 0);
	return CMPLX((cos(y) * exp_x * scale1 * scale2), (sin(y) * exp_x * scale1 * scale2));
}


LIB_FUNC double complex _cexp(const double complex z) {
	const double x = creal(z), y = cimag(z);
	double exp_x;
	uint32_t hx, hy, lx, ly;
	EXTRACT_WORDS(hy, ly, y);
	hy &= 0x7fffffff;
	if ((hy | ly) == 0) { return CMPLX(exp(x), y); }
	EXTRACT_WORDS(hx, lx, x);
	if (((hx & 0x7fffffff) | lx) == 0) { return CMPLX(cos(y), sin(y)); }
	else if (hy >= 0x7ff00000) {
		if (lx != 0 || (hx & 0x7fffffff) != 0x7ff00000) {  // cexp(finite|NaN +- I Inf|NaN) = NaN + I NaN
			return CMPLX(y - y, y - y);
		} else if (hx & 0x80000000) {  // cexp(-Inf +- I Inf|NaN) = 0 + I 0
			return CMPLX(0.0, 0.0);
		} else {  // cexp(+Inf +- I Inf|NaN) = Inf + I NaN
			return CMPLX(x, y - y);
		}
	} else if (hx >= (uint32_t)0x40862e42 && hx <= (uint32_t)0x4096b8e4) {
		// x is between 709.7 and 1454.3, so we must scale to avoid overflow in exp(x)
		return __ldexp_cexp(z, 0);
	} else {
		/* Cases covered here:
		 * - x < exp_ovfl and exp(x) will not overflow (common case)
		 * - x > cexp_ovfl, so exp(x) * s overflows for all s > 0
		 * - x = +-Inf (generated by exp())
		 * - x = NaN (spurious inexact exception from y) */
		exp_x = exp(x);
		return CMPLX((exp_x * cos(y)), (exp_x * sin(y)));
	}
}


LIB_FUNC float complex cexpf(const float complex z) {
	const float x = crealf(z), y = cimagf(z), r = expf(x);
	return CMPLXF(r * cosf(y), r * sinf(y));
}


LIB_FUNC double complex cexp(const double complex z) {
	const double x = creal(z), y = cimag(z), r = exp(x);
	return (double complex)(r * cos(y) + r * sin(y) * I);
}


LIB_FUNC long double complex cexpl(const long double complex z) {
	const long double x = creall(z), y = cimagl(z), r = expl(x);
	return (long double complex)(r * cosl(y) + r * sinl(y) * I);
}


// COMPLEX LOGARITHM FUNCTIONS

LIB_FUNC float complex clogf(const float complex z) {
	const float r = cabsf(z), phi = cargf(z);
	return CMPLXF(logf(r), phi);
}


LIB_FUNC double complex clog(const double complex z) {
	const double r = cabs(z), phi = carg(z);
	return CMPLX(log(r), phi);
}


LIB_FUNC long double complex clogl(const long double complex z) {
	const long double p = logl(cabsl(z));
	register long double rr = atan2l(cimagl(z), creall(z));
	return (long double complex)(p + rr * I);
}


LIB_FUNC float complex clog10f(const float complex z) {
	const float p = log10f(cabsf(z));
	float rr = atan2f(cimagf(z), crealf(z)) * M_IVLN10F;
	return CMPLXF(p, rr);
}


LIB_FUNC double complex clog10(const double complex z) {
	const double p = log10(cabs(z));
	double rr = atan2(cimag(z), creal(z)) * M_IVLN10;
	return (double complex)(p + rr * I);
}


// COMPLEX POWER FUNCTIONS

LIB_FUNC float complex cpowf(const float complex z, const float complex c) {
	return cexpf(c * clogf(z));
}


LIB_FUNC double complex cpow(const double complex z, const double complex c) {
	return cexp(c * clog(z));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex cpowl(const long double complex z, const long double complex c) {
	return cpow(z, c);
}
#else
LIB_FUNC long double complex cpowl(const long double complex z, const long double complex c) {
	return cexpl(c * clogl(z));
}
#endif


// COMPLEX SQUAREROOT FUNCTIONS

LIB_FUNC float complex csqrtf(const float complex z) {
	const float a = crealf(z), b = cimagf(z);
	double t;
	if (z == 0) { return CMPLXF(0, b); }
	else if (isinff(b)) { return CMPLXF(INFINITY, b); }
	else if (isnanf(a)) {
		t = (b - b) / (b - b);  // Raise invalid if b is not a NaN
		return CMPLXF(a, t);  // Return NaN + NaN i
	} else if (isinff(a)) {
		/* csqrtf(inf + NaN i) = inf + NaN i
		 * csqrtf(inf + y i) = inf + 0 i
		 * csqrtf(-inf + NaN i) = NaN +- inf i
		 * csqrtf(-inf + y i) = 0 + inf i */
		if (signbit(a)) { return CMPLXF(fabsf(b - b), copysignf(a, b)); }
		else { return CMPLXF(a, copysignf(b - b, b)); }
	}
	if (a >= 0) {
		t = sqrt((((double)a) + hypot((double)a, (double)b)) * 0.5);
		return CMPLXF((float)t, (b / (float)(2.0 * t)));
	} else {
		t = sqrt(((((double)-a) + hypot((double)a, (double)b)) * 0.5));
		return CMPLXF(fabsf(b) / (float)(2.0 * t), copysignf((float)t, b));
	}
}


LIB_FUNC double complex csqrt(const double complex z) {
	double complex result;
	double a = creal(z), b = cimag(z), t;
	if (z == 0) { return CMPLX(0, b); }
	else if (__isinf(b)) { return CMPLX(INFINITY, b); }
	else if (__isnan(a)) {
		t = (b - b) / (b - b);  // Raise invalid if b is not a NaN
		return CMPLX(a, t);  // Return NaN + NaN i
	} else if (__isinf(a)) {
		/* csqrt(inf + NaN i) = inf + NaN i
		 * csqrt(inf + y i) = inf + 0 i
		 * csqrt(-inf + NaN i) = NaN +- inf i
		 * csqrt(-inf + y i) = 0 + inf i */
		if (signbit(a)) { return CMPLX(fabs(b - b), copysign(a, b)); }
		else { return CMPLX(a, copysign(b - b, b)); }
	}
	register int scale;
	if (fabs(a) >= 0x1.a827999fcef32p+1022 || fabs(b) >= 0x1.a827999fcef32p+1022) {
		a *= 0.25;
		b *= 0.25;
		scale = 1;
	} else { scale = 0; }
	if (a >= 0) {
		t = sqrt((a + hypot(a, b)) * 0.5);
		result = CMPLX(t, b / (2 * t));
	} else {
		t = sqrt((-a + hypot(a, b)) * 0.5);
		result = CMPLX(fabs(b) / (2 * t), copysign(t, b));
	}
	if (scale) { result *= 2; }
	return result;
}


#if SUPPORTS_LONG_DOUBLE
LIB_FUNC long double complex csqrtl(const long double complex z) {
	return csqrt(z);
}
#endif


// COMPLEX TRIGONOMETRY FUNCTIONS

LIB_FUNC float complex casinf(const float complex z) {
	const float x = crealf(z), y = cimagf(z);
	float complex w = CMPLXF((1.0F - (x - y) * (x + y)), (-2.0F * x * y));
	return clogf(CMPLXF(-y, x) + csqrtf(w));
}


LIB_FUNC double complex casin(const double complex z) {
	const double x = creal(z), y = cimag(z);
	double complex w = CMPLX((1.0 - (x - y) * (x + y)), (-2.0 * x * y));
	return clog(CMPLX(-y, x) + csqrt(w));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex casinl(const long double complex z) {
	return (long double complex)casin((double complex)z);
}
#else
LIB_FUNC long double complex casinl(const long double complex z) {
	const long double x = creall(z), y = cimagl(z);
	long double complex w = CMPLXL((1.0 - (x - y) * (x + y)), (-2.0 * x * y));
	return clogl(CMPLXL(-y, x) + csqrtl(w));
}
#endif


LIB_FUNC float complex cacosf(const float complex z) {
	const float complex y = casinf(z);
	return CMPLXF(((float)M_PI_2 - crealf(y)), -cimagf(y));
}


LIB_FUNC double complex cacos(const double complex z) {
	const double complex y = casin(z);
	return CMPLX(M_PI_2 - creal(y), -cimag(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex cacosl(const long double complex z) {
	return cacos(z);
}
#else
LIB_FUNC long double complex cacosl(const long double complex z) {
	const long double complex y = casinl(z);
	return CMPLXL((1.57079632679489661923132169163975144L - creall(y)), -cimagl(y));
}
#endif


LIB_FUNC float complex cacoshf(const float complex z) {
	const float complex y = cacosf(z);
	return CMPLXF(-cimagf(y), crealf(y));
}


LIB_FUNC double complex cacosh(const double complex z) {
	const double complex y = cacos(z);
	return CMPLX(-cimag(y), creal(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex cacoshl(const long double complex z) {
	return (long double complex)cacosh((double complex)z);
}
#else
LIB_FUNC long double complex cacoshl(const long double complex z) {
	const long double complex y = cacosl(z);
	return CMPLXL(-cimagl(y), creall(y));
}
#endif


LIB_FUNC float complex casinhf(const float complex z) {
	const float complex y = casinf(CMPLXF(-cimagf(z), crealf(z)));
	return CMPLXF(cimagf(y), -crealf(y));
}


LIB_FUNC double complex casinh(const double complex z) {
	const double complex y = casin(CMPLX(-cimag(z), creal(z)));
	return CMPLX(cimag(y), -creal(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex casinhl(const long double complex z) {
	return (long double complex)casinh((double complex)z);
}
#else
LIB_FUNC long double complex casinhl(const long double complex z) {
	const long double complex y = casinl(CMPLXL(-cimagl(z), creall(z)));
	return CMPLXL(cimagl(y), -creall(y));
}
#endif


LIB_FUNC float _redupif(const float x) {
	register float t = x / (float)M_PI;
	if (t >= 0.0F) { t += 0.5F; }
	else { t -= 0.5F; }
	const long i = (long)t;
	t = (float)i;
	t = ((x - t * 3.140625F) - t * 9.67502593994140625E-4F) - t * 1.509957990978376432E-7F;
	return t;
}
#define redupif(x)   _redupif((x))
#define __redupif(x)   _redupif((x))


LIB_FUNC float complex catanf(const float complex z) {
	float complex w;
	const float x = crealf(z), y = cimagf(z);
	const float x2 = x * x;
	float t, a = (float)(1.0F - x2 - (y * y));
	if (((x == 0.0F) && (y > 1.0F)) || (a == 0.0F)) { goto catanf_ovrf; }
	t = 0.5F * atan2f(2.0F * x, a);
	w = _redupif(t);
	t = y - 1.0F;
	a = x2 + (t * t);
	if (a == 0.0F) { goto catanf_ovrf; }
	t = y + 1.0F;
	a = (x2 + (t * t)) / a;
	w = CMPLXF(w, (0.25F * logf(a)));
	return w;
catanf_ovrf:
	w = CMPLXF(1.0e38F, 1.0e38F);
	return w;
}


LIB_FUNC double _redupi(const double x) {
	double t;
	register long i;
	t = x / M_PI;
	if (t >= 0.0) { t += 0.5; }
	else { t -= 0.5; }
	i = (long)t;
	t = (double)i;
	t = ((x - t * 3.14159265160560607910E0) - t * 1.98418714791870343106E-9) - t * 1.14423774522196636802E-17;
	return t;
}


LIB_FUNC double complex catan(const double complex z) {
	double complex w;
	const double x = creal(z), y = cimag(z);
	const double x2 = x * x;
	double t, a = 1.0 - x2 - (y * y);
	if ((x == 0.0 && y > 1.0) || (a == 0.0)) { goto catan_ovrf; }
	t = 0.5 * atan2(2.0 * x, a);
	w = _redupi(t);
	t = y - 1.0;
	a = x2 + (t * t);
	if (a == 0.0) { goto catan_ovrf; }
	t = y + 1.0;
	a = (x2 + t * t) / a;
	w = CMPLX(w, (0.25 * log(a)));
	return w;
catan_ovrf:
	w = CMPLX(1.0e308, 1.0e308);
	return w;
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex catanl(const long double complex z) {
	return catan(z);
}
#else
LIB_FUNC long double redupil(const long double x) {
	long double t = x / 3.141592653589793238462643383279502884197169L;
	if (t >= 0.0L) { t += 0.5L; }
	else { t -= 0.5L; }
	const long i = (long)t;
	t = (long double)i;
	t = ((x - t * 3.14159265358979323829596852490908531763125L) - t * 1.6667485837041756656403424829301998703007e-19L) - t * 1.8830410776607851167459095484560349402753e-39L;
	return t;
}


LIB_FUNC long double complex catanl(const long double complex z) {
	long double complex w;
	const long double x = creall(z), y = cimagl(z);
	const long double x2 = x * x;
	long double t, a = 1.0L - x2 - (y * y);
	if (((x == 0.0L) && (y > 1.0L)) || (a == 0.0L)) { goto catanl_ovrf; }
	t = atan2l(2.0L * x, a) * 0.5L;
	w = redupil(t);
	t = y - 1.0L;
	a = x2 + (t * t);
	if (a == 0.0L) { goto catanl_ovrf; }
	t = y + 1.0L;
	a = (x2 + (t * t)) / a;
	w = CMPLXL(w, (0.25L * logl(a)));
	return w;
catanl_ovrf:
	w = CMPLXL(LDBL_MAX, LDBL_MAX);
	return w;
}
#endif


LIB_FUNC float complex catanhf(const float complex z) {
	const float complex y = catanf(CMPLXF(-cimagf(z), crealf(z)));
	return CMPLXF(cimagf(y), -crealf(y));
}


LIB_FUNC double complex catanh(const double complex z) {
	const double complex y = catan(CMPLX(-cimag(z), creal(z)));
	return CMPLX(cimag(y), -creal(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex catanhl(const long double complex z) {
	return catanh(z);
}
#else
LIB_FUNC long double complex catanhl(const long double complex z) {
	const long double complex y = catanl(CMPLXL(-cimagl(z), creall(z)));
	return CMPLXL(cimagl(y), -creall(y));
}
#endif


LIB_FUNC float complex ccoshf(const float complex num) {
	float complex z = num;
	float x = crealf(z), y = cimagf(z), h;
	int32_t hx, hy, ix, iy;
	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	ix = 0x7fffffff & hx;
	iy = 0x7fffffff & hy;
	if (ix < 0x7f800000 && iy < 0x7f800000) {
		if (iy == 0) { return CMPLXF(coshf(x), x * y); }
		else if (ix < 0x41100000) { return CMPLXF(coshf(x) * cosf(y), sinhf(x) * sinf(y)); }
		else if (ix < 0x42b17218) {
			h = expf(fabsf(x)) * 0.5f;
			return CMPLXF(h * cosf(y), copysignf(h, x) * sinf(y));
		} else if (ix < 0x4340b1e7) {
			z = __ldexp_cexpf(CMPLXF(fabsf(x), y), -1);
			return CMPLXF(crealf(z), cimagf(z) * copysignf(1, x));
		} else {
			h = (float)(0x1p127F * x);
			return CMPLXF(h * h * cosf(y), h * sinf(y));
		}
	}
	if (ix == 0 && iy >= 0x7f800000) { return CMPLXF(y - y, copysignf(0, x * (y - y))); }
	else if (iy == 0 && ix >= 0x7f800000) {
		if ((hx & 0x7fffff) == 0) { return CMPLXF(x * x, copysignf(0, x) * y); }
		return CMPLXF(x * x, copysignf(0, (x + x) * y));
	}
	else if (ix < 0x7f800000 && iy >= 0x7f800000) { return CMPLXF(y - y, x * (y - y)); }
	else if (ix >= 0x7f800000 && (hx & 0x7fffff) == 0) {
		if (iy >= 0x7f800000) { return CMPLXF(x * x, x * (y - y)); }
		return CMPLXF((x * x) * cosf(y), x * sinf(y));
	}
	return CMPLXF(((x * x) * (y - y)), ((x + x) * (y - y)));
}


LIB_FUNC double complex ccosh(const double complex num) {
	double complex z = num;
	const double x = creal(z), y = cimag(z);
	double h;
	int32_t hx, hy, ix, iy, lx, ly;
	EXTRACT_SWORDS(hx, lx, x);
	EXTRACT_SWORDS(hy, ly, y);
	ix = 0x7fffffff & hx;
	iy = 0x7fffffff & hy;
	if (ix < 0x7ff00000 && iy < 0x7ff00000) {
		if ((iy | ly) == 0) { return CMPLX(cosh(x), x * y); }
		else if (ix < 0x40360000) { return CMPLX(cosh(x) * cos(y), sinh(x) * sin(y)); }
		else if (ix < 0x40862e42) {
			h = exp(fabs(x)) * 0.5;
			return CMPLX(h * cos(y), copysign(h, x) * sin(y));
		} else if (ix < 0x4096bbaa) {
			z = __ldexp_cexp(CMPLX(fabs(x), y), -1);
			return CMPLX(creal(z), cimag(z) * copysign(1, x));
		} else {
			h = (double)((double)0x1p1023 * x);
			return CMPLX(h * h * cos(y), h * sin(y));
		}
	}
	if ((ix | lx) == 0 && iy >= 0x7ff00000) { return CMPLX(y - y, copysign(0, x * (y - y))); }
	else if ((iy | ly) == 0 && ix >= 0x7ff00000) {
		if (((hx & 0xfffff) | lx) == 0) { return CMPLX(x * x, copysign(0, x) * y); }
		return CMPLX(x * x, copysign(0, (x + x) * y));
	}
	else if (ix < 0x7ff00000 && iy >= 0x7ff00000) { return CMPLX(y - y, x * (y - y)); }
	else if (ix >= 0x7ff00000 && ((hx & 0xfffff) | lx) == 0) {
		if (iy >= 0x7ff00000) { return CMPLX(x * x, x * (y - y)); }
		return CMPLX((x * x) * cos(y), x * sin(y));
	}
	return CMPLX(((x * x) * (y - y)), ((x + x) * (y - y)));
}


LIB_FUNC long double complex ccoshl(const long double complex z) {
	return (long double complex)ccosh((double complex)z);
}


LIB_FUNC float complex ccosf(const float complex z) {
	return ccoshf(CMPLXF(-cimagf(z), crealf(z)));
}


LIB_FUNC double complex ccos(const double complex z) {
	return ccosh(CMPLX(-cimag(z), creal(z)));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex ccosl(const long double complex z) {
	return (long double complex)ccos((double complex)z);
}
#else
LIB_FUNC long double complex ccosl(const long double complex z) {
	return ccoshl(CMPLXL(-cimagl(z), creall(z)));
}
#endif


LIB_FUNC float complex csinhf(const float complex num) {
	float complex z = num;
	const float x = crealf(z), y = cimagf(z);
	float h;
	int32_t hx, hy, ix, iy;
	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	ix = 0x7fffffff & hx;
	iy = 0x7fffffff & hy;
	if (ix < 0x7f800000 && iy < 0x7f800000) {
		if (iy == 0) { return CMPLXF(sinhf(x), y); }
		else if (ix < 0x41100000) { return CMPLXF(sinhf(x) * cosf(y), coshf(x) * sinf(y)); }
		else if (ix < 0x42b17218) {
			h = expf(fabsf(x)) * 0.5f;
			return CMPLXF(copysignf(h, x) * cosf(y), h * sinf(y));
		} else if (ix < 0x4340b1e7) {
			z = __ldexp_cexpf(CMPLXF(fabsf(x), y), -1);
			return CMPLXF(crealf(z) * copysignf(1, x), cimagf(z));
		} else {
			h = (float)(0x1p127F * x);
			return CMPLXF(h * cosf(y), (h * h * sinf(y)));
		}
	}
	if (ix == 0 && iy >= 0x7f800000) { return CMPLXF(copysignf(0, x * (y - y)), y - y); }
	else if (iy == 0 && ix >= 0x7f800000) {
		if ((hx & 0x7fffff) == 0) { return CMPLXF(x, y); }
		return CMPLXF(x, copysignf(0, y));
	} else if (ix < 0x7f800000 && iy >= 0x7f800000) { return CMPLXF(y - y, x * (y - y)); }
	else if (ix >= 0x7f800000 && (hx & 0x7fffff) == 0) {
		if (iy >= 0x7f800000) { return CMPLXF(x * x, x * (y - y)); }
		return CMPLXF(x * cosf(y), INFF * sinf(y));
	}
	return CMPLXF(((x * x) * (y - y)), ((x + x) * (y - y)));
}


LIB_FUNC double complex csinh(const double complex num) {
	double complex z = num;
	const double x = creal(z), y = cimag(z);
	double h;
	int32_t hx, hy, ix, iy, lx, ly;
	EXTRACT_SWORDS(hx, lx, x);
	EXTRACT_SWORDS(hy, ly, y);
	ix = 0x7fffffff & hx;
	iy = 0x7fffffff & hy;
	if (ix < 0x7ff00000 && iy < 0x7ff00000) {
		if ((iy | ly) == 0) { return CMPLX(sinh(x), y); }
		else if (ix < 0x40360000) { return CMPLX(sinh(x) * cos(y), cosh(x) * sin(y)); }
		if (ix < 0x40862e42) {
			h = exp(fabs(x)) * 0.5;
			return CMPLX(copysign(h, x) * cos(y), h * sin(y));
		} else if (ix < 0x4096bbaa) {
			z = __ldexp_cexp(CMPLX(fabs(x), y), -1);
			return CMPLX(creal(z) * copysign(1, x), cimag(z));
		} else {
			h = (0x1p1023 * x);
			return CMPLX(h * cos(y), (h * h * sin(y)));
		}
	}
	if ((ix | lx) == 0 && iy >= 0x7ff00000) { return CMPLX(copysign(0, x * (y - y)), y - y); }
	else if ((iy | ly) == 0 && ix >= 0x7ff00000) {
		if (((hx & 0xfffff) | lx) == 0) { return CMPLX(x, y); }
		return CMPLX(x, copysign(0, y));
	} else if (ix < 0x7ff00000 && iy >= 0x7ff00000) { return CMPLX(y - y, x * (y - y)); }
	else if (ix >= 0x7ff00000 && ((hx & 0xfffff) | lx) == 0) {
		if (iy >= 0x7ff00000) { return CMPLX(x * x, x * (y - y)); }
		return CMPLX(x * cos(y), INFINITY * sin(y));
	}
	return CMPLX(((x * x) * (y - y)), ((x + x) * (y - y)));
}


LIB_FUNC long double complex csinhl(const long double complex z) {
	return (long double complex)csinh((double complex)z);
}


LIB_FUNC float complex csinf(const float complex z) {
	const float complex y = csinhf(CMPLXF(-cimagf(z), crealf(z)));
	return CMPLXF(cimagf(y), -crealf(y));
}


LIB_FUNC double complex csin(const double complex z) {
	const double complex y = csinh(CMPLX(-cimag(z), creal(z)));
	return CMPLX(cimag(y), -creal(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex csinl(const long double complex z) {
	return (long double complex)csin((double complex)z);
}
#else
LIB_FUNC long double complex csinl(const long double complex z) {
	const long double complex y = csinhl(CMPLXL(-cimagl(z), creall(z)));
	return CMPLXL(cimagl(y), -creall(y));
}
#endif


LIB_FUNC float complex ctanhf(const float complex z) {
	float x = crealf(z), y = cimagf(z), t, beta, s, rho, denom;
	uint32_t hx, ix;
	GET_FLOAT_UWORD(hx, x);
	ix = hx & 0x7fffffff;
	if (ix >= 0x7f800000) {
		if (ix & 0x7fffff) { return CMPLXF(x, (y == 0 ? y : x * y)); }
		SET_FLOAT_WORD(x, (int)(hx - 0x40000000));
		return CMPLXF(x, copysignf(0, isinf(y) ? y : sinf(y) * cosf(y)));
	} else if (!isfinite(y)) { return CMPLXF(ix ? y - y : x, y - y); }
	else if (ix >= 0x41300000) {  // x >= 11
		float exp_mx = expf(-fabsf(x));
		return CMPLXF(copysignf(1, x), (4 * sinf(y) * cosf(y) * exp_mx * exp_mx));
	}
	t = tanf(y);
	beta = 1.0F + t * t;
	s = sinhf(x);
	rho = sqrtf((1.0F + s * s));
	denom = 1.0F + beta * s * s;
	return CMPLXF(((beta * rho * s) / denom), (t / denom));
}


LIB_FUNC double complex ctanh(const double complex z) {
	double x = creal(z), y = cimag(z), t, beta, s, rho, denom;
	uint32_t hx, ix, lx;
	EXTRACT_WORDS(hx, lx, x);
	ix = hx & 0x7fffffff;
	/* ctanh(NaN + i 0) = NaN + i 0
	 * ctanh(NaN + i y) = NaN + i NaN (if y != 0)
	 * ctanh(+-Inf +- i Inf) = +-1 +- 0
	 * ctanh(+-Inf + i y) = +-1 + 0 sin(2y) (if y is finite) */
	if (ix >= 0x7ff00000) {
		if ((ix & 0xfffff) | lx) { return CMPLX(x, (y == 0 ? y : x * y)); }  // x is NaN
		SET_HIGH_WORD(x, (int)(hx - 0x40000000));  // x = copysign(1, x)
		return CMPLX(x, copysign(0, __isinf(y) ? y : sin(y) * cos(y)));
	}
	/* ctanh(+-0 + i NAN) = +-0 + i NaN
	 * ctanh(+-0 +- i Inf) = +-0 + i NaN
	 * ctanh(x + i NAN) = NaN + i NaN
	 * ctanh(x +- i Inf) = NaN + i NaN
	 */
	else if (!isfinite(y)) { return CMPLX(x ? y - y : x, y - y); }
	else if (ix >= 0x40360000) {  // x >= 22
		double exp_mx = exp(-fabs(x));
		return CMPLX(copysign(1, x), (4 * sin(y) * cos(y) * exp_mx * exp_mx));
	}
	t = tan(y);
	beta = 1.0 + t * t;
	s = sinh(x);
	rho = sqrt(1.0 + s * s);
	denom = 1.0 + beta * s * s;
	return CMPLX(((beta * rho * s) / denom), (t / denom));
}


LIB_FUNC long double complex ctanhl(const long double complex z) {
	return (long double complex)ctanh((double complex)z);
}


LIB_FUNC float complex ctanf(const float complex z) {
	const float complex y = ctanhf(CMPLXF(-cimagf(z), crealf(z)));
	return CMPLXF(cimagf(y), -crealf(y));
}


LIB_FUNC double complex ctan(const double complex z) {
	const double complex y = ctanh(CMPLX(-cimag(z), creal(z)));
	return CMPLX(cimag(y), -creal(y));
}


#if LONG_DOUBLE_IS_BINARY64
LIB_FUNC long double complex ctanl(const long double complex z) {
	return ctan(z);
}
#else
LIB_FUNC long double complex ctanl(const long double complex z) {
	const long double complex y = ctanhl(CMPLXL(-cimagl(z), creall(z)));
	return CMPLXL(cimagl(y), -creall(y));
}
#endif


/** Calculate cosh and sinh */
LIB_FUNC void _cchshf(const float x, float* c, float* s) {
	if (fabsf(x) <= 0.5F) {
		*c = coshf(x);
		*s = sinhf(x);
	} else {
		float e = expf(x);
		const float ei = 0.5F / e;
		e = 0.5F * e;
		*s = e - ei;
		*c = e + ei;
	}
}


LIB_FUNC void _cchsh(const double x, double* c, double* s) {
	if (fabs(x) <= 0.5) {
		*c = cosh(x);
		*s = sinh(x);
	} else {
		double e = exp(x);
		const double ei = 0.5 / e;
		e = 0.5 * e;
		*s = e - ei;
		*c = e + ei;
	}
}


/** Taylor series expansion for cosh(2y) - cos(2x) */
LIB_FUNC float _ctansf(const float complex z) {
	float x = fabsf(2.0F * crealf(z)), y = fabsf(2.0F * cimagf(z));
	float f = 1.0F, x2 = 1.0F, y2 = 1.0F, rn = 0.0F, t, d = 0.0F;
	x = _redupif(x);
	x = x * x;
	y = y * y;
	do {
		rn += 1.0F;
		f *= rn;
		rn += 1.0F;
		f *= rn;
		x2 *= x;
		y2 *= y;
		t = y2 + x2;
		t /= f;
		d += t;
		rn += 1.0F;
		f *= rn;
		rn += 1.0F;
		f *= rn;
		x2 *= x;
		y2 *= y;
		t = y2 - x2;
		t /= f;
		d += t;
	} while (fabsf(t / d) > 3.0e-8F);
	return d;
}


/** Taylor series expansion for cosh(2y) - cos(2x) */
LIB_FUNC double _ctans(const double complex z) {
	double f = 1.0, x2 = 1.0, y2 = 1.0, rn = 0.0, t, d = 0.0;
	double x = fabs(2.0 * creal(z)), y = fabs(2.0 * cimag(z));
	x = _redupi(x);
	x = x * x;
	y = y * y;
	do {
		rn += 1.0;
		f *= rn;
		rn += 1.0;
		f *= rn;
		x2 *= x;
		y2 *= y;
		t = y2 + x2;
		t /= f;
		d += t;
		rn += 1.0;
		f *= rn;
		rn += 1.0;
		f *= rn;
		x2 *= x;
		y2 *= y;
		t = y2 - x2;
		t /= f;
		d += t;
	} while (fabs(t / d) > 1.1e-16);
	return d;
}


// TRIGONOMETRY (COMPLEX FLOATS)

/** Return the Chord */
LIB_FUNC float complex ccrdf(const float complex radians) {
	return ((float complex)2.0F + 2.0F * I_FLOAT * csinf(radians / (float complex)2.0F + 2.0F * I_FLOAT));
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC float complex cacotf(const float complex radians) {
	return catanf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC float complex carccotf(const float complex radians) {
	return catanf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC float complex cacothf(const float complex radians) {
	return catanhf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC float complex carccothf(const float complex radians) {
	return catanhf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC float complex ccothf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / ctanhf(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC float complex ccotf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / ctanf(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC float complex cacscf(const float complex radians) {
	return casinf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC float complex carccscf(const float complex radians) {
	return casinf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC float complex cacschf(const float complex radians) {
	return casinhf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC float complex carccschf(const float complex radians) {
	return casinhf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC float complex ccschf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / csinhf(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC float complex ccscf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / csinf(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC float complex casecf(const float complex radians) {
	return cacosf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC float complex carcsecf(const float complex radians) {
	return cacosf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC float complex casechf(const float complex radians) {
	return cacoshf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC float complex carcsechf(const float complex radians) {
	return cacoshf((float complex)1.0F + 1.0F * I_FLOAT / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC float complex csechf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / ccoshf(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC float complex csecf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / ccosf(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC float complex carcversinf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - cacosf(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC float complex carcversinhf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - cacoshf(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC float complex cversinhf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - ccoshf(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC float complex cversinf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - ccosf(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC float complex carcvercosf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - casinf(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC float complex carcvercoshf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - casinhf(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC float complex cvercoshf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - csinhf(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC float complex cvercosf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT - csinf(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC float complex chaversinf(const float complex radians) {
	return ((float complex)0.5F * ((float complex)1.0F + 1.0F * I_FLOAT - ccosf(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC float complex chacoversinf(const float complex radians) {
	return ((float complex)0.5F * ((float complex)1.0F + 1.0F * I_FLOAT - csinf(radians)));
}


// TRIGONOMETRY (COMPLEX DOUBLES)

/** Return the Chord */
LIB_FUNC double complex ccrd(const double complex radians) {
	return ((double complex)2.0 + 2.0 * I_DOUBLE * csin(radians / (double complex)2.0 + 2.0 * I_DOUBLE));
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC double complex cacot(const double complex radians) {
	return catan((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC double complex carccot(const double complex radians) {
	return catan((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC double complex cacoth(const double complex radians) {
	return catanh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC double complex carccoth(const double complex radians) {
	return catanh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC double complex ccoth(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / ctanh(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC double complex ccot(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / ctan(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC double complex cacsc(const double complex radians) {
	return casin((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC double complex carccsc(const double complex radians) {
	return casin((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC double complex cacsch(const double complex radians) {
	return casinh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC double complex carccsch(const double complex radians) {
	return casinh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC double complex ccsch(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / csinh(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC double complex ccsc(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / csin(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC double complex casec(const double complex radians) {
	return cacos((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC double complex carcsec(const double complex radians) {
	return cacos((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC double complex casech(const double complex radians) {
	return cacosh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC double complex carcsech(const double complex radians) {
	return cacosh((double complex)1.0 + 1.0 * I_DOUBLE / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC double complex csech(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / ccosh(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC double complex csec(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / ccos(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC double complex carcversin(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - cacos(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC double complex carcversinh(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - cacosh(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC double complex cversinh(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - ccosh(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC double complex cversin(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - ccos(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC double complex carcvercos(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - casin(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC double complex carcvercosh(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - casinh(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC double complex cvercosh(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - csinh(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC double complex cvercos(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE - csin(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC double complex chaversin(const double complex radians) {
	return ((double complex)0.5 * ((double complex)1.0 + 1.0 * I_DOUBLE - ccos(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC double complex chacoversin(const double complex radians) {
	return ((double complex)0.5 * ((double complex)1.0 + 1.0 * I_DOUBLE - csin(radians)));
}


// TRIGONOMETRY (COMPLEX LONG DOUBLES)

/** Return the Chord */
LIB_FUNC long double complex ccrdl(const long double complex radians) {
	return ((long double complex)2.0L + 2.0L * I_LONG_DOUBLE * csinl(radians / (long double complex)2.0L + 2.0L * I_LONG_DOUBLE));
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC long double complex cacotl(const long double complex radians) {
	return catanl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Arc-Cotangent (acot(x)||arccot(x) == atan(1/x)) */
LIB_FUNC long double complex carccotl(const long double complex radians) {
	return catanl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC long double complex cacothl(const long double complex radians) {
	return catanhl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cotangent (acoth(x)||arccoth(x) == atanh(1/x)) */
LIB_FUNC long double complex carccothl(const long double complex radians) {
	return catanhl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Cotangent (coth(x) == 1/tanh(x)) */
LIB_FUNC long double complex ccothl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ctanhl(radians));
}


/** Return the Cotangent (cot(x) == 1/tan(x)) */
LIB_FUNC long double complex ccotl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ctanl(radians));
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC long double complex cacscl(const long double complex radians) {
	return casinl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Arc-Cosecant (acsc(x)||arccsc(x) == asin(1/x)) */
LIB_FUNC long double complex carccscl(const long double complex radians) {
	return casinl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsch(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC long double complex cacschl(const long double complex radians) {
	return casinhl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Cosecant (acsc(x)||arccsch(x) == asinh(1/x)) */
LIB_FUNC long double complex carccschl(const long double complex radians) {
	return casinhl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Cosecant (csch(x) == 1/sinh(x)) */
LIB_FUNC long double complex ccschl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / csinhl(radians));
}


/** Return the Cosecant (csc(x) == 1/sin(x)) */
LIB_FUNC long double complex ccscl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / csinl(radians));
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC long double complex casecl(const long double complex radians) {
	return cacosl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Arc-Secant (asec(x)||arcsec(x) == acos(1/x)) */
LIB_FUNC long double complex carcsecl(const long double complex radians) {
	return cacosl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC long double complex casechl(const long double complex radians) {
	return cacoshl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Arc-Secant (asech(x)||arcsech(x) == acosh(1/x)) */
LIB_FUNC long double complex carcsechl(const long double complex radians) {
	return cacoshl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / radians);
}


/** Return the Hyperbolic Secant (sech(x) == 1/cosh(x)) */
LIB_FUNC long double complex csechl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ccoshl(radians));
}


/** Return the Secant (sec(x) == 1/cos(x)) */
LIB_FUNC long double complex csecl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ccosl(radians));
}


/** Return the Arc-Versed Sine (arcversin(x) == 1 - acos(x)) */
LIB_FUNC long double complex carcversinl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - cacosl(radians));
}


/** Return the Hyperbolic Arc-Versed Sine (arcversinh(x) == 1 - acosh(x)) */
LIB_FUNC long double complex carcversinhl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - cacoshl(radians));
}


/** Return the Hyperbolic Versed Sine (versinh(x) == 1 - cosh(x)) */
LIB_FUNC long double complex cversinhl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - ccoshl(radians));
}


/** Return the Versed Sine (versin(x) == 1 - cos(x)) */
LIB_FUNC long double complex cversinl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - ccosl(radians));
}


/** Return the Arc-Versed Cosine (arcvercos(x) == 1 - asin(x)) */
LIB_FUNC long double complex carcvercosl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - casinl(radians));
}


/** Return the Hyperbolic Arc-Versed Cosine (arcvercosh(x) == 1 - asinh(x)) */
LIB_FUNC long double complex carcvercoshl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - casinhl(radians));
}


/** Return the Hyperbolic Versed Cosine (vercosh(x) == 1 - sinh(x)) */
LIB_FUNC long double complex cvercoshl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - csinhl(radians));
}


/** Return the Versed Cosine (vercos(x) == 1 - sin(x)) */
LIB_FUNC long double complex cvercosl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - csinl(radians));
}


/** Return the Haversine (haversin(x) == 0.5*(1 - cos(x))) */
LIB_FUNC long double complex chaversinl(const long double complex radians) {
	return ((long double complex)0.5L * ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - ccosl(radians)));
}


/** Return the Hacoversine (hacoversin(x) == 0.5*(1 - sin(x))) */
LIB_FUNC long double complex chacoversinl(const long double complex radians) {
	return ((long double complex)0.5L * ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - csinl(radians)));
}


// EXTERNAL TRIGONOMETRY (COMPLEX FLOATS)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC float complex carcexcotf(const float complex radians) {
	return catanf((float complex)1.0F + 1.0F * I_FLOAT / (radians + (float complex)1.0F + 1.0F * I_FLOAT));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC float complex carcexcothf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / catanhf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC float complex cexcothf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / ctanhf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC float complex cexcotf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / ctanf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC float complex carcexcscf(const float complex radians) {
	return casinf((float complex)1.0F + 1.0F * I_FLOAT / (radians + (float complex)1.0F + 1.0F * I_FLOAT));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC float complex carcexcschf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / casinhf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC float complex cexcschf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / csinhf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC float complex cexcscf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / csinf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC float complex carcexsecf(const float complex radians) {
	return cacosf((float complex)1.0F + 1.0F * I_FLOAT / (radians + (float complex)1.0F + 1.0F * I_FLOAT));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC float complex carcexsechf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / cacoshf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC float complex cexsechf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / ccoshf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC float complex cexsecf(const float complex radians) {
	return (((float complex)1.0F + 1.0F * I_FLOAT / ccosf(radians)) - (float complex)1.0F + 1.0F * I_FLOAT);
}


// EXTERNAL TRIGONOMETRY (COMPLEX DOUBLES)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC double complex carcexcot(const double complex radians) {
	return catan((double complex)1.0 + 1.0 * I_DOUBLE / (radians + (double complex)1.0 + 1.0 * I_DOUBLE));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC double complex carcexcoth(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / catanh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC double complex cexcoth(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / ctanh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC double complex cexcot(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / ctan(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC double complex carcexcsc(const double complex radians) {
	return casin((double complex)1.0 + 1.0 * I_DOUBLE / (radians + (double complex)1.0 + 1.0 * I_DOUBLE));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC double complex carcexcsch(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / casinh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC double complex cexcsch(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / csinh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC double complex cexcsc(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / csin(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC double complex carcexsec(const double complex radians) {
	return cacos((double complex)1.0 + 1.0 * I_DOUBLE / (radians + (double complex)1.0 + 1.0 * I_DOUBLE));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC double complex carcexsech(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / cacosh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC double complex cexsech(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / ccosh(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC double complex cexsec(const double complex radians) {
	return (((double complex)1.0 + 1.0 * I_DOUBLE / ccos(radians)) - (double complex)1.0 + 1.0 * I_DOUBLE);
}


// EXTERNAL TRIGONOMETRY (COMPLEX LONG DOUBLES)

/** Return the Arc-External Cotangent (arcexcot(x) == atan(1/(x+1))) */
LIB_FUNC long double complex carcexcotl(const long double complex radians) {
	return catanl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / (radians + (long double complex)1.0L + 1.0L * I_LONG_DOUBLE));
}


/** Return the Hyperbolic Arc-External Cotangent [arcexcoth(x) == (1/atanh(x)-1)] */
LIB_FUNC long double complex carcexcothl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / catanhl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Hyperbolic Cotangent [excoth(x) == (1/tanh(x)-1)] */
LIB_FUNC long double complex cexcothl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ctanhl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Cotangent [excot(x) == (1/tan(x))-1 == cot(x)-1] */
LIB_FUNC long double complex cexcotl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ctanl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the Arc-External Cosecant (arcexcsc(x) == asin(1/(x+1))) */
LIB_FUNC long double complex carcexcscl(const long double complex radians) {
	return casinl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / (radians + (long double complex)1.0L + 1.0L * I_LONG_DOUBLE));
}


/** Return the Hyperbolic Arc-External Cosecant [arcexcsch(x) == (1/asinh(x)-1)] */
LIB_FUNC long double complex carcexcschl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / casinhl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Hyperbolic Cosecant [excsch(x) == (1/sinh(x)-1)] */
LIB_FUNC long double complex cexcschl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / csinhl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Cosecant [excsc(x) == (1/sin(x))-1 == csc(x)-1] */
LIB_FUNC long double complex cexcscl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / csinl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the Arc-External Secant (arcexsec(x) == acos(1/(x+1))) */
LIB_FUNC long double complex carcexsecl(const long double complex radians) {
	return cacosl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / (radians + (long double complex)1.0L + 1.0L * I_LONG_DOUBLE));
}


/** Return the Hyperbolic Arc-External Secant [arcexsech(x) == (1/acosh(x)-1)] */
LIB_FUNC long double complex carcexsechl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / cacoshl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Hyperbolic Secant [exsech(x) == (1/cosh(x)-1)] */
LIB_FUNC long double complex cexsechl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ccoshl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


/** Return the External Secant [exsec(x) == (1/cos(x))-1 == sec(x)-1] */
LIB_FUNC long double complex cexsecl(const long double complex radians) {
	return (((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / ccosl(radians)) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE);
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (COMPLEX FLOATS)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC float complex ccos_arcsinf(const float complex radians) {
	return (csqrtf((float complex)1.0F + 1.0F * I_FLOAT - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC float complex ccos_arctanf(const float complex radians) {
	return ((float complex)1.0F + 1.0F * I_FLOAT / csqrtf((float complex)1.0F + 1.0F * I_FLOAT + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC float complex csin_arcsecf(const float complex radians) {
	return (csqrtf((radians * radians) - (float complex)1.0F + 1.0F * I_FLOAT) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC float complex csin_arctanf(const float complex radians) {
	return (radians / csqrtf((float complex)1.0F + 1.0F * I_FLOAT + (radians * radians)));
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (COMPLEX DOUBLES)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC double complex ccos_arcsin(const double complex radians) {
	return (csqrt((double complex)1.0 + 1.0 * I_DOUBLE - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC double complex ccos_arctan(const double complex radians) {
	return ((double complex)1.0 + 1.0 * I_DOUBLE / csqrt((double complex)1.0 + 1.0 * I_DOUBLE + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC double complex csin_arcsec(const double complex radians) {
	return (csqrt((radians * radians) - (double complex)1.0 + 1.0 * I_DOUBLE) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC double complex csin_arctan(const double complex radians) {
	return (radians / csqrt((double complex)1.0 + 1.0 * I_DOUBLE + (radians * radians)));
}


// SPECIAL TRIGONOMETRIC FUNCTIONS (COMPLEX LONG DOUBLES)

/** Return the Cosine of an Arc-Sine [sqrt(1-(x*x))] */
LIB_FUNC long double complex ccos_arcsinl(const long double complex radians) {
	return (csqrtl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE - (radians * radians)));
}


/** Return the Cosine of an Arc-Tangent [1 / sqrt(1+(x*x))] */
LIB_FUNC long double complex ccos_arctanl(const long double complex radians) {
	return ((long double complex)1.0L + 1.0L * I_LONG_DOUBLE / csqrtl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE + (radians * radians)));
}


/** Return the Sine of an Arc-Tangent [sqrt((x*x)-1)/x] */
LIB_FUNC long double complex csin_arcsecl(const long double complex radians) {
	return (csqrtl((radians * radians) - (long double complex)1.0L + 1.0L * I_LONG_DOUBLE) / radians);
}


/** Return the Sine of an Arc-Tangent [x / sqrt(1+(x*x))] */
LIB_FUNC long double complex csin_arctanl(const long double complex radians) {
	return (radians / csqrtl((long double complex)1.0L + 1.0L * I_LONG_DOUBLE + (radians * radians)));
}


#endif  // COMPLEX_H


/* QUATERNION MATH */


#if (!(defined(QUATERNION_H) || defined(_QUATERNION_H) || defined(_QUATERNION_H_)))
#define QUATERNION_H   (1)
#define _QUATERNION_H   (1)
#define _QUATERNION_H_   (1)


/** Imaginary number with three imaginary parts (double) */
typedef struct quaternion { double R, i, j, k; }   quaternion;
/** Imaginary number with three imaginary parts (float) */
typedef struct quaternion_float { float R, i, j, k; }   quaternion_float;
/** Imaginary number with three imaginary parts (long double) */
typedef struct quaternion_long_double { long double R, i, j, k; }   quaternion_long_double;
#ifdef FLOAT128_SUPPORTED
/** Imaginary number with three imaginary parts (float128_t) */
typedef struct quaternion_float128 { float128_t R, i, j, k; }   quaternion_float128;
#endif
#ifndef QUATERNIONF
#   define QUATERNIONF(r, x, y, z)   ((quaternion_float){(float)(r), (float)(x), (float)(y), (float)(z)})
#endif
#ifndef __quaternionf__
#   define __quaternionf__(r, x, y, z)   QUATERNIONF(r, x, y, z)
#endif
#ifndef QUATERNION
#   define QUATERNION(r, x, y, z)   ((quaternion){(double)(r), (double)(x), (double)(y), (double)(z)})
#endif
#ifndef __quaternion__
#   define __quaternion__(r, x, y, z)   QUATERNION(r, x, y, z)
#endif
#ifndef QUATERNIONL
#   define QUATERNIONL(r, x, y, z)   ((quaternion_long_double){(long double)(r), (long double)(x), (long double)(y), (long double)(z)})
#endif
#ifndef __quaternionl__
#   define __quaternionl__(r, x, y, z)   QUATERNIONL(r, x, y, z)
#endif
#if ((!defined(QUATERNIONF128)) && defined(FLOAT128_SUPPORTED))
#   define QUATERNIONF128(r, x, y, z)   ((quaternion_float128){(float128_t)(r), (float128_t)(x), (float128_t)(y), (float128_t)(z)})
#endif
#if ((!defined(__quaternionf128__)) && defined(FLOAT128_SUPPORTED))
#   define __quaternionf128__(r, x, y, z)   QUATERNIONF128(r, x, y, z)
#endif


#define qimagf(x)   ((x).i, (x).j, (x).k)
#define qimag(x)   ((x).i, (x).j, (x).k)
#define qimagl(x)   ((x).i, (x).j, (x).k)


/** Return the real number from the quaternion number */
LIB_FUNC double qreal(const quaternion num) {
	return num.R;
}


/** Return the imaginary i num of the quaternion number */
LIB_FUNC double qgeti(const quaternion num) {
	return num.i;
}


/** Return the imaginary j num of the quaternion number */
LIB_FUNC double qgetj(const quaternion num) {
	return num.j;
}


/** Return the imaginary k num of the quaternion number */
LIB_FUNC double qgetk(const quaternion num) {
	return num.k;
}


/** Return the conjugate of the quaternion number */
LIB_FUNC quaternion qconjugate(const quaternion num) {
	return (quaternion){num.R, num.i * (double)-1.0, num.j * (double)-1.0, num.k * (double)-1.0};
}


/** Return the norm value of the quaternion number */
LIB_FUNC double qnorm(const quaternion num) {
	return squareroot((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Add two quaternion numbers */
LIB_FUNC quaternion qadd(const quaternion num1, const quaternion num2) {
	return (quaternion){num1.R + num2.R, num1.i + num2.i, num1.j + num2.j, num1.k + num2.k};
}


/** Subtract two quaternion numbers */
LIB_FUNC quaternion qsub(const quaternion num1, const quaternion num2) {
	return (quaternion){num1.R - num2.R, num1.i - num2.i, num1.j - num2.j, num1.k - num2.k};
}


/** Multiply two quaternion numbers */
LIB_FUNC quaternion qmul(const quaternion num1, const quaternion num2) {
	double tmp_r = (num2.R * num1.R) - (num2.i * num1.i) - (num2.j * num1.j) - (num2.k * num1.k);
	double tmp_i = (num2.R * num1.i) + (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) + (num2.j * num1.R) - (num2.k * num1.i);
	double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) + (num2.k * num1.R);
	return (quaternion){tmp_r, tmp_i, tmp_j, tmp_k};
}


/** Divide two quaternion numbers */
LIB_FUNC quaternion qdiv(const quaternion num1, const quaternion num2) {
	if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) && (num1.k == num2.k)) return (quaternion){1.0, 0.0, 0.0, 0.0};
	double tmp_r = (num2.R * num1.R) + (num2.i * num1.i) + (num2.j * num1.j) + (num2.k * num1.k);
	double tmp_i = (num2.R * num1.i) - (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) - (num2.j * num1.R) - (num2.k * num1.i);
	double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) - (num2.k * num1.R);
	register double tmp2n = squareroot((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) + (num2.k * num2.k));  // Norm
	return (quaternion){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n, tmp_k / tmp2n};
}


/** Inverse quaternion */
LIB_FUNC quaternion qinv(const quaternion qnum) {
	register double tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	return (quaternion){ (qnum.R / tmp), ((-qnum.i) / tmp), ((-qnum.j) / tmp), ((-qnum.k) / tmp) };
}


/** Inverse quaternion (in-place) */
LIB_FUNC void qinv_inplace(quaternion qnum) {
	register double tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	qnum.R /= tmp;
	qnum.i = (-qnum.i) / tmp;
	qnum.j = (-qnum.j) / tmp;
	qnum.k = (-qnum.k) / tmp;
}


/** Return the negative quaternion */
LIB_FUNC quaternion qneg(const quaternion qnum) {
	return (quaternion){ (-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k) };
}


/** Negate quaternion (in-place) */
LIB_FUNC void qneg_inplace(quaternion qnum) {
	qnum.R = -qnum.R;
	qnum.i = -qnum.i;
	qnum.j = -qnum.j;
	qnum.k = -qnum.k;
}


/** Return the length of a quaternion */
LIB_FUNC double qlen(const quaternion num) {
	return squareroot((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Return the mid-point of two quaternions */
LIB_FUNC quaternion qmid(const quaternion num1, const quaternion num2) {
	quaternion q = qadd(num1, num2);
	register double tmp = qlen(num1);
	if (tmp < (1e-12)) {
		q.R = num2.i;
		q.i = -num2.R;
		q.j = num2.k;
		q.k = -num2.j;
	} else {
		q.R /= tmp;
		q.i /= tmp;
		q.j /= tmp;
		q.k /= tmp;
	}
	return q;
}


/** Return the squareroot of a quaternion */
LIB_FUNC quaternion qsqrt(const quaternion num) {
	return qmid(num, (quaternion){ 1.0, 0.0, 0.0, 0.0 });
}


/** Return the scalar portion of the quaternion number */
LIB_FUNC quaternion qscalar(const quaternion num) {
	quaternion conj_num = (quaternion){num.R, num.i * (double)-1.0, num.j * (double)-1.0, num.k * (double)-1.0};
	return (quaternion){(num.R + conj_num.R) * 0.5, (num.i + conj_num.i) * 0.5, (num.j + conj_num.j) * 0.5, (num.k + conj_num.k) * 0.5};
}


/** Return the vector portion of the quaternion number */
LIB_FUNC quaternion qvector(const quaternion num) {
	quaternion conj_num = (quaternion){num.R, num.i * (double)-1.0, num.j * (double)-1.0, num.k * (double)-1.0};
	return (quaternion){(num.R - conj_num.R) * 0.5, (num.i - conj_num.i) * 0.5, (num.j - conj_num.j) * 0.5, (num.k - conj_num.k) * 0.5};
}


/** Return the versor the quaternion number */
LIB_FUNC quaternion qversor(const quaternion num) {
	quaternion conj_num = (quaternion){num.R, num.i * (double)-1.0, num.j * (double)-1.0, num.k * (double)-1.0};
	return qdiv(num, conj_num);
}


/** Return the real number from the quaternion number */
LIB_FUNC float qrealf(const quaternion_float num) {
	return num.R;
}


/** Return the imaginary i num of the quaternion number */
LIB_FUNC float qgetif(const quaternion_float num) {
	return num.i;
}


/** Return the imaginary j num of the quaternion number */
LIB_FUNC float qgetjf(const quaternion_float num) {
	return num.j;
}


/** Return the imaginary k num of the quaternion number */
LIB_FUNC float qgetkf(const quaternion_float num) {
	return num.k;
}


/** Return the conjugate of the quaternion number */
LIB_FUNC quaternion_float qconjugatef(const quaternion_float num) {
	return (quaternion_float){num.R, num.i * (float)-1.0F, num.j * (float)-1.0F, num.k * (float)-1.0F};
}


/** Return the norm value of the quaternion number */
LIB_FUNC float qnormf(const quaternion_float num) {
	return squarerootf((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Add two quaternion numbers */
LIB_FUNC quaternion_float qaddf(const quaternion_float num1, const quaternion_float num2) {
	return (quaternion_float){num1.R + num2.R, num1.i + num2.i, num1.j + num2.j, num1.k + num2.k};
}


/** Subtract two quaternion numbers */
LIB_FUNC quaternion_float qsubf(const quaternion_float num1, const quaternion_float num2) {
	return (quaternion_float){num1.R - num2.R, num1.i - num2.i, num1.j - num2.j, num1.k - num2.k};
}


/** Multiply two quaternion numbers */
LIB_FUNC quaternion_float qmulf(const quaternion_float num1, const quaternion_float num2) {
	float tmp_r = (num2.R * num1.R) - (num2.i * num1.i) - (num2.j * num1.j) - (num2.k * num1.k);
	float tmp_i = (num2.R * num1.i) + (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	float tmp_j = (num2.R * num1.j) + (num2.i * num1.k) + (num2.j * num1.R) - (num2.k * num1.i);
	float tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) + (num2.k * num1.R);
	return (quaternion_float){tmp_r, tmp_i, tmp_j, tmp_k};
}


/** Divide two quaternion numbers */
LIB_FUNC quaternion_float qdivf(const quaternion_float num1, const quaternion_float num2) {
	if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) && (num1.k == num2.k)) return (quaternion_float){1.0F, 0.0F, 0.0F, 0.0F};
	float tmp_r = (num2.R * num1.R) + (num2.i * num1.i) + (num2.j * num1.j) + (num2.k * num1.k);
	float tmp_i = (num2.R * num1.i) - (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	float tmp_j = (num2.R * num1.j) + (num2.i * num1.k) - (num2.j * num1.R) - (num2.k * num1.i);
	float tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) - (num2.k * num1.R);
	register float tmp2n = squarerootf((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) + (num2.k * num2.k));  // Norm
	return (quaternion_float){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n, tmp_k / tmp2n};
}


/** Inverse quaternion */
LIB_FUNC quaternion_float qinvf(const quaternion_float qnum) {
	register float tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	return (quaternion_float){ (qnum.R / tmp), ((-qnum.i) / tmp), ((-qnum.j) / tmp), ((-qnum.k) / tmp) };
}


/** Inverse quaternion (in-place) */
LIB_FUNC void qinv_inplacef(quaternion_float qnum) {
	register float tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	qnum.R /= tmp;
	qnum.i = (-qnum.i) / tmp;
	qnum.j = (-qnum.j) / tmp;
	qnum.k = (-qnum.k) / tmp;
}


/** Return the negative quaternion */
LIB_FUNC quaternion_float qnegf(const quaternion_float qnum) {
	return (quaternion_float){ (-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k) };
}


/** Negate quaternion (in-place) */
LIB_FUNC void qneg_inplacef(quaternion_float qnum) {
	qnum.R = -qnum.R;
	qnum.i = -qnum.i;
	qnum.j = -qnum.j;
	qnum.k = -qnum.k;
}


/** Return the length of a quaternion */
LIB_FUNC float qlenf(const quaternion_float num) {
	return squarerootf((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Return the mid-point of two quaternions */
LIB_FUNC quaternion_float qmidf(const quaternion_float num1, const quaternion_float num2) {
	quaternion_float q = qaddf(num1, num2);
	register float tmp = qlenf(num1);
	if (tmp < (1e-12F)) {
		q.R = num2.i;
		q.i = -num2.R;
		q.j = num2.k;
		q.k = -num2.j;
	} else {
		q.R /= tmp;
		q.i /= tmp;
		q.j /= tmp;
		q.k /= tmp;
	}
	return q;
}


/** Return the squareroot of a quaternion */
LIB_FUNC quaternion_float qsqrtf(const quaternion_float num) {
	return qmidf(num, (quaternion_float){ 1.0F, 0.0F, 0.0F, 0.0F });
}


/** Return the scalar portion of the quaternion number */
LIB_FUNC quaternion_float qscalarf(const quaternion_float num) {
	quaternion_float conj_num = (quaternion_float){num.R, num.i * (float)-1.0F, num.j * (float)-1.0F, num.k * (float)-1.0F};
	return (quaternion_float){(num.R + conj_num.R) * 0.5F, (num.i + conj_num.i) * 0.5F, (num.j + conj_num.j) * 0.5F, (num.k + conj_num.k) * 0.5F};
}


/** Return the vector portion of the quaternion number */
LIB_FUNC quaternion_float qvectorf(const quaternion_float num) {
	quaternion_float conj_num = (quaternion_float){num.R, num.i * (float)-1.0F, num.j * (float)-1.0F, num.k * (float)-1.0F};
	return (quaternion_float){(num.R - conj_num.R) * 0.5F, (num.i - conj_num.i) * 0.5F, (num.j - conj_num.j) * 0.5F, (num.k - conj_num.k) * 0.5F};
}


/** Return the versor the quaternion number */
LIB_FUNC quaternion_float qversorf(const quaternion_float num) {
	quaternion_float conj_num = (quaternion_float){num.R, num.i * (float)-1.0F, num.j * (float)-1.0F, num.k * (float)-1.0F};
	return qdivf(num, conj_num);
}


/** Return the real number from the quaternion number */
LIB_FUNC long double qreall(const quaternion_long_double num) {
	return num.R;
}


/** Return the imaginary i num of the quaternion number */
LIB_FUNC long double qgetil(const quaternion_long_double num) {
	return num.i;
}


/** Return the imaginary j num of the quaternion number */
LIB_FUNC long double qgetjl(const quaternion_long_double num) {
	return num.j;
}


/** Return the imaginary k num of the quaternion number */
LIB_FUNC long double qgetkl(const quaternion_long_double num) {
	return num.k;
}


/** Return the conjugate of the quaternion number */
LIB_FUNC quaternion_long_double qconjugatel(const quaternion_long_double num) {
	return (quaternion_long_double){num.R, num.i * (long double)-1.0L, num.j * (long double)-1.0L, num.k * (long double)-1.0L};
}


/** Return the norm value of the quaternion number */
LIB_FUNC long double qnorml(const quaternion_long_double num) {
	return squarerootl((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Add two quaternion numbers */
LIB_FUNC quaternion_long_double qaddl(const quaternion_long_double num1, const quaternion_long_double num2) {
	return (quaternion_long_double){num1.R + num2.R, num1.i + num2.i, num1.j + num2.j, num1.k + num2.k};
}


/** Subtract two quaternion numbers */
LIB_FUNC quaternion_long_double qsubl(const quaternion_long_double num1, const quaternion_long_double num2) {
	return (quaternion_long_double){num1.R - num2.R, num1.i - num2.i, num1.j - num2.j, num1.k - num2.k};
}


/** Multiply two quaternion numbers */
LIB_FUNC quaternion_long_double qmull(const quaternion_long_double num1, const quaternion_long_double num2) {
	long double tmp_r = (num2.R * num1.R) - (num2.i * num1.i) - (num2.j * num1.j) - (num2.k * num1.k);
	long double tmp_i = (num2.R * num1.i) + (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	long double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) + (num2.j * num1.R) - (num2.k * num1.i);
	long double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) + (num2.k * num1.R);
	return (quaternion_long_double){tmp_r, tmp_i, tmp_j, tmp_k};
}


/** Divide two quaternion numbers */
LIB_FUNC quaternion_long_double qdivl(const quaternion_long_double num1, const quaternion_long_double num2) {
	if ((num1.R == num2.R) && (num1.i == num2.i) && (num1.j == num2.j) && (num1.k == num2.k)) {
		return (quaternion_long_double){1.0L, 0.0L, 0.0L, 0.0L};
	}
	long double tmp_r = (num2.R * num1.R) + (num2.i * num1.i) + (num2.j * num1.j) + (num2.k * num1.k);
	long double tmp_i = (num2.R * num1.i) - (num2.i * num1.R) - (num2.j * num1.k) + (num2.k * num1.j);
	long double tmp_j = (num2.R * num1.j) + (num2.i * num1.k) - (num2.j * num1.R) - (num2.k * num1.i);
	long double tmp_k = (num2.R * num1.k) - (num2.i * num1.j) + (num2.j * num1.i) - (num2.k * num1.R);
	register long double tmp2n = squarerootl((num2.R * num2.R) + (num2.i * num2.i) + (num2.j * num2.j) + (num2.k * num2.k));  // Norm
	return (quaternion_long_double){tmp_r / tmp2n, tmp_i / tmp2n, tmp_j / tmp2n, tmp_k / tmp2n};
}


/** Inverse quaternion */
LIB_FUNC quaternion_long_double qinvl(const quaternion_long_double qnum) {
	register long double tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	return (quaternion_long_double){ (qnum.R / tmp), ((-qnum.i) / tmp), ((-qnum.j) / tmp), ((-qnum.k) / tmp) };
}


/** Inverse quaternion (in-place) */
LIB_FUNC void qinv_inplacel(quaternion_long_double qnum) {
	register long double tmp = ((qnum.R * qnum.R) + (qnum.i * qnum.i) + (qnum.j * qnum.j) + (qnum.k * qnum.k));
	qnum.R /= tmp;
	qnum.i = (-qnum.i) / tmp;
	qnum.j = (-qnum.j) / tmp;
	qnum.k = (-qnum.k) / tmp;
}


/** Return the negative quaternion */
LIB_FUNC quaternion_long_double qnegl(const quaternion_long_double qnum) {
	return (quaternion_long_double){ (-qnum.R), (-qnum.i), (-qnum.j), (-qnum.k) };
}


/** Negate quaternion (in-place) */
LIB_FUNC void qneg_inplacel(quaternion_long_double qnum) {
	qnum.R = -qnum.R;
	qnum.i = -qnum.i;
	qnum.j = -qnum.j;
	qnum.k = -qnum.k;
}


/** Return the length of a quaternion */
LIB_FUNC long double qlenl(const quaternion_long_double num) {
	return squarerootl((num.R * num.R) + (num.i * num.i) + (num.j * num.j) + (num.k * num.k));
}


/** Return the mid-point of two quaternions */
LIB_FUNC quaternion_long_double qmidl(const quaternion_long_double num1, const quaternion_long_double num2) {
	quaternion_long_double q = qaddl(num1, num2);
	register long double tmp = qlenl(num1);
	if (tmp < (1e-12L)) {
		q.R = num2.i;
		q.i = -num2.R;
		q.j = num2.k;
		q.k = -num2.j;
	} else {
		q.R /= tmp;
		q.i /= tmp;
		q.j /= tmp;
		q.k /= tmp;
	}
	return q;
}


/** Return the squareroot of a quaternion */
LIB_FUNC quaternion_long_double qsqrtl(const quaternion_long_double num) {
	return qmidl(num, (quaternion_long_double){ 1.0L, 0.0L, 0.0L, 0.0L });
}


/** Return the scalar portion of the quaternion number */
LIB_FUNC quaternion_long_double qscalarl(const quaternion_long_double num) {
	quaternion_long_double conj_num = (quaternion_long_double){num.R, num.i * (long double)-1.0L, num.j * (long double)-1.0L, num.k * (long double)-1.0L};
	return (quaternion_long_double){(num.R + conj_num.R) * 0.5L, (num.i + conj_num.i) * 0.5L, (num.j + conj_num.j) * 0.5L, (num.k + conj_num.k) * 0.5L};
}


/** Return the vector portion of the quaternion number */
LIB_FUNC quaternion_long_double qvectorl(const quaternion_long_double num) {
	quaternion_long_double conj_num = (quaternion_long_double){num.R, num.i * (long double)-1.0L, num.j * (long double)-1.0L, num.k * (long double)-1.0L};
	return (quaternion_long_double){(num.R - conj_num.R) * 0.5L, (num.i - conj_num.i) * 0.5L, (num.j - conj_num.j) * 0.5L, (num.k - conj_num.k) * 0.5L};
}


/** Return the versor the quaternion number */
LIB_FUNC quaternion_long_double qversorl(const quaternion_long_double num) {
	quaternion_long_double conj_num = (quaternion_long_double){num.R, num.i * (long double)-1.0L, num.j * (long double)-1.0L, num.k * (long double)-1.0L};
	return qdivl(num, conj_num);
}


#endif  // QUATERNION_H


/* TYPE GENERIC MATH (<tgmath.h>) */


#if ((!(defined(TGMATH_H) || defined(_TGMATH_H) || defined(_TGMATH_H_) || defined(__TGMATH_H))) && IS_NOT_CPLUSPLUS)  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/tgmath.h.html & http://www.cplusplus.com/reference/ctgmath/
#define TGMATH_H   (1)
#define _TGMATH_H   (1)
#define _TGMATH_H_   (1)
#define __TGMATH_H   (1)


#define tgm_select(expr, ldc, dc, fc, ld, d, f)   _Generic (expr, \
	long double _Complex:   ldc, \
	double _Complex: dc, \
	float _Complex: fc, \
	long double: ld, \
	double: d, \
	float: f, \
	default: d \
)


// ACOS
#define tg_acos(x)   _Generic ((x), const float: acosf(x), const double: acos(x), const long double: acosl(x), const float complex: cacosf(x), const double complex: cacos(x), const long double complex: cacosl(x), float: acosf(x), double: acos(x), long double: acosl(x), float complex: cacosf(x), double complex: cacos(x), long double complex: cacosl(x), default: 0)
#define __tg_acos(x)   tg_acos((x))


// ASIN
#define tg_asin(x)   _Generic ((x), const float: asinf(x), const double: asin(x), const long double: asinl(x), const float complex: casinf(x), const double complex: casin(x), const long double complex: casinl(x), float: asinf(x), double: asin(x), long double: asinl(x), float complex: casinf(x), double complex: casin(x), long double complex: casinl(x), default: 0)
#define __tg_asin(x)   tg_asin((x))


// ATAN
#define tg_atan(x)   _Generic ((x), const float: atanf(x), const double: atan(x), const long double: atanl(x), const float complex: catanf(x), const double complex: catan(x), const long double complex: catanl(x), float: atanf(x), double: atan(x), long double: atanl(x), float complex: catanf(x), double complex: catan(x), long double complex: catanl(x), default: 0)
#define __tg_atan(x)   tg_atan((x))


// ACOSH
#define tg_acosh(x)   _Generic ((x), const float: acoshf(x), const double: acosh(x), const long double: acoshl(x), const float complex: cacoshf(x), const double complex: cacosh(x), const long double complex: cacoshl(x), float: acoshf(x), double: acosh(x), long double: acoshl(x), float complex: cacoshf(x), double complex: cacosh(x), long double complex: cacoshl(x), default: 0)
#define __tg_acosh(x)   tg_acosh((x))


// ASINH
#define tg_asinh(x)   _Generic ((x), const float: asinhf(x), const double: asinh(x), const long double: asinhl(x), const float complex: casinhf(x), const double complex: casinh(x), const long double complex: casinhl(x), float: asinhf(x), double: asinh(x), long double: asinhl(x), float complex: casinhf(x), double complex: casinh(x), long double complex: casinhl(x), default: 0)
#define __tg_asinh(x)   tg_asinh((x))


// ATANH
#define tg_atanh(x)   _Generic ((x), const float: atanhf(x), const double: atanh(x), const long double: atanhl(x), const float complex: catanhf(x), const double complex: catanh(x), const long double complex: catanhl(x), float: atanhf(x), double: atanh(x), long double: atanhl(x), float complex: catanhf(x), double complex: catanh(x), long double complex: catanhl(x), default: 0)
#define __tg_atanh(x)   tg_atanh((x))


// COS
#define tg_cos(x)   _Generic ((x), const float: cosf(x), const double: cos(x), const long double: cosl(x), const float complex: ccosf(x), const double complex: ccos(x), const long double complex: ccosl(x), float: cosf(x), double: cos(x), long double: cosl(x), float complex: ccosf(x), double complex: ccos(x), long double complex: ccosl(x), default: 0)
#define __tg_cos(x)   tg_cos((x))


// SIN
#define tg_sin(x)   _Generic ((x), const float: sinf(x), const double: sin(x), const long double: sinl(x), const float complex: csinf(x), const double complex: csin(x), const long double complex: csinl(x), float: sinf(x), double: sin(x), long double: sinl(x), float complex: csinf(x), double complex: csin(x), long double complex: csinl(x), default: 0)
#define __tg_sin(x)   tg_sin((x))


// TAN
#define tg_tan(x)   _Generic ((x), const float: tanf(x), const double: tan(x), const long double: tanl(x), const float complex: ctanf(x), const double complex: ctan(x), const long double complex: ctanl(x), float: tanf(x), double: tan(x), long double: tanl(x), float complex: ctanf(x), double complex: ctan(x), long double complex: ctanl(x), default: 0)
#define __tg_tan(x)   tg_tan((x))


// COSH
#define tg_cosh(x)   _Generic ((x), const float: coshf(x), const double: cosh(x), const long double: coshl(x), const float complex: ccoshf(x), const double complex: ccosh(x), const long double complex: ccoshl(x), float: coshf(x), double: cosh(x), long double: coshl(x), float complex: ccoshf(x), double complex: ccosh(x), long double complex: ccoshl(x), default: 0)
#define __tg_cosh(x)   tg_cosh((x))


// SINH
#define tg_sinh(x)   _Generic ((x), const float: sinhf(x), const double: sinh(x), const long double: sinhl(x), const float complex: csinhf(x), const double complex: csinh(x), const long double complex: csinhl(x), float: sinhf(x), double: sinh(x), long double: sinhl(x), float complex: csinhf(x), double complex: csinh(x), long double complex: csinhl(x), default: 0)
#define __tg_sinh(x)   tg_sinh((x))


// TANH
#define tg_tanh(x)   _Generic ((x), const float: tanhf(x), const double: tanh(x), const long double: tanhl(x), const float complex: ctanhf(x), const double complex: ctanh(x), const long double complex: ctanhl(x), float: tanhf(x), double: tanh(x), long double: tanhl(x), float complex: ctanhf(x), double complex: ctanh(x), long double complex: ctanhl(x), default: 0)
#define __tg_tanh(x)   tg_tanh((x))


// ATAN2
#define tg_atan2(x)   _Generic ((x), const float: atan2f(x), const double: atan2(x), const long double: atan2l(x), float: atan2f(x), double: atan2(x), long double: atan2l(x), default: 0)
#define __tg_atan2(x)   tg_atan2((x))


// EXP
#define tg_exp(x)   _Generic ((x), const float: expf(x), const double: exp(x), const long double: expl(x), const float complex: cexpf(x), const double complex: cexp(x), const long double complex: cexpl(x), float: expf(x), double: exp(x), long double: expl(x), float complex: cexpf(x), double complex: cexp(x), long double complex: cexpl(x), default: 0)
#define __tg_exp(x)   tg_exp((x))


// EXP2
#define tg_exp2(x)   _Generic ((x), const float: exp2f(x), const double: exp2(x), const long double: exp2l(x), float: exp2f(x), double: exp2(x), long double: exp2l(x), default: 0)
#define __tg_exp2(x)   tg_exp2((x))


// EXPM1
#define tg_expm1(x)   _Generic ((x), const float: expm1f(x), const double: expm1(x), const long double: expm1l(x), float: expm1f(x), double: expm1(x), long double: expm1l(x), default: 0)
#define __tg_expm1(x)   tg_expm1((x))


// LDEXP
#define tg_ldexp(x, y)   _Generic ((x), const float: ldexpf(x, y), const double: ldexp(x, y), const long double: ldexpl(x, y), float: ldexpf(x, y), double: ldexp(x, y), long double: ldexpl(x, y), default: 0)
#define __tg_ldexp(x, y)   tg_ldexp((x), (y))


// LOG
#define tg_log(x)   _Generic ((x), const float: logf(x), const double: log(x), const long double: logl(x), const float complex: clogf(x), const double complex: clog(x), const long double complex: clogl(x), float: logf(x), double: log(x), long double: logl(x), float complex: clogf(x), double complex: clog(x), long double complex: clogl(x), default: 0)
#define __tg_log(x)   tg_log((x))


// ILOGB
#define tg_ilogb(x)   _Generic ((x), const float: ilogbf(x), const double: ilogb(x), const long double: ilogbl(x), float: ilogbf(x), double: ilogb(x), long double: ilogbl(x), default: 0)
#define __tg_ilogb(x)   tg_ilogb((x))


// LOG10
#define tg_log10(x)   _Generic ((x), const float: log10f(x), const double: log10(x), const long double: log10l(x), float: log10f(x), double: log10(x), long double: log10l(x), default: 0)
#define __tg_log10(x)   tg_log10((x))


// LOG1P
#define tg_log1p(x)   _Generic ((x), const float: log1pf(x), const double: log1p(x), const long double: log1pl(x), float: log1pf(x), double: log1p(x), long double: log1pl(x), default: 0)
#define __tg_log1p(x)   tg_log1p((x))


// LOG2
#define tg_log2(x)   _Generic ((x), const float: log2f(x), const double: log2(x), const long double: log2l(x), float: log2f(x), double: log2(x), long double: log2l(x), default: 0)
#define __tg_log2(x)   tg_log2((x))


// LOGB
#define tg_logb(x)   _Generic ((x), const float: logbf(x), const double: logb(x), const long double: logbl(x), float: logbf(x), double: logb(x), long double: logbl(x), default: 0)
#define __tg_logb(x)   tg_logb((x))


// POW
#define tg_pow(x, y)   _Generic ((x), const float: powf(x, y), const double: pow(x, y), const long double: powl(x, y), const float complex: cpowf(x, y), const double complex: cpow(x, y), const long double complex: cpowl(x, y), float: powf(x, y), double: pow(x, y), long double: powl(x, y), float complex: cpowf(x, y), double complex: cpow(x, y), long double complex: cpowl(x, y), default: 0)
#define __tg_pow(x, y)   tg_pow((x), (y))


// SQRT
#define tg_sqrt(x)   _Generic ((x), const float: sqrtf(x), const double: sqrt(x), const long double: sqrtl(x), const float complex: csqrtf(x), const double complex: csqrt(x), const long double complex: csqrtl(x), float: sqrtf(x), double: sqrt(x), long double: sqrtl(x), float complex: csqrtf(x), double complex: csqrt(x), long double complex: csqrtl(x), default: 0)
#define __tg_sqrt(x)   tg_sqrt((x))


// CBRT
#define tg_cbrt(x)   _Generic ((x), const float: cbrtf(x), const double: cbrt(x), const long double: cbrtl(x), float: cbrtf(x), double: cbrt(x), long double: cbrtl(x), default: 0)
#define __tg_cbrt(x)   tg_cbrt((x))


// FABS
#define tg_fabs(x)   _Generic ((x), const float: fabsf(x), const double: fabs(x), const long double: fabsl(x), const float complex: cfabsf(x), const double complex: cfabs(x), const long double complex: cfabsl(x), float: fabsf(x), double: fabs(x), long double: fabsl(x), float complex: cfabsf(x), double complex: cfabs(x), long double complex: cfabsl(x), default: 0)
#define __tg_fabs(x)   tg_fabs((x))


// CEIL
#define tg_ceil(x)   _Generic ((x), const float: ceilf(x), const double: ceil(x), const long double: ceill(x), float: ceilf(x), double: ceil(x), long double: ceill(x), default: 0)
#define __tg_ceil(x)   tg_ceil((x))


// FLOOR
#define tg_floor(x)   _Generic ((x), const float: floorf(x), const double: floor(x), const long double: floorl(x), float: floorf(x), double: floor(x), long double: floorl(x), default: 0)
#define __tg_floor(x)   tg_floor((x))


// TRUNC
#define tg_trunc(x)   _Generic ((x), const float: truncf(x), const double: trunc(x), const long double: truncl(x), float: truncf(x), double: trunc(x), long double: truncl(x), default: 0)
#define __tg_trunc(x)   tg_trunc((x))


// COPYSIGN
#define tg_copysign(x)   _Generic ((x), const float: copysignf(x), const double: copysign(x), const long double: copysignl(x), float: copysignf(x), double: copysign(x), long double: copysignl(x), default: 0)
#define __tg_copysign(x)   tg_copysign((x))


// NEARBYINT
#define tg_nearbyint(x)   _Generic ((x), const float: nearbyintf(x), const double: nearbyint(x), const long double: nearbyintl(x), float: nearbyintf(x), double: nearbyint(x), long double: nearbyintl(x), default: 0)
#define __tg_nearbyint(x)   tg_nearbyint((x))


// NEXTAFTER
#define tg_nextafter(x, y)   _Generic ((x), const float: nextafterf(x, y), const double: nextafter(x, y), const long double: nextafterl(x, y), float: nextafterf(x, y), double: nextafter(x, y), long double: nextafterl(x, y), default: 0)
#define __tg_nextafter(x, y)   tg_nextafter((x), (y))


// NEXTTOWARD
#define tg_nexttoward(x, y)   _Generic ((x), const float: nexttowardf(x, y), const double: nexttoward(x, y), const long double: nexttowardl(x, y), float: nexttowardf(x, y), double: nexttoward(x, y), long double: nexttowardl(x, y), default: 0)
#define __tg_nexttoward(x, y)   tg_nexttoward((x), (y))


// REMAINDER
#define tg_remainder(x, y)   _Generic ((x), const float: remainderf(x, y), const double: remainder(x, y), const long double: remainderl(x, y), float: remainderf(x, y), double: remainder(x, y), long double: remainderl(x, y), default: 0)
#define __tg_remainder(x, y)   tg_remainder((x), (y))


// REMQUO
#define tg_remquo(x, y, z)   _Generic ((x), const float: remquof(x, y, z), const double: remquo(x, y, z), const long double: remquol(x, y, z), float: remquof(x, y, z), double: remquo(x, y, z), long double: remquol(x, y, z), default: 0)
#define __tg_remquo(x, y, z)   tg_remquo((x), (y), (z))


// RINT
#define tg_rint(x)   _Generic ((x), const float: rintf(x), const double: rint(x), const long double: rintl(x), float: rintf(x), double: rint(x), long double: rintl(x), default: 0)
#define __tg_rint(x)   tg_rint((x))


// LRINT
#define tg_lrint(x)   _Generic ((x), const float: lrintf(x), const double: lrint(x), const long double: lrintl(x), float: lrintf(x), double: lrint(x), long double: lrintl(x), default: 0)
#define __tg_lrint(x)   tg_lrint((x))


// LLRINT
#define tg_llrint(x)   _Generic ((x), const float: llrintf(x), const double: llrint(x), const long double: llrintl(x), float: llrintf(x), double: llrint(x), long double: llrintl(x), default: 0)
#define __tg_llrint(x)   tg_llrint((x))


// ROUND
#define tg_round(x)   _Generic ((x), const float: roundf(x), const double: round(x), const long double: roundl(x), float: roundf(x), double: round(x), long double: roundl(x), default: 0)
#define __tg_round(x)   tg_round((x))


// LROUND
#define tg_lround(x)   _Generic ((x), const float: lroundf(x), const double: lround(x), const long double: lroundl(x), float: lroundf(x), double: lround(x), long double: lroundl(x), default: 0)
#define __tg_lround(x)   tg_lround((x))


// LLROUND
#define tg_llround(x)   _Generic ((x), const float: llroundf(x), const double: llround(x), const long double: llroundl(x), float: llroundf(x), double: llround(x), long double: llroundl(x), default: 0)
#define __tg_llround(x)   tg_llround((x))


// ERF
#define tg_erf(x)   _Generic ((x), const float: erff(x), const double: erf(x), const long double: erfl(x), float: erff(x), double: erf(x), long double: erfl(x), default: 0)
#define __tg_erf(x)   tg_erf((x))


// ERFC
#define tg_erfc(x)   _Generic ((x), const float: erfcf(x), const double: erfc(x), const long double: erfcl(x), float: erfcf(x), double: erfc(x), long double: erfcl(x), default: 0)
#define __tg_erfc(x)   tg_erfc((x))


// LGAMMA
#define tg_lgamma(x)   _Generic ((x), const float: lgammaf(x), const double: lgamma(x), const long double: lgammal(x), float: lgammaf(x), double: lgamma(x), long double: lgammal(x), default: 0)
#define __tg_lgamma(x)   tg_lgamma((x))


// TGAMMA
#define tg_tgamma(x)   _Generic ((x), const float: tgammaf(x), const double: tgamma(x), const long double: tgammal(x), float: tgammaf(x), double: tgamma(x), long double: tgammal(x), default: 0)
#define __tg_tgamma(x)   tg_tgamma((x))


// FDIM
#define tg_fdim(x)   _Generic ((x), const float: fdimf(x), const double: fdim(x), const long double: fdiml(x), float: fdimf(x), double: fdim(x), long double: fdiml(x), default: 0)
#define __tg_fdim(x)   tg_fdim((x))


// FMA
#define tg_fma(x, y, z)   _Generic ((x), const float: fmaf(x, y, z), const double: fma(x, y, z), const long double: fmal(x, y, z), float: fmaf(x, y, z), double: fma(x, y, z), long double: fmal(x, y, z), default: 0)
#define __tg_fma(x, y, z)   tg_fma((x), (y), (z))


// FMAX
#define tg_fmax(x, y)   _Generic ((x), const float: fmaxf(x, y), const double: fmax(x, y), const long double: fmaxl(x, y), float: fmaxf(x, y), double: fmax(x, y), long double: fmaxl(x, y), default: 0)
#define __tg_fmax(x, y)   tg_fmax((x), (y))


// FMIN
#define tg_fmin(x, y)   _Generic ((x), const float: fminf(x, y), const double: fmin(x, y), const long double: fminl(x, y), float: fminf(x, y), double: fmin(x, y), long double: fminl(x, y), default: 0)
#define __tg_fmin(x, y)   tg_fmin((x), (y))


// FMOD
#define tg_fmod(x, y)   _Generic ((x), const float: fmodf(x, y), const double: fmod(x, y), const long double: fmodl(x, y), float: fmodf(x, y), double: fmod(x, y), long double: fmodl(x, y), default: 0)
#define __tg_fmod(x, y)   tg_fmod((x), (y))


// FREXP
#define tg_frexp(x, y)   _Generic ((x), const float: frexpf(x, y), const double: frexp(x, y), const long double: frexpl(x, y), float: frexpf(x, y), double: frexp(x, y), long double: frexpl(x, y), default: 0)
#define __tg_frexp(x, y)   tg_frexp((x), (y))


// HYPOT
#define tg_hypot(x, y)   _Generic ((x), const float: hypotf(x, y), const double: hypot(x, y), const long double: hypotl(x, y), float: hypotf(x, y), double: hypot(x, y), long double: hypotl(x, y), default: 0)
#define __tg_hypot(x, y)   tg_hypot((x), (y))


// SCALBN
#define tg_scalbn(x, y)   _Generic ((x), const float: scalbnf(x, y), const double: scalbn(x, y), const long double: scalbnl(x, y), float: scalbnf(x, y), double: scalbn(x, y), long double: scalbnl(x, y), default: 0)
#define __tg_scalbn(x, y)   tg_scalbn((x), (y))


// SCALBLN
#define tg_scalbln(x, y)   _Generic ((x), const float: scalblnf(x, y), const double: scalbln(x, y), const long double: scalblnl(x, y), float: scalblnf(x, y), double: scalbln(x, y), long double: scalblnl(x, y), default: 0)
#define __tg_scalbln(x, y)   tg_scalbln((x), (y))


// CARG
#define tg_carg(x)   _Generic ((x), const float: atan2f(0.0F, x), const double: atan2(0.0, x), const long double: atan2l(0.0L, x), const float complex: cargf(x), const double complex: carg(x), const long double complex: cargl(x), float: atan2f(0.0F, x), double: atan2(0.0, x), long double: atan2l(0.0L, x), float complex: cargf(x), double complex: carg(x), long double complex: cargl(x), default: 0)
#define __tg_carg(x)   tg_carg((x))


// CIMAG
#define tg_cimag(x)   _Generic ((x), const float: 0, const double: 0, const long double: 0, const float complex: cimagf(x), const double complex: cimag(x), const long double complex: cimagl(x), float: 0, double: 0, long double: 0, float complex: cimagf(x), double complex: cimag(x), long double complex: cimagl(x), default: 0)
#define __tg_cimag(x)   tg_cimag((x))


// CONJ
#define tg_conj(x)   _Generic ((x), const float: x, const double: x, const long double: x, const float complex: conjf(x), const double complex: conj(x), const long double complex: conjl(x), float: x, double: x, long double: x, float complex: conjf(x), double complex: conj(x), long double complex: conjl(x), default: x)
#define __tg_conj(x)   tg_conj((x))


// CPROJ
#define tg_cproj(x)   _Generic ((x), const float: cprojf(x), const double: cproj(x), const long double: cprojl(x), const float complex: cprojf(x), const double complex: cproj(x), const long double complex: cprojl(x), float: cprojf(x), double: cproj(x), long double: cprojl(x), float complex: cprojf(x), double complex: cproj(x), long double complex: cprojl(x), default: x)
#define __tg_cproj(x)   tg_cproj((x))


// CREAL
#define tg_creal(x)   _Generic ((x), const float: x, const double: x, const long double: x, const float complex: crealf(x), const double complex: creal(x), const long double complex: creall(x), float: x, double: x, long double: x, float complex: crealf(x), double complex: creal(x), long double complex: creall(x), default: x)
#define __tg_creal(x)   tg_creal((x))


#endif  // TGMATH_H


/* INTSCAN (<intscan.h>) */


#if (!(defined(INTSCAN_H) || defined(_INTSCAN_H) || defined(INTSCAN_H_) || defined(_INTSCAN_H_)))
#define INTSCAN_H   (1)
#define _INTSCAN_H   (1)
#define INTSCAN_H_   (1)
#define _INTSCAN_H_   (1)


LIB_FUNC unsigned long long int intscan(FILE* f, const unsigned int _base, const int pok, const unsigned long long int lim) {
	if (_base > 36) { errno = EINVAL; return 0; }
	const unsigned char* val = integer_table + 1;
	int c, neg = 0;
	unsigned int x, base = _base;
	unsigned long long int y;
	do { c = shgetc(f); } while (isspace(c));
	if (c == '+' || c == '-') { neg = -(c == '-'); c = shgetc(f); }
	if ((base == 0 || base == 16) && c == '0') {
		c = shgetc(f);
		if ((c | 32) == 'x') {
			c = shgetc(f);
			if (val[c] >= 16) {
				shunget(f);
				if (pok) { shunget(f); }
				else { shlim(f, 0); }
				return 0;
			}
			base = 16;
		} else if (base == 0) { base = 8; }
	} else {
		if (base == 0) { base = 10; }
		if (val[c] >= base) {
			shunget(f);
			shlim(f, 0);
			errno = EINVAL;
			return 0;
		}
	}
	if (base == 10) {
		for (x = 0; ((c - '0') < 10) && x <= (unsigned int)(UINT_MAX / 10 - 1); c = shgetc(f)) { x = x * 10 + (unsigned int)(c - '0'); }
		for (y = x; (c - '0') < 10 && y <= (unsigned long long int)(ULLONG_MAX / 10) && (10 * y) <= ULLONG_MAX - (unsigned long long int)(c - '0'); c = shgetc(f)) { y = y * 10 + (unsigned long long int)(c - '0'); }
		if ((c - '0') >= 10) {
			shunget(f);
			if (y >= lim) {
				if (!(lim & 1) && (!neg)) { errno = ERANGE; return lim - 1; }
				else if (y > lim) { errno = ERANGE; return lim; }
			}
			return (unsigned long long int)((y ^ (unsigned long long int)neg) - (unsigned long long int)neg);
		}
	} else if (!(base & (base - 1))) {
		int bs = "\0\1\2\4\7\3\6\5"[(0x17 * base) >> 5 & 7];
		for (x = 0; val[c] < base && x <= UINT_MAX >> 5; c = shgetc(f)) { x = x << bs | val[c]; }
		for (y = x; val[c] < base && y <= ULLONG_MAX >> bs; c = shgetc(f)) { y = y << bs | val[c]; }
	} else {
		for (x = 0; val[c] < base && x <= UINT_MAX / 36 - 1; c = shgetc(f)) { x = x * base + val[c]; }
		for (y = x; val[c] < base && y <= ULLONG_MAX / base && base * y <= ULLONG_MAX - val[c]; c = shgetc(f)) { y = y * base + val[c]; }
	}
	if (val[c] < base) {
		for (; val[c] < base; c = shgetc(f));
		errno = ERANGE;
		y = lim;
		if (lim & 1) { neg = 0; }
	}
	shunget(f);
	if (y >= lim) {
		if (!(lim & 1) && !neg) { errno = ERANGE; return lim - 1; }
		else if (y > lim) { errno = ERANGE; return lim; }
	}
	return (unsigned long long int)((y ^ (unsigned long long int)neg) - (unsigned long long int)neg);
}
#define __intscan(f, base, pok, lim)   intscan((f), (base), (pok), (lim))


#endif  // INTSCAN_H


/* FLOATSCAN (<floatscan.h>) */


#if (!(defined(FLOATSCAN_H) || defined(FLOATSCAN_H_)))
#define FLOATSCAN_H   (1)
#define FLOATSCAN_H_   (1)


LIB_FUNC long long scanexp(FILE* f, const int pok) {
	int c = shgetc(f), x, neg = 0;
	long long y;
	if (c == '+' || c == '-') {
		neg = (c == '-');
		c = shgetc(f);
		if ((c - '0' >= 10) && pok) { shunget(f); }
	}
	if ((c - '0') >= 10) { shunget(f); return LLONG_MIN; }
	for (x = 0; (c - '0') < 10 && x < (int)(INT_MAX / 10); c = shgetc(f)) { x = 10 * x + (int)(c - '0'); }
	for (y = x; (c - '0') < 10 && y < (long long)(LLONG_MAX / 100); c = shgetc(f)) { y = 10 * y + (long long)(c - '0'); }
	for (; (c - '0') < 10; c = shgetc(f));
	shunget(f);
	return (long long)(neg ? (-y) : y);
}


LIB_FUNC long double decfloat(FILE* f, int c, int bits, const int emin, const int sign, const int pok) {
	uint32_t x[KMAX];
	static const uint32_t th[] = { LD_B1B_MAX };
	int i, j = 0, k = 0, a, z;
	long long lrp = 0, dc = 0, e10 = 0;
	int lnz = 0, gotdig = 0, gotrad = 0;
	int rp, e2, emax = (((-emin) - bits) + 3), denormal = 0;
	long double y, frac = 0.0L, bias = 0.0L;
	// Do not let leading zeros consume buffer space
	for (; c == '0'; c = shgetc(f)) { gotdig = 1; }
	if (c == '.') {
		gotrad = 1;
		for (c = shgetc(f); c == '0'; c = shgetc(f)) { gotdig = 1, --lrp; }
	}
	x[0] = 0;
	for (; (c - '0') < 10 || c == '.'; c = shgetc(f)) {
		if (c == '.') {
			if (gotrad) { break; }
			gotrad = 1;
			lrp = dc;
		} else if (k < KMAX - 3) {
			dc++;
			if (c != '0') { lnz = (int)dc; }
			if (j) { x[k] = x[k] * 10 + (uint32_t)(c - '0'); }
			else { x[k] = (uint32_t)(c - '0'); }
			if (++j == 9) { ++k; j = 0; }
			gotdig = 1;
		} else {
			++dc;
			if (c != '0') { x[KMAX - 4] |= 1; }
		}
	}
	if (!gotrad) { lrp = dc; }
	if (gotdig && (c | 32) == 'e') {
		e10 = scanexp(f, pok);
		if (e10 == LLONG_MIN) {
			if (pok) { shunget(f); }
			else { shlim(f, 0); return 0; }
			e10 = 0;
		}
		lrp += e10;
	} else if (c >= 0) { shunget(f); }
	if (!gotdig) {
		errno = EINVAL;
		shlim(f, 0);
		return 0;
	}
	// Handle zero specially to avoid nasty special cases later
	if (!x[0]) { return (sign * 0.0); }
	// Optimize small integers (w/no exponent) and over/under-flow
	else if (lrp == dc && dc < 10 && (bits > 30 || x[0] >> bits == 0)) {
		return sign * (long double)x[0];
	} else if (lrp > (-emin / 2)) {
		errno = ERANGE;
		return (sign * LDBL_MAX * LDBL_MAX);
	} else if (lrp < emin - 2 * LDBL_MANT_DIG) {
		errno = ERANGE;
		return sign * LDBL_MIN * LDBL_MIN;
	}
	// Align incomplete final B1B digit
	if (j) { for (; j < 9; j++) { x[k] *= 10; } ++k; j = 0; }
	a = 0;
	z = k;
	e2 = 0;
	rp = (int)lrp;
	/* Optimize small to mid-size integers (even in exp. notation) */
	if (lnz < 9 && lnz <= rp && rp < 18) {
		if (rp == 9) { return sign * (long double)x[0]; }
		else if (rp < 9) { return sign * (long double)x[0] / positive_tens[8 - rp]; }
		int bitlim = bits - 3 * (int)(rp - 9);
		if (bitlim > 30 || x[0] >> bitlim == 0) { return sign * (long double)x[0] * positive_tens[rp - 10]; }
	}
	/* Align radix point to B1B digit boundary */
	if (rp % 9) {
		int rpm9 = (rp >= 0 ? (rp % 9) : (rp % 9 + 9));
		int p10 = positive_tens[8 - rpm9];
		uint32_t carry = 0;
		for (k = a; k != z; k++) {
			uint32_t tmp = x[k] % (uint32_t)p10;
			x[k] = (x[k] / (uint32_t)p10) + carry;
			carry = (uint32_t)(1000000000 / p10) * tmp;
			if (k == a && !x[k]) { a = ((a + 1) & FLOAT_MASK); rp -= 9; }
		}
		if (carry) { x[z++] = carry; }
		rp += (9 - rpm9);
	}
	// Upscale until desired number of bits are left of radix point
	while (rp < 9 * LD_B1B_DIG || (rp == 9 * LD_B1B_DIG && x[a] < th[0])) {
		uint32_t carry = 0;
		e2 -= 29;
		for (k = ((z - 1) & FLOAT_MASK); ; k = ((k - 1) & FLOAT_MASK)) {
			uint64_t tmp = ((uint64_t)x[k] << 29) + carry;
			if (tmp > 1000000000) {
				carry = (uint32_t)(tmp / 1000000000);
				x[k] = (uint32_t)(tmp % 1000000000);
			} else {
				carry = 0;
				x[k] = (uint32_t)tmp;
			}
			if (k == ((z - 1) & FLOAT_MASK) && k != a && !x[k]) { z = k; }
			if (k == a) { break; }
		}
		if (carry) {
			rp += 9;
			a = ((a - 1) & FLOAT_MASK);
			if (a == z) { z = ((z - 1) & FLOAT_MASK); x[(z - 1) & FLOAT_MASK] |= x[z]; }
			x[a] = carry;
		}
	}
	// Downscale until exactly number of bits are left of radix point
	for (;;) {
		uint32_t carry = 0;
		int sh = 1;
		for (i = 0; i < LD_B1B_DIG; i++) {
			k = ((a + i) & FLOAT_MASK);
			if (k == z || x[k] < th[i]) { i = LD_B1B_DIG; break; }
			else if (x[(a + i) & FLOAT_MASK] > th[i]) { break; }
		}
		if (i == LD_B1B_DIG && rp == (9 * LD_B1B_DIG)) { break; }
		else if (rp > 9 + (9 * LD_B1B_DIG)) { sh = 9; }
		e2 += sh;
		for (k = a; k != z; k = ((k + 1) & FLOAT_MASK)) {
			uint32_t tmp = (uint32_t)(x[k] & (uint32_t)(1 << sh)) - 1;
			x[k] = (x[k] >> sh) + carry;
			carry = (uint32_t)(1000000000 >> sh) * tmp;
			if (k == a && (!x[k])) {
				a = ((a + 1) & FLOAT_MASK);
				--i;
				rp -= 9;
			}
		}
		if (carry) {
			if (((z + 1) & FLOAT_MASK) != a) { x[z] = carry; z = ((z + 1) & FLOAT_MASK); }
			else { x[(z - 1) & FLOAT_MASK] |= 1; }
		}
	}
	// Assemble desired bits into floating point variable
	for (y = i = 0; i < LD_B1B_DIG; i++) {
		if (((a + i) & FLOAT_MASK) == z) { x[(z = ((z + 1) & FLOAT_MASK))-1] = 0; }
		y = 1000000000.0L * y + x[(a + i) & FLOAT_MASK];
	}
	y *= sign;
	// Limit precision for denormal results
	if (bits > LDBL_MANT_DIG + e2 - emin) {
		bits = LDBL_MANT_DIG + e2 - emin;
		if (bits < 0) { bits = 0; }
		denormal = 1;
	}
	// Calculate bias term to force rounding, move out lower bits
	if (bits < LDBL_MANT_DIG) {
		bias = copysignl(scalbn(1, 2 * LDBL_MANT_DIG - bits - 1), y);
		frac = fmodl(y, scalbn(1, LDBL_MANT_DIG - bits));
		y -= frac;
		y += bias;
	}
	// Process tail of decimal input so it can affect rounding
	if (((a + i) & FLOAT_MASK) != z) {
		uint32_t t = x[(a + i) & FLOAT_MASK];
		if (t < 500000000 && (t || ((a + i + 1) & FLOAT_MASK) != z)) { frac += 0.25L * sign; }
		else if (t > 500000000) { frac += 0.75L * sign; }
		else if (t == 500000000) {
			if (((a + i + 1) & FLOAT_MASK) == z) { frac += 0.5L * sign; }
			else { frac += 0.75L * sign; }
		}
		if ((LDBL_MANT_DIG - bits) >= 2 && (!(fmodl(frac, 1)))) { frac++; }
	}
	y += frac;
	y -= bias;
	if (((e2 + LDBL_MANT_DIG) & INT_MAX) > (emax - 5)) {
		if (fabsl(y) >= CONCAT(0x1p, LDBL_MANT_DIG)) {
			if (denormal && bits == (LDBL_MANT_DIG + e2 - emin)) { denormal = 0; }
			y *= 0.5L;
			e2++;
		}
		if ((e2 + LDBL_MANT_DIG) > emax || (denormal && frac)) { errno = ERANGE; }
	}
	return scalbnl(y, e2);
}


LIB_FUNC long double hexfloat(FILE* f, int bits, const int emin, const int sign, const int pok) {
	uint32_t x = 0;
	long double y = 0.0L, scale = 1.0L, bias = 0.0L;
	int gottail = 0, gotrad = 0, gotdig = 0, d, c;
	long long rp = 0, dc = 0, e2 = 0;
	c = shgetc(f);
	// Skip leading zeros
	for (; c == '0'; c = shgetc(f)) { gotdig = 1; }
	if (c == '.') {
		gotrad = 1;
		c = shgetc(f);
		// Count zeros after the radix point before significand
		for (rp = 0; c == '0'; c = shgetc(f), rp--) { gotdig = 1; }
	}
	for (; (c - '0') < 10 || (c | 32) - 'a' < 6 || c == '.'; c = shgetc(f)) {
		if (c == '.') {
			if (gotrad) { break; }
			rp = dc;
			gotrad = 1;
		} else {
			gotdig = 1;
			if (c > '9') { d = (c | 32) + 10 - 'a'; }
			else { d = c - '0'; }
			if (dc < 8) { x = x * 16 + (uint32_t)d; }
			else if (dc < ((LDBL_MANT_DIG >> 2) + 1)) { y += d * (scale /= 16); }
			else if (d && !gottail) { y += 0.5L * scale; gottail = 1; }
			dc++;
		}
	}
	if (!gotdig) {
		shunget(f);
		if (pok) { shunget(f); if (gotrad) { shunget(f); } }
		else { shlim(f, 0); }
		return sign * 0.0L;
	}
	if (!gotrad) { rp = dc; }
	while (dc < 8) { x *= 16, ++dc; }
	if ((c | 32) == 'p') {
		e2 = scanexp(f, pok);
		if (e2 == LLONG_MIN) {
			if (pok) { shunget(f); }
			else { shlim(f, 0); return 0.0L; }
			e2 = 0;
		}
	} else { shunget(f); }
	e2 += 4 * rp - 32;
	if (!x) { return sign * 0.0L; }
	else if (e2 > -emin) {
		errno = ERANGE;
		return sign * LDBL_MAX * LDBL_MAX;
	} else if (e2 < emin - 2 * LDBL_MANT_DIG) {
		errno = ERANGE;
		return sign * LDBL_MIN * LDBL_MIN;
	}
	while (x < 0x80000000) {
		if (y >= 0.5L) { x += x + 1; y += y - 1; }
		else { x += x; y += y; }
		e2--;
	}
	if (bits > (32 + (int)e2 - emin)) { bits = (32 + (int)e2 - emin); if (bits < 0) { bits = 0; } }
	if (bits < LDBL_MANT_DIG) { bias = copysignl(scalbn(1, 32 + LDBL_MANT_DIG - bits - 1), sign); }
	if (bits < 32 && y && !(x&1)) { ++x; y = 0.0L; }
	y = bias + sign * (long double)x + sign * y;
	y -= bias;
	if (!y) { errno = ERANGE; }
	return scalbnl(y, (int)e2);
}


LIB_FUNC long double __floatscan(FILE* f, const int prec, const int pok) {
	int bits, emin, c;
	switch (prec) {
		case 0:
			bits = FLT_MANT_DIG;
			emin = FLT_MIN_EXP - bits;
			break;
		case 1:
			bits = DBL_MANT_DIG;
			emin = DBL_MIN_EXP - bits;
			break;
		case 2:
			bits = LDBL_MANT_DIG;
			emin = LDBL_MIN_EXP - bits;
			break;
		default:
			return 0.0L;
	}
	register size_t i;
	do { c = shgetc(f); } while (isspace(c));
	register int sign = 1;
	if (c == '+' || c == '-') {
		sign -= 2 * (c == '-');
		c = shgetc(f);
	}
	for (i = 0; i < 8 && (c | 32) == "infinity"[i]; i++) { if (i < 7) { c = shgetc(f); } }
	if (i == 3 || i == 8 || (i > 3 && pok)) {
		if (i != 8) {
			shunget(f);
			if (pok) { for (; i > 3; i--) { shunget(f); } }
		}
		return sign * INF;
	}
	if (!i) for (i = 0; i < 3 && (c | 32) == "nan"[i]; i++) { if (i < 2) { c = shgetc(f); } }
	if (i == 3) {
		if (shgetc(f) != '(') { shunget(f); return NANL; }
		for (i = 1; ; i++) {
			c = shgetc(f);
			if ((c - '0') < 10 || (c - 'A') < 26 || (c - 'a') < 26 || c == '_') { continue; }
			else if (c == ')') { return NANL; }
			shunget(f);
			if (!pok) {
				errno = EINVAL;
				shlim(f, 0);
				return 0.0L;
			}
			while (i--) { shunget(f); }
			return NANL;
		}
		return NANL;
	}
	if (i) {
		shunget(f);
		errno = EINVAL;
		shlim(f, 0);
		return 0.0L;
	} else if (c == '0') {
		c = shgetc(f);
		if ((c | 32) == 'x') { return hexfloat(f, bits, emin, sign, pok); }
		shunget(f);
		c = '0';
	}
	return decfloat(f, c, bits, emin, sign, pok);
}


#endif  // FLOATSCAN_H


/* PROCESS ACCOUNTING (<sys/acct.h>) */


#if (!(defined(_SYS_ACCT_H) || defined(_SYS_ACCT_H_)))
#define _SYS_ACCT_H   (1)
#define _SYS_ACCT_H_   (1)


#define ACCT_COMM   16
/** Has executed fork, but no exec */
#define AFORK   1
/** Used super-user privileges */
#define ASU   2
/** Dumped core */
#define ACORE   8
/** Killed by a signal */
#define AXSIG   0x10
#if IS_BIG_ENDIAN
/** Accounting file endianness */
#   define ACCT_BYTEORDER   0x80
#else
/** Accounting file endianness */
#   define ACCT_BYTEORDER   0
#endif
#define AHZ   100


struct attr_packed acct {
	char ac_flag;  // Flags
	uint16_t ac_uid;  // Real user ID
	uint16_t ac_gid;  // Real group ID
	uint16_t ac_tty;  // Controlling terminal
	uint32_t ac_btime;  // Beginning time
	comp_t ac_utime;  // User time
	comp_t ac_stime;  // System time
	comp_t ac_etime;  // Elapsed time
	comp_t ac_mem;  // Average memory usage
	comp_t ac_io;  // Chars transferred
	comp_t ac_rw;  // Blocks read or written
	comp_t ac_minflt;  // Minor pagefaults
	comp_t ac_majflt;  // Major pagefaults
	comp_t ac_swaps;  // Number of swaps
	uint32_t ac_exitcode;  // Process exitcode
	char ac_comm[ACCT_COMM + 1];  // Command name
	char ac_pad[10];  // Padding bytes
};


struct acct_v3 {
	char ac_flag;  // Flags
	char ac_version;  // Always set to ACCT_VERSION
	uint16_t ac_tty;  // Control Terminal
	uint32_t ac_exitcode;  // Exitcode
	uint32_t ac_uid;  // Real User ID
	uint32_t ac_gid;  // Real Group ID
	uint32_t ac_pid;  // Process ID
	uint32_t ac_ppid;  // Parent Process ID
	uint32_t ac_btime;  // Process Creation Time
	float ac_etime;  // Elapsed Time
	comp_t ac_utime;  // User Time
	comp_t ac_stime;  // System Time
	comp_t ac_mem;  // Average Memory Usage
	comp_t ac_io;  // Chars Transferred
	comp_t ac_rw;  // Blocks Read or Written
	comp_t ac_minflt;  // Minor Pagefaults
	comp_t ac_majflt;  // Major Pagefaults
	comp_t ac_swaps;  // Number of Swaps
	char ac_comm[ACCT_COMM];  // Command Name
};


/** Switch process accounting on and off */
LIB_FUNC int acct(const char* filename) {
	return (int)syscall(SYS_acct, (long)&filename);
}


#endif  // SYS_ACCT_H


/* PROCESS CONTROL (<sys/prctl.h>) */


#if (!(defined(_SYS_PRCTL_H) || defined(_SYS_PRCTL_H_)))
#define _SYS_PRCTL_H   (1)
#define _SYS_PRCTL_H_   (1)


#define PR_SET_PDEATHSIG   1
#define PR_GET_PDEATHSIG   2
#define PR_GET_DUMPABLE   3
#define PR_SET_DUMPABLE   4
#define PR_GET_UNALIGN   5
#define PR_SET_UNALIGN   6
#define PR_UNALIGN_NOPRINT   1
#define PR_UNALIGN_SIGBUS   2
#define PR_GET_KEEPCAPS   7
#define PR_SET_KEEPCAPS   8
#define PR_GET_FPEMU   9
#define PR_SET_FPEMU   10
#define PR_FPEMU_NOPRINT   1
#define PR_FPEMU_SIGFPE   2
#define PR_GET_FPEXC   11
#define PR_SET_FPEXC   12
#define PR_FP_EXC_SW_ENABLE   0x80
#define PR_FP_EXC_DIV   0x10000
#define PR_FP_EXC_OVF   0x20000
#define PR_FP_EXC_UND   0x40000
#define PR_FP_EXC_RES   0x80000
#define PR_FP_EXC_INV   0x100000
#define PR_FP_EXC_DISABLED   0
#define PR_FP_EXC_NONRECOV   1
#define PR_FP_EXC_ASYNC   2
#define PR_FP_EXC_PRECISE   3
#define PR_GET_TIMING   13
#define PR_SET_TIMING   14
#define PR_TIMING_STATISTICAL   0
#define PR_TIMING_TIMESTAMP   1
#define PR_SET_NAME   15
#define PR_GET_NAME   16
#define PR_GET_ENDIAN   19
#define PR_SET_ENDIAN   20
#define PR_ENDIAN_BIG   0
#define PR_ENDIAN_LITTLE   1
#define PR_ENDIAN_PPC_LITTLE   2
#define PR_GET_SECCOMP   21
#define PR_SET_SECCOMP   22
#define PR_CAPBSET_READ   23
#define PR_CAPBSET_DROP   24
#define PR_GET_TSC   25
#define PR_SET_TSC   26
#define PR_TSC_ENABLE   1
#define PR_TSC_SIGSEGV   2
#define PR_GET_SECUREBITS   27
#define PR_SET_SECUREBITS   28
#define PR_SET_TIMERSLACK   29
#define PR_GET_TIMERSLACK   30
#define PR_TASK_PERF_EVENTS_DISABLE   31
#define PR_TASK_PERF_EVENTS_ENABLE   32
#define PR_MCE_KILL   33
#define PR_MCE_KILL_CLEAR   0
#define PR_MCE_KILL_SET   1
#define PR_MCE_KILL_LATE   0
#define PR_MCE_KILL_EARLY   1
#define PR_MCE_KILL_DEFAULT   2
#define PR_MCE_KILL_GET   34
#define PR_SET_MM   35
#define PR_SET_MM_START_CODE   1
#define PR_SET_MM_END_CODE   2
#define PR_SET_MM_START_DATA   3
#define PR_SET_MM_END_DATA   4
#define PR_SET_MM_START_STACK   5
#define PR_SET_MM_START_BRK   6
#define PR_SET_MM_BRK   7
#define PR_SET_MM_ARG_START   8
#define PR_SET_MM_ARG_END   9
#define PR_SET_MM_ENV_START   10
#define PR_SET_MM_ENV_END   11
#define PR_SET_MM_AUXV   12
#define PR_SET_MM_EXE_FILE   13
#define PR_SET_MM_MAP   14
#define PR_SET_MM_MAP_SIZE   15
#define PR_SET_PTRACER   0x59616d61
#define PR_SET_PTRACER_ANY   (-1UL)
#define PR_SET_CHILD_SUBREAPER   36
#define PR_GET_CHILD_SUBREAPER   37
#define PR_SET_NO_NEW_PRIVS   38
#define PR_GET_NO_NEW_PRIVS   39
#define PR_GET_TID_ADDRESS   40
#define PR_SET_THP_DISABLE   41
#define PR_GET_THP_DISABLE   42
#define PR_MPX_ENABLE_MANAGEMENT   43
#define PR_MPX_DISABLE_MANAGEMENT   44
#define PR_SET_FP_MODE   45
#define PR_GET_FP_MODE   46
#define PR_FP_MODE_FR   1
#define PR_FP_MODE_FRE   2
#define PR_CAP_AMBIENT   47
#define PR_CAP_AMBIENT_IS_SET   1
#define PR_CAP_AMBIENT_RAISE   2
#define PR_CAP_AMBIENT_LOWER   3
#define PR_CAP_AMBIENT_CLEAR_ALL   4


typedef struct prctl_mm_map {
	uint64_t start_code, end_code, start_data, end_data;
	uint64_t start_brk, brk, start_stack;
	uint64_t arg_start, arg_end, env_start, env_end;
	uint64_t* auxv;
	uint32_t auxv_size, exe_fd;
} prctl_mm_map_t;


/** Control process execution */
LIB_FUNC int prctl(int op, ...) {
	unsigned long x[4] = { 0 };
	register int i;
	va_list ap;
	va_start(ap, op);
	for (i = 0; i < 4; i++) { x[i] = va_arg(ap, unsigned long); }
	va_end(ap);
	return (int)syscall(SYS_prctl, op, x[0], x[1], x[2], x[3]);
}


#ifdef SYS_arch_prctl
LIB_FUNC int arch_prctl(const int code, unsigned long addr) {
	return (int)syscall(SYS_arch_prctl, code, addr);
}
#endif


#endif  // SYS_PRCTL_H


/* 4.4BSD EXTRAS */


#if (!(defined(BSD44_EXTRAS_H) || defined(BSD44_EXTRAS_H_)))
#define BSD44_EXTRAS_H   (1)
#define BSD44_EXTRAS_H_   (1)


#ifndef TCSASOFT
/** 4.4BSD extension to set the software termios bits */
#   define TCSASOFT   0
#endif
#ifndef O_EXLOCK
/** 4.4BSD extension to provide lock values in the open call */
#   define O_EXLOCK   0
#endif
#ifndef O_SHLOCK
/** 4.4BSD extension to provide lock values in the open call */
#   define O_SHLOCK   0
#endif
#ifndef WCOREDUMP
/** 4.4BSD extension to determine if a program dropped core from the exit status */
#   define WCOREDUMP(X)   0
#endif


#endif  // BSD44_EXTRAS_H


/* CPIO (<cpio.h>) */


#if (!(defined(_CPIO_H) || defined(_CPIO_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/cpio.h.html
#define CPIO_H   (1)
#define _CPIO_H   (1)
#define _CPIO_H_   (1)


/** Socket */
#define C_ISSOCK   0140000
/** Symbolic link */
#define C_ISLNK   0120000
/** Reserved */
#define C_ISCTG   0110000
/** Regular file */
#define C_ISREG   0100000
/** Block special */
#define C_ISBLK   060000
/** Directory */
#define C_ISDIR   040000
/** Character special */
#define C_ISCHR   020000
/** FIFO */
#define C_ISFIFO   010000
/** Set user ID */
#define C_ISUID   04000
/** Set group ID */
#define C_ISGID   02000
/** On directories, restricted deletion flag */
#define C_ISVTX   01000
/** Read by owner */
#define C_IRUSR   0400
/** Write by owner */
#define C_IWUSR   0200
/** Execute by owner */
#define C_IXUSR   0100
/** Read by group */
#define C_IRGRP   040
/** Write by group */
#define C_IWGRP   020
/** Execute by group */
#define C_IXGRP   010
/** Read by others */
#define C_IROTH   4
/** Write by others */
#define C_IWOTH   2
/** Execute by others */
#define C_IXOTH   1
#define MAGIC   "070707"


#endif  // CPIO_H


/* TAR (<tar.h>) */


#if (!(defined(TAR_H) || defined(_TAR_H) || defined(_TAR_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/tar.h.html
#define TAR_H   (1)
#define _TAR_H   (1)
#define _TAR_H_   (1)


/** Set UID on execution */
#define TSUID   04000
/** Set GID on execution */
#define TSGID   02000
/** On directories, restricted deletion flag */
#define TSVTX   01000
/** Read by owner */
#define TUREAD   0400
/** Write by owner */
#define TUWRITE   0200
/** Execute/search by owner */
#define TUEXEC   0100
/** Read by group */
#define TGREAD   040
/** Write by group */
#define TGWRITE   020
/** Execute/search by group */
#define TGEXEC   010
/** Read by other */
#define TOREAD   4
/** Write by other */
#define TOWRITE   2
/** Execute/search by other */
#define TOEXEC   1
/** Regular file */
#define REGTYPE   '0'
/** Regular file */
#define AREGTYPE   '\0'
/** Link */
#define LNKTYPE   '1'
/** Symbolic link */
#define SYMTYPE   '2'
/** Special Character */
#define CHRTYPE   '3'
/** Special block */
#define BLKTYPE   '4'
/** Directory */
#define DIRTYPE   '5'
/** Special FIFO */
#define FIFOTYPE   '6'
/** Reserved */
#define CONTTYPE   '7'
/** ustar plus null byte */
#define TMAGIC   "ustar\0"
/** Length of TMAGIC */
#define TMAGLEN   6
#define TVERSION   "00"
/** Length of TVERSION */
#define TVERSLEN   2


#endif  // TAR_H


/* ELF HINTS (<elf-hints.h>) */


#if (!(defined(_ELF_HINTS_H) || defined(_ELF_HINTS_H_)))
#define _ELF_HINTS_H   (1)
#define _ELF_HINTS_H_   (1)


#define ELFHINTS_MAGIC   0x746e6845


/** Hints file produced by ldconfig */
typedef struct elfhints_hdr {
	uint32_t magic;  // Magic number
	uint32_t version;  // File version
	uint32_t strtab;  // Offset of string table in file
	uint32_t strsize;  // Size of string table
	uint32_t dirlist;  // Offset of directory list in string table
	uint32_t dirlistlen;  // strlen(dirlist)
	uint32_t spare[26];  // Room for expansion
} elfhints_hdr_t;


#endif  // ELF_HINTS_H


/* ELF TYPES, STRUCTURES, & MACROS (<elf.h>, <sys/elf_common.h>, <sys/elf32.h>, and <sys/elf64.h>) */


#if (!(defined(_ELF_H) || defined(_ELF_H_) || defined(_SYS_ELF_COMMON_H_) || defined(_SYS_ELF32_H_) || defined(_SYS_ELF64_H_)))
#define _ELF_H   (1)
#define _ELF_H_   (1)
#define _SYS_ELF32_H_   (1)
#define _SYS_ELF64_H_   (1)
#define _SYS_ELF_COMMON_H_   (1)


#define __ELF_NATIVE_CLASS   __WORDSIZE
#if WORDSIZE_IS_32
#   define WORD_WIDTH   (8)
#else
#   define WORD_WIDTH   (0x10)
#endif

#if  (defined(ALPHA) || (defined(S390) && IS_WORDSIZE_64))
/** Linux/Alpha is exceptional as it has .hash section with 64 bit entries */
typedef uint64_t   Elf_Symndx;
#else
/** Hash table entries usually have a size of 32 bits */
typedef uint32_t   Elf_Symndx;
#endif


typedef uint16_t   Elf32_Half;
typedef uint16_t   Elf64_Half;
typedef uint32_t   Elf32_Word;
typedef int32_t   Elf32_Sword;
typedef uint32_t   Elf64_Word;
typedef int32_t   Elf64_Sword;
typedef uint64_t   Elf32_Xword;
typedef int64_t   Elf32_Sxword;
typedef uint64_t   Elf64_Xword;
typedef int64_t   Elf64_Sxword;
typedef uint32_t   Elf32_Addr;
typedef uint64_t   Elf64_Addr;
/** Elf file offset (32-bit Elf) */
typedef uint32_t   Elf32_Off;
/** Elf file offset (64-bit Elf) */
typedef uint64_t   Elf64_Off;
/** 16-bit section indices in Elf files (32-bit Elf) */
typedef uint16_t   Elf32_Section;
/** 16-bit section indices in Elf files (64-bit Elf) */
typedef uint16_t   Elf64_Section;
/** Elf file version symbol information (32-bit Elf) */
typedef Elf32_Half   Elf32_Versym;
/** Elf file version symbol information (64-bit Elf) */
typedef Elf64_Half   Elf64_Versym;
/** Entries found in sections of type SHT_MIPS_CONFLICT */
typedef Elf32_Addr   Elf32_Conflict;


#define EI_NIDENT   (0x10)
// Extract and insert information held in ELF fields
#define ELF32_ST_BIND(val)   (((unsigned char)(val)) >> 4)
#define ELF32_ST_TYPE(val)   ((val) & 0xF)
#define ELF32_ST_INFO(bind, type)   (((bind) << 4) + ((type) & 0xF))
#define ELF32_ST_VISIBILITY(o)   ((o) & 3)
#define ELF64_ST_VISIBILITY(o)   ELF32_ST_VISIBILITY(o)
// Macros to construct move records
#define ELF32_M_SYM(info)   ((info) >> 8)
#define ELF32_M_SIZE(info)   ((unsigned char)(info))
#define ELF32_M_INFO(sym, size)   (((sym) << 8) + (unsigned char)(size))
#define ELF64_M_SYM(info)   ELF32_M_SYM (info)
#define ELF64_M_SIZE(info)   ELF32_M_SIZE (info)
#define ELF64_M_INFO(sym, size)   ELF32_M_INFO (sym, size)
// Extract and insert information held in the r_info field
#define ELF32_R_SYM(val)   ((val) >> 8)
#define ELF32_R_TYPE(val)   ((val) & 0xff)
#define ELF32_R_INFO(sym, type)   (((sym) << 8) + ((type) & 0xff))
#define ELF64_R_SYM(i)   ((i) >> 0x20)
#define ELF64_R_TYPE(i)   ((i) & 0xffffffff)
#define ELF64_R_INFO(sym,type)   ((((Elf64_Xword)(sym)) << 0x20) + (type))
// Legal values for p_flags (segment flags)
/** Segment is executable */
#define PF_X   (1)
/** Segment is writable */
#define PF_W   (2)
/** Segment is readable */
#define PF_R   (4)
/** Enable  PAGEEXEC */
#define PF_PAGEEXEC   (0x10)
/** Disable PAGEEXEC */
#define PF_NOPAGEEXEC   (0x20)
/** Enable  SEGMEXEC */
#define PF_SEGMEXEC   (0x40)
/** Disable SEGMEXEC */
#define PF_NOSEGMEXEC   (0x80)  // (1 << 7)
/** Enable  MPROTECT */
#define PF_MPROTECT   (0x100)  // (1 << 8)
/** Disable MPROTECT */
#define PF_NOMPROTECT   (0x200)
/** Enable  RANDEXEC */
#define PF_RANDEXEC   (0x400)
/** Disable RANDEXEC */
#define PF_NORANDEXEC   (0x800)
/** Enable  EMUTRAMP */
#define PF_EMUTRAMP   (0x1000)
/** Disable EMUTRAMP */
#define PF_NOEMUTRAMP   (0x2000)  // (1 << 13)
/** Enable  RANDMMAP */
#define PF_RANDMMAP   (0x4000)
/** Disable RANDMMAP */
#define PF_NORANDMMAP   (0x8000)  // (1 << 15)
/** OS-specific */
#define PF_MASKOS   0x0ff00000
/** Processor-specific */
#define PF_MASKPROC   0xf0000000
// Legal values for DT_MIPS_FLAGS Elf32_Dyn entry
/** No flags */
#define RHF_NONE   (0)
/** Use quickstart */
#define RHF_QUICKSTART   (1)
/** Hash size not power of 2 */
#define RHF_NOTPOT   (2)
/** Ignore LD_LIBRARY_PATH */
#define RHF_NO_LIBRARY_REPLACEMENT (4)
#define RHF_NO_MOVE   (8)  // (1 << 3)
#define RHF_SGI_ONLY   (0x10)  // (1 << 4)
#define RHF_GUARANTEE_INIT   (0x20)  // (1 << 5)
#define RHF_DELTA_C_PLUS_PLUS   (0x40)
#define RHF_GUARANTEE_START_INIT   (0x80)
#define RHF_PIXIE   (0x100)
#define RHF_DEFAULT_DELAY_LOAD   (0x200)
#define RHF_REQUICKSTART   (0x400)  // 1 << 10
#define RHF_REQUICKSTARTED   (0x800)
#define RHF_CORD   (0x1000)  // 1 << 12
#define RHF_NO_UNRES_UNDEF   (0x2000)
#define RHF_RLD_ORDER_SAFE   (0x4000)
// Legal values for l_flags
#define LL_NONE   (0)
/** Require exact match */
#define LL_EXACT_MATCH   (1)
/** Ignore interface version */
#define LL_IGNORE_INT_VER (2)
#define LL_REQUIRE_MINOR  (4)  // (1 << 2)
#define LL_EXPORTS   (8)  // (1 << 3)
#define LL_DELAY_LOAD   (0x10)  // (1 << 4)
#define LL_DELTA   (0x20)  // (1 << 5)


/** ELF file header */
typedef struct _Elf32_Ehdr {
	unsigned char e_ident[EI_NIDENT];  // Magic number and other info
	Elf32_Half e_type;  // Object file type
	Elf32_Half e_machine;  // Architecture
	Elf32_Word e_version;  // Object file version
	Elf32_Addr e_entry;  // Entry point virtual address
	Elf32_Off e_phoff;  // Program header table file offset
	Elf32_Off e_shoff;  // Section header table file offset
	Elf32_Word e_flags;  // Processor-specific flags
	Elf32_Half e_ehsize;  // ELF header size in bytes
	Elf32_Half e_phentsize;  // Program header table entry size
	Elf32_Half e_phnum;  // Program header table entry count
	Elf32_Half e_shentsize;  // Section header table entry size
	Elf32_Half e_shnum;  // Section header table entry count
	Elf32_Half e_shstrndx;  // Section header string table index
} Elf32_Ehdr;

/** ELF file header */
typedef struct _Elf64_Ehdr {
	unsigned char e_ident[EI_NIDENT];  // Magic number and other info
	Elf64_Half e_type;  // Object file type
	Elf64_Half e_machine;  // Architecture
	Elf64_Word e_version;  // Object file version
	Elf64_Addr e_entry;  // Entry point virtual address
	Elf64_Off e_phoff;  // Program header table file offset
	Elf64_Off e_shoff;  // Section header table file offset
	Elf64_Word e_flags;  // Processor-specific flags
	Elf64_Half e_ehsize;  // ELF header size in bytes
	Elf64_Half e_phentsize;  // Program header table entry size
	Elf64_Half e_phnum;  // Program header table entry count
	Elf64_Half e_shentsize;  // Section header table entry size
	Elf64_Half e_shnum;  // Section header table entry count
	Elf64_Half e_shstrndx;  // Section header string table index
} Elf64_Ehdr;

#define EI_MAG0   0  // File identification byte 0 index
#define ELFMAG0   0x7F  // Magic number byte 0
#define EI_MAG1   1  // File identification byte 1 index
#define ELFMAG1   'E'  // Magic number byte 1
#define EI_MAG2   2  // File identification byte 2 index
#define ELFMAG2   'L'  // Magic number byte 2
#define EI_MAG3   3  // File identification byte 3 index
#define ELFMAG3   'F'  // Magic number byte 3
#define ELFMAG   "\177ELF"
#define SELFMAG   4
#if IS_LITTLE_ENDIAN
#   define ELFMAG_U32   ((uint32_t)(ELFMAG0 + 0x100 * (ELFMAG1 + (0x100 * (ELFMAG2 + 0x100 * ELFMAG3)))))
#else  // BIG_ENDIAN
#   define ELFMAG_U32   ((uint32_t)((((ELFMAG0 * 0x100) + ELFMAG1) * 0x100 + ELFMAG2) * 0x100 + ELFMAG3))
#endif

/** File class byte index */
#define EI_CLASS   4
/** Invalid class */
#define ELFCLASSNONE   0
/** 32-bit objects */
#define ELFCLASS32   1
/** 64-bit objects */
#define ELFCLASS64   2
#define ELFCLASSNUM   3
/** Data encoding byte index */
#define EI_DATA   5
/** Invalid data encoding */
#define ELFDATANONE   0
/** 2's complement, little endian */
#define ELFDATA2LSB   1
/** 2's complement, big endian */
#define ELFDATA2MSB   2
#define ELFDATANUM   3
/** File version byte index */
#define EI_VERSION   6
/** OS ABI identification */
#define EI_OSABI   7
/** UNIX System V ABI */
#define ELFOSABI_NONE   0
/** Alias */
#define ELFOSABI_SYSV   0
/** HP-UX */
#define ELFOSABI_HPUX   1
/** NetBSD */
#define ELFOSABI_NETBSD   2
/** Linux */
#define ELFOSABI_LINUX   3
/** GNU/Hurd */
#define ELFOSABI_HURD   4
/** Sun Solaris */
#define ELFOSABI_SOLARIS   6
/** IBM AIX */
#define ELFOSABI_AIX   7
/** SGI Irix */
#define ELFOSABI_IRIX   8
/** FreeBSD */
#define ELFOSABI_FREEBSD   9
/** Compaq TRU64 UNIX */
#define ELFOSABI_TRU64   10
/** Novell Modesto */
#define ELFOSABI_MODESTO   11
/** OpenBSD */
#define ELFOSABI_OPENBSD   12
/** OpenVMS */
#define ELFOSABI_OPENVMS   13
/** Hewlett-Packard Non-Stop Kernel */
#define ELFOSABI_NSK   14
/** Amiga Research OS */
#define ELFOSABI_AROS   15
/** ARM */
#define ELFOSABI_ARM   97
/** Standalone (embedded) application */
#define ELFOSABI_STANDALONE   255
/** ABI version */
#define EI_ABIVERSION   8
/** Byte index of padding bytes */
#define EI_PAD   9
// Legal values for e_type (object file type)
/** No file type */
#define ET_NONE   0
/** Relocatable file */
#define ET_REL   1
/** Executable file */
#define ET_EXEC   2
/** Shared object file */
#define ET_DYN   3
/** Core file */
#define ET_CORE   4
/** Number of defined types */
#define ET_NUM   5
/** OS-specific range start */
#define ET_LOOS   0xfe00
/** OS-specific range end */
#define ET_HIOS   0xfeff
/** Processor-specific range start */
#define ET_LOPROC   0xff00
/** Processor-specific range end */
#define ET_HIPROC   0xffff
// Legal values for e_machine (architecture)
/** No machine */
#define EM_NONE   0
/** AT&T WE 32100 */
#define EM_M32   1
/** SUN SPARC */
#define EM_SPARC   2
/** Intel 80386 */
#define EM_386   3
/** Motorola m68k family */
#define EM_68K   4
/** Motorola m88k family */
#define EM_88K   5
/** Intel 80486 *//** Reserved for future use */
#define EM_486   6
/** Intel 80860 */
#define EM_860   7
/** MIPS R3000 big-endian */
#define EM_MIPS   8
/** IBM System/370 */
#define EM_S370   9
/** MIPS R3000 little-endian */
#define EM_MIPS_RS3_LE   10
/** HPPA */
#define EM_PARISC   15
/** Fujitsu VPP500 */
#define EM_VPP500   17
/** Sun's "v8plus" */
#define EM_SPARC32PLUS   18
/** Intel 80960 */
#define EM_960   19
/** PowerPC */
#define EM_PPC   20
/** PowerPC 64-bit */
#define EM_PPC64   21
/** IBM S390 */
#define EM_S390   22
/** NEC V800 series */
#define EM_V800   36
/** Fujitsu FR20 */
#define EM_FR20   37
/** TRW RH-32 */
#define EM_RH32   38
/** Motorola M*Core */
#define EM_MCORE   39
/** Old name for MCore */
#define EM_RCE   39
/** ARM */
#define EM_ARM   40
/** Digital Alpha */
#define EM_FAKE_ALPHA   41
/** Renesas SH */
#define EM_SH   42
/** SPARC v9 64-bit */
#define EM_SPARCV9   43
/** Siemens Tricore */
#define EM_TRICORE   44
/** Argonaut RISC Core */
#define EM_ARC   45
/** Renesas H8/300 */
#define EM_H8_300   46
/** Renesas H8/300H */
#define EM_H8_300H   47
/** Renesas H8S */
#define EM_H8S   48
/** Renesas H8/500 */
#define EM_H8_500   49
/** Intel Merced */
#define EM_IA_64   50
/** Stanford MIPS-X */
#define EM_MIPS_X   51
/** Motorola Coldfire */
#define EM_COLDFIRE   52
/** Motorola M68HC12 */
#define EM_68HC12   53
/** Fujitsu MMA Multimedia Accelerator*/
#define EM_MMA   54
/** Siemens PCP */
#define EM_PCP   55
/** Sony nCPU embeeded RISC */
#define EM_NCPU   56
/** Denso NDR1 microprocessor */
#define EM_NDR1   57
/** Motorola Start*Core processor */
#define EM_STARCORE   58
/** Toyota ME16 processor */
#define EM_ME16   59
/** STMicroelectronic ST100 processor */
#define EM_ST100   60
/** Advanced Logic Corp. Tinyj emb.fam*/
#define EM_TINYJ   61
/** AMD x86-64 architecture */
#define EM_X86_64   62
/** Sony DSP Processor */
#define EM_PDSP   63
/** Siemens FX66 microcontroller */
#define EM_FX66   66
/** STMicroelectronics ST9+ 8/16 mc */
#define EM_ST9PLUS   67
/** STmicroelectronics ST7 8 bit mc */
#define EM_ST7   68
/** Motorola MC68HC16 microcontroller */
#define EM_68HC16   69
/** Motorola MC68HC11 microcontroller */
#define EM_68HC11   70
/** Motorola MC68HC08 microcontroller */
#define EM_68HC08   71
/** Motorola MC68HC05 microcontroller */
#define EM_68HC05   72
/** Silicon Graphics SVx */
#define EM_SVX   73
/** STMicroelectronics ST19 8 bit mc */
#define EM_ST19   74
/** Digital VAX */
#define EM_VAX   75
/** Axis Communications 32-bit embedded processor */
#define EM_CRIS   76
/** Infineon Technologies 32-bit embedded processor */
#define EM_JAVELIN   77
/** Element 14 64-bit DSP Processor */
#define EM_FIREPATH   78
/** LSI Logic 16-bit DSP Processor */
#define EM_ZSP   79
/** Donald Knuth's educational 64-bit processor */
#define EM_MMIX   80
/** Harvard University machine-independent object files */
#define EM_HUANY   81
/** SiTera Prism */
#define EM_PRISM   82
/** Atmel AVR 8-bit microcontroller */
#define EM_AVR   83
/** Fujitsu FR30 */
#define EM_FR30   84
/** Mitsubishi D10V */
#define EM_D10V   85
/** Mitsubishi D30V */
#define EM_D30V   86
/** NEC v850 */
#define EM_V850   87
/** Renesas M32R */
#define EM_M32R   88
/** Matsushita MN10300 */
#define EM_MN10300   89
/** Matsushita MN10200 */
#define EM_MN10200   90
/** picoJava */
#define EM_PJ   91
/** OpenRISC 32-bit embedded processor */
#define EM_OPENRISC   92
/** ARC Cores Tangent-A5 */
#define EM_ARC_A5   93
/** Tensilica Xtensa Architecture */
#define EM_XTENSA   94
/** Ubicom IP2022 micro controller */
#define EM_IP2K   101
/** National Semiconductor CompactRISC */
#define EM_CR   103
/** TI msp430 micro controller */
#define EM_MSP430   105
/** Analog Devices Blackfin */
#define EM_BLACKFIN   106
/** Altera Nios II soft-core processor */
#define EM_ALTERA_NIOS2   113
/** National Semiconductor CRX */
#define EM_CRX   114
#define EM_NUM   95
#define EM_TI_C6000   140
// Unofficial Values
/** picoJava */
#define EM_PJ_OLD   99
/** Cygnus PowerPC ELF backend */
#define EM_CYGNUS_POWERPC 0x9025
/** Old version of Sparc v9, from before the ABI */
#define EM_OLD_SPARCV9   11
/** Old version of PowerPC */
#define EM_PPC_OLD   17
/** (Deprecated) Temporary number for the OpenRISC processor */
#define EM_OR32   0x8472
/** Renesas M32C and M16C */
#define EM_M32C   0xFEB0
/** Cygnus M32R ELF backend */
#define EM_CYGNUS_M32R   0x9041
/** old S/390 backend magic number */
#define EM_S390_OLD   0xa390
/** D10V backend magic number */
#define EM_CYGNUS_D10V   0x7650
/** D30V backend magic number */
#define EM_CYGNUS_D30V   0x7676
/** V850 backend magic number */
#define EM_CYGNUS_V850   0x9080
/** mn10200 and mn10300 backend magic numbers */
#define EM_CYGNUS_MN10200   0xdead
#define EM_CYGNUS_MN10300   0xbeef
/** FR30 magic number - no EABI available */
#define EM_CYGNUS_FR30   0x3330
/** AVR magic number */
#define EM_AVR_OLD   0x1057
/** OpenRISC magic number */
#define EM_OPENRISC_OLD   0x3426
/** DLX magic number */
#define EM_DLX   0x5aa5
#define EM_XSTORMY16   0xad45
/** FRV magic number */
#define EM_CYGNUS_FRV   0x5441
/** Ubicom IP2xxx */
#define EM_IP2K_OLD   0x8217
 /** Morpho MT */
#define EM_MT   0x2530
/** MSP430 magic number */
#define EM_MSP430_OLD   0x1059
/** Vitesse IQ2000 */
#define EM_IQ2000   0xFEBA
/** Old, unofficial value for Xtensa */
#define EM_XTENSA_OLD   0xabc7
/** Alpha backend magic number */
#define EM_ALPHA   0x9026
/** NIOS magic number - no EABI available */
#define EM_NIOS32   0xFEBB
/** AVR32 magic number from ATMEL */
#define EM_AVR32   0x18ad
/** V850 backend magic number */
#define EM_CYGNUS_V850   0x9080
/** Xilinx Microblaze (unofficial); Note that there is now an official microblaze magic number, but all the toolchains currently in existence use the old number */
#define EM_MICROBLAZE_OLD   0xbaab
/** Xilinx Microblaze (official) */
#define EM_MICROBLAZE   189
// Legal values for e_version (version)
/** Invalid ELF version */
#define EV_NONE   0
/** Current version */
#define EV_CURRENT   1
#define EV_NUM   2

/** Elf Section Header */
typedef struct _Elf32_Shdr {
	Elf32_Word   sh_name;  // Section name (string tbl index)
	Elf32_Word   sh_type;  // Section type
	Elf32_Word   sh_flags;  // Section flags
	Elf32_Addr   sh_addr;  // Section virtual addr at execution
	Elf32_Off   sh_offset;  // Section file offset
	Elf32_Word   sh_size;  // Section size in bytes
	Elf32_Word   sh_link;  // Link to another section
	Elf32_Word   sh_info;  // Additional section information
	Elf32_Word   sh_addralign;  // Section alignment
	Elf32_Word   sh_entsize;  // Entry size if section holds table
} Elf32_Shdr;

/** Elf Section Header */
typedef struct _Elf64_Shdr {
	Elf64_Word   sh_name;  // Section name (string tbl index)
	Elf64_Word   sh_type;  // Section type
	Elf64_Xword   sh_flags;  // Section flags
	Elf64_Addr   sh_addr;  // Section virtual addr at execution
	Elf64_Off   sh_offset;  // Section file offset
	Elf64_Xword   sh_size;  // Section size in bytes
	Elf64_Word   sh_link;  // Link to another section
	Elf64_Word   sh_info;  // Additional section information
	Elf64_Xword   sh_addralign;  // Section alignment
	Elf64_Xword   sh_entsize;  // Entry size if section holds table
} Elf64_Shdr;

// Special Section Indices
/** Undefined section */
#define SHN_UNDEF   0
/** Start of reserved indices */
#define SHN_LORESERVE   0xff00
/** Start of processor-specific */
#define SHN_LOPROC   0xff00
/** Order section before all others (Solaris) */
#define SHN_BEFORE   0xff00
/** Order section after all others (Solaris) */
#define SHN_AFTER   0xff01
/** End of processor-specific */
#define SHN_HIPROC   0xff1f
/** Start of OS-specific */
#define SHN_LOOS   0xff20
/** End of OS-specific */
#define SHN_HIOS   0xff3f
/** Associated symbol is absolute */
#define SHN_ABS   0xfff1
/** Associated symbol is common */
#define SHN_COMMON   0xfff2
/** Index is in extra table */
#define SHN_XINDEX   0xffff
/** End of reserved indices */
#define SHN_HIRESERVE   0xffff
// Legal values for sh_type (section type)
/** Section header table entry unused */
#define SHT_NULL   0
/** Program data */
#define SHT_PROGBITS   1
/** Symbol table */
#define SHT_SYMTAB   2
/** String table */
#define SHT_STRTAB   3
/** Relocation entries with addends */
#define SHT_RELA   4
/** Symbol hash table */
#define SHT_HASH   5
/** Dynamic linking information */
#define SHT_DYNAMIC   6
/** Notes */
#define SHT_NOTE   7
/** Program space with no data (bss) */
#define SHT_NOBITS   8
/** Relocation entries, no addends */
#define SHT_REL   9
/** Reserved */
#define SHT_SHLIB   10
/** Dynamic linker symbol table */
#define SHT_DYNSYM   11
/** Array of constructors */
#define SHT_INIT_ARRAY   14
/** Array of destructors */
#define SHT_FINI_ARRAY   15
/** Array of pre-constructors */
#define SHT_PREINIT_ARRAY 16
/** Section group */
#define SHT_GROUP   17
/** Extended section indeces */
#define SHT_SYMTAB_SHNDX   18
/** Number of defined types */
#define SHT_NUM   19
/** Start OS-specific */
#define SHT_LOOS   0x60000000
/** GNU-style hash table */
#define SHT_GNU_HASH   0x6ffffff6
/** Prelink library list */
#define SHT_GNU_LIBLIST   0x6ffffff7
/** Checksum for DSO content */
#define SHT_CHECKSUM   0x6ffffff8
/** Sun-specific low bound */
#define SHT_LOSUNW   0x6ffffffa
#define SHT_SUNW_move   0x6ffffffa
#define SHT_SUNW_COMDAT   0x6ffffffb
#define SHT_SUNW_syminfo  0x6ffffffc
/** Version definition section */
#define SHT_GNU_verdef   0x6ffffffd
/** Version needs section */
#define SHT_GNU_verneed   0x6ffffffe
/** Version symbol table */
#define SHT_GNU_versym   0x6fffffff
/** Sun-specific high bound */
#define SHT_HISUNW   0x6fffffff
/** End OS-specific type */
#define SHT_HIOS   0x6fffffff
/** Start of processor-specific */
#define SHT_LOPROC   0x70000000
/** End of processor-specific */
#define SHT_HIPROC   0x7fffffff
/** Start of application-specific */
#define SHT_LOUSER   0x80000000
/** End of application-specific */
#define SHT_HIUSER   0x8fffffff
// Legal values for sh_flags (section flags)
/** Writable */
#define SHF_WRITE   (1)
/** Occupies memory during execution */
#define SHF_ALLOC   (2)
/** Executable */
#define SHF_EXECINSTR   (4)
/** Might be merged */
#define SHF_MERGE   (0x10)
/** Contains nul-terminated strings */
#define SHF_STRINGS   (0x20)
/** `sh_info` contains SHT index */
#define SHF_INFO_LINK   (0x40)
/** Preserve order after combining */
#define SHF_LINK_ORDER   (0x80)
/** Non-standard OS specific handling required */
#define SHF_OS_NONCONFORMING (0x100)
/** Section is member of a group */
#define SHF_GROUP   (0x200)
/** Section hold thread-local data */
#define SHF_TLS   (0x400)
/** OS-specific */
#define SHF_MASKOS   (0x0FF00000)
/** Processor-specific */
#define SHF_MASKPROC   (0xF0000000)
/** Special ordering requirement (Solaris) */
#define SHF_ORDERED   (0x40000000)
/** Section is excluded unless referenced or allocated (Solaris) */
#define SHF_EXCLUDE   (0x80000000)
// Section group handling
/** Mark group as COMDAT */
#define GRP_COMDAT   (1)

/** Symbol table entry */
typedef struct _Elf32_Sym {
	Elf32_Word st_name;  // Symbol name (string tbl index)
	Elf32_Addr st_value;  // Symbol value
	Elf32_Word st_size;  // Symbol size
	unsigned char st_info;  // Symbol type and binding
	unsigned char st_other;  // Symbol visibility
	Elf32_Section st_shndx;  // Section index
} Elf32_Sym;

/** Symbol table entry */
typedef struct _Elf64_Sym {
	Elf64_Word st_name;  // Symbol name (string tbl index)
	unsigned char st_info;  // Symbol type and binding
	unsigned char st_other;  // Symbol visibility
	Elf64_Section st_shndx;  // Section index
	Elf64_Addr st_value;  // Symbol value
	Elf64_Xword st_size;  // Symbol size
} Elf64_Sym;

/** The syminfo section (if available) contains additional information about every dynamic symbol */
typedef struct _Elf32_Syminfo {
	Elf32_Half si_boundto;  // Direct bindings, symbol bound to
	Elf32_Half si_flags;  // Per symbol flags
} Elf32_Syminfo;

/** The syminfo section (if available) contains additional information about every dynamic symbol */
typedef struct _Elf64_Syminfo {
	Elf64_Half si_boundto;  // Direct bindings, symbol bound to
	Elf64_Half si_flags;  // Per symbol flags
} Elf64_Syminfo;

// Possible values for si_boundto
/** Symbol bound to self */
#define SYMINFO_BT_SELF   0xffff
/** Symbol bound to parent */
#define SYMINFO_BT_PARENT   0xfffe
/** Beginning of reserved entries */
#define SYMINFO_BT_LOWRESERVE   0xff00
// Possible bitmasks for si_flags
/** Direct bound symbol */
#define SYMINFO_FLG_DIRECT   1
/** Pass-thru symbol for translator */
#define SYMINFO_FLG_PASSTHRU   2
/** Symbol is a copy-reloc */
#define SYMINFO_FLG_COPY   4
/** Symbol bound to object to be lazy loaded */
#define SYMINFO_FLG_LAZYLOAD   8
// Syminfo version values
#define SYMINFO_NONE   0
#define SYMINFO_CURRENT   1
#define SYMINFO_NUM   2
// Both Elf32_Sym and Elf64_Sym use the same one-byte st_info field
#define ELF64_ST_BIND(val)   ELF32_ST_BIND(val)
#define ELF64_ST_TYPE(val)   ELF32_ST_TYPE(val)
#define ELF64_ST_INFO(bind, type)   ELF32_ST_INFO((bind), (type))
// Legal values for ST_BIND subfield of st_info (symbol binding)
#define STB_GNU_UNIQUE   10
/** Local symbol */
#define STB_LOCAL   0
/** Global symbol */
#define STB_GLOBAL   1
/** Weak symbol */
#define STB_WEAK   2
/** Number of defined types */
#define STB_NUM   3
/** Start of OS-specific */
#define STB_LOOS   10
/** End of OS-specific */
#define STB_HIOS   12
/** Start of processor-specific */
#define STB_LOPROC   13
/** End of processor-specific */
#define STB_HIPROC   15
// Legal values for ST_TYPE subfield of st_info (symbol type)
/** Symbol type is unspecified */
#define STT_NOTYPE   0
/** Symbol is a data object */
#define STT_OBJECT   1
/** Symbol is a code object */
#define STT_FUNC   2
/** Symbol associated with a section */
#define STT_SECTION   3
/** Symbol's name is file name */
#define STT_FILE   4
/** Symbol is a common data object */
#define STT_COMMON   5
#define STT_TLS   6  /** Symbol is thread-local data object*/
/** Number of defined types */
#define STT_NUM   7
/** Start of OS-specific */
#define STT_LOOS   10
#define STT_GNU_IFUNC   10
/** End of OS-specific */
#define STT_HIOS   12
/** Start of processor-specific */
#define STT_LOPROC   13
/** End of processor-specific */
#define STT_HIPROC   15
/** End of a chain; Symbol table indices are found in the hash buckets and chain table of a symbol hash table section; This special index value indicates the end of a chain, meaning no further symbols are found in that bucket */
#define STN_UNDEF   0

// Symbol visibility specification encoded in the st_other field
/** Default symbol visibility rules */
#define STV_DEFAULT   0
/** Processor specific hidden class */
#define STV_INTERNAL   1
/** Sym unavailable in other modules */
#define STV_HIDDEN   2
/** Not preemptible, not exported */
#define STV_PROTECTED   3

/** Relocation table entry without addend (in section of type SHT_REL) */
typedef struct _Elf32_Rel {
	Elf32_Addr r_offset;  // Address
	Elf32_Word r_info;  // Relocation type and symbol index
} Elf32_Rel;

/** Relocation table entry without addend (in section of type SHT_REL) */
typedef struct _Elf64_Rel {  // used on Sparc v9, MIPS, and Alpha
	Elf64_Addr r_offset;  // Address
	Elf64_Xword r_info;  // Relocation type and symbol index
} Elf64_Rel;

/** Relocation table entry with addend (in section of type SHT_RELA) */
typedef struct _Elf32_Rela {
	Elf32_Addr r_offset;  // Address
	Elf32_Word r_info;  // Relocation type and symbol index
	Elf32_Sword r_addend;  // Addend
} Elf32_Rela;

/** Relocation table entry with addend (in section of type SHT_RELA) */
typedef struct _Elf64_Rela {
	Elf64_Addr r_offset;  // Address
	Elf64_Xword r_info;  // Relocation type and symbol index
	Elf64_Sxword r_addend;  // Addend
} Elf64_Rela;

/** Program Segment Header */
typedef struct _Elf32_Phdr {
	Elf32_Word p_type;  // Segment type
	Elf32_Off p_offset;  // Segment file offset
	Elf32_Addr p_vaddr;  // Segment virtual address
	Elf32_Addr p_paddr;  // Segment physical address
	Elf32_Word p_filesz;  // Segment size in file
	Elf32_Word p_memsz;  // Segment size in memory
	Elf32_Word p_flags;  // Segment flags
	Elf32_Word p_align;  // Segment alignment
} Elf32_Phdr;

/** Program Segment Header */
typedef struct _Elf64_Phdr {
	Elf64_Word p_type;  // Segment type
	Elf64_Word p_flags;  // Segment flags
	Elf64_Off p_offset;  // Segment file offset
	Elf64_Addr p_vaddr;  // Segment virtual address
	Elf64_Addr p_paddr;  // Segment physical address
	Elf64_Xword p_filesz;  // Segment size in file
	Elf64_Xword p_memsz;  // Segment size in memory
	Elf64_Xword p_align;  // Segment alignment
} Elf64_Phdr;

// Legal values for p_type (segment type)
/** Program header table entry unused */
#define PT_NULL   0
/** Loadable program segment */
#define PT_LOAD   1
/** Dynamic linking information */
#define PT_DYNAMIC   2
/** Program interpreter */
#define PT_INTERP   3
/** Auxiliary information */
#define PT_NOTE   4
/** Reserved */
#define PT_SHLIB   5
/** Entry for header table itself */
#define PT_PHDR   6
/** Thread-local storage segment */
#define PT_TLS   7
/** Number of defined types */
#define PT_NUM   8
/** Start of OS-specific */
#define PT_LOOS   0x60000000
/** GCC .eh_frame_hdr segment */
#define PT_GNU_EH_FRAME   0x6474e550
/** Indicates stack executability */
#define PT_GNU_STACK   0x6474e551
/** Read-only after relocation */
#define PT_GNU_RELRO   0x6474e552
/** Indicates PaX flag markings */
#define PT_PAX_FLAGS   0x65041580
#define PT_LOSUNW   0x6ffffffa
/** Sun Specific segment */
#define PT_SUNWBSS   0x6ffffffa
/** Stack segment */
#define PT_SUNWSTACK   0x6ffffffb
#define PT_HISUNW   0x6fffffff
/** End of OS-specific */
#define PT_HIOS   0x6fffffff
/** Start of processor-specific */
#define PT_LOPROC   0x70000000
/** End of processor-specific */
#define PT_HIPROC   0x7fffffff
// Legal values for note segment descriptor types for core files
/** Contains copy of prstatus struct */
#define NT_PRSTATUS   1
/** Contains copy of fpregset struct */
#define NT_FPREGSET   2
/** Contains copy of prpsinfo struct */
#define NT_PRPSINFO   3
/** Contains copy of prxregset struct */
#define NT_PRXREG   4
/** Contains copy of task structure */
#define NT_TASKSTRUCT   4
/** String from sysinfo(SI_PLATFORM) */
#define NT_PLATFORM   5
/** Contains copy of auxv array */
#define NT_AUXV   6
/** Contains copy of gwindows struct */
#define NT_GWINDOWS   7
/** Contains copy of asrset struct */
#define NT_ASRS   8
/** Contains copy of pstatus struct */
#define NT_PSTATUS   10
/** Contains copy of psinfo struct */
#define NT_PSINFO   13
/** Contains copy of prcred struct */
#define NT_PRCRED   14
/** Contains copy of utsname struct */
#define NT_UTSNAME   15
/** Contains copy of lwpstatus struct */
#define NT_LWPSTATUS   16
/** Contains copy of lwpinfo struct */
#define NT_LWPSINFO   17
/** Contains copy of fprxregset struct */
#define NT_PRFPXREG   20
// Legal values for the note segment descriptor types for object files
/** Contains a version string */
#define NT_VERSION   1

/** Dynamic Section Entry */
typedef struct _Elf32_Dyn {
	Elf32_Sword d_tag;  // Dynamic entry type
	union {
		Elf32_Word d_val;  // Integer value
		Elf32_Addr d_ptr;  // Address value
	} d_un;
} Elf32_Dyn;

/** Dynamic Section Entry */
typedef struct _Elf64_Dyn {
	Elf64_Sxword d_tag;  // Dynamic entry type
	union {
		Elf64_Xword d_val;  // Integer value
		Elf64_Addr d_ptr;  // Address value
	} d_un;
} Elf64_Dyn;

// Legal values for d_tag (dynamic entry type)
/** Marks end of dynamic section */
#define DT_NULL   0
/** Name of needed library */
#define DT_NEEDED   1
/** Size in bytes of PLT relocs */
#define DT_PLTRELSZ   2
/** Processor defined value */
#define DT_PLTGOT   3
/** Address of symbol hash table */
#define DT_HASH   4
/** Address of string table */
#define DT_STRTAB   5
/** Address of symbol table */
#define DT_SYMTAB   6
/** Address of Rela relocs */
#define DT_RELA   7
/** Total size of Rela relocs */
#define DT_RELASZ   8
/** Size of one Rela reloc */
#define DT_RELAENT   9
/** Size of string table */
#define DT_STRSZ   10
/** Size of one symbol table entry */
#define DT_SYMENT   11
/** Address of init function */
#define DT_INIT   12
/** Address of termination function */
#define DT_FINI   13
/** Name of shared object */
#define DT_SONAME   14
/** Library search path (deprecated) */
#define DT_RPATH   15
/** Start symbol search here */
#define DT_SYMBOLIC   16
/** Address of Rel relocs */
#define DT_REL   17
/** Total size of Rel relocs */
#define DT_RELSZ   18
/** Size of one Rel reloc */
#define DT_RELENT   19
/** Type of reloc in PLT */
#define DT_PLTREL   20
/** For debugging; unspecified */
#define DT_DEBUG   21
/** Reloc might modify .text */
#define DT_TEXTREL   22
/** Address of PLT relocs */
#define DT_JMPREL   23
/** Process relocations of object */
#define DT_BIND_NOW   24
/** Array with addresses of init fct */
#define DT_INIT_ARRAY   25
/** Array with addresses of fini fct */
#define DT_FINI_ARRAY   26
/** Size in bytes of DT_INIT_ARRAY */
#define DT_INIT_ARRAYSZ   27
/** Size in bytes of DT_FINI_ARRAY */
#define DT_FINI_ARRAYSZ   28
/** Library search path */
#define DT_RUNPATH   29
/** Flags for the object being loaded */
#define DT_FLAGS   30
/** Start of encoded range */
#define DT_ENCODING   32
#define DT_PREINIT_ARRAY   32  /** Array with addresses of preinit fct*/
/** size in bytes of DT_PREINIT_ARRAY */
#define DT_PREINIT_ARRAYSZ   33
/** Number used */
#define DT_NUM   34
/** Start of OS-specific */
#define DT_LOOS   0x6000000d
/** End of OS-specific */
#define DT_HIOS   0x6ffff000
/** Start of processor-specific */
#define DT_LOPROC   0x70000000
/** End of processor-specific */
#define DT_HIPROC   0x7fffffff
/** Most used by any processor */
#define DT_PROCNUM   DT_MIPS_NUM
// DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure. This follows Sun's approach
#define DT_VALRNGLO   0x6ffffd00
/** Prelinking timestamp */
#define DT_GNU_PRELINKED   0x6ffffdf5
/** Size of conflict section */
#define DT_GNU_CONFLICTSZ   0x6ffffdf6
/** Size of library list */
#define DT_GNU_LIBLISTSZ   0x6ffffdf7
#define DT_CHECKSUM   0x6ffffdf8
#define DT_PLTPADSZ   0x6ffffdf9
#define DT_MOVEENT   0x6ffffdfa
#define DT_MOVESZ   0x6ffffdfb
/** Feature selection (DTF_*) */
#define DT_FEATURE_1   0x6ffffdfc
/** Flags for DT_* entries, effecting the following DT_* entry */
#define DT_POSFLAG_1   0x6ffffdfd
/** Size of syminfo table (in bytes) */
#define DT_SYMINSZ   0x6ffffdfe
/** Entry size of syminfo */
#define DT_SYMINENT   0x6ffffdff
#define DT_VALRNGHI   0x6ffffdff
/** Reverse order */
#define DT_VALTAGIDX(tag)   (DT_VALRNGHI - (tag))
#define DT_VALNUM   12
// DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the Dyn.d_un.d_ptr field of the Elf*_Dyn structure. If any adjustment is made to the ELF object after it has been built these entries will need to be adjusted
#define DT_ADDRRNGLO   0x6ffffe00
/** GNU-style hash table */
#define DT_GNU_HASH   0x6ffffef5
/** Start of conflict section */
#define DT_GNU_CONFLICT   0x6ffffef8
/** Library list */
#define DT_GNU_LIBLIST   0x6ffffef9
/** Configuration information */
#define DT_CONFIG   0x6ffffefa
/** Dependency auditing */
#define DT_DEPAUDIT   0x6ffffefb
/** Object auditing */
#define DT_AUDIT   0x6ffffefc
/** PLT padding */
#define DT_PLTPAD   0x6ffffefd
/** Move table */
#define DT_MOVETAB   0x6ffffefe
/** Syminfo table */
#define DT_SYMINFO   0x6ffffeff
#define DT_ADDRRNGHI   0x6ffffeff
/** Reverse order */
#define DT_ADDRTAGIDX(tag)   (DT_ADDRRNGHI - (tag))
#define DT_ADDRNUM   10
// The versioning entry types
// GNU Extensions
#define DT_VERSYM   0x6ffffff0
#define DT_RELACOUNT   0x6ffffff9
#define DT_RELCOUNT   0x6ffffffa
// These were chosen by Sun
/** State flags, see DF_1_* below */
#define DT_FLAGS_1   0x6ffffffb
/** Address of version definition table */
#define DT_VERDEF   0x6ffffffc
/** Number of version definitions */
#define DT_VERDEFNUM   0x6ffffffd
/** Address of table with needed versions */
#define DT_VERNEED   0x6ffffffe
/** Number of needed versions */
#define DT_VERNEEDNUM   0x6fffffff
/** Reverse order! */
#define DT_VERSIONTAGIDX(tag)   (DT_VERNEEDNUM - (tag))
#define DT_VERSIONTAGNUM   16
// Sun added these machine-independent extensions in the "processor-specific" range
#define DT_AUXILIARY   0x7ffffffd  /* Shared object to load before self */
#define DT_FILTER   0x7fffffff  /* Shared object to get values from */
#define DT_EXTRATAGIDX(tag)   ((Elf32_Word) - ((Elf32_Sword)(tag) << 1 >> 1) - 1)
#define DT_EXTRANUM   3
// Values of `d_un.d_val` in the DT_FLAGS entry
/** Object may use DF_ORIGIN */
#define DF_ORIGIN   1
/** Symbol resolutions starts here */
#define DF_SYMBOLIC   2
/** Object contains text relocations */
#define DF_TEXTREL   4
/** No lazy binding for this object */
#define DF_BIND_NOW   8
/** Module uses the static TLS model */
#define DF_STATIC_TLS   0x10
// State flags selectable in the `d_un.d_val` element of the DT_FLAGS_1 entry in the dynamic section
/** Set RTLD_NOW for this object */
#define DF_1_NOW   1
/** Set RTLD_GLOBAL for this object */
#define DF_1_GLOBAL   2
/** Set RTLD_GROUP for this object */
#define DF_1_GROUP   4
/** Set RTLD_NODELETE for this object */
#define DF_1_NODELETE   8
/** Trigger filtee loading at runtime */
#define DF_1_LOADFLTR   0x10
/** Set RTLD_INITFIRST for this object*/
#define DF_1_INITFIRST   0x20
/** Set RTLD_NOOPEN for this object */
#define DF_1_NOOPEN   0x40
/** $ORIGIN must be handled */
#define DF_1_ORIGIN   0x80
/** Direct binding enabled */
#define DF_1_DIRECT   0x100
#define DF_1_TRANS   0x200
/** Object is used to interpose */
#define DF_1_INTERPOSE   0x400
/** Ignore default lib search path */
#define DF_1_NODEFLIB   0x800
/** Object cannot be dldumped */
#define DF_1_NODUMP   0x1000
/** Configuration alternative created */
#define DF_1_CONFALT   0x2000
/** Filtee terminates filters search */
#define DF_1_ENDFILTEE   0x4000
/** Disp reloc applied at build time */
#define DF_1_DISPRELDNE   0x8000
/** Disp reloc applied at run-time */
#define DF_1_DISPRELPND   0x10000
// Flags for the feature selection in DT_FEATURE_1
#define DTF_1_PARINIT   1
#define DTF_1_CONFEXP   2
// Flags in the DT_POSFLAG_1 entry effecting only the next DT_* entry
/** Lazyload following object */
#define DF_P1_LAZYLOAD   1
/** Symbols from next object are not generally available */
#define DF_P1_GROUPPERM   2

/** Version Definition Section */
typedef struct _Elf32_Verdef {
	Elf32_Half vd_version;  // Version revision
	Elf32_Half vd_flags;  // Version information
	Elf32_Half vd_ndx;  // Version Index
	Elf32_Half vd_cnt;  // Number of associated aux entries
	Elf32_Word vd_hash;  // Version name hash value
	Elf32_Word vd_aux;  // Offset in bytes to verdaux array
	Elf32_Word vd_next;  // Offset in bytes to next verdef entry
} Elf32_Verdef;

/** Version Definition Section */
typedef struct _Elf64_Verdef {
	Elf64_Half vd_version;  // Version revision
	Elf64_Half vd_flags;  // Version information
	Elf64_Half vd_ndx;  // Version Index
	Elf64_Half vd_cnt;  // Number of associated aux entries
	Elf64_Word vd_hash;  // Version name hash value
	Elf64_Word vd_aux;  // Offset in bytes to verdaux array
	Elf64_Word vd_next;  // Offset in bytes to next verdef entry
} Elf64_Verdef;

// Legal values for vd_version (version revision)
/** No version */
#define VER_DEF_NONE   0
/** Current version */
#define VER_DEF_CURRENT   1
/** Given version number */
#define VER_DEF_NUM   2
// Legal values for vd_flags (version information flags)
/** Version definition of file itself */
#define VER_FLG_BASE   1
/** Weak version identifier */
#define VER_FLG_WEAK   2
// Versym symbol index values
/** Symbol is local */
#define VER_NDX_LOCAL   0
/** Symbol is global */
#define VER_NDX_GLOBAL   1
/** Beginning of reserved entries */
#define VER_NDX_LORESERVE   0xff00
/** Symbol is to be eliminated */
#define VER_NDX_ELIMINATE   0xff01

/** Auxialiary Version Information */
typedef struct _Elf32_Verdaux {
	Elf32_Word vda_name;  // Version or dependency names
	Elf32_Word vda_next;  // Offset in bytes to next verdaux entry
} Elf32_Verdaux;

/** Auxialiary Version Information */
typedef struct _Elf64_Verdaux {
	Elf64_Word vda_name;  // Version or dependency names
	Elf64_Word vda_next;  // Offset in bytes to next verdaux entry
} Elf64_Verdaux;

/** Version Dependency Section */
typedef struct _Elf32_Verneed {
	Elf32_Half vn_version;  // Version of structure
	Elf32_Half vn_cnt;  // Number of associated aux entries
	Elf32_Word vn_file;  // Offset of filename for this dependency
	Elf32_Word vn_aux;  // Offset in bytes to vernaux array
	Elf32_Word vn_next;  // Offset in bytes to next verneed entry
} Elf32_Verneed;

/** Version Dependency Section */
typedef struct _Elf64_Verneed {
	Elf64_Half vn_version;  // Version of structure
	Elf64_Half vn_cnt;  // Number of associated aux entries
	Elf64_Word vn_file;  // Offset of filename for this dependency
	Elf64_Word vn_aux;  // Offset in bytes to vernaux array
	Elf64_Word vn_next;  // Offset in bytes to next verneed entry
} Elf64_Verneed;

// Legal values for vn_version (version revision)
/** No version */
#define VER_NEED_NONE   (0)
/** Current version */
#define VER_NEED_CURRENT   (1)
/** Given version number */
#define VER_NEED_NUM   (2)

/** Auxiliary Needed Version Information */
typedef struct _Elf32_Vernaux {
	Elf32_Word vna_hash;  // Hash value of dependency name
	Elf32_Half vna_flags;  // Dependency specific information
	Elf32_Half vna_other;  // Unused
	Elf32_Word vna_name;  // Dependency name string offset
	Elf32_Word vna_next;  // Offset in bytes to next vernaux entry
} Elf32_Vernaux;

/** Auxiliary Needed Version Information */
typedef struct _Elf64_Vernaux {
	Elf64_Word vna_hash;  // Hash value of dependency name
	Elf64_Half vna_flags;  // Dependency specific information
	Elf64_Half vna_other;  // Unused
	Elf64_Word vna_name;  // Dependency name string offset
	Elf64_Word vna_next;  // Offset in bytes to next vernaux entry
} Elf64_Vernaux;

/** Auxiliary Vector */
typedef struct Elf32_auxv {
	uint32_t a_type;  /** Entry type */
	union {
		uint32_t a_val;  /** Integer value */
	} a_un;
} Elf32_auxv_t;

/** Auxiliary Vector */
typedef struct Elf64_auxv {
	uint64_t a_type;  /** Entry type */
	union {
		uint64_t a_val;  /** Integer value */
	} a_un;
} Elf64_auxv_t;

// Legal values for a_type (entry type)
/** End of vector */
#define AT_NULL   0
/** Entry should be ignored */
#define AT_IGNORE   1
/** File descriptor of program */
#define AT_EXECFD   2
/** Program headers for program */
#define AT_PHDR   3
/** Size of program header entry */
#define AT_PHENT   4
/** Number of program headers */
#define AT_PHNUM   5
/** System page size */
#define AT_PAGESZ   6
/** Base address of interpreter */
#define AT_BASE   7
/** Flags */
#define AT_FLAGS   8
/** Entry point of program */
#define AT_ENTRY   9
/** Program is not ELF */
#define AT_NOTELF   10
/** Real uid */
#define AT_UID   11
/** Effective uid */
#define AT_EUID   12
/** Real gid */
#define AT_GID   13
/** Effective gid */
#define AT_EGID   14
/** Frequency of times() */
#define AT_CLKTCK   17
// Some more special a_type values describing the hardware
/** String identifying platform */
#define AT_PLATFORM   15
/** Machine dependent hints about processor capabilities */
#define AT_HWCAP   16
/** FPU control word; This entry gives some information about the FPU initialization performed by the kernel */
#define AT_FPUCW   18
// Cache Block Sizes
/** Data cache block size */
#define AT_DCACHEBSIZE   19
/** Instruction cache block size */
#define AT_ICACHEBSIZE   20
/** Unified cache block size */
#define AT_UCACHEBSIZE   21
// A special ignored value for PPC, used by the kernel to control the interpretation of the AUXV. Must be > 16
/** Entry should be ignored */
#define AT_IGNOREPPC   22
/** Boolean (was exec setuid-like) */
#define AT_SECURE   23
// Pointer to the global system page used for system calls
#define AT_SYSINFO   32
#define AT_SYSINFO_EHDR   33
// Shapes of the caches; Bits 0-3 contains associativity; bits 4-7 contains log2 of line size; mask those to get cache size
#define AT_L1I_CACHESHAPE   34
#define AT_L1D_CACHESHAPE   35
#define AT_L2_CACHESHAPE   36
#define AT_L3_CACHESHAPE   37

/** Note Section Contents; Each entry in the note section begins with a header of a fixed form */
typedef struct _Elf32_Nhdr {
	Elf32_Word n_namesz;  // Length of the note's name
	Elf32_Word n_descsz;  // Length of the note's descriptor
	Elf32_Word n_type;  // Type of the note
} Elf32_Nhdr;

typedef struct _Elf64_Nhdr {
	Elf64_Word n_namesz;  // Length of the note's name
	Elf64_Word n_descsz;  // Length of the note's descriptor
	Elf64_Word n_type;  // Type of the note
} Elf64_Nhdr;

// Known Names of Notes
/** Solaris entries in the note section have this name */
#define ELF_NOTE_SOLARIS   "SUNW Solaris"
/** Note entries for GNU systems have this name */
#define ELF_NOTE_GNU   "GNU"
// Defined Types of Notes for Solaris
/** Value of descriptor (one word) is desired pagesize for the binary */
#define ELF_NOTE_PAGESIZE_HINT   1
// Defined Note Types for GNU Systems
/** ABI information
The descriptor consists of words:
 - word 0: OS descriptor
 - word 1: major version of the ABI
 - word 2: minor version of the ABI
 - word 3: subminor version of the ABI
*/
#define ELF_NOTE_ABI   1
// Known OSes; These value can appear in word 0 of an ELF_NOTE_ABI note section entry
#define ELF_NOTE_OS_LINUX   0
#define ELF_NOTE_OS_GNU   1
#define ELF_NOTE_OS_SOLARIS2   2
#define ELF_NOTE_OS_FREEBSD   3

/** Move records */
typedef struct attr_packed _Elf32_Move {
	Elf32_Xword m_value;  // Symbol value
	Elf32_Word m_info;  // Size and index
	Elf32_Word m_poffset;  // Symbol offset
	Elf32_Half m_repeat;  // Repeat count
	Elf32_Half m_stride;  // Stride info
} Elf32_Move;

typedef struct attr_packed _Elf64_Move {
	Elf64_Xword m_value;  // Symbol value
	Elf64_Xword m_info;  // Size and index
	Elf64_Xword m_poffset;  // Symbol offset
	Elf64_Half m_repeat;  // Repeat count
	Elf64_Half m_stride;  // Stride info
} Elf64_Move;

/* Motorola 68k Specific Definitions */
// Values for Elf32_Ehdr.e_flags
#define EF_CPU32   0x810000
/* m68k Relocs */
/** No reloc */
#define R_68K_NONE   0
/** Direct 32 bit */
#define R_68K_32   1
/** Direct 16 bit */
#define R_68K_16   2
/** Direct 8 bit */
#define R_68K_8   3
/** PC relative 32 bit */
#define R_68K_PC32   4
/** PC relative 16 bit */
#define R_68K_PC16   5
/** PC relative 8 bit */
#define R_68K_PC8   6
/** 32 bit PC relative GOT entry */
#define R_68K_GOT32   7
/** 16 bit PC relative GOT entry */
#define R_68K_GOT16   8
/** 8 bit PC relative GOT entry */
#define R_68K_GOT8   9
/** 32 bit GOT offset */
#define R_68K_GOT32O   10
/** 16 bit GOT offset */
#define R_68K_GOT16O   11
/** 8 bit GOT offset */
#define R_68K_GOT8O   12
/** 32 bit PC relative PLT address */
#define R_68K_PLT32   13
/** 16 bit PC relative PLT address */
#define R_68K_PLT16   14
/** 8 bit PC relative PLT address */
#define R_68K_PLT8   15
/** 32 bit PLT offset */
#define R_68K_PLT32O   16
/** 16 bit PLT offset */
#define R_68K_PLT16O   17
/** 8 bit PLT offset */
#define R_68K_PLT8O   18
/** Copy symbol at runtime */
#define R_68K_COPY   19
/** Create GOT entry */
#define R_68K_GLOB_DAT   20
/** Create PLT entry */
#define R_68K_JMP_SLOT   21
/** Adjust by program base */
#define R_68K_RELATIVE   22
#define R_68K_NUM   23

/* Intel 80386 Specific Definitions */
/* i386 Relocs */
/** No reloc */
#define R_386_NONE   0
/** Direct 32 bit */
#define R_386_32   1
/** PC relative 32 bit */
#define R_386_PC32   2
/** 32 bit GOT entry */
#define R_386_GOT32   3
/** 32 bit PLT address */
#define R_386_PLT32   4
/** Copy symbol at runtime */
#define R_386_COPY   5
/** Create GOT entry */
#define R_386_GLOB_DAT   6
/** Create PLT entry */
#define R_386_JMP_SLOT   7
/** Adjust by program base */
#define R_386_RELATIVE   8
/** 32 bit offset to GOT */
#define R_386_GOTOFF   9
/** 32 bit PC relative offset to GOT */
#define R_386_GOTPC   10
#define R_386_32PLT   11
/** Offset in static TLS block */
#define R_386_TLS_TPOFF   14
/** Address of GOT entry for static TLS block offset */
#define R_386_TLS_IE   15
/** GOT entry for static TLS block offset */
#define R_386_TLS_GOTIE   16
/** Offset relative to static TLS block */
#define R_386_TLS_LE   17
/** Direct 32 bit for GNU version of general dynamic thread local data */
#define R_386_TLS_GD   18
/** Direct 32 bit for GNU version of local dynamic thread local data in LE code */
#define R_386_TLS_LDM   19
#define R_386_16   20
#define R_386_PC16   21
#define R_386_8   22
#define R_386_PC8   23
/** Direct 32 bit for general dynamic thread local data */
#define R_386_TLS_GD_32   24
/** Tag for pushl in GD TLS code */
#define R_386_TLS_GD_PUSH   25
/** Relocation for call to __tls_get_addr() */
#define R_386_TLS_GD_CALL   26
/** Tag for popl in GD TLS code */
#define R_386_TLS_GD_POP   27
/** Direct 32 bit for local dynamic thread local data in LE code */
#define R_386_TLS_LDM_32   28
/** Tag for pushl in LDM TLS code */
#define R_386_TLS_LDM_PUSH   29
/** Relocation for call to __tls_get_addr() in LDM code */
#define R_386_TLS_LDM_CALL   30
/** Tag for popl in LDM TLS code */
#define R_386_TLS_LDM_POP   31
/** Offset relative to TLS block */
#define R_386_TLS_LDO_32   32
/** GOT entry for negated static TLS block offset */
#define R_386_TLS_IE_32   33
/** Negated offset relative to static TLS block */
#define R_386_TLS_LE_32   34
/** ID of module containing symbol */
#define R_386_TLS_DTPMOD32   35
/** Offset in TLS block */
#define R_386_TLS_DTPOFF32   36
/** Negated offset in static TLS block */
#define R_386_TLS_TPOFF32   37
#define R_386_NUM   38

/* Blackfin Specific Definitions */
#define R_BFIN_UNUSED0   0
#define R_BFIN_PCREL5M2   1
#define R_BFIN_UNUSED1   2
#define R_BFIN_PCREL10   3
#define R_BFIN_PCREL12_JUMP   4
#define R_BFIN_RIMM16   5
#define R_BFIN_LUIMM16   6
#define R_BFIN_HUIMM16   7
#define R_BFIN_PCREL12_JUMP_S   8
#define R_BFIN_PCREL24_JUMP_X   9
#define R_BFIN_PCREL24   0xa
#define R_BFIN_UNUSEDB   0xb
#define R_BFIN_UNUSEDC   0xc
#define R_BFIN_PCREL24_JUMP_L   0xd
#define R_BFIN_PCREL24_CALL_X   0xe
#define R_BFIN_var_eq_symb   0xf
#define R_BFIN_BYTE_DATA   0x10
#define R_BFIN_BYTE2_DATA   0x11
#define R_BFIN_BYTE4_DATA   0x12
#define R_BFIN_PCREL11   0x13
#define R_BFIN_GOT17M4   0x14
#define R_BFIN_GOTHI   0x15
#define R_BFIN_GOTLO   0x16
#define R_BFIN_FUNCDESC   0x17
#define R_BFIN_FUNCDESC_GOT17M4   0x18
#define R_BFIN_FUNCDESC_GOTHI   0x19
#define R_BFIN_FUNCDESC_GOTLO   0x1a
#define R_BFIN_FUNCDESC_VALUE   0x1b
#define R_BFIN_FUNCDESC_GOTOFF17M4   0x1c
#define R_BFIN_FUNCDESC_GOTOFFHI   0x1d
#define R_BFIN_FUNCDESC_GOTOFFLO   0x1e
#define R_BFIN_GOTOFF17M4   0x1f
#define R_BFIN_GOTOFFHI   0x20
#define R_BFIN_GOTOFFLO   0x21
#define EF_BFIN_PIC   1
#define EF_BFIN_FDPIC   2
#define EF_BFIN_CODE_IN_L1   0x10
#define EF_BFIN_DATA_IN_L1   0x20

/* FR-V Specific Definitions */
/** No reloc */
#define R_FRV_NONE   0
/** Direct 32 bit */
#define R_FRV_32   1
/** Canonical function descriptor address */
#define R_FRV_FUNCDESC   14
/** Private function descriptor initialization */
#define R_FRV_FUNCDESC_VALUE   18
// gpr support
/** mask for # of gprs */
#define EF_FRV_GPR_MASK   3
/** -mgpr-32 */
#define EF_FRV_GPR_32   1
/** -mgpr-64 */
#define EF_FRV_GPR_64   2
// fpr support
/** mask for # of fprs */
#define EF_FRV_FPR_MASK   0xc
/** -mfpr-32 */
#define EF_FRV_FPR_32   4
/** -mfpr-64 */
#define EF_FRV_FPR_64   8
/** -msoft-float */
#define EF_FRV_FPR_NONE   0xc
#define EF_FRV_PIC   0x100
#define EF_FRV_FDPIC   0x8000

/* SUN SPARC Specific Definitions */
// Legal values for ST_TYPE subfield of st_info (symbol type)
/** Global register reserved to app */
#define STT_SPARC_REGISTER   13
// Values for Elf64_Ehdr.e_flags
#define EF_SPARCV9_MM   3
#define EF_SPARCV9_TSO   0
#define EF_SPARCV9_PSO   1
#define EF_SPARCV9_RMO   2
/** Little endian data */
#define EF_SPARC_LEDATA   0x800000
#define EF_SPARC_EXT_MASK   0xFFFF00
/** Generic V8+ features */
#define EF_SPARC_32PLUS   0x100
/** Sun UltraSPARC1 extensions */
#define EF_SPARC_SUN_US1   0x200
/** HAL R1 extensions */
#define EF_SPARC_HAL_R1   0x400
/** Sun UltraSPARCIII extensions */
#define EF_SPARC_SUN_US3   0x800

/* SPARC Relocs */
/** No reloc */
#define R_SPARC_NONE   0
/** Direct 8 bit */
#define R_SPARC_8   1
/** Direct 16 bit */
#define R_SPARC_16   2
/** Direct 32 bit */
#define R_SPARC_32   3
/** PC relative 8 bit */
#define R_SPARC_DISP8   4
/** PC relative 16 bit */
#define R_SPARC_DISP16   5
/** PC relative 32 bit */
#define R_SPARC_DISP32   6
/** PC relative 30 bit shifted */
#define R_SPARC_WDISP30   7
/** PC relative 22 bit shifted */
#define R_SPARC_WDISP22   8
/** High 22 bit */
#define R_SPARC_HI22   9
/** Direct 22 bit */
#define R_SPARC_22   10
/** Direct 13 bit */
#define R_SPARC_13   11
/** Truncated 10 bit */
#define R_SPARC_LO10   12
/** Truncated 10 bit GOT entry */
#define R_SPARC_GOT10   13
/** 13 bit GOT entry */
#define R_SPARC_GOT13   14
/** 22 bit GOT entry shifted */
#define R_SPARC_GOT22   15
/** PC relative 10 bit truncated */
#define R_SPARC_PC10   16
/** PC relative 22 bit shifted */
#define R_SPARC_PC22   17
/** 30 bit PC relative PLT address */
#define R_SPARC_WPLT30   18
/** Copy symbol at runtime */
#define R_SPARC_COPY   19
/** Create GOT entry */
#define R_SPARC_GLOB_DAT   20
/** Create PLT entry */
#define R_SPARC_JMP_SLOT   21
/** Adjust by program base */
#define R_SPARC_RELATIVE   22
/** Direct 32 bit unaligned */
#define R_SPARC_UA32   23

/* Additional Sparc64 Relocs */
/** Direct 32 bit ref to PLT entry */
#define R_SPARC_PLT32   24
/** High 22 bit PLT entry */
#define R_SPARC_HIPLT22   25
/** Truncated 10 bit PLT entry */
#define R_SPARC_LOPLT10   26
/** PC rel 32 bit ref to PLT entry */
#define R_SPARC_PCPLT32   27
/** PC rel high 22 bit PLT entry */
#define R_SPARC_PCPLT22   28
/** PC rel trunc 10 bit PLT entry */
#define R_SPARC_PCPLT10   29
/** Direct 10 bit */
#define R_SPARC_10   30
/** Direct 11 bit */
#define R_SPARC_11   31
/** Direct 64 bit */
#define R_SPARC_64   32
/** 10bit with secondary 13bit addend */
#define R_SPARC_OLO10   33
/** Top 22 bits of direct 64 bit */
#define R_SPARC_HH22   34
/** High middle 10 bits */
#define R_SPARC_HM10   35
/** Low middle 22 bits */
#define R_SPARC_LM22   36
/** Top 22 bits of pc rel 64 bit */
#define R_SPARC_PC_HH22   37
/** High middle 10 bit */
#define R_SPARC_PC_HM10   38
/** Low miggle 22 bits */
#define R_SPARC_PC_LM22   39
/** PC relative 16 bit shifted */
#define R_SPARC_WDISP16   40
/** PC relative 19 bit shifted */
#define R_SPARC_WDISP19   41
/** Direct 7 bit */
#define R_SPARC_7   43
/** Direct 5 bit */
#define R_SPARC_5   44
/** Direct 6 bit */
#define R_SPARC_6   45
/** PC relative 64 bit */
#define R_SPARC_DISP64   46
/** Direct 64 bit ref to PLT entry */
#define R_SPARC_PLT64   47
/** High 22 bit complemented */
#define R_SPARC_HIX22   48
/** Truncated 11 bit complemented */
#define R_SPARC_LOX10   49
/** Direct high 12 of 44 bit */
#define R_SPARC_H44   50
/** Direct mid 22 of 44 bit */
#define R_SPARC_M44   51
/** Direct low 10 of 44 bit */
#define R_SPARC_L44   52
/** Global register usage */
#define R_SPARC_REGISTER   53
/** Direct 64 bit unaligned */
#define R_SPARC_UA64   54
/** Direct 16 bit unaligned */
#define R_SPARC_UA16   55
#define R_SPARC_TLS_GD_HI22   56
#define R_SPARC_TLS_GD_LO10   57
#define R_SPARC_TLS_GD_ADD   58
#define R_SPARC_TLS_GD_CALL   59
#define R_SPARC_TLS_LDM_HI22   60
#define R_SPARC_TLS_LDM_LO10   61
#define R_SPARC_TLS_LDM_ADD   62
#define R_SPARC_TLS_LDM_CALL   63
#define R_SPARC_TLS_LDO_HIX22   64
#define R_SPARC_TLS_LDO_LOX10   65
#define R_SPARC_TLS_LDO_ADD   66
#define R_SPARC_TLS_IE_HI22   67
#define R_SPARC_TLS_IE_LO10   68
#define R_SPARC_TLS_IE_LD   69
#define R_SPARC_TLS_IE_LDX   70
#define R_SPARC_TLS_IE_ADD   71
#define R_SPARC_TLS_LE_HIX22   72
#define R_SPARC_TLS_LE_LOX10   73
#define R_SPARC_TLS_DTPMOD32   74
#define R_SPARC_TLS_DTPMOD64   75
#define R_SPARC_TLS_DTPOFF32   76
#define R_SPARC_TLS_DTPOFF64   77
#define R_SPARC_TLS_TPOFF32   78
#define R_SPARC_TLS_TPOFF64   79
#define R_SPARC_NUM   80
// For Sparc64, legal values for d_tag of Elf64_Dyn
#define DT_SPARC_REGISTER   0x70000001
#define DT_SPARC_NUM   2
// Bits present in AT_HWCAP, primarily for Sparc32
/** CPU supports flush insn */
#define HWCAP_SPARC_FLUSH   1
#define HWCAP_SPARC_STBAR   2
#define HWCAP_SPARC_SWAP   4
#define HWCAP_SPARC_MULDIV   8
/** The cpu is v9, so v8plus is ok */
#define HWCAP_SPARC_V9   16
#define HWCAP_SPARC_ULTRA3   32

/* MIPS R3000 Specific Definitions */
// Legal values for e_flags field of Elf32_Ehdr
/** A .noreorder directive was used */
#define EF_MIPS_NOREORDER   1
/** Contains PIC code */
#define EF_MIPS_PIC   2
/** Uses PIC calling sequence */
#define EF_MIPS_CPIC   4
#define EF_MIPS_XGOT   8
#define EF_MIPS_64BIT_WHIRL 16
#define EF_MIPS_ABI2   32
#define EF_MIPS_ABI_ON32   64
/** MIPS architecture level */
#define EF_MIPS_ARCH   0xf0000000
// Legal values for MIPS architecture level
/** -mips1 code */
#define EF_MIPS_ARCH_1   0
/** -mips2 code */
#define EF_MIPS_ARCH_2   0x10000000
/** -mips3 code */
#define EF_MIPS_ARCH_3   0x20000000
/** -mips4 code */
#define EF_MIPS_ARCH_4   0x30000000
/** -mips5 code */
#define EF_MIPS_ARCH_5   0x40000000
/** MIPS32 code */
#define EF_MIPS_ARCH_32   0x60000000
/** MIPS64 code */
#define EF_MIPS_ARCH_64   0x70000000
// The following are non-official names and should not be used
/** -mips1 code */
#define E_MIPS_ARCH_1   0
/** -mips2 code */
#define E_MIPS_ARCH_2   0x10000000
/** -mips3 code */
#define E_MIPS_ARCH_3   0x20000000
/** -mips4 code */
#define E_MIPS_ARCH_4   0x30000000
/** -mips5 code */
#define E_MIPS_ARCH_5   0x40000000
/** MIPS32 code */
#define E_MIPS_ARCH_32   0x60000000
/** MIPS64 code */
#define E_MIPS_ARCH_64   0x70000000
// Special section indices
/** Allocated common symbols */
#define SHN_MIPS_ACOMMON   0xff00
/** Allocated test symbols */
#define SHN_MIPS_TEXT   0xff01
/** Allocated data symbols */
#define SHN_MIPS_DATA   0xff02
/** Small common symbols */
#define SHN_MIPS_SCOMMON   0xff03
/** Small undefined symbols */
#define SHN_MIPS_SUNDEFINED   0xff04
// Legal values for sh_type field of Elf32_Shdr
/** Shared objects used in link */
#define SHT_MIPS_LIBLIST   0x70000000
#define SHT_MIPS_MSYM   0x70000001
/** Conflicting symbols */
#define SHT_MIPS_CONFLICT   0x70000002
/** Global data area sizes */
#define SHT_MIPS_GPTAB   0x70000003
/** Reserved for SGI/MIPS compilers */
#define SHT_MIPS_UCODE   0x70000004
/** MIPS ECOFF debugging information */
#define SHT_MIPS_DEBUG   0x70000005
/** Register usage information */
#define SHT_MIPS_REGINFO   0x70000006
#define SHT_MIPS_PACKAGE   0x70000007
#define SHT_MIPS_PACKSYM   0x70000008
#define SHT_MIPS_RELD   0x70000009
#define SHT_MIPS_IFACE   0x7000000b
#define SHT_MIPS_CONTENT   0x7000000c
/** Miscellaneous options */
#define SHT_MIPS_OPTIONS   0x7000000d
#define SHT_MIPS_SHDR   0x70000010
#define SHT_MIPS_FDESC   0x70000011
#define SHT_MIPS_EXTSYM   0x70000012
#define SHT_MIPS_DENSE   0x70000013
#define SHT_MIPS_PDESC   0x70000014
#define SHT_MIPS_LOCSYM   0x70000015
#define SHT_MIPS_AUXSYM   0x70000016
#define SHT_MIPS_OPTSYM   0x70000017
#define SHT_MIPS_LOCSTR   0x70000018
#define SHT_MIPS_LINE   0x70000019
#define SHT_MIPS_RFDESC   0x7000001a
#define SHT_MIPS_DELTASYM   0x7000001b
#define SHT_MIPS_DELTAINST   0x7000001c
#define SHT_MIPS_DELTACLASS   0x7000001d
/** DWARF debugging information */
#define SHT_MIPS_DWARF   0x7000001e
#define SHT_MIPS_DELTADECL   0x7000001f
#define SHT_MIPS_SYMBOL_LIB   0x70000020
/** Event section */
#define SHT_MIPS_EVENTS   0x70000021
#define SHT_MIPS_TRANSLATE   0x70000022
#define SHT_MIPS_PIXIE   0x70000023
#define SHT_MIPS_XLATE   0x70000024
#define SHT_MIPS_XLATE_DEBUG   0x70000025
#define SHT_MIPS_WHIRL   0x70000026
#define SHT_MIPS_EH_REGION   0x70000027
#define SHT_MIPS_XLATE_OLD   0x70000028
#define SHT_MIPS_PDR_EXCEPTION 0x70000029
// Legal values for sh_flags field of Elf32_Shdr
/** Must be part of global data area */
#define SHF_MIPS_GPREL   0x10000000
#define SHF_MIPS_MERGE   0x20000000
#define SHF_MIPS_ADDR   0x40000000
#define SHF_MIPS_STRINGS   0x80000000
#define SHF_MIPS_NOSTRIP   0x8000000
#define SHF_MIPS_LOCAL   0x4000000
#define SHF_MIPS_NAMES   0x2000000
#define SHF_MIPS_NODUPE   0x1000000
// Symbol tables
// MIPS specific values for `st_other`
#define STO_MIPS_DEFAULT   0
#define STO_MIPS_INTERNAL   1
#define STO_MIPS_HIDDEN   2
#define STO_MIPS_PROTECTED   3
#define STO_MIPS_PLT   8
#define STO_MIPS_SC_ALIGN_UNUSED   0xff
// MIPS specific values for `st_info`
#define STB_MIPS_SPLIT_COMMON   13

/** Entries found in sections of type SHT_MIPS_GPTAB */
typedef union _Elf32_gptab {
	struct {
		Elf32_Word gt_current_g_value;  // -G value used for compilation
		Elf32_Word gt_unused;  // Not used
	} gt_header;  // First entry in section
	struct {
		Elf32_Word gt_g_value;  // If this value were used for -G
		Elf32_Word gt_bytes;  // This many bytes would be used
	} gt_entry;  // Subsequent entries in section
} Elf32_gptab;

/** Entry found in sections of type SHT_MIPS_REGINFO */
typedef struct _Elf32_RegInfo {
	Elf32_Word ri_gprmask;  // General registers used
	Elf32_Word ri_cprmask[4];  // Coprocessor registers used
	Elf32_Sword ri_gp_value;  // $gp register value
} Elf32_RegInfo;

/** Entries found in sections of type SHT_MIPS_OPTIONS */
typedef struct _Elf_Options {
	unsigned char kind;  // Determines interpretation of the variable part of descriptor
	unsigned char size;  // Size of descriptor, including header
	Elf32_Section section;  // Section header index of section affected, 0 for global options
	Elf32_Word info;  // Kind-specific information
} Elf_Options;

// Values for `kind` field in Elf_Options
/** Undefined */
#define ODK_NULL   0
/** Register usage information */
#define ODK_REGINFO   1
/** Exception processing options */
#define ODK_EXCEPTIONS   2
/** Section padding options */
#define ODK_PAD   3
/** Hardware workarounds performed */
#define ODK_HWPATCH   4
/** record the fill value used by the linker */
#define ODK_FILL   5
/** reserve space for desktop tools to write */
#define ODK_TAGS   6
/** HW workaround; 'AND' bits when merging */
#define ODK_HWAND   7
/** HW workaround; 'OR' bits when merging */
#define ODK_HWOR   8
// Values for `info` in Elf_Options for ODK_EXCEPTIONS entries
/** FPE's which MUST be enabled */
#define OEX_FPU_MIN   0x1f
/** FPE's which MAY be enabled */
#define OEX_FPU_MAX   0x1f00
/** page zero must be mapped */
#define OEX_PAGE0   0x10000
/** Force sequential memory mode? */
#define OEX_SMM   0x20000
/** Force floating point debug mode? */
#define OEX_FPDBUG   0x40000
#define OEX_PRECISEFP   OEX_FPDBUG
/** Dismiss invalid address faults? */
#define OEX_DISMISS   0x80000
#define OEX_FPU_INVAL   0x10
#define OEX_FPU_DIV0   8
#define OEX_FPU_OFLO   4
#define OEX_FPU_UFLO   2
#define OEX_FPU_INEX   1
// Masks for `info` in Elf_Options for an ODK_HWPATCH entry
/** R4000 end-of-page patch */
#define OHW_R4KEOP   1
/** may need R8000 prefetch patch */
#define OHW_R8KPFETCH   2
/** R5000 end-of-page patch */
#define OHW_R5KEOP   4
/** R5000 cvt.[ds].l bug; clean=1 */
#define OHW_R5KCVTL   8
#define OPAD_PREFIX   1
#define OPAD_POSTFIX   2
#define OPAD_SYMBOL   4

/** Entry found in `.options` section */
typedef struct _Elf_Options_Hw {
	Elf32_Word hwp_flags1, hwp_flags2;
} Elf_Options_Hw;

// Masks for `info` in ElfOptions for ODK_HWAND and ODK_HWOR entries
#define OHWA0_R4KEOP_CHECKED   (1)
#define OHWA1_R4KEOP_CLEAN   (2)

/* MIPS Relocs */
/** No reloc */
#define R_MIPS_NONE   0
/** Direct 16 bit */
#define R_MIPS_16   1
/** Direct 32 bit */
#define R_MIPS_32   2
/** PC relative 32 bit */
#define R_MIPS_REL32   3
/** Direct 26 bit shifted */
#define R_MIPS_26   4
/** High 16 bit */
#define R_MIPS_HI16   5
/** Low 16 bit */
#define R_MIPS_LO16   6
/** GP relative 16 bit */
#define R_MIPS_GPREL16   7
/** 16 bit literal entry */
#define R_MIPS_LITERAL   8
/** 16 bit GOT entry */
#define R_MIPS_GOT16   9
/** PC relative 16 bit */
#define R_MIPS_PC16   10
/** 16 bit GOT entry for function */
#define R_MIPS_CALL16   11
/** GP relative 32 bit */
#define R_MIPS_GPREL32   12
#define R_MIPS_SHIFT5   16
#define R_MIPS_SHIFT6   17
#define R_MIPS_64   18
#define R_MIPS_GOT_DISP   19
#define R_MIPS_GOT_PAGE   20
#define R_MIPS_GOT_OFST   21
#define R_MIPS_GOT_HI16   22
#define R_MIPS_GOT_LO16   23
#define R_MIPS_SUB   24
#define R_MIPS_INSERT_A   25
#define R_MIPS_INSERT_B   26
#define R_MIPS_DELETE   27
#define R_MIPS_HIGHER   28
#define R_MIPS_HIGHEST   29
#define R_MIPS_CALL_HI16   30
#define R_MIPS_CALL_LO16   31
#define R_MIPS_SCN_DISP   32
#define R_MIPS_REL16   33
#define R_MIPS_ADD_IMMEDIATE   34
#define R_MIPS_PJUMP   35
#define R_MIPS_RELGOT   36
#define R_MIPS_JALR   37
/** Module number 32 bit */
#define R_MIPS_TLS_DTPMOD32   38
/** Module-relative offset 32 bit */
#define R_MIPS_TLS_DTPREL32   39
/** Module number 64 bit */
#define R_MIPS_TLS_DTPMOD64   40
/** Module-relative offset 64 bit */
#define R_MIPS_TLS_DTPREL64   41
/** 16 bit GOT offset for GD */
#define R_MIPS_TLS_GD   42
/** 16 bit GOT offset for LDM */
#define R_MIPS_TLS_LDM   43
/** Module-relative offset, high 16 bits */
#define R_MIPS_TLS_DTPREL_HI16   44
/** Module-relative offset, low 16 bits */
#define R_MIPS_TLS_DTPREL_LO16   45
/** 16 bit GOT offset for IE */
#define R_MIPS_TLS_GOTTPREL   46
/** TP-relative offset, 32 bit */
#define R_MIPS_TLS_TPREL32   47
/** TP-relative offset, 64 bit */
#define R_MIPS_TLS_TPREL64   48
/** TP-relative offset, high 16 bits */
#define R_MIPS_TLS_TPREL_HI16   49
/** TP-relative offset, low 16 bits */
#define R_MIPS_TLS_TPREL_LO16   50
#define R_MIPS_GLOB_DAT   51
#define R_MIPS_COPY   126
#define R_MIPS_JUMP_SLOT   127
#define R_MIPS_NUM   128
// Legal values for p_type field of Elf32_Phdr
/** Register usage information */
#define PT_MIPS_REGINFO   0x70000000
/** Runtime procedure table */
#define PT_MIPS_RTPROC   0x70000001
#define PT_MIPS_OPTIONS   0x70000002
// Special program header types
#define PF_MIPS_LOCAL   0x10000000
// Legal values for d_tag field of Elf32_Dyn
/** Runtime linker interface version */
#define DT_MIPS_RLD_VERSION   0x70000001
/** Timestamp */
#define DT_MIPS_TIME_STAMP   0x70000002
/** Checksum */
#define DT_MIPS_ICHECKSUM   0x70000003
/** Version string (string tbl index) */
#define DT_MIPS_IVERSION   0x70000004
/** Flags */
#define DT_MIPS_FLAGS   0x70000005
/** Base address */
#define DT_MIPS_BASE_ADDRESS 0x70000006
#define DT_MIPS_MSYM   0x70000007
/** Address of CONFLICT section */
#define DT_MIPS_CONFLICT   0x70000008
/** Address of LIBLIST section */
#define DT_MIPS_LIBLIST   0x70000009
/** Number of local GOT entries */
#define DT_MIPS_LOCAL_GOTNO   0x7000000a
/** Number of CONFLICT entries */
#define DT_MIPS_CONFLICTNO   0x7000000b
/** Number of LIBLIST entries */
#define DT_MIPS_LIBLISTNO   0x70000010
/** Number of DYNSYM entries */
#define DT_MIPS_SYMTABNO   0x70000011
/** First external DYNSYM */
#define DT_MIPS_UNREFEXTNO   0x70000012
/** First GOT entry in DYNSYM */
#define DT_MIPS_GOTSYM   0x70000013
/** Number of GOT page table entries */
#define DT_MIPS_HIPAGENO   0x70000014
/** Address of run time loader map */
#define DT_MIPS_RLD_MAP   0x70000016
/** Delta C++ class definition */
#define DT_MIPS_DELTA_CLASS   0x70000017
/** Number of entries in DT_MIPS_DELTA_CLASS */
#define DT_MIPS_DELTA_CLASS_NO   0x70000018
/** Delta C++ class instances */
#define DT_MIPS_DELTA_INSTANCE   0x70000019
/** Number of entries in DT_MIPS_DELTA_INSTANCE */
#define DT_MIPS_DELTA_INSTANCE_NO   0x7000001a
/** Delta relocations */
#define DT_MIPS_DELTA_RELOC   0x7000001b
/** Number of entries in DT_MIPS_DELTA_RELOC */
#define DT_MIPS_DELTA_RELOC_NO   0x7000001c
/** Delta symbols that Delta relocations refer to */
#define DT_MIPS_DELTA_SYM   0x7000001d
/** Number of entries in DT_MIPS_DELTA_SYM */
#define DT_MIPS_DELTA_SYM_NO   0x7000001e
/** Delta symbols that hold the class declaration */
#define DT_MIPS_DELTA_CLASSSYM   0x70000020
/** Number of entries in DT_MIPS_DELTA_CLASSSYM */
#define DT_MIPS_DELTA_CLASSSYM_NO   0x70000021
/** Flags indicating for C++ flavor */
#define DT_MIPS_CXX_FLAGS   0x70000022
#define DT_MIPS_PIXIE_INIT   0x70000023
#define DT_MIPS_SYMBOL_LIB   0x70000024
#define DT_MIPS_LOCALPAGE_GOTIDX   0x70000025
#define DT_MIPS_LOCAL_GOTIDX   0x70000026
#define DT_MIPS_HIDDEN_GOTIDX   0x70000027
#define DT_MIPS_PROTECTED_GOTIDX   0x70000028
/** Address of .options */
#define DT_MIPS_OPTIONS   0x70000029
/** Address of .interface */
#define DT_MIPS_INTERFACE   0x7000002a
#define DT_MIPS_DYNSTR_ALIGN   0x7000002b
/** Size of the .interface section */
#define DT_MIPS_INTERFACE_SIZE   0x7000002c
/** Address of rld_text_rsolve function stored in GOT */
#define DT_MIPS_RLD_TEXT_RESOLVE_ADDR   0x7000002d
/** Default suffix of dso to be added by rld on dlopen() calls */
#define DT_MIPS_PERF_SUFFIX   0x7000002e
/** (O32)Size of compact rel section */
#define DT_MIPS_COMPACT_SIZE   0x7000002f
/** GP value for aux GOTs */
#define DT_MIPS_GP_VALUE   0x70000030
/** Address of aux .dynamic */
#define DT_MIPS_AUX_DYNAMIC   0x70000031
/** The address of .got.plt in an executable using the new non-PIC ABI */
#define DT_MIPS_PLTGOT   0x70000032
/** The base of the PLT in an executable using the new non-PIC ABI if that PLT is writable; For a non-writable PLT, this is omitted or has a zero value */
#define DT_MIPS_RWPLT   0x70000034
#define DT_MIPS_NUM   0x35

/** Entries found in sections of type SHT_MIPS_LIBLIST */
typedef struct _Elf32_Lib {
	Elf32_Word l_name;  // Name (string table index)
	Elf32_Word l_time_stamp;  // Timestamp
	Elf32_Word l_checksum;  // Checksum
	Elf32_Word l_version;  // Interface version
	Elf32_Word l_flags;  // Flags
} Elf32_Lib;

/** Entries found in sections of type SHT_MIPS_LIBLIST */
typedef struct _Elf64_Lib {
	Elf64_Word l_name;  // Name (string table index)
	Elf64_Word l_time_stamp;  // Timestamp
	Elf64_Word l_checksum;  // Checksum
	Elf64_Word l_version;  // Interface version
	Elf64_Word l_flags;  // Flags
} Elf64_Lib;

/* HPPA Specific Definitions */
// Legal values for e_flags field of Elf32_Ehdr
/** Trap nil pointer dereference */
#define EF_PARISC_TRAPNIL   0x10000
/** Program uses arch. extensions */
#define EF_PARISC_EXT   0x20000
/** Program expects little endian */
#define EF_PARISC_LSB   0x40000
/** Program expects wide mode */
#define EF_PARISC_WIDE   0x80000
/** No kernel assisted branch prediction */
#define EF_PARISC_NO_KABP   0x100000
/** Allow lazy swapping */
#define EF_PARISC_LAZYSWAP   0x400000
/** Architecture version */
#define EF_PARISC_ARCH   0xffff
// Defined values for `e_flags & EF_PARISC_ARCH' are:
/** PA-RISC 1.0 big-endian */
#define EFA_PARISC_1_0   0x20b
/** PA-RISC 1.1 big-endian */
#define EFA_PARISC_1_1   0x210
/** PA-RISC 2.0 big-endian */
#define EFA_PARISC_2_0   0x214
// Additional Section Indices
/** Section for tenatively declared symbols in ANSI C */
#define SHN_PARISC_ANSI_COMMON   0xff00
/** Common blocks in huge model */
#define SHN_PARISC_HUGE_COMMON   0xff01
// Legal values for sh_type field of Elf32_Shdr
/** Contains product specific ext */
#define SHT_PARISC_EXT   0x70000000
/** Unwind information */
#define SHT_PARISC_UNWIND   0x70000001
/** Debug info for optimized code */
#define SHT_PARISC_DOC   0x70000002
// Legal values for sh_flags field of Elf32_Shdr
/** Section with short addressing */
#define SHF_PARISC_SHORT   0x20000000
/** Section far from gp */
#define SHF_PARISC_HUGE   0x40000000
/** Static branch prediction code */
#define SHF_PARISC_SBP   0x80000000
// Legal values for ST_TYPE subfield of st_info (symbol type)
/** Millicode function entry point */
#define STT_PARISC_MILLICODE   13
#define STT_HP_OPAQUE   (STT_LOOS + 1)
#define STT_HP_STUB   (STT_LOOS + 2)

/* HPPA Relocs */
/** No reloc */
#define R_PARISC_NONE   0
/** Direct 32-bit reference */
#define R_PARISC_DIR32   1
/** Left 21 bits of eff. address */
#define R_PARISC_DIR21L   2
/** Right 17 bits of eff. address */
#define R_PARISC_DIR17R   3
/** 17 bits of eff. address */
#define R_PARISC_DIR17F   4
/** Right 14 bits of eff. address */
#define R_PARISC_DIR14R   6
/** 32-bit rel. address */
#define R_PARISC_PCREL32   9
/** Left 21 bits of rel. address */
#define R_PARISC_PCREL21L   10
/** Right 17 bits of rel. address */
#define R_PARISC_PCREL17R   11
/** 17 bits of rel. address */
#define R_PARISC_PCREL17F   12
/** Right 14 bits of rel. address */
#define R_PARISC_PCREL14R   14
/** Left 21 bits of rel. address */
#define R_PARISC_DPREL21L   18
/** Right 14 bits of rel. address */
#define R_PARISC_DPREL14R   22
/** GP-relative, left 21 bits */
#define R_PARISC_GPREL21L   26
/** GP-relative, right 14 bits */
#define R_PARISC_GPREL14R   30
/** LT-relative, left 21 bits */
#define R_PARISC_LTOFF21L   34
/** LT-relative, right 14 bits */
#define R_PARISC_LTOFF14R   38
/** 32 bits section rel. address */
#define R_PARISC_SECREL32   41
/** No relocation, set segment base */
#define R_PARISC_SEGBASE   48
/** 32 bits segment rel. address */
#define R_PARISC_SEGREL32   49
/** PLT rel. address, left 21 bits */
#define R_PARISC_PLTOFF21L   50
/** PLT rel. address, right 14 bits */
#define R_PARISC_PLTOFF14R   54
/** 32 bits LT-rel. function pointer */
#define R_PARISC_LTOFF_FPTR32   57
/** LT-rel. fct ptr, left 21 bits */
#define R_PARISC_LTOFF_FPTR21L   58
/** LT-rel. fct ptr, right 14 bits */
#define R_PARISC_LTOFF_FPTR14R   62
/** 64 bits function address */
#define R_PARISC_FPTR64   64
/** 32 bits function address */
#define R_PARISC_PLABEL32   65
/** 64 bits PC-rel. address */
#define R_PARISC_PCREL64   72
/** 22 bits PC-rel. address */
#define R_PARISC_PCREL22F   74
/** PC-rel. address, right 14 bits */
#define R_PARISC_PCREL14WR   75
/** PC rel. address, right 14 bits */
#define R_PARISC_PCREL14DR   76
/** 16 bits PC-rel. address */
#define R_PARISC_PCREL16F   77
/** 16 bits PC-rel. address */
#define R_PARISC_PCREL16WF   78
/** 16 bits PC-rel. address */
#define R_PARISC_PCREL16DF   79
/** 64 bits of eff. address */
#define R_PARISC_DIR64   80
/** 14 bits of eff. address */
#define R_PARISC_DIR14WR   83
/** 14 bits of eff. address */
#define R_PARISC_DIR14DR   84
/** 16 bits of eff. address */
#define R_PARISC_DIR16F   85
/** 16 bits of eff. address */
#define R_PARISC_DIR16WF   86
/** 16 bits of eff. address */
#define R_PARISC_DIR16DF   87
/** 64 bits of GP-rel. address */
#define R_PARISC_GPREL64   88
/** GP-rel. address, right 14 bits */
#define R_PARISC_GPREL14WR   91
/** GP-rel. address, right 14 bits */
#define R_PARISC_GPREL14DR   92
/** 16 bits GP-rel. address */
#define R_PARISC_GPREL16F   93
/** 16 bits GP-rel. address */
#define R_PARISC_GPREL16WF   94
/** 16 bits GP-rel. address */
#define R_PARISC_GPREL16DF   95
/** 64 bits LT-rel. address */
#define R_PARISC_LTOFF64   96
/** LT-rel. address, right 14 bits */
#define R_PARISC_LTOFF14WR   99
/** LT-rel. address, right 14 bits */
#define R_PARISC_LTOFF14DR   100
/** 16 bits LT-rel. address */
#define R_PARISC_LTOFF16F   101
/** 16 bits LT-rel. address */
#define R_PARISC_LTOFF16WF   102
/** 16 bits LT-rel. address */
#define R_PARISC_LTOFF16DF   103
/** 64 bits section rel. address */
#define R_PARISC_SECREL64   104
/** 64 bits segment rel. address */
#define R_PARISC_SEGREL64   112
/** PLT-rel. address, right 14 bits */
#define R_PARISC_PLTOFF14WR   115
/** PLT-rel. address, right 14 bits */
#define R_PARISC_PLTOFF14DR   116
/** 16 bits LT-rel. address */
#define R_PARISC_PLTOFF16F   117
/** 16 bits PLT-rel. address */
#define R_PARISC_PLTOFF16WF   118
/** 16 bits PLT-rel. address */
#define R_PARISC_PLTOFF16DF   119
/** 64 bits LT-rel. function ptr */
#define R_PARISC_LTOFF_FPTR64   120
/** LT-rel. fct. ptr., right 14 bits */
#define R_PARISC_LTOFF_FPTR14WR   123
/** LT-rel. fct. ptr., right 14 bits */
#define R_PARISC_LTOFF_FPTR14DR   124
/** 16 bits LT-rel. function ptr */
#define R_PARISC_LTOFF_FPTR16F   125
/** 16 bits LT-rel. function ptr */
#define R_PARISC_LTOFF_FPTR16WF   126
/** 16 bits LT-rel. function ptr */
#define R_PARISC_LTOFF_FPTR16DF   127
#define R_PARISC_LORESERVE   128
/** Copy relocation */
#define R_PARISC_COPY   128
/** Dynamic reloc, imported PLT */
#define R_PARISC_IPLT   129
/** Dynamic reloc, exported PLT */
#define R_PARISC_EPLT   130
/** 32 bits TP-rel. address */
#define R_PARISC_TPREL32   153
/** TP-rel. address, left 21 bits */
#define R_PARISC_TPREL21L   154
/** TP-rel. address, right 14 bits */
#define R_PARISC_TPREL14R   158
/** LT-TP-rel. address, left 21 bits */
#define R_PARISC_LTOFF_TP21L   162
/** LT-TP-rel. address, right 14 bits */
#define R_PARISC_LTOFF_TP14R   166
/** 14 bits LT-TP-rel. address */
#define R_PARISC_LTOFF_TP14F   167
/** 64 bits TP-rel. address */
#define R_PARISC_TPREL64   216
/** TP-rel. address, right 14 bits */
#define R_PARISC_TPREL14WR   219
/** TP-rel. address, right 14 bits */
#define R_PARISC_TPREL14DR   220
/** 16 bits TP-rel. address */
#define R_PARISC_TPREL16F   221
/** 16 bits TP-rel. address */
#define R_PARISC_TPREL16WF   222
/** 16 bits TP-rel. address */
#define R_PARISC_TPREL16DF   223
/** 64 bits LT-TP-rel. address */
#define R_PARISC_LTOFF_TP64   224
/** LT-TP-rel. address, right 14 bits */
#define R_PARISC_LTOFF_TP14WR   227
/** LT-TP-rel. address, right 14 bits */
#define R_PARISC_LTOFF_TP14DR   228
/** 16 bits LT-TP-rel. address */
#define R_PARISC_LTOFF_TP16F   229
/** 16 bits LT-TP-rel. address */
#define R_PARISC_LTOFF_TP16WF   230
/** 16 bits LT-TP-rel. address */
#define R_PARISC_LTOFF_TP16DF   231
#define R_PARISC_HIRESERVE   255
// Legal values for p_type field of Elf32_Phdr/Elf64_Phdr
#define PT_HP_TLS   (PT_LOOS)
#define PT_HP_CORE_NONE   (PT_LOOS + 1)
#define PT_HP_CORE_VERSION   (PT_LOOS + 2)
#define PT_HP_CORE_KERNEL   (PT_LOOS + 3)
#define PT_HP_CORE_COMM   (PT_LOOS + 4)
#define PT_HP_CORE_PROC   (PT_LOOS + 5)
#define PT_HP_CORE_LOADABLE   (PT_LOOS + 6)
#define PT_HP_CORE_STACK   (PT_LOOS + 7)
#define PT_HP_CORE_SHM   (PT_LOOS + 8)
#define PT_HP_CORE_MMF   (PT_LOOS + 9)
#define PT_HP_PARALLEL   (PT_LOOS + 0x10)
#define PT_HP_FASTBIND   (PT_LOOS + 0x11)
#define PT_HP_OPT_ANNOT   (PT_LOOS + 0x12)
#define PT_HP_HSL_ANNOT   (PT_LOOS + 0x13)
#define PT_HP_STACK   (PT_LOOS + 0x14)
#define PT_PARISC_ARCHEXT   0x70000000
#define PT_PARISC_UNWIND   0x70000001
// Legal values for p_flags field of Elf32_Phdr/Elf64_Phdr
#define PF_PARISC_SBP   0x08000000
#define PF_HP_PAGE_SIZE   0x100000
#define PF_HP_FAR_SHARED   0x200000
#define PF_HP_NEAR_SHARED   0x400000
#define PF_HP_CODE   0x1000000
#define PF_HP_MODIFY   0x2000000
#define PF_HP_LAZYSWAP   0x4000000
#define PF_HP_SBP   0x8000000

/* Alpha Specific Definitions */
// Legal values for e_flags field of Elf64_Ehdr
/** All addresses must be < 2GB */
#define EF_ALPHA_32BIT   1
/** Relocations for relaxing exist */
#define EF_ALPHA_CANRELAX   2
// Legal values for sh_type field of Elf64_Shdr
/** Concerned with ECOFF debugging info */
#define SHT_ALPHA_DEBUG   0x70000001
/** Concerned with ECOFF debugging info */
#define SHT_ALPHA_REGINFO   0x70000002
// Legal values for sh_flags field of Elf64_Shdr
#define SHF_ALPHA_GPREL   0x10000000
// Legal values for st_other field of Elf64_Sym
/** No PV required */
#define STO_ALPHA_NOPV   0x80
/** PV only used for initial ldgp */
#define STO_ALPHA_STD_GPLOAD   0x88

/* Alpha Relocs */
/** No reloc */
#define R_ALPHA_NONE   0
/** Direct 32 bit */
#define R_ALPHA_REFLONG   1
/** Direct 64 bit */
#define R_ALPHA_REFQUAD   2
/** GP relative 32 bit */
#define R_ALPHA_GPREL32   3
/** GP relative 16 bit w/optimization */
#define R_ALPHA_LITERAL   4
/** Optimization hint for LITERAL */
#define R_ALPHA_LITUSE   5
/** Add displacement to GP */
#define R_ALPHA_GPDISP   6
/** PC+4 relative 23 bit shifted */
#define R_ALPHA_BRADDR   7
/** PC+4 relative 16 bit shifted */
#define R_ALPHA_HINT   8
/** PC relative 16 bit */
#define R_ALPHA_SREL16   9
/** PC relative 32 bit */
#define R_ALPHA_SREL32   10
/** PC relative 64 bit */
#define R_ALPHA_SREL64   11
/** GP relative 32 bit, high 16 bits */
#define R_ALPHA_GPRELHIGH   17
/** GP relative 32 bit, low 16 bits */
#define R_ALPHA_GPRELLOW   18
/** GP relative 16 bit */
#define R_ALPHA_GPREL16   19
/** Copy symbol at runtime */
#define R_ALPHA_COPY   24
/** Create GOT entry */
#define R_ALPHA_GLOB_DAT   25
/** Create PLT entry */
#define R_ALPHA_JMP_SLOT   26
/** Adjust by program base */
#define R_ALPHA_RELATIVE   27
#define R_ALPHA_TLS_GD_HI   28
#define R_ALPHA_TLSGD   29
#define R_ALPHA_TLS_LDM   30
#define R_ALPHA_DTPMOD64   31
#define R_ALPHA_GOTDTPREL   32
#define R_ALPHA_DTPREL64   33
#define R_ALPHA_DTPRELHI   34
#define R_ALPHA_DTPRELLO   35
#define R_ALPHA_DTPREL16   36
#define R_ALPHA_GOTTPREL   37
#define R_ALPHA_TPREL64   38
#define R_ALPHA_TPRELHI   39
#define R_ALPHA_TPRELLO   40
#define R_ALPHA_TPREL16   41
#define R_ALPHA_NUM   46
// Magic values of the LITUSE relocation addend
#define LITUSE_ALPHA_ADDR   0
#define LITUSE_ALPHA_BASE   1
#define LITUSE_ALPHA_BYTOFF   2
#define LITUSE_ALPHA_JSR   3
#define LITUSE_ALPHA_TLS_GD   4
#define LITUSE_ALPHA_TLS_LDM   5
// Legal values for d_tag of Elf64_Dyn
#define DT_ALPHA_PLTRO   (DT_LOPROC)
#define DT_ALPHA_NUM   1

/* PowerPC Specific Declarations */
// Values for Elf32/64_Ehdr.e_flags
/** PowerPC embedded flag */
#define EF_PPC_EMB   0x80000000
// Cygnus local bits
/** PowerPC -mrelocatable flag*/
#define EF_PPC_RELOCATABLE   0x10000
/** PowerPC -mrelocatable-lib flag */
#define EF_PPC_RELOCATABLE_LIB   0x8000
// PowerPC relocations defined by the ABIs
#define R_PPC_NONE   0
/** 32bit absolute address */
#define R_PPC_ADDR32   1
/** 26bit address, 2 bits ignored */
#define R_PPC_ADDR24   2
/** 16bit absolute address */
#define R_PPC_ADDR16   3
/** lower 16bit of absolute address */
#define R_PPC_ADDR16_LO   4
/** high 16bit of absolute address */
#define R_PPC_ADDR16_HI   5
/** adjusted high 16bit */
#define R_PPC_ADDR16_HA   6
/** 16bit address, 2 bits ignored */
#define R_PPC_ADDR14   7
#define R_PPC_ADDR14_BRTAKEN   8
#define R_PPC_ADDR14_BRNTAKEN   9
/** PC relative 26 bit */
#define R_PPC_REL24   10
/** PC relative 16 bit */
#define R_PPC_REL14   11
#define R_PPC_REL14_BRTAKEN   12
#define R_PPC_REL14_BRNTAKEN   13
#define R_PPC_GOT16   14
#define R_PPC_GOT16_LO   15
#define R_PPC_GOT16_HI   16
#define R_PPC_GOT16_HA   17
#define R_PPC_PLTREL24   18
#define R_PPC_COPY   19
#define R_PPC_GLOB_DAT   20
#define R_PPC_JMP_SLOT   21
#define R_PPC_RELATIVE   22
#define R_PPC_LOCAL24PC   23
#define R_PPC_UADDR32   24
#define R_PPC_UADDR16   25
#define R_PPC_REL32   26
#define R_PPC_PLT32   27
#define R_PPC_PLTREL32   28
#define R_PPC_PLT16_LO   29
#define R_PPC_PLT16_HI   30
#define R_PPC_PLT16_HA   31
#define R_PPC_SDAREL16   32
#define R_PPC_SECTOFF   33
#define R_PPC_SECTOFF_LO   34
#define R_PPC_SECTOFF_HI   35
#define R_PPC_SECTOFF_HA   36
// PowerPC relocations defined for the TLS access ABI
/** none (sym+add)tls */
#define R_PPC_TLS   67
/** word32 (sym+add)dtpmod */
#define R_PPC_DTPMOD32   68
/** half16* (sym+add)tprel */
#define R_PPC_TPREL16   69
/** half16 (sym+add)tprell */
#define R_PPC_TPREL16_LO   70
/** half16 (sym+add)tprelh */
#define R_PPC_TPREL16_HI   71
/** half16 (sym+add)tprelha */
#define R_PPC_TPREL16_HA   72
/** word32 (sym+add)tprel */
#define R_PPC_TPREL32   73
/** half16* (sym+add)dtprel */
#define R_PPC_DTPREL16   74
/** half16 (sym+add)dtprell */
#define R_PPC_DTPREL16_LO   75
/** half16 (sym+add)dtprelh */
#define R_PPC_DTPREL16_HI   76
/** half16 (sym+add)dtprelha */
#define R_PPC_DTPREL16_HA   77
/** word32 (sym+add)dtprel */
#define R_PPC_DTPREL32   78
/** half16* (sym+add)gottlsgd */
#define R_PPC_GOT_TLSGD16   79
/** half16 (sym+add)gottlsgdl */
#define R_PPC_GOT_TLSGD16_LO   80
/** half16 (sym+add)gottlsgdh */
#define R_PPC_GOT_TLSGD16_HI   81
/** half16 (sym+add)gottlsgdha */
#define R_PPC_GOT_TLSGD16_HA   82
/** half16* (sym+add)gottlsld */
#define R_PPC_GOT_TLSLD16   83
/** half16 (sym+add)gottlsldl */
#define R_PPC_GOT_TLSLD16_LO   84
/** half16 (sym+add)gottlsldh */
#define R_PPC_GOT_TLSLD16_HI   85
/** half16 (sym+add)gottlsldha */
#define R_PPC_GOT_TLSLD16_HA   86
/** half16* (sym+add)gottprel */
#define R_PPC_GOT_TPREL16   87
/** half16 (sym+add)gottprell */
#define R_PPC_GOT_TPREL16_LO   88
/** half16 (sym+add)gottprelh */
#define R_PPC_GOT_TPREL16_HI   89
/** half16 (sym+add)gottprelha */
#define R_PPC_GOT_TPREL16_HA   90
/** half16* (sym+add)gotdtprel */
#define R_PPC_GOT_DTPREL16   91
/** half16* (sym+add)gotdtprell */
#define R_PPC_GOT_DTPREL16_LO   92
/** half16* (sym+add)gotdtprelh */
#define R_PPC_GOT_DTPREL16_HI   93
/** half16* (sym+add)gotdtprelha */
#define R_PPC_GOT_DTPREL16_HA   94
#define R_PPC_NUM   95
// The remaining relocs are from the Embedded ELF ABI, and are not in the SVR4 ELF ABI
#define R_PPC_EMB_NADDR32   101
#define R_PPC_EMB_NADDR16   102
#define R_PPC_EMB_NADDR16_LO   103
#define R_PPC_EMB_NADDR16_HI   104
#define R_PPC_EMB_NADDR16_HA   105
#define R_PPC_EMB_SDAI16   106
#define R_PPC_EMB_SDA2I16   107
#define R_PPC_EMB_SDA2REL   108
/** 16 bit offset in SDA */
#define R_PPC_EMB_SDA21   109
#define R_PPC_EMB_MRKREF   110
#define R_PPC_EMB_RELSEC16   111
#define R_PPC_EMB_RELST_LO   112
#define R_PPC_EMB_RELST_HI   113
#define R_PPC_EMB_RELST_HA   114
#define R_PPC_EMB_BIT_FLD   115
/** 16 bit relative offset in SDA */
#define R_PPC_EMB_RELSDA   116
// Diab tool relocations
/** like EMB_SDA21, but lower 16 bit */
#define R_PPC_DIAB_SDA21_LO   180
/** like EMB_SDA21, but high 16 bit */
#define R_PPC_DIAB_SDA21_HI   181
/** like EMB_SDA21, adjusted high 16 */
#define R_PPC_DIAB_SDA21_HA   182
/** like EMB_RELSDA, but lower 16 bit */
#define R_PPC_DIAB_RELSDA_LO   183
/** like EMB_RELSDA, but high 16 bit */
#define R_PPC_DIAB_RELSDA_HI   184
/** like EMB_RELSDA, adjusted high 16 */
#define R_PPC_DIAB_RELSDA_HA   185
// GNU relocs used in PIC code sequences
/** word32 (sym+add-.) */
#define R_PPC_REL16   249
/** half16 (sym+add-.)@l */
#define R_PPC_REL16_LO   250
/** half16 (sym+add-.)@h */
#define R_PPC_REL16_HI   251
/** half16 (sym+add-.)@ha */
#define R_PPC_REL16_HA   252
/** Phony reloc to handle any old TOC16 references that may still be in object files */
#define R_PPC_TOC16   255
// PowerPC specific values for the Dyn d_tag field
#define DT_PPC_GOT   (DT_LOPROC)
#define DT_PPC_NUM   1
// PowerPC64 relocations defined by the ABIs
#define R_PPC64_NONE   R_PPC_NONE
/** 32bit absolute address */
#define R_PPC64_ADDR32   R_PPC_ADDR32
/** 26bit address, word aligned */
#define R_PPC64_ADDR24   R_PPC_ADDR24
/** 16bit absolute address */
#define R_PPC64_ADDR16   R_PPC_ADDR16
/** lower 16bits of address */
#define R_PPC64_ADDR16_LO   R_PPC_ADDR16_LO
/** high 16bits of address */
#define R_PPC64_ADDR16_HI   R_PPC_ADDR16_HI
/** adjusted high 16bits */
#define R_PPC64_ADDR16_HA   R_PPC_ADDR16_HA
/** 16bit address, word aligned */
#define R_PPC64_ADDR14   R_PPC_ADDR14
#define R_PPC64_ADDR14_BRTAKEN   R_PPC_ADDR14_BRTAKEN
#define R_PPC64_ADDR14_BRNTAKEN   R_PPC_ADDR14_BRNTAKEN
/** PC-rel. 26 bit, word aligned */
#define R_PPC64_REL24   R_PPC_REL24
/** PC relative 16 bit */
#define R_PPC64_REL14   R_PPC_REL14
#define R_PPC64_REL14_BRTAKEN   R_PPC_REL14_BRTAKEN
#define R_PPC64_REL14_BRNTAKEN   R_PPC_REL14_BRNTAKEN
#define R_PPC64_GOT16   R_PPC_GOT16
#define R_PPC64_GOT16_LO   R_PPC_GOT16_LO
#define R_PPC64_GOT16_HI   R_PPC_GOT16_HI
#define R_PPC64_GOT16_HA   R_PPC_GOT16_HA
#define R_PPC64_COPY   R_PPC_COPY
#define R_PPC64_GLOB_DAT   R_PPC_GLOB_DAT
#define R_PPC64_JMP_SLOT   R_PPC_JMP_SLOT
#define R_PPC64_RELATIVE   R_PPC_RELATIVE
#define R_PPC64_UADDR32   R_PPC_UADDR32
#define R_PPC64_UADDR16   R_PPC_UADDR16
#define R_PPC64_REL32   R_PPC_REL32
#define R_PPC64_PLT32   R_PPC_PLT32
#define R_PPC64_PLTREL32   R_PPC_PLTREL32
#define R_PPC64_PLT16_LO   R_PPC_PLT16_LO
#define R_PPC64_PLT16_HI   R_PPC_PLT16_HI
#define R_PPC64_PLT16_HA   R_PPC_PLT16_HA
#define R_PPC64_SECTOFF   R_PPC_SECTOFF
#define R_PPC64_SECTOFF_LO   R_PPC_SECTOFF_LO
#define R_PPC64_SECTOFF_HI   R_PPC_SECTOFF_HI
#define R_PPC64_SECTOFF_HA   R_PPC_SECTOFF_HA
/** word30 (S + A - P) >> 2 */
#define R_PPC64_ADDR30   37
/** doubleword64 S + A */
#define R_PPC64_ADDR64   38
/** half16 #higher(S + A) */
#define R_PPC64_ADDR16_HIGHER   39
/** half16 #highera(S + A) */
#define R_PPC64_ADDR16_HIGHERA   40
/** half16 #highest(S + A) */
#define R_PPC64_ADDR16_HIGHEST   41
/** half16 #highesta(S + A) */
#define R_PPC64_ADDR16_HIGHESTA   42
/** doubleword64 S + A */
#define R_PPC64_UADDR64   43
/** doubleword64 S + A - P */
#define R_PPC64_REL64   44
/** doubleword64 L + A */
#define R_PPC64_PLT64   45
/** doubleword64 L + A - P */
#define R_PPC64_PLTREL64   46
/** half16* S + A - .TOC */
#define R_PPC64_TOC16   47
/** half16 #lo(S + A - .TOC.) */
#define R_PPC64_TOC16_LO   48
/** half16 #hi(S + A - .TOC.) */
#define R_PPC64_TOC16_HI   49
/** half16 #ha(S + A - .TOC.) */
#define R_PPC64_TOC16_HA   50
/** doubleword64 .TOC */
#define R_PPC64_TOC   51
/** half16* M + A */
#define R_PPC64_PLTGOT16   52
/** half16 #lo(M + A) */
#define R_PPC64_PLTGOT16_LO   53
/** half16 #hi(M + A) */
#define R_PPC64_PLTGOT16_HI   54
/** half16 #ha(M + A) */
#define R_PPC64_PLTGOT16_HA   55
/** half16ds* (S + A) >> 2 */
#define R_PPC64_ADDR16_DS   56
/** half16ds  #lo(S + A) >> 2 */
#define R_PPC64_ADDR16_LO_DS   57
/** half16ds* (G + A) >> 2 */
#define R_PPC64_GOT16_DS   58
/** half16ds  #lo(G + A) >> 2 */
#define R_PPC64_GOT16_LO_DS   59
/** half16ds  #lo(L + A) >> 2 */
#define R_PPC64_PLT16_LO_DS   60
/** half16ds* (R + A) >> 2 */
#define R_PPC64_SECTOFF_DS   61
/** half16ds  #lo(R + A) >> 2 */
#define R_PPC64_SECTOFF_LO_DS   62
/** half16ds* (S + A - .TOC.) >> 2 */
#define R_PPC64_TOC16_DS   63
/** half16ds  #lo(S + A - .TOC.) >> 2 */
#define R_PPC64_TOC16_LO_DS   64
/** half16ds* (M + A) >> 2 */
#define R_PPC64_PLTGOT16_DS   65
/** half16ds  #lo(M + A) >> 2 */
#define R_PPC64_PLTGOT16_LO_DS   66
// PowerPC64 relocations defined for the TLS access ABI
/** none (sym+add)tls */
#define R_PPC64_TLS   67
/** doubleword64 (sym+add)dtpmod */
#define R_PPC64_DTPMOD64   68
/** half16* (sym+add)tprel */
#define R_PPC64_TPREL16   69
/** half16 (sym+add)tprell */
#define R_PPC64_TPREL16_LO   70
/** half16 (sym+add)tprelh */
#define R_PPC64_TPREL16_HI   71
/** half16 (sym+add)tprelha */
#define R_PPC64_TPREL16_HA   72
/** doubleword64 (sym+add)tprel */
#define R_PPC64_TPREL64   73
/** half16* (sym+add)dtprel */
#define R_PPC64_DTPREL16   74
/** half16 (sym+add)dtprell */
#define R_PPC64_DTPREL16_LO   75
/** half16 (sym+add)dtprelh */
#define R_PPC64_DTPREL16_HI   76
/** half16 (sym+add)dtprelha */
#define R_PPC64_DTPREL16_HA   77
/** doubleword64 (sym+add)dtprel */
#define R_PPC64_DTPREL64   78
/** half16* (sym+add)gottlsgd */
#define R_PPC64_GOT_TLSGD16   79
/** half16 (sym+add)gottlsgdl */
#define R_PPC64_GOT_TLSGD16_LO   80
/** half16 (sym+add)gottlsgdh */
#define R_PPC64_GOT_TLSGD16_HI   81
/** half16 (sym+add)gottlsgdha */
#define R_PPC64_GOT_TLSGD16_HA   82
/** half16* (sym+add)gottlsld */
#define R_PPC64_GOT_TLSLD16   83
/** half16 (sym+add)gottlsldl */
#define R_PPC64_GOT_TLSLD16_LO   84
/** half16 (sym+add)gottlsldh */
#define R_PPC64_GOT_TLSLD16_HI   85
/** half16 (sym+add)gottlsldha */
#define R_PPC64_GOT_TLSLD16_HA   86
/** half16ds* (sym+add)gottprel */
#define R_PPC64_GOT_TPREL16_DS   87
/** half16ds (sym+add)gottprell */
#define R_PPC64_GOT_TPREL16_LO_DS 88
/** half16 (sym+add)gottprelh */
#define R_PPC64_GOT_TPREL16_HI   89
/** half16 (sym+add)gottprelha */
#define R_PPC64_GOT_TPREL16_HA   90
/** half16ds* (sym+add)gotdtprel */
#define R_PPC64_GOT_DTPREL16_DS   91
/** half16ds (sym+add)gotdtprell */
#define R_PPC64_GOT_DTPREL16_LO_DS   92
/** half16 (sym+add)gotdtprelh */
#define R_PPC64_GOT_DTPREL16_HI   93
/** half16 (sym+add)gotdtprelha */
#define R_PPC64_GOT_DTPREL16_HA   94
/** half16ds* (sym+add)tprel */
#define R_PPC64_TPREL16_DS   95
/** half16ds (sym+add)tprell */
#define R_PPC64_TPREL16_LO_DS   96
/** half16 (sym+add)tprelhigher */
#define R_PPC64_TPREL16_HIGHER   97
/** half16 (sym+add)tprelhighera */
#define R_PPC64_TPREL16_HIGHERA   98
/** half16 (sym+add)tprelhighest */
#define R_PPC64_TPREL16_HIGHEST   99
/** half16 (sym+add)tprelhighesta */
#define R_PPC64_TPREL16_HIGHESTA 100
/** half16ds* (sym+add)dtprel */
#define R_PPC64_DTPREL16_DS   101
/** half16ds (sym+add)dtprell */
#define R_PPC64_DTPREL16_LO_DS   102
/** half16 (sym+add)dtprelhigher */
#define R_PPC64_DTPREL16_HIGHER   103
/** half16 (sym+add)dtprelhighera */
#define R_PPC64_DTPREL16_HIGHERA   104
/** half16 (sym+add)dtprelhighest */
#define R_PPC64_DTPREL16_HIGHEST   105
/** half16 (sym+add)dtprelhighesta */
#define R_PPC64_DTPREL16_HIGHESTA   106
#define R_PPC64_NUM   107
// PowerPC64 specific values for the Dyn d_tag field
#define DT_PPC64_GLINK   (DT_LOPROC)
#define DT_PPC64_OPD   (DT_LOPROC + 1)
#define DT_PPC64_OPDSZ   (DT_LOPROC + 2)
#define DT_PPC64_NUM   3

/* ARM Specific Declarations */
// Processor specific flags for the ELF header e_flags field
#define EF_ARM_RELEXEC   1
#define EF_ARM_HASENTRY   2
#define EF_ARM_INTERWORK   4
#define EF_ARM_APCS_26   8
#define EF_ARM_APCS_FLOAT   0x10
#define EF_ARM_PIC   0x20
/** 8-bit structure alignment is in use */
#define EF_ARM_ALIGN8   0x40
#define EF_ARM_NEW_ABI   0x80
#define EF_ARM_OLD_ABI   0x100
// Other constants defined in the ARM ELF spec. version B-01
#define EF_ARM_SYMSARESORTED   4
#define EF_ARM_DYNSYMSUSESEGIDX   8
#define EF_ARM_MAPSYMSFIRST   0x10
#define EF_ARM_EABIMASK   0XFF000000
#define EF_ARM_EABI_VERSION(flags)   ((flags) & EF_ARM_EABIMASK)
#define EF_ARM_EABI_UNKNOWN   0
#define EF_ARM_EABI_VER1   0x1000000
#define EF_ARM_EABI_VER2   0x2000000
// Additional symbol types for Thumb
#define STT_ARM_TFUNC   0xd
// ARM-specific values for sh_flags
/** Section contains an entry point */
#define SHF_ARM_ENTRYSECT   0x10000000
/** Section may be multiply defined in the input to a link step */
#define SHF_ARM_COMDEF   0x80000000
// ARM-specific program header flags
/** Segment contains the location addressed by the static base */
#define PF_ARM_SB   0x10000000
// Processor specific values for the Phdr p_type field
/** .ARM.exidx segment */
#define PT_ARM_EXIDX   0x70000001

/* ARM Relocs */
/** No reloc */
#define R_ARM_NONE   0
/** PC relative 26 bit branch */
#define R_ARM_PC24   1
/** Direct 32 bit */
#define R_ARM_ABS32   2
/** PC relative 32 bit */
#define R_ARM_REL32   3
#define R_ARM_PC13   4
/** Direct 16 bit */
#define R_ARM_ABS16   5
/** Direct 12 bit */
#define R_ARM_ABS12   6
#define R_ARM_THM_ABS5   7
/** Direct 8 bit */
#define R_ARM_ABS8   8
#define R_ARM_SBREL32   9
#define R_ARM_THM_PC22   10
#define R_ARM_THM_PC8   11
#define R_ARM_AMP_VCALL9   12
#define R_ARM_SWI24   13
#define R_ARM_THM_SWI8   14
#define R_ARM_XPC25   15
#define R_ARM_THM_XPC22   16
#define R_ARM_TLS_DTPMOD32   17
#define R_ARM_TLS_DTPOFF32   18
#define R_ARM_TLS_TPOFF32   19
/** Copy symbol at runtime */
#define R_ARM_COPY   20
/** Create GOT entry */
#define R_ARM_GLOB_DAT   21
/** Create PLT entry */
#define R_ARM_JUMP_SLOT   22
/** Adjust by program base */
#define R_ARM_RELATIVE   23
/** 32 bit offset to GOT */
#define R_ARM_GOTOFF   24
/** 32 bit PC relative offset to GOT */
#define R_ARM_GOTPC   25
/** 32 bit GOT entry */
#define R_ARM_GOT32   26
/** 32 bit PLT address */
#define R_ARM_PLT32   27
#define R_ARM_ALU_PCREL_7_0   32
#define R_ARM_ALU_PCREL_15_8   33
#define R_ARM_ALU_PCREL_23_15   34
#define R_ARM_LDR_SBREL_11_0   35
#define R_ARM_ALU_SBREL_19_12   36
#define R_ARM_ALU_SBREL_27_20   37
#define R_ARM_GNU_VTENTRY   100
#define R_ARM_GNU_VTINHERIT   101
/** thumb unconditional branch */
#define R_ARM_THM_PC11   102
/** thumb conditional branch */
#define R_ARM_THM_PC9   103
#define R_ARM_TLS_GD32   104
#define R_ARM_TLS_LDM32   105
#define R_ARM_TLS_LDO32   106
#define R_ARM_TLS_IE32   107
#define R_ARM_TLS_LE32   108
#define R_ARM_TLS_LDO12   109
#define R_ARM_TLS_LE12   110
#define R_ARM_TLS_IE12GP   111
#define R_ARM_RXPC25   249
#define R_ARM_RSBREL32   250
#define R_ARM_THM_RPC22   251
#define R_ARM_RREL32   252
#define R_ARM_RABS22   253
#define R_ARM_RPC24   254
#define R_ARM_RBASE   255
#define R_ARM_NUM   256

/* IA-64 specific declarations */
// Processor specific flags for the Ehdr e_flags field
/** os-specific flags */
#define EF_IA_64_MASKOS   0xf
/** 64-bit ABI */
#define EF_IA_64_ABI64   0x10
/** arch. version mask */
#define EF_IA_64_ARCH   0xff000000
// Processor specific values for the Phdr p_type field
/** arch extension bits */
#define PT_IA_64_ARCHEXT   (PT_LOPROC)
/** ia64 unwind bits */
#define PT_IA_64_UNWIND   (PT_LOPROC + 1)
#define PT_IA_64_HP_OPT_ANOT   (PT_LOOS + 0x12)
#define PT_IA_64_HP_HSL_ANOT   (PT_LOOS + 0x13)
#define PT_IA_64_HP_STACK   (PT_LOOS + 0x14)
// Processor specific flags for the Phdr p_flags field
/** spec insns w/o recovery */
#define PF_IA_64_NORECOV   0x80000000
// Processor specific values for the Shdr sh_type field
/** Extension bits */
#define SHT_IA_64_EXT   (SHT_LOPROC)
/** Unwind bits */
#define SHT_IA_64_UNWIND   (SHT_LOPROC + 1)
// Processor specific flags for the Shdr sh_flags field
/** Section near gp */
#define SHF_IA_64_SHORT   0x10000000
/** Spec insns w/o recovery */
#define SHF_IA_64_NORECOV   0x20000000
// Processor specific values for the Dyn d_tag field
#define DT_IA_64_PLT_RESERVE   (DT_LOPROC)
#define DT_IA_64_NUM   1

/* IA-64 Relocations */
/** none */
#define R_IA64_NONE   0
/** symbol + addend, add imm14 */
#define R_IA64_IMM14   0x21
/** symbol + addend, add imm22 */
#define R_IA64_IMM22   0x22
/** symbol + addend, mov imm64 */
#define R_IA64_IMM64   0x23
/** symbol + addend, data4 MSB */
#define R_IA64_DIR32MSB   0x24
/** symbol + addend, data4 LSB */
#define R_IA64_DIR32LSB   0x25
/** symbol + addend, data8 MSB */
#define R_IA64_DIR64MSB   0x26
/** symbol + addend, data8 LSB */
#define R_IA64_DIR64LSB   0x27
/** gprel(sym + add), add imm22 */
#define R_IA64_GPREL22   0x2a
/** gprel(sym + add), mov imm64 */
#define R_IA64_GPREL64I   0x2b
/** gprel(sym + add), data4 MSB */
#define R_IA64_GPREL32MSB   0x2c
/** gprel(sym + add), data4 LSB */
#define R_IA64_GPREL32LSB   0x2d
/** gprel(sym + add), data8 MSB */
#define R_IA64_GPREL64MSB   0x2e
/** gprel(sym + add), data8 LSB */
#define R_IA64_GPREL64LSB   0x2f
/** ltoff(sym + add), add imm22 */
#define R_IA64_LTOFF22   0x32
/** ltoff(sym + add), mov imm64 */
#define R_IA64_LTOFF64I   0x33
/** pltoff(sym + add), add imm22 */
#define R_IA64_PLTOFF22   0x3a
/** pltoff(sym + add), mov imm64 */
#define R_IA64_PLTOFF64I   0x3b
/** pltoff(sym + add), data8 MSB */
#define R_IA64_PLTOFF64MSB   0x3e
/** pltoff(sym + add), data8 LSB */
#define R_IA64_PLTOFF64LSB   0x3f
/** fptr(sym + add), mov imm64 */
#define R_IA64_FPTR64I   0x43
/** fptr(sym + add), data4 MSB */
#define R_IA64_FPTR32MSB   0x44
/** fptr(sym + add), data4 LSB */
#define R_IA64_FPTR32LSB   0x45
/** fptr(sym + add), data8 MSB */
#define R_IA64_FPTR64MSB   0x46
/** fptr(sym + add), data8 LSB */
#define R_IA64_FPTR64LSB   0x47
/** pcrel(sym + add), brl */
#define R_IA64_PCREL60B   0x48
/** pcrel(sym + add), ptb, call */
#define R_IA64_PCREL21B   0x49
/** pcrel(sym + add), chk.s */
#define R_IA64_PCREL21M   0x4a
/** pcrel(sym + add), fchkf */
#define R_IA64_PCREL21F   0x4b
/** pcrel(sym + add), data4 MSB */
#define R_IA64_PCREL32MSB   0x4c
/** pcrel(sym + add), data4 LSB */
#define R_IA64_PCREL32LSB   0x4d
/** pcrel(sym + add), data8 MSB */
#define R_IA64_PCREL64MSB   0x4e
/** pcrel(sym + add), data8 LSB */
#define R_IA64_PCREL64LSB   0x4f
/** ltoff(fptr(s+a)), imm22 */
#define R_IA64_LTOFF_FPTR22   0x52
/** ltoff(fptr(s+a)), imm64 */
#define R_IA64_LTOFF_FPTR64I   0x53
/** ltoff(fptr(s+a)), data4 MSB */
#define R_IA64_LTOFF_FPTR32MSB   0x54
/** ltoff(fptr(s+a)), data4 LSB */
#define R_IA64_LTOFF_FPTR32LSB   0x55
/** ltoff(fptr(s+a)), data8 MSB */
#define R_IA64_LTOFF_FPTR64MSB   0x56
/** ltoff(fptr(s+a)), data8 LSB */
#define R_IA64_LTOFF_FPTR64LSB   0x57
/** segrel(sym + add), data4 MSB */
#define R_IA64_SEGREL32MSB   0x5c
/** segrel(sym + add), data4 LSB */
#define R_IA64_SEGREL32LSB   0x5d
/** segrel(sym + add), data8 MSB */
#define R_IA64_SEGREL64MSB   0x5e
/** segrel(sym + add), data8 LSB */
#define R_IA64_SEGREL64LSB   0x5f
/** secrel(sym + add), data4 MSB */
#define R_IA64_SECREL32MSB   0x64
/** secrel(sym + add), data4 LSB */
#define R_IA64_SECREL32LSB   0x65
/** secrel(sym + add), data8 MSB */
#define R_IA64_SECREL64MSB   0x66
/** secrel(sym + add), data8 LSB */
#define R_IA64_SECREL64LSB   0x67
/** data 4 + REL */
#define R_IA64_REL32MSB   0x6c
/** data 4 + REL */
#define R_IA64_REL32LSB   0x6d
/** data 8 + REL */
#define R_IA64_REL64MSB   0x6e
/** data 8 + REL */
#define R_IA64_REL64LSB   0x6f
/** symbol + addend, data4 MSB */
#define R_IA64_LTV32MSB   0x74
/** symbol + addend, data4 LSB */
#define R_IA64_LTV32LSB   0x75
/** symbol + addend, data8 MSB */
#define R_IA64_LTV64MSB   0x76
/** symbol + addend, data8 LSB */
#define R_IA64_LTV64LSB   0x77
/** pcrel(sym + add), 21bit inst */
#define R_IA64_PCREL21BI   0x79
/** pcrel(sym + add), 22bit inst */
#define R_IA64_PCREL22   0x7a
/** pcrel(sym + add), 64bit inst */
#define R_IA64_PCREL64I   0x7b
/** dynamic reloc, imported PLT, MSB */
#define R_IA64_IPLTMSB   0x80
/** dynamic reloc, imported PLT, LSB */
#define R_IA64_IPLTLSB   0x81
/** copy relocation */
#define R_IA64_COPY   0x84
/** Addend and symbol difference */
#define R_IA64_SUB   0x85
/** LTOFF22, relaxable */
#define R_IA64_LTOFF22X   0x86
/** Use of LTOFF22X */
#define R_IA64_LDXMOV   0x87
/** tprel(sym + add), imm14 */
#define R_IA64_TPREL14   0x91
/** tprel(sym + add), imm22 */
#define R_IA64_TPREL22   0x92
/** tprel(sym + add), imm64 */
#define R_IA64_TPREL64I   0x93
/** tprel(sym + add), data8 MSB */
#define R_IA64_TPREL64MSB   0x96
/** tprel(sym + add), data8 LSB */
#define R_IA64_TPREL64LSB   0x97
/** ltoff(tprel(s+a)), imm2 */
#define R_IA64_LTOFF_TPREL22   0x9a
/** dtpmod(sym + add), data8 MSB */
#define R_IA64_DTPMOD64MSB   0xa6
/** dtpmod(sym + add), data8 LSB */
#define R_IA64_DTPMOD64LSB   0xa7
/** ltoff(dtpmod(sym + add)), imm22 */
#define R_IA64_LTOFF_DTPMOD22   0xaa
/** dtprel(sym + add), imm14 */
#define R_IA64_DTPREL14   0xb1
/** dtprel(sym + add), imm22 */
#define R_IA64_DTPREL22   0xb2
/** dtprel(sym + add), imm64 */
#define R_IA64_DTPREL64I   0xb3
/** dtprel(sym + add), data4 MSB */
#define R_IA64_DTPREL32MSB   0xb4
/** dtprel(sym + add), data4 LSB */
#define R_IA64_DTPREL32LSB   0xb5
/** dtprel(sym + add), data8 MSB */
#define R_IA64_DTPREL64MSB   0xb6
/** dtprel(sym + add), data8 LSB */
#define R_IA64_DTPREL64LSB   0xb7
/** ltoff(dtprel(s+a)), imm22 */
#define R_IA64_LTOFF_DTPREL22   0xba

/* SH specific declarations */
/** If set, this is a symbol pointing to SHmedia code, which will be branched to, so add 1 to the symbol value */
#define STO_SH5_ISA32   (4)

/* SH Relocs */
#define R_SH_NONE   0
#define R_SH_DIR32   1
#define R_SH_REL32   2
#define R_SH_DIR8WPN   3
#define R_SH_IND12W   4
#define R_SH_DIR8WPL   5
#define R_SH_DIR8WPZ   6
#define R_SH_DIR8BP   7
#define R_SH_DIR8W   8
#define R_SH_DIR8L   9
#define R_SH_SWITCH16   25
#define R_SH_SWITCH32   26
#define R_SH_USES   27
#define R_SH_COUNT   28
#define R_SH_ALIGN   29
#define R_SH_CODE   30
#define R_SH_DATA   31
#define R_SH_LABEL   32
#define R_SH_SWITCH8   33
#define R_SH_GNU_VTINHERIT   34
#define R_SH_GNU_VTENTRY   35
#define R_SH_TLS_GD_32   144
#define R_SH_TLS_LD_32   145
#define R_SH_TLS_LDO_32   146
#define R_SH_TLS_IE_32   147
#define R_SH_TLS_LE_32   148
#define R_SH_TLS_DTPMOD32   149
#define R_SH_TLS_DTPOFF32   150
#define R_SH_TLS_TPOFF32   151
#define R_SH_GOT32   160
#define R_SH_PLT32   161
#define R_SH_COPY   162
#define R_SH_GLOB_DAT   163
#define R_SH_JMP_SLOT   164
#define R_SH_RELATIVE   165
#define R_SH_GOTOFF   166
#define R_SH_GOTPC   167
#define R_SH_RELATIVE_LOW16   197
#define R_SH_RELATIVE_MEDLOW16   198
#define R_SH_IMM_LOW16   246
#define R_SH_IMM_LOW16_PCREL   247
#define R_SH_IMM_MEDLOW16   248
#define R_SH_IMM_MEDLOW16_PCREL   249
#define R_SH_NUM   256

/* Additional s390 Relocs */
/** No reloc */
#define R_390_NONE   0
/** Direct 8 bit */
#define R_390_8   1
/** Direct 12 bit */
#define R_390_12   2
/** Direct 16 bit */
#define R_390_16   3
/** Direct 32 bit */
#define R_390_32   4
/** PC relative 32 bit */
#define R_390_PC32   5
/** 12 bit GOT offset */
#define R_390_GOT12   6
/** 32 bit GOT offset */
#define R_390_GOT32   7
/** 32 bit PC relative PLT address */
#define R_390_PLT32   8
/** Copy symbol at runtime */
#define R_390_COPY   9
/** Create GOT entry */
#define R_390_GLOB_DAT   10
/** Create PLT entry */
#define R_390_JMP_SLOT   11
/** Adjust by program base */
#define R_390_RELATIVE   12
/** 32 bit offset to GOT */
#define R_390_GOTOFF32   13
/** 32 bit PC relative offset to GOT */
#define R_390_GOTPC   14
/** 16 bit GOT offset */
#define R_390_GOT16   15
/** PC relative 16 bit */
#define R_390_PC16   16
/** PC relative 16 bit shifted by 1 */
#define R_390_PC16DBL   17
/** 16 bit PC rel. PLT shifted by 1 */
#define R_390_PLT16DBL   18
/** PC relative 32 bit shifted by 1 */
#define R_390_PC32DBL   19
/** 32 bit PC rel. PLT shifted by 1 */
#define R_390_PLT32DBL   20
/** 32 bit PC rel. GOT shifted by 1 */
#define R_390_GOTPCDBL   21
/** Direct 64 bit */
#define R_390_64   22
/** PC relative 64 bit */
#define R_390_PC64   23
/** 64 bit GOT offset */
#define R_390_GOT64   24
/** 64 bit PC relative PLT address */
#define R_390_PLT64   25
/** 32 bit PC rel. to GOT entry >> 1 */
#define R_390_GOTENT   26
/** 16 bit offset to GOT */
#define R_390_GOTOFF16   27
/** 64 bit offset to GOT */
#define R_390_GOTOFF64   28
/** 12 bit offset to jump slot */
#define R_390_GOTPLT12   29
/** 16 bit offset to jump slot */
#define R_390_GOTPLT16   30
/** 32 bit offset to jump slot */
#define R_390_GOTPLT32   31
/** 64 bit offset to jump slot */
#define R_390_GOTPLT64   32
/** 32 bit rel. offset to jump slot */
#define R_390_GOTPLTENT   33
/** 16 bit offset from GOT to PLT */
#define R_390_PLTOFF16   34
/** 32 bit offset from GOT to PLT */
#define R_390_PLTOFF32   35
/** 16 bit offset from GOT to PLT */
#define R_390_PLTOFF64   36
/** Tag for load insn in TLS code */
#define R_390_TLS_LOAD   37
/** Tag for function call in general dynamic TLS code */
#define R_390_TLS_GDCALL   38
/** Tag for function call in local dynamic TLS code */
#define R_390_TLS_LDCALL   39
/** Direct 32 bit for general dynamic thread local data */
#define R_390_TLS_GD32   40
/** Direct 64 bit for general dynamic thread local data */
#define R_390_TLS_GD64   41
/** 12 bit GOT offset for static TLS block offset */
#define R_390_TLS_GOTIE12   42
/** 32 bit GOT offset for static TLS block offset */
#define R_390_TLS_GOTIE32   43
/** 64 bit GOT offset for static TLS block offset */
#define R_390_TLS_GOTIE64   44
/** Direct 32 bit for local dynamic thread local data in LE code */
#define R_390_TLS_LDM32   45
/** Direct 64 bit for local dynamic thread local data in LE code */
#define R_390_TLS_LDM64   46
/** 32 bit address of GOT entry for negated static TLS block offset */
#define R_390_TLS_IE32   47
/** 64 bit address of GOT entry for negated static TLS block offset */
#define R_390_TLS_IE64   48
/** 32 bit rel. offset to GOT entry for negated static TLS block offset */
#define R_390_TLS_IEENT   49
/** 32 bit negated offset relative to static TLS block */
#define R_390_TLS_LE32   50
/** 64 bit negated offset relative to static TLS block */
#define R_390_TLS_LE64   51
/** 32 bit offset relative to TLS block */
#define R_390_TLS_LDO32   52
/** 64 bit offset relative to TLS block */
#define R_390_TLS_LDO64   53
/** ID of module containing symbol */
#define R_390_TLS_DTPMOD   54
/** Offset in TLS block */
#define R_390_TLS_DTPOFF   55
/** Negated offset in static TLS block */
#define R_390_TLS_TPOFF   56
/** Direct 20 bit */
#define R_390_20   57
/** 20 bit GOT offset */
#define R_390_GOT20   58
/** 20 bit offset to jump slot */
#define R_390_GOTPLT20   59
/** 20 bit GOT offset for static TLS block offset */
#define R_390_TLS_GOTIE20   60
#define R_390_NUM   61

/* CRIS Flags */
#define EF_CRIS_VARIANT_MASK   0xe
#define EF_CRIS_VARIANT_ANY_V0_V10   0
#define EF_CRIS_VARIANT_V32   2
#define EF_CRIS_VARIANT_COMMON_V10_V32   4

/* CRIS Relocations */
#define R_CRIS_NONE   0
#define R_CRIS_8   1
#define R_CRIS_16   2
#define R_CRIS_32   3
#define R_CRIS_8_PCREL   4
#define R_CRIS_16_PCREL   5
#define R_CRIS_32_PCREL   6
#define R_CRIS_GNU_VTINHERIT   7
#define R_CRIS_GNU_VTENTRY   8
#define R_CRIS_COPY   9
#define R_CRIS_GLOB_DAT   10
#define R_CRIS_JUMP_SLOT   11
#define R_CRIS_RELATIVE   12
#define R_CRIS_16_GOT   13
#define R_CRIS_32_GOT   14
#define R_CRIS_16_GOTPLT   15
#define R_CRIS_32_GOTPLT   16
#define R_CRIS_32_GOTREL   17
#define R_CRIS_32_PLT_GOTREL   18
#define R_CRIS_32_PLT_PCREL   19
#define R_CRIS_NUM   20

/* AMD/x86-64 Relocations */
/** No reloc */
#define R_X86_64_NONE   0
/** Direct 64 bit */
#define R_X86_64_64   1
/** PC relative 32 bit signed */
#define R_X86_64_PC32   2
/** 32 bit GOT entry */
#define R_X86_64_GOT32   3
/** 32 bit PLT address */
#define R_X86_64_PLT32   4
/** Copy symbol at runtime */
#define R_X86_64_COPY   5
/** Create GOT entry */
#define R_X86_64_GLOB_DAT   6
/** Create PLT entry */
#define R_X86_64_JUMP_SLOT   7
/** Adjust by program base */
#define R_X86_64_RELATIVE   8
/** 32 bit signed PC relative offset to GOT */
#define R_X86_64_GOTPCREL   9
/** Direct 32 bit zero extended */
#define R_X86_64_32   10
/** Direct 32 bit sign extended */
#define R_X86_64_32S   11
/** Direct 16 bit zero extended */
#define R_X86_64_16   12
/** 16 bit sign extended pc relative */
#define R_X86_64_PC16   13
/** Direct 8 bit sign extended */
#define R_X86_64_8   14
/** 8 bit sign extended pc relative */
#define R_X86_64_PC8   15
/** ID of module containing symbol */
#define R_X86_64_DTPMOD64   16
/** Offset in module's TLS block */
#define R_X86_64_DTPOFF64   17
/** Offset in initial TLS block */
#define R_X86_64_TPOFF64   18
/** 32 bit signed PC relative offset to two GOT entries for GD symbol */
#define R_X86_64_TLSGD   19
/** 32 bit signed PC relative offset to two GOT entries for LD symbol */
#define R_X86_64_TLSLD   20
/** Offset in TLS block */
#define R_X86_64_DTPOFF32   21
/** 32 bit signed PC relative offset to GOT entry for IE symbol */
#define R_X86_64_GOTTPOFF   22
/** Offset in initial TLS block */
#define R_X86_64_TPOFF32   23
#define R_X86_64_NUM   24

/* AM33 Relocations */
/** No reloc */
#define R_MN10300_NONE   0
/** Direct 32 bit */
#define R_MN10300_32   1
/** Direct 16 bit */
#define R_MN10300_16   2
/** Direct 8 bit */
#define R_MN10300_8   3
/** PC-relative 32-bit */
#define R_MN10300_PCREL32   4
/** PC-relative 16-bit signed */
#define R_MN10300_PCREL16   5
/** PC-relative 8-bit signed */
#define R_MN10300_PCREL8   6
/** Ancient C++ vtable garbage */
#define R_MN10300_GNU_VTINHERIT   7
/** Collection annotation */
#define R_MN10300_GNU_VTENTRY   8
/** Direct 24 bit */
#define R_MN10300_24   9
/** 32-bit PCrel offset to GOT */
#define R_MN10300_GOTPC32   10
/** 16-bit PCrel offset to GOT */
#define R_MN10300_GOTPC16   11
/** 32-bit offset from GOT */
#define R_MN10300_GOTOFF32   12
/** 24-bit offset from GOT */
#define R_MN10300_GOTOFF24   13
/** 16-bit offset from GOT */
#define R_MN10300_GOTOFF16   14
/** 32-bit PCrel to PLT entry */
#define R_MN10300_PLT32   15
/** 16-bit PCrel to PLT entry */
#define R_MN10300_PLT16   16
/** 32-bit offset to GOT entry */
#define R_MN10300_GOT32   17
/** 24-bit offset to GOT entry */
#define R_MN10300_GOT24   18
/** 16-bit offset to GOT entry */
#define R_MN10300_GOT16   19
/** Copy symbol at runtime */
#define R_MN10300_COPY   20
/** Create GOT entry */
#define R_MN10300_GLOB_DAT   21
/** Create PLT entry */
#define R_MN10300_JMP_SLOT   22
/** Adjust by program base */
#define R_MN10300_RELATIVE   23
#define R_MN10300_NUM   24

/* M32R Relocs */
/** No reloc */
#define R_M32R_NONE   0
/** Direct 16 bit */
#define R_M32R_16   1
/** Direct 32 bit */
#define R_M32R_32   2
/** Direct 24 bit */
#define R_M32R_24   3
/** PC relative 10 bit shifted */
#define R_M32R_10_PCREL   4
/** PC relative 18 bit shifted */
#define R_M32R_18_PCREL   5
/** PC relative 26 bit shifted */
#define R_M32R_26_PCREL   6
/** High 16 bit with unsigned low */
#define R_M32R_HI16_ULO   7
/** High 16 bit with signed low */
#define R_M32R_HI16_SLO   8
/** Low 16 bit */
#define R_M32R_LO16   9
/** 16 bit offset in SDA */
#define R_M32R_SDA16   10
#define R_M32R_GNU_VTINHERIT   11
#define R_M32R_GNU_VTENTRY   12
// M32R relocs use SHT_RELA
/** Direct 16 bit */
#define R_M32R_16_RELA   33
/** Direct 32 bit */
#define R_M32R_32_RELA   34
/** Direct 24 bit */
#define R_M32R_24_RELA   35
/** PC relative 10 bit shifted */
#define R_M32R_10_PCREL_RELA   36
/** PC relative 18 bit shifted */
#define R_M32R_18_PCREL_RELA   37
/** PC relative 26 bit shifted */
#define R_M32R_26_PCREL_RELA   38
/** High 16 bit with unsigned low */
#define R_M32R_HI16_ULO_RELA   39
/** High 16 bit with signed low */
#define R_M32R_HI16_SLO_RELA   40
/** Low 16 bit */
#define R_M32R_LO16_RELA   41
/** 16 bit offset in SDA */
#define R_M32R_SDA16_RELA   42
#define R_M32R_RELA_GNU_VTINHERIT   43
#define R_M32R_RELA_GNU_VTENTRY   44
/** 24 bit GOT entry */
#define R_M32R_GOT24   48
/** 26 bit PC relative to PLT shifted */
#define R_M32R_26_PLTREL   49
/** Copy symbol at runtime */
#define R_M32R_COPY   50
/** Create GOT entry */
#define R_M32R_GLOB_DAT   51
/** Create PLT entry */
#define R_M32R_JMP_SLOT   52
/** Adjust by program base */
#define R_M32R_RELATIVE   53
/** 24 bit offset to GOT */
#define R_M32R_GOTOFF   54
/** 24 bit PC relative offset to GOT */
#define R_M32R_GOTPC24   55
/** High 16 bit GOT entry with unsigned low */
#define R_M32R_GOT16_HI_ULO   56
/** High 16 bit GOT entry with signed low */
#define R_M32R_GOT16_HI_SLO   57
/** Low 16 bit GOT entry */
#define R_M32R_GOT16_LO   58
/** High 16 bit PC relative offset to GOT with unsigned low */
#define R_M32R_GOTPC_HI_ULO   59
/** High 16 bit PC relative offset to GOT with signed low */
#define R_M32R_GOTPC_HI_SLO   60
/** Low 16 bit PC relative offset to GOT */
#define R_M32R_GOTPC_LO   61
/** High 16 bit offset to GOT with unsigned low */
#define R_M32R_GOTOFF_HI_ULO   62
/** High 16 bit offset to GOT with signed low */
#define R_M32R_GOTOFF_HI_SLO   63
/** Low 16 bit offset to GOT */
#define R_M32R_GOTOFF_LO   64
/** Keep this the last entry */
#define R_M32R_NUM   256

/* i960 Relocations */
#define R_960_NONE   0
#define R_960_12   1
#define R_960_32   2
#define R_960_IP24   3
#define R_960_SUB   4
#define R_960_OPTCALL   5
#define R_960_OPTCALLX   6
#define R_960_OPTCALLXA   7
#define R_960_NUM   8

/* v850 relocations */
#define R_V850_NONE   0
#define R_V850_9_PCREL   1
#define R_V850_22_PCREL   2
#define R_V850_HI16_S   3
#define R_V850_HI16   4
#define R_V850_LO16   5
#define R_V850_32   6
#define R_V850_16   7
#define R_V850_8   8
/** For ld.b, st.b, set1, clr1, not1, tst1, movea, movhi */
#define R_V850_SDA_16_16_OFFSET   9
/** For ld.w, ld.h, ld.hu, st.w, st.h */
#define R_V850_SDA_15_16_OFFSET   10
/** For ld.b, st.b, set1, clr1, not1, tst1, movea, movhi */
#define R_V850_ZDA_16_16_OFFSET   11
/** For ld.w, ld.h, ld.hu, st.w, st.h */
#define R_V850_ZDA_15_16_OFFSET   12
/** For sst.w, sld.w */
#define R_V850_TDA_6_8_OFFSET   13
/** For sst.h, sld.h */
#define R_V850_TDA_7_8_OFFSET   14
/** For sst.b, sld.b */
#define R_V850_TDA_7_7_OFFSET   15
/** For set1, clr1, not1, tst1, movea, movhi */
#define R_V850_TDA_16_16_OFFSET   16
// CYGNUS LOCAL v850e
/** For sld.hu */
#define R_V850_TDA_4_5_OFFSET   17
/** For sld.bu */
#define R_V850_TDA_4_4_OFFSET   18
/** For ld.bu */
#define R_V850_SDA_16_16_SPLIT_OFFSET   19
/** For ld.bu */
#define R_V850_ZDA_16_16_SPLIT_OFFSET   20
/** For callt */
#define R_V850_CALLT_6_7_OFFSET   21
/** For callt */
#define R_V850_CALLT_16_16_OFFSET   22
// END CYGNUS LOCAL
#define R_V850_GNU_VTINHERIT   23
#define R_V850_GNU_VTENTRY   24
#define R_V850_NUM   25

/* Atmel AVR32 relocations */
#define R_AVR32_NONE   0
#define R_AVR32_32   1
#define R_AVR32_16   2
#define R_AVR32_8   3
#define R_AVR32_32_PCREL   4
#define R_AVR32_16_PCREL   5
#define R_AVR32_8_PCREL   6
#define R_AVR32_DIFF32   7
#define R_AVR32_DIFF16   8
#define R_AVR32_DIFF8   9
#define R_AVR32_GOT32   10
#define R_AVR32_GOT16   11
#define R_AVR32_GOT8   12
#define R_AVR32_21S   13
#define R_AVR32_16U   14
#define R_AVR32_16S   15
#define R_AVR32_8S   16
#define R_AVR32_8S_EXT   17
#define R_AVR32_22H_PCREL   18
#define R_AVR32_18W_PCREL   19
#define R_AVR32_16B_PCREL   20
#define R_AVR32_16N_PCREL   21
#define R_AVR32_14UW_PCREL   22
#define R_AVR32_11H_PCREL   23
#define R_AVR32_10UW_PCREL   24
#define R_AVR32_9H_PCREL   25
#define R_AVR32_9UW_PCREL   26
#define R_AVR32_HI16   27
#define R_AVR32_LO16   28
#define R_AVR32_GOTPC   29
#define R_AVR32_GOTCALL   30
#define R_AVR32_LDA_GOT   31
#define R_AVR32_GOT21S   32
#define R_AVR32_GOT18SW   33
#define R_AVR32_GOT16S   34
#define R_AVR32_GOT7UW   35
#define R_AVR32_32_CPENT   36
#define R_AVR32_CPCALL   37
#define R_AVR32_16_CP   38
#define R_AVR32_9W_CP   39
#define R_AVR32_RELATIVE   40
#define R_AVR32_GLOB_DAT   41
#define R_AVR32_JMP_SLOT   42
#define R_AVR32_ALIGN   43
#define R_AVR32_NUM   44
/** Total size of GOT in bytes (dynamic tag) */
#define DT_AVR32_GOTSZ   0x70000001

/* Renesas H8/300 Relocations */
#define R_H8_NONE   0
#define R_H8_DIR32   1
#define R_H8_DIR32_28   2
#define R_H8_DIR32_24   3
#define R_H8_DIR32_16   4
#define R_H8_DIR32U   6
#define R_H8_DIR32U_28   7
#define R_H8_DIR32U_24   8
#define R_H8_DIR32U_20   9
#define R_H8_DIR32U_16   10
#define R_H8_DIR24   11
#define R_H8_DIR24_20   12
#define R_H8_DIR24_16   13
#define R_H8_DIR24U   14
#define R_H8_DIR24U_20   15
#define R_H8_DIR24U_16   16
#define R_H8_DIR16   17
#define R_H8_DIR16U   18
#define R_H8_DIR16S_32   19
#define R_H8_DIR16S_28   20
#define R_H8_DIR16S_24   21
#define R_H8_DIR16S_20   22
#define R_H8_DIR16S   23
#define R_H8_DIR8   24
#define R_H8_DIR8U   25
#define R_H8_DIR8Z_32   26
#define R_H8_DIR8Z_28   27
#define R_H8_DIR8Z_24   28
#define R_H8_DIR8Z_20   29
#define R_H8_DIR8Z_16   30
#define R_H8_PCREL16   31
#define R_H8_PCREL8   32
#define R_H8_BPOS   33
#define R_H8_PCREL32   34
#define R_H8_GOT32O   35
#define R_H8_GOT16O   36
#define R_H8_DIR16A8   59
#define R_H8_DIR16R8   60
#define R_H8_DIR24A8   61
#define R_H8_DIR24R8   62
#define R_H8_DIR32A16   63
#define R_H8_ABS32   65
#define R_H8_ABS32A16   127
#define R_H8_NUM   128

/* NIOS Relocations */
#define R_NIOS_NONE   0
/** A 32 bit absolute relocation */
#define R_NIOS_32   1
/** A LO-16 5 bit absolute relocation */
#define R_NIOS_LO16_LO5   2
/** A LO-16 top 11 bit absolute relocation */
#define R_NIOS_LO16_HI11   3
/** A HI-16 5 bit absolute relocation */
#define R_NIOS_HI16_LO5   4
/** A HI-16 top 11 bit absolute relocation */
#define R_NIOS_HI16_HI11   5
/** A 6 bit relative relocation */
#define R_NIOS_PCREL6   6
/** An 8 bit relative relocation */
#define R_NIOS_PCREL8   7
/** An 11 bit relative relocation */
#define R_NIOS_PCREL11   8
/** A 16 bit absolute relocation */
#define R_NIOS_16   9
/** Low 5-bits of absolute relocation in halfwords */
#define R_NIOS_H_LO5   10
/** Top 11 bits of 16-bit absolute relocation in halfwords */
#define R_NIOS_H_HI11   11
/** Low 5 bits of top 16-bits of 32-bit absolute relocation in halfwords */
#define R_NIOS_H_XLO5   12
/** Top 11 bits of top 16-bits of 32-bit absolute relocation in halfwords */
#define R_NIOS_H_XHI11   13
/** Half-word h value */
#define R_NIOS_H_16   14
/** Word h value */
#define R_NIOS_H_32   15
/** GNU extension to record C++ vtable hierarchy */
#define R_NIOS_GNU_VTINHERIT   200
/** GNU extension to record C++ vtable member usage */
#define R_NIOS_GNU_VTENTRY   201
#define R_NIOS_NUM   202

/* NIOS II Relocations */
#define R_NIOS2_NONE   0
#define R_NIOS2_S16   1
#define R_NIOS2_U16   2
#define R_NIOS2_PCREL16   3
#define R_NIOS2_CALL26   4
#define R_NIOS2_IMM5   5
#define R_NIOS2_CACHE_OPX   6
#define R_NIOS2_IMM6   7
#define R_NIOS2_IMM8   8
#define R_NIOS2_HI16   9
#define R_NIOS2_LO16   10
#define R_NIOS2_HIADJ16   11
#define R_NIOS2_BFD_RELOC_32   12
#define R_NIOS2_BFD_RELOC_16   13
#define R_NIOS2_BFD_RELOC_8   14
#define R_NIOS2_GPREL   15
#define R_NIOS2_GNU_VTINHERIT   16
#define R_NIOS2_GNU_VTENTRY   17
#define R_NIOS2_UJMP   18
#define R_NIOS2_CJMP   19
#define R_NIOS2_CALLR   20
#define R_NIOS2_ALIGN   21
#define R_NIOS2_NUM   22

/* Xtensa-specific declarations */
// Xtensa values for the Dyn d_tag field
#define DT_XTENSA_GOT_LOC_OFF   (DT_LOPROC)
#define DT_XTENSA_GOT_LOC_SZ   (DT_LOPROC + 1)
#define DT_XTENSA_NUM   2
// Xtensa relocations
#define R_XTENSA_NONE   0
#define R_XTENSA_32   1
#define R_XTENSA_RTLD   2
#define R_XTENSA_GLOB_DAT   3
#define R_XTENSA_JMP_SLOT   4
#define R_XTENSA_RELATIVE   5
#define R_XTENSA_PLT   6
#define R_XTENSA_OP0   8
#define R_XTENSA_OP1   9
#define R_XTENSA_OP2   10
#define R_XTENSA_ASM_EXPAND   11
#define R_XTENSA_ASM_SIMPLIFY   12
#define R_XTENSA_GNU_VTINHERIT   15
#define R_XTENSA_GNU_VTENTRY   16
#define R_XTENSA_DIFF8   17
#define R_XTENSA_DIFF16   18
#define R_XTENSA_DIFF32   19
#define R_XTENSA_SLOT0_OP   20
#define R_XTENSA_SLOT1_OP   21
#define R_XTENSA_SLOT2_OP   22
#define R_XTENSA_SLOT3_OP   23
#define R_XTENSA_SLOT4_OP   24
#define R_XTENSA_SLOT5_OP   25
#define R_XTENSA_SLOT6_OP   26
#define R_XTENSA_SLOT7_OP   27
#define R_XTENSA_SLOT8_OP   28
#define R_XTENSA_SLOT9_OP   29
#define R_XTENSA_SLOT10_OP   30
#define R_XTENSA_SLOT11_OP   31
#define R_XTENSA_SLOT12_OP   32
#define R_XTENSA_SLOT13_OP   33
#define R_XTENSA_SLOT14_OP   34
#define R_XTENSA_SLOT0_ALT   35
#define R_XTENSA_SLOT1_ALT   36
#define R_XTENSA_SLOT2_ALT   37
#define R_XTENSA_SLOT3_ALT   38
#define R_XTENSA_SLOT4_ALT   39
#define R_XTENSA_SLOT5_ALT   40
#define R_XTENSA_SLOT6_ALT   41
#define R_XTENSA_SLOT7_ALT   42
#define R_XTENSA_SLOT8_ALT   43
#define R_XTENSA_SLOT9_ALT   44
#define R_XTENSA_SLOT10_ALT   45
#define R_XTENSA_SLOT11_ALT   46
#define R_XTENSA_SLOT12_ALT   47
#define R_XTENSA_SLOT13_ALT   48
#define R_XTENSA_SLOT14_ALT   49
#define R_XTENSA_NUM   50

/* C6X Specific Relocs */
#define R_C6000_NONE   0
#define R_C6000_ABS32   1
#define R_C6000_ABS16   2
#define R_C6000_ABS8   3
#define R_C6000_PCR_S21   4
#define R_C6000_PCR_S12   5
#define R_C6000_PCR_S10   6
#define R_C6000_PCR_S7   7
#define R_C6000_ABS_S16   8
#define R_C6000_ABS_L16   9
#define R_C6000_ABS_H16   10
#define R_C6000_SBR_U15_B   11
#define R_C6000_SBR_U15_H   12
#define R_C6000_SBR_U15_W   13
#define R_C6000_SBR_S16   14
#define R_C6000_SBR_L16_B   15
#define R_C6000_SBR_L16_H   16
#define R_C6000_SBR_L16_W   17
#define R_C6000_SBR_H16_B   18
#define R_C6000_SBR_H16_H   19
#define R_C6000_SBR_H16_W   20
#define R_C6000_SBR_GOT_U15_W   21
#define R_C6000_SBR_GOT_L16_W   22
#define R_C6000_SBR_GOT_H16_W   23
#define R_C6000_DSBT_INDEX   24
#define R_C6000_PREL31   25
#define R_C6000_COPY   26
#define R_C6000_JUMP_SLOT   27
#define R_C6000_SBR_GOT32   28
#define R_C6000_PCR_H16   29
#define R_C6000_PCR_L16   30
#define R_C6000_ALIGN   253
#define R_C6000_FPHEAD   254
#define R_C6000_NOCMP   255
// C6x specific values for the Dyn d_tag field
#define DT_C6000_DSBT_BASE   (DT_LOPROC)
#define DT_C6000_DSBT_SIZE   (DT_LOPROC + 1)
#define DT_C6000_PREEMPTMAP   (DT_LOPROC + 2)
#define DT_C6000_DSBT_INDEX   (DT_LOPROC + 3)
#define DT_C6000_NUM   4

/* Microblaze Specific Relocs */
#define R_MICROBLAZE_NONE   0
#define R_MICROBLAZE_32   1
#define R_MICROBLAZE_32_PCREL   2
#define R_MICROBLAZE_64_PCREL   3
#define R_MICROBLAZE_32_PCREL_LO   4
#define R_MICROBLAZE_64   5
#define R_MICROBLAZE_32_LO   6
#define R_MICROBLAZE_SRO32   7
#define R_MICROBLAZE_SRW32   8
#define R_MICROBLAZE_64_NONE   9
#define R_MICROBLAZE_32_SYM_OP_SYM   10
#define R_MICROBLAZE_GNU_VTINHERIT   11
#define R_MICROBLAZE_GNU_VTENTRY   12
/** PC-relative GOT offset */
#define R_MICROBLAZE_GOTPC_64   13
/** GOT entry offset */
#define R_MICROBLAZE_GOT_64   14
/** PLT offset; PC-relative */
#define R_MICROBLAZE_PLT_64   15
/** Adjust by program base */
#define R_MICROBLAZE_REL   16
/** Create PLT entry */
#define R_MICROBLAZE_JUMP_SLOT   17
/** Create GOT entry */
#define R_MICROBLAZE_GLOB_DAT   18
/** Offset relative to GOT */
#define R_MICROBLAZE_GOTOFF_64   19
/** Offset relative to GOT */
#define R_MICROBLAZE_GOTOFF_32   20
/** Runtime copy */
#define R_MICROBLAZE_COPY   21
#define R_MICROBLAZE_NUM   22


#if (ULONG_MAX == 0xffffffff)
typedef Elf32_Ehdr   Ehdr;
typedef Elf32_Phdr   Phdr;
typedef Elf32_Sym   Sym;
typedef Elf32_Verdef   Verdef;
typedef Elf32_Verdaux   Verdaux;
#else
typedef Elf64_Ehdr   Ehdr;
typedef Elf64_Phdr   Phdr;
typedef Elf64_Sym   Sym;
typedef Elf64_Verdef   Verdef;
typedef Elf64_Verdaux   Verdaux;
#endif


#define OK_TYPES   ((1 << STT_NOTYPE) | (1 << STT_OBJECT) | (1 << STT_FUNC) | (1 << STT_COMMON))
#define OK_BINDS   ((1 << STB_GLOBAL) | (1 << STB_WEAK) | (1 << STB_GNU_UNIQUE))


LIB_FUNC int checkver(Verdef* def, int vsym, const char* vername, char* strings) {
	vsym &= 0x7fff;
	LOOP_FOREVER {
		if (!(def->vd_flags & VER_FLG_BASE) && (def->vd_ndx & 0x7fff) == vsym) { break; }
		if (def->vd_next == 0) { return 0; }
		def = (Verdef*)((char*)def + def->vd_next);
	}
	Verdaux *aux = (Verdaux*)((char*)def + def->vd_aux);
	return (int)(!strcmp(vername, strings + aux->vda_name));
}


LIB_FUNC void* __vdsosym(const char* vername, const char* name) {
	size_t i;
	for (i = 0; libc.auxv[i] != AT_SYSINFO_EHDR; i += 2) { if (!libc.auxv[i]) { return 0; } }
	Ehdr* eh = (void*)libc.auxv[i + 1];
	Phdr* ph = (void*)((char*)eh + eh->e_phoff);
	size_t* dynv = 0;
	register size_t base;
	for (i = 0; i < eh->e_phnum; i++, ph = (void*)((char*)ph + eh->e_phentsize)) {
		if (ph->p_type == PT_LOAD) { base = (size_t)eh + ph->p_offset - ph->p_vaddr; }
		else if (ph->p_type == PT_DYNAMIC) { dynv = (void*)((char*)eh + ph->p_offset); }
	}
	if (!dynv || base == (size_t)-1) { return 0; }
	char* strings = 0;
	Sym* syms = 0;
	uint32_t* hashtab = 0;
	uint16_t* versym = 0;
	Verdef* verdef = 0;
	for (i = 0; dynv[i]; i += 2) {
		void* p = (void*)(base + dynv[i + 1]);
		switch (dynv[i]) {
			case DT_STRTAB: strings = p; break;
			case DT_SYMTAB: syms = p; break;
			case DT_HASH: hashtab = p; break;
			case DT_VERSYM: versym = p; break;
			case DT_VERDEF: verdef = p; break;
			default: break;
		}
	}
	if (!strings || !syms || !hashtab) { return 0; }
	else if (!verdef) { versym = 0; }
	for (i = 0; i < hashtab[1]; i++) {
		if (!(1 << (syms[i].st_info & 0xf) & OK_TYPES)) { continue; }
		else if (!(1 << (syms[i].st_info >> 4) & OK_BINDS)) { continue; }
		else if (!syms[i].st_shndx) { continue; }
		else if (strcmp(name, strings + syms[i].st_name)) { continue; }
		else if (versym && (!checkver(verdef, versym[i], vername, strings))) { continue; }
		return (void*)(base + syms[i].st_value);
	}
	return 0;
}


#endif  // ELF_H


/* ALPHA OPCODE TABLE (<alpha.h>) */


#if ((!defined(OPCODE_ALPHA_H)) && defined(ARCHALPHA))
#define OPCODE_ALPHA_H   (1)


struct alpha_opcode {
	const char* name;
	unsigned int opcode, mask, flags;
	unsigned char operands[4];
};


extern const UNUSED struct alpha_opcode alpha_opcodes[];
extern const UNUSED unsigned alpha_num_opcodes;


// Values defined for the flags field of a struct alpha_opcode

/** Base architecture */
#define AXP_OPCODE_BASE   1
/** EV4 specific PALcode insns */
#define AXP_OPCODE_EV4   2
/** EV5 specific PALcode insns */
#define AXP_OPCODE_EV5   4
/** EV6 specific PALcode insns */
#define AXP_OPCODE_EV6   8
/** Byte/word extension (amask bit 0) */
#define AXP_OPCODE_BWX   0x100
/** "Count" extension (amask bit 1) */
#define AXP_OPCODE_CIX   0x200
/** Multimedia extension (amask bit 8) */
#define AXP_OPCODE_MAX   0x400
#define AXP_OPCODE_NOPAL   (~(AXP_OPCODE_EV4 | AXP_OPCODE_EV5 | AXP_OPCODE_EV6))
/** A macro to extract the major opcode from an instruction */
#define AXP_OP(i)   (((i) >> 26) & 0x3F)
/** The total number of major opcodes */
#define AXP_NOPS   0x40


typedef struct attr_packed alpha_operand {
	unsigned int bits:5;
	unsigned int shift:5;
	signed int default_reloc:16;
	unsigned int flags:16;
	unsigned int (*insert)(unsigned instruction, int op, const char** errmsg);
	int (*extract)(unsigned instruction, int* invalid);
} alpha_operand_t;


extern const UNUSED struct alpha_operand alpha_operands[];
extern const UNUSED unsigned alpha_num_operands;


// Values defined for the flags field of a struct alpha_operand

/** Mask for selecting the type for typecheck purposes */
#define AXP_OPERAND_TYPECHECK_MASK   (AXP_OPERAND_PARENS | AXP_OPERAND_COMMA | AXP_OPERAND_IR | AXP_OPERAND_FPR | AXP_OPERAND_RELATIVE | AXP_OPERAND_SIGNED | AXP_OPERAND_UNSIGNED)
/** This operand does not actually exist in the assembler input; This is used to support extended mnemonics, for which two operands fields are identical */
#define AXP_OPERAND_FAKE   1
/** The operand should be wrapped in parentheses rather than separated from the previous by a comma; This is used for the load and store instructions which want their operands to look like "Ra,disp(Rb)" */
#define AXP_OPERAND_PARENS   2
/** Used in combination with PARENS, this supresses the supression of the comma; This is used for "jmp Ra,(Rb),hint" */
#define AXP_OPERAND_COMMA   4
/** This operand names an integer register */
#define AXP_OPERAND_IR   010
/** This operand names a floating point register */
#define AXP_OPERAND_FPR   020
/** This operand is a relative branch displacement; The disassembler prints these symbolically if possible */
#define AXP_OPERAND_RELATIVE   040
/** This operand takes signed values */
#define AXP_OPERAND_SIGNED   0100
/** This operand takes unsigned values; This exists primarily so that a flags value of 0 can be treated as end-of-arguments */
#define AXP_OPERAND_UNSIGNED   0200
/** Supress overflow detection on this field; This is used for hints */
#define AXP_OPERAND_NOOVERFLOW   0400
/** Mask for optional argument default value */
#define AXP_OPERAND_OPTIONAL_MASK   07000
/** This operand defaults to zero; This is used for jump hints */
#define AXP_OPERAND_DEFAULT_ZERO   01000
/** This operand should default to the first (real) operand and is used in conjunction with AXP_OPERAND_OPTIONAL; This allows "and $0,3,$0" to be written as "and $0,3", etc. */
#define AXP_OPERAND_DEFAULT_FIRST   02000
/** Similarly, this operand should default to the second (real) operand; This allows "negl $0" instead of "negl $0,$0" */
#define AXP_OPERAND_DEFAULT_SECOND   04000


// Register common names

#define AXP_REG_V0   0
#define AXP_REG_T0   1
#define AXP_REG_T1   2
#define AXP_REG_T2   3
#define AXP_REG_T3   4
#define AXP_REG_T4   5
#define AXP_REG_T5   6
#define AXP_REG_T6   7
#define AXP_REG_T7   8
#define AXP_REG_S0   9
#define AXP_REG_S1   10
#define AXP_REG_S2   11
#define AXP_REG_S3   12
#define AXP_REG_S4   13
#define AXP_REG_S5   14
#define AXP_REG_FP   15
#define AXP_REG_A0   16
#define AXP_REG_A1   17
#define AXP_REG_A2   18
#define AXP_REG_A3   19
#define AXP_REG_A4   20
#define AXP_REG_A5   21
#define AXP_REG_T8   22
#define AXP_REG_T9   23
#define AXP_REG_T10   24
#define AXP_REG_T11   25
#define AXP_REG_RA   26
#define AXP_REG_PV   27
#define AXP_REG_T12   27
#define AXP_REG_AT   28
#define AXP_REG_GP   29
#define AXP_REG_SP   30
#define AXP_REG_ZERO   31


#endif  // OPCODE_ALPHA_H


/* WINDOWS BASE (<winbase.h>) */


#if (!(defined(WINBASE_H) || defined(_WINBASE_)))
#define WINBASE_H   (1)
#define _WINBASE_   (1)


#define PROCESS_NAME_NATIVE   1
#define FILE_ENCRYPTABLE   0
#define FILE_IS_ENCRYPTED   1
#define FILE_SYSTEM_ATTR   2
#define FILE_ROOT_DIR   3
#define FILE_SYSTEM_DIR   4
#define FILE_UNKNOWN   5
#define FILE_SYSTEM_NOT_SUPPORT   6
#define FILE_USER_DISALLOWED   7
#define FILE_READ_ONLY   8
#define FILE_DIR_DISALOWED   9
#define COMMPROP_INITIALIZED   0xE73CF52E
#define SP_SERIALCOMM   1
#define PST_UNSPECIFIED   0
#define PST_RS232   1
#define PST_PARALLELPORT   2
#define PST_RS422   3
#define PST_RS423   4
#define PST_RS449   5
#define PST_MODEM   6
#define PST_FAX   0x21
#define PST_SCANNER   0x22
#define PST_NETWORK_BRIDGE   0x100
#define PST_LAT   0x101
#define PST_TCPIP_TELNET   0x102
#define PST_X25   0x103
#define BAUD_075   1
#define BAUD_110   2
#define BAUD_134_5   4
#define BAUD_150   8
#define BAUD_300   16
#define BAUD_600   32
#define BAUD_1200   64
#define BAUD_1800   128
#define BAUD_2400   256
#define BAUD_4800   512
#define BAUD_7200   1024
#define BAUD_9600   2048
#define BAUD_14400   4096
#define BAUD_19200   8192
#define BAUD_38400   16384
#define BAUD_56K   32768
#define BAUD_128K   65536
#define BAUD_115200   131072
#define BAUD_57600   262144
#define BAUD_USER   0x10000000
#define PCF_DTRDSR   1
#define PCF_RTSCTS   2
#define PCF_RLSD   4
#define PCF_PARITY_CHECK   8
#define PCF_XONXOFF   16
#define PCF_SETXCHAR   32
#define PCF_TOTALTIMEOUTS   64
#define PCF_INTTIMEOUTS 128
#define PCF_SPECIALCHARS   256
#define PCF_16BITMODE   512
#define SP_PARITY   1
#define SP_BAUD   2
#define SP_DATABITS   4
#define SP_STOPBITS   8
#define SP_HANDSHAKING   16
#define SP_PARITY_CHECK   32
#define SP_RLSD   64
#define DATABITS_5   1
#define DATABITS_6   2
#define DATABITS_7   4
#define DATABITS_8   8
#define DATABITS_16   16
#define DATABITS_16X   32
#define STOPBITS_10   1
#define STOPBITS_15   2
#define STOPBITS_20   4
#define PARITY_NONE   256
#define PARITY_ODD   512
#define PARITY_EVEN   1024
#define PARITY_MARK   2048
#define PARITY_SPACE   4096
#define EXCEPTION_DEBUG_EVENT   1
#define CREATE_THREAD_DEBUG_EVENT   2
#define CREATE_PROCESS_DEBUG_EVENT   3
#define EXIT_THREAD_DEBUG_EVENT 4
#define EXIT_PROCESS_DEBUG_EVENT   5
#define LOAD_DLL_DEBUG_EVENT   6
#define UNLOAD_DLL_DEBUG_EVENT  7
#define OUTPUT_DEBUG_STRING_EVENT   8
#define RIP_EVENT   9
#define HFILE_ERROR   ((HFILE)-1)
#define FILE_BEGIN   0
#define FILE_CURRENT   1
#define FILE_END   2
#define INVALID_SET_FILE_POINTER   ((DWORD)-1)
#define OF_READ   0
#define OF_READWRITE   2
#define OF_WRITE   1
#define OF_SHARE_COMPAT   0
#define OF_SHARE_DENY_NONE   64
#define OF_SHARE_DENY_READ   48
#define OF_SHARE_DENY_WRITE   32
#define OF_SHARE_EXCLUSIVE   16
#define OF_CANCEL   2048
#define OF_CREATE   4096
#define OF_DELETE   512
#define OF_EXIST   16384
#define OF_PARSE   256
#define OF_PROMPT   8192
#define OF_REOPEN   32768
#define OF_VERIFY   1024
#define NMPWAIT_NOWAIT   1
#define NMPWAIT_WAIT_FOREVER   ((DWORD)-1)
#define NMPWAIT_USE_DEFAULT_WAIT   0
#define CE_BREAK   16
#define CE_DNS   2048
#define CE_FRAME   8
#define CE_IOE   1024
#define CE_MODE   32768
#define CE_OOP   4096
#define CE_OVERRUN   2
#define CE_PTO   512
#define CE_RXOVER   1
#define CE_RXPARITY   4
#define CE_TXFULL   256
#define PROGRESS_CONTINUE   0
#define PROGRESS_CANCEL   1
#define PROGRESS_STOP   2
#define PROGRESS_QUIET   3
#define CALLBACK_CHUNK_FINISHED   0
#define CALLBACK_STREAM_SWITCH   1
#define OFS_MAXPATHNAME   128
#define FILE_MAP_COPY   SECTION_QUERY
#define FILE_MAP_WRITE   SECTION_MAP_WRITE
#define FILE_MAP_READ   SECTION_MAP_READ
#define FILE_MAP_ALL_ACCESS   SECTION_ALL_ACCESS
#define FILE_MAP_EXECUTE   SECTION_MAP_EXECUTE_EXPLICIT
#define MUTEX_ALL_ACCESS   0x1f0001
#define MUTEX_MODIFY_STATE   1
#define SEMAPHORE_ALL_ACCESS   0x1f0003
#define SEMAPHORE_MODIFY_STATE   2
#define EVENT_ALL_ACCESS   0x1f0003
#define EVENT_MODIFY_STATE   2
#define PIPE_ACCESS_DUPLEX   3
#define PIPE_ACCESS_INBOUND   1
#define PIPE_ACCESS_OUTBOUND   2
#define PIPE_TYPE_BYTE   0
#define PIPE_TYPE_MESSAGE   4
#define PIPE_READMODE_BYTE   0
#define PIPE_READMODE_MESSAGE   2
#define PIPE_WAIT   0
#define PIPE_NOWAIT   1
#define PIPE_CLIENT_END   0
#define PIPE_SERVER_END   1
#define PIPE_UNLIMITED_INSTANCES   255
#define DEBUG_PROCESS   1
#define DEBUG_ONLY_THIS_PROCESS   2
#define CREATE_SUSPENDED   4
#define DETACHED_PROCESS   8
#define CREATE_NEW_CONSOLE   0x10
#define NORMAL_PRIORITY_CLASS   0x20
#define IDLE_PRIORITY_CLASS   0x40
#define HIGH_PRIORITY_CLASS   0x80
#define REALTIME_PRIORITY_CLASS   0x100
#define CREATE_NEW_PROCESS_GROUP   0x200
#define CREATE_UNICODE_ENVIRONMENT   0x400
#define CREATE_SEPARATE_WOW_VDM   0x800
#define CREATE_SHARED_WOW_VDM   0x1000
#define CREATE_FORCEDOS   0x2000
#define BELOW_NORMAL_PRIORITY_CLASS   0x4000
#define ABOVE_NORMAL_PRIORITY_CLASS   0x8000
#define CREATE_BREAKAWAY_FROM_JOB   0x1000000
#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL   0x2000000
#define CREATE_DEFAULT_ERROR_MODE   0x4000000
#define CREATE_NO_WINDOW   0x8000000
#define PROFILE_USER   0x10000000
#define PROFILE_KERNEL   0x20000000
#define PROFILE_SERVER   0x40000000
#define CREATE_NEW   1
#define CREATE_ALWAYS   2
#define OPEN_EXISTING   3
#define OPEN_ALWAYS   4
#define TRUNCATE_EXISTING   5
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION   8
#define COPY_FILE_FAIL_IF_EXISTS   1
#define COPY_FILE_RESTARTABLE   2
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE   4
#define FILE_FLAG_WRITE_THROUGH   0x80000000
#define FILE_FLAG_OVERLAPPED   1073741824
#define FILE_FLAG_NO_BUFFERING   536870912
#define FILE_FLAG_RANDOM_ACCESS   268435456
#define FILE_FLAG_SEQUENTIAL_SCAN   134217728
#define FILE_FLAG_DELETE_ON_CLOSE   67108864
#define FILE_FLAG_BACKUP_SEMANTICS   33554432
#define FILE_FLAG_POSIX_SEMANTICS   16777216
#define FILE_FLAG_OPEN_REPARSE_POINT   2097152
#define FILE_FLAG_OPEN_NO_RECALL   1048576
#define FILE_FLAG_FIRST_PIPE_INSTANCE   524288
#define CLRDTR   6
#define CLRRTS   4
#define SETDTR   5
#define SETRTS   3
#define SETXOFF   1
#define SETXON   2
#define RESETDEV   7
#define SETBREAK   8
#define CLRBREAK   9
#define STILL_ACTIVE   0x103
#define FIND_FIRST_EX_CASE_SENSITIVE   1
#define FIND_FIRST_EX_LARGE_FETCH   2
#define SCS_32BIT_BINARY   0
#define SCS_64BIT_BINARY   6
#define SCS_DOS_BINARY   1
#define SCS_OS216_BINARY   5
#define SCS_PIF_BINARY   3
#define SCS_POSIX_BINARY   4
#define SCS_WOW_BINARY   2
#define MAX_COMPUTERNAME_LENGTH   15
#define HW_PROFILE_GUIDLEN   39
#define MAX_PROFILE_LEN   80
#define DOCKINFO_UNDOCKED   1
#define DOCKINFO_DOCKED   2
#define DOCKINFO_USER_SUPPLIED   4
#define DOCKINFO_USER_UNDOCKED   (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)
#define DOCKINFO_USER_DOCKED   (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED   3
#define DRIVE_REMOTE   4
#define DRIVE_CDROM   5
#define DRIVE_RAMDISK   6
#define DRIVE_UNKNOWN   0
#define DRIVE_NO_ROOT_DIR   1
#define FILE_TYPE_UNKNOWN   0
#define FILE_TYPE_DISK   1
#define FILE_TYPE_CHAR   2
#define FILE_TYPE_PIPE   3
#define FILE_TYPE_REMOTE   0x8000
#ifndef HANDLE_FLAG_INHERIT
#   define HANDLE_FLAG_INHERIT   1  // Also in <ddk/ntapi.h>
#endif
#ifndef HANDLE_FLAG_PROTECT_FROM_CLOSE
#   define HANDLE_FLAG_PROTECT_FROM_CLOSE   2  // Also in <ddk/ntapi.h>
#endif
#define STD_INPUT_HANDLE   (DWORD)(0xfffffff6)
#define STD_OUTPUT_HANDLE   (DWORD)(0xfffffff5)
#define STD_ERROR_HANDLE   (DWORD)(0xfffffff4)
#define INVALID_HANDLE_VALUE   (HANDLE)(-1)
#define GET_TAPE_MEDIA_INFORMATION   0
#define GET_TAPE_DRIVE_INFORMATION   1
#define SET_TAPE_MEDIA_INFORMATION   0
#define SET_TAPE_DRIVE_INFORMATION   1
#define THREAD_PRIORITY_ABOVE_NORMAL   1
#define THREAD_PRIORITY_BELOW_NORMAL   (-1)
#define THREAD_PRIORITY_HIGHEST   2
#define THREAD_PRIORITY_IDLE   (-15)
#define THREAD_PRIORITY_LOWEST   (-2)
#define THREAD_PRIORITY_NORMAL   0
#define THREAD_PRIORITY_TIME_CRITICAL   15
#define THREAD_PRIORITY_ERROR_RETURN   2147483647
#define TIME_ZONE_ID_UNKNOWN   0
#define TIME_ZONE_ID_STANDARD   1
#define TIME_ZONE_ID_DAYLIGHT   2
#define TIME_ZONE_ID_INVALID   0xFFFFFFFF
#define FS_CASE_IS_PRESERVED   2
#define FS_CASE_SENSITIVE   1
#define FS_UNICODE_STORED_ON_DISK   4
#define FS_PERSISTENT_ACLS   8
#define FS_FILE_COMPRESSION   16
#define FS_VOL_IS_COMPRESSED   32768
#define GMEM_FIXED   0
#define GMEM_MOVEABLE   2
#define GMEM_MODIFY   128
#define GPTR   64
#define GHND   66
#define GMEM_DDESHARE   8192
#define GMEM_DISCARDABLE   256
#define GMEM_LOWER   4096
#define GMEM_NOCOMPACT   16
#define GMEM_NODISCARD   32
#define GMEM_NOT_BANKED   4096
#define GMEM_NOTIFY   16384
#define GMEM_SHARE   8192
#define GMEM_ZEROINIT   64
#define GMEM_DISCARDED   16384
#define GMEM_INVALID_HANDLE   32768
#define GMEM_LOCKCOUNT   255
#define GMEM_VALID_FLAGS   32626
#define EXCEPTION_ACCESS_VIOLATION   ((DWORD)0xC0000005)
#define EXCEPTION_DATATYPE_MISALIGNMENT   ((DWORD)0x80000002)
#define EXCEPTION_BREAKPOINT   ((DWORD)0x80000003)
#define EXCEPTION_SINGLE_STEP   ((DWORD)0x80000004)
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED   ((DWORD)0xC000008C)
#define EXCEPTION_FLT_DENORMAL_OPERAND   ((DWORD)0xC000008D)
#define EXCEPTION_FLT_DIVIDE_BY_ZERO   ((DWORD)0xC000008E)
#define EXCEPTION_FLT_INEXACT_RESULT   ((DWORD)0xC000008F)
#define EXCEPTION_FLT_INVALID_OPERATION   ((DWORD)0xC0000090)
#define EXCEPTION_FLT_OVERFLOW   ((DWORD)0xC0000091)
#define EXCEPTION_FLT_STACK_CHECK   ((DWORD)0xC0000092)
#define EXCEPTION_FLT_UNDERFLOW   ((DWORD)0xC0000093)
#define EXCEPTION_INT_DIVIDE_BY_ZERO   ((DWORD)0xC0000094)
#define EXCEPTION_INT_OVERFLOW   ((DWORD)0xC0000095)
#define EXCEPTION_PRIV_INSTRUCTION   ((DWORD)0xC0000096)
#define EXCEPTION_IN_PAGE_ERROR   ((DWORD)0xC0000006)
#define EXCEPTION_ILLEGAL_INSTRUCTION   ((DWORD)0xC000001D)
#define EXCEPTION_NONCONTINUABLE_EXCEPTION   ((DWORD)0xC0000025)
#define EXCEPTION_STACK_OVERFLOW   ((DWORD)0xC00000FD)
#define EXCEPTION_INVALID_DISPOSITION   ((DWORD)0xC0000026)
#define EXCEPTION_GUARD_PAGE   ((DWORD)0x80000001)
#define EXCEPTION_INVALID_HANDLE   ((DWORD)0xC0000008L)
#define CONTROL_C_EXIT   ((DWORD)0xC000013A)
#define PROCESS_HEAP_REGION   1
#define PROCESS_HEAP_UNCOMMITTED_RANGE   2
#define PROCESS_HEAP_ENTRY_BUSY   4
#define PROCESS_HEAP_ENTRY_MOVEABLE   16
#define PROCESS_HEAP_ENTRY_DDESHARE   32
#define DONT_RESOLVE_DLL_REFERENCES   1
#define LOAD_LIBRARY_AS_DATAFILE   2
#define LOAD_WITH_ALTERED_SEARCH_PATH   8
#define LOAD_IGNORE_CODE_AUTHZ_LEVEL   16
#define LOAD_LIBRARY_AS_IMAGE_RESOURCE   32
#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE   64
#define LMEM_FIXED   0
#define LMEM_MOVEABLE   2
#define LMEM_NONZEROLHND   2
#define LMEM_NONZEROLPTR   0
#define LMEM_DISCARDABLE   3840
#define LMEM_NOCOMPACT   16
#define LMEM_NODISCARD   32
#define LMEM_ZEROINIT   64
#define LMEM_DISCARDED   16384
#define LMEM_MODIFY   128
#define LMEM_INVALID_HANDLE   32768
#define LMEM_LOCKCOUNT   255
#define LMEM_VALID_FLAGS   0x0F72
#define LPTR   64
#define LHND   66
#define NONZEROLHND   2
#define NONZEROLPTR   0
#define LOCKFILE_FAIL_IMMEDIATELY   1
#define LOCKFILE_EXCLUSIVE_LOCK   2
#define LOGON32_PROVIDER_DEFAULT   0
#define LOGON32_PROVIDER_WINNT35   1
#define LOGON32_PROVIDER_WINNT40   2
#define LOGON32_PROVIDER_WINNT50   3
#define LOGON32_LOGON_INTERACTIVE   2
#define LOGON32_LOGON_NETWORK   3
#define LOGON32_LOGON_BATCH   4
#define LOGON32_LOGON_SERVICE   5
#define LOGON32_LOGON_UNLOCK   7
#define LOGON32_LOGON_NETWORK_CLEARTEXT   8
#define LOGON32_LOGON_NEW_CREDENTIALS   9
#define MOVEFILE_REPLACE_EXISTING   1
#define MOVEFILE_COPY_ALLOWED   2
#define MOVEFILE_DELAY_UNTIL_REBOOT   4
#define MOVEFILE_WRITE_THROUGH   8
#define MOVEFILE_CREATE_HARDLINK   16
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE   32
#define MAXIMUM_WAIT_OBJECTS   64
#define MAXIMUM_SUSPEND_COUNT   0x7F
#define WAIT_OBJECT_0   0
#define WAIT_ABANDONED_0   128
#ifndef WAIT_TIMEOUT
#   define WAIT_TIMEOUT   258  // Also in <winerror.h>
#endif
#define WAIT_IO_COMPLETION   0xC0
#define WAIT_ABANDONED   128
#define WAIT_FAILED   ((DWORD)0xFFFFFFFF)
#define PURGE_TXABORT   1
#define PURGE_RXABORT   2
#define PURGE_TXCLEAR   4
#define PURGE_RXCLEAR   8
#define EVENTLOG_SUCCESS   0
#define EVENTLOG_FORWARDS_READ   4
#define EVENTLOG_BACKWARDS_READ   8
#define EVENTLOG_SEEK_READ   2
#define EVENTLOG_SEQUENTIAL_READ   1
#define EVENTLOG_ERROR_TYPE   1
#define EVENTLOG_WARNING_TYPE   2
#define EVENTLOG_INFORMATION_TYPE   4
#define EVENTLOG_AUDIT_SUCCESS   8
#define EVENTLOG_AUDIT_FAILURE   16
#define FORMAT_MESSAGE_ALLOCATE_BUFFER   256
#define FORMAT_MESSAGE_IGNORE_INSERTS   512
#define FORMAT_MESSAGE_FROM_STRING   1024
#define FORMAT_MESSAGE_FROM_HMODULE   2048
#define FORMAT_MESSAGE_FROM_SYSTEM   4096
#define FORMAT_MESSAGE_ARGUMENT_ARRAY   8192
#define FORMAT_MESSAGE_MAX_WIDTH_MASK   255
#define EV_BREAK   64
#define EV_CTS   8
#define EV_DSR   16
#define EV_ERR   128
#define EV_EVENT1   2048
#define EV_EVENT2   4096
#define EV_PERR   512
#define EV_RING   256
#define EV_RLSD   32
#define EV_RX80FULL   1024
#define EV_RXCHAR   1
#define EV_RXFLAG   2
#define EV_TXEMPTY   4
#define SEM_FAILCRITICALERRORS   1  // Also in ddk/ntapi.h
#define SEM_NOGPFAULTERRORBOX   2  // Also in ddk/ntapi.h
#define SEM_NOALIGNMENTFAULTEXCEPT   4  // Also in ddk/ntapi.h
#define SEM_NOOPENFILEERRORBOX   0x8000  // Also in ddk/ntapi.h
#define SLE_ERROR   1
#define SLE_MINORERROR   2
#define SLE_WARNING   3
#define SHUTDOWN_NORETRY   1
#define MAXINTATOM   0xC000
#define INVALID_ATOM   ((ATOM)0)
#ifndef IGNORE
#   define IGNORE   0
#endif
#define INFINITE   0xFFFFFFFF
#define NOPARITY   0
#define ODDPARITY   1
#define EVENPARITY   2
#define MARKPARITY   3
#define SPACEPARITY   4
#define ONESTOPBIT   0
#define ONE5STOPBITS   1
#define TWOSTOPBITS   2
#define CBR_110   110
#define CBR_300   300
#define CBR_600   600
#define CBR_1200   1200
#define CBR_2400   2400
#define CBR_4800   4800
#define CBR_9600   9600
#define CBR_14400   14400
#define CBR_19200   19200
#define CBR_38400   38400
#define CBR_56000   56000
#define CBR_57600   57600
#define CBR_115200   115200
#define CBR_128000   128000
#define CBR_256000   256000
#define BACKUP_INVALID   0
#define BACKUP_DATA   1
#define BACKUP_EA_DATA   2
#define BACKUP_SECURITY_DATA   3
#define BACKUP_ALTERNATE_DATA   4
#define BACKUP_LINK   5
#define BACKUP_PROPERTY_DATA   6
#define BACKUP_OBJECT_ID   7
#define BACKUP_REPARSE_DATA   8
#define BACKUP_SPARSE_BLOCK   9
#define STREAM_NORMAL_ATTRIBUTE 0
#define STREAM_MODIFIED_WHEN_READ 1
#define STREAM_CONTAINS_SECURITY   2
#define STREAM_CONTAINS_PROPERTIES   4
#define STARTF_USESHOWWINDOW   1
#define STARTF_USESIZE   2
#define STARTF_USEPOSITION   4
#define STARTF_USECOUNTCHARS   8
#define STARTF_USEFILLATTRIBUTE   0x10
#define STARTF_RUNFULLSCREEN   0x20
#define STARTF_FORCEONFEEDBACK   0x40
#define STARTF_FORCEOFFFEEDBACK   0x80
#define STARTF_USESTDHANDLES   0x100
#if (WINVER >= 0x400)
#   define STARTF_USEHOTKEY   0x200
#   define STARTF_TITLEISLINKNAME   0x800
#   define STARTF_TITLEISAPPID   0x1000
#   define STARTF_PREVENTPINNING   0x2000
#endif  // (WINVER >= 0x400)
#define TC_NORMAL   0
#define TC_HARDERR   1
#define TC_GP_TRAP   2
#define TC_SIGNAL   3
#define AC_LINE_OFFLINE   0
#define AC_LINE_ONLINE   1
#define AC_LINE_BACKUP_POWER   2
#define AC_LINE_UNKNOWN   255
#define BATTERY_FLAG_HIGH   1
#define BATTERY_FLAG_LOW   2
#define BATTERY_FLAG_CRITICAL   4
#define BATTERY_FLAG_CHARGING   8
#define BATTERY_FLAG_NO_BATTERY   128
#define BATTERY_FLAG_UNKNOWN   255
#define BATTERY_PERCENTAGE_UNKNOWN   255
#define BATTERY_LIFE_UNKNOWN   0xFFFFFFFF
#define DDD_RAW_TARGET_PATH   1
#define DDD_REMOVE_DEFINITION   2
#define DDD_EXACT_MATCH_ON_REMOVE   4
#define DDD_NO_BROADCAST_SYSTEM   8
#define DDD_LUID_BROADCAST_DRIVE   16
#define HINSTANCE_ERROR   32
#define MS_CTS_ON   16
#define MS_DSR_ON   32
#define MS_RING_ON   64
#define MS_RLSD_ON   128
#define DTR_CONTROL_DISABLE   0
#define DTR_CONTROL_ENABLE   1
#define DTR_CONTROL_HANDSHAKE   2
#define RTS_CONTROL_DISABLE   0
#define RTS_CONTROL_ENABLE   1
#define RTS_CONTROL_HANDSHAKE   2
#define RTS_CONTROL_TOGGLE   3
#define SECURITY_ANONYMOUS   (SecurityAnonymous << 16)
#define SECURITY_IDENTIFICATION   (SecurityIdentification << 16)
#define SECURITY_IMPERSONATION   (SecurityImpersonation << 16)
#define SECURITY_DELEGATION   (SecurityDelegation << 16)
#define SECURITY_CONTEXT_TRACKING   0x40000
#define SECURITY_EFFECTIVE_ONLY   0x80000
#define SECURITY_SQOS_PRESENT   0x100000
#define SECURITY_VALID_SQOS_FLAGS   0x1F0000
#define INVALID_FILE_SIZE   0xFFFFFFFF
#define TLS_OUT_OF_INDEXES   (DWORD)0xFFFFFFFF


#endif  // WINBASE


/* DEV_T ACCESS (<sys/sysmacros.h>) */


#if (!(defined(_SYS_SYSMACROS_H) || defined(_SYS_SYSMACROS_H_)))
#define _SYS_SYSMACROS_H   (1)
#define _SYS_SYSMACROS_H_   (1)


#define gnu_dev_major(__dev)   ((((unsigned long long)__dev) >> 8) & 0xFFF) | ((unsigned int)(((unsigned long long)__dev) >> 0x20) & 0xFFFFF000);

#define gnu_dev_minor(__dev)   ((unsigned long long)__dev) & 0xFF) | ((unsigned int)((unsigned long long)__dev) >> 0xC) & 0xFFFFFF00);

#define gnu_dev_makedev(__major, __minor)   ((((unsigned int)__minor) & 0xFF) | ((((unsigned int)__major) & 0xFFF) << 8) | (((unsigned long long)(((unsigned int)__minor) & 0xFFFFFF00)) << 12) | (((unsigned long long)(((unsigned int)__major) & 0xFFFFF000)) << 0x20));

#if (defined(OSNETBSD) || defined(OSMINIX))
#   define major(x)   ((int32_t)((((x) & 0xFFF00) >> 8)))
#   define minor(x)   ((int32_t)((((x) & 0xFFF00000) >> 0xC) | (((x) & 0xFF) >> 0)))
#   define makedev(x, y)   ((dev_t)((((x) << 8) & 0xFFF00) | (((y) << 0xC) & 0xFFF00000) | ((y) & 0xFF)))
#elif defined(OSANDROID)
#   define major(x)   (((x) >> 8) & 0xfff)
#   define minor(x)   (((x) & 0xff) | (((x) >> 12) & 0xfff00))
#   define makedev(x, y)   ((((x) & 0xfff) << 8) | ((y) & 0xff) | (((y) & 0xfff00) << 12))
#elif defined(OSSUN)
/** Major part of a device */
#   define major(x)   ((int)(((unsigned)(x) >> 8) & 0377))
/** Minor part of a device */
#   define minor(x)   ((int)((x) & 0377))
/** Make a device number */
#   define makedev(x, y)   ((dev_t)(((x) << 8) | (y)))
/** Number of SVR4 major device bits */
#   define L_BITSMAJOR   14
/** Number of SVR4 minor device bits */
#   define L_BITSMINOR   18
/** MAX minor for 3b2 software drivers; For 3b2 hardware devices the minor is restricted to 256 (0-255) */
#   define L_MAXMIN   0x3ffff
/** Number of SunOS 4.x minor device bits */
#   define O_BITSMINOR   8
/** SunOS 4.x max major value */
#   define O_MAXMAJ   0xff
/** SunOS 4.x max minor value */
#   define O_MAXMIN   0xff
/** Convert to old dev format */
#   define cmpdev(x)   (unsigned long)((((x) >> L_BITSMINOR) > O_MAXMAJ || ((x) & L_MAXMIN) > O_MAXMIN) ? NODEV : ((((x) >> L_BITSMINOR) << O_BITSMINOR) | ((x) & O_MAXMIN)))
#else
#   define major(x)   gnu_dev_major(x)
#   define minor(x)   gnu_dev_minor(x)
#   define makedev(x, y)   gnu_dev_makedev(x, y)
#endif


#endif  // SYS_SYSMACROS_H


/* STREAMS INTERFACE (<stropts.h>) */


#if (!(defined(_BITS_STROPTS_H) || defined(_BITS_STROPTS_H_) || defined(_STROPTS_H_) || defined(_STROPTS_H)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stropts.h.html
#define _BITS_STROPTS_H_   (1)
#define _BITS_STROPTS_H   (1)
#define _STROPTS_H_   (1)
#define _STROPTS_H   (1)


/** Macros used as `request` argument to `ioctl` */
#define __SID   0x5300  // 'S' << 8
/** Counts the number of data bytes in the data block in the first message */
#define I_NREAD   (__SID | 1)
/** Push STREAMS module onto top of the current STREAM, just below the STREAM head */
#define I_PUSH   (__SID | 2)
/** Remove STREAMS module from just below the STREAM head */
#define I_POP   (__SID | 3)
/** Retrieve the name of the module just below the STREAM head and place it in a character string */
#define I_LOOK   (__SID | 4)
/** Flush all input and/or output */
#define I_FLUSH   (__SID | 5)
/** Sets the read mode */
#define I_SRDOPT   (__SID | 6)
/** Returns the current read mode setting */
#define I_GRDOPT   (__SID | 7)
/** Construct an internal STREAMS `ioctl` message and send that message downstream */
#define I_STR   (__SID | 8)
/** Inform the STREAM head that the process wants the SIGPOLL signal issued */
#define I_SETSIG   (__SID | 9)
/** Return the events for which the calling process is currently registered to be sent a SIGPOLL signal */
#define I_GETSIG   (__SID | 10)
/** Compares the names of all modules currently present in the STREAM to the name pointed to by `arg` */
#define I_FIND   (__SID | 11)
/** Connect two STREAMs */
#define I_LINK   (__SID | 12)
/** Disconnects the two STREAMs */
#define I_UNLINK   (__SID | 13)
/** Allows a process to retrieve the information in the first message on the STREAM head read queue without taking the message off the queue */
#define I_PEEK   (__SID | 15)
/** Create a message from the specified buffer(s), adds information about another STREAM, and send the message downstream */
#define I_FDINSERT   (__SID | 16)
/** Requests the STREAM associated with `fildes` to send a message, containing a file-pointer, to the STREAM head at the other end of a STREAMS pipe */
#define I_SENDFD   (__SID | 17)
/** Non-EFT definition */
#define I_RECVFD   (__SID | 14)
/** Set the write mode */
#define I_SWROPT   (__SID | 19)
/** Return the current write mode setting */
#define I_GWROPT   (__SID | 20)
/** List all the module names on the STREAM, up to and including the topmost driver name */
#define I_LIST   (__SID | 21)
/** Connect two STREAMs with a persistent link */
#define I_PLINK   (__SID | 22)
/** Disconnect the two STREAMs that were connected with a persistent link */
#define I_PUNLINK   (__SID | 23)
/** Flush only band specified */
#define I_FLUSHBAND   (__SID | 28)
/** Check if the message of a given priority band exists on the STREAM head read queue */
#define I_CKBAND   (__SID | 29)
/** Return the priority band of the first message on the STREAM head read queue */
#define I_GETBAND   (__SID | 30)
/** See if the current message on the STREAM head read queue is "marked" by some module downstream */
#define I_ATMARK   (__SID | 31)
/** Set the time the STREAM head will delay when a STREAM is closing and there is data on the write queues */
#define I_SETCLTIME   (__SID | 32)
/** Get current value for closing timeout */
#define I_GETCLTIME   (__SID | 33)
/** Check if a certain band is writable */
#define I_CANPUT   (__SID | 34)
/** Used in `I_LOOK` request; UnixWare/Solaris compatibility */
#define FMNAMESZ   8
/** Flush read queues */
#define FLUSHR   1
/** Flush write queues */
#define FLUSHW   2
/** Flush read and write queues */
#define FLUSHRW   3
/** Flush only specified band */
#define FLUSHBAND   4
// Possible arguments for `I_SETSIG`
/** A message, other than a high-priority message, has arrived */
#define S_INPUT   1
/** A high-priority message is present */
#define S_HIPRI   2
/** The write queue for normal data is no longer full */
#define S_OUTPUT   4
/** A STREAMS signal message that contains the SIGPOLL signal reaches the front of the STREAM head read queue */
#define S_MSG   8
/** Notification of an error condition */
#define S_ERROR   0x10
/** Notification of a hangup */
#define S_HANGUP   0x20
/** A normal message has arrived */
#define S_RDNORM   0x40
#define S_WRNORM   S_OUTPUT
/** A message with a non-zero priority has arrived */
#define S_RDBAND   0x80
/** The write queue for a non-zero priority band is no longer full */
#define S_WRBAND   0x100
/** When used in conjunction with S_RDBAND, SIGURG is generated instead of SIGPOLL when a priority message reaches the front of the STREAM head read queue */
#define S_BANDURG   0x200
/** Option for `I_PEEK`; Only look for high-priority messages */
#define RS_HIPRI   1
// Options for `I_SRDOPT`
/** Byte-STREAM mode, the default */
#define RNORM   0
/** Message-discard mode */
#define RMSGD   1
/** Message-nondiscard mode */
#define RMSGN   2
/** Deliver the control part of a message as data */
#define RPROTDAT   4
/** Discard the control part of a message, delivering any data part */
#define RPROTDIS   8
/** Fail `read` with EBADMSG if a message containing a control part is at the front of the STREAM head read queue */
#define RPROTNORM   0x10
/** The RPROT bits */
#define RPROTMASK   0x1C
// Possible modes for `I_SWROPT`
/** Send a zero-length message downstream when a `write` of 0 bytes occurs */
#define SNDZERO   1
/** Send SIGPIPE on write and putmsg if sd_werror is set */
#define SNDPIPE   2
// Arguments for `I_ATMARK`
/** Check if the message is marked */
#define ANYMARK   1
/** Check if the message is the last one marked on the queue */
#define LASTMARK   2
/** Argument for `I_UNLINK`; Unlink all STREAMs linked to the STREAM associated with `fildes` */
#define MUXID_ALL   -1
/** Send/receive high priority message */
#define MSG_HIPRI   1
/** Receive any message */
#define MSG_ANY   2
/** Receive message from specified band */
#define MSG_BAND   4
/** More control information is left in message; returned by getmsg and getpmsg */
#define MORECTL   1
/** More data is left in message; returned by getmsg and getpmsg */
#define MOREDATA   2


/** Structure used for the I_FLUSHBAND ioctl on streams */
typedef struct attr_packed bandinfo {
	unsigned char bi_pri;
	int bi_flag;
} bandinfo_t;


typedef struct strbuf {
	int maxlen;  // Maximum buffer length
	int len;  // Length of data
	char* buf;  // Pointer to buffer
} strbuf_t;


typedef struct strpeek {
	struct strbuf ctlbuf, databuf;
	t_uscalar_t flags;  // UnixWare/Solaris compatibility
} strpeek_t;


typedef struct strfdinsert {
	struct strbuf ctlbuf, databuf;
	t_uscalar_t flags;  // UnixWare/Solaris compatibility
	int fildes, offset;
} strfdinsert_t;


typedef struct attr_packed strioctl {
	int ic_cmd, ic_timout, ic_len;
	char* ic_dp;
} strioctl_t;


typedef struct strrecvfd {
	int fd;
	uid_t uid;
	gid_t gid;
	char __fill[8];  // UnixWare/Solaris compatibility
} strrecvfd_t;


typedef struct str_mlist { char l_name[FMNAMESZ + 1]; }   str_mlist_t;


typedef struct str_list {
	const char* str;
	size_t len;
	struct str_list* next;
} str_list_t;


/* TODO: Add fcntl
// Test if the file-descriptor belongs to a stream
LIB_FUNC int isastream(const int fd) {
	return (int)((fcntl(fd, F_GETFD) < 0) ? (-1) : 0);
}
int fattach(int, const char*);
int fdetach(const char*);
int getmsg(int, struct strbuf* restrict, struct strbuf* restrict, int* restrict);
int getpmsg(int, struct strbuf* restrict, struct strbuf* restrict, int* restrict, int* restrict);
int ioctl(int, int, ...);
int putmsg(int, const struct strbuf*, const struct strbuf*, int);
int putpmsg(int, const struct strbuf*, const struct strbuf*, int, int);
*/


#endif  // STROPTS_H


/* IFADDRS (<ifaddrs.h>) */


#if (!(defined(_IFADDRS_H) || defined(_IFADDRS_H_)))
#define IFADDRS_H   (1)
#define _IFADDRS_H   (1)
#define _IFADDRS_H_   (1)


typedef struct attr_packed ifaddrs {
	struct ifaddrs* ifa_next;  // Next item in list
	const char* ifa_name;  // Name of interface
	unsigned int ifa_flags;  // Flags from SIOCGIFFLAGS
	struct sockaddr* ifa_addr;  // Address of interface
	struct sockaddr* ifa_netmask;  // Netmask of interface
	struct sockaddr* ifa_dstaddr;
	void* ifa_data;  // Address-specific data
} ifaddrs_t;
#define ifa_broadaddr   ifa_dstaddr


/** Routing statistics */
struct rtstat {
	short rts_badredirect, rts_dynamic, rts_newgateway, rts_unreach, rts_wildcard;
};


/** These numbers are used by reliable protocols for determining retransmission behavior and are included in the routing structure */
struct rt_metrics {
	unsigned long rmx_locks, rmx_mtu, rmx_hopcount, rmx_expire;
	unsigned long rmx_recvpipe, rmx_sendpipe, rmx_ssthresh, rmx_rtt;
	unsigned long rmx_rttvar, rmx_pksent;
	unsigned long rmx_filler[4];
};


/** Structures for routing messages */
struct rt_msghdr {
	unsigned short rtm_hdrlen, rtm_msglen;
	unsigned char rtm_version, rtm_type;
	unsigned short rtm_index;
	int rtm_flags, rtm_addrs;
	pid_t rtm_pid;
	int rtm_seq, rtm_errno, rtm_use;
	unsigned long rtm_inits;
	struct rt_metrics rtm_rmx;
};


/** Structure describing information about an interface which may be of interest to management entities */
struct attr_packed if_data {
	unsigned char ifi_type, ifi_physical, ifi_addrlen;
	unsigned char ifi_hdrlen, ifi_recvquota, ifi_xmitquota;
	unsigned long ifi_mtu, ifi_metric, ifi_baudrate;
	unsigned long ifi_ipackets, ifi_ierrors, ifi_opackets;
	unsigned long ifi_oerrors, ifi_collisions, ifi_ibytes;
	unsigned long ifi_obytes, ifi_imcasts, ifi_omcasts;
	unsigned long ifi_iqdrops, ifi_noproto, ifi_hwassist, ifi_unused;
	struct timeval ifi_lastchange;
};


/** Message format for use in obtaining information about interfaces from getkerninfo and the routing socket */
struct if_msghdr {
	unsigned short ifm_msglen;
	unsigned char ifm_version, ifm_type;
	int ifm_addrs, ifm_flags;
	unsigned short ifm_index;
	struct if_data ifm_data;
};


/** Message format for use in obtaining information about interface addresses from getkerninfo and the routing socket */
struct attr_packed ifa_msghdr {
	unsigned short ifam_msglen;
	unsigned char ifam_version, ifam_type;
	int ifam_addrs, ifam_flags;
	unsigned short ifam_index;
	int ifam_metric;
};


/** Structure of a Link-Level sockaddr */
struct sockaddr_dl {
	unsigned char sdl_len, sdl_family;
	unsigned short sdl_index;
	unsigned char sdl_type, sdl_nlen, sdl_alen, sdl_slen;
	char sdl_data[46];
};


#define SA_RLEN(sa)   ((sa)->sa_len ? (((sa)->sa_len + SALIGN) & (~SALIGN)) : (SALIGN + 1))
/** Route usable */
#define RTF_UP   1
/** Destination is a gateway */
#define RTF_GATEWAY   2
/** Host entry (net otherwise) */
#define RTF_HOST   4
/** Host or net unreachable */
#define RTF_REJECT   8
/** Created dynamically (by redirect) */
#define RTF_DYNAMIC   0x10
/** Modified dynamically (by redirect) */
#define RTF_MODIFIED   0x20
/** Message confirmed */
#define RTF_DONE   0x40
/** Unused  */
#define RTF_DELCLONE   0x80
/** Generate new routes on use */
#define RTF_CLONING   0x100
/** External daemon resolves name */
#define RTF_XRESOLVE   0x200
/** Generated by link layer (e.g. ARP) */
#define RTF_LLINFO   0x400
/** Manually added */
#define RTF_STATIC   0x800
/** Just discard pkts (during updates) */
#define RTF_BLACKHOLE   0x1000
/** Protocol specific routing flag */
#define RTF_PROTO2   0x4000
/** Protocol specific routing flag */
#define RTF_PROTO1   0x8000
/** Protocol requires cloning */
#define RTF_PRCLONING   0x10000
/** Route generated through cloning */
#define RTF_WASCLONED   0x20000
/** Protocol specific routing flag */
#define RTF_PROTO3   0x40000
/** Future use */
#define RTF_PINNED   0x100000
/** Route represents a local address */
#define RTF_LOCAL   0x200000
/** Route represents a bcast address */
#define RTF_BROADCAST   0x400000
/** Route represents a mcast address */
#define RTF_MULTICAST   0x800000
#define RTA_MASKS   (RTA_NETMASK | RTA_IFA | RTA_BRD)
/** Up the ante and ignore older versions */
#define RTM_VERSION   5
// Message types
/** Add Route */
#define RTM_ADD   1
/** Delete Route */
#define RTM_DELETE   2
/** Change Metrics or flags */
#define RTM_CHANGE   3
/** Report Metrics */
#define RTM_GET   4
/** Kernel Suspects Partitioning */
#define RTM_LOSING   5
/** Told to use different route */
#define RTM_REDIRECT   6
/** Lookup failed on this address */
#define RTM_MISS   7
/** Fix specified metrics */
#define RTM_LOCK   8
/** Caused by SIOCADDRT */
#define RTM_OLDADD   9
/** Caused by SIOCDELRT */
#define RTM_OLDDEL   0xa
/** Req to resolve dst to LL addr */
#define RTM_RESOLVE   0xb
/** Address being added to iface */
#define RTM_NEWADDR   0xc
/** Address being removed from iface */
#define RTM_DELADDR   0xd
/** Iface going up/down etc. */
#define RTM_IFINFO   0xe
/** Mcast group membership being added to if */
#define RTM_NEWMADDR   0xf
/** Mcast group membership being deleted */
#define RTM_DELMADDR   0x10
/** Iface arrival/departure */
#define RTM_IFANNOUNCE   0x11
// Bitmask values for rtm_inits and rmx_locks
/** Init or lock _mtu */
#define RTV_MTU   1
/** Init or lock _hopcount */
#define RTV_HOPCOUNT   2
/** Init or lock _expire */
#define RTV_EXPIRE   4
/** Init or lock _recvpipe */
#define RTV_RPIPE   8
/** Init or lock _sendpipe */
#define RTV_SPIPE   0x10
/** Init or lock _ssthresh */
#define RTV_SSTHRESH   0x20
/** Init or lock _rtt */
#define RTV_RTT   0x40
/** Init or lock _rttvar */
#define RTV_RTTVAR   0x80
// Bitmask values for rtm_addrs
/** Destination sockaddr present */
#define RTA_DST   1
/** Gateway sockaddr present */
#define RTA_GATEWAY   2
/** Netmask sockaddr present */
#define RTA_NETMASK   4
/** Cloning mask sockaddr present */
#define RTA_GENMASK   8
/** Interface name sockaddr present */
#define RTA_IFP   0x10
/** Interface addr sockaddr present */
#define RTA_IFA   0x20
/** Sockaddr for author of redirect */
#define RTA_AUTHOR   0x40
/** For NEWADDR, broadcast or p-p dest addr */
#define RTA_BRD   0x80
// Index offsets for sockaddr array for alternate internal encoding
/** Destination sockaddr present */
#define RTAX_DST   0
/** Gateway sockaddr present */
#define RTAX_GATEWAY   1
/** Netmask sockaddr present */
#define RTAX_NETMASK   2
/** Cloning mask sockaddr present */
#define RTAX_GENMASK   3
/** Interface name sockaddr present */
#define RTAX_IFP   4
/** Interface addr sockaddr present */
#define RTAX_IFA   5
/** Sockaddr for author of redirect */
#define RTAX_AUTHOR   6
/** For NEWADDR, broadcast or p-p dest addr */
#define RTAX_BRD   7
/** Size of array to allocate */
#define RTAX_MAX   8


LIB_FUNC int getifaddrs(struct ifaddrs** pif) {
	int icnt = 1, dcnt = 0, ncnt = 0, i;
	size_t needed, len, alen, dlen;
	char *buf = NULL, *bufp, *next, *p, *p0, *data, *names;
	struct ifaddrs* cif = 0;
	struct rt_msghdr* rtm;
	struct if_msghdr* ifm;
	struct ifa_msghdr* ifam;
	struct sockaddr_dl* dl;
	struct sockaddr* sa;
	register unsigned short index = 0;
	struct ifaddrs *ifa, *ift;
	int mib[6];
	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;
	while (1) {
		if (sysctl(mib, 6, NULL, &needed, NULL, 0) == -1) {
			free(buf);
			return -1;
		}
		if (needed == 0) { break; }
		if ((bufp = realloc(buf, needed)) == NULL) {
			free(buf);
			return -1;
		}
		buf = bufp;
		if (sysctl(mib, 6, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM) { continue; }
			free(buf);
			return -1;
		}
		break;
	}
	next = buf;
	rtm = (struct rt_msghdr*)next;
	for (; next < (buf + needed); next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr*)next;
		if (rtm->rtm_version != RTM_VERSION) { continue; }
		switch (rtm->rtm_type) {
			case RTM_IFINFO:
				ifm = (struct if_msghdr*)rtm;
				if (ifm->ifm_addrs & RTA_IFP) {
					index = ifm->ifm_index;
					++icnt;
					dl = (struct sockaddr_dl*)(next + rtm->rtm_hdrlen);
					dcnt += SA_RLEN((struct sockaddr*)dl) + ALIGNBYTES;
					dcnt += (int)sizeof(ifm->ifm_data);
					ncnt += dl->sdl_nlen + 1;
				} else { index = 0; }
				break;
			case RTM_NEWADDR:
				ifam = (struct ifa_msghdr*)rtm;
				if (index && ifam->ifam_index != index) { abort(); }
				else if (index == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0) { break; }
				p = next + rtm->rtm_hdrlen;
				++icnt;
				alen = 0;
				for (p0 = p, i = 0; i < RTAX_MAX; i++) {
					if ((RTA_MASKS & ifam->ifam_addrs & (1 << i)) == 0) { continue; }
					sa = (struct sockaddr*)p;
					len = (size_t)SA_RLEN(sa);
					if (i == RTAX_IFA) {
						alen = len;
						break;
					}
					p += len;
				}
				for (p = p0, i = 0; i < RTAX_MAX; i++) {
					if ((RTA_MASKS & ifam->ifam_addrs & (1 << i)) == 0) { continue; }
					sa = (struct sockaddr*)p;
					len = (size_t)SA_RLEN(sa);
					if (i == RTAX_NETMASK && sa->sa_len == 0) { dcnt += (int)alen; }
					else { dcnt = dcnt + (int)len; }
					p += len;
				}
				break;
			default: break;
		}
	}
	if (icnt + dcnt + ncnt == 1) {
		*pif = NULL;
		free(buf);
		return 0;
	}
	data = malloc((size_t)((sizeof(struct ifaddrs) * (size_t)icnt) + (size_t)dcnt + (size_t)ncnt));
	if (data == NULL) {
		free(buf);
		return -1;
	}
	ifa = (struct ifaddrs*)data;
	data += (int)(sizeof(struct ifaddrs) * (size_t)icnt);
	names = data + dcnt;
	memset(ifa, 0, sizeof(struct ifaddrs) * (size_t)icnt);
	ift = ifa;
	index = 0;
	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr*)next;
		if (rtm->rtm_version != RTM_VERSION) { continue; }
		switch (rtm->rtm_type) {
			case RTM_IFINFO:
				ifm = (struct if_msghdr*)rtm;
				if (ifm->ifm_addrs & RTA_IFP) {
					index = ifm->ifm_index;
					dl = (struct sockaddr_dl*)(next + rtm->rtm_hdrlen);
					cif = ift;
					ift->ifa_name = names;
					ift->ifa_flags = (unsigned int)ifm->ifm_flags;
					memcpy_no_output(names, dl->sdl_data, dl->sdl_nlen);
					names[dl->sdl_nlen] = 0;
					names += dl->sdl_nlen + 1;
					ift->ifa_addr = (struct sockaddr*)data;
					memcpy_no_output(data, dl, ((struct sockaddr*)dl)->sa_len);
					data += SA_RLEN((struct sockaddr*)dl);
					ift->ifa_data = data = (void*)ALIGN(data);
					dlen = rtm->rtm_hdrlen - offsetof(struct if_msghdr, ifm_data);
					if (dlen > sizeof(ifm->ifm_data)) { dlen = sizeof(ifm->ifm_data); }
					memcpy_no_output(data, &ifm->ifm_data, dlen);
	 				data += sizeof(ifm->ifm_data);
					ift = (ift->ifa_next = ift + 1);
				} else { index = 0; }
				break;
			case RTM_NEWADDR:
				ifam = (struct ifa_msghdr*)rtm;
				if (index && ifam->ifam_index != index) { abort(); }
				if (index == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0) { break; }
				ift->ifa_name = cif->ifa_name;
				ift->ifa_flags = cif->ifa_flags;
				ift->ifa_data = NULL;
				p = next + rtm->rtm_hdrlen;
				alen = 0;
				for (p0 = p, i = 0; i < RTAX_MAX; i++) {
					if ((RTA_MASKS & ifam->ifam_addrs & (1 << i)) == 0) { continue; }
					sa = (struct sockaddr*)p;
					len = (size_t)SA_RLEN(sa);
					if (i == RTAX_IFA) {
						alen = len;
						break;
					}
					p += len;
				}
				for (p = p0, i = 0; i < RTAX_MAX; i++) {
					if ((RTA_MASKS & ifam->ifam_addrs & (1 << i)) == 0) { continue; }
					sa = (struct sockaddr*)p;
					len = (size_t)SA_RLEN(sa);
					switch (i) {
						case RTAX_IFA:
							ift->ifa_addr = (struct sockaddr*)data;
							memcpy_no_output(data, p, len);
							data += len;
							break;
						case RTAX_NETMASK:
							ift->ifa_netmask = (struct sockaddr*)data;
							if (sa->sa_len == 0) {
								memset(data, 0, alen);
								data += alen;
								break;
							}
							memcpy_no_output(data, p, len);
							data += len;
							break;
						case RTAX_BRD:
							ift->ifa_broadaddr = (struct sockaddr*)data;
							memcpy_no_output(data, p, len);
							data += len;
							break;
						default: break;
					}
					p += len;
				}
				ift = (ift->ifa_next = ift + 1);
				break;
			default: break;
		}
	}
	free(buf);
	if (--ift >= ifa) {
		ift->ifa_next = NULL;
		*pif = ifa;
	} else {
		*pif = NULL;
		free(ifa);
	}
	return 0;
}


LIB_FUNC void freeifaddrs(struct ifaddrs* ifp) {
	if (ifp != NULL) { free(ifp); }
}


#endif  // IFADDRS_H


/* ETHERNET PROTOCOL TYPES (<net/ethernet.h> & <net/ethertypes.h>) */


#if (!(defined(_NET_ETHERNET_H) || defined(_NET_ETHERNET_H_) || defined(_NET_ETHERTYPES_H) || defined(_NET_ETHERTYPES_H_)))
/** According to "assigned numbers", the Ethernet protocol numbers are also used as ARP protocol type numbers. Additional sources of information:
 - http://www.mit.edu/~map/Ethernet/Ethernet.txt
 - ftp://venera.isi.edu/in-notes/iana/assignments/ethernet-numbers
*/
#define NET_ETHERNET_H   (1)
#define _NET_ETHERNET_H   (1)
#define _NET_ETHERNET_H_   (1)
#define NET_ETHERTYPES_H   (1)
#define _NET_ETHERTYPES_H   (1)
#define _NET_ETHERTYPES_H_   (1)


#ifndef ETH_ALEN
#   define ETH_ALEN   6
#endif
#define ETHER_ADDR_LEN   ETH_ALEN
#define ETHER_TYPE_LEN   2
#define ETHER_CRC_LEN   4
#define ETHER_HDR_LEN   ETH_HLEN
#define ETHER_MIN_LEN   (ETH_ZLEN + ETHER_CRC_LEN)
#define ETHER_MAX_LEN   (ETH_FRAME_LEN + ETHER_CRC_LEN)
#define ETHER_IS_VALID_LEN(foo)   ((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
#define ETHERTYPE_NTRAILER   16
#define ETHERMTU   ETH_DATA_LEN
#define ETHERMIN   (ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
/** IEEE 802.3 packet */
#define ETHERTYPE_8023   4
/* 0x0101 - 0x1FF: Experimental */
/** Xerox PUP protocol */
#define ETHERTYPE_PUP   0x200
/** PUP Address Translation */
#define ETHERTYPE_PUPAT   0x200
/* 0x400: Nixdorf */
#define ETHERTYPE_SPRITE   0x500
/** XNS */
#define ETHERTYPE_NS   0x600
/** XNS Address Translation (3Mb only) */
#define ETHERTYPE_NSAT   0x601
/** DLOG */
#define ETHERTYPE_DLOG1   0x660
/** DLOG */
#define ETHERTYPE_DLOG2   0x661
/** IP protocol */
#define ETHERTYPE_IP   0x800
/** X.75 Internet */
#define ETHERTYPE_X75   0x801
/** NBS Internet */
#define ETHERTYPE_NBS   0x802
/** ECMA Internet */
#define ETHERTYPE_ECMA   0x803
/** CHAOSnet */
#define ETHERTYPE_CHAOS   0x804
/** X.25 Level 3 */
#define ETHERTYPE_X25   0x805
/** Address resolution protocol */
#define ETHERTYPE_ARP   0x806
/** XNS Compatibility */
#define ETHERTYPE_NSCOMPAT   0x807
/** Frame Relay ARP (RFC1701) */
#define ETHERTYPE_FRARP   0x808
/* 0x81C: Private Symbolics */
/* 0x888 - 0x88A: Xyplex */
/** Ungermann-Bass network debugger */
#define ETHERTYPE_UBDEBUG   0x900
/** Xerox IEEE802.3 PUP */
#define ETHERTYPE_IEEEPUP   0xA00
/** Xerox IEEE802.3 PUP Address Translation */
#define ETHERTYPE_IEEEPUPAT   0xA01
/** Banyan VINES */
#define ETHERTYPE_VINES   0xBAD
/** Banyan VINES Loopback */
#define ETHERTYPE_VINESLOOP   0xBAE
/** Banyan VINES Echo */
#define ETHERTYPE_VINESECHO   0xBAF
/* 0x1000 - 0x100F: Berkeley Trailer */
/** Trailer packet */
#define ETHERTYPE_TRAIL   0x1000
/** DCA - Multicast */
#define ETHERTYPE_DCA   0x1234
/** VALID system protocol */
#define ETHERTYPE_VALID   0x1600
/** Artificial Horizons ("Aviator" dogfight simulator on SunOS) */
#define ETHERTYPE_DOGFIGHT   0x1989
/** Datapoint Corporation (RCL lan protocol) */
#define ETHERTYPE_RCL   0x1995
/* The following 3C0x types are unregistered */
/** 3Com NBP virtual circuit datagram (like XNS SPP) */
#define ETHERTYPE_NBPVCD   0x3C00
/** 3Com NBP System control datagram */
#define ETHERTYPE_NBPSCD   0x3C01
/** 3Com NBP Connect request (virtual cct) */
#define ETHERTYPE_NBPCREQ   0x3C02
/** 3Com NBP Connect response */
#define ETHERTYPE_NBPCRSP   0x3C03
/** 3Com NBP Connect complete */
#define ETHERTYPE_NBPCC   0x3C04
/** 3Com NBP Close request (virtual cct) */
#define ETHERTYPE_NBPCLREQ   0x3C05
/** 3Com NBP Close response */
#define ETHERTYPE_NBPCLRSP   0x3C06
/** 3Com NBP Datagram (like XNS IDP) */
#define ETHERTYPE_NBPDG   0x3C07
/** 3Com NBP Datagram broadcast */
#define ETHERTYPE_NBPDGB   0x3C08
/** 3Com NBP Claim NetBIOS name */
#define ETHERTYPE_NBPCLAIM   0x3C09
/** 3Com NBP Delete Netbios name */
#define ETHERTYPE_NBPDLTE   0x3C0A
/** 3Com NBP Remote adaptor status request */
#define ETHERTYPE_NBPRAS   0x3C0B
/** 3Com NBP Remote adaptor response */
#define ETHERTYPE_NBPRAR   0x3C0C
/** 3Com NBP Reset */
#define ETHERTYPE_NBPRST   0x3C0D
/** PCS Basic Block Protocol */
#define ETHERTYPE_PCS   0x4242
/** Information Modes Little Big LAN diagnostic */
#define ETHERTYPE_IMLBLDIAG   0x424C
/** THD - Diddle */
#define ETHERTYPE_DIDDLE   0x4321
/** Information Modes Little Big LAN */
#define ETHERTYPE_IMLBL   0x4C42
/** BBN Simnet Private */
#define ETHERTYPE_SIMNET   0x5208
/** DEC Unassigned, experimental */
#define ETHERTYPE_DECEXPER   0x6000
/** DEC MOP dump/load */
#define ETHERTYPE_MOPDL   0x6001
/** DEC MOP remote console */
#define ETHERTYPE_MOPRC   0x6002
/** DEC DECNET Phase IV route */
#define ETHERTYPE_DECnet   0x6003
/** libpcap, tcpdump */
#define ETHERTYPE_DN   ETHERTYPE_DECnet
/** DEC LAT */
#define ETHERTYPE_LAT   0x6004
/** DEC diagnostic protocol */
#define ETHERTYPE_DECDIAG   0x6005
/** DEC customer protocol */
#define ETHERTYPE_DECCUST   0x6006
/** DEC LAVC, SCA */
#define ETHERTYPE_SCA   0x6007
/** DEC AMBER */
#define ETHERTYPE_AMBER   0x6008
/** DEC MUMPS */
#define ETHERTYPE_DECMUMPS   0x6009
/* 0x6010 - 0x6014: 3Com Corporation */
/** Trans Ether Bridging (RFC1701)*/
#define ETHERTYPE_TRANSETHER   0x6558
/** Raw Frame Relay (RFC1701) */
#define ETHERTYPE_RAWFR   0x6559
/** Ungermann-Bass download */
#define ETHERTYPE_UBDL   0x7000
/** Ungermann-Bass NIUs */
#define ETHERTYPE_UBNIU   0x7001
/** Ungermann-Bass diagnostic/loopback */
#define ETHERTYPE_UBDIAGLOOP   0x7002
/** Ungermann-Base (NMC to/from UB Bridge) */
#define ETHERTYPE_UBNMC   0x7003
/** Ungermann-Bass Bridge Spanning Tree */
#define ETHERTYPE_UBBST   0x7005
/** OS/9 Microware */
#define ETHERTYPE_OS9   0x7007
/** OS/9 Net */
#define ETHERTYPE_OS9NET   0x7009
/* 0x7020 - 0x7029: LRT (England; now Sintrom) */
/** Racal-Interlan */
#define ETHERTYPE_RACAL   0x7030
/** Prime NTS (Network Terminal Service) */
#define ETHERTYPE_PRIMENTS   0x7031
/** Cabletron */
#define ETHERTYPE_CABLETRON   0x7034
/** Cronus VLN */
#define ETHERTYPE_CRONUSVLN   0x8003
/** Cronus Direct */
#define ETHERTYPE_CRONUS   0x8004
/** HP Probe */
#define ETHERTYPE_HP   0x8005
/** Nestar */
#define ETHERTYPE_NESTAR   0x8006
/** AT&T/Stanford (local use) */
#define ETHERTYPE_ATTSTANFORD   0x8008
/** Excelan */
#define ETHERTYPE_EXCELAN   0x8010
/** SGI diagnostic type */
#define ETHERTYPE_SG_DIAG   0x8013
/** SGI network games */
#define ETHERTYPE_SG_NETGAMES   0x8014
/** SGI reserved type */
#define ETHERTYPE_SG_RESV   0x8015
/** SGI bounce server */
#define ETHERTYPE_SG_BOUNCE   0x8016
/** Apollo DOMAIN */
#define ETHERTYPE_APOLLODOMAIN   0x8019
/** Tymeshare */
#define ETHERTYPE_TYMSHARE   0x802E
/** Tigan, Incorporated */
#define ETHERTYPE_TIGAN   0x802F
/** Reverse addr resolution protocol */
#define ETHERTYPE_REVARP   0x8035
/** Aeonic Systems */
#define ETHERTYPE_AEONIC   0x8036
/** IPX (Novell Netware) */
#define ETHERTYPE_IPXNEW   0x8037
/** DEC LANBridge */
#define ETHERTYPE_LANBRIDGE   0x8038
/** DEC DSM/DDP */
#define ETHERTYPE_DSMD   0x8039
/** DEC Argonaut Console */
#define ETHERTYPE_ARGONAUT   0x803A
/** DEC VAXELN */
#define ETHERTYPE_VAXELN   0x803B
/** DEC DNS Naming Service */
#define ETHERTYPE_DECDNS   0x803C
/** DEC Ethernet Encryption */
#define ETHERTYPE_ENCRYPT   0x803D
/** DEC Distributed Time Service */
#define ETHERTYPE_DECDTS   0x803E
/** DEC LAN Traffic Monitor */
#define ETHERTYPE_DECLTM   0x803F
/** DEC PATHWORKS DECnet NETBIOS Emulation */
#define ETHERTYPE_DECNETBIOS   0x8040
/** DEC Local Area System Transport */
#define ETHERTYPE_DECLAST   0x8041
/* 0x8042: DEC Unassigned */
/** Planning Research Corporation */
#define ETHERTYPE_PLANNING   0x8044
/* 0x8046 - 0x8047: AT&T */
/** DEC Availability Manager for Distributed Systems DECamds */
#define ETHERTYPE_DECAM   0x8048
/** ExperData */
#define ETHERTYPE_EXPERDATA   0x8049
/** Stanford V Kernel exp. */
#define ETHERTYPE_VEXP   0x805B
/** Stanford V Kernel prod. */
#define ETHERTYPE_VPROD   0x805C
/** Evans & Sutherland */
#define ETHERTYPE_ES   0x805D
/** Little Machines */
#define ETHERTYPE_LITTLE   0x8060
/** Counterpoint Computers */
#define ETHERTYPE_COUNTERPOINT   0x8062
/* 0x8065 - 0x8066: University of Mass @ Amherst */
/** Veeco Integrated Auto. */
#define ETHERTYPE_VEECO   0x8067
/** General Dynamics */
#define ETHERTYPE_GENDYN   0x8068
/** AT&T */
#define ETHERTYPE_ATT   0x8069
/** Autophon */
#define ETHERTYPE_AUTOPHON   0x806A
/** ComDesign */
#define ETHERTYPE_COMDESIGN   0x806C
/** Compugraphic Corporation */
#define ETHERTYPE_COMPUGRAPHIC   0x806D
/* 0x806E - 0x8077: Landmark Graphics Corporation */
/** Matra */
#define ETHERTYPE_MATRA   0x807A
/** Dansk Data Elektronik */
#define ETHERTYPE_DDE   0x807B
/** Merit Internodal or University of Michigan */
#define ETHERTYPE_MERIT   0x807C
/** 0x807D - 0x807F: Vitalink Communications */
/** Vitalink TransLAN III Management */
#define ETHERTYPE_VLTLMAN   0x8080
/* 0x8081 - 0x8083: Counterpoint Computers */
/* 0x8088 - 0x808A: Xyplex */
/** AppleTalk */
#define ETHERTYPE_ATALK   0x809B
/** AppleTalk (Old NetBSD) */
#define ETHERTYPE_AT   0x809B
/** AppleTalk (HP-UX) */
#define ETHERTYPE_APPLETALK   ETHERTYPE_ATALK
/* 0x809C - 0x809E: Datability */
/** Spider Systems Ltd. */
#define ETHERTYPE_SPIDER   0x809F
/* 0x80A3: Nixdorf */
/* 0x80A4 - 0x80B3: Siemens Gammasonics Inc. */
/* 0x80C0 - 0x80C3: DCA (Digital Comm. Assoc.) Data Exchange Cluster */
/* 0x80C4 - 0x80C5: Banyan Systems */
/** Pacer Software */
#define ETHERTYPE_PACER   0x80C6
/** Applitek Corporation */
#define ETHERTYPE_APPLITEK   0x80C7
/* 0x80C8 - 0x80CC: Intergraph Corporation */
/* 0x80CD - 0x80CE: Harris Corporation */
/* 0x80CF - 0x80D2: Taylor Instrument */
/* 0x80D3 - 0x80D4: Rosemount Corporation */
/** IBM SNA Services over Ethernet */
#define ETHERTYPE_SNA   0x80D5
/** Varian Associates */
#define ETHERTYPE_VARIAN   0x80DD
/* 0x80DE - 0x80DF: TRFS (Integrated Solutions Transparent Remote File System) */
/* 0x80E0 - 0x80E3: Allen-Bradley */
/* 0x80E4 - 0x80F0: Datability */
/** Retix */
#define ETHERTYPE_RETIX   0x80F2
/** AppleTalk AARP */
#define ETHERTYPE_AARP   0x80F3
/* 0x80F4 - 0x80F5: Kinetics */
/** Apollo Computer */
#define ETHERTYPE_APOLLO   0x80F7
/** IEEE 802.1Q VLAN tagging */
#define ETHERTYPE_VLAN   0x8100
/* 0x80FF - 0x8101: Wellfleet Communications */
/** Wellfleet; BOFL (Breath OF Life) pkts [every 5-10 secs.] */
#define ETHERTYPE_BOFL   0x8102
/** Wellfleet Communications */
#define ETHERTYPE_WELLFLEET   0x8103
/* 0x8107 - 0x8109: Private Symbolics */
/** Talaris */
#define ETHERTYPE_TALARIS   0x812B
/** Waterloo Microsystems Incorporated */
#define ETHERTYPE_WATERLOO   0x8130
/** Hayes Microcomputers */
#define ETHERTYPE_HAYES   0x8130
/** VG Laboratory Systems */
#define ETHERTYPE_VGLAB   0x8131
/* 0x8132 - 0x8137: Bridge Communications */
/** Novell; old NetWare IPX (ECONFIG E option) */
#define ETHERTYPE_IPX   0x8137
/** Novell, Incorporated */
#define ETHERTYPE_NOVELL   0x8138
/* 0x8139 - 0x813D: KTI */
 /** M/MUMPS data sharing */
#define ETHERTYPE_MUMPS   0x813F
/** Vrije Universiteit (NL) Amoeba 4 RPC (obsolete) */
#define ETHERTYPE_AMOEBA   0x8145
/** Vrije Universiteit (NL) FLIP (Fast Local Internet Protocol) */
#define ETHERTYPE_FLIP   0x8146
/** Vrije Universiteit (NL); reserved */
#define ETHERTYPE_VURESERVED   0x8147
/** Logicraft */
#define ETHERTYPE_LOGICRAFT   0x8148
/** Network Computing Devices */
#define ETHERTYPE_NCD   0x8149
/** Alpha Micro */
#define ETHERTYPE_ALPHA   0x814A
/** SNMP over Ethernet (see RFC1089) */
#define ETHERTYPE_SNMP   0x814C
/* 0x814D - 0x814E: BIIN */
/** Technically Elite Concepts */
#define ETHERTYPE_TEC   0x814F
/** Rational Corp */
#define ETHERTYPE_RATIONAL   0x8150
/* 0x8151 - 0x8153: Qualcomm */
/* 0x815C - 0x815E: Computer Protocol Pty Ltd */
/* 0x8164 - 0x8166: Charles River Data Systems */
/** Protocol Engines XTP */
#define ETHERTYPE_XTP   0x817D
/** SGI/Time Warner prop. */
#define ETHERTYPE_SGITW   0x817E
/** HIPPI-FP encapsulation */
#define ETHERTYPE_HIPPI_FP   0x8180
/** Scheduled Transfer STP, HIPPI-ST */
#define ETHERTYPE_STP   0x8181
/* 0x8182 - 0x8183: Reserved for HIPPI-6400 */
/* 0x8184 - 0x818C: SGI prop. */
/** Motorola */
#define ETHERTYPE_MOTOROLA   0x818D
/** PowerLAN NetBIOS/NetBEUI (PC) */
#define ETHERTYPE_NETBEUI   0x8191
/* 0x819A - 0x81A3: RAD Network Devices */
/* 0x81B7 - 0x81B9: Xyplex */
/* 0x81CC - 0x81D5: Apricot Computers */
/* 0x81D6 - 0x81DD: Artisoft Lantastic */
/* 0x81E6 - 0x81EF: Polygon */
/* 0x81F0 - 0x81F2: Comsat Labs */
/* 0x81F3 - 0x81F5: SAIC */
/* 0x81F6 - 0x81F8: VG Analytical */
/* 0x8203 - 0x8205: QNX Software Systems Ltd. */
/* 0x8221 - 0x8222: Ascom Banking Systems */
/* 0x823E - 0x8240: Advanced Encryption Systems */
/* 0x8263 - 0x826A: Charles River Data Systems */
/* 0x827F - 0x8282: Athena Programming */
/* 0x829A - 0x829B: Inst Ind Info Tech */
/* 0x829C - 0x82AB: Taurus Controls */
/* 0x82AC - 0x8693: Walker Richer & Quinn */
/** Accton Technologies (unregistered) */
#define ETHERTYPE_ACCTON   0x8390
/** Talaris multicast */
#define ETHERTYPE_TALARISMC   0x852B
/** Kalpana */
#define ETHERTYPE_KALPANA   0x8582
/* 0x8694 - 0x869D: Idea Courier */
/* 0x869E - 0x86A1: Computer Network Tech */
/* 0x86A3 - 0x86AC: Gateway Communications */
/** SECTRA */
#define ETHERTYPE_SECTRA   0x86DB
/** IP protocol version 6 */
#define ETHERTYPE_IPV6   0x86DD
/** Delta Controls */
#define ETHERTYPE_DELTACON   0x86DE
/** ATOMIC */
#define ETHERTYPE_ATOMIC   0x86DF
/* 0x86E0 - 0x86EF: Landis & Gyr Powers */
/* 0x8700 - 0x8710: Motorola */
/** Control Technology Inc. RDP Without IP */
#define ETHERTYPE_RDP   0x8739
/** Control Technology Inc. Mcast Industrial Ctrl Proto. */
#define ETHERTYPE_MICP   0x873A
/* 0x873B - 0x873C   Control Technology Inc. Proprietary */
/** TCP/IP Compression (RFC1701) */
#define ETHERTYPE_TCPCOMP   0x876B
/** IP Autonomous Systems (RFC1701) */
#define ETHERTYPE_IPAS   0x876C
/** Secure Data (RFC1701) */
#define ETHERTYPE_SECUREDATA   0x876D
/** 802.3x flow control packet */
#define ETHERTYPE_FLOWCONTROL   0x8808
/** Slow protocols */
#define ETHERTYPE_SLOWPROTOCOLS   0x8809
/** PPP (obsolete by PPPOE) */
#define ETHERTYPE_PPP   0x880B
/** Hitachi Cable (Optoelectronic Systems Laboratory) */
#define ETHERTYPE_HITACHI   0x8820
/** MPLS Unicast */
#define ETHERTYPE_MPLS   0x8847
/** MPLS Multicast */
#define ETHERTYPE_MPLS_MCAST   0x8848
/** Axis Communications AB proprietary bootstrap/config */
#define ETHERTYPE_AXIS   0x8856
/** PPP Over Ethernet Discovery Stage */
#define ETHERTYPE_PPPOEDISC   0x8863
/** PPP Over Ethernet Session Stage */
#define ETHERTYPE_PPPOE   0x8864
/** HP LanProbe test */
#define ETHERTYPE_LANPROBE   0x8888
/** EAPOL PAE/802.1x */
#define ETHERTYPE_PAE   0x888e
/** ATA over Ethernet */
#define ETHERTYPE_AOE   0x88a2
/** Fibre Channel over Ethernet */
#define ETHERTYPE_FCOE   0x8906
/** Loopback */
#define ETHERTYPE_LOOPBACK   0x9000
/** DEC MOP loopback */
#define ETHERTYPE_LBACK   ETHERTYPE_LOOPBACK
/** 3Com (Formerly Bridge Communications), XNS Systems Management */
#define ETHERTYPE_XNSSM   0x9001
/** 3Com (Formerly Bridge Communications), TCP/IP Systems Management */
#define ETHERTYPE_TCPSM   0x9002
/** 3Com (Formerly Bridge Communications), loopback detection */
#define ETHERTYPE_BCLOOP   0x9003
/** DECNET; Used by VAX 6220 DEBNI */
#define ETHERTYPE_DEBNI   0xAAAA
/** Sonix Arpeggio */
#define ETHERTYPE_SONIX   0xFAF5
/** BBN VITAL-LanBridge cache wakeups */
#define ETHERTYPE_VITAL   0xFF00
/* 0xFF00 - 0xFFOF: ISC Bunker Ramo */
/** Maximum valid ethernet type; reserved */
#define ETHERTYPE_MAX   0xFFFF


typedef struct ether_addr { uint8_t ether_addr_octet[ETH_ALEN]; }   ether_addr_t;


typedef struct attr_packed etherent {
	const char* e_name;
	struct ether_addr e_addr;
} etherent_t;


typedef struct ether_header {
	uint8_t ether_dhost[ETH_ALEN], ether_shost[ETH_ALEN];
	uint16_t ether_type;
} ether_header_t;


#endif  // NET_ETHERNET_H


/* <net/if_arp.h> */


#if (!(defined(_NET_IF_ARP_H) || defined(_NET_IF_ARP_H_)))
#define NET_IF_ARP_H   (1)
#define _NET_IF_ARP_H   (1)
#define _NET_IF_ARP_H_   (1)


#define ARPOP_REQUEST   1
#define ARPOP_REPLY   2
#define ARPOP_RREQUEST   3
#define ARPOP_RREPLY   4
#define ARPOP_InREQUEST   8
#define ARPOP_InREPLY   9
#define ARPOP_NAK   10
#define ARPHRD_NETROM   0
#define ARPHRD_ETHER   1
#define ARPHRD_EETHER   2
#define ARPHRD_AX25   3
#define ARPHRD_PRONET   4
#define ARPHRD_CHAOS   5
#define ARPHRD_IEEE802   6
#define ARPHRD_ARCNET   7
#define ARPHRD_APPLETLK   8
#define ARPHRD_DLCI   15
#define ARPHRD_ATM   19
#define ARPHRD_METRICOM   23
#define ARPHRD_IEEE1394   24
#define ARPHRD_EUI64   27
#define ARPHRD_INFINIBAND   32
#define ARPHRD_SLIP   256
#define ARPHRD_CSLIP   257
#define ARPHRD_SLIP6   258
#define ARPHRD_CSLIP6   259
#define ARPHRD_RSRVD   260
#define ARPHRD_ADAPT   264
#define ARPHRD_ROSE   270
#define ARPHRD_X25   271
#define ARPHRD_HWX25   272
#define ARPHRD_CAN   280
#define ARPHRD_PPP   512
#define ARPHRD_CISCO   513
#define ARPHRD_HDLC   ARPHRD_CISCO
#define ARPHRD_LAPB   516
#define ARPHRD_DDCMP   517
#define ARPHRD_RAWHDLC   518
#define ARPHRD_TUNNEL   768
#define ARPHRD_TUNNEL6   769
#define ARPHRD_FRAD   770
#define ARPHRD_SKIP   771
#define ARPHRD_LOOPBACK   772
#define ARPHRD_LOCALTLK   773
#define ARPHRD_FDDI   774
#define ARPHRD_BIF   775
#define ARPHRD_SIT   776
#define ARPHRD_IPDDP   777
#define ARPHRD_IPGRE   778
#define ARPHRD_PIMREG   779
#define ARPHRD_HIPPI   780
#define ARPHRD_ASH   781
#define ARPHRD_ECONET   782
#define ARPHRD_IRDA   783
#define ARPHRD_FCPP   784
#define ARPHRD_FCAL   785
#define ARPHRD_FCPL   786
#define ARPHRD_FCFABRIC   787
#define ARPHRD_IEEE802_TR   800
#define ARPHRD_IEEE80211   801
#define ARPHRD_IEEE80211_PRISM   802
#define ARPHRD_IEEE80211_RADIOTAP   803
#define ARPHRD_IEEE802154   804
#define ARPHRD_IEEE802154_MONITOR   805
#define ARPHRD_PHONET   820
#define ARPHRD_PHONET_PIPE   821
#define ARPHRD_CAIF   822
#define ARPHRD_IP6GRE   823
#define ARPHRD_NETLINK   824
#define ARPHRD_VOID   0xFFFF
#define ARPHRD_NONE   0xFFFE
#define ATF_COM   2
#define ATF_PERM   4
#define ATF_PUBL   8
#define ATF_USETRAILERS   0x10
#define ATF_NETMASK   0x20
#define ATF_DONTPUB   0x40
#define ATF_MAGIC   0x80
#define ARPD_UPDATE   1
#define ARPD_LOOKUP   2
#define ARPD_FLUSH   3


typedef struct arphdr {
	uint16_t ar_hrd, ar_pro;
	uint8_t ar_hln, ar_pln;
	uint16_t ar_op;
} arphdr_t;


typedef struct attr_packed arpreq {
	struct sockaddr arp_pa, arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
} arpreq_t;


typedef struct attr_packed arpreq_old {
	struct sockaddr arp_pa, arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
} arpreq_old_t;


typedef struct attr_packed arpd_request {
	unsigned short req;
	uint32_t ip;
	unsigned long dev, stamp, updated;
	unsigned char ha[MAX_ADDR_LEN];
} arpd_request_t;


#endif  // NET_IF_ARP_H


/* INTERNET ADDRESS FAMILY (<netinet/in.h>) */


#if (!(defined(_NETINET_IN_H) || defined(_NETINET_IN_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_in.h.html
#define NETINET_IN_H   (1)
#define _NETINET_IN_H   (1)
#define _NETINET_IN_H_   (1)


typedef uint16_t   in_port_t;
/** Base type for Internet address */
typedef uint32_t   in_addr_t;
/** Internet address */
typedef struct in_addr { in_addr_t s_addr; }   in_addr;


#ifndef INET_ADDRSTRLEN
#   define INET_ADDRSTRLEN   16
#endif
#ifndef INET6_ADDRSTRLEN
#   define INET6_ADDRSTRLEN   46
#endif
#define IPPROTO_IP   0
#define IPPROTO_HOPOPTS   0
#define IPPROTO_ICMP   1
#define IPPROTO_IGMP   2
#define IPPROTO_IPIP   4
#define IPPROTO_TCP   6
#define IPPROTO_EGP   8
#define IPPROTO_PUP   12
#define IPPROTO_UDP   17
#define IPPROTO_IDP   22
#define IPPROTO_TP   29
#define IPPROTO_DCCP   33
#define IPPROTO_IPV6   41
#define IPPROTO_ROUTING   43
#define IPPROTO_FRAGMENT   44
#define IPPROTO_RSVP   46
#define IPPROTO_GRE   47
#define IPPROTO_ESP   50
#define IPPROTO_AH   51
#define IPPROTO_ICMPV6   58
#define IPPROTO_NONE   59
#define IPPROTO_DSTOPTS   60
#define IPPROTO_MTP   92
#define IPPROTO_BEETPH   94
#define IPPROTO_ENCAP   98
#define IPPROTO_PIM   103
#define IPPROTO_COMP   108
#define IPPROTO_SCTP   132
#define IPPROTO_MH   135
#define IPPROTO_UDPLITE   136
#define IPPROTO_MPLS   137
#define IPPROTO_RAW   255
#define IPPROTO_MAX   256
#define INADDR_ANY   ((in_addr_t)0)
#define INADDR_BROADCAST   ((in_addr_t)0xffffffff)
#define INADDR_NONE   ((in_addr_t)0xffffffff)
#define INADDR_LOOPBACK   ((in_addr_t)0x7f000001)
#define INADDR_UNSPEC_GROUP   ((in_addr_t)0xe0000000)
#define INADDR_ALLHOSTS_GROUP   ((in_addr_t)0xe0000001)
#define INADDR_ALLRTRS_GROUP   ((in_addr_t)0xe0000002)
#define INADDR_MAX_LOCAL_GROUP   ((in_addr_t)0xe00000ff)
#define IN6ADDR_ANY_INIT   { { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } }
#define IN6ADDR_LOOPBACK_INIT   { { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } } }
#define IN6_IS_ADDR_UNSPECIFIED(a)   (((uint32_t*)(a))[0] == 0 && ((uint32_t*)(a))[1] == 0 && ((uint32_t*)(a))[2] == 0 && ((uint32_t*)(a))[3] == 0)
#define IN6_IS_ADDR_LOOPBACK(a)   (((uint32_t*)(a))[0] == 0 && ((uint32_t*)(a))[1] == 0 && ((uint32_t*)(a))[2] == 0 && ((uint8_t*)(a))[12] == 0 && ((uint8_t*)(a))[13] == 0 && ((uint8_t*)(a))[14] == 0 && ((uint8_t*)(a))[15] == 1 )
#define IN6_IS_ADDR_MULTICAST(a)   (((uint8_t*)(a))[0] == 0xff)
#define IN6_IS_ADDR_LINKLOCAL(a)   ((((uint8_t*)(a))[0]) == 0xfe && (((uint8_t*)(a))[1] & 0xc0) == 0x80)
#define IN6_IS_ADDR_SITELOCAL(a)   ((((uint8_t*)(a))[0]) == 0xfe && (((uint8_t*)(a))[1] & 0xc0) == 0xc0)
#define IN6_IS_ADDR_V4MAPPED(a)   (((uint32_t*)(a))[0] == 0 && ((uint32_t*)(a))[1] == 0 && ((uint8_t*)(a))[8] == 0 && ((uint8_t*)(a))[9] == 0 && ((uint8_t*)(a))[10] == 0xff && ((uint8_t*)(a))[11] == 0xff)
#define IN6_IS_ADDR_V4COMPAT(a)   (((uint32_t*)(a))[0] == 0 && ((uint32_t*)(a))[1] == 0 && ((uint32_t*)(a))[2] == 0 && ((uint8_t*)(a))[15] > 1)
#define IN6_IS_ADDR_MC_NODELOCAL(a)   (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x1))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)   (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x2))
#define IN6_IS_ADDR_MC_SITELOCAL(a)   (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x5))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)   (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0x8))
#define IN6_IS_ADDR_MC_GLOBAL(a)   (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t*)(a))[1] & 0xf) == 0xe))
#define __ARE_4_EQUAL(a, b)   (!((0[a] - 0[b]) | (1[a]-1[b]) | (2[a] - 2[b]) | (3[a] - 3[b])))
#define IN6_ARE_ADDR_EQUAL(a, b)   __ARE_4_EQUAL((const uint32_t*)(a), (const uint32_t*)(b))
#define IN_CLASSA(a)   ((((in_addr_t)(a)) & 0x80000000) == 0)
#define IN_CLASSA_NET   0xff000000
#define IN_CLASSA_NSHIFT   24
#define IN_CLASSA_HOST   (0xffffffff & (~IN_CLASSA_NET))
#define IN_CLASSA_MAX   128
#define IN_CLASSB(a)   ((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET   0xffff0000
#define IN_CLASSB_NSHIFT   16
#define IN_CLASSB_HOST   (0xffffffff & (~IN_CLASSB_NET))
#define IN_CLASSB_MAX   65536
#define IN_CLASSC(a)   ((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET   0xffffff00
#define IN_CLASSC_NSHIFT   8
#define IN_CLASSC_HOST   (0xffffffff & (~IN_CLASSC_NET))
#define IN_CLASSD(a)   ((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
#define IN_MULTICAST(a)   IN_CLASSD(a)
#define IN_EXPERIMENTAL(a)   ((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
#define IN_BADCLASS(a)   ((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)
#define IN_LOOPBACKNET   127
#define IP_TOS   1
#define IP_TTL   2
#define IP_HDRINCL   3
#define IP_OPTIONS   4
#define IP_ROUTER_ALERT   5
#define IP_RECVOPTS   6
#define IP_RETOPTS   7
#define IP_PKTINFO   8
#define IP_PKTOPTIONS   9
#define IP_PMTUDISC   10
#define IP_MTU_DISCOVER   10
#define IP_RECVERR   11
#define IP_RECVTTL   12
#define IP_RECVTOS   13
#define IP_MTU   14
#define IP_FREEBIND   15
#define IP_IPSEC_POLICY   16
#define IP_XFRM_POLICY   17
#define IP_PASSSEC   18
#define IP_TRANSPARENT   19
#define IP_ORIGDSTADDR   20
#define IP_RECVORIGDSTADDR   IP_ORIGDSTADDR
#define IP_MINTTL   21
#define IP_NODEFRAG   22
#define IP_CHECKSUM   23
#define IP_BIND_ADDRESS_NO_PORT   24
#define IP_MULTICAST_IF   32
#define IP_MULTICAST_TTL   33
#define IP_MULTICAST_LOOP   34
#define IP_ADD_MEMBERSHIP   35
#define IP_DROP_MEMBERSHIP   36
#define IP_UNBLOCK_SOURCE   37
#define IP_BLOCK_SOURCE   38
#define IP_ADD_SOURCE_MEMBERSHIP   39
#define IP_DROP_SOURCE_MEMBERSHIP   40
#define IP_MSFILTER   41
#define IP_MULTICAST_ALL   49
#define IP_UNICAST_IF   50
#define IP_RECVRETOPTS   IP_RETOPTS
#define IP_PMTUDISC_DONT   0
#define IP_PMTUDISC_WANT   1
#define IP_PMTUDISC_DO   2
#define IP_PMTUDISC_PROBE   3
#define IP_PMTUDISC_INTERFACE   4
#define IP_PMTUDISC_OMIT   5
#define IP_DEFAULT_MULTICAST_TTL   1
#define IP_DEFAULT_MULTICAST_LOOP   1
#define IP_MAX_MEMBERSHIPS   20
#define MCAST_JOIN_GROUP   42
#define MCAST_BLOCK_SOURCE   43
#define MCAST_UNBLOCK_SOURCE   44
#define MCAST_LEAVE_GROUP   45
#define MCAST_JOIN_SOURCE_GROUP   46
#define MCAST_LEAVE_SOURCE_GROUP   47
#define MCAST_MSFILTER   48
#define MCAST_EXCLUDE   0
#define MCAST_INCLUDE   1
#define IPV6_ADDRFORM   1
#define IPV6_2292PKTINFO   2
#define IPV6_2292HOPOPTS   3
#define IPV6_2292DSTOPTS   4
#define IPV6_2292RTHDR   5
#define IPV6_2292PKTOPTIONS   6
#define IPV6_CHECKSUM   7
#define IPV6_2292HOPLIMIT   8
#define IPV6_NEXTHOP   9
#define IPV6_AUTHHDR   10
#define IPV6_UNICAST_HOPS   16
#define IPV6_MULTICAST_IF   17
#define IPV6_MULTICAST_HOPS   18
#define IPV6_MULTICAST_LOOP   19
#define IPV6_JOIN_GROUP   20
#define IPV6_LEAVE_GROUP   21
#define IPV6_ROUTER_ALERT   22
#define IPV6_MTU_DISCOVER   23
#define IPV6_MTU   24
#define IPV6_RECVERR   25
#define IPV6_V6ONLY   26
#define IPV6_JOIN_ANYCAST   27
#define IPV6_LEAVE_ANYCAST   28
#define IPV6_IPSEC_POLICY   34
#define IPV6_XFRM_POLICY   35
#define IPV6_RECVPKTINFO   49
#define IPV6_PKTINFO   50
#define IPV6_RECVHOPLIMIT   51
#define IPV6_HOPLIMIT   52
#define IPV6_RECVHOPOPTS   53
#define IPV6_HOPOPTS   54
#define IPV6_RTHDRDSTOPTS   55
#define IPV6_RECVRTHDR   56
#define IPV6_RTHDR   57
#define IPV6_RECVDSTOPTS   58
#define IPV6_DSTOPTS   59
#define IPV6_RECVPATHMTU   60
#define IPV6_PATHMTU   61
#define IPV6_DONTFRAG   62
#define IPV6_RECVTCLASS   66
#define IPV6_TCLASS   67
#define IPV6_AUTOFLOWLABEL   70
#define IPV6_ADDR_PREFERENCES   72
#define IPV6_MINHOPCOUNT   73
#define IPV6_ORIGDSTADDR   74
#define IPV6_RECVORIGDSTADDR   IPV6_ORIGDSTADDR
#define IPV6_TRANSPARENT   75
#define IPV6_UNICAST_IF   76
#define IPV6_ADD_MEMBERSHIP   IPV6_JOIN_GROUP
#define IPV6_DROP_MEMBERSHIP   IPV6_LEAVE_GROUP
#define IPV6_RXHOPOPTS   IPV6_HOPOPTS
#define IPV6_RXDSTOPTS   IPV6_DSTOPTS
#define IPV6_PMTUDISC_DONT   0
#define IPV6_PMTUDISC_WANT   1
#define IPV6_PMTUDISC_DO   2
#define IPV6_PMTUDISC_PROBE   3
#define IPV6_PMTUDISC_INTERFACE 4
#define IPV6_PMTUDISC_OMIT   5
#define IPV6_PREFER_SRC_TMP   1
#define IPV6_PREFER_SRC_PUBLIC   2
#define IPV6_PREFER_SRC_PUBTMP_DEFAULT   0x100
#define IPV6_PREFER_SRC_COA   4
#define IPV6_PREFER_SRC_HOME   0x400
#define IPV6_PREFER_SRC_CGA   8
#define IPV6_PREFER_SRC_NONCGA   0x800
#define IPV6_RTHDR_LOOSE   0
#define IPV6_RTHDR_STRICT   1
#define IPV6_RTHDR_TYPE_0   0


typedef struct sockaddr_in {
	sa_family_t sin_family;
	in_port_t sin_port;
	struct in_addr sin_addr;
	uint8_t sin_zero[8];
} sockaddr_in_t;


typedef struct in6_addr {
	union in6_union {
		uint8_t __s6_addr[16];
		uint16_t __s6_addr16[8];
		uint32_t __s6_addr32[4];
	} __in6_union;
} in6_addr_t;
#define s6_addr   __in6_union.__s6_addr
#define s6_addr16   __in6_union.__s6_addr16
#define s6_addr32   __in6_union.__s6_addr32
static const UNUSED struct in6_addr in6addr_any, in6addr_loopback;


typedef struct sockaddr_in6 {
	sa_family_t sin6_family;
	in_port_t sin6_port;
	uint32_t sin6_flowinfo;
	struct in6_addr sin6_addr;
	uint32_t sin6_scope_id;
} sockaddr_in6_t;


typedef struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	unsigned ipv6mr_interface;
} ipv6_mreq_t;


typedef struct ip_opts {
	struct in_addr ip_dst;
	char ip_opts[40];
} ip_opts_t;


typedef struct ip_mreq {
	struct in_addr imr_multiaddr, imr_interface;
} ip_mreq_t;


typedef struct ip_mreqn {
	struct in_addr imr_multiaddr, imr_address;
	int imr_ifindex;
} ip_mreqn_t;


typedef struct ip_mreq_source {
	struct in_addr imr_multiaddr, imr_interface, imr_sourceaddr;
} ip_mreq_source_t;


typedef struct ip_msfilter {
	struct in_addr imsf_multiaddr, imsf_interface;
	uint32_t imsf_fmode, imsf_numsrc;
	struct in_addr imsf_slist[1];
} ip_msfilter_t;
#define IP_MSFILTER_SIZE(numsrc)   (sizeof(struct ip_msfilter) - sizeof(struct in_addr) + (numsrc) * sizeof(struct in_addr))


typedef struct attr_packed group_req {
	uint32_t gr_interface;
	struct sockaddr_storage gr_group;
} group_req_t;


typedef struct group_source_req {
	uint32_t gsr_interface;
	struct sockaddr_storage gsr_group, gsr_source;
} group_source_req_t;


typedef struct attr_packed group_filter {
	uint32_t gf_interface;
	struct sockaddr_storage gf_group;
	uint32_t gf_fmode, gf_numsrc;
	struct sockaddr_storage gf_slist[1];
} group_filter_t;
#define GROUP_FILTER_SIZE(numsrc)   (sizeof(struct group_filter) - sizeof(struct sockaddr_storage) + (numsrc) * sizeof(struct sockaddr_storage))


typedef struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst, ipi_addr;
} in_pktinfo_t;


typedef struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	unsigned ipi6_ifindex;
} in6_pktinfo_t;


typedef struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	uint32_t ip6m_mtu;
} ip6_mtuinfo_t;


#endif  // NETINET_IN_H


/* <netinet/ifether.h> */


#if (!(defined(_NETINET_IF_ETHER_H) || defined(_NETINET_IF_ETHER_H_)))
#define _NETINET_IF_ETHER_H   (1)
#define _NETINET_IF_ETHER_H_   (1)


#ifndef ETH_ALEN
#   define ETH_ALEN   6
#endif
#define ETH_HLEN   14
#define ETH_ZLEN   60
#define ETH_DATA_LEN   1500
#define ETH_FRAME_LEN   1514
#define ETH_FCS_LEN   4
#define ETH_P_LOOP   0x60
#define ETH_P_PUP   0x200
#define ETH_P_PUPAT   0x201
#define ETH_P_IP   0x800
#define ETH_P_X25   0x805
#define ETH_P_ARP   0x806
#define ETH_P_BPQ   0x8FF
#define ETH_P_IEEEPUP   0xa00
#define ETH_P_IEEEPUPAT   0xa01
#define ETH_P_BATMAN   0x4305
#define ETH_P_DEC   0x6000
#define ETH_P_DNA_DL   0x6001
#define ETH_P_DNA_RC   0x6002
#define ETH_P_DNA_RT   0x6003
#define ETH_P_LAT   0x6004
#define ETH_P_DIAG   0x6005
#define ETH_P_CUST   0x6006
#define ETH_P_SCA   0x6007
#define ETH_P_TEB   0x6558
#define ETH_P_RARP   0x8035
#define ETH_P_ATALK   0x809B
#define ETH_P_AARP   0x80F3
#define ETH_P_8021Q   0x8100
#define ETH_P_IPX   0x8137
#define ETH_P_IPV6   0x86DD
#define ETH_P_PAUSE   0x8808
#define ETH_P_SLOW   0x8809
#define ETH_P_WCCP   0x883E
#define ETH_P_MPLS_UC   0x8847
#define ETH_P_MPLS_MC   0x8848
#define ETH_P_ATMMPOA   0x884c
#define ETH_P_PPP_DISC   0x8863
#define ETH_P_PPP_SES   0x8864
#define ETH_P_LINK_CTL   0x886c
#define ETH_P_ATMFATE   0x8884
#define ETH_P_PAE   0x888E
#define ETH_P_AOE   0x88A2
#define ETH_P_8021AD   0x88A8
#define ETH_P_802_EX1   0x88B5
#define ETH_P_TIPC   0x88CA
#define ETH_P_8021AH   0x88E7
#define ETH_P_MVRP   0x88F5
#define ETH_P_1588   0x88F7
#define ETH_P_PRP   0x88FB
#define ETH_P_FCOE   0x8906
#define ETH_P_TDLS   0x890D
#define ETH_P_FIP   0x8914
#define ETH_P_80221   0x8917
#define ETH_P_LOOPBACK   0x9000
#define ETH_P_QINQ1   0x9100
#define ETH_P_QINQ2   0x9200
#define ETH_P_QINQ3   0x9300
#define ETH_P_EDSA   0xDADA
#define ETH_P_AF_IUCV   0xFBFB
#define ETH_P_802_3_MIN   0x600
#define ETH_P_802_3   1
#define ETH_P_AX25   2
#define ETH_P_ALL   3
#define ETH_P_802_2   4
#define ETH_P_SNAP   5
#define ETH_P_DDCMP   6
#define ETH_P_WAN_PPP   7
#define ETH_P_PPP_MP   8
#define ETH_P_LOCALTALK   9
#define ETH_P_CAN   0xC
#define ETH_P_CANFD   0xD
#define ETH_P_PPPTALK   0x10
#define ETH_P_TR_802_2   0x11
#define ETH_P_MOBITEX   0x15
#define ETH_P_CONTROL   0x16
#define ETH_P_IRDA   0x17
#define ETH_P_ECONET   0x18
#define ETH_P_HDLC   0x19
#define ETH_P_ARCNET   0x1A
#define ETH_P_DSA   0x1B
#define ETH_P_TRAILER   0x1C
#define ETH_P_PHONET   0xF5
#define ETH_P_IEEE802154   0xF6
#define ETH_P_CAIF   0xF7


typedef struct ethhdr {
	uint8_t h_dest[ETH_ALEN], h_source[ETH_ALEN];
	uint16_t h_proto;
} ethhdr_t;


typedef struct ether_arp {
	struct arphdr ea_hdr;
	uint8_t arp_sha[ETH_ALEN], arp_spa[4], arp_tha[ETH_ALEN], arp_tpa[4];
} ether_arp_t;
#define arp_hrd   ea_hdr.ar_hrd
#define arp_pro   ea_hdr.ar_pro
#define arp_hln   ea_hdr.ar_hln
#define arp_pln   ea_hdr.ar_pln
#define arp_op   ea_hdr.ar_op
#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr)   do { (enaddr)[0] = 1; (enaddr)[1] = 0; (enaddr)[2] = 0x5e; (enaddr)[3] = ((uint8_t*)ipaddr)[1] & 0x7f; (enaddr)[4] = ((uint8_t*)ipaddr)[2]; (enaddr)[5] = ((uint8_t*)ipaddr)[3]; } while (0x0)


#endif  // NETINET_IF_ETHER_H


/* <net/route.h> */


#if (!(defined(_NET_ROUTE_H) || defined(_NET_ROUTE_H_)))
#define NET_ROUTE_H   (1)
#define _NET_ROUTE_H   (1)
#define _NET_ROUTE_H_   (1)


#define RTF_UP   1
#define RTF_GATEWAY   2
#define RTF_HOST   4
#define RTF_REINSTATE   8
#define RTF_DYNAMIC   0x10
#define RTF_MODIFIED   0x20
#define RTF_MTU   0x40
#define RTF_MSS   RTF_MTU
#define RTF_WINDOW   0x80
#define RTF_IRTT   0x100
#define RTF_NOFORWARD   0x1000
#define RTF_THROW   0x2000
#define RTF_NOPMTUDISC   0x4000
#define RTF_DEFAULT   0x10000
#define RTF_ALLONLINK   0x20000
#define RTF_ADDRCONF   0x40000
#define RTF_LINKRT   0x100000
#define RTF_NONEXTHOP   0x200000
#define RTF_CACHE   0x1000000
#define RTF_FLOW   0x2000000
#define RTF_POLICY   0x4000000
#define RTCF_VALVE   0x200000
#define RTCF_MASQ   0x400000
#define RTCF_NAT   0x800000
#define RTCF_DOREDIRECT   0x1000000
#define RTCF_LOG   0x2000000
#define RTCF_DIRECTSRC   0x4000000
#define RTF_INTERFACE   0x40000000
#define RTF_NAT   0x8000000
#define RTF_ADDRCLASSMASK   0xF8000000
#define RT_ADDRCLASS(flags)   ((uint32_t) flags >> 23)
#define RT_TOS(tos)   ((tos) & IPTOS_TOS_MASK)
#define RT_LOCALADDR(flags)   ((flags & RTF_ADDRCLASSMASK) == (RTF_LOCAL | RTF_INTERFACE))
#define RT_CLASS_UNSPEC   0
#define RT_CLASS_DEFAULT   253
#define RT_CLASS_MAIN   254
#define RT_CLASS_LOCAL   255
#define RT_CLASS_MAX   255
#define RTMSG_ACK   NLMSG_ACK
#define RTMSG_OVERRUN   NLMSG_OVERRUN
#define RTMSG_NEWDEVICE   0x11
#define RTMSG_DELDEVICE   0x12
#define RTMSG_NEWROUTE   0x21
#define RTMSG_DELROUTE   0x22
#define RTMSG_NEWRULE   0x31
#define RTMSG_DELRULE   0x32
#define RTMSG_CONTROL   0x40
#define RTMSG_AR_FAILED   0x51


typedef struct attr_packed rtentry {
	unsigned long rt_pad1;
	struct sockaddr rt_dst, rt_gateway, rt_genmask;
	unsigned short rt_flags;
	short rt_pad2;
	unsigned long rt_pad3;
	unsigned char rt_tos, rt_class;
	short rt_pad4[(SIZEOF_LONG / 2) - 1];
	short rt_metric;
	char* rt_dev;
	unsigned long rt_mtu, rt_window;
	unsigned short rt_irtt;
} rtentry_t;
#define rt_mss   rt_mtu


typedef struct attr_packed in6_rtmsg {
	struct in6_addr rtmsg_dst, rtmsg_src, rtmsg_gateway;
	uint32_t rtmsg_type;
	uint16_t rtmsg_dst_len, rtmsg_src_len;
	uint32_t rtmsg_metric;
	unsigned long rtmsg_info;
	uint32_t rtmsg_flags;
	int rtmsg_ifindex;
} in6_rtmsg_t;


#endif  // NET_ROUTE_H


/* SUN SOCKET & UNIX DOMAIN SOCKETS (<un.h> & <sys/un.h>) */


#if (!(defined(_SYS_UN_H) || defined(_SYS_UN_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_un.h.html
#define SYS_UN_H   (1)
#define _SYS_UN_H   (1)
#define _SYS_UN_H_   (1)


typedef struct sockaddr_un {
	sa_family_t sun_family;
	char sun_path[108];
} sockaddr_un_t;
#define SUN_LEN(s)   (2 + strlen((s)->sun_path))


#endif  // SYS_UN_H


/* <arpa/nameser.h> & <arpa/nameser_compat.h> */


#if (!(defined(_ARPA_NAMESER_H) || defined(_ARPA_NAMESER_H_) || defined(_ARPA_NAMESER_COMPAT_H) || defined(_ARPA_NAMESER_COMPAT_H_)))
#define ARPA_NAMESER_H   (1)
#define _ARPA_NAMESER_H   (1)
#define _ARPA_NAMESER_H_   (1)
#define _ARPA_NAMESER_COMPAT_H   (1)
#define _ARPA_NAMESER_COMPAT_H_   (1)


#define __NAMESER   19991006
#define NS_PACKETSZ   512
#define NS_MAXDNAME   1025
#define NS_MAXMSG   65535
#define NS_MAXCDNAME   255
#define NS_MAXLABEL   63
#define NS_HFIXEDSZ   12
#define NS_QFIXEDSZ   4
#define NS_RRFIXEDSZ   10
#define NS_INT32SZ   4
#define NS_INT16SZ   2
#define NS_INT8SZ   1
#define NS_INADDRSZ   4
#define NS_IN6ADDRSZ   16
#define NS_CMPRSFLGS   0xc0
#define NS_DEFAULTPORT   53
#define NS_TSIG_FUDGE   300
#define NS_TSIG_TCP_COUNT   100
#define NS_TSIG_ALG_HMAC_MD5   "HMAC-MD5.SIG-ALG.REG.INT"
#define NS_TSIG_ERROR_NO_TSIG   -10
#define NS_TSIG_ERROR_NO_SPACE   -11
#define NS_TSIG_ERROR_FORMERR   -12
#define NS_KEY_TYPEMASK   0xC000
#define NS_KEY_TYPE_AUTH_CONF   0
#define NS_KEY_TYPE_CONF_ONLY   0x8000
#define NS_KEY_TYPE_AUTH_ONLY   0x4000
#define NS_KEY_TYPE_NO_KEY  0xC000
#define NS_KEY_NO_AUTH   0x8000
#define NS_KEY_NO_CONF   0x4000
#define NS_KEY_RESERVED2   0x2000
#define NS_KEY_EXTENDED_FLAGS   0x1000
#define NS_KEY_RESERVED4   0x800
#define NS_KEY_RESERVED5   0x400
#define NS_KEY_NAME_TYPE   0x300
#define NS_KEY_NAME_USER   0x
#define NS_KEY_NAME_ENTITY  0x200
#define NS_KEY_NAME_ZONE   0x100
#define NS_KEY_NAME_RESERVED   0x300
#define NS_KEY_RESERVED8   0x80
#define NS_KEY_RESERVED9   0x40
#define NS_KEY_RESERVED10   0x20
#define NS_KEY_RESERVED11   0x10
#define NS_KEY_SIGNATORYMASK   0xF
#define NS_KEY_RESERVED_BITMASK   (NS_KEY_RESERVED2 | NS_KEY_RESERVED4 | NS_KEY_RESERVED5 | NS_KEY_RESERVED8 | NS_KEY_RESERVED9 | NS_KEY_RESERVED10 | NS_KEY_RESERVED11)
#define NS_KEY_RESERVED_BITMASK2   0xFFFF
#define NS_ALG_MD5RSA   1
#define NS_ALG_DH   2
#define NS_ALG_DSA   3
#define NS_ALG_DSS   NS_ALG_DSA
#define NS_ALG_EXPIRE_ONLY   253
#define NS_ALG_PRIVATE_OID   254
#define NS_KEY_PROT_TLS   1
#define NS_KEY_PROT_EMAIL   2
#define NS_KEY_PROT_DNSSEC   3
#define NS_KEY_PROT_IPSEC   4
#define NS_KEY_PROT_ANY   255
#define NS_MD5RSA_MIN_BITS   512
#define NS_MD5RSA_MAX_BITS   4096
#define NS_MD5RSA_MAX_BYTES   (((NS_MD5RSA_MAX_BITS + 7) >> 3) * 2 + 3)
#define NS_MD5RSA_MAX_BASE64   (((NS_MD5RSA_MAX_BYTES + 2) / 3) * 4)
#define NS_MD5RSA_MIN_SIZE   ((NS_MD5RSA_MIN_BITS + 7) >> 3)
#define NS_MD5RSA_MAX_SIZE   ((NS_MD5RSA_MAX_BITS + 7) >> 3)
#define NS_DSA_SIG_SIZE   41
#define NS_DSA_MIN_SIZE   213
#define NS_DSA_MAX_BYTES   405
#define NS_SIG_TYPE   0
#define NS_SIG_ALG   2
#define NS_SIG_LABELS   3
#define NS_SIG_OTTL   4
#define NS_SIG_EXPIR   8
#define NS_SIG_SIGNED   12
#define NS_SIG_FOOT   16
#define NS_SIG_SIGNER   18
#define NS_NXT_BITS   8
#define NS_NXT_BIT_SET(n, p)   (p[(n) / NS_NXT_BITS] |= (0x80 >> ((n) % NS_NXT_BITS)))
#define NS_NXT_BIT_CLEAR(n, p)   (p[(n) / NS_NXT_BITS] &= (~(0x80 >> ((n) % NS_NXT_BITS))))
#define NS_NXT_BIT_ISSET(n, p)   (p[(n) / NS_NXT_BITS] & (0x80 >> ((n) % NS_NXT_BITS)))
#define NS_NXT_MAX   127
#define NS_OPT_DNSSEC_OK   0x8000U
#define NS_OPT_NSID   3
#define NS_GET16(s, cp)   (void)((s) = (uint16_t)ns_get16(((cp) += 2) - 2))
#define NS_GET32(l, cp)   (void)((l) = (uint32_t)ns_get32(((cp) += 4) - 4))
#define NS_PUT16(s, cp)   ns_put16((s), ((cp) += 2) - 2)
#define NS_PUT32(l, cp)   ns_put32((l), ((cp) += 4) - 4)
#define __BIND   19950621
#define PACKETSZ   NS_PACKETSZ
#define MAXDNAME   NS_MAXDNAME
#define MAXCDNAME   NS_MAXCDNAME
#define MAXLABEL   NS_MAXLABEL
#define HFIXEDSZ   NS_HFIXEDSZ
#define QFIXEDSZ   NS_QFIXEDSZ
#define RRFIXEDSZ   NS_RRFIXEDSZ
#define INT32SZ   NS_INT32SZ
#define INT16SZ   NS_INT16SZ
#define INT8SZ   NS_INT8SZ
#define INADDRSZ   NS_INADDRSZ
#define IN6ADDRSZ   NS_IN6ADDRSZ
#define INDIR_MASK   NS_CMPRSFLGS
#define NAMESERVER_PORT   NS_DEFAULTPORT
#define S_ZONE   ns_s_zn
#define S_PREREQ   ns_s_pr
#define S_UPDATE   ns_s_ud
#define S_ADDT   ns_s_ar
#define QUERY   ns_o_query
#define IQUERY   ns_o_iquery
#define STATUS   ns_o_status
#define NS_NOTIFY_OP   ns_o_notify
#define NS_UPDATE_OP   ns_o_update
#define NOERROR   ns_r_noerror
#define FORMERR   ns_r_formerr
#define SERVFAIL   ns_r_servfail
#define NXDOMAIN   ns_r_nxdomain
#define NOTIMP   ns_r_notimpl
#define REFUSED   ns_r_refused
#define YXDOMAIN   ns_r_yxdomain
#define YXRRSET   ns_r_yxrrset
#define NXRRSET   ns_r_nxrrset
#define NOTAUTH   ns_r_notauth
#define NOTZONE   ns_r_notzone
#define DELETE   ns_uop_delete
#define ADD   ns_uop_add
#define T_A   ns_t_a
#define T_NS   ns_t_ns
#define T_MD   ns_t_md
#define T_MF   ns_t_mf
#define T_CNAME   ns_t_cname
#define T_SOA   ns_t_soa
#define T_MB   ns_t_mb
#define T_MG   ns_t_mg
#define T_MR   ns_t_mr
#define T_NULL   ns_t_null
#define T_WKS   ns_t_wks
#define T_PTR   ns_t_ptr
#define T_HINFO   ns_t_hinfo
#define T_MINFO   ns_t_minfo
#define T_MX   ns_t_mx
#define T_TXT   ns_t_txt
#define T_RP   ns_t_rp
#define T_AFSDB   ns_t_afsdb
#define T_X25   ns_t_x25
#define T_ISDN   ns_t_isdn
#define T_RT   ns_t_rt
#define T_NSAP   ns_t_nsap
#define T_NSAP_PTR  ns_t_nsap_ptr
#define T_SIG   ns_t_sig
#define T_KEY   ns_t_key
#define T_PX   ns_t_px
#define T_GPOS   ns_t_gpos
#define T_AAAA   ns_t_aaaa
#define T_LOC   ns_t_loc
#define T_NXT   ns_t_nxt
#define T_EID   ns_t_eid
#define T_NIMLOC   ns_t_nimloc
#define T_SRV   ns_t_srv
#define T_ATMA   ns_t_atma
#define T_NAPTR   ns_t_naptr
#define T_A6   ns_t_a6
#define T_DNAME   ns_t_dname
#define T_TSIG   ns_t_tsig
#define T_IXFR   ns_t_ixfr
#define T_AXFR   ns_t_axfr
#define T_MAILB   ns_t_mailb
#define T_MAILA   ns_t_maila
#define T_ANY   ns_t_any
#define C_IN   ns_c_in
#define C_CHAOS   ns_c_chaos
#define C_HS   ns_c_hs
#define C_NONE   ns_c_none
#define C_ANY   ns_c_any
#define GETSHORT   NS_GET16
#define GETLONG   NS_GET32
#define PUTSHORT   NS_PUT16
#define PUTLONG   NS_PUT32


typedef enum __ns_sect {
	ns_s_qd = 0,
	ns_s_zn = 0,
	ns_s_an = 1,
	ns_s_pr = 1,
	ns_s_ns = 2,
	ns_s_ud = 2,
	ns_s_ar = 3,
	ns_s_max = 4
} ns_sect;


typedef enum __ns_flag {
	ns_f_qr, ns_f_opcode,
	ns_f_aa, ns_f_tc, ns_f_rd,
	ns_f_ra, ns_f_z, ns_f_ad,
	ns_f_cd, ns_f_rcode, ns_f_max
} ns_flag;


typedef enum __ns_opcode {
	ns_o_query = 0,
	ns_o_iquery = 1,
	ns_o_status = 2,
	ns_o_notify = 4,
	ns_o_update = 5,
	ns_o_max = 6
} ns_opcode;


typedef enum __ns_rcode {
	ns_r_noerror = 0,
	ns_r_formerr = 1,
	ns_r_servfail = 2,
	ns_r_nxdomain = 3,
	ns_r_notimpl = 4,
	ns_r_refused = 5,
	ns_r_yxdomain = 6,
	ns_r_yxrrset = 7,
	ns_r_nxrrset = 8,
	ns_r_notauth = 9,
	ns_r_notzone = 10,
	ns_r_max = 11,
	ns_r_badvers = 16,
	ns_r_badsig = 16,
	ns_r_badkey = 17,
	ns_r_badtime = 18
} ns_rcode;


typedef enum __ns_update_operation {
	ns_uop_delete = 0,
	ns_uop_add = 1,
	ns_uop_max = 2
} ns_update_operation;


struct attr_packed ns_tsig_key {
	char name[NS_MAXDNAME], alg[NS_MAXDNAME];
	unsigned char* data;
	int len;
};
typedef struct ns_tsig_key   ns_tsig_key;


struct attr_packed ns_tcp_tsig_state {
	int counter;
	struct dst_key* key;
	void* ctx;
	unsigned char sig[NS_PACKETSZ];
	int siglen;
};
typedef struct ns_tcp_tsig_state ns_tcp_tsig_state;


typedef enum __ns_class {
	ns_c_invalid = 0,
	ns_c_in = 1,
	ns_c_2 = 2,
	ns_c_chaos = 3,
	ns_c_hs = 4,
	ns_c_none = 254,
	ns_c_any = 255,
	ns_c_max = 65536
} ns_class;


typedef enum __ns_key_types {
	ns_kt_rsa = 1,
	ns_kt_dh = 2,
	ns_kt_dsa = 3,
	ns_kt_private = 254
} ns_key_types;


typedef enum __ns_cert_types {
	cert_t_pkix = 1,
	cert_t_spki = 2,
	cert_t_pgp = 3,
	cert_t_url = 253,
	cert_t_oid = 254
} ns_cert_types;


typedef struct attr_packed __ns_msg {
	const unsigned char *_msg, *_eom;
	uint16_t _id, flags, _counts[ns_s_max];
	const unsigned char* _sections[ns_s_max];
	ns_sect _sect;
	int _rrnum;
	const unsigned char* _msg_ptr;
} ns_msg;
struct _ns_flagdata { int mask, shift; };
const struct _ns_flagdata _ns_flagdata[16] = {
	{ 0x8000, 15 }, { 0x7800, 11 }, { 0x400, 10 }, { 0x200, 9 },
	{ 0x100, 8 }, { 0x80, 7 }, { 0x40, 6 }, { 0x20, 5 }, { 0x10, 4 }, { 0xf, 0 },
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }
};
#define ns_msg_id(handle)   ((handle)._id + 0)
#define ns_msg_base(handle)   ((handle)._msg + 0)
#define ns_msg_end(handle)   ((handle)._eom + 0)
#define ns_msg_size(handle)   ((handle)._eom - (handle)._msg)
#define ns_msg_count(handle, section)   ((handle)._counts[section] + 0)
#define ns_msg_getflag(handle, flag)   (((handle).flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift)


typedef struct attr_packed __ns_rr {
	char name[NS_MAXDNAME];
	uint16_t type, rr_class;
	uint32_t ttl;
	uint16_t rdlength;
	const unsigned char* rdata;
} ns_rr;
#define ns_rr_name(rr)   (((rr).name[0] != '\0') ? (rr).name : ".")
#define ns_rr_type(rr)   ((ns_type)((rr).type + 0))
#define ns_rr_class(rr)   ((ns_class)((rr).rr_class + 0))
#define ns_rr_ttl(rr)   ((rr).ttl + 0)
#define ns_rr_rdlen(rr)   ((rr).rdlength + 0)
#define ns_rr_rdata(rr)   ((rr).rdata + 0)


typedef enum __ns_type {
	ns_t_invalid = 0,
	ns_t_a = 1,
	ns_t_ns = 2,
	ns_t_md = 3,
	ns_t_mf = 4,
	ns_t_cname = 5,
	ns_t_soa = 6,
	ns_t_mb = 7,
	ns_t_mg = 8,
	ns_t_mr = 9,
	ns_t_null = 10,
	ns_t_wks = 11,
	ns_t_ptr = 12,
	ns_t_hinfo = 13,
	ns_t_minfo = 14,
	ns_t_mx = 15,
	ns_t_txt = 16,
	ns_t_rp = 17,
	ns_t_afsdb = 18,
	ns_t_x25 = 19,
	ns_t_isdn = 20,
	ns_t_rt = 21,
	ns_t_nsap = 22,
	ns_t_nsap_ptr = 23,
	ns_t_sig = 24,
	ns_t_key = 25,
	ns_t_px = 26,
	ns_t_gpos = 27,
	ns_t_aaaa = 28,
	ns_t_loc = 29,
	ns_t_nxt = 30,
	ns_t_eid = 31,
	ns_t_nimloc = 32,
	ns_t_srv = 33,
	ns_t_atma = 34,
	ns_t_naptr = 35,
	ns_t_kx = 36,
	ns_t_cert = 37,
	ns_t_a6 = 38,
	ns_t_dname = 39,
	ns_t_sink = 40,
	ns_t_opt = 41,
	ns_t_apl = 42,
	ns_t_tkey = 249,
	ns_t_tsig = 250,
	ns_t_ixfr = 251,
	ns_t_axfr = 252,
	ns_t_mailb = 253,
	ns_t_maila = 254,
	ns_t_any = 255,
	ns_t_zxfr = 256,
	ns_t_max = 65536
} ns_type;
#define ns_t_qt_p(t)   (ns_t_xfr_p(t) || (t) == ns_t_any || (t) == ns_t_mailb || (t) == ns_t_maila)
#define ns_t_mrr_p(t)   ((t) == ns_t_tsig || (t) == ns_t_opt)
#define ns_t_rr_p(t)   (!ns_t_qt_p(t) && !ns_t_mrr_p(t))
#define ns_t_udp_p(t)   ((t) != ns_t_axfr && (t) != ns_t_zxfr)
#define ns_t_xfr_p(t)   ((t) == ns_t_axfr || (t) == ns_t_ixfr || (t) == ns_t_zxfr)


typedef struct _HEADER_struct {
	unsigned id:16;
#   if IS_BIG_ENDIAN
	unsigned qr:1;
	unsigned opcode:4;
	unsigned aa:1;
	unsigned tc:1;
	unsigned rd:1;
	unsigned ra:1;
	unsigned unused:1;
	unsigned ad:1;
	unsigned cd:1;
	unsigned rcode:4;
#   else  // LITTLE_ENDIAN
	unsigned rd:1;
	unsigned tc:1;
	unsigned aa:1;
	unsigned opcode:4;
	unsigned qr:1;
	unsigned rcode:4;
	unsigned cd:1;
	unsigned ad:1;
	unsigned unused:1;
	unsigned ra:1;
#   endif
	unsigned qdcount:16;
	unsigned ancount:16;
	unsigned nscount:16;
	unsigned arcount:16;
} HEADER;


LIB_FUNC unsigned int ns_get16(const unsigned char* cp) {
	return ((unsigned int)(cp[0] << 8) | (unsigned int)cp[1]);
}


LIB_FUNC unsigned long ns_get32(const unsigned char* cp) {
	return (unsigned long)((unsigned long)(cp[0] << 24) | (unsigned long)(cp[1] << 16) | (unsigned long)(cp[2] << 8) | (unsigned long)cp[3]);
}


LIB_FUNC void ns_put16(const unsigned int s, unsigned char* cp) {
	*cp++ = (unsigned char)(s >> 8);
	*cp++ = (unsigned char)s;
}


LIB_FUNC void ns_put32(const unsigned long l, unsigned char* cp) {
	*cp++ = (unsigned char)(l >> 24);
	*cp++ = (unsigned char)(l >> 16);
	*cp++ = (unsigned char)(l >> 8);
	*cp++ = (unsigned char)l;
}


LIB_FUNC int dn_skipname(const unsigned char* cur, const unsigned char* eom) {
	const unsigned char* orig = cur;
	while (cur < eom) {
		if ((*cur & 0xc) == 0xc) {
			if (cur + 1 < eom) { return (int)(cur - orig + 2); }
			else { return -1; }
		} else if (*cur == 0) { return (int)(cur - orig + 1); }
		else if ((cur + *cur + 1) < eom) { cur += (*cur + 1); }
		else { return -1; }
	}
	return -1;
}


LIB_FUNC int ns_skiprr(const unsigned char* ptr, const unsigned char* eom, ns_sect section, int count) {
	const unsigned char* p = ptr;
	int r;
	while (count--) {
		r = dn_skipname(p, eom);
		if ((r < 0) || ((r + 2 * NS_INT16SZ) > (eom - p))) { errno = EMSGSIZE; return -1; }
		p += r + 2 * NS_INT16SZ;
		if (section != ns_s_qd) {
			if (NS_INT32SZ + NS_INT16SZ > eom - p) { errno = EMSGSIZE; return -1; }
			p += NS_INT32SZ;
			NS_GET16(r, p);
			if (r > eom - p) { errno = EMSGSIZE; return -1; }
			p += r;
		}
	}
	return (int)(p - ptr);
}


LIB_FUNC int ns_initparse(const unsigned char* msg, const int msglen, ns_msg* handle) {
	int i, r;
	handle->_msg = msg;
	handle->_eom = msg + msglen;
	if (msglen < (2 + ns_s_max) * NS_INT16SZ) { errno = EMSGSIZE; return -1; }
	NS_GET16(handle->_id, msg);
	NS_GET16(handle->flags, msg);
	for (i = 0; i < ns_s_max; i++) { NS_GET16(handle->_counts[i], msg); }
	for (i = 0; i < ns_s_max; i++) {
		if (handle->_counts[i]) {
			handle->_sections[i] = msg;
			r = ns_skiprr(msg, handle->_eom, i, handle->_counts[i]);
			if (r < 0) { return -1; }
			msg += r;
		} else { handle->_sections[i] = NULL; }
	}
	if (msg != handle->_eom) { errno = EMSGSIZE; return -1; }
	handle->_sect = ns_s_max;
	handle->_rrnum = -1;
	handle->_msg_ptr = NULL;
	return 0;
}


/** Return length of decoded data or -1 */
LIB_FUNC int dns_decodename(const unsigned char* packet, const unsigned int offset, unsigned char* dest, const unsigned int maxlen, const unsigned char* behindpacket) {
	const unsigned char* tmp;
	const unsigned char* max = dest + maxlen;
	const unsigned char* after = packet + offset;
	register int ok = 0;
	for (tmp = after; maxlen > 0 && *tmp; ) {
		if (tmp >= behindpacket) { return -1; }
		else if ((*tmp >> 6) == 3) {
			unsigned int ofs = ((unsigned int)(*tmp & 0x3f) << 8) | (*(tmp + 1));
			if (ofs >= (unsigned int)offset) { return -1; }
			if (after < tmp + 2) { after = tmp + 2; }
			tmp = packet + ofs;
			ok = 0;
		} else if ((*tmp >> 6) == 0) {
			unsigned int duh;
			if ((dest + *tmp + 1) > max) { return -1; }
			else if ((tmp + *tmp + 1) >= behindpacket) { return -1; }
			for (duh = *tmp; duh > 0; --duh) { *dest++ = *++tmp; }
			*dest++ = '.';
			ok = 1;
			++tmp;
			if (tmp > after) { after = tmp; if (!*tmp) { ++after; } }
		} else { return -1; }
	}
	if (ok) { --dest; }
	*dest = 0;
	return (int)(after - packet);
}
#define __dns_decodename(packet, offset, dest, maxlen, behindpacket)   dns_decodename((packet), (offset), (dest), (maxlen), (behindpacket))


LIB_FUNC int dn_expand(const unsigned char* msg, const unsigned char* eomorig, const unsigned char* comp_dn, unsigned char* exp_dn, const int length) {
	return (dns_decodename(msg, (unsigned int)(comp_dn - msg), exp_dn, (unsigned int)length, eomorig) - (int)(comp_dn - msg));
}


LIB_FUNC int ns_name_uncompress(const unsigned char* msg, const unsigned char* eom, const unsigned char* src, char* dst, const size_t dstsiz) {
	const int r = dn_expand(msg, eom, src, (unsigned char*)dst, (int)dstsiz);
	if (r < 0) { errno = EMSGSIZE; }
	return r;
}


LIB_FUNC int ns_parserr(ns_msg* handle, ns_sect section, int rrnum, ns_rr* rr) {
	if (section < 0 || section >= ns_s_max) { errno = ENODEV; return -1; }
	else if (section != handle->_sect) {
		handle->_sect = section;
		handle->_rrnum = 0;
		handle->_msg_ptr = handle->_sections[section];
	}
	if (rrnum == -1) { rrnum = handle->_rrnum; }
	if (rrnum < 0 || rrnum >= handle->_counts[section]) { errno = ENODEV; return -1; }
	else if (rrnum < handle->_rrnum) {
		handle->_rrnum = 0;
		handle->_msg_ptr = handle->_sections[section];
	}
	register int r;
	if (rrnum > handle->_rrnum) {
		r = ns_skiprr(handle->_msg_ptr, handle->_eom, section, rrnum - handle->_rrnum);
		if (r < 0) { return -1; }
		handle->_msg_ptr += r;
		handle->_rrnum = rrnum;
	}
	r = ns_name_uncompress(handle->_msg, handle->_eom, handle->_msg_ptr, rr->name, NS_MAXDNAME);
	if (r < 0) { return -1; }
	handle->_msg_ptr += r;
	if (2 * NS_INT16SZ > handle->_eom - handle->_msg_ptr) { errno = EMSGSIZE; return -1; }
	NS_GET16(rr->type, handle->_msg_ptr);
	NS_GET16(rr->rr_class, handle->_msg_ptr);
	if (section != ns_s_qd) {
		if (NS_INT32SZ + NS_INT16SZ > handle->_eom - handle->_msg_ptr) { errno = EMSGSIZE; return -1; }
		NS_GET32(rr->ttl, handle->_msg_ptr);
		NS_GET16(rr->rdlength, handle->_msg_ptr);
		if (rr->rdlength > handle->_eom - handle->_msg_ptr) { errno = EMSGSIZE; return -1; }
		rr->rdata = handle->_msg_ptr;
		handle->_msg_ptr += rr->rdlength;
	} else {
		rr->ttl = 0;
		rr->rdlength = 0;
		rr->rdata = NULL;
	}
	handle->_rrnum++;
	if (handle->_rrnum > handle->_counts[section]) {
		handle->_sect = section + 1;
		if (handle->_sect == ns_s_max) {
			handle->_rrnum = -1;
			handle->_msg_ptr = NULL;
		} else { handle->_rrnum = 0; }
	}
	return 0;
}


#endif  // ARPA_NAMESER_H


/* INTERNET OPERATIONS (<arpa/inet.h>) */


#if (!(defined(_ARPA_INET_H) || defined(_ARPA_INET_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/arpa_inet.h.html
#define ARPA_INET_H   (1)
#define _ARPA_INET_H   (1)
#define _ARPA_INET_H_   (1)


#ifndef INET_ADDRSTRLEN
#   define INET_ADDRSTRLEN   16
#endif
#ifndef INET6_ADDRSTRLEN
#   define INET6_ADDRSTRLEN   46
#endif


LIB_FUNC char* inet_ntoa(struct in_addr in) {
	static char buf[16] = { 0 };
	unsigned char* a = (void*)&in;
	snprintf(buf, sizeof(buf), "%d.%d.%d.%d", a[0], a[1], a[2], a[3]);
	return buf;
}


/** Internet network address interpretation routine */
LIB_FUNC in_addr_t inet_network(const char* cp) {
	in_addr_t val, base, n;
	char c;
	in_addr_t parts[4] = { 0 }, *pp = parts;
	int i, _digit;
inet_network_again:
	val = 0; base = 10; _digit = 0;
	if (*cp == '0') { _digit = 1, base = 8, cp++; }
	if (*cp == 'x' || *cp == 'X') { base = 16, cp++; }
	while ((c = *cp) != 0) {
		if (isdigit((unsigned char)c)) {
			if (base == 8U && (c == '8' || c == '9')) { return INADDR_NONE; }
			val = (val * base) + (in_addr_t)(c - '0');
			++cp;
			_digit = 1;
			continue;
		}
		if (base == 16U && isxdigit((unsigned char)c)) {
			val = (in_addr_t)(val << 4) + (in_addr_t)(c + 10 - (islower((unsigned char)c) ? 'a' : 'A'));
			++cp;
			_digit = 1;
			continue;
		}
		break;
	}
	if (!_digit) { return INADDR_NONE; }
	else if (pp >= parts + 4 || val > 0xffU) { return INADDR_NONE; }
	else if (*cp == '.') {
		*pp++ = val, cp++;
		goto inet_network_again;
	}
	if (*cp && (!isspace(*cp & 0xff))) { return INADDR_NONE; }
	*pp++ = val;
	n = (in_addr_t)(pp - parts);
	if (n > 4U) { return INADDR_NONE; }
	for (val = 0, i = 0; i < (int)n; i++) {
		val <<= 8;
		val |= parts[i] & 0xff;
	}
	return val;
}
#define __inet_network(cp)   inet_network((cp))


LIB_FUNC int inet_pton(const int af, char* restrict s, void* restrict a0) {
	unsigned char* a = a0;
	int i, j, v, d, brk = -1, need_v4 = 0;
	if (af == AF_INET) {
		for (i = 0; i < 4; i++) {
			for (v = j = 0; j < 3 && isdigit(s[j]); j++) { v = 10 * v + s[j] - '0'; }
			if (j == 0 || (j > 1 && s[0] == '0') || v > 255) { return 0; }
			a[i] = (unsigned char)v;
			if (s[j] == 0 && i == 3) { return 1; }
			else if (s[j] != '.') { return 0; }
			s += j + 1;
		}
		return 0;
	} else if (af != AF_INET6) {
		errno = EAFNOSUPPORT;
		return -1;
	} else if (*s == ':' && *++s != ':') { return 0; }
	uint16_t ip[8] = { 0 };
	for (i = 0; ; i++) {
		if (s[0] == ':' && brk < 0) {
			brk = i;
			ip[i & 7] = 0;
			if (!(*++s)) { break; }
			if (i == 7) { return 0; }
			continue;
		}
		for (v = j = 0; j < 4 && (d = hexval((unsigned int)s[j])) >= 0; j++) { v = 16 * v + d; }
		if (j == 0) { return 0; }
		ip[i & 7] = (uint16_t)v;
		if (!s[j] && (brk >= 0 || i == 7)) { break; }
		else if (i == 7) { return 0; }
		if (s[j] != ':') {
			if (s[j] != '.' || (i < 6 && brk < 0)) { return 0; }
			need_v4 = 1;
			i++;
			break;
		}
		s += j + 1;
	}
	if (brk >= 0) {
		memmove((ip + brk + 7 - i), (ip + brk), (size_t)(2 * (i + 1 - brk)));
		for (j = 0; j < 7 - i; j++) { ip[brk + j] = 0; }
	}
	for (j = 0; j < 8; j++) {
		*a++ = (unsigned char)(ip[j] >> 8);
		*a++ = (unsigned char)ip[j];
	}
	if (need_v4 && inet_pton(AF_INET, (void*)s, (a - 4)) <= 0) { return 0; }
	return 1;
}


LIB_FUNC const char* inet_ntop(const int af, const void* restrict a0, char* restrict s, const socklen_t sock_len) {
	const unsigned char* a = a0;
	int i, j, max, best;
	char buf[100] = { 0 };
	switch (af) {
		case AF_INET:
			if (snprintf(s, sock_len, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]) < (int)sock_len) { return s; }
			break;
		case AF_INET6:
			if (memcmp(a, "\0\0\0\0\0\0\0\0\0\0\377\377", 12)) {
				snprintf(buf, sizeof(buf), "%x:%x:%x:%x:%x:%x:%x:%x", 256 * a[0] + a[1], 256 * a[2] + a[3], 256 * a[4] + a[5], 256 * a[6] + a[7], 256 * a[8] + a[9], 256 * a[10] + a[11], 256 * a[12] + a[13], 256 * a[14] + a[15]);
			} else {
				snprintf(buf, sizeof(buf), "%x:%x:%x:%x:%x:%x:%d.%d.%d.%d", 256 * a[0] + a[1], 256 * a[2] + a[3], 256 * a[4] + a[5], 256 * a[6] + a[7], 256 * a[8] + a[9], 256 * a[10] + a[11], a[12], a[13], a[14], a[15]);
			}
			for (i = best = 0, max = 2; buf[i]; i++) {
				if (i && buf[i] != ':') { continue; }
				j = (int)strspn((buf + i), ":0");
				if (j > max) { best = i, max = j; }
			}
			if (max > 2) {
				buf[best] = buf[best + 1] = ':';
				memmove((buf + best + 2), (buf + best + max), (size_t)(i - best - max + 1));
			}
			if (strlen(buf) < sock_len) { return strcpy(s, buf); }
			break;
		default:
			errno = EAFNOSUPPORT;
			return 0;
	}
	errno = ENOSPC;
	return 0;
}


LIB_FUNC int inet_aton(const char* s0, struct in_addr* dest) {
	const char* s = s0;
	unsigned char* d = (unsigned char*)dest;
	unsigned long a[4] = { 0 };
	const char** restrict z;
	int i;
	for (i = 0; i < 4; i++) {
		a[i] = strtoul(s, z, 0);
		if (*z == s || (**z && **z != '.') || (!isdigit(*s))) { return 0; }
		else if (!*z) { break; }
		s = (*z + 1);
	}
	switch (i) {
		case 0:
			a[1] = a[0] & 0xffffff;
			a[0] >>= 24;
			break;
		case 1:
			a[2] = a[1] & 0xffff;
			a[1] >>= 16;
			break;
		case 2:
			a[3] = a[2] & 0xff;
			a[2] >>= 8;
			break;
		default:  // 4
			return 0;
	}
	for (i = 0; i < 4; i++) {
		if (a[i] > 255) { return 0; }
		d[i] = (unsigned char)a[i];
	}
	return 1;
}
#define __inet_aton(s0, dest)   inet_aton((s0), (dest))


LIB_FUNC in_addr_t inet_addr(const char* p) {
	struct in_addr a;
	if ((!inet_aton(p, &a))) { return (in_addr_t)-1; }
	return a.s_addr;
}


/** Formulate an Internet address from network + host; Used in building addresses stored in the ifnet structure */
LIB_FUNC struct in_addr inet_makeaddr(const in_addr_t net, const in_addr_t host) {
	struct in_addr a;
	if (net < 128U) { a.s_addr = (net << IN_CLASSA_NSHIFT) | (host & IN_CLASSA_HOST); }
	else if (net < 65536U) { a.s_addr = (net << IN_CLASSB_NSHIFT) | (host & IN_CLASSB_HOST); }
	else if (net < 16777216L) { a.s_addr = (net << IN_CLASSC_NSHIFT) | (host & IN_CLASSC_HOST); }
	else { a.s_addr = net | host; }
	a.s_addr = htonl(a.s_addr);
	return a;
}
#define __inet_makeaddr(net, host)   inet_makeaddr((net), (host))


/** Return the local network address portion of an Internet address; handles class a/b/c network number formats */
LIB_FUNC in_addr_t inet_lnaof(const struct in_addr in) {
	in_addr_t i = ntohl(in.s_addr);
	if (IN_CLASSA(i)) { return ((i) & IN_CLASSA_HOST); }
	else if (IN_CLASSB(i)) { return ((i) & IN_CLASSB_HOST); }
	return ((i) & IN_CLASSC_HOST);
}
#define __inet_lnaof(in)   inet_lnaof((in))


/** Return the network number from an Internet address; this handles class a, b, and c network numbers */
LIB_FUNC in_addr_t inet_netof(const struct in_addr in) {
	in_addr_t i = ntohl(in.s_addr);
	if (IN_CLASSA(i)) { return (((i)&IN_CLASSA_NET) >> IN_CLASSA_NSHIFT); }
	else if (IN_CLASSB(i)) { return (((i)&IN_CLASSB_NET) >> IN_CLASSB_NSHIFT); }
	return (((i)&IN_CLASSC_NET) >> IN_CLASSC_NSHIFT);
}
#define __inet_netof(in)   inet_netof((in))


/** Format an in_addr_t network number into presentation format */
LIB_FUNC char* inet_neta(in_addr_t src, char* dst, size_t size) {
	char* odst = dst;
	char* tp;
	while (src & 0xffffffff) {
		unsigned char b = (unsigned char)((uint32_t)(src & 0xff000000) >> 24);
		src <<= 8;
		if (b) {
			if (size < sizeof("255.")) { errno = EMSGSIZE; return NULL; }
			tp = dst;
			dst += sprintf(dst, "%u", b);
			if (src != 0L) {
				*dst++ = '.';
				*dst = '\0';
			}
			size -= (size_t)(dst - tp);
		}
	}
	if (dst == odst) {
		if (size < sizeof("0.0.0.0")) { errno = EMSGSIZE; return NULL; }
		strcpy_no_output(dst, "0.0.0.0");
	}
	return odst;
}
#define __inet_neta(src, dst, size)   inet_neta((src), (dst), (size))


/** Convert IPv4 network number from network to presentation format; This always generates a CIDR style result */
LIB_FUNC char* inet_net_ntop_ipv4(const unsigned char* src, const int bits, char* dst, size_t size) {
	char* odst = dst;
	char* t;
	if (bits < 0 || bits > 32) {
		errno = EINVAL;
		return NULL;
	} else if (bits == 0) {
		if (size < sizeof("0")) { errno = EMSGSIZE; return NULL; }
		*dst++ = '0';
		size--;
		*dst = '\0';
	}
	unsigned int m;
	register int b;
	// Format whole octets
	for (b = bits / 8; b > 0; b--) {
		if (size <= sizeof("255.")) { errno = EMSGSIZE; return NULL; }
		t = dst;
		dst += sprintf(dst, "%u", *src++);
		if (b > 1) {
			*dst++ = '.';
			*dst = '\0';
		}
		size -= (size_t)(dst - t);
	}
	// Format partial octet
	b = bits % 8;
	if (b > 0) {
		if (size <= sizeof(".255")) { errno = EMSGSIZE; return NULL; }
		t = dst;
		if (dst != odst) { *dst++ = '.'; }
		m = (unsigned int)((unsigned int)((1 << b) - 1) << (unsigned int)(8 - b));
		dst += sprintf(dst, "%u", (*src & m));
		size -= (size_t)(dst - t);
	}
	// Format CIDR /width
	if (size <= sizeof("/32")) { errno = EMSGSIZE; return NULL; }
	dst += sprintf(dst, "/%u", bits);
	return odst;
}


/** Convert IPv6 network number from network to presentation format; This always generates a CIDR style result */
LIB_FUNC char* inet_net_ntop_ipv6(const unsigned char* src, const int bits, char* dst, const size_t size) {
	int b, i, p, words, zero_s, zero_l, tmp_zero_s, tmp_zero_l, is_ipv4 = 0;
	unsigned char inbuf[16] = { 0 };
	char outbuf[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128")];
	char* cp;
	unsigned char* s;
	if (bits < 0 || bits > 128) { errno = EINVAL; return NULL; }
	cp = outbuf;
	if (bits == 0) {
		*cp++ = ':';
		*cp++ = ':';
		*cp = '\0';
	} else {  // Copy src to private buffer; Zero host portion
		p = ((bits + 7) / 8);
		memcpy_no_output(inbuf, src, (size_t)p);
		memset_no_output((inbuf + p), 0, (size_t)(16 - p));
		b = bits % 8;
		if (b != 0) {
			inbuf[p - 1] = (unsigned char)(inbuf[p - 1] & ((unsigned char)((unsigned int)(~0) << (unsigned int)(8 - b))));
		}
		s = inbuf;
		words = (bits + 15) / 16;  // Number of words needed to be displayed in output
		if (words == 1) { words = 2; }
		// Find the longest substring of zero's
		zero_s = zero_l = tmp_zero_s = tmp_zero_l = 0;
		for (i = 0; i < (words * 2); i += 2) {
			if ((s[i] | s[i + 1]) == 0) {
				if (tmp_zero_l == 0) { tmp_zero_s = i / 2; }
				++tmp_zero_l;
			} else if (tmp_zero_l && zero_l < tmp_zero_l) {
				zero_s = tmp_zero_s;
				zero_l = tmp_zero_l;
				tmp_zero_l = 0;
			}
		}
		if (tmp_zero_l && zero_l < tmp_zero_l) {
			zero_s = tmp_zero_s;
			zero_l = tmp_zero_l;
		}
		if (zero_l != words && zero_s == 0 && ((zero_l == 6) || ((zero_l == 5 && s[10] == 0xff && s[11] == 0xff) || ((zero_l == 7 && s[14] != 0 && s[15] != 1))))) { is_ipv4 = 1; }
		for (p = 0; p < words; p++) {  // Format whole words
			if (zero_l != 0 && p >= zero_s && p < zero_s + zero_l) {  // Skip some zeros
				if (p == zero_s || p == (words - 1)) { *cp++ = ':'; }
				++s;
				++s;
				continue;
			}
			if (is_ipv4 && p > 5 ) {
				*cp++ = ((p == 6) ? ':' : '.');
				cp += sprintf(cp, "%u", *s++);
				if (p != 7 || bits > 120) {
					*cp++ = '.';
					cp += sprintf(cp, "%u", *s++);
				}
			} else {
				if (cp != outbuf) { *cp++ = ':'; }
				cp += sprintf(cp, "%x", (*s * 256 + s[1]));
				s += 2;
			}
		}
	}
	// Format CIDR /width
	sprintf(cp, "/%u", bits);
	if (strlen(outbuf) + 1 > size) { errno = EMSGSIZE; return NULL; }
	strcpy_no_output(dst, outbuf);
	return (dst);
}
#define __inet_net_ntop_ipv6(src, bits, dst, size)   inet_net_ntop_ipv6((src), (bits), (dst), (size))


/** Convert network number from network to presentation format; This always generates a CIDR style result */
LIB_FUNC char* inet_net_ntop(const int af, const void* src, const int bits, char* dst, const size_t size) {
	switch (af) {
		case AF_INET:
			return inet_net_ntop_ipv4(src, bits, dst, size);
		case AF_INET6:
			return inet_net_ntop_ipv6(src, bits, dst, size);
		default:
			errno = EAFNOSUPPORT;
			return NULL;
	}
	UNREACHABLE
}


/** Convert an IPv4 network number from presentation to network format; accepts hex octets, hex strings, decimal octets, and CIDR */
LIB_FUNC int inet_net_pton_ipv4(const char* src, unsigned char* dst, size_t size) {
	int n, ch, tmp = 0, dirty, bits;
	const unsigned char* odst = dst;
	ch = *src++;
	if (ch == '0' && (src[0] == 'x' || src[0] == 'X') && isascii((unsigned char)(src[1])) && isxdigit((unsigned char)(src[1]))) {  // Hexadecimal: Eat nybble string
		if (size <= 0U) { errno = EMSGSIZE; return -1; }
		dirty = 0;
		++src;
		while ((ch = *src++) != '\0' && isascii(ch) && isxdigit(ch)) {
			if (isupper(ch)) { ch = tolower(ch); }
			n = (int)(strchr(xdigits_l, ch) - xdigits_l);
			assert(n >= 0 && n <= 15);
			if (dirty == 0) { tmp = n; }
			else { tmp = (tmp << 4) | n; }
			if (++dirty == 2) {
				if (size-- <= 0U) { errno = EMSGSIZE; return -1; }
				*dst++ = (unsigned char)tmp;
				dirty = 0;
			}
		}
		if (dirty) {  // Odd trailing nibble
			if (size-- <= 0U) { errno = EMSGSIZE; return -1; }
			*dst++ = (unsigned char)(tmp << 4);
		}
	} else if (isascii(ch) && isdigit(ch)) {  // Decimal: eat dotted digit string
		for (;;) {
			tmp = 0;
			do {
				n = (int)(strchr(digits, ch) - digits);
				assert(n >= 0 && n <= 9);
				tmp *= 10;
				tmp += n;
				if (tmp > 255) { errno = ENOENT; return -1; }
			} while ((ch = *src++) != '\0' && isascii(ch) && isdigit(ch));
			if (size-- <= 0U) { errno = EMSGSIZE; return -1; }
			*dst++ = (unsigned char)tmp;
			if (ch == '\0' || ch == '/') { break; }
			else if (ch != '.') { errno = ENOENT; return -1; }
			ch = *src++;
			if ((!isascii(ch)) || (!isdigit(ch))) { errno = ENOENT; return -1; }
		}
	}
	bits = -1;
	if (ch == '/' && isascii((unsigned char)(src[0])) &&
		isdigit((unsigned char)(src[0])) && dst > odst) {  // CIDR width specifier; Nothing can follow it
		ch = *src++;
		bits = 0;
		do {
			n = (int)(strchr(digits, ch) - digits);
			assert(n >= 0 && n <= 9);
			bits *= 10;
			bits += n;
			if (bits > 32) { errno = ENOENT; return -1; }
		} while ((ch = *src++) != '\0' && isascii(ch) && isdigit(ch));
		if (ch != '\0') { errno = ENOENT; return -1; }
	}
	if (ch != '\0') { errno = ENOENT; return -1; }
	else if (dst == odst) { errno = ENOENT; return -1; }  // If nothing was written to the destination, no was found address
	else if (bits == -1) {  // If no CIDR spec was given, infer width from net class
		if (*odst >= 240) { bits = 32; }  // Class E
		else if (*odst >= 224) { bits = 8; }  // Class D
		else if (*odst >= 192) { bits = 24; }  // Class C
		else if (*odst >= 128) { bits = 16; }  // Class B
		else { bits = 8; }  // Class A
		if (bits < ((dst - odst) * 8)) { bits = (int)((dst - odst) * 8); }
		if (bits == 8 && *odst == 224) { bits = 4; }  // If there are no additional bits specified for a class D address, then adjust bits to 4
	}
	while (bits > ((dst - odst) * 8)) {  // Extend network to cover the actual mask
		if (size-- <= 0U) { errno = EMSGSIZE; return -1; }
		*dst++ = '\0';
	}
	return bits;
}


LIB_FUNC int getbits(const char* src, int* bitsp) {
	register int n = 0, val = 0;
	char ch;
	while ((ch = *src++) != '\0') {
		const char* pch = strchr(digits, ch);
		if (pch != NULL) {
			if (n++ != 0 && val == 0) { return 0; }
			val = (val * 10) + (int)(pch - digits);
			if (val > 128) { return 0; }
			continue;
		}
		return 0;
	}
	if (n == 0) { return 0; }
	*bitsp = val;
	return 1;
}


LIB_FUNC int getv4(const char* src, unsigned char* dst, int* bitsp) {
	unsigned char* odst = dst;
	register int n = 0;
	unsigned int val = 0;
	char ch;
	while ((ch = *src++) != '\0') {
		const char* pch = strchr(digits, ch);
		if (pch != NULL) {
			if (n++ != 0 && val == 0) { return 0; }
			val = (val * 10) + (unsigned int)(pch - digits);
			if (val > 255) { return 0; }
			continue;
		}
		if (ch == '.' || ch == '/') {
			if (dst - odst > 3) { return 0; }
			*dst++ = (unsigned char)val;
			if (ch == '/') { return getbits(src, bitsp); }
			val = 0;
			n = 0;
			continue;
		}
		return 0;
	}
	if (n == 0) { return 0; }
	else if ((dst - odst) > 3) { return 0; }
	else { *dst++ = (unsigned char)val; return 1; }
	UNREACHABLE
}


LIB_FUNC int inet_net_pton_ipv6(const char* src, unsigned char* dst, const size_t size) {
	unsigned char tmp[NS_IN6ADDRSZ] = { 0 }, *tp, *endp, *colonp;
	const char* xdigits;
	int ch, words, ipv4, saw_xdigit = 0, digits = 0, bits = -1;
	unsigned int val = 0;
	memset((tp = tmp), '\0', NS_IN6ADDRSZ);
	endp = tp + NS_IN6ADDRSZ;
	colonp = NULL;
	if (*src == ':' && (*++src != ':')) { errno = ENOENT; return -1; }  // Leading :: requires some special handling
	const char* curtok = src;
	saw_xdigit = 0;
	ipv4 = 0;
	while ((ch = *src++) != '\0') {
		const char* pch;
		if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL) { pch = strchr((xdigits = xdigits_u), ch); }
		if (pch != NULL) {
			val <<= 4;
			val |= (unsigned int)(pch - xdigits);
			if (++digits > 4) { errno = ENOENT; return -1; }
			saw_xdigit = 1;
			continue;
		} else if (ch == ':') {
			curtok = src;
			if (!saw_xdigit) {
				if (colonp) { errno = ENOENT; return -1; }
				colonp = tp;
				continue;
			} else if (*src == '\0') { errno = ENOENT; return -1; }
			else if (tp + NS_INT16SZ > endp) { return 0; }
			*tp++ = (unsigned char)((val >> 8) & 0xff);
			*tp++ = (unsigned char)(val & 0xff);
			saw_xdigit = 0;
			digits = 0;
			val = 0;
			continue;
		} else if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) && getv4(curtok, tp, &bits) > 0) {
			tp += NS_INADDRSZ;
			saw_xdigit = 0;
			ipv4 = 1;
			break;
		} else if (ch == '/' && getbits(src, &bits) > 0) { break; }
		errno = ENOENT;
		return -1;
	}
	if (saw_xdigit) {
		if (tp + NS_INT16SZ > endp) { errno = ENOENT; return -1; }
		*tp++ = (unsigned char)((val >> 8) & 0xff);
		*tp++ = (unsigned char)(val & 0xff);
	}
	if (bits == -1) { bits = 128; }
	words = (bits + 15) / 16;
	if (words < 2) { words = 2; }
	if (ipv4) { words = 8; }
	endp = (tmp + (2 * words));
	if (colonp != NULL) {  // Shift by hand (because memmove cannot handle overlapping regions)
		if (tp == endp) { errno = ENOENT; return -1; }
		register int i, for_n = (int)(tp - colonp);
		for (i = 1; i <= for_n; i++) {
			endp[- i] = colonp[for_n - i];
			colonp[for_n - i] = 0;
		}
		tp = endp;
	}
	if (tp != endp) { errno = ENOENT; return -1; }
	const size_t bytes = (size_t)((bits + 7) / 8);
	if (bytes > size) { errno = EMSGSIZE; return -1; }
	memcpy_no_output(dst, tmp, bytes);
	return bits;
}


/** Convert network number from presentation to network format; accepts hex octets, hex strings, decimal octets, and CIDR */
LIB_FUNC int inet_net_pton(const int af, const char* src, void* dst, const size_t size) {
	switch (af) {
		case AF_INET:
			return inet_net_pton_ipv4(src, dst, size);
		case AF_INET6:
			return inet_net_pton_ipv6(src, dst, size);
		default:
			errno = EAFNOSUPPORT;
			return -1;
	}
	UNREACHABLE
}
#define __inet_net_pton(af, src, dst, size)   inet_net_pton((af), (src), (dst), (size))


#endif  // ARPA_INET_H


/* FTP (<arpa/ftp.h>) */


#if (!(defined(_ARPA_FTP_H) || defined(_ARPA_FTP_H_)))
#define ARPA_FTP_H   (1)
#define _ARPA_FTP_H   (1)
#define _ARPA_FTP_H_   (1)


#define PRELIM   1
#define COMPLETE   2
#define CONTINUE   3
#define TRANSIENT   4
#define ERROR   5
#define TYPE_A   1
#define TYPE_E   2
#define TYPE_I   3
#define TYPE_L   4
#define FORM_N   1
#define FORM_T   2
#define FORM_C   3
#define STRU_F   1
#define STRU_R   2
#define STRU_P   3
#define MODE_S   1
#define MODE_B   2
#define MODE_C   3
#define REC_ESC   '\377'
#define REC_EOR   '\001'
#define REC_EOF   '\002'
#define BLK_EOR   0x80
#define BLK_EOF   0x40
#define BLK_ERRORS   0x20
#define BLK_RESTART   0x10
#define BLK_BYTECOUNT   2
#ifdef FTP_NAMES
static const UNUSED char* modenames[4][16] = { "0", "Stream", "Block", "Compressed" };
static const UNUSED char* strunames[4][8] = { "0", "File", "Record", "Page" };
static const UNUSED char* typenames[8][8] = { "0", "ASCII", "EBCDIC", "Image", "Local" };
static const UNUSED char* formnames[4][32] = { "0", "Nonprint", "Telnet", "Carriage-control" };
#endif


#endif  // ARPA_FTP_H


/* ICMP6 (<netinet/icmp6.h>) */


#if (!(defined(_NETINET_ICMP6_H) || defined(_NETINET_ICMP6_H_)))
#define NETINET_ICMP6_H   (1)
#define _NETINET_ICMP6_H   (1)
#define _NETINET_ICMP6_H_   (1)


#define RPM_PCO_ADD   1
#define RPM_PCO_CHANGE   2
#define RPM_PCO_SETGLOBAL   3
#define MLD_LISTENER_QUERY   130
#define MLD_LISTENER_REPORT   131
#define MLD_LISTENER_REDUCTION   132
#if IS_BIG_ENDIAN
#   define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME   0x80000000
#   define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME   0x40000000
#   define ICMP6_RR_RESULT_FLAGS_OOB   2
#   define ICMP6_RR_RESULT_FLAGS_FORBIDDEN   1
#else
#   define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME   0x80
#   define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME   0x40
#   define ICMP6_RR_RESULT_FLAGS_OOB   0x200
#   define ICMP6_RR_RESULT_FLAGS_FORBIDDEN   0x100
#endif
#define ICMP6_FILTER   1
#define ICMP6_FILTER_BLOCK   1
#define ICMP6_FILTER_PASS   2
#define ICMP6_FILTER_BLOCKOTHERS   3
#define ICMP6_FILTER_PASSONLY   4
#define ICMP6_DST_UNREACH   1
#define ICMP6_PACKET_TOO_BIG   2
#define ICMP6_TIME_EXCEEDED   3
#define ICMP6_PARAM_PROB   4
#define ICMP6_INFOMSG_MASK   0x80
#define ICMP6_ECHO_REQUEST   128
#define ICMP6_ECHO_REPLY   129
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK   0x20
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO   0x10
#define ICMP6_ROUTER_RENUMBERING   138
#define ICMP6_RR_FLAGS_TEST   0x80
#define ICMP6_RR_FLAGS_REQRESULT   0x40
#define ICMP6_RR_FLAGS_FORCEAPPLY   0x20
#define ICMP6_RR_FLAGS_SPECSITE   0x10
#define ICMP6_RR_FLAGS_PREVDONE   8
#define ICMP6_DST_UNREACH_NOROUTE   0
#define ICMP6_DST_UNREACH_ADMIN   1
#define ICMP6_DST_UNREACH_BEYONDSCOPE   2
#define ICMP6_DST_UNREACH_ADDR   3
#define ICMP6_DST_UNREACH_NOPORT   4
#define ICMP6_TIME_EXCEED_TRANSIT   0
#define ICMP6_TIME_EXCEED_REASSEMBLY   1
#define ICMP6_PARAMPROB_HEADER   0
#define ICMP6_PARAMPROB_NEXTHEADER   1
#define ICMP6_PARAMPROB_OPTION   2
#if IS_BIG_ENDIAN
#   define ND_NA_FLAG_ROUTER   0x80000000
#   define ND_NA_FLAG_SOLICITED   0x40000000
#   define ND_NA_FLAG_OVERRIDE   0x20000000
#else
#   define ND_NA_FLAG_ROUTER   0x80
#   define ND_NA_FLAG_SOLICITED   0x40
#   define ND_NA_FLAG_OVERRIDE   0x20
#endif
#define ND_ROUTER_SOLICIT   133
#define ND_ROUTER_ADVERT   134
#define ND_NEIGHBOR_SOLICIT   135
#define ND_NEIGHBOR_ADVERT   136
#define ND_REDIRECT   137
#define ND_RA_FLAG_MANAGED   0x80
#define ND_RA_FLAG_OTHER   0x40
#define ND_RA_FLAG_HOME_AGENT   0x20
#define ND_OPT_SOURCE_LINKADDR   1
#define ND_OPT_TARGET_LINKADDR   2
#define ND_OPT_PREFIX_INFORMATION   3
#define ND_OPT_REDIRECTED_HEADER   4
#define ND_OPT_MTU   5
#define ND_OPT_RTR_ADV_INTERVAL   7
#define ND_OPT_HOME_AGENT_INFO   8
#define ND_OPT_PI_FLAG_ONLINK   0x80
#define ND_OPT_PI_FLAG_AUTO   0x40
#define ND_OPT_PI_FLAG_RADDR   0x20


typedef struct icmp6_filter { uint32_t icmp6_filt[8]; }   icmp6_filter_t;


#define ICMP6_FILTER_WILLPASS(type, filterp)   ((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
#define ICMP6_FILTER_WILLBLOCK(type, filterp)   ((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
#define ICMP6_FILTER_SETPASS(type, filterp)   ((((filterp)->icmp6_filt[(type) >> 5]) &= (~(1 << ((type) & 31)))))
#define ICMP6_FILTER_SETBLOCK(type, filterp)   ((((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31))))
#define ICMP6_FILTER_SETPASSALL(filterp)   memset(filterp, 0, sizeof(struct icmp6_filter));
#define ICMP6_FILTER_SETBLOCKALL(filterp)   memset(filterp, 0xFF, sizeof(struct icmp6_filter));


typedef struct icmp6_hdr {
	uint8_t icmp6_type, icmp6_code;
	uint16_t icmp6_cksum;
	union _icmp6_dataun {
		uint32_t icmp6_un_data32[1];
		uint16_t icmp6_un_data16[2];
		uint8_t icmp6_un_data8[4];
	} icmp6_dataun;
} icmp6_hdr_t;
#define icmp6_data32   icmp6_dataun.icmp6_un_data32
#define icmp6_data16   icmp6_dataun.icmp6_un_data16
#define icmp6_data8   icmp6_dataun.icmp6_un_data8
#define icmp6_pptr   icmp6_data32[0]
#define icmp6_mtu   icmp6_data32[0]
#define icmp6_id   icmp6_data16[0]
#define icmp6_seq   icmp6_data16[1]
#define icmp6_maxdelay   icmp6_data16[0]


typedef struct nd_router_solicit { struct icmp6_hdr nd_rs_hdr; } nd_router_solicit_t;
#define nd_rs_type   nd_rs_hdr.icmp6_type
#define nd_rs_code   nd_rs_hdr.icmp6_code
#define nd_rs_cksum   nd_rs_hdr.icmp6_cksum
#define nd_rs_reserved   nd_rs_hdr.icmp6_data32[0]


typedef struct nd_router_advert {
	struct icmp6_hdr nd_ra_hdr;
	uint32_t nd_ra_reachable, nd_ra_retransmit;
} nd_router_advert_t;
#define nd_ra_type   nd_ra_hdr.icmp6_type
#define nd_ra_code   nd_ra_hdr.icmp6_code
#define nd_ra_cksum   nd_ra_hdr.icmp6_cksum
#define nd_ra_curhoplimit   nd_ra_hdr.icmp6_data8[0]
#define nd_ra_flags_reserved   nd_ra_hdr.icmp6_data8[1]
#define nd_ra_router_lifetime   nd_ra_hdr.icmp6_data16[1]


typedef struct nd_neighbor_solicit {
	struct icmp6_hdr nd_ns_hdr;
	struct in6_addr nd_ns_target;
} nd_neighbor_solicit_t;
#define nd_ns_type   nd_ns_hdr.icmp6_type
#define nd_ns_code   nd_ns_hdr.icmp6_code
#define nd_ns_cksum   nd_ns_hdr.icmp6_cksum
#define nd_ns_reserved   nd_ns_hdr.icmp6_data32[0]


typedef struct nd_neighbor_advert {
	struct icmp6_hdr nd_na_hdr;
	struct in6_addr nd_na_target;
} nd_neighbor_advert_t;
#define nd_na_type   nd_na_hdr.icmp6_type
#define nd_na_code   nd_na_hdr.icmp6_code
#define nd_na_cksum   nd_na_hdr.icmp6_cksum
#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]


typedef struct nd_redirect {
	struct icmp6_hdr nd_rd_hdr;
	struct in6_addr nd_rd_target, nd_rd_dst;
} nd_redirect_t;
#define nd_rd_type   nd_rd_hdr.icmp6_type
#define nd_rd_code   nd_rd_hdr.icmp6_code
#define nd_rd_cksum   nd_rd_hdr.icmp6_cksum
#define nd_rd_reserved   nd_rd_hdr.icmp6_data32[0]


typedef struct nd_opt_hdr { uint8_t nd_opt_type, nd_opt_len; }   nd_opt_hdr_t;


typedef struct nd_opt_prefix_info {
	uint8_t nd_opt_pi_type, nd_opt_pi_len, nd_opt_pi_prefix_len, nd_opt_pi_flags_reserved;
	uint32_t nd_opt_pi_valid_time, nd_opt_pi_preferred_time, nd_opt_pi_reserved2;
	struct in6_addr nd_opt_pi_prefix;
} nd_opt_prefix_info_t;


typedef struct nd_opt_rd_hdr {
	uint8_t nd_opt_rh_type, nd_opt_rh_len;
	uint16_t nd_opt_rh_reserved1;
	uint32_t nd_opt_rh_reserved2;
} nd_opt_rd_hdr_t;


typedef struct nd_opt_mtu {
	uint8_t nd_opt_mtu_type, nd_opt_mtu_len;
	uint16_t nd_opt_mtu_reserved;
	uint32_t nd_opt_mtu_mtu;
} nd_opt_mtu_t;


typedef struct mld_hdr {
	struct icmp6_hdr mld_icmp6_hdr;
	struct in6_addr mld_addr;
} mld_hdr_t;
#define mld_type   mld_icmp6_hdr.icmp6_type
#define mld_code   mld_icmp6_hdr.icmp6_code
#define mld_cksum   mld_icmp6_hdr.icmp6_cksum
#define mld_maxdelay   mld_icmp6_hdr.icmp6_data16[0]
#define mld_reserved   mld_icmp6_hdr.icmp6_data16[1]


typedef struct icmp6_router_renum {
	struct icmp6_hdr rr_hdr;
	uint8_t rr_segnum, rr_flags;
	uint16_t rr_maxdelay;
	uint32_t rr_reserved;
} icmp6_router_renum_t;
#define rr_type   rr_hdr.icmp6_type
#define rr_code   rr_hdr.icmp6_code
#define rr_cksum   rr_hdr.icmp6_cksum
#define rr_seqnum   rr_hdr.icmp6_data32[0]


typedef struct rr_pco_match {
	uint8_t rpm_code, rpm_len, rpm_ordinal, rpm_matchlen, rpm_minlen, rpm_maxlen;
	uint16_t rpm_reserved;
	struct in6_addr rpm_prefix;
} rr_pco_match_t;


typedef struct rr_pco_use {
	uint8_t rpu_uselen, rpu_keeplen, rpu_ramask, rpu_raflags;
	uint32_t rpu_vltime, rpu_pltime, rpu_flags;
	struct in6_addr rpu_prefix;
} rr_pco_use_t;


typedef struct rr_result {
	uint16_t rrr_flags;
	uint8_t rrr_ordinal, rrr_matchedlen;
	uint32_t rrr_ifid;
	struct in6_addr rrr_prefix;
} rr_result_t;


typedef struct nd_opt_adv_interval {
	uint8_t nd_opt_adv_interval_type, nd_opt_adv_interval_len;
	uint16_t nd_opt_adv_interval_reserved;
	uint32_t nd_opt_adv_interval_ival;
} nd_opt_adv_interval_t;


typedef struct nd_opt_home_agent_info {
	uint8_t nd_opt_home_agent_info_type, nd_opt_home_agent_info_len;
	uint16_t nd_opt_home_agent_info_reserved, nd_opt_home_agent_info_preference, nd_opt_home_agent_info_lifetime;
} nd_opt_home_agent_info_t;


#endif  // NETINET_ICMP6_H


/* PPP/P2P: POINT-TO-POINT PROTOCOL (<ppp.h>) */


#if (!(defined(_PPP_DEFS_H) || defined(_PPP_DEFS_H_)))
#define PPP_DEFS_H   (1)
#define _PPP_DEFS_H   (1)
#define _PPP_DEFS_H_   (1)


#define PPP_ADDRESS(p)   (((unsigned char*)(p))[0])
#define PPP_CONTROL(p)   (((unsigned char*)(p))[1])
#define PPP_PROTOCOL(p)   ((((unsigned char*)(p))[2] << 8) + ((unsigned char*)(p))[3])
// Basic PPP frame
/** Octets for standard ppp header */
#define PPP_HDRLEN   4
/** Octets for FCS */
#define PPP_FCSLEN   2
/** Default MRU = max length of info field */
#define PPP_MRU   1500
// Significant octet values
/** All-Stations broadcast address */
#define PPP_ALLSTATIONS   0xff
/** Unnumbered Information */
#define PPP_UI   3
/** Flag Sequence */
#define PPP_FLAG   0x7e
/** Asynchronous Control Escape */
#define PPP_ESCAPE   0x7d
/** Asynchronous transparency modifier */
#define PPP_TRANS   0x20
// Protocol field values
/** Internet Protocol */
#define PPP_IP   0x21
/** Xerox NS */
#define PPP_XNS   0x25
/** AppleTalk Protocol */
#define PPP_AT   0x29
/** IPX Datagram (RFC1552) */
#define PPP_IPX   0x2b
/** VJ compressed TCP */
#define PPP_VJC_COMP   0x2d
/** VJ uncompressed TCP */
#define PPP_VJC_UNCOMP   0x2f
/** Compressed packet */
#define PPP_COMP   0xfd
/** IP Control Protocol */
#define PPP_IPCP   0x8021
/** AppleTalk Control Protocol */
#define PPP_ATCP   0x8029
/** IPX Control Protocol (RFC1552) */
#define PPP_IPXCP   0x802b
/** Compression Control Protocol */
#define PPP_CCP   0x80fd
/** Link Control Protocol */
#define PPP_LCP   0xc021
/** Password Authentication Protocol */
#define PPP_PAP   0xc023
/** Link Quality Report protocol */
#define PPP_LQR   0xc025
/** Cryptographic Handshake Authentication Protocol */
#define PPP_CHAP   0xc223
/** Callback Control Protocol */
#define PPP_CBCP   0xc029
/** Internet Protocol version 6*/
#define PPP_IPV6   0x57
/** IPv6 Control Protocol */
#define PPP_IPV6CP   0x8057
// Values for FCS calculations
/** Initial FCS value */
#define PPP_INITFCS   0xffff
/** Good final FCS value */
#define PPP_GOODFCS   0xf0b8


/** Calculate FCS; RFC1331 */
static const UNUSED unsigned short fcstab[256] = {
	0, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
	0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
	0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
	0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
	0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
	0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
	0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
	0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
	0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
	0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
	0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
	0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
	0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
	0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
	0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
	0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
	0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
	0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
	0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
	0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
	0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
	0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
	0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
	0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};


static const UNUSED char* snames[8] = {
	"Sclosed", "Sclosing", "Sreqsent", "Sackrcvd", "Sacksent", "Sopened"
};


#define PPP_FCS(fcs, c)   (((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])
/** Extended asyncmap - allows any character to be escaped */
typedef uint32_t   ext_accm[8];


enum NPmode {
	NPMODE_PASS,  // Pass the packet through
	NPMODE_DROP,  // Silently drop the packet
	NPMODE_ERROR,  // Return an error
	NPMODE_QUEUE  // Save it up for later
};


typedef struct pppstat {
	unsigned int ppp_ibytes;  // Bytes received
	unsigned int ppp_ipackets;  // Packets received
	unsigned int ppp_ierrors;  // Receive errors
	unsigned int ppp_obytes;  // Bytes sent
	unsigned int ppp_opackets;  // Packets sent
	unsigned int ppp_oerrors;  // Transmit errors
} pppstat_t;


typedef struct vjstat {
	unsigned int vjs_packets;  // Outbound packets
	unsigned int vjs_compressed;  // Outbound compressed packets
	unsigned int vjs_searches;  // Searches for connection state
	unsigned int vjs_misses;  // Times could not find conn. state
	unsigned int vjs_uncompressedin;  // Inbound uncompressed packets
	unsigned int vjs_compressedin;  // Inbound compressed packets
	unsigned int vjs_errorin;  // Inbound unknown type packets
	unsigned int vjs_tossed;  // Inbound packets tossed because of error
} vjstat_t;


typedef struct ppp_stats {
	struct pppstat p;  // Basic PPP statistics
	struct vjstat vj;  // VJ header compression statistics
} ppp_stats_t;


typedef struct compstat {
	unsigned int unc_bytes;  // Total uncompressed bytes
	unsigned int unc_packets;  // Total uncompressed packets
	unsigned int comp_bytes;  // Compressed bytes
	unsigned int comp_packets;  // Compressed packets
	unsigned int inc_bytes;  // Incompressible bytes
	unsigned int inc_packets;  // Incompressible packets
	unsigned int ratio;  // Recent compression ratio << 8
} compstat_t;


typedef struct ppp_comp_stats {
	struct compstat c;  // Packet compression statistics
	struct compstat d;  // Packet decompression statistics
} ppp_comp_stats_t;


/** Records the time in seconds since the last NP packet was sent or received */
typedef struct ppp_idle {
	time_t xmit_idle;  // Time since last NP packet sent
	time_t recv_idle;  // Time since last NP packet received
} ppp_idle_t;


#endif  // PPP_DEFS_H


/* TCP: INTERNET TRANSMISSION CONTROL PROTOCOL (<netinet/tcp.h>) */


#if (!(defined(_NETINET_TCP_H) || defined(_NETINET_TCP_H_)))  // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html
#define NETINET_TCP_H   (1)
#define _NETINET_TCP_H   (1)
#define _NETINET_TCP_H_   (1)


/** Avoid coalescing of small segments */
#define TCP_NODELAY   1
#define TCP_MAXSEG   2
#define TCP_CORK   3
#define TCP_KEEPIDLE   4
#define TCP_KEEPINTVL   5
#define TCP_KEEPCNT   6
#define TCP_SYNCNT   7
#define TCP_LINGER2   8
#define TCP_DEFER_ACCEPT   9
#define TCP_WINDOW_CLAMP   10
#define TCP_INFO   11
#define TCP_QUICKACK   12
#define TCP_CONGESTION   13
#define TCP_MD5SIG   14
#define TCP_THIN_LINEAR_TIMEOUTS   16
#define TCP_THIN_DUPACK   17
#define TCP_USER_TIMEOUT   18
#define TCP_REPAIR   19
#define TCP_REPAIR_QUEUE   20
#define TCP_QUEUE_SEQ   21
#define TCP_REPAIR_OPTIONS   22
#define TCP_FASTOPEN   23
#define TCP_TIMESTAMP   24
#define TCP_NOTSENT_LOWAT   25
#define TCP_CC_INFO   26
#define TCP_SAVE_SYN   27
#define TCP_SAVED_SYN   28
#define TCP_ESTABLISHED   1
#define TCP_SYN_SENT   2
#define TCP_SYN_RECV   3
#define TCP_FIN_WAIT1   4
#define TCP_FIN_WAIT2   5
#define TCP_TIME_WAIT   6
#define TCP_CLOSE   7
#define TCP_CLOSE_WAIT   8
#define TCP_LAST_ACK   9
#define TCP_LISTEN   10
#define TCP_CLOSING   11
#define TCPOPT_EOL   0
#define TCPOPT_NOP   1
#define TCPOPT_MAXSEG   2
#define TCPOPT_WINDOW   3
#define TCPOPT_SACK_PERMITTED   4
#define TCPOPT_SACK   5
#define TCPOPT_TIMESTAMP   8
#define TCPOLEN_SACK_PERMITTED   2
#define TCPOLEN_WINDOW   3
#define TCPOLEN_MAXSEG   4
#define TCPOLEN_TIMESTAMP   10
#define SOL_TCP   6
#define TH_FIN   1
#define TH_SYN   2
#define TH_RST   4
#define TH_PUSH   8
#define TH_ACK   0x10
#define TH_URG   0x20
#define TCPI_OPT_TIMESTAMPS   1
#define TCPI_OPT_SACK   2
#define TCPI_OPT_WSCALE   4
#define TCPI_OPT_ECN   8
#define TCP_CA_Open   0
#define TCP_CA_Disorder   1
#define TCP_CA_CWR   2
#define TCP_CA_Recovery   3
#define TCP_CA_Loss   4
#define TCP_MD5SIG_MAXKEYLEN   80


typedef uint32_t   tcp_seq;


typedef struct tcphdr {
#ifdef _GNU_SOURCE
#   ifdef __GNUC__
	__extension__
#   endif
	union { struct {
		uint16_t source, dest;
		uint32_t seq, ack_seq;
#   if IS_LITTLE_ENDIAN
		uint16_t res1:4;
		uint16_t doff:4;
		uint16_t fin:1;
		uint16_t syn:1;
		uint16_t rst:1;
		uint16_t psh:1;
		uint16_t ack:1;
		uint16_t urg:1;
		uint16_t res2:2;
#   else
		uint16_t doff:4;
		uint16_t res1:4;
		uint16_t res2:2;
		uint16_t urg:1;
		uint16_t ack:1;
		uint16_t psh:1;
		uint16_t rst:1;
		uint16_t syn:1;
		uint16_t fin:1;
#   endif
		uint16_t window, check, urg_ptr;
	};
	struct {
#endif
		uint16_t th_sport, th_dport;
		uint32_t th_seq, th_ack;
#   if IS_LITTLE_ENDIAN
		uint8_t th_x2:4;
		uint8_t th_off:4;
#   else
		uint8_t th_off:4;
		uint8_t th_x2:4;
#   endif
		uint8_t th_flags;
		uint16_t th_win, th_sum, th_urp;
#   ifdef _GNU_SOURCE
	}; };
#   endif
} tcphdr_t;


typedef struct attr_packed tcp_info {
	uint8_t tcpi_state, tcpi_ca_state;
	uint8_t tcpi_retransmits, tcpi_probes, tcpi_backoff, tcpi_options;
	uint8_t tcpi_snd_wscale:4, tcpi_rcv_wscale:4;
	uint32_t tcpi_rto, tcpi_ato, tcpi_snd_mss;
	uint32_t tcpi_rcv_mss, tcpi_unacked, tcpi_sacked;
	uint32_t tcpi_lost, tcpi_retrans, tcpi_fackets;
	uint32_t tcpi_last_data_sent, tcpi_last_ack_sent, tcpi_last_data_recv;
	uint32_t tcpi_last_ack_recv, tcpi_pmtu, tcpi_rcv_ssthresh;
	uint32_t tcpi_rtt, tcpi_rttvar, tcpi_snd_ssthresh;
	uint32_t tcpi_snd_cwnd, tcpi_advmss, tcpi_reordering;
	uint32_t tcpi_rcv_rtt, tcpi_rcv_space, tcpi_total_retrans;
	uint64_t tcpi_pacing_rate, tcpi_max_pacing_rate, tcpi_bytes_acked, tcpi_bytes_received;
	uint32_t tcpi_segs_out, tcpi_segs_in;
} tcp_info_t;


typedef struct attr_packed tcp_md5sig {
	struct sockaddr_storage tcpm_addr;
	uint16_t __tcpm_pad1, tcpm_keylen;
	uint32_t __tcpm_pad2;
	uint8_t tcpm_key[TCP_MD5SIG_MAXKEYLEN];
} tcp_md5sig_t;


#endif  // NETINET_TCP_H


/* TELNET <arpa/telnet.h> */


#if (!(defined(_ARPA_TELNET_H) || defined(_ARPA_TELNET_H_)))
#define ARPA_TELNET_H   (1)
#define _ARPA_TELNET_H   (1)
#define _ARPA_TELNET_H_   (1)


#define IAC   255
#define DONT   254
#define DO   253
#define WONT   252
#define WILL   251
#define SB   250
#define GA   249
#define EL   248
#define EC   247
#define AYT   246
#define AO   245
#define IP   244
#define BREAK   243
#define DM   242
#define NOP   241
#define SE   240
#define EOR   239
#define TELOPT_ABORT   238
#define TELNET_ABORT   238
#define SUSP   237
#define xEOF   236
#define SYNCH   242
#define telcmds   ((char [32][8]) { "EOF", "SUSP", "ABORT", "EOR", "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC", "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", "\0", "\0" })
#define TELCMD_FIRST   xEOF
#define TELCMD_LAST   IAC
#define TELCMD_OK(x)   ((unsigned int)(x) <= TELCMD_LAST && (unsigned int)(x) >= TELCMD_FIRST)
#define TELCMD(x)   telcmds[(x) - TELCMD_FIRST]
#define TELOPT_BINARY   0
#define TELOPT_ECHO   1
#define TELOPT_RCP   2
#define TELOPT_SGA   3
#define TELOPT_NAMS   4
#define TELOPT_STATUS   5
#define TELOPT_TM   6
#define TELOPT_RCTE   7
#define TELOPT_NAOL   8
#define TELOPT_NAOP   9
#define TELOPT_NAOCRD   10
#define TELOPT_NAOHTS   11
#define TELOPT_NAOHTD   12
#define TELOPT_NAOFFD   13
#define TELOPT_NAOVTS   14
#define TELOPT_NAOVTD   15
#define TELOPT_NAOLFD   16
#define TELOPT_XASCII   17
#define TELOPT_LOGOUT   18
#define TELOPT_BM   19
#define TELOPT_DET   20
#define TELOPT_SUPDUP   21
#define TELOPT_SUPDUPOUTPUT   22
#define TELOPT_SNDLOC   23
#define TELOPT_TTYPE   24
#define TELOPT_EOR   25
#define TELOPT_TUID   26
#define TELOPT_OUTMRK   27
#define TELOPT_TTYLOC   28
#define TELOPT_3270REGIME   29
#define TELOPT_X3PAD   30
#define TELOPT_NAWS   31
#define TELOPT_TSPEED   32
#define TELOPT_LFLOW   33
#define TELOPT_LINEMODE   34
#define TELOPT_XDISPLOC   35
#define TELOPT_OLD_ENVIRON   36
/** Authenticate */
#define TELOPT_AUTHENTICATION   37
#define TELOPT_ENCRYPT   38
#define TELOPT_NEW_ENVIRON   39
#define TELOPT_EXOPL   255
#define NTELOPTS   (1 + TELOPT_NEW_ENVIRON)
#define TELQUAL_IS   0
#define TELQUAL_SEND   1
#define TELQUAL_INFO   2
#define TELQUAL_REPLY   2
#define TELQUAL_NAME   3
#define LFLOW_OFF   0
#define LFLOW_ON   1
#define LFLOW_RESTART_ANY   2
#define LFLOW_RESTART_XON   3
#define LM_MODE   1
#define LM_FORWARDMASK   2
#define LM_SLC   3
#define MODE_EDIT   1
#define MODE_TRAPSIG   2
#define MODE_ACK   4
#define MODE_SOFT_TAB   8
#define MODE_LIT_ECHO   0x10
#define MODE_MASK   0x1f
#define MODE_FLOW   0x100
#define MODE_ECHO   0x200
#define MODE_INBIN   0x400
#define MODE_OUTBIN   0x800
#define MODE_FORCE   0x1000
#define SLC_SYNCH   1
#define SLC_BRK   2
#define SLC_IP   3
#define SLC_AO   4
#define SLC_AYT   5
#define SLC_EOR   6
#define SLC_ABORT   7
#define SLC_EOF   8
#define SLC_SUSP   9
#define SLC_EC   10
#define SLC_EL   11
#define SLC_EW   12
#define SLC_RP   13
#define SLC_LNEXT   14
#define SLC_XON   15
#define SLC_XOFF   16
#define SLC_FORW1   17
#define SLC_FORW2   18
#define NSLC   18
#ifdef TELOPTS
static const UNUSED char* telopts[NTELOPTS + 1] = {
	"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
	"STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
	"NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
	"NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
	"DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
	"SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
	"TACACS UID", "OUTPUT MARKING", "TTYLOC",
	"3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
	"LINEMODE", "XDISPLOC", "OLD-ENVIRON", "AUTHENTICATION", "ENCRYPT", "NEW-ENVIRON", 0
};
#define TELOPT_FIRST   TELOPT_BINARY
#define TELOPT_LAST   TELOPT_NEW_ENVIRON
#define TELOPT_OK(x)   ((unsigned int)(x) <= TELOPT_LAST)
#define TELOPT(x)   telopts[(x) - TELOPT_FIRST]
#endif
#define SLC_NAMELIST   "0", "SYNCH", "BRK", "IP", "AO", "AYT", "EOR", "ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP", "LNEXT", "XON", "XOFF", "FORW1", "FORW2", "\0"
static const UNUSED char* slc_names[32] = { SLC_NAMELIST };
#ifndef SLC_NAMES
#   define SLC_NAMES   SLC_NAMELIST
#endif
#define SLC_NAME_OK(x)   ((unsigned int)(x) <= NSLC)
#define SLC_NAME(x)   slc_names[x]
#define SLC_NOSUPPORT   0
#define SLC_CANTCHANGE   1
#define SLC_VARIABLE   2
#define SLC_DEFAULT   3
#define SLC_LEVELBITS   3
#define SLC_FUNC   0
#define SLC_FLAGS   1
#define SLC_VALUE   2
#define SLC_ACK   0x80
#define SLC_FLUSHIN   0x40
#define SLC_FLUSHOUT   0x20
#define OLD_ENV_VAR   1
#define OLD_ENV_VALUE   0
#define NEW_ENV_VAR   0
#define NEW_ENV_VALUE   1
#define ENV_ESC   2
#define ENV_USERVAR   3
#define AUTH_WHO_CLIENT   0
#define AUTH_WHO_SERVER   1
#define AUTH_WHO_MASK   1
#define AUTH_HOW_ONE_WAY   0
#define AUTH_HOW_MUTUAL   2
#define AUTH_HOW_MASK   2
#define AUTHTYPE_NULL   0
#define AUTHTYPE_KERBEROS_V4   1
#define AUTHTYPE_KERBEROS_V5   2
#define AUTHTYPE_SPX   3
#define AUTHTYPE_MINK   4
#define AUTHTYPE_CNT   5
#define AUTHTYPE_TEST   99
static const UNUSED char* authtype_names[8] = { "NULL", "KERBEROS_V4", "KERBEROS_V5", "SPX", "MINK", 0 };
#define AUTHTYPE_NAME_OK(x)   ((unsigned int)(x) < AUTHTYPE_CNT)
#define AUTHTYPE_NAME(x)   authtype_names[x]
#define ENCRYPT_IS   0
#define ENCRYPT_SUPPORT   1
#define ENCRYPT_REPLY   2
#define ENCRYPT_START   3
#define ENCRYPT_END   4
#define ENCRYPT_REQSTART   5
#define ENCRYPT_REQEND   6
#define ENCRYPT_ENC_KEYID   7
#define ENCRYPT_DEC_KEYID   8
#define ENCRYPT_CNT   9
#define ENCTYPE_ANY   0
#define ENCTYPE_DES_CFB64   1
#define ENCTYPE_DES_OFB64   2
#define ENCTYPE_CNT   3
static const UNUSED char* encrypt_names[16] = { "IS", "SUPPORT", "REPLY", "START", "END", "REQUEST-START", "REQUEST-END", "ENC-KEYID", "DEC-KEYID", 0 };
static const UNUSED char* enctype_names[4] = { "ANY", "DES_CFB64", "DES_OFB64", 0 };
#define ENCRYPT_NAME_OK(x)   ((unsigned int)(x) < ENCRYPT_CNT)
#define ENCRYPT_NAME(x)   encrypt_names[x]
#define ENCTYPE_NAME_OK(x)   ((unsigned int)(x) < ENCTYPE_CNT)
#define ENCTYPE_NAME(x)   enctype_names[x]


#endif  // ARPA_TELNET_H


/* TRIVIAL FILE TRANSFER PROTOCOL (<arpa/tftp.h>) */


#if (!(defined(_ARPA_TFTP_H) || defined(_ARPA_TFTP_H_)))
#define ARPA_TFTP_H   (1)
#define _ARPA_TFTP_H   (1)
#define _ARPA_TFTP_H_   (1)


/** Data segment size */
#define SEGSIZE   512
// Packet types
/** Read request */
#define RRQ   1
/** Write request */
#define WRQ   2
/** Data packet */
#define DATA   3
/** Acknowledgement */
#define ACK   4
/** Error code */
#define ERROR   5
/** Option acknowledgement */
#define OACK   6
// Error codes
/** Not defined */
#define EUNDEF   0
/** File not found */
#define ENOTFOUND   1
/** Access violation */
#define EACCESS   2
/** Disk full or allocation exceeded */
#define ENOSPACE   3
/** Illegal TFTP operation */
#define EBADOP   4
/** Unknown transfer ID */
#define EBADID   5
/** File already exists */
#define EEXISTS   6
/** No such user */
#define ENOUSER   7
/** Option negotiation failed */
#define EOPTNEG   8


typedef struct attr_packed tftphdr {
	unsigned short th_opcode;  // Packet type
	union th_u_union {
		unsigned short tu_block;  // Block #
		unsigned short tu_code;  // Error code
		char tu_stuff[1];  // Request packet stuff
	} th_u;
	char th_data[1];  // Data or error string
} tftphdr_t;
#define th_block   th_u.tu_block
#define th_code   th_u.tu_code
#define th_stuff   th_u.tu_stuff
#define th_msg   th_data


#endif  // ARPA_TFTP_H


/* <nss.h> */


#if (!(defined(_NSS_H) || defined(_NSS_H_) || defined(NSS_H)))
#define _NSS_H   (1)
#define _NSS_H_   (1)
#define NSS_H   (1)


/** Possible results of lookup using a nss_* function */
typedef enum nss_status {
	NSS_STATUS_TRYAGAIN = -2,
	NSS_STATUS_UNAVAIL,
	NSS_STATUS_NOTFOUND,
	NSS_STATUS_SUCCESS,
	NSS_STATUS_RETURN
} nss_status_t;


/** Data structure used for the `gethostbyname4_r` function */
struct gaih_addrtuple {
	struct gaih_addrtuple* next;
	char* name;
	int family;
	uint32_t addr[4];
	uint32_t scopeid;
};


#endif


/* <nss/nsswitch.h> & <nsswitch.h> */


#if (!(defined(_NSSWITCH_H) || defined(_NSSWITCH_H_) || defined(_NSS_NSSWITCH_H) || defined(_NSS_NSSWITCH_H_)))
#define NSSWITCH_H   (1)
#define _NSSWITCH_H   (1)
#define _NSSWITCH_H_   (1)
#define NSS_NSSWITCH_H   (1)
#define _NSS_NSSWITCH_H   (1)
#define _NSS_NSSWITCH_H_   (1)


#define NSS_MODULE_INTERFACE_VERSION   0
#define NS_CONTINUE   0
#define NS_RETURN   1
/** Maximum number of NSS aliases */
#define MAX_NR_ALIASES   48
/** Maximum number of NSS addresses */
#define MAX_NR_ADDRS   48
// nsswitch.conf status codes and nsdispatch(3) return values
/** Entry was found */
#define NS_SUCCESS   1
/** Source not responding, or corrupt */
#define NS_UNAVAIL   2
/** Source responded 'no such entry' */
#define NS_NOTFOUND   4
/** Source busy, may respond to retrys */
#define NS_TRYAGAIN   8
/** Bitmask to get the status flags */
#define NS_STATUSMASK   0xff
/** Force all methods to be invoked; Internal nsdispatch(3) flag that is not settable in nsswitch.conf(5) */
#define NS_FORCEALL   (0x100)
/** Local files */
#define NSSRC_FILES   "files"
/** DNS; IN for hosts, HS for others */
#define NSSRC_DNS   "dns"
/** YP/NIS */
#define NSSRC_NIS   "nis"
/** passwd (group in YP compat mode) */
#define NSSRC_COMPAT   "compat"
// Currently implemented databases
#define NSDB_HOSTS   "hosts"
#define NSDB_GROUP   "group"
#define NSDB_GROUP_COMPAT   "group_compat"
#define NSDB_NETGROUP   "netgroup"
#define NSDB_NETWORKS   "networks"
#define NSDB_PASSWD   "passwd"
#define NSDB_PASSWD_COMPAT   "passwd_compat"
#define NSDB_SHELLS   "shells"
// Suggested databases
#define NSDB_ALIASES   "aliases"
#define NSDB_AUTH   "auth"
#define NSDB_AUTOMOUNT   "automount"
#define NSDB_BOOTPARAMS   "bootparams"
#define NSDB_ETHERS   "ethers"
#define NSDB_EXPORTS   "exports"
#define NSDB_NETMASKS   "netmasks"
#define NSDB_PHONES   "phones"
#define NSDB_PRINTCAP   "printcap"
#define NSDB_PROTOCOLS   "protocols"
#define NSDB_REMOTE   "remote"
#define NSDB_RPC   "rpc"
#define NSDB_SENDMAILVARS   "sendmailvars"
#define NSDB_SERVICES   "services"
#define NSDB_TERMCAP   "termcap"
#define NSDB_TTYS   "ttys"
// Macros to help build an ns_dtab[]
#define NS_FILES_CB(F, C)   { NSSRC_FILES,  F,  __UNCONST(C) },
#define NS_COMPAT_CB(F, C)   { NSSRC_COMPAT, F,  __UNCONST(C) },
#ifdef HESIOD
#   define NS_DNS_CB(F, C)   { NSSRC_DNS,  F,  __UNCONST(C) },
#else
#   define NS_DNS_CB(F, C)
#endif
#ifdef YP
#   define NS_NIS_CB(F, C)   { NSSRC_NIS,  F,  __UNCONST(C) },
#else
#   define NS_NIS_CB(F, C)
#endif
#define NS_NULL_CB   { .src = NULL },


/** Actions performed after lookup finished */
typedef enum lookup_actions { NSS_ACTION_CONTINUE, NSS_ACTION_RETURN }   lookup_actions;


typedef struct service_library {
	const char* name;  // Name of service (files, dns, nis, etc.)
	void* lib_handle;  // Pointer to the loaded shared library
	struct service_library* next;  // Link to the next entry
} service_library;


/** ns_dtab `callback` function */
typedef int (*nss_method)(void*, void*, va_list);


/** nsswitch dispatch table; Contains an entry for each source and the appropriate function to call */
typedef struct ns_dtab {
	const char* src;
	nss_method callback;
	void* cb_data;
} ns_dtab;


/** nsswitch source; Used by the nsparser routines to store a mapping between a source and its dispatch control flags for a given database */
typedef struct attr_packed __ns_src {
	const char* name;
	uint32_t flags;
} ns_src;


// Default sourcelists (if nsswitch.conf is missing, corrupt, or if the requested database does not have an entry)
// static UNUSED ns_src __nsdefaultsrc[];
// static UNUSED ns_src __nsdefaultcompat[];
// static UNUSED ns_src __nsdefaultcompat_forceall[];
// static UNUSED ns_src __nsdefaultfiles[];
// static UNUSED ns_src __nsdefaultfiles_forceall[];
// static UNUSED ns_src __nsdefaultnis[];
// static UNUSED ns_src __nsdefaultnis_forceall[];


/** nsswitch method table; An nsswitch module provides a mapping from (database name, method name) tuples to the nss_method and associated callback data */
typedef struct ns_mtab {
	const char* database;
	const char* name;
	nss_method method;
	void* mdata;
} ns_mtab;


/** Module un-registration function called at module unload */
typedef void (*nss_module_unregister_fn)(ns_mtab*, unsigned int);


/** Module registration function called at module load */
typedef ns_mtab *(*nss_module_register_fn)(const char*, unsigned int*, nss_module_unregister_fn*);


/** For each database in /etc/nsswitch.conf there is a ns_dbt, with its name and a list of ns_src's containing the source information */
typedef struct attr_packed ns_dbt {
	const char* name;  // Name of database
	ns_src* srclist;  // List of sources
	unsigned int srclistsize;  // Size of srclist
} ns_dbt;


/** nsswitch module */
typedef struct attr_packed ns_mod {
	const char* name;  // module name
	void* handle;  // Handle from dlopen()
	ns_mtab* mtab;  // Method table
	unsigned int mtabsize;  // size of mtab
	nss_module_unregister_fn unregister;  // Called to unload module
} ns_mod;


/** Datatype for mapping a function name to a function pointer */
typedef struct known_function {
	const char* fct_name;
	void* fct_ptr;
} known_function;


typedef int (*lookup_function)(const char*, struct etherent*, char*, int, int*);


typedef struct attr_packed service_user {
	struct service_user* next;
	lookup_actions actions[5];
	service_library* library;
	struct entry* known;
	char* name;
} service_user;


/* TODO: Add nsswitch.h functions
int nsdispatch(void*, const ns_dtab[], const char*, const char*, const ns_src[], ...);
int _nsdbtaddsrc(ns_dbt*, const ns_src*);
void _nsdbtdump(const ns_dbt*);
int _nsdbtput(const ns_dbt*);
void _nsyyerror(const char*);
int _nsyylex(void);
*/


#endif  // NSSWITCH_H


/* <netinet/ether.h> */


#if (!(defined(NETINET_ETHER_H) || defined(_NETINET_ETHER_H) || defined(_NETINET_ETHER_H_)))
#define NETINET_ETHER_H   (1)
#define _NETINET_ETHER_H   (1)
#define _NETINET_ETHER_H_   (1)


#ifndef ETHER_LINE_LEN
#   define ETHER_LINE_LEN   256
#endif


LIB_FUNC struct ether_addr* ether_aton_r(const char* asc, struct ether_addr* addr) {
	register size_t cnt = 0;
	register unsigned int number;
	register char ch;
	for (; cnt < 6; ++cnt) {
		ch = (char)_tolower(*asc++);
		if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) { return NULL; }
		number = (unsigned int)((isdigit(ch)) ? (ch - '0') : (ch - 'a' + 10));
		ch = (char)_tolower(*asc);
		if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\0' && !isspace(ch))) {
			++asc;
			if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f')) { return NULL; }
			number <<= 4;
			number += (unsigned int)(isdigit(ch) ? (ch - '0') : (ch - 'a' + 10));
			ch = *asc;
			if (cnt < 5 && ch != ':') { return NULL; }
		}
		addr->ether_addr_octet[cnt] = (unsigned char)number;
		++asc;
	}
	return addr;
}


LIB_FUNC struct ether_addr* ether_aton(const char* asc) {
	static struct ether_addr result;
	return ether_aton_r(asc, &result);
}


/** Returns a pointer to the part of the line with the start of the hostname, or NULL if it could not parse the line */
LIB_FUNC const char* __ether_line(const char* line, struct ether_addr* addr) {
	struct ether_addr* res = ether_aton_r(line, addr);
	if (!res) { return NULL; }
	while (*line && (*line != ' ') && (*line != '\t')) { line++; }
	while (*line && ((*line == ' ')	|| (*line == '\t'))) { line++; }
	return ((*line) ? line : NULL);
}


/** Strips out the comment before calling __ether_line */
LIB_FUNC const char* __ether_line_w(char* line, struct ether_addr* addr) {
	const char* end = strchr(line, '#');
	if (!end) { end = strchr(line, '\n'); }
	// if (end) { *end = '\0'; }
	return __ether_line(line, addr);
}


LIB_FUNC int ether_line(const char* line, struct ether_addr* addr, char* hostname) {
	const char* name = __ether_line(line, addr);
	if (!name) { return -1; }
	while (*name) {
		if ((*name == '#') || isspace(*name)) { break; }
		*hostname++ = *name++;
	}
	*hostname = '\0';
	return 0;
}


LIB_FUNC char* ether_ntoa_r(const struct ether_addr* addr, char* buf) {
	sprintf(buf, "%x:%x:%x:%x:%x:%x", addr->ether_addr_octet[0], addr->ether_addr_octet[1], addr->ether_addr_octet[2], addr->ether_addr_octet[3], addr->ether_addr_octet[4], addr->ether_addr_octet[5]);
	return buf;
}


LIB_FUNC char* ether_ntoa(const struct ether_addr* addr) {
	static char asc[18] = { 0 };
	return ether_ntoa_r(addr, asc);
}


LIB_FUNC int ether_ntohost(char* hostname, const struct ether_addr* addr) {
	int res = -1;
	FILE* fp = fopen(ETHER_FILE_NAME, "r");
	if (!fp) { return -1; }
	char buf[ETHER_LINE_LEN] = { 0 };
	while (fgets(buf, ETHER_LINE_LEN, fp)) {
		struct ether_addr tmp_addr;
		const char* cp = __ether_line_w(buf, &tmp_addr);
		if (!cp) { continue; }
		else if (memcmp(addr, &tmp_addr, sizeof(tmp_addr))) { continue; }
		strcpy_no_output(hostname, cp);
		res = 0;
		break;
	}
	fclose(fp);
	return res;
}


LIB_FUNC int ether_hostton(const char* hostname, struct ether_addr* addr) {
	int res = -1;
	FILE* fp = fopen(ETHER_FILE_NAME, "r");
	if (!fp) { return -1; }
	char buf[ETHER_LINE_LEN] = { 0 };
	while (fgets(buf, ETHER_LINE_LEN, fp)) {
		const char* cp = __ether_line_w(buf, addr);
		if (!cp) { continue; }
		else if (strcasecmp(hostname, cp)) { continue; }
		res = 0;
		break;
	}
	fclose(fp);
	return res;
}


#endif  // NETINET_ETHER_H


/* NSCD (<nscd/nscd_proto.h>) */


#if (!(defined(_NSCD_PROTO_H) || defined(_NSCD_PROTO_H_)))
#define NSCD_PROTO_H   (1)
#define _NSCD_PROTO_H   (1)
#define _NSCD_PROTO_H_   (1)


/** Interval in which we transfer retry to contact the NSCD */
#define NSS_NSCD_RETRY   100
// Variables for communication between NSCD handler functions and NSS
// static UNUSED int __nss_not_use_nscd_passwd;
// static UNUSED int __nss_not_use_nscd_group;
// static UNUSED int __nss_not_use_nscd_hosts;
// static UNUSED int __nss_not_use_nscd_services;
// static UNUSED int __nss_not_use_nscd_netgroup;


/* TODO: Add nscd_proto.h functions
struct nscd_ai_result;
static int __nscd_getpwnam_r (const char *name, struct passwd *resultbuf, char *buffer, size_t buflen, struct passwd **result);
static int __nscd_getpwuid_r (uid_t uid, struct passwd *resultbuf, char *buffer,  size_t buflen, struct passwd **result);
static int __nscd_getgrnam_r (const char *name, struct group *resultbuf, char *buffer, size_t buflen, struct group **result);
static int __nscd_getgrgid_r (gid_t gid, struct group *resultbuf, char *buffer,  size_t buflen, struct group **result);
static int __nscd_gethostbyname_r (const char *name, struct hostent *resultbuf, char *buffer, size_t buflen, struct hostent **result, int *h_errnop);
static int __nscd_gethostbyname2_r (const char *name, int af, struct hostent *resultbuf, char *buffer, size_t buflen, struct hostent **result, int *h_errnop);
static int __nscd_gethostbyaddr_r (const void *addr, socklen_t len, int type, struct hostent *resultbuf, char *buffer, size_t buflen, struct hostent **result, int *h_errnop);
static int __nscd_getai (const char *key, struct nscd_ai_result **result, int *h_errnop);
static int __nscd_getgrouplist (const char *user, gid_t group, long *size, gid_t **groupsp, long limit);
static int __nscd_getservbyname_r (const char *name, const char *proto, struct servent *result_buf, char *buf, size_t buflen, struct servent **result);
static int __nscd_getservbyport_r (int port, const char *proto, struct servent *result_buf, char *buf, size_t buflen, struct servent **result);
static int __nscd_innetgr (const char *netgroup, const char *host, const char *user, const char *domain);
static int __nscd_setnetgrent (const char *group, struct __netgrent *datap);
*/


#endif  // NSCD_PROTO_H


/* MD4 (<md4.h>) */


#if (!(defined(_MD4_H) || defined(_MD4_H_) || defined(_SYS_MD4_H) || defined(_SYS_MD4_H_)))
#define _MD4_H   (1)
#define _MD4_H_   (1)
#define _SYS_MD4_H   (1)
#define _SYS_MD4_H_   (1)


/** MD4 context */
typedef struct MD4Context {
	uint32_t state[4];  // State (ABCD)
	uint32_t count[2];  // Number of bits, modulo 2^64 (lsb first)
	unsigned char buffer[64];  // Input buffer
} MD4_CTX;


/* TODO: Add MD4 functions
void MD4Init(MD4_CTX *);
void MD4Update(MD4_CTX *, const unsigned char *, unsigned int);
void MD4Pad(MD4_CTX *);
void MD4Final(unsigned char [16], MD4_CTX *);
char* MD4End(MD4_CTX *, char *);
char* MD4File(const char *, char *);
char* MD4Data(const unsigned char *, unsigned int, char *);
*/


#endif  // MD4_H


/* MD5 (<md5.h>) */


#if (!(defined(_SYS_MD5_H) || defined(_SYS_MD5_H_) || defined(_MD5_H) || defined(_MD5_H_)))
#define _MD5_H   (1)
#define _MD5_H_   (1)
#define _SYS_MD5_H   (1)
#define _SYS_MD5_H_   (1)


#define MD5_BLOCK_LENGTH   64
#define MD5_DIGEST_LENGTH   16
#define MD5_DIGEST_STRING_LENGTH   ((MD5_DIGEST_LENGTH * 2) + 1)


/** MD5 context */
typedef struct MD5Context {
	uint32_t state[4];  // State (ABCD)
	uint32_t count[2];  // Number of bits, modulo 2^64 (lsb first)
	unsigned char buffer[64];  // Input buffer
} MD5_CTX;


typedef int16_t   md5_int16;
#define md5_int16_t   md5_int16
typedef uint16_t   md5_uint16;
#define md5_uint16_t   md5_uint16
typedef int32_t   md5_int32;
#define md5_int32_t   md5_int32
typedef uint32_t   md5_uint32;
#define md5_uint32_t   md5_uint32
typedef intptr_t   md5_intptr;
typedef uintptr_t   md5_uintptr;
/** Structure to save state of computation between the single steps */
typedef struct md5_ctx {
	md5_uint32 A, B, C, D;
	md5_uint32 total[2];
	md5_uint32 buflen;
	char ATTR_ALIGNED_ALIGNOF(md5_uint32) buffer[128];
} md5_ctx_t;


/* TODO: Add MD5 Functions
void MD5Init (MD5_CTX *);
extern void md5_init_ctx(struct md5_ctx *ctx);
void MD5Update (MD5_CTX *, const unsigned char *, unsigned int);
void MD5Final (unsigned char [16], MD5_CTX *);
char* MD5End(MD5_CTX *, char *);
char* MD5File(const char *, char *);
char* MD5FileChunk(const char *, char *, off_t, off_t);
char* MD5Data(const unsigned char *, unsigned int, char *);
extern void md5_process_block(const void *buffer, size_t len, struct md5_ctx *ctx);
extern void md5_process_bytes(const void *buffer, size_t len, struct md5_ctx *ctx);
extern void *md5_finish_ctx(struct md5_ctx *ctx, void *resbuf);
extern void *md5_read_ctx(const struct md5_ctx *ctx, void *resbuf);
extern int md5_stream(FILE *stream, void *resblock);
extern void *md5_buffer(const char *buffer, size_t len, void *resblock);
*/


#endif  // SYS_MD5_H


/* PHYSICS (<physics.h>) */


#if (!(defined(PHYSICS_H) || defined(_PHYSICS_H_) || defined(_PHYSICS_H)))
#define PHYSICS_H   (1)
#define _PHYSICS_H_   (1)
#define _PHYSICS_H   (1)


/** Earth's Atmospheric Pressure (kPa) */
#define ATMOSPHERIC_PRESSURE   (double)101.0;
/** Earth's Atmospheric Pressure (kPa) */
#define ATMOSPHERIC_PRESSUREl   (long double)101.0L;
/** Earth's Escape Velocity (m/s) */
#define ESCAPE_VELOCITY   (double)8000000.0;
/** Earth's Escape Velocity (m/s) */
#define ESCAPE_VELOCITYl   (long double)8000000.0L;
/** Earth's Gravitational Constant (m/s2) */
#define G   (double)9.8;
/** Earth's Gravitational Constant (m/s2) */
#define Gl   (long double)9.8L;


/** Return density given mass and volume

	@param[in] mass
	@param[in] volume
	@returns Density
*/
#define density(mass, volume)   (mass / volume)


/** Return pressure given force and area

	@param[in] force
	@param[in] area    Area of the acting force
	@returns Pressure
*/
#define pressure(force, area)   (force / area)


/** Return distance given speed and time

	@param[in] speed
	@param[in] time
	@returns Distance
*/
#define distance(speed, time)   (speed * time)


/** Return speed/velocity given the distance and time

	@param[in] distance
	@param[in] time
	@returns Speed
*/
#define speed(distance, time)   (distance / time)


/** Return the acceleration given time and change in velocity

	@param[in] velocity_change
	@param[in] time
	@returns Acceleration
*/
#define acceleration_given_velocity(velocity_change, time)   (velocity_change / time)


/** Return the acceleration given force and mass

	@param[in] force
	@param[in] mass
	@returns Acceleration
*/
#define acceleration_given_force(force, mass)   (force / mass)


/** Return momentum given mass and velocity

	@param[in] mass
	@param[in] velocity    Amount of directional speed of the mass
	@returns Momentum
*/
#define momentum(mass, velocity)   (mass * velocity)


/** Return the force given mass and acceleration

	@param[in] mass
	@param[in] acceleration    Amount of acceleration of the mass
	@returns Force
*/
#define force(mass, acceleration)   (mass * acceleration)


/** Return impulse given force and time

	@param[in] force
	@param[in] time    Amount of time the force was exerted
	@returns Impulse
*/
#define impulse(force, time)   (force * time)


/** Return impulse given velocity and a change in mass

	@param[in] mass
	@param[in] velocity
	@returns Impulse
*/
#define impulse_given_mass_velocity(mass, velocity)   (mass * velocity)


/** Return work given force and distance

	@param[in] force
	@param[in] distance    Amount of distance the force was exerted
	@returns Work exerted
*/
#define work(force, distance)   (force * distance)


/** Return power given force, distance, and time

	@param[in] force
	@param[in] distance    Amount of distance the force was exerted
	@param[in] time    Amount of time the force was exerted
	@returns Power (Watts)
*/
#define power(force, distance, time)   ((force * distance) / time)


/** Return power given work and time

	@param[in] work    Work (Newtons)
	@param[in] time    Amount of time the work was exerted
	@returns Power (Watts)
*/
#define power_given_work_time(work, time)   (work / time)


/** Return the kinetic-energy given mass and velocity

	@param[in] mass    Mass of some object
	@param[in] velocity    Velocity of the object
	@returns Kinetic energy of an object at a given velocity and mass
*/
#define kinetic_energy(mass, velocity)   (0.500 * mass * velocity * velocity)


/** Return potential-energy given mass (kg) and height (meters) of an object on Earth

	@param[in] mass_kg    Mass of some object
	@param[in] height_meters    height from some surface
	@returns Potential energy of an object on Earth at a given height and mass
*/
#define potential_energy(mass_kg, height_meters)   (mass_kg * G * height_meters)


/** Return gravitational intensity given distance

	@param[in] distance    Distance between two objects
	@returns Gravitational intensity at the given distance
*/
#define gravitational_intensity(distance)   (1.0 / (distance * distance))


/** Return instantaneous speed given acceleration and time

	@param[in] acceleration    Acceleration at the given time
	@param[in] time    Time of the given instance
	@returns Speed at the given time and acceleration
*/
#define instantaneous_speed(acceleration, time)   (acceleration * time)


/** Return the freefall velocity given time (seconds)

	@param[in] time_sec    Time since falling
	@returns Free-fall velocity at the given time
*/
#define freefall_velocity(time_sec)   (G * time_sec)


/** Return distance fallen during freefall given time (seconds)

	@param[in] time_sec    Time since falling
	@returns Distance fallen at the given time
*/
#define freefall_distance(time_sec)   (0.500 * G * time_sec * time_sec)


#endif  // PHYSICS_H


#ifdef COMPILER_CLANG
#   pragma clang diagnostic error "-Wshadow"
#   pragma clang diagnostic error "-Wunused-function"
#elif defined(COMPILER_GNUC)
#   pragma GCC diagnostic error "-Wshadow"
#   pragma GCC diagnostic error "-Wunused-function"
#endif
